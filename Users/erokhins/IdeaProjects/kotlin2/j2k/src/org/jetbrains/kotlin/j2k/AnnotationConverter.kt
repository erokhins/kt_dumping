'+' @ [31:53] ==> public operator fun <T> Collection<(String..String?)>.plus(elements: Iterable<(String..String?)>): List<(String..String?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.String..kotlin.String?)

'getInstance' @ [31:76] ==> public open fun getInstance(p0: (Project..Project?)): (NullableNotNullManager..NullableNotNullManager?) defined in com.intellij.codeInsight.NullableNotNullManager[JavaMethodDescriptor]

'converter' @ [31:88] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.AnnotationConverter[PropertyDescriptorImpl]

'project' @ [31:98] ==> public final val project: Project defined in org.jetbrains.kotlin.j2k.Converter[PropertyDescriptorImpl]

'notNulls' @ [31:107] ==> public final val NullableNotNullManager.notNulls: (MutableList<(String..String?)>..List<(String..String?)>)[MyPropertyDescriptor]

'getInstance' @ [32:78] ==> public open fun getInstance(p0: (Project..Project?)): (NullableNotNullManager..NullableNotNullManager?) defined in com.intellij.codeInsight.NullableNotNullManager[JavaMethodDescriptor]

'converter' @ [32:90] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.AnnotationConverter[PropertyDescriptorImpl]

'project' @ [32:100] ==> public final val project: Project defined in org.jetbrains.kotlin.j2k.Converter[PropertyDescriptorImpl]

'nullables' @ [32:109] ==> public final val NullableNotNullManager.nullables: (MutableList<(String..String?)>..List<(String..String?)>)[MyPropertyDescriptor]

'listOf' @ [33:55] ==> public fun <T> listOf(vararg elements: (String..String?)): List<(String..String?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.String..kotlin.String?)

'JAVA_LANG_OVERRIDE' @ [33:79] ==> @NonNls public const final val JAVA_LANG_OVERRIDE: String defined in com.intellij.psi.CommonClassNames[JavaPropertyDescriptor]

'ElementType' @ [33:99] ==> private constructor ElementType() defined in java.lang.annotation.ElementType[JavaClassConstructorDescriptor]

'java' @ [33:118] ==> public val <T> KClass<ElementType>.java: Class<ElementType> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> ElementType

'name' @ [33:123] ==> public final val <T : (Any..Any?)> Class<ElementType>.name: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> ElementType

'SuppressWarnings' @ [33:129] ==> public constructor SuppressWarnings(vararg value: String) defined in java.lang.SuppressWarnings[JavaClassConstructorDescriptor]

'java' @ [33:153] ==> public val <T> KClass<SuppressWarnings>.java: Class<SuppressWarnings> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> SuppressWarnings

'name' @ [33:158] ==> public final val <T : (Any..Any?)> Class<SuppressWarnings>.name: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> SuppressWarnings

'toSet' @ [33:165] ==> public fun <T> Iterable<(String..String?)>.toSet(): Set<(String..String?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.String..kotlin.String?)

'fqName' @ [36:28] ==> value-parameter fqName: FqName defined in org.jetbrains.kotlin.j2k.AnnotationConverter.isImportNotRequired[ValueParameterDescriptorImpl]

'asString' @ [36:35] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'nameAsString' @ [37:16] ==> val nameAsString: String defined in org.jetbrains.kotlin.j2k.AnnotationConverter.isImportNotRequired[LocalVariableDescriptor]

'annotationsToRemove' @ [37:32] ==> private final val annotationsToRemove: Set<String> defined in org.jetbrains.kotlin.j2k.AnnotationConverter[PropertyDescriptorImpl]

'nameAsString' @ [37:55] ==> val nameAsString: String defined in org.jetbrains.kotlin.j2k.AnnotationConverter.isImportNotRequired[LocalVariableDescriptor]

'Target' @ [37:71] ==> public constructor Target(vararg value: ElementType) defined in java.lang.annotation.Target[JavaClassConstructorDescriptor]

'java' @ [37:85] ==> public val <T> KClass<Target>.java: Class<Target> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> Target

'name' @ [37:90] ==> public final val <T : (Any..Any?)> Class<Target>.name: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Target

'convertAnnotationsOnly' @ [41:15] ==> private final fun convertAnnotationsOnly(owner: PsiModifierListOwner, target: AnnotationUseTarget?): Annotations defined in org.jetbrains.kotlin.j2k.AnnotationConverter[SimpleFunctionDescriptorImpl]

'owner' @ [41:38] ==> value-parameter owner: PsiModifierListOwner defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotations[ValueParameterDescriptorImpl]

'target' @ [41:45] ==> value-parameter target: AnnotationUseTarget? = ... defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotations[ValueParameterDescriptorImpl]

'convertModifiersToAnnotations' @ [41:55] ==> private final fun convertModifiersToAnnotations(owner: PsiModifierListOwner, target: AnnotationUseTarget?): Annotations defined in org.jetbrains.kotlin.j2k.AnnotationConverter[SimpleFunctionDescriptorImpl]

'owner' @ [41:85] ==> value-parameter owner: PsiModifierListOwner defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotations[ValueParameterDescriptorImpl]

'target' @ [41:92] ==> value-parameter target: AnnotationUseTarget? = ... defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotations[ValueParameterDescriptorImpl]

'owner' @ [44:28] ==> value-parameter owner: PsiModifierListOwner defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[ValueParameterDescriptorImpl]

'modifierList' @ [44:34] ==> public final val PsiModifierListOwner.modifierList: PsiModifierList?[MyPropertyDescriptor]

'modifierList' @ [45:27] ==> val modifierList: PsiModifierList? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[LocalVariableDescriptor]

'annotations' @ [45:41] ==> public final val PsiModifierList.annotations: (Array<(PsiAnnotation..PsiAnnotation?)>..Array<out (PsiAnnotation..PsiAnnotation?)>)[MyPropertyDescriptor]

'filter' @ [45:54] ==> public inline fun <T> Array<out (PsiAnnotation..PsiAnnotation?)>.filter(predicate: ((PsiAnnotation..PsiAnnotation?)) -> Boolean): List<(PsiAnnotation..PsiAnnotation?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiAnnotation..com.intellij.psi.PsiAnnotation?)

'it' @ [45:63] ==> value-parameter it: (PsiAnnotation..PsiAnnotation?) defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly.<anonymous>[ValueParameterDescriptorImpl]

'qualifiedName' @ [45:66] ==> public final val PsiAnnotation.qualifiedName: String?[MyPropertyDescriptor]

'annotationsToRemove' @ [45:84] ==> private final val annotationsToRemove: Set<String> defined in org.jetbrains.kotlin.j2k.AnnotationConverter[PropertyDescriptorImpl]

'if (annotations != null && annotations.isNotEmpty()) {
            val newLines = if (!modifierList.isInSingleLine()) {
                true
            }
            else {
                var child: PsiElement? = modifierList
                while (true) {
                    child = child!!.nextSibling
                    if (child == null || child.textLength != 0) break
                }
                if (child is PsiWhiteSpace) !child.isInSingleLine() else false
            }

            annotations.mapNotNull { convertAnnotation(it, newLineAfter = newLines, target = target) }
        }
        else {
            listOf()
        }' @ [47:54] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<Annotation>, elseBranch: List<Annotation>): List<Annotation>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<Annotation>

'annotations' @ [47:58] ==> val annotations: List<(PsiAnnotation..PsiAnnotation?)>? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[LocalVariableDescriptor]

'annotations' @ [47:81] ==> val annotations: List<(PsiAnnotation..PsiAnnotation?)>? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[LocalVariableDescriptor]

'isNotEmpty' @ [47:93] ==> @InlineOnly public inline fun <T> Collection<(PsiAnnotation..PsiAnnotation?)>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiAnnotation..com.intellij.psi.PsiAnnotation?)

'if (!modifierList.isInSingleLine()) {
                true
            }
            else {
                var child: PsiElement? = modifierList
                while (true) {
                    child = child!!.nextSibling
                    if (child == null || child.textLength != 0) break
                }
                if (child is PsiWhiteSpace) !child.isInSingleLine() else false
            }' @ [48:28] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Boolean, elseBranch: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Boolean

'!' @ [48:32] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'modifierList' @ [48:33] ==> val modifierList: PsiModifierList? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[LocalVariableDescriptor]

'isInSingleLine' @ [48:46] ==> public fun PsiElement.isInSingleLine(): Boolean defined in org.jetbrains.kotlin.j2k in file Utils.kt[SimpleFunctionDescriptorImpl]

'modifierList' @ [52:42] ==> val modifierList: PsiModifierList? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[LocalVariableDescriptor]

'child' @ [54:21] ==> var child: PsiElement? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[LocalVariableDescriptor]

'child' @ [54:29] ==> var child: PsiElement? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[LocalVariableDescriptor]

'nextSibling' @ [54:37] ==> public final val PsiElement.nextSibling: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'child' @ [55:25] ==> var child: PsiElement? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[LocalVariableDescriptor]

'child' @ [55:42] ==> var child: PsiElement? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[LocalVariableDescriptor]

'textLength' @ [55:48] ==> public final val PsiElement.textLength: Int[MyPropertyDescriptor]

'if (child is PsiWhiteSpace) !child.isInSingleLine() else false' @ [57:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Boolean, elseBranch: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Boolean

'child' @ [57:21] ==> var child: PsiElement? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[LocalVariableDescriptor]

'!' @ [57:45] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'child' @ [57:46] ==> var child: PsiElement? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[LocalVariableDescriptor]

'isInSingleLine' @ [57:52] ==> public fun PsiElement.isInSingleLine(): Boolean defined in org.jetbrains.kotlin.j2k in file Utils.kt[SimpleFunctionDescriptorImpl]

'annotations' @ [60:13] ==> val annotations: List<(PsiAnnotation..PsiAnnotation?)>? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[LocalVariableDescriptor]

'mapNotNull' @ [60:25] ==> public inline fun <T, R : Any> Iterable<(PsiAnnotation..PsiAnnotation?)>.mapNotNull(transform: ((PsiAnnotation..PsiAnnotation?)) -> Annotation?): List<Annotation> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiAnnotation..com.intellij.psi.PsiAnnotation?)
    <R : Any> -> Annotation

'convertAnnotation' @ [60:38] ==> public final fun convertAnnotation(annotation: PsiAnnotation, newLineAfter: Boolean, target: AnnotationUseTarget? = ...): Annotation? defined in org.jetbrains.kotlin.j2k.AnnotationConverter[SimpleFunctionDescriptorImpl]

'it' @ [60:56] ==> value-parameter it: (PsiAnnotation..PsiAnnotation?) defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly.<anonymous>[ValueParameterDescriptorImpl]

'newLines' @ [60:75] ==> val newLines: Boolean defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[LocalVariableDescriptor]

'target' @ [60:94] ==> value-parameter target: AnnotationUseTarget? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[ValueParameterDescriptorImpl]

'listOf' @ [63:13] ==> @InlineOnly public inline fun <T> listOf(): List<Annotation> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Annotation

'owner' @ [66:13] ==> value-parameter owner: PsiModifierListOwner defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[ValueParameterDescriptorImpl]

'convertDeprecatedJavadocTag' @ [67:40] ==> private final fun convertDeprecatedJavadocTag(element: PsiDocCommentOwner, target: AnnotationUseTarget?): Annotation? defined in org.jetbrains.kotlin.j2k.AnnotationConverter[SimpleFunctionDescriptorImpl]

'owner' @ [67:68] ==> value-parameter owner: PsiModifierListOwner defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[ValueParameterDescriptorImpl]

'target' @ [67:75] ==> value-parameter target: AnnotationUseTarget? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[ValueParameterDescriptorImpl]

'deprecatedAnnotation' @ [68:17] ==> val deprecatedAnnotation: Annotation? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[LocalVariableDescriptor]

'convertedAnnotations' @ [69:17] ==> var convertedAnnotations: List<Annotation> defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[LocalVariableDescriptor]

'convertedAnnotations' @ [69:40] ==> var convertedAnnotations: List<Annotation> defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[LocalVariableDescriptor]

'filter' @ [69:61] ==> public inline fun <T> Iterable<Annotation>.filter(predicate: (Annotation) -> Boolean): List<Annotation> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Annotation

'it' @ [69:70] ==> value-parameter it: Annotation defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [69:73] ==> public final val name: Identifier defined in org.jetbrains.kotlin.j2k.ast.Annotation[PropertyDescriptorImpl]

'name' @ [69:78] ==> public final val name: String defined in org.jetbrains.kotlin.j2k.ast.Identifier[PropertyDescriptorImpl]

'deprecatedAnnotation' @ [69:86] ==> val deprecatedAnnotation: Annotation? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[LocalVariableDescriptor]

'name' @ [69:107] ==> public final val name: Identifier defined in org.jetbrains.kotlin.j2k.ast.Annotation[PropertyDescriptorImpl]

'name' @ [69:112] ==> public final val name: String defined in org.jetbrains.kotlin.j2k.ast.Identifier[PropertyDescriptorImpl]

'convertedAnnotations' @ [70:17] ==> var convertedAnnotations: List<Annotation> defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[LocalVariableDescriptor]

'deprecatedAnnotation' @ [70:41] ==> val deprecatedAnnotation: Annotation? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[LocalVariableDescriptor]

'Annotations' @ [74:16] ==> public constructor Annotations(annotations: List<Annotation>) defined in org.jetbrains.kotlin.j2k.ast.Annotations[ClassConstructorDescriptorImpl]

'convertedAnnotations' @ [74:28] ==> var convertedAnnotations: List<Annotation> defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationsOnly[LocalVariableDescriptor]

'assignNoPrototype' @ [74:50] ==> public fun <TElement : Element> Annotations.assignNoPrototype(): Annotations defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Annotations

'element' @ [78:29] ==> value-parameter element: PsiDocCommentOwner defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertDeprecatedJavadocTag[ValueParameterDescriptorImpl]

'docComment' @ [78:37] ==> public final val PsiDocCommentOwner.docComment: PsiDocComment?[MyPropertyDescriptor]

'findTagByName' @ [78:49] ==> @Nullable public abstract fun findTagByName(@NonNls p0: (String..String?)): PsiDocTag? defined in com.intellij.psi.javadoc.PsiDocComment[JavaMethodDescriptor]

'converter' @ [79:34] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.AnnotationConverter[PropertyDescriptorImpl]

'deferredElement' @ [79:44] ==> public final fun <TResult : Element> deferredElement(generator: (CodeConverter) -> Expression): DeferredElement<Expression> defined in org.jetbrains.kotlin.j2k.Converter[SimpleFunctionDescriptorImpl]
Inferred types:
    <TResult : Element> -> Expression

'LiteralExpression' @ [80:13] ==> public constructor LiteralExpression(literalText: String) defined in org.jetbrains.kotlin.j2k.ast.LiteralExpression[ClassConstructorDescriptorImpl]

'+' @ [80:31] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'escapeStringCharacters' @ [80:49] ==> @NotNull @Contract public open fun escapeStringCharacters(@NotNull p0: String): String defined in com.intellij.openapi.util.text.StringUtil[JavaMethodDescriptor]

'deprecatedTag' @ [80:72] ==> val deprecatedTag: PsiDocTag defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertDeprecatedJavadocTag[LocalVariableDescriptor]

'content' @ [80:86] ==> public fun PsiDocTag.content(): String defined in org.jetbrains.kotlin.j2k in file DocCommentConverter.kt[SimpleFunctionDescriptorImpl]

'assignNoPrototype' @ [80:105] ==> public fun <TElement : Element> LiteralExpression.assignNoPrototype(): LiteralExpression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> LiteralExpression

'Identifier' @ [82:26] ==> public constructor Identifier(name: String, isNullable: Boolean = ..., quotingNeeded: Boolean = ..., imports: Collection<FqName> = ...) defined in org.jetbrains.kotlin.j2k.ast.Identifier[ClassConstructorDescriptorImpl]

'assignPrototype' @ [82:51] ==> public fun <TElement : Element> Identifier.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Identifier defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Identifier

'deprecatedTag' @ [82:67] ==> val deprecatedTag: PsiDocTag defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertDeprecatedJavadocTag[LocalVariableDescriptor]

'nameElement' @ [82:81] ==> public final val PsiDocTag.nameElement: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'Annotation' @ [83:16] ==> public constructor Annotation(name: Identifier, arguments: List<Pair<Identifier?, DeferredElement<Expression>>>, newLineAfter: Boolean, target: AnnotationUseTarget? = ...) defined in org.jetbrains.kotlin.j2k.ast.Annotation[ClassConstructorDescriptorImpl]

'identifier' @ [83:27] ==> val identifier: Identifier defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertDeprecatedJavadocTag[LocalVariableDescriptor]

'listOf' @ [84:27] ==> public fun <T> listOf(element: Pair<Nothing?, DeferredElement<Expression>>): List<Pair<Nothing?, DeferredElement<Expression>>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<Nothing?, DeferredElement<Expression>>

'to' @ [84:34] ==> public infix fun <A, B> Nothing?.to(that: DeferredElement<Expression>): Pair<Nothing?, DeferredElement<Expression>> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Nothing?
    <B> -> DeferredElement<Expression>

'deferredExpression' @ [84:42] ==> val deferredExpression: DeferredElement<Expression> defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertDeprecatedJavadocTag[LocalVariableDescriptor]

'effectiveAnnotationUseTarget' @ [86:27] ==> private final fun effectiveAnnotationUseTarget(name: String, target: AnnotationUseTarget?): AnnotationUseTarget? defined in org.jetbrains.kotlin.j2k.AnnotationConverter[SimpleFunctionDescriptorImpl]

'identifier' @ [86:56] ==> val identifier: Identifier defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertDeprecatedJavadocTag[LocalVariableDescriptor]

'name' @ [86:67] ==> public final val name: String defined in org.jetbrains.kotlin.j2k.ast.Identifier[PropertyDescriptorImpl]

'target' @ [86:73] ==> value-parameter target: AnnotationUseTarget? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertDeprecatedJavadocTag[ValueParameterDescriptorImpl]

'assignPrototype' @ [87:18] ==> public fun <TElement : Element> Annotation.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Annotation defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Annotation

'deprecatedTag' @ [87:34] ==> val deprecatedTag: PsiDocTag defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertDeprecatedJavadocTag[LocalVariableDescriptor]

'MODIFIER_TO_ANNOTATION' @ [91:20] ==> private final val MODIFIER_TO_ANNOTATION: List<Pair<String, String>> defined in org.jetbrains.kotlin.j2k.AnnotationConverter[PropertyDescriptorImpl]

'filter' @ [92:18] ==> public inline fun <T> Iterable<Pair<String, String>>.filter(predicate: (Pair<String, String>) -> Boolean): List<Pair<String, String>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<String, String>

'owner' @ [92:27] ==> value-parameter owner: PsiModifierListOwner defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertModifiersToAnnotations[ValueParameterDescriptorImpl]

'hasModifierProperty' @ [92:33] ==> public abstract fun hasModifierProperty(@PsiModifier.ModifierConstant @NonNls @NotNull p0: String): Boolean defined in com.intellij.psi.PsiModifierListOwner[JavaMethodDescriptor]

'it' @ [92:53] ==> value-parameter it: Pair<String, String> defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertModifiersToAnnotations.<anonymous>[ValueParameterDescriptorImpl]

'first' @ [92:56] ==> public final val first: String defined in kotlin.Pair[DeserializedPropertyDescriptor]

'map' @ [93:18] ==> public inline fun <T, R> Iterable<Pair<String, String>>.map(transform: (Pair<String, String>) -> Annotation): List<Annotation> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<String, String>
    <R> -> Annotation

'Annotation' @ [94:21] ==> public constructor Annotation(name: Identifier, arguments: List<Pair<Identifier?, DeferredElement<Expression>>>, newLineAfter: Boolean, target: AnnotationUseTarget? = ...) defined in org.jetbrains.kotlin.j2k.ast.Annotation[ClassConstructorDescriptorImpl]

'Identifier' @ [94:32] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.Identifier[FakeCallableDescriptorForObject]

'withNoPrototype' @ [94:43] ==> public final fun withNoPrototype(name: String, isNullable: Boolean = ..., quotingNeeded: Boolean = ..., imports: Collection<FqName> = ...): Identifier defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[SimpleFunctionDescriptorImpl]

'it' @ [94:59] ==> value-parameter it: Pair<String, String> defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertModifiersToAnnotations.<anonymous>[ValueParameterDescriptorImpl]

'second' @ [94:62] ==> public final val second: String defined in kotlin.Pair[DeserializedPropertyDescriptor]

'listOf' @ [95:32] ==> @InlineOnly public inline fun <T> listOf(): List<Pair<Identifier?, DeferredElement<Expression>>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<Identifier?, DeferredElement<Expression>>

'target' @ [97:41] ==> value-parameter target: AnnotationUseTarget? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertModifiersToAnnotations[ValueParameterDescriptorImpl]

'assignNoPrototype' @ [98:23] ==> public fun <TElement : Element> Annotation.assignNoPrototype(): Annotation defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Annotation

'Annotations' @ [100:16] ==> public constructor Annotations(annotations: List<Annotation>) defined in org.jetbrains.kotlin.j2k.ast.Annotations[ClassConstructorDescriptorImpl]

'list' @ [100:28] ==> val list: List<Annotation> defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertModifiersToAnnotations[LocalVariableDescriptor]

'assignNoPrototype' @ [100:34] ==> public fun <TElement : Element> Annotations.assignNoPrototype(): Annotations defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Annotations

'listOf' @ [103:42] ==> public fun <T> listOf(vararg elements: Pair<String, String>): List<Pair<String, String>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<String, String>

'to' @ [104:13] ==> public infix fun <A, B> String.to(that: String): Pair<String, String> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> String

'SYNCHRONIZED' @ [104:25] ==> public const final val SYNCHRONIZED: String defined in com.intellij.psi.PsiModifier[JavaPropertyDescriptor]

'to' @ [105:13] ==> public infix fun <A, B> String.to(that: String): Pair<String, String> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> String

'VOLATILE' @ [105:25] ==> public const final val VOLATILE: String defined in com.intellij.psi.PsiModifier[JavaPropertyDescriptor]

'to' @ [106:13] ==> public infix fun <A, B> String.to(that: String): Pair<String, String> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> String

'STRICTFP' @ [106:25] ==> public const final val STRICTFP: String defined in com.intellij.psi.PsiModifier[JavaPropertyDescriptor]

'to' @ [107:13] ==> public infix fun <A, B> String.to(that: String): Pair<String, String> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> String

'TRANSIENT' @ [107:25] ==> public const final val TRANSIENT: String defined in com.intellij.psi.PsiModifier[JavaPropertyDescriptor]

'expr' @ [111:16] ==> value-parameter expr: PsiReferenceExpression defined in org.jetbrains.kotlin.j2k.AnnotationConverter.mapTargetByName[ValueParameterDescriptorImpl]

'referenceName' @ [111:21] ==> public final val PsiReferenceExpression.referenceName: String?[MyPropertyDescriptor]

'let' @ [111:36] ==> @InlineOnly public inline fun <T, R> String.let(block: (String) -> Set<KotlinTarget>): Set<KotlinTarget> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String
    <R> -> Set<KotlinTarget>

'JavaAnnotationTargetMapper' @ [111:42] ==> public object JavaAnnotationTargetMapper defined in org.jetbrains.kotlin.load.java.components[FakeCallableDescriptorForObject]

'mapJavaTargetArgumentByName' @ [111:69] ==> public final fun mapJavaTargetArgumentByName(argumentName: String?): Set<KotlinTarget> defined in org.jetbrains.kotlin.load.java.components.JavaAnnotationTargetMapper[DeserializedSimpleFunctionDescriptor]

'it' @ [111:97] ==> value-parameter it: String defined in org.jetbrains.kotlin.j2k.AnnotationConverter.mapTargetByName.<anonymous>[ValueParameterDescriptorImpl]

'emptySet' @ [111:106] ==> public fun <T> emptySet(): Set<KotlinTarget> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'when {
                name == "Deprecated" &&
                (target == AnnotationUseTarget.Param || target == AnnotationUseTarget.Field) -> null
                else -> target
            }' @ [115:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: AnnotationUseTarget?, entry1: AnnotationUseTarget?): AnnotationUseTarget?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> AnnotationUseTarget?

'name' @ [116:17] ==> value-parameter name: String defined in org.jetbrains.kotlin.j2k.AnnotationConverter.effectiveAnnotationUseTarget[ValueParameterDescriptorImpl]

'target' @ [117:18] ==> value-parameter target: AnnotationUseTarget? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.effectiveAnnotationUseTarget[ValueParameterDescriptorImpl]

'Param' @ [117:48] ==> enum entry Param defined in org.jetbrains.kotlin.j2k.ast.AnnotationUseTarget[FakeCallableDescriptorForObject]

'target' @ [117:57] ==> value-parameter target: AnnotationUseTarget? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.effectiveAnnotationUseTarget[ValueParameterDescriptorImpl]

'Field' @ [117:87] ==> enum entry Field defined in org.jetbrains.kotlin.j2k.ast.AnnotationUseTarget[FakeCallableDescriptorForObject]

'target' @ [118:25] ==> value-parameter target: AnnotationUseTarget? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.effectiveAnnotationUseTarget[ValueParameterDescriptorImpl]

'component1' @ [122:14] ==> public final operator fun component1(): Identifier defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [122:20] ==> public final operator fun component2(): List<Pair<Identifier?, DeferredElement<Expression>>> defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'convertAnnotationValue' @ [122:33] ==> private final fun convertAnnotationValue(annotation: PsiAnnotation): Pair<Identifier, List<Pair<Identifier?, DeferredElement<Expression>>>>? defined in org.jetbrains.kotlin.j2k.AnnotationConverter[SimpleFunctionDescriptorImpl]

'annotation' @ [122:56] ==> value-parameter annotation: PsiAnnotation defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotation[ValueParameterDescriptorImpl]

'Annotation' @ [123:16] ==> public constructor Annotation(name: Identifier, arguments: List<Pair<Identifier?, DeferredElement<Expression>>>, newLineAfter: Boolean, target: AnnotationUseTarget? = ...) defined in org.jetbrains.kotlin.j2k.ast.Annotation[ClassConstructorDescriptorImpl]

'name' @ [123:27] ==> val name: Identifier defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotation[LocalVariableDescriptor]

'arguments' @ [123:33] ==> val arguments: List<Pair<Identifier?, DeferredElement<Expression>>> defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotation[LocalVariableDescriptor]

'newLineAfter' @ [123:44] ==> value-parameter newLineAfter: Boolean defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotation[ValueParameterDescriptorImpl]

'effectiveAnnotationUseTarget' @ [123:58] ==> private final fun effectiveAnnotationUseTarget(name: String, target: AnnotationUseTarget?): AnnotationUseTarget? defined in org.jetbrains.kotlin.j2k.AnnotationConverter[SimpleFunctionDescriptorImpl]

'name' @ [123:87] ==> val name: Identifier defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotation[LocalVariableDescriptor]

'name' @ [123:92] ==> public final val name: String defined in org.jetbrains.kotlin.j2k.ast.Identifier[PropertyDescriptorImpl]

'target' @ [123:98] ==> value-parameter target: AnnotationUseTarget? = ... defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotation[ValueParameterDescriptorImpl]

'assignPrototype' @ [123:107] ==> public fun <TElement : Element> Annotation.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Annotation defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Annotation

'annotation' @ [123:123] ==> value-parameter annotation: PsiAnnotation defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotation[ValueParameterDescriptorImpl]

'CommentsAndSpacesInheritance' @ [123:135] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.CommentsAndSpacesInheritance[FakeCallableDescriptorForObject]

'NO_SPACES' @ [123:164] ==> public final val NO_SPACES: CommentsAndSpacesInheritance defined in org.jetbrains.kotlin.j2k.ast.CommentsAndSpacesInheritance.Companion[PropertyDescriptorImpl]

'annotation' @ [127:29] ==> value-parameter annotation: PsiAnnotation defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue[ValueParameterDescriptorImpl]

'qualifiedName' @ [127:40] ==> public final val PsiAnnotation.qualifiedName: String?[MyPropertyDescriptor]

'qualifiedName' @ [128:13] ==> val qualifiedName: String? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue[LocalVariableDescriptor]

'JAVA_LANG_DEPRECATED' @ [128:47] ==> @NonNls public const final val JAVA_LANG_DEPRECATED: String defined in com.intellij.psi.CommonClassNames[JavaPropertyDescriptor]

'annotation' @ [128:71] ==> value-parameter annotation: PsiAnnotation defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue[ValueParameterDescriptorImpl]

'parameterList' @ [128:82] ==> public final val PsiAnnotation.parameterList: PsiAnnotationParameterList[MyPropertyDescriptor]

'attributes' @ [128:96] ==> public final val PsiAnnotationParameterList.attributes: (Array<(PsiNameValuePair..PsiNameValuePair?)>..Array<out (PsiNameValuePair..PsiNameValuePair?)>)[MyPropertyDescriptor]

'isEmpty' @ [128:107] ==> @InlineOnly public inline fun <T> Array<out (PsiNameValuePair..PsiNameValuePair?)>.isEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiNameValuePair..com.intellij.psi.PsiNameValuePair?)

'converter' @ [129:38] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.AnnotationConverter[PropertyDescriptorImpl]

'deferredElement' @ [129:48] ==> public final fun <TResult : Element> deferredElement(generator: (CodeConverter) -> Expression): DeferredElement<Expression> defined in org.jetbrains.kotlin.j2k.Converter[SimpleFunctionDescriptorImpl]
Inferred types:
    <TResult : Element> -> Expression

'LiteralExpression' @ [129:78] ==> public constructor LiteralExpression(literalText: String) defined in org.jetbrains.kotlin.j2k.ast.LiteralExpression[ClassConstructorDescriptorImpl]

'assignNoPrototype' @ [129:104] ==> public fun <TElement : Element> LiteralExpression.assignNoPrototype(): LiteralExpression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> LiteralExpression

'Identifier' @ [130:20] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.Identifier[FakeCallableDescriptorForObject]

'withNoPrototype' @ [130:31] ==> public final fun withNoPrototype(name: String, isNullable: Boolean = ..., quotingNeeded: Boolean = ..., imports: Collection<FqName> = ...): Identifier defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[SimpleFunctionDescriptorImpl]

'listOf' @ [130:64] ==> public fun <T> listOf(element: Pair<Nothing?, DeferredElement<Expression>>): List<Pair<Nothing?, DeferredElement<Expression>>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<Nothing?, DeferredElement<Expression>>

'to' @ [130:71] ==> public infix fun <A, B> Nothing?.to(that: DeferredElement<Expression>): Pair<Nothing?, DeferredElement<Expression>> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Nothing?
    <B> -> DeferredElement<Expression>

'deferredExpression' @ [130:79] ==> val deferredExpression: DeferredElement<Expression> defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue[LocalVariableDescriptor]

'qualifiedName' @ [132:13] ==> val qualifiedName: String? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue[LocalVariableDescriptor]

'JAVA_LANG_ANNOTATION_TARGET' @ [132:47] ==> @NonNls public const final val JAVA_LANG_ANNOTATION_TARGET: String defined in com.intellij.psi.CommonClassNames[JavaPropertyDescriptor]

'annotation' @ [133:30] ==> value-parameter annotation: PsiAnnotation defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue[ValueParameterDescriptorImpl]

'parameterList' @ [133:41] ==> public final val PsiAnnotation.parameterList: PsiAnnotationParameterList[MyPropertyDescriptor]

'attributes' @ [133:55] ==> public final val PsiAnnotationParameterList.attributes: (Array<(PsiNameValuePair..PsiNameValuePair?)>..Array<out (PsiNameValuePair..PsiNameValuePair?)>)[MyPropertyDescriptor]

'if (attributes.isEmpty()) {
                setOf()
            }
            else {
                val value = attributes[0].value
                when (value) {
                    is PsiArrayInitializerMemberValue -> value.initializers.filterIsInstance<PsiReferenceExpression>()
                            .flatMap { mapTargetByName(it) }
                            .toSet()
                    is PsiReferenceExpression -> mapTargetByName(value)
                    else -> setOf()
                }
            }' @ [134:48] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Set<KotlinTarget>, elseBranch: Set<KotlinTarget>): Set<KotlinTarget>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Set<KotlinTarget>

'attributes' @ [134:52] ==> val attributes: (Array<(PsiNameValuePair..PsiNameValuePair?)>..Array<out (PsiNameValuePair..PsiNameValuePair?)>) defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue[LocalVariableDescriptor]

'isEmpty' @ [134:63] ==> @InlineOnly public inline fun <T> Array<out (PsiNameValuePair..PsiNameValuePair?)>.isEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiNameValuePair..com.intellij.psi.PsiNameValuePair?)

'setOf' @ [135:17] ==> @InlineOnly public inline fun <T> setOf(): Set<KotlinTarget> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'attributes' @ [138:29] ==> val attributes: (Array<(PsiNameValuePair..PsiNameValuePair?)>..Array<out (PsiNameValuePair..PsiNameValuePair?)>) defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue[LocalVariableDescriptor]

'value' @ [138:43] ==> public final val PsiNameValuePair.value: PsiAnnotationMemberValue?[MyPropertyDescriptor]

'when (value) {
                    is PsiArrayInitializerMemberValue -> value.initializers.filterIsInstance<PsiReferenceExpression>()
                            .flatMap { mapTargetByName(it) }
                            .toSet()
                    is PsiReferenceExpression -> mapTargetByName(value)
                    else -> setOf()
                }' @ [139:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Set<KotlinTarget>, entry1: Set<KotlinTarget>, entry2: Set<KotlinTarget>): Set<KotlinTarget>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Set<KotlinTarget>

'value' @ [139:23] ==> val value: PsiAnnotationMemberValue? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue[LocalVariableDescriptor]

'value' @ [140:58] ==> val value: PsiAnnotationMemberValue? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue[LocalVariableDescriptor]

'initializers' @ [140:64] ==> public final val PsiArrayInitializerMemberValue.initializers: (Array<(PsiAnnotationMemberValue..PsiAnnotationMemberValue?)>..Array<out (PsiAnnotationMemberValue..PsiAnnotationMemberValue?)>)[MyPropertyDescriptor]

'filterIsInstance' @ [140:77] ==> public inline fun <reified R> Array<*>.filterIsInstance(): List<PsiReferenceExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified R> -> PsiReferenceExpression

'flatMap' @ [141:30] ==> public inline fun <T, R> Iterable<PsiReferenceExpression>.flatMap(transform: (PsiReferenceExpression) -> Iterable<KotlinTarget>): List<KotlinTarget> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiReferenceExpression
    <R> -> KotlinTarget

'mapTargetByName' @ [141:40] ==> private final fun mapTargetByName(expr: PsiReferenceExpression): Set<KotlinTarget> defined in org.jetbrains.kotlin.j2k.AnnotationConverter[SimpleFunctionDescriptorImpl]

'it' @ [141:56] ==> value-parameter it: PsiReferenceExpression defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue.<anonymous>[ValueParameterDescriptorImpl]

'toSet' @ [142:30] ==> public fun <T> Iterable<KotlinTarget>.toSet(): Set<KotlinTarget> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'mapTargetByName' @ [143:50] ==> private final fun mapTargetByName(expr: PsiReferenceExpression): Set<KotlinTarget> defined in org.jetbrains.kotlin.j2k.AnnotationConverter[SimpleFunctionDescriptorImpl]

'value' @ [143:66] ==> val value: PsiAnnotationMemberValue? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue[LocalVariableDescriptor]

'setOf' @ [144:29] ==> @InlineOnly public inline fun <T> setOf(): Set<KotlinTarget> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'arguments' @ [147:42] ==> val arguments: Set<KotlinTarget> defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue[LocalVariableDescriptor]

'map' @ [147:52] ==> public inline fun <T, R> Iterable<KotlinTarget>.map(transform: (KotlinTarget) -> Pair<Nothing?, DeferredElement<Expression>>): List<Pair<Nothing?, DeferredElement<Expression>>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget
    <R> -> Pair<Nothing?, DeferredElement<Expression>>

'it' @ [148:28] ==> value-parameter it: KotlinTarget defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [148:31] ==> public final val name: String defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[DeserializedPropertyDescriptor]

'to' @ [149:17] ==> public infix fun <A, B> Nothing?.to(that: DeferredElement<Expression>): Pair<Nothing?, DeferredElement<Expression>> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Nothing?
    <B> -> DeferredElement<Expression>

'converter' @ [149:25] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.AnnotationConverter[PropertyDescriptorImpl]

'deferredElement' @ [149:35] ==> public final fun <TResult : Element> deferredElement(generator: (CodeConverter) -> Expression): DeferredElement<Expression> defined in org.jetbrains.kotlin.j2k.Converter[SimpleFunctionDescriptorImpl]
Inferred types:
    <TResult : Element> -> Expression

'QualifiedExpression' @ [150:21] ==> public constructor QualifiedExpression(qualifier: Expression, identifier: Expression, dotPrototype: PsiElement?) defined in org.jetbrains.kotlin.j2k.ast.QualifiedExpression[ClassConstructorDescriptorImpl]

'Identifier' @ [150:41] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.Identifier[FakeCallableDescriptorForObject]

'withNoPrototype' @ [150:52] ==> public final fun withNoPrototype(name: String, isNullable: Boolean = ..., quotingNeeded: Boolean = ..., imports: Collection<FqName> = ...): Identifier defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[SimpleFunctionDescriptorImpl]

'Identifier' @ [151:41] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.Identifier[FakeCallableDescriptorForObject]

'withNoPrototype' @ [151:52] ==> public final fun withNoPrototype(name: String, isNullable: Boolean = ..., quotingNeeded: Boolean = ..., imports: Collection<FqName> = ...): Identifier defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[SimpleFunctionDescriptorImpl]

'name' @ [151:68] ==> val name: String defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue.<anonymous>[LocalVariableDescriptor]

'Identifier' @ [155:20] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.Identifier[FakeCallableDescriptorForObject]

'withNoPrototype' @ [155:31] ==> public final fun withNoPrototype(name: String, isNullable: Boolean = ..., quotingNeeded: Boolean = ..., imports: Collection<FqName> = ...): Identifier defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[SimpleFunctionDescriptorImpl]

'deferredExpressionList' @ [155:60] ==> val deferredExpressionList: List<Pair<Nothing?, DeferredElement<Expression>>> defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue[LocalVariableDescriptor]

'annotation' @ [158:23] ==> value-parameter annotation: PsiAnnotation defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue[ValueParameterDescriptorImpl]

'nameReferenceElement' @ [158:34] ==> public final val PsiAnnotation.nameReferenceElement: PsiJavaCodeReferenceElement?[MyPropertyDescriptor]

'Identifier' @ [159:20] ==> public constructor Identifier(name: String, isNullable: Boolean = ..., quotingNeeded: Boolean = ..., imports: Collection<FqName> = ...) defined in org.jetbrains.kotlin.j2k.ast.Identifier[ClassConstructorDescriptorImpl]

'!!' @ [159:31] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: String?): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> String

'nameRef' @ [159:32] ==> val nameRef: PsiJavaCodeReferenceElement? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue[LocalVariableDescriptor]

'text' @ [159:56] ==> public final val PsiJavaCodeReferenceElement.text: (String..String?)[MyPropertyDescriptor]

'assignPrototype' @ [159:64] ==> public fun <TElement : Element> Identifier.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Identifier defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Identifier

'nameRef' @ [159:80] ==> val nameRef: PsiJavaCodeReferenceElement? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue[LocalVariableDescriptor]

'nameRef' @ [160:31] ==> val nameRef: PsiJavaCodeReferenceElement? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue[LocalVariableDescriptor]

'resolve' @ [160:39] ==> @Nullable public abstract fun resolve(): PsiElement? defined in com.intellij.psi.PsiJavaCodeReferenceElement[JavaMethodDescriptor]

'annotation' @ [161:25] ==> value-parameter annotation: PsiAnnotation defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue[ValueParameterDescriptorImpl]

'parameterList' @ [161:36] ==> public final val PsiAnnotation.parameterList: PsiAnnotationParameterList[MyPropertyDescriptor]

'attributes' @ [161:50] ==> public final val PsiAnnotationParameterList.attributes: (Array<(PsiNameValuePair..PsiNameValuePair?)>..Array<out (PsiNameValuePair..PsiNameValuePair?)>)[MyPropertyDescriptor]

'flatMap' @ [161:61] ==> public inline fun <T, R> Array<out (PsiNameValuePair..PsiNameValuePair?)>.flatMap(transform: ((PsiNameValuePair..PsiNameValuePair?)) -> Iterable<Pair<Identifier?, DeferredElement<Expression>>>): List<Pair<Identifier?, DeferredElement<Expression>>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiNameValuePair..com.intellij.psi.PsiNameValuePair?)
    <R> -> Pair<Identifier?, DeferredElement<Expression>>

'it' @ [162:33] ==> value-parameter it: (PsiNameValuePair..PsiNameValuePair?) defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [162:36] ==> public final val PsiNameValuePair.name: String?[MyPropertyDescriptor]

'annotationClass' @ [163:26] ==> val annotationClass: PsiClass? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue[LocalVariableDescriptor]

'findMethodsByName' @ [163:43] ==> @NotNull public abstract fun findMethodsByName(@NonNls p0: (String..String?), p1: Boolean): (Array<(PsiMethod..PsiMethod?)>..Array<out (PsiMethod..PsiMethod?)>) defined in com.intellij.psi.PsiClass[JavaMethodDescriptor]

'parameterName' @ [163:61] ==> val parameterName: String defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue.<anonymous>[LocalVariableDescriptor]

'firstOrNull' @ [163:84] ==> public fun <T> Array<out (PsiMethod..PsiMethod?)>.firstOrNull(): PsiMethod? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiMethod..com.intellij.psi.PsiMethod?)

'method' @ [164:32] ==> val method: PsiMethod? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue.<anonymous>[LocalVariableDescriptor]

'returnType' @ [164:40] ==> public final val PsiMethod.returnType: PsiType?[MyPropertyDescriptor]

'it' @ [166:28] ==> value-parameter it: (PsiNameValuePair..PsiNameValuePair?) defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [166:31] ==> public final val PsiNameValuePair.name: String?[MyPropertyDescriptor]

'let' @ [166:37] ==> @InlineOnly public inline fun <T, R> String.let(block: (String) -> Identifier): Identifier defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String
    <R> -> Identifier

'Identifier' @ [166:43] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.Identifier[FakeCallableDescriptorForObject]

'withNoPrototype' @ [166:54] ==> public final fun withNoPrototype(name: String, isNullable: Boolean = ..., quotingNeeded: Boolean = ..., imports: Collection<FqName> = ...): Identifier defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[SimpleFunctionDescriptorImpl]

'it' @ [166:70] ==> value-parameter it: String defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [167:25] ==> value-parameter it: (PsiNameValuePair..PsiNameValuePair?) defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [167:28] ==> public final val PsiNameValuePair.value: PsiAnnotationMemberValue?[MyPropertyDescriptor]

'parameterName' @ [169:28] ==> val parameterName: String defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue.<anonymous>[LocalVariableDescriptor]

'convertAttributeValue' @ [170:30] ==> private final fun convertAttributeValue(value: PsiAnnotationMemberValue?, expectedType: PsiType?, isVararg: Boolean, isUnnamed: Boolean): List<(CodeConverter) -> Expression> defined in org.jetbrains.kotlin.j2k.AnnotationConverter[SimpleFunctionDescriptorImpl]

'value' @ [170:52] ==> val value: PsiAnnotationMemberValue? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue.<anonymous>[LocalVariableDescriptor]

'expectedType' @ [170:59] ==> val expectedType: PsiType? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue.<anonymous>[LocalVariableDescriptor]

'isVarArg' @ [170:73] ==> val isVarArg: Boolean defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue.<anonymous>[LocalVariableDescriptor]

'it' @ [170:83] ==> value-parameter it: (PsiNameValuePair..PsiNameValuePair?) defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [170:86] ==> public final val PsiNameValuePair.name: String?[MyPropertyDescriptor]

'attrValues' @ [172:13] ==> val attrValues: List<(CodeConverter) -> Expression> defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue.<anonymous>[LocalVariableDescriptor]

'map' @ [172:24] ==> public inline fun <T, R> Iterable<(CodeConverter) -> Expression>.map(transform: ((CodeConverter) -> Expression) -> Pair<Identifier?, DeferredElement<Expression>>): List<Pair<Identifier?, DeferredElement<Expression>>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Function1<CodeConverter, Expression>
    <R> -> Pair<Identifier?, DeferredElement<Expression>>

'attrName' @ [172:30] ==> val attrName: Identifier? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue.<anonymous>[LocalVariableDescriptor]

'converter' @ [172:42] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.AnnotationConverter[PropertyDescriptorImpl]

'deferredElement' @ [172:52] ==> public final fun <TResult : Element> deferredElement(generator: (CodeConverter) -> Expression): DeferredElement<Expression> defined in org.jetbrains.kotlin.j2k.Converter[SimpleFunctionDescriptorImpl]
Inferred types:
    <TResult : Element> -> Expression

'it' @ [172:68] ==> value-parameter it: (CodeConverter) -> Expression defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [174:16] ==> val name: Identifier defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue[LocalVariableDescriptor]

'arguments' @ [174:24] ==> val arguments: List<Pair<Identifier?, DeferredElement<Expression>>> defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationValue[LocalVariableDescriptor]

'method' @ [178:21] ==> value-parameter method: PsiAnnotationMethod defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationMethodDefault[ValueParameterDescriptorImpl]

'defaultValue' @ [178:28] ==> public final val PsiAnnotationMethod.defaultValue: PsiAnnotationMemberValue?[MyPropertyDescriptor]

'method' @ [179:26] ==> value-parameter method: PsiAnnotationMethod defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationMethodDefault[ValueParameterDescriptorImpl]

'returnType' @ [179:33] ==> public final val PsiAnnotationMethod.returnType: PsiType?[MyPropertyDescriptor]

'returnType' @ [180:13] ==> val returnType: PsiType? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationMethodDefault[LocalVariableDescriptor]

'value' @ [180:43] ==> val value: PsiAnnotationMemberValue defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationMethodDefault[LocalVariableDescriptor]

'converter' @ [181:20] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.AnnotationConverter[PropertyDescriptorImpl]

'deferredElement' @ [181:30] ==> public final fun <TResult : Element> deferredElement(generator: (CodeConverter) -> Expression): DeferredElement<Expression> defined in org.jetbrains.kotlin.j2k.Converter[SimpleFunctionDescriptorImpl]
Inferred types:
    <TResult : Element> -> Expression

'converter' @ [182:37] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.AnnotationConverter[PropertyDescriptorImpl]

'typeConverter' @ [182:47] ==> public final val typeConverter: TypeConverter defined in org.jetbrains.kotlin.j2k.Converter[PropertyDescriptorImpl]

'convertType' @ [182:61] ==> public final fun convertType(type: PsiType?, nullability: Nullability = ..., mutability: Mutability = ..., inAnnotationType: Boolean = ...): Type defined in org.jetbrains.kotlin.j2k.TypeConverter[SimpleFunctionDescriptorImpl]

'returnType' @ [182:73] ==> val returnType: PsiType? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationMethodDefault[LocalVariableDescriptor]

'convertAttributeValue' @ [183:45] ==> private final fun convertAttributeValue(value: PsiAnnotationMemberValue?, expectedType: PsiType?, isVararg: Boolean, isUnnamed: Boolean): List<(CodeConverter) -> Expression> defined in org.jetbrains.kotlin.j2k.AnnotationConverter[SimpleFunctionDescriptorImpl]

'value' @ [183:67] ==> val value: PsiAnnotationMemberValue defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationMethodDefault[LocalVariableDescriptor]

'returnType' @ [183:74] ==> val returnType: PsiType? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationMethodDefault[LocalVariableDescriptor]

'componentType' @ [183:85] ==> public final val PsiArrayType.componentType: PsiType[MyPropertyDescriptor]

'createArrayExpression' @ [184:17] ==> private final fun createArrayExpression(codeConverter: CodeConverter, componentGenerators: List<(CodeConverter) -> Expression>, expectedType: ArrayType, isVararg: Boolean): Expression defined in org.jetbrains.kotlin.j2k.AnnotationConverter[SimpleFunctionDescriptorImpl]

'codeConverter' @ [184:39] ==> value-parameter codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationMethodDefault.<anonymous>[ValueParameterDescriptorImpl]

'convertAttributeValue' @ [184:54] ==> val convertAttributeValue: List<(CodeConverter) -> Expression> defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationMethodDefault.<anonymous>[LocalVariableDescriptor]

'toList' @ [184:76] ==> public fun <T> Iterable<(CodeConverter) -> Expression>.toList(): List<(CodeConverter) -> Expression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Function1<CodeConverter, Expression>

'convertedType' @ [184:86] ==> val convertedType: ArrayType defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationMethodDefault.<anonymous>[LocalVariableDescriptor]

'converter' @ [187:16] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.AnnotationConverter[PropertyDescriptorImpl]

'deferredElement' @ [187:26] ==> public final fun <TResult : Element> deferredElement(generator: (CodeConverter) -> Expression): DeferredElement<Expression> defined in org.jetbrains.kotlin.j2k.Converter[SimpleFunctionDescriptorImpl]
Inferred types:
    <TResult : Element> -> Expression

'convertAttributeValue' @ [187:42] ==> private final fun convertAttributeValue(value: PsiAnnotationMemberValue?, expectedType: PsiType?, isVararg: Boolean, isUnnamed: Boolean): List<(CodeConverter) -> Expression> defined in org.jetbrains.kotlin.j2k.AnnotationConverter[SimpleFunctionDescriptorImpl]

'value' @ [187:64] ==> val value: PsiAnnotationMemberValue defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationMethodDefault[LocalVariableDescriptor]

'returnType' @ [187:71] ==> val returnType: PsiType? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAnnotationMethodDefault[LocalVariableDescriptor]

'single' @ [187:97] ==> public fun <T> List<(CodeConverter) -> Expression>.single(): (CodeConverter) -> Expression defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Function1<CodeConverter, Expression>

'when (value) {
            is PsiExpression -> listOf({ codeConverter -> convertExpressionValue(codeConverter, value, expectedType, isVararg) })

            is PsiArrayInitializerMemberValue -> {
                val componentType = (expectedType as? PsiArrayType)?.componentType
                val componentGenerators = value.initializers.map { convertAttributeValue(it, componentType, false, true).single() }
                if (isVararg && isUnnamed) {
                    componentGenerators
                }
                else {
                    listOf({ codeConverter ->
                               convertArrayInitializerValue(codeConverter, value.text, componentGenerators, expectedType, isVararg)
                                       .assignPrototype(value)
                           })
                }
            }

            is PsiAnnotation -> {
                listOf({ _ ->
                           val (name, arguments) = convertAnnotationValue(value)!!
                           AnnotationConstructorCall(name, arguments).assignPrototype(value)
                       })
            }
            else -> listOf({ _ -> DummyStringExpression(value?.text ?: "").assignPrototype(value) })
        }' @ [191:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: List<(CodeConverter) -> Expression>, entry1: List<(CodeConverter) -> Expression>, entry2: List<(CodeConverter) -> Expression>, entry3: List<(CodeConverter) -> Expression>): List<(CodeConverter) -> Expression>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> List<Function1<CodeConverter, Expression>>

'value' @ [191:22] ==> value-parameter value: PsiAnnotationMemberValue? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAttributeValue[ValueParameterDescriptorImpl]

'listOf' @ [192:33] ==> public fun <T> listOf(element: (CodeConverter) -> Expression): List<(CodeConverter) -> Expression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Function1<CodeConverter, Expression>

'convertExpressionValue' @ [192:59] ==> private final fun convertExpressionValue(codeConverter: CodeConverter, value: PsiExpression, expectedType: PsiType?, isVararg: Boolean): Expression defined in org.jetbrains.kotlin.j2k.AnnotationConverter[SimpleFunctionDescriptorImpl]

'codeConverter' @ [192:82] ==> value-parameter codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAttributeValue.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [192:97] ==> value-parameter value: PsiAnnotationMemberValue? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAttributeValue[ValueParameterDescriptorImpl]

'expectedType' @ [192:104] ==> value-parameter expectedType: PsiType? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAttributeValue[ValueParameterDescriptorImpl]

'isVararg' @ [192:118] ==> value-parameter isVararg: Boolean defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAttributeValue[ValueParameterDescriptorImpl]

'expectedType' @ [195:38] ==> value-parameter expectedType: PsiType? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAttributeValue[ValueParameterDescriptorImpl]

'componentType' @ [195:70] ==> public final val PsiArrayType.componentType: PsiType[MyPropertyDescriptor]

'value' @ [196:43] ==> value-parameter value: PsiAnnotationMemberValue? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAttributeValue[ValueParameterDescriptorImpl]

'initializers' @ [196:49] ==> public final val PsiArrayInitializerMemberValue.initializers: (Array<(PsiAnnotationMemberValue..PsiAnnotationMemberValue?)>..Array<out (PsiAnnotationMemberValue..PsiAnnotationMemberValue?)>)[MyPropertyDescriptor]

'map' @ [196:62] ==> public inline fun <T, R> Array<out (PsiAnnotationMemberValue..PsiAnnotationMemberValue?)>.map(transform: ((PsiAnnotationMemberValue..PsiAnnotationMemberValue?)) -> (CodeConverter) -> Expression): List<(CodeConverter) -> Expression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiAnnotationMemberValue..com.intellij.psi.PsiAnnotationMemberValue?)
    <R> -> Function1<CodeConverter, Expression>

'convertAttributeValue' @ [196:68] ==> private final fun convertAttributeValue(value: PsiAnnotationMemberValue?, expectedType: PsiType?, isVararg: Boolean, isUnnamed: Boolean): List<(CodeConverter) -> Expression> defined in org.jetbrains.kotlin.j2k.AnnotationConverter[SimpleFunctionDescriptorImpl]

'it' @ [196:90] ==> value-parameter it: (PsiAnnotationMemberValue..PsiAnnotationMemberValue?) defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAttributeValue.<anonymous>[ValueParameterDescriptorImpl]

'componentType' @ [196:94] ==> val componentType: PsiType? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAttributeValue[LocalVariableDescriptor]

'single' @ [196:122] ==> public fun <T> List<(CodeConverter) -> Expression>.single(): (CodeConverter) -> Expression defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Function1<CodeConverter, Expression>

'if (isVararg && isUnnamed) {
                    componentGenerators
                }
                else {
                    listOf({ codeConverter ->
                               convertArrayInitializerValue(codeConverter, value.text, componentGenerators, expectedType, isVararg)
                                       .assignPrototype(value)
                           })
                }' @ [197:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<(CodeConverter) -> Expression>, elseBranch: List<(CodeConverter) -> Expression>): List<(CodeConverter) -> Expression>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<Function1<CodeConverter, Expression>>

'isVararg' @ [197:21] ==> value-parameter isVararg: Boolean defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAttributeValue[ValueParameterDescriptorImpl]

'isUnnamed' @ [197:33] ==> value-parameter isUnnamed: Boolean defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAttributeValue[ValueParameterDescriptorImpl]

'componentGenerators' @ [198:21] ==> val componentGenerators: List<(CodeConverter) -> Expression> defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAttributeValue[LocalVariableDescriptor]

'listOf' @ [201:21] ==> public fun <T> listOf(element: (CodeConverter) -> Expression): List<(CodeConverter) -> Expression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Function1<CodeConverter, Expression>

'convertArrayInitializerValue' @ [202:32] ==> private final fun convertArrayInitializerValue(codeConverter: CodeConverter, valueText: String, componentGenerators: List<(CodeConverter) -> Expression>, expectedType: PsiType?, isVararg: Boolean): Expression defined in org.jetbrains.kotlin.j2k.AnnotationConverter[SimpleFunctionDescriptorImpl]

'codeConverter' @ [202:61] ==> value-parameter codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAttributeValue.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [202:76] ==> value-parameter value: PsiAnnotationMemberValue? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAttributeValue[ValueParameterDescriptorImpl]

'text' @ [202:82] ==> public final val PsiArrayInitializerMemberValue.text: (String..String?)[MyPropertyDescriptor]

'componentGenerators' @ [202:88] ==> val componentGenerators: List<(CodeConverter) -> Expression> defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAttributeValue[LocalVariableDescriptor]

'expectedType' @ [202:109] ==> value-parameter expectedType: PsiType? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAttributeValue[ValueParameterDescriptorImpl]

'isVararg' @ [202:123] ==> value-parameter isVararg: Boolean defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAttributeValue[ValueParameterDescriptorImpl]

'assignPrototype' @ [203:41] ==> public fun <TElement : Element> Expression.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Expression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Expression

'value' @ [203:57] ==> value-parameter value: PsiAnnotationMemberValue? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAttributeValue[ValueParameterDescriptorImpl]

'listOf' @ [209:17] ==> public fun <T> listOf(element: (CodeConverter) -> Expression): List<(CodeConverter) -> Expression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Function1<CodeConverter, Expression>

'component1' @ [210:33] ==> public final operator fun component1(): Identifier defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [210:39] ==> public final operator fun component2(): List<Pair<Identifier?, DeferredElement<Expression>>> defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'convertAnnotationValue' @ [210:52] ==> private final fun convertAnnotationValue(annotation: PsiAnnotation): Pair<Identifier, List<Pair<Identifier?, DeferredElement<Expression>>>>? defined in org.jetbrains.kotlin.j2k.AnnotationConverter[SimpleFunctionDescriptorImpl]

'value' @ [210:75] ==> value-parameter value: PsiAnnotationMemberValue? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAttributeValue[ValueParameterDescriptorImpl]

'AnnotationConstructorCall' @ [211:28] ==> public constructor AnnotationConstructorCall(name: Identifier, arguments: List<Pair<Identifier?, DeferredElement<Expression>>>) defined in org.jetbrains.kotlin.j2k.ast.AnnotationConstructorCall[ClassConstructorDescriptorImpl]

'name' @ [211:54] ==> val name: Identifier defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAttributeValue.<anonymous>[LocalVariableDescriptor]

'arguments' @ [211:60] ==> val arguments: List<Pair<Identifier?, DeferredElement<Expression>>> defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAttributeValue.<anonymous>[LocalVariableDescriptor]

'assignPrototype' @ [211:71] ==> public fun <TElement : Element> AnnotationConstructorCall.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): AnnotationConstructorCall defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> AnnotationConstructorCall

'value' @ [211:87] ==> value-parameter value: PsiAnnotationMemberValue? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAttributeValue[ValueParameterDescriptorImpl]

'listOf' @ [214:21] ==> public fun <T> listOf(element: (CodeConverter) -> Expression): List<(CodeConverter) -> Expression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Function1<CodeConverter, Expression>

'DummyStringExpression' @ [214:35] ==> public constructor DummyStringExpression(string: String) defined in org.jetbrains.kotlin.j2k.ast.DummyStringExpression[ClassConstructorDescriptorImpl]

'value' @ [214:57] ==> value-parameter value: PsiAnnotationMemberValue? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAttributeValue[ValueParameterDescriptorImpl]

'text' @ [214:64] ==> public final val PsiAnnotationMemberValue.text: (String..String?)[MyPropertyDescriptor]

'assignPrototype' @ [214:76] ==> public fun <TElement : Element> DummyStringExpression.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): DummyStringExpression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> DummyStringExpression

'value' @ [214:92] ==> value-parameter value: PsiAnnotationMemberValue? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertAttributeValue[ValueParameterDescriptorImpl]

'if (value is PsiClassObjectAccessExpression) {
            val type = converter.convertTypeElement(value.operand, Nullability.NotNull)
            ClassLiteralExpression(type)
        }
        else {
            codeConverter.convertExpression(value, expectedType)
        }' @ [219:26] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Expression, elseBranch: Expression): Expression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Expression

'value' @ [219:30] ==> value-parameter value: PsiExpression defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertExpressionValue[ValueParameterDescriptorImpl]

'converter' @ [220:24] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.AnnotationConverter[PropertyDescriptorImpl]

'convertTypeElement' @ [220:34] ==> public final fun convertTypeElement(element: PsiTypeElement?, nullability: Nullability): Type defined in org.jetbrains.kotlin.j2k.Converter[SimpleFunctionDescriptorImpl]

'value' @ [220:53] ==> value-parameter value: PsiExpression defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertExpressionValue[ValueParameterDescriptorImpl]

'operand' @ [220:59] ==> public final val PsiClassObjectAccessExpression.operand: PsiTypeElement[MyPropertyDescriptor]

'NotNull' @ [220:80] ==> enum entry NotNull defined in org.jetbrains.kotlin.j2k.ast.Nullability[FakeCallableDescriptorForObject]

'ClassLiteralExpression' @ [221:13] ==> public constructor ClassLiteralExpression(type: Type) defined in org.jetbrains.kotlin.j2k.ast.ClassLiteralExpression[ClassConstructorDescriptorImpl]

'type' @ [221:36] ==> val type: Type defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertExpressionValue[LocalVariableDescriptor]

'codeConverter' @ [224:13] ==> value-parameter codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertExpressionValue[ValueParameterDescriptorImpl]

'convertExpression' @ [224:27] ==> public final fun convertExpression(expression: PsiExpression?, expectedType: PsiType?, expectedNullability: Nullability? = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'value' @ [224:45] ==> value-parameter value: PsiExpression defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertExpressionValue[ValueParameterDescriptorImpl]

'expectedType' @ [224:52] ==> value-parameter expectedType: PsiType? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertExpressionValue[ValueParameterDescriptorImpl]

'assignPrototype' @ [225:11] ==> public fun <TElement : Element> Expression.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Expression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Expression

'value' @ [225:27] ==> value-parameter value: PsiExpression defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertExpressionValue[ValueParameterDescriptorImpl]

'expectedType' @ [227:13] ==> value-parameter expectedType: PsiType? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertExpressionValue[ValueParameterDescriptorImpl]

'!' @ [227:45] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isVararg' @ [227:46] ==> value-parameter isVararg: Boolean defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertExpressionValue[ValueParameterDescriptorImpl]

'convertArrayInitializerValue' @ [228:20] ==> private final fun convertArrayInitializerValue(codeConverter: CodeConverter, valueText: String, componentGenerators: List<(CodeConverter) -> Expression>, expectedType: PsiType?, isVararg: Boolean): Expression defined in org.jetbrains.kotlin.j2k.AnnotationConverter[SimpleFunctionDescriptorImpl]

'codeConverter' @ [228:49] ==> value-parameter codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertExpressionValue[ValueParameterDescriptorImpl]

'value' @ [229:49] ==> value-parameter value: PsiExpression defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertExpressionValue[ValueParameterDescriptorImpl]

'text' @ [229:55] ==> public final val PsiExpression.text: (String..String?)[MyPropertyDescriptor]

'listOf' @ [230:49] ==> public fun <T> listOf(element: (CodeConverter) -> Expression): List<(CodeConverter) -> Expression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Function1<CodeConverter, Expression>

'expression' @ [230:63] ==> val expression: Expression defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertExpressionValue[LocalVariableDescriptor]

'expectedType' @ [231:49] ==> value-parameter expectedType: PsiType? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertExpressionValue[ValueParameterDescriptorImpl]

'assignPrototype' @ [233:15] ==> public fun <TElement : Element> Expression.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Expression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Expression

'value' @ [233:31] ==> value-parameter value: PsiExpression defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertExpressionValue[ValueParameterDescriptorImpl]

'expression' @ [235:16] ==> val expression: Expression defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertExpressionValue[LocalVariableDescriptor]

'converter' @ [245:37] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.AnnotationConverter[PropertyDescriptorImpl]

'typeConverter' @ [245:47] ==> public final val typeConverter: TypeConverter defined in org.jetbrains.kotlin.j2k.Converter[PropertyDescriptorImpl]

'convertType' @ [245:61] ==> public final fun convertType(type: PsiType?, nullability: Nullability = ..., mutability: Mutability = ..., inAnnotationType: Boolean = ...): Type defined in org.jetbrains.kotlin.j2k.TypeConverter[SimpleFunctionDescriptorImpl]

'expectedType' @ [245:73] ==> value-parameter expectedType: PsiType? defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertArrayInitializerValue[ValueParameterDescriptorImpl]

'if (expectedTypeConverted is ArrayType) {
            createArrayExpression(codeConverter, componentGenerators, expectedTypeConverted, isVararg)
        }
        else {
            DummyStringExpression(valueText)
        }' @ [246:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Expression, elseBranch: Expression): Expression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Expression

'expectedTypeConverted' @ [246:20] ==> val expectedTypeConverted: Type defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertArrayInitializerValue[LocalVariableDescriptor]

'createArrayExpression' @ [247:13] ==> private final fun createArrayExpression(codeConverter: CodeConverter, componentGenerators: List<(CodeConverter) -> Expression>, expectedType: ArrayType, isVararg: Boolean): Expression defined in org.jetbrains.kotlin.j2k.AnnotationConverter[SimpleFunctionDescriptorImpl]

'codeConverter' @ [247:35] ==> value-parameter codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertArrayInitializerValue[ValueParameterDescriptorImpl]

'componentGenerators' @ [247:50] ==> value-parameter componentGenerators: List<(CodeConverter) -> Expression> defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertArrayInitializerValue[ValueParameterDescriptorImpl]

'expectedTypeConverted' @ [247:71] ==> val expectedTypeConverted: Type defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertArrayInitializerValue[LocalVariableDescriptor]

'isVararg' @ [247:94] ==> value-parameter isVararg: Boolean defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertArrayInitializerValue[ValueParameterDescriptorImpl]

'DummyStringExpression' @ [250:13] ==> public constructor DummyStringExpression(string: String) defined in org.jetbrains.kotlin.j2k.ast.DummyStringExpression[ClassConstructorDescriptorImpl]

'valueText' @ [250:35] ==> value-parameter valueText: String defined in org.jetbrains.kotlin.j2k.AnnotationConverter.convertArrayInitializerValue[ValueParameterDescriptorImpl]

'createArrayInitializerExpression' @ [255:21] ==> public fun createArrayInitializerExpression(arrayType: ArrayType, initializers: List<Expression>, needExplicitType: Boolean = ...): MethodCallExpression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]

'expectedType' @ [255:54] ==> value-parameter expectedType: ArrayType defined in org.jetbrains.kotlin.j2k.AnnotationConverter.createArrayExpression[ValueParameterDescriptorImpl]

'componentGenerators' @ [255:68] ==> value-parameter componentGenerators: List<(CodeConverter) -> Expression> defined in org.jetbrains.kotlin.j2k.AnnotationConverter.createArrayExpression[ValueParameterDescriptorImpl]

'map' @ [255:88] ==> public inline fun <T, R> Iterable<(CodeConverter) -> Expression>.map(transform: ((CodeConverter) -> Expression) -> Expression): List<Expression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Function1<CodeConverter, Expression>
    <R> -> Expression

'invoke' @ [255:94] ==> public abstract operator fun invoke(p1: CodeConverter): Expression defined in kotlin.Function1[FunctionInvokeDescriptor]

'codeConverter' @ [255:97] ==> value-parameter codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.AnnotationConverter.createArrayExpression[ValueParameterDescriptorImpl]

'if (isVararg) {
            StarExpression(array.assignNoPrototype())
        }
        else {
            array
        }' @ [256:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Expression, elseBranch: Expression): Expression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Expression

'isVararg' @ [256:20] ==> value-parameter isVararg: Boolean defined in org.jetbrains.kotlin.j2k.AnnotationConverter.createArrayExpression[ValueParameterDescriptorImpl]

'StarExpression' @ [257:13] ==> public constructor StarExpression(operand: Expression) defined in org.jetbrains.kotlin.j2k.ast.StarExpression[ClassConstructorDescriptorImpl]

'array' @ [257:28] ==> val array: MethodCallExpression defined in org.jetbrains.kotlin.j2k.AnnotationConverter.createArrayExpression[LocalVariableDescriptor]

'assignNoPrototype' @ [257:34] ==> public fun <TElement : Element> MethodCallExpression.assignNoPrototype(): MethodCallExpression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> MethodCallExpression

'array' @ [260:13] ==> val array: MethodCallExpression defined in org.jetbrains.kotlin.j2k.AnnotationConverter.createArrayExpression[LocalVariableDescriptor]

