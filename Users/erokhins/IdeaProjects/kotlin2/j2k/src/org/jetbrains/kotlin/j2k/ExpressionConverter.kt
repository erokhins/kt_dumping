'specialConverter' @ [54:19] ==> value-parameter specialConverter: SpecialExpressionConverter defined in org.jetbrains.kotlin.j2k.withSpecialConverter[ValueParameterDescriptorImpl]

'convertExpression' @ [54:36] ==> public abstract fun convertExpression(expression: PsiExpression, codeConverter: CodeConverter): Expression? defined in org.jetbrains.kotlin.j2k.SpecialExpressionConverter[SimpleFunctionDescriptorImpl]

'expression' @ [54:54] ==> value-parameter expression: PsiExpression defined in org.jetbrains.kotlin.j2k.withSpecialConverter.<no name provided>.convertExpression[ValueParameterDescriptorImpl]

'codeConverter' @ [54:66] ==> value-parameter codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.withSpecialConverter.<no name provided>.convertExpression[ValueParameterDescriptorImpl]

'this@withSpecialConverter' @ [54:84] ==> <this> defined in org.jetbrains.kotlin.j2k.withSpecialConverter[ReceiverParameterDescriptorImpl]

'convertExpression' @ [54:110] ==> public abstract fun convertExpression(expression: PsiExpression, codeConverter: CodeConverter): Expression defined in org.jetbrains.kotlin.j2k.ExpressionConverter[SimpleFunctionDescriptorImpl]

'expression' @ [54:128] ==> value-parameter expression: PsiExpression defined in org.jetbrains.kotlin.j2k.withSpecialConverter.<no name provided>.convertExpression[ValueParameterDescriptorImpl]

'codeConverter' @ [54:140] ==> value-parameter codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.withSpecialConverter.<no name provided>.convertExpression[ValueParameterDescriptorImpl]

'JavaElementVisitor' @ [58:36] ==> public constructor JavaElementVisitor() defined in com.intellij.psi.JavaElementVisitor[JavaClassConstructorDescriptor]

'Empty' @ [60:49] ==> public object Empty : Expression defined in org.jetbrains.kotlin.j2k.ast.Expression[FakeCallableDescriptorForObject]

'_codeConverter' @ [62:54] ==> private final var _codeConverter: CodeConverter? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'codeConverter' @ [63:54] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'typeConverter' @ [63:68] ==> public final val typeConverter: TypeConverter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'codeConverter' @ [64:46] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'converter' @ [64:60] ==> public final val converter: Converter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'this' @ [67:9] ==> <this> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[LazyClassReceiverParameterDescriptor]

'_codeConverter' @ [67:14] ==> private final var _codeConverter: CodeConverter? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'codeConverter' @ [67:31] ==> value-parameter codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertExpression[ValueParameterDescriptorImpl]

'result' @ [68:9] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'Empty' @ [68:29] ==> public object Empty : Expression defined in org.jetbrains.kotlin.j2k.ast.Expression[FakeCallableDescriptorForObject]

'expression' @ [70:9] ==> value-parameter expression: PsiExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertExpression[ValueParameterDescriptorImpl]

'accept' @ [70:20] ==> public abstract fun accept(@NotNull p0: PsiElementVisitor): Unit defined in com.intellij.psi.PsiExpression[JavaMethodDescriptor]

'this' @ [70:27] ==> <this> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[LazyClassReceiverParameterDescriptor]

'result' @ [71:16] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'expression' @ [75:26] ==> value-parameter expression: PsiArrayAccessExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitArrayAccessExpression[ValueParameterDescriptorImpl]

'getStrictParentOfType' @ [75:37] ==> public inline fun <reified T : PsiElement> PsiElement.getStrictParentOfType(): PsiAssignmentExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> PsiAssignmentExpression

'assignment' @ [76:22] ==> val assignment: PsiAssignmentExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitArrayAccessExpression[LocalVariableDescriptor]

'expression' @ [76:44] ==> value-parameter expression: PsiArrayAccessExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitArrayAccessExpression[ValueParameterDescriptorImpl]

'assignment' @ [76:58] ==> val assignment: PsiAssignmentExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitArrayAccessExpression[LocalVariableDescriptor]

'lExpression' @ [76:69] ==> public final val PsiAssignmentExpression.lExpression: PsiExpression[MyPropertyDescriptor]

'result' @ [77:9] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'ArrayAccessExpression' @ [77:18] ==> public constructor ArrayAccessExpression(expression: Expression, index: Expression, lvalue: Boolean) defined in org.jetbrains.kotlin.j2k.ast.ArrayAccessExpression[ClassConstructorDescriptorImpl]

'codeConverter' @ [77:40] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [77:54] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'expression' @ [77:72] ==> value-parameter expression: PsiArrayAccessExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitArrayAccessExpression[ValueParameterDescriptorImpl]

'arrayExpression' @ [77:83] ==> public final val PsiArrayAccessExpression.arrayExpression: PsiExpression[MyPropertyDescriptor]

'codeConverter' @ [78:40] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [78:54] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'expression' @ [78:72] ==> value-parameter expression: PsiArrayAccessExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitArrayAccessExpression[ValueParameterDescriptorImpl]

'indexExpression' @ [78:83] ==> public final val PsiArrayAccessExpression.indexExpression: PsiExpression?[MyPropertyDescriptor]

'lvalue' @ [79:40] ==> val lvalue: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitArrayAccessExpression[LocalVariableDescriptor]

'expression' @ [83:25] ==> value-parameter expression: PsiArrayInitializerExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitArrayInitializerExpression[ValueParameterDescriptorImpl]

'type' @ [83:36] ==> public final val PsiArrayInitializerExpression.type: PsiType?[MyPropertyDescriptor]

'arrayType' @ [84:30] ==> val arrayType: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitArrayInitializerExpression[LocalVariableDescriptor]

'componentType' @ [84:59] ==> public final val PsiArrayType.componentType: PsiType[MyPropertyDescriptor]

'typeConverter' @ [85:30] ==> private final val typeConverter: TypeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertType' @ [85:44] ==> public final fun convertType(type: PsiType?, nullability: Nullability = ..., mutability: Mutability = ..., inAnnotationType: Boolean = ...): Type defined in org.jetbrains.kotlin.j2k.TypeConverter[SimpleFunctionDescriptorImpl]

'arrayType' @ [85:56] ==> val arrayType: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitArrayInitializerExpression[LocalVariableDescriptor]

'assert' @ [86:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'expressionType' @ [86:16] ==> val expressionType: Type defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitArrayInitializerExpression[LocalVariableDescriptor]

'expressionType' @ [86:106] ==> val expressionType: Type defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitArrayInitializerExpression[LocalVariableDescriptor]

'expression' @ [86:135] ==> value-parameter expression: PsiArrayInitializerExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitArrayInitializerExpression[ValueParameterDescriptorImpl]

'result' @ [87:9] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'createArrayInitializerExpression' @ [87:18] ==> public fun createArrayInitializerExpression(arrayType: ArrayType, initializers: List<Expression>, needExplicitType: Boolean = ...): MethodCallExpression defined in org.jetbrains.kotlin.j2k.ast in file Expressions.kt[SimpleFunctionDescriptorImpl]

'expressionType' @ [87:51] ==> val expressionType: Type defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitArrayInitializerExpression[LocalVariableDescriptor]

'expression' @ [88:51] ==> value-parameter expression: PsiArrayInitializerExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitArrayInitializerExpression[ValueParameterDescriptorImpl]

'initializers' @ [88:62] ==> public final val PsiArrayInitializerExpression.initializers: (Array<(PsiExpression..PsiExpression?)>..Array<out (PsiExpression..PsiExpression?)>)[MyPropertyDescriptor]

'map' @ [88:75] ==> public inline fun <T, R> Array<out (PsiExpression..PsiExpression?)>.map(transform: ((PsiExpression..PsiExpression?)) -> Expression): List<Expression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiExpression..com.intellij.psi.PsiExpression?)
    <R> -> Expression

'codeConverter' @ [88:81] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [88:95] ==> public final fun convertExpression(expression: PsiExpression?, expectedType: PsiType?, expectedNullability: Nullability? = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'it' @ [88:113] ==> value-parameter it: (PsiExpression..PsiExpression?) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitArrayInitializerExpression.<anonymous>[ValueParameterDescriptorImpl]

'componentType' @ [88:117] ==> val componentType: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitArrayInitializerExpression[LocalVariableDescriptor]

'expression' @ [92:25] ==> value-parameter expression: PsiAssignmentExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitAssignmentExpression[ValueParameterDescriptorImpl]

'operationSign' @ [92:36] ==> public final val PsiAssignmentExpression.operationSign: PsiJavaToken[MyPropertyDescriptor]

'tokenType' @ [92:50] ==> public final val PsiJavaToken.tokenType: (IElementType..IElementType?)[MyPropertyDescriptor]

'codeConverter' @ [94:19] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [94:33] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'expression' @ [94:51] ==> value-parameter expression: PsiAssignmentExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitAssignmentExpression[ValueParameterDescriptorImpl]

'lExpression' @ [94:62] ==> public final val PsiAssignmentExpression.lExpression: PsiExpression[MyPropertyDescriptor]

'codeConverter' @ [95:19] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [95:33] ==> public final fun convertExpression(expression: PsiExpression?, expectedType: PsiType?, expectedNullability: Nullability? = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'expression' @ [95:51] ==> value-parameter expression: PsiAssignmentExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitAssignmentExpression[ValueParameterDescriptorImpl]

'rExpression' @ [95:62] ==> public final val PsiAssignmentExpression.rExpression: PsiExpression?[MyPropertyDescriptor]

'expression' @ [95:77] ==> value-parameter expression: PsiAssignmentExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitAssignmentExpression[ValueParameterDescriptorImpl]

'lExpression' @ [95:88] ==> public final val PsiAssignmentExpression.lExpression: PsiExpression[MyPropertyDescriptor]

'type' @ [95:100] ==> public final val PsiExpression.type: PsiType?[MyPropertyDescriptor]

'when (tokenType) {
            JavaTokenType.GTGTEQ, JavaTokenType.LTLTEQ, JavaTokenType.GTGTGTEQ,
            JavaTokenType.XOREQ, JavaTokenType.OREQ,
            JavaTokenType.ANDEQ -> true
            else -> false
        }' @ [97:24] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'tokenType' @ [97:30] ==> val tokenType: (IElementType..IElementType?) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitAssignmentExpression[LocalVariableDescriptor]

'GTGTEQ' @ [98:27] ==> public final val GTGTEQ: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'LTLTEQ' @ [98:49] ==> public final val LTLTEQ: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'GTGTGTEQ' @ [98:71] ==> public final val GTGTGTEQ: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'XOREQ' @ [99:27] ==> public final val XOREQ: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'OREQ' @ [99:48] ==> public final val OREQ: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'ANDEQ' @ [100:27] ==> public final val ANDEQ: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'Operator' @ [104:24] ==> public constructor Operator(operatorType: IElementType) defined in org.jetbrains.kotlin.j2k.ast.Operator[ClassConstructorDescriptorImpl]

'tokenType' @ [104:33] ==> val tokenType: (IElementType..IElementType?) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitAssignmentExpression[LocalVariableDescriptor]

'assignPrototype' @ [104:44] ==> public fun <TElement : Element> Operator.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Operator defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Operator

'expression' @ [104:60] ==> value-parameter expression: PsiAssignmentExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitAssignmentExpression[ValueParameterDescriptorImpl]

'operationSign' @ [104:71] ==> public final val PsiAssignmentExpression.operationSign: PsiJavaToken[MyPropertyDescriptor]

'result' @ [105:9] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'if (secondOp) {
            AssignmentExpression(lhs, BinaryExpression(lhs, rhs, operator).assignNoPrototype(), Operator.EQ)
        }
        else {
            AssignmentExpression(lhs, rhs, operator)
        }' @ [105:18] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Expression, elseBranch: Expression): Expression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Expression

'secondOp' @ [105:22] ==> val secondOp: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitAssignmentExpression[LocalVariableDescriptor]

'AssignmentExpression' @ [106:13] ==> public constructor AssignmentExpression(left: Expression, right: Expression, op: Operator) defined in org.jetbrains.kotlin.j2k.ast.AssignmentExpression[ClassConstructorDescriptorImpl]

'lhs' @ [106:34] ==> val lhs: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitAssignmentExpression[LocalVariableDescriptor]

'BinaryExpression' @ [106:39] ==> public constructor BinaryExpression(left: Expression, right: Expression, op: Operator) defined in org.jetbrains.kotlin.j2k.ast.BinaryExpression[ClassConstructorDescriptorImpl]

'lhs' @ [106:56] ==> val lhs: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitAssignmentExpression[LocalVariableDescriptor]

'rhs' @ [106:61] ==> val rhs: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitAssignmentExpression[LocalVariableDescriptor]

'operator' @ [106:66] ==> val operator: Operator defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitAssignmentExpression[LocalVariableDescriptor]

'assignNoPrototype' @ [106:76] ==> public fun <TElement : Element> BinaryExpression.assignNoPrototype(): BinaryExpression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> BinaryExpression

'EQ' @ [106:106] ==> public final val EQ: Operator defined in org.jetbrains.kotlin.j2k.ast.Operator.Companion[PropertyDescriptorImpl]

'AssignmentExpression' @ [109:13] ==> public constructor AssignmentExpression(left: Expression, right: Expression, op: Operator) defined in org.jetbrains.kotlin.j2k.ast.AssignmentExpression[ClassConstructorDescriptorImpl]

'lhs' @ [109:34] ==> val lhs: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitAssignmentExpression[LocalVariableDescriptor]

'rhs' @ [109:39] ==> val rhs: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitAssignmentExpression[LocalVariableDescriptor]

'operator' @ [109:44] ==> val operator: Operator defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitAssignmentExpression[LocalVariableDescriptor]

'expression' @ [115:20] ==> value-parameter expression: PsiBinaryExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[ValueParameterDescriptorImpl]

'lOperand' @ [115:31] ==> public final val PsiBinaryExpression.lOperand: PsiExpression[MyPropertyDescriptor]

'expression' @ [116:21] ==> value-parameter expression: PsiBinaryExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[ValueParameterDescriptorImpl]

'rOperand' @ [116:32] ==> public final val PsiBinaryExpression.rOperand: PsiExpression?[MyPropertyDescriptor]

'expression' @ [118:34] ==> value-parameter expression: PsiBinaryExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[ValueParameterDescriptorImpl]

'operationTokenType' @ [118:45] ==> public final val PsiBinaryExpression.operationTokenType: IElementType[MyPropertyDescriptor]

'if (operationTokenType in NON_NULL_OPERAND_OPS) Nullability.NotNull else null' @ [120:35] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nullability?, elseBranch: Nullability?): Nullability?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nullability?

'operationTokenType' @ [120:39] ==> val operationTokenType: IElementType defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'NON_NULL_OPERAND_OPS' @ [120:61] ==> private final val NON_NULL_OPERAND_OPS: Set<(IElementType..IElementType?)> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'NotNull' @ [120:95] ==> enum entry NotNull defined in org.jetbrains.kotlin.j2k.ast.Nullability[FakeCallableDescriptorForObject]

'getOperandExpectedType' @ [122:39] ==> private final fun getOperandExpectedType(current: PsiExpression?, other: PsiExpression?, operationTokenType: IElementType): PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[SimpleFunctionDescriptorImpl]

'left' @ [122:62] ==> val left: PsiExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'right' @ [122:68] ==> val right: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'operationTokenType' @ [122:75] ==> val operationTokenType: IElementType defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'codeConverter' @ [123:29] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [123:43] ==> public final fun convertExpression(expression: PsiExpression?, expectedType: PsiType?, expectedNullability: Nullability? = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'left' @ [123:61] ==> val left: PsiExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'leftOperandExpectedType' @ [123:67] ==> val leftOperandExpectedType: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'expectedNullability' @ [123:92] ==> val expectedNullability: Nullability? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'codeConverter' @ [124:30] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [124:44] ==> public final fun convertExpression(expression: PsiExpression?, expectedType: PsiType?, expectedNullability: Nullability? = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'right' @ [125:17] ==> val right: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'if (leftOperandExpectedType == null)
                    getOperandExpectedType(right, left, operationTokenType)
                else
                    null' @ [126:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: PsiType?, elseBranch: PsiType?): PsiType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> PsiType?

'leftOperandExpectedType' @ [126:21] ==> val leftOperandExpectedType: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'getOperandExpectedType' @ [127:21] ==> private final fun getOperandExpectedType(current: PsiExpression?, other: PsiExpression?, operationTokenType: IElementType): PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[SimpleFunctionDescriptorImpl]

'right' @ [127:44] ==> val right: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'left' @ [127:51] ==> val left: PsiExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'operationTokenType' @ [127:57] ==> val operationTokenType: IElementType defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'expectedNullability' @ [130:17] ==> val expectedNullability: Nullability? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'if (operationTokenType == JavaTokenType.GTGTGT) {
            result = MethodCallExpression.buildNonNull(leftConverted, "ushr", ArgumentList.withNoPrototype(rightConverted))
        }
        else {
            var operator = Operator(operationTokenType)
            if (operationTokenType == JavaTokenType.EQEQ || operationTokenType == JavaTokenType.NE) {
                if (!canKeepEqEq(left, right)) {
                    operator = if (operationTokenType == JavaTokenType.EQEQ) Operator(KtTokens.EQEQEQ) else Operator(KtTokens.EXCLEQEQEQ)
                }
            }
            result = BinaryExpression(leftConverted, rightConverted, operator.assignPrototype(expression.operationSign))
            if (!expression.isInSingleLine()) {
                result = ParenthesizedExpression(result.assignNoPrototype())
            }
        }' @ [133:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'operationTokenType' @ [133:13] ==> val operationTokenType: IElementType defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'GTGTGT' @ [133:49] ==> public final val GTGTGT: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'result' @ [134:13] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'MethodCallExpression' @ [134:22] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.MethodCallExpression[FakeCallableDescriptorForObject]

'buildNonNull' @ [134:43] ==> public final fun buildNonNull(receiver: Expression?, methodName: String, argumentList: ArgumentList = ..., typeArguments: List<Type> = ..., dotPrototype: PsiElement? = ...): MethodCallExpression defined in org.jetbrains.kotlin.j2k.ast.MethodCallExpression.Companion[SimpleFunctionDescriptorImpl]

'leftConverted' @ [134:56] ==> val leftConverted: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'withNoPrototype' @ [134:92] ==> public final fun withNoPrototype(vararg arguments: Expression): ArgumentList defined in org.jetbrains.kotlin.j2k.ast.ArgumentList.Companion[SimpleFunctionDescriptorImpl]

'rightConverted' @ [134:108] ==> val rightConverted: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'Operator' @ [137:28] ==> public constructor Operator(operatorType: IElementType) defined in org.jetbrains.kotlin.j2k.ast.Operator[ClassConstructorDescriptorImpl]

'operationTokenType' @ [137:37] ==> val operationTokenType: IElementType defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'operationTokenType' @ [138:17] ==> val operationTokenType: IElementType defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'EQEQ' @ [138:53] ==> public final val EQEQ: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'operationTokenType' @ [138:61] ==> val operationTokenType: IElementType defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'NE' @ [138:97] ==> public final val NE: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'!' @ [139:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'canKeepEqEq' @ [139:22] ==> private final fun canKeepEqEq(left: PsiExpression, right: PsiExpression?): Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[SimpleFunctionDescriptorImpl]

'left' @ [139:34] ==> val left: PsiExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'right' @ [139:40] ==> val right: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'operator' @ [140:21] ==> var operator: Operator defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'if (operationTokenType == JavaTokenType.EQEQ) Operator(KtTokens.EQEQEQ) else Operator(KtTokens.EXCLEQEQEQ)' @ [140:32] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Operator, elseBranch: Operator): Operator[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Operator

'operationTokenType' @ [140:36] ==> val operationTokenType: IElementType defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'EQEQ' @ [140:72] ==> public final val EQEQ: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'Operator' @ [140:78] ==> public constructor Operator(operatorType: IElementType) defined in org.jetbrains.kotlin.j2k.ast.Operator[ClassConstructorDescriptorImpl]

'EQEQEQ' @ [140:96] ==> public final val EQEQEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'Operator' @ [140:109] ==> public constructor Operator(operatorType: IElementType) defined in org.jetbrains.kotlin.j2k.ast.Operator[ClassConstructorDescriptorImpl]

'EXCLEQEQEQ' @ [140:127] ==> public final val EXCLEQEQEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'result' @ [143:13] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'BinaryExpression' @ [143:22] ==> public constructor BinaryExpression(left: Expression, right: Expression, op: Operator) defined in org.jetbrains.kotlin.j2k.ast.BinaryExpression[ClassConstructorDescriptorImpl]

'leftConverted' @ [143:39] ==> val leftConverted: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'rightConverted' @ [143:54] ==> val rightConverted: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'operator' @ [143:70] ==> var operator: Operator defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[LocalVariableDescriptor]

'assignPrototype' @ [143:79] ==> public fun <TElement : Element> Operator.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Operator defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Operator

'expression' @ [143:95] ==> value-parameter expression: PsiBinaryExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[ValueParameterDescriptorImpl]

'operationSign' @ [143:106] ==> public final val PsiBinaryExpression.operationSign: PsiJavaToken[MyPropertyDescriptor]

'!' @ [144:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'expression' @ [144:18] ==> value-parameter expression: PsiBinaryExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitBinaryExpression[ValueParameterDescriptorImpl]

'isInSingleLine' @ [144:29] ==> public fun PsiElement.isInSingleLine(): Boolean defined in org.jetbrains.kotlin.j2k in file Utils.kt[SimpleFunctionDescriptorImpl]

'result' @ [145:17] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'ParenthesizedExpression' @ [145:26] ==> public constructor ParenthesizedExpression(expression: Expression) defined in org.jetbrains.kotlin.j2k.ast.ParenthesizedExpression[ClassConstructorDescriptorImpl]

'result' @ [145:50] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'assignNoPrototype' @ [145:57] ==> public fun <TElement : Element> Expression.assignNoPrototype(): Expression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Expression

'current' @ [151:27] ==> value-parameter current: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getOperandExpectedType[ValueParameterDescriptorImpl]

'type' @ [151:36] ==> public final val PsiExpression.type: PsiType?[MyPropertyDescriptor]

'other' @ [152:25] ==> value-parameter other: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getOperandExpectedType[ValueParameterDescriptorImpl]

'type' @ [152:32] ==> public final val PsiExpression.type: PsiType?[MyPropertyDescriptor]

'currentType' @ [153:13] ==> val currentType: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getOperandExpectedType[LocalVariableDescriptor]

'otherType' @ [153:49] ==> val otherType: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getOperandExpectedType[LocalVariableDescriptor]

'currentType' @ [154:13] ==> val currentType: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getOperandExpectedType[LocalVariableDescriptor]

'BOOLEAN' @ [154:36] ==> public final val BOOLEAN: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'otherType' @ [154:47] ==> val otherType: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getOperandExpectedType[LocalVariableDescriptor]

'BOOLEAN' @ [154:68] ==> public final val BOOLEAN: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'operationTokenType' @ [156:13] ==> value-parameter operationTokenType: IElementType defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getOperandExpectedType[ValueParameterDescriptorImpl]

'EQEQ' @ [156:49] ==> public final val EQEQ: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'operationTokenType' @ [157:16] ==> value-parameter operationTokenType: IElementType defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getOperandExpectedType[ValueParameterDescriptorImpl]

'NE' @ [157:52] ==> public final val NE: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'currentType' @ [158:16] ==> val currentType: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getOperandExpectedType[LocalVariableDescriptor]

'CHAR' @ [158:39] ==> public final val CHAR: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'currentType' @ [159:17] ==> val currentType: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getOperandExpectedType[LocalVariableDescriptor]

'otherType' @ [159:31] ==> val otherType: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getOperandExpectedType[LocalVariableDescriptor]

'otherType' @ [159:49] ==> val otherType: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getOperandExpectedType[LocalVariableDescriptor]

'when (this) {
            other -> 0
            PsiType.BYTE -> when (other) {
                PsiType.CHAR -> 1
                else -> -1
            }
            PsiType.SHORT -> when (other) {
                PsiType.CHAR,
                PsiType.BYTE -> 1
                else -> -1
            }
            PsiType.INT -> when (other) {
                PsiType.BYTE,
                PsiType.SHORT,
                PsiType.CHAR -> 1
                else -> -1
            }
            PsiType.LONG -> when (other) {
                PsiType.DOUBLE,
                PsiType.FLOAT -> -1
                else -> 1
            }
            PsiType.FLOAT -> when (other) {
                PsiType.DOUBLE -> -1
                else -> 1
            }
            PsiType.DOUBLE -> 1
            PsiType.CHAR -> -1
            else -> throw AssertionError("Unknown primitive type $this")
        }' @ [166:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Int, entry1: Int, entry2: Int, entry3: Int, entry4: Int, entry5: Int, entry6: Int, entry7: Int, entry8: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Int

'this' @ [166:22] ==> <this> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.compareTo[ReceiverParameterDescriptorImpl]

'other' @ [167:13] ==> value-parameter other: PsiPrimitiveType defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.compareTo[ValueParameterDescriptorImpl]

'BYTE' @ [168:21] ==> public final val BYTE: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'when (other) {
                PsiType.CHAR -> 1
                else -> -1
            }' @ [168:29] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Int, entry1: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Int

'other' @ [168:35] ==> value-parameter other: PsiPrimitiveType defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.compareTo[ValueParameterDescriptorImpl]

'CHAR' @ [169:25] ==> public final val CHAR: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'-' @ [170:25] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'SHORT' @ [172:21] ==> public final val SHORT: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'when (other) {
                PsiType.CHAR,
                PsiType.BYTE -> 1
                else -> -1
            }' @ [172:30] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Int, entry1: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Int

'other' @ [172:36] ==> value-parameter other: PsiPrimitiveType defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.compareTo[ValueParameterDescriptorImpl]

'CHAR' @ [173:25] ==> public final val CHAR: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'BYTE' @ [174:25] ==> public final val BYTE: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'-' @ [175:25] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'INT' @ [177:21] ==> public final val INT: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'when (other) {
                PsiType.BYTE,
                PsiType.SHORT,
                PsiType.CHAR -> 1
                else -> -1
            }' @ [177:28] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Int, entry1: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Int

'other' @ [177:34] ==> value-parameter other: PsiPrimitiveType defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.compareTo[ValueParameterDescriptorImpl]

'BYTE' @ [178:25] ==> public final val BYTE: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'SHORT' @ [179:25] ==> public final val SHORT: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'CHAR' @ [180:25] ==> public final val CHAR: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'-' @ [181:25] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'LONG' @ [183:21] ==> public final val LONG: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'when (other) {
                PsiType.DOUBLE,
                PsiType.FLOAT -> -1
                else -> 1
            }' @ [183:29] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Int, entry1: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Int

'other' @ [183:35] ==> value-parameter other: PsiPrimitiveType defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.compareTo[ValueParameterDescriptorImpl]

'DOUBLE' @ [184:25] ==> public final val DOUBLE: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'FLOAT' @ [185:25] ==> public final val FLOAT: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'-' @ [185:34] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'FLOAT' @ [188:21] ==> public final val FLOAT: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'when (other) {
                PsiType.DOUBLE -> -1
                else -> 1
            }' @ [188:30] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Int, entry1: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Int

'other' @ [188:36] ==> value-parameter other: PsiPrimitiveType defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.compareTo[ValueParameterDescriptorImpl]

'DOUBLE' @ [189:25] ==> public final val DOUBLE: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'-' @ [189:35] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'DOUBLE' @ [192:21] ==> public final val DOUBLE: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'CHAR' @ [193:21] ==> public final val CHAR: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'-' @ [193:29] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'AssertionError' @ [194:27] ==> public constructor AssertionError(p0: (Any..Any?)) defined in java.lang.AssertionError[JavaClassConstructorDescriptor]

'this' @ [194:67] ==> <this> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.compareTo[ReceiverParameterDescriptorImpl]

'left' @ [199:13] ==> value-parameter left: PsiExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.canKeepEqEq[ValueParameterDescriptorImpl]

'isNullLiteral' @ [199:18] ==> public fun PsiExpression.isNullLiteral(): Boolean defined in org.jetbrains.kotlin.j2k in file Utils.kt[SimpleFunctionDescriptorImpl]

'right' @ [199:38] ==> value-parameter right: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.canKeepEqEq[ValueParameterDescriptorImpl]

'isNullLiteral' @ [199:45] ==> public fun PsiExpression.isNullLiteral(): Boolean defined in org.jetbrains.kotlin.j2k in file Utils.kt[SimpleFunctionDescriptorImpl]

'left' @ [200:20] ==> value-parameter left: PsiExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.canKeepEqEq[ValueParameterDescriptorImpl]

'type' @ [200:25] ==> public final val PsiExpression.type: PsiType?[MyPropertyDescriptor]

'when (type) {
            is PsiPrimitiveType, is PsiArrayType -> return true

            is PsiClassType -> {
                if (right?.type is PsiPrimitiveType) return true

                val psiClass = type.resolve() ?: return false
                if (!psiClass.hasModifierProperty(PsiModifier.FINAL)) return false
                if (psiClass.isEnum) return true

                val equalsSignature = getEqualsSignature(converter.project, GlobalSearchScope.allScope(converter.project))
                val equalsMethod = MethodSignatureUtil.findMethodBySignature(psiClass, equalsSignature, true)
                if (equalsMethod != null && equalsMethod.containingClass?.qualifiedName != CommonClassNames.JAVA_LANG_OBJECT) return false

                return true
            }

            else -> return false
        }' @ [201:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Nothing, entry1: Nothing, entry2: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Nothing

'type' @ [201:15] ==> val type: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.canKeepEqEq[LocalVariableDescriptor]

'right' @ [205:21] ==> value-parameter right: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.canKeepEqEq[ValueParameterDescriptorImpl]

'type' @ [205:28] ==> public final val PsiExpression.type: PsiType?[MyPropertyDescriptor]

'type' @ [207:32] ==> val type: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.canKeepEqEq[LocalVariableDescriptor]

'resolve' @ [207:37] ==> @Nullable public abstract fun resolve(): PsiClass? defined in com.intellij.psi.PsiClassType[JavaMethodDescriptor]

'!' @ [208:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'psiClass' @ [208:22] ==> val psiClass: PsiClass defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.canKeepEqEq[LocalVariableDescriptor]

'hasModifierProperty' @ [208:31] ==> public abstract fun hasModifierProperty(@PsiModifier.ModifierConstant @NonNls @NotNull p0: String): Boolean defined in com.intellij.psi.PsiClass[JavaMethodDescriptor]

'FINAL' @ [208:63] ==> public const final val FINAL: String defined in com.intellij.psi.PsiModifier[JavaPropertyDescriptor]

'psiClass' @ [209:21] ==> val psiClass: PsiClass defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.canKeepEqEq[LocalVariableDescriptor]

'isEnum' @ [209:30] ==> public final val PsiClass.isEnum: Boolean[MyPropertyDescriptor]

'getEqualsSignature' @ [211:39] ==> private final fun getEqualsSignature(project: Project, scope: GlobalSearchScope): MethodSignature defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[SimpleFunctionDescriptorImpl]

'converter' @ [211:58] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'project' @ [211:68] ==> public final val project: Project defined in org.jetbrains.kotlin.j2k.Converter[PropertyDescriptorImpl]

'allScope' @ [211:95] ==> @NotNull public open fun allScope(@NotNull p0: Project): GlobalSearchScope defined in com.intellij.psi.search.GlobalSearchScope[JavaMethodDescriptor]

'converter' @ [211:104] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'project' @ [211:114] ==> public final val project: Project defined in org.jetbrains.kotlin.j2k.Converter[PropertyDescriptorImpl]

'findMethodBySignature' @ [212:56] ==> @Nullable public open fun findMethodBySignature(@NotNull p0: PsiClass, @NotNull p1: MethodSignature, p2: Boolean): PsiMethod? defined in com.intellij.psi.util.MethodSignatureUtil[JavaMethodDescriptor]

'psiClass' @ [212:78] ==> val psiClass: PsiClass defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.canKeepEqEq[LocalVariableDescriptor]

'equalsSignature' @ [212:88] ==> val equalsSignature: MethodSignature defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.canKeepEqEq[LocalVariableDescriptor]

'equalsMethod' @ [213:21] ==> val equalsMethod: PsiMethod? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.canKeepEqEq[LocalVariableDescriptor]

'equalsMethod' @ [213:45] ==> val equalsMethod: PsiMethod? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.canKeepEqEq[LocalVariableDescriptor]

'containingClass' @ [213:58] ==> public final val PsiMethod.containingClass: PsiClass?[MyPropertyDescriptor]

'qualifiedName' @ [213:75] ==> public final val PsiClass.qualifiedName: String?[MyPropertyDescriptor]

'JAVA_LANG_OBJECT' @ [213:109] ==> @NonNls public const final val JAVA_LANG_OBJECT: String defined in com.intellij.psi.CommonClassNames[JavaPropertyDescriptor]

'getJavaLangObject' @ [224:38] ==> @NotNull public open fun getJavaLangObject(@NotNull p0: PsiManager, @NotNull p1: GlobalSearchScope): PsiClassType defined in com.intellij.psi.PsiType[JavaMethodDescriptor]

'getInstance' @ [224:67] ==> @NotNull public open fun getInstance(@NotNull p0: Project): PsiManager defined in com.intellij.psi.PsiManager[JavaMethodDescriptor]

'project' @ [224:79] ==> value-parameter project: Project defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getEqualsSignature[ValueParameterDescriptorImpl]

'scope' @ [224:89] ==> value-parameter scope: GlobalSearchScope defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getEqualsSignature[ValueParameterDescriptorImpl]

'createMethodSignature' @ [225:36] ==> @NotNull public open fun createMethodSignature(@NonNls @NotNull p0: String, @NotNull p1: (Array<(PsiType..PsiType?)>..Array<out (PsiType..PsiType?)>), @NotNull p2: (Array<(PsiTypeParameter..PsiTypeParameter?)>..Array<out (PsiTypeParameter..PsiTypeParameter?)>), @NotNull p3: PsiSubstitutor): MethodSignature defined in com.intellij.psi.util.MethodSignatureUtil[JavaMethodDescriptor]

'arrayOf' @ [225:68] ==> public inline fun <reified @PureReifiable T> arrayOf(vararg elements: PsiType): Array<PsiType> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified @PureReifiable T> -> PsiType

'javaLangObject' @ [225:85] ==> val javaLangObject: PsiClassType defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getEqualsSignature[LocalVariableDescriptor]

'EMPTY_ARRAY' @ [225:119] ==> public final val EMPTY_ARRAY: (Array<(PsiTypeParameter..PsiTypeParameter?)>..Array<out (PsiTypeParameter..PsiTypeParameter?)>?) defined in com.intellij.psi.PsiTypeParameter[JavaPropertyDescriptor]

'EMPTY' @ [225:147] ==> @NotNull public final val EMPTY: PsiSubstitutor defined in com.intellij.psi.PsiSubstitutor[JavaPropertyDescriptor]

'setOf' @ [228:40] ==> public fun <T> setOf(vararg elements: (IElementType..IElementType?)): Set<(IElementType..IElementType?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.tree.IElementType..com.intellij.psi.tree.IElementType?)

'ANDAND' @ [229:27] ==> public final val ANDAND: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'OROR' @ [230:27] ==> public final val OROR: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'PLUS' @ [231:27] ==> public final val PLUS: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'MINUS' @ [232:27] ==> public final val MINUS: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'ASTERISK' @ [233:27] ==> public final val ASTERISK: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'DIV' @ [234:27] ==> public final val DIV: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'PERC' @ [235:27] ==> public final val PERC: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'LTLT' @ [236:27] ==> public final val LTLT: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'GTGT' @ [237:27] ==> public final val GTGT: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'GTGTGT' @ [238:27] ==> public final val GTGTGT: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'expression' @ [241:23] ==> value-parameter expression: PsiClassObjectAccessExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitClassObjectAccessExpression[ValueParameterDescriptorImpl]

'operand' @ [241:34] ==> public final val PsiClassObjectAccessExpression.operand: PsiTypeElement[MyPropertyDescriptor]

'converter' @ [242:20] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertTypeElement' @ [242:30] ==> public final fun convertTypeElement(element: PsiTypeElement?, nullability: Nullability): Type defined in org.jetbrains.kotlin.j2k.Converter[SimpleFunctionDescriptorImpl]

'operand' @ [242:49] ==> val operand: PsiTypeElement defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitClassObjectAccessExpression[LocalVariableDescriptor]

'NotNull' @ [242:70] ==> enum entry NotNull defined in org.jetbrains.kotlin.j2k.ast.Nullability[FakeCallableDescriptorForObject]

'operand' @ [243:24] ==> val operand: PsiTypeElement defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitClassObjectAccessExpression[LocalVariableDescriptor]

'type' @ [243:32] ==> public final val PsiTypeElement.type: PsiType[MyPropertyDescriptor]

'canonicalText' @ [243:37] ==> public final val PsiType.canonicalText: String[MyPropertyDescriptor]

'values' @ [244:46] ==> public final fun values(): Array<JvmPrimitiveType> defined in org.jetbrains.kotlin.resolve.jvm.JvmPrimitiveType[SimpleFunctionDescriptorImpl]

'firstOrNull' @ [244:55] ==> public inline fun <T> Array<out JvmPrimitiveType>.firstOrNull(predicate: (JvmPrimitiveType) -> Boolean): JvmPrimitiveType? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JvmPrimitiveType

'it' @ [244:69] ==> value-parameter it: JvmPrimitiveType defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitClassObjectAccessExpression.<anonymous>[ValueParameterDescriptorImpl]

'javaKeywordName' @ [244:72] ==> public final val JvmPrimitiveType.javaKeywordName: String[MyPropertyDescriptor]

'typeName' @ [244:91] ==> val typeName: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitClassObjectAccessExpression[LocalVariableDescriptor]

'typeName' @ [245:13] ==> val typeName: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitClassObjectAccessExpression[LocalVariableDescriptor]

'result' @ [246:13] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'QualifiedExpression' @ [246:22] ==> public constructor QualifiedExpression(qualifier: Expression, identifier: Expression, dotPrototype: PsiElement?) defined in org.jetbrains.kotlin.j2k.ast.QualifiedExpression[ClassConstructorDescriptorImpl]

'Identifier' @ [246:42] ==> public constructor Identifier(name: String, isNullable: Boolean = ..., quotingNeeded: Boolean = ..., imports: Collection<FqName> = ...) defined in org.jetbrains.kotlin.j2k.ast.Identifier[ClassConstructorDescriptorImpl]

'assignNoPrototype' @ [246:68] ==> public fun <TElement : Element> Identifier.assignNoPrototype(): Identifier defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Identifier

'withNoPrototype' @ [246:100] ==> public final fun withNoPrototype(name: String, isNullable: Boolean = ..., quotingNeeded: Boolean = ..., imports: Collection<FqName> = ...): Identifier defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[SimpleFunctionDescriptorImpl]

'if (primitiveType != null) {
            "javaPrimitiveType"
        }
        else {
            "java"
        }' @ [249:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'primitiveType' @ [249:24] ==> val primitiveType: JvmPrimitiveType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitClassObjectAccessExpression[LocalVariableDescriptor]

'result' @ [255:9] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'QualifiedExpression' @ [255:18] ==> public constructor QualifiedExpression(qualifier: Expression, identifier: Expression, dotPrototype: PsiElement?) defined in org.jetbrains.kotlin.j2k.ast.QualifiedExpression[ClassConstructorDescriptorImpl]

'ClassLiteralExpression' @ [255:38] ==> public constructor ClassLiteralExpression(type: Type) defined in org.jetbrains.kotlin.j2k.ast.ClassLiteralExpression[ClassConstructorDescriptorImpl]

'type' @ [255:61] ==> val type: Type defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitClassObjectAccessExpression[LocalVariableDescriptor]

'assignNoPrototype' @ [255:67] ==> public fun <TElement : Element> ClassLiteralExpression.assignNoPrototype(): ClassLiteralExpression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> ClassLiteralExpression

'withNoPrototype' @ [255:99] ==> public final fun withNoPrototype(name: String, isNullable: Boolean = ..., quotingNeeded: Boolean = ..., imports: Collection<FqName> = ...): Identifier defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[SimpleFunctionDescriptorImpl]

'name' @ [255:115] ==> val name: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitClassObjectAccessExpression[LocalVariableDescriptor]

'expression' @ [259:25] ==> value-parameter expression: PsiConditionalExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitConditionalExpression[ValueParameterDescriptorImpl]

'condition' @ [259:36] ==> public final val PsiConditionalExpression.condition: PsiExpression[MyPropertyDescriptor]

'condition' @ [260:20] ==> val condition: PsiExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitConditionalExpression[LocalVariableDescriptor]

'type' @ [260:30] ==> public final val PsiExpression.type: PsiType?[MyPropertyDescriptor]

'if (type != null)
            codeConverter.convertExpression(condition, type)
        else
            codeConverter.convertExpression(condition)' @ [261:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Expression, elseBranch: Expression): Expression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Expression

'type' @ [261:24] ==> val type: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitConditionalExpression[LocalVariableDescriptor]

'codeConverter' @ [262:13] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [262:27] ==> public final fun convertExpression(expression: PsiExpression?, expectedType: PsiType?, expectedNullability: Nullability? = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'condition' @ [262:45] ==> val condition: PsiExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitConditionalExpression[LocalVariableDescriptor]

'type' @ [262:56] ==> val type: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitConditionalExpression[LocalVariableDescriptor]

'codeConverter' @ [264:13] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [264:27] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'condition' @ [264:45] ==> val condition: PsiExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitConditionalExpression[LocalVariableDescriptor]

'result' @ [265:9] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'IfStatement' @ [265:18] ==> public constructor IfStatement(condition: Expression, thenStatement: Element, elseStatement: Element, singleLine: Boolean) defined in org.jetbrains.kotlin.j2k.ast.IfStatement[ClassConstructorDescriptorImpl]

'expr' @ [265:30] ==> val expr: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitConditionalExpression[LocalVariableDescriptor]

'codeConverter' @ [266:30] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [266:44] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'expression' @ [266:62] ==> value-parameter expression: PsiConditionalExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitConditionalExpression[ValueParameterDescriptorImpl]

'thenExpression' @ [266:73] ==> public final val PsiConditionalExpression.thenExpression: PsiExpression?[MyPropertyDescriptor]

'codeConverter' @ [267:30] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [267:44] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'expression' @ [267:62] ==> value-parameter expression: PsiConditionalExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitConditionalExpression[ValueParameterDescriptorImpl]

'elseExpression' @ [267:73] ==> public final val PsiConditionalExpression.elseExpression: PsiExpression?[MyPropertyDescriptor]

'expression' @ [268:30] ==> value-parameter expression: PsiConditionalExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitConditionalExpression[ValueParameterDescriptorImpl]

'isInSingleLine' @ [268:41] ==> public fun PsiElement.isInSingleLine(): Boolean defined in org.jetbrains.kotlin.j2k in file Utils.kt[SimpleFunctionDescriptorImpl]

'expression' @ [272:25] ==> value-parameter expression: PsiInstanceOfExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitInstanceOfExpression[ValueParameterDescriptorImpl]

'checkType' @ [272:36] ==> public final val PsiInstanceOfExpression.checkType: PsiTypeElement?[MyPropertyDescriptor]

'result' @ [273:9] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'IsOperator' @ [273:18] ==> public constructor IsOperator(expression: Expression, type: Type) defined in org.jetbrains.kotlin.j2k.ast.IsOperator[ClassConstructorDescriptorImpl]

'codeConverter' @ [273:29] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [273:43] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'expression' @ [273:61] ==> value-parameter expression: PsiInstanceOfExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitInstanceOfExpression[ValueParameterDescriptorImpl]

'operand' @ [273:72] ==> public final val PsiInstanceOfExpression.operand: PsiExpression[MyPropertyDescriptor]

'converter' @ [274:29] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertTypeElement' @ [274:39] ==> public final fun convertTypeElement(element: PsiTypeElement?, nullability: Nullability): Type defined in org.jetbrains.kotlin.j2k.Converter[SimpleFunctionDescriptorImpl]

'checkType' @ [274:58] ==> val checkType: PsiTypeElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitInstanceOfExpression[LocalVariableDescriptor]

'NotNull' @ [274:81] ==> enum entry NotNull defined in org.jetbrains.kotlin.j2k.ast.Nullability[FakeCallableDescriptorForObject]

'expression' @ [278:21] ==> value-parameter expression: PsiLiteralExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[ValueParameterDescriptorImpl]

'value' @ [278:32] ==> public final val PsiLiteralExpression.value: Any?[MyPropertyDescriptor]

'expression' @ [279:20] ==> value-parameter expression: PsiLiteralExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[ValueParameterDescriptorImpl]

'text' @ [279:31] ==> public final val PsiLiteralExpression.text: (String..String?)[MyPropertyDescriptor]

'expression' @ [280:20] ==> value-parameter expression: PsiLiteralExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[ValueParameterDescriptorImpl]

'type' @ [280:31] ==> public final val PsiLiteralExpression.type: PsiType?[MyPropertyDescriptor]

'expression' @ [282:13] ==> value-parameter expression: PsiLiteralExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[ValueParameterDescriptorImpl]

'isNullLiteral' @ [282:24] ==> public fun PsiExpression.isNullLiteral(): Boolean defined in org.jetbrains.kotlin.j2k in file Utils.kt[SimpleFunctionDescriptorImpl]

'result' @ [283:13] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'NullLiteral' @ [283:40] ==> public object NullLiteral : LiteralExpression defined in org.jetbrains.kotlin.j2k.ast.LiteralExpression[FakeCallableDescriptorForObject]

'type' @ [287:13] ==> val type: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'type' @ [288:27] ==> val type: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'canonicalText' @ [288:32] ==> public final val PsiType.canonicalText: String[MyPropertyDescriptor]

'typeStr' @ [289:17] ==> val typeStr: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'text' @ [290:17] ==> var text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'text' @ [290:24] ==> var text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'replace' @ [290:29] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'replace' @ [291:26] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'!' @ [292:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'text' @ [292:22] ==> var text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'contains' @ [292:27] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'!' @ [292:44] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'text' @ [292:45] ==> var text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'contains' @ [292:50] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'text' @ [293:21] ==> var text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'text' @ [294:21] ==> var text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'endsWith' @ [294:26] ==> public fun String.endsWith(suffix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'text' @ [295:21] ==> var text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'typeStr' @ [298:17] ==> val typeStr: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'text' @ [299:17] ==> var text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'text' @ [299:24] ==> var text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'replace' @ [299:29] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'replace' @ [300:26] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'replace' @ [301:26] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'typeStr' @ [304:17] ==> val typeStr: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'text' @ [305:17] ==> var text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'text' @ [305:24] ==> var text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'replace' @ [305:29] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'text' @ [308:46] ==> value-parameter text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression.isHexLiteral[ValueParameterDescriptorImpl]

'startsWith' @ [308:51] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'text' @ [308:71] ==> value-parameter text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression.isHexLiteral[ValueParameterDescriptorImpl]

'startsWith' @ [308:76] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'if ((typeStr == "long" || typeStr == "int") && isHexLiteral(text)) {
                val v = BigInteger(text.substring(2).replace("L", ""), 16)
                if (text.contains("L")) {
                    if (v.bitLength() > 63) {
                        text = "-0x${v.toLong().toString(16).substring(1)}L"
                    }
                }
                else {
                    if (v.bitLength() > 31) {
                        text = "-0x${v.toInt().toString(16).substring(1)}"
                    }
                }
            }
            else if (typeStr == "int" && value != null) {
                text = value.toString()
            }' @ [310:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'typeStr' @ [310:18] ==> val typeStr: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'typeStr' @ [310:39] ==> val typeStr: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'isHexLiteral' @ [310:60] ==> local final fun isHexLiteral(text: String): Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[SimpleFunctionDescriptorImpl]

'text' @ [310:73] ==> var text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'BigInteger' @ [311:25] ==> public constructor BigInteger(p0: (String..String?), p1: Int) defined in java.math.BigInteger[JavaClassConstructorDescriptor]

'text' @ [311:36] ==> var text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'substring' @ [311:41] ==> @InlineOnly public inline fun String.substring(startIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'replace' @ [311:54] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'if (text.contains("L")) {
                    if (v.bitLength() > 63) {
                        text = "-0x${v.toLong().toString(16).substring(1)}L"
                    }
                }
                else {
                    if (v.bitLength() > 31) {
                        text = "-0x${v.toInt().toString(16).substring(1)}"
                    }
                }' @ [312:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'text' @ [312:21] ==> var text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'contains' @ [312:26] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'v' @ [313:25] ==> val v: BigInteger defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'bitLength' @ [313:27] ==> public open fun bitLength(): Int defined in java.math.BigInteger[JavaMethodDescriptor]

'text' @ [314:25] ==> var text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'v' @ [314:38] ==> val v: BigInteger defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'toLong' @ [314:40] ==> public open fun toLong(): Long defined in java.math.BigInteger[JavaMethodDescriptor]

'toString' @ [314:49] ==> @SinceKotlin @InlineOnly public inline fun Long.toString(radix: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'substring' @ [314:62] ==> @InlineOnly public inline fun String.substring(startIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'v' @ [318:25] ==> val v: BigInteger defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'bitLength' @ [318:27] ==> public open fun bitLength(): Int defined in java.math.BigInteger[JavaMethodDescriptor]

'text' @ [319:25] ==> var text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'v' @ [319:38] ==> val v: BigInteger defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'toInt' @ [319:40] ==> public open fun toInt(): Int defined in java.math.BigInteger[JavaMethodDescriptor]

'toString' @ [319:48] ==> @SinceKotlin @InlineOnly public inline fun Int.toString(radix: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'substring' @ [319:61] ==> @InlineOnly public inline fun String.substring(startIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'typeStr' @ [323:22] ==> val typeStr: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'value' @ [323:42] ==> val value: Any? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'text' @ [324:17] ==> var text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'value' @ [324:24] ==> val value: Any? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'toString' @ [324:30] ==> public open fun toString(): String defined in kotlin.Any[DeserializedSimpleFunctionDescriptor]

'typeStr' @ [327:17] ==> val typeStr: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'text' @ [328:17] ==> var text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'text' @ [328:24] ==> var text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'replace' @ [328:29] ==> @InlineOnly public inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'toRegex' @ [328:62] ==> @InlineOnly public inline fun String.toRegex(): Regex defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'String' @ [329:21] ==> public companion object defined in kotlin.String[FakeCallableDescriptorForObject]

'format' @ [329:28] ==> @InlineOnly public inline fun String.Companion.format(format: String, vararg args: Any?): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'parseInt' @ [329:54] ==> public open fun parseInt(p0: (String..String?), p1: Int): Int defined in java.lang.Integer[JavaMethodDescriptor]

'it' @ [329:63] ==> value-parameter it: MatchResult defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression.<anonymous>[ValueParameterDescriptorImpl]

'groupValues' @ [329:66] ==> public abstract val groupValues: List<String> defined in kotlin.text.MatchResult[DeserializedPropertyDescriptor]

'typeStr' @ [333:17] ==> val typeStr: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'text' @ [334:17] ==> var text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'text' @ [334:24] ==> var text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'replace' @ [334:29] ==> @InlineOnly public inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'toRegex' @ [334:73] ==> @InlineOnly public inline fun String.toRegex(): Regex defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'it' @ [335:46] ==> value-parameter it: MatchResult defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression.<anonymous>[ValueParameterDescriptorImpl]

'groupValues' @ [335:49] ==> public abstract val groupValues: List<String> defined in kotlin.text.MatchResult[DeserializedPropertyDescriptor]

'if (leadingBackslashes.length % 2 == 0) {
                        String.format("%s\\u%04x", leadingBackslashes, Integer.parseInt(it.groupValues[2], 8))
                    }
                    else {
                        it.value
                    }' @ [336:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: CharSequence, elseBranch: CharSequence): CharSequence[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> CharSequence

'leadingBackslashes' @ [336:25] ==> val leadingBackslashes: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression.<anonymous>[LocalVariableDescriptor]

'length' @ [336:44] ==> public open val length: Int defined in kotlin.String[DeserializedPropertyDescriptor]

'format' @ [337:32] ==> @InlineOnly public inline fun String.Companion.format(format: String, vararg args: Any?): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'leadingBackslashes' @ [337:52] ==> val leadingBackslashes: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression.<anonymous>[LocalVariableDescriptor]

'parseInt' @ [337:80] ==> public open fun parseInt(p0: (String..String?), p1: Int): Int defined in java.lang.Integer[JavaMethodDescriptor]

'it' @ [337:89] ==> value-parameter it: MatchResult defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression.<anonymous>[ValueParameterDescriptorImpl]

'groupValues' @ [337:92] ==> public abstract val groupValues: List<String> defined in kotlin.text.MatchResult[DeserializedPropertyDescriptor]

'it' @ [340:25] ==> value-parameter it: MatchResult defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [340:28] ==> public abstract val value: String defined in kotlin.text.MatchResult[DeserializedPropertyDescriptor]

'text' @ [343:17] ==> var text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'text' @ [343:24] ==> var text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'replace' @ [343:29] ==> @InlineOnly public inline fun CharSequence.replace(regex: Regex, replacement: String): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'toRegex' @ [343:58] ==> @InlineOnly public inline fun String.toRegex(): Regex defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'result' @ [348:9] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'LiteralExpression' @ [348:18] ==> public constructor LiteralExpression(literalText: String) defined in org.jetbrains.kotlin.j2k.ast.LiteralExpression[ClassConstructorDescriptorImpl]

'text' @ [348:36] ==> var text: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLiteralExpression[LocalVariableDescriptor]

'expression' @ [352:26] ==> value-parameter expression: PsiMethodCallExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[ValueParameterDescriptorImpl]

'methodExpression' @ [352:37] ==> public final val PsiMethodCallExpression.methodExpression: PsiReferenceExpression[MyPropertyDescriptor]

'expression' @ [353:25] ==> value-parameter expression: PsiMethodCallExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[ValueParameterDescriptorImpl]

'argumentList' @ [353:36] ==> public final val PsiMethodCallExpression.argumentList: PsiExpressionList[MyPropertyDescriptor]

'expressions' @ [353:49] ==> public final val PsiExpressionList.expressions: (Array<(PsiExpression..PsiExpression?)>..Array<out (PsiExpression..PsiExpression?)>)[MyPropertyDescriptor]

'methodExpr' @ [354:25] ==> val methodExpr: PsiReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'qualifierExpression' @ [354:36] ==> public final var PsiReferenceExpression.qualifierExpression: PsiExpression?[MyPropertyDescriptor]

'methodExpr' @ [355:19] ==> val methodExpr: PsiReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'dot' @ [355:30] ==> public fun PsiReferenceExpression.dot(): PsiElement? defined in org.jetbrains.kotlin.j2k in file Utils.kt[SimpleFunctionDescriptorImpl]

'methodExpr' @ [356:22] ==> val methodExpr: PsiReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'resolve' @ [356:33] ==> @Nullable public abstract fun resolve(): PsiElement? defined in com.intellij.psi.PsiReferenceExpression[JavaMethodDescriptor]

'if (target is PsiMethod) typeConverter.methodNullability(target).isNullable(codeConverter.settings) else false' @ [357:26] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Boolean, elseBranch: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Boolean

'target' @ [357:30] ==> val target: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'typeConverter' @ [357:51] ==> private final val typeConverter: TypeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'methodNullability' @ [357:65] ==> public final fun methodNullability(method: PsiMethod): Nullability defined in org.jetbrains.kotlin.j2k.TypeConverter[SimpleFunctionDescriptorImpl]

'target' @ [357:83] ==> val target: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'isNullable' @ [357:91] ==> public fun Nullability.isNullable(settings: ConverterSettings): Boolean defined in org.jetbrains.kotlin.j2k.ast in file Types.kt[SimpleFunctionDescriptorImpl]

'codeConverter' @ [357:102] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'settings' @ [357:116] ==> public final val settings: ConverterSettings defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'convertTypeArguments' @ [358:29] ==> private final fun convertTypeArguments(call: PsiCallExpression): List<Type> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[SimpleFunctionDescriptorImpl]

'expression' @ [358:50] ==> value-parameter expression: PsiMethodCallExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[ValueParameterDescriptorImpl]

'target' @ [360:13] ==> val target: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'target' @ [361:26] ==> val target: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'kotlinOrigin' @ [361:33] ==> public abstract val kotlinOrigin: KtDeclaration? defined in org.jetbrains.kotlin.asJava.elements.KtLightMethod[DeserializedPropertyDescriptor]

'origin' @ [362:30] ==> val origin: KtDeclaration? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'getStrictParentOfType' @ [362:38] ==> public inline fun <reified T : PsiElement> PsiElement.getStrictParentOfType(): KtClassOrObject? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtClassOrObject

'when (origin) {
                is KtProperty, is KtPropertyAccessor, is KtParameter -> {
                    val property = if (origin is KtPropertyAccessor)
                        origin.parent as KtProperty
                    else
                        origin as KtNamedDeclaration
                    val parameterCount = target.parameterList.parameters.size
                    if (parameterCount == arguments.size) {
                        val propertyName = Identifier.withNoPrototype(property.name!!, isNullable)
                        val isExtension = property.isExtensionDeclaration()
                        val propertyAccess = if (isTopLevel) {
                            if (isExtension)
                                QualifiedExpression(codeConverter.convertExpression(arguments.firstOrNull(), shouldParenthesize = true), propertyName, null).assignNoPrototype()
                            else
                                propertyName
                        }
                        else if (qualifier != null) {
                            QualifiedExpression(codeConverter.convertExpression(qualifier), propertyName, dot).assignNoPrototype()
                        }
                        else {
                            propertyName
                        }

                        when (if (isExtension) parameterCount - 1 else parameterCount) {
                            0 /* getter */ -> {
                                result = propertyAccess
                                return
                            }

                            1 /* setter */ -> {
                                val argument = codeConverter.convertExpression(arguments[if (isExtension) 1 else 0])
                                result = AssignmentExpression(propertyAccess, argument, Operator.EQ)
                                return
                            }
                        }
                    }
                }
                is KtFunction -> if (isTopLevel) {
                    result = if (origin.isExtensionDeclaration()) {
                        val qualifier = codeConverter.convertExpression(arguments.firstOrNull(), shouldParenthesize = true)
                        MethodCallExpression.build(qualifier,
                                                   origin.name!!,
                                                   convertArguments(expression, isExtension = true),
                                                   typeArguments,
                                                   isNullable,
                                                   dot)
                    }
                    else {
                        MethodCallExpression.build(null,
                                                   origin.name!!,
                                                   convertArguments(expression),
                                                   typeArguments,
                                                   isNullable)
                    }
                    return
                }
                null -> {
                    val resolvedQualifier = (methodExpr.qualifier as? PsiReferenceExpression)?.resolve()
                    if (isFacadeClassFromLibrary(resolvedQualifier)) {
                        result = if (target.isKotlinExtensionFunction()) {
                            val qualifier = codeConverter.convertExpression(arguments.firstOrNull(), shouldParenthesize = true)
                            MethodCallExpression.build(qualifier,
                                                       methodExpr.referenceName!!,
                                                       convertArguments(expression, isExtension = true),
                                                       typeArguments,
                                                       isNullable,
                                                       dot)
                        }
                        else {
                            MethodCallExpression.build(null,
                                                       methodExpr.referenceName!!,
                                                       convertArguments(expression),
                                                       typeArguments,
                                                       isNullable)
                        }
                        return
                    }
                }
            }' @ [363:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'origin' @ [363:19] ==> val origin: KtDeclaration? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'if (origin is KtPropertyAccessor)
                        origin.parent as KtProperty
                    else
                        origin as KtNamedDeclaration' @ [365:36] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtNamedDeclaration, elseBranch: KtNamedDeclaration): KtNamedDeclaration[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtNamedDeclaration

'origin' @ [365:40] ==> val origin: KtDeclaration? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'origin' @ [366:25] ==> val origin: KtDeclaration? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'parent' @ [366:32] ==> public final val KtPropertyAccessor.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'origin' @ [368:25] ==> val origin: KtDeclaration? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'target' @ [369:42] ==> val target: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'parameterList' @ [369:49] ==> public final val KtLightMethod.parameterList: PsiParameterList[MyPropertyDescriptor]

'parameters' @ [369:63] ==> public final val PsiParameterList.parameters: (Array<(PsiParameter..PsiParameter?)>..Array<out (PsiParameter..PsiParameter?)>)[MyPropertyDescriptor]

'size' @ [369:74] ==> public final val size: Int defined in kotlin.Array[DeserializedPropertyDescriptor]

'parameterCount' @ [370:25] ==> val parameterCount: Int defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'arguments' @ [370:43] ==> val arguments: (Array<(PsiExpression..PsiExpression?)>..Array<out (PsiExpression..PsiExpression?)>) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'size' @ [370:53] ==> public final val size: Int defined in kotlin.Array[DeserializedPropertyDescriptor]

'Identifier' @ [371:44] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.Identifier[FakeCallableDescriptorForObject]

'withNoPrototype' @ [371:55] ==> public final fun withNoPrototype(name: String, isNullable: Boolean = ..., quotingNeeded: Boolean = ..., imports: Collection<FqName> = ...): Identifier defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[SimpleFunctionDescriptorImpl]

'property' @ [371:71] ==> val property: KtNamedDeclaration defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'name' @ [371:80] ==> public final val KtNamedDeclaration.name: String?[MyPropertyDescriptor]

'isNullable' @ [371:88] ==> val isNullable: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'property' @ [372:43] ==> val property: KtNamedDeclaration defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'isExtensionDeclaration' @ [372:52] ==> public fun PsiElement.isExtensionDeclaration(): Boolean defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'if (isTopLevel) {
                            if (isExtension)
                                QualifiedExpression(codeConverter.convertExpression(arguments.firstOrNull(), shouldParenthesize = true), propertyName, null).assignNoPrototype()
                            else
                                propertyName
                        }
                        else if (qualifier != null) {
                            QualifiedExpression(codeConverter.convertExpression(qualifier), propertyName, dot).assignNoPrototype()
                        }
                        else {
                            propertyName
                        }' @ [373:46] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Expression, elseBranch: Expression): Expression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Expression

'isTopLevel' @ [373:50] ==> val isTopLevel: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'if (isExtension)
                                QualifiedExpression(codeConverter.convertExpression(arguments.firstOrNull(), shouldParenthesize = true), propertyName, null).assignNoPrototype()
                            else
                                propertyName' @ [374:29] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Expression, elseBranch: Expression): Expression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Expression

'isExtension' @ [374:33] ==> val isExtension: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'QualifiedExpression' @ [375:33] ==> public constructor QualifiedExpression(qualifier: Expression, identifier: Expression, dotPrototype: PsiElement?) defined in org.jetbrains.kotlin.j2k.ast.QualifiedExpression[ClassConstructorDescriptorImpl]

'codeConverter' @ [375:53] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [375:67] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'arguments' @ [375:85] ==> val arguments: (Array<(PsiExpression..PsiExpression?)>..Array<out (PsiExpression..PsiExpression?)>) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'firstOrNull' @ [375:95] ==> public fun <T> Array<out (PsiExpression..PsiExpression?)>.firstOrNull(): PsiExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiExpression..com.intellij.psi.PsiExpression?)

'propertyName' @ [375:138] ==> val propertyName: Identifier defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'assignNoPrototype' @ [375:158] ==> public fun <TElement : Element> QualifiedExpression.assignNoPrototype(): QualifiedExpression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> QualifiedExpression

'propertyName' @ [377:33] ==> val propertyName: Identifier defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'if (qualifier != null) {
                            QualifiedExpression(codeConverter.convertExpression(qualifier), propertyName, dot).assignNoPrototype()
                        }
                        else {
                            propertyName
                        }' @ [379:30] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Expression, elseBranch: Expression): Expression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Expression

'qualifier' @ [379:34] ==> val qualifier: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'QualifiedExpression' @ [380:29] ==> public constructor QualifiedExpression(qualifier: Expression, identifier: Expression, dotPrototype: PsiElement?) defined in org.jetbrains.kotlin.j2k.ast.QualifiedExpression[ClassConstructorDescriptorImpl]

'codeConverter' @ [380:49] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [380:63] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'qualifier' @ [380:81] ==> val qualifier: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'propertyName' @ [380:93] ==> val propertyName: Identifier defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'dot' @ [380:107] ==> val dot: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'assignNoPrototype' @ [380:112] ==> public fun <TElement : Element> QualifiedExpression.assignNoPrototype(): QualifiedExpression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> QualifiedExpression

'propertyName' @ [383:29] ==> val propertyName: Identifier defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'when (if (isExtension) parameterCount - 1 else parameterCount) {
                            0 /* getter */ -> {
                                result = propertyAccess
                                return
                            }

                            1 /* setter */ -> {
                                val argument = codeConverter.convertExpression(arguments[if (isExtension) 1 else 0])
                                result = AssignmentExpression(propertyAccess, argument, Operator.EQ)
                                return
                            }
                        }' @ [386:25] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Nothing, entry1: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Nothing

'if (isExtension) parameterCount - 1 else parameterCount' @ [386:31] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Int, elseBranch: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Int

'isExtension' @ [386:35] ==> val isExtension: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'parameterCount' @ [386:48] ==> val parameterCount: Int defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'parameterCount' @ [386:72] ==> val parameterCount: Int defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'result' @ [388:33] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'propertyAccess' @ [388:42] ==> val propertyAccess: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'codeConverter' @ [393:48] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [393:62] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'arguments' @ [393:80] ==> val arguments: (Array<(PsiExpression..PsiExpression?)>..Array<out (PsiExpression..PsiExpression?)>) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'if (isExtension) 1 else 0' @ [393:90] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Int, elseBranch: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Int

'isExtension' @ [393:94] ==> val isExtension: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'result' @ [394:33] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'AssignmentExpression' @ [394:42] ==> public constructor AssignmentExpression(left: Expression, right: Expression, op: Operator) defined in org.jetbrains.kotlin.j2k.ast.AssignmentExpression[ClassConstructorDescriptorImpl]

'propertyAccess' @ [394:63] ==> val propertyAccess: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'argument' @ [394:79] ==> val argument: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'EQ' @ [394:98] ==> public final val EQ: Operator defined in org.jetbrains.kotlin.j2k.ast.Operator.Companion[PropertyDescriptorImpl]

'isTopLevel' @ [400:38] ==> val isTopLevel: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'result' @ [401:21] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'if (origin.isExtensionDeclaration()) {
                        val qualifier = codeConverter.convertExpression(arguments.firstOrNull(), shouldParenthesize = true)
                        MethodCallExpression.build(qualifier,
                                                   origin.name!!,
                                                   convertArguments(expression, isExtension = true),
                                                   typeArguments,
                                                   isNullable,
                                                   dot)
                    }
                    else {
                        MethodCallExpression.build(null,
                                                   origin.name!!,
                                                   convertArguments(expression),
                                                   typeArguments,
                                                   isNullable)
                    }' @ [401:30] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Expression, elseBranch: Expression): Expression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Expression

'origin' @ [401:34] ==> val origin: KtDeclaration? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'isExtensionDeclaration' @ [401:41] ==> public fun PsiElement.isExtensionDeclaration(): Boolean defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'codeConverter' @ [402:41] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [402:55] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'arguments' @ [402:73] ==> val arguments: (Array<(PsiExpression..PsiExpression?)>..Array<out (PsiExpression..PsiExpression?)>) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'firstOrNull' @ [402:83] ==> public fun <T> Array<out (PsiExpression..PsiExpression?)>.firstOrNull(): PsiExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiExpression..com.intellij.psi.PsiExpression?)

'build' @ [403:46] ==> public final fun build(receiver: Expression?, methodName: String, argumentList: ArgumentList, typeArguments: List<Type>, isNullable: Boolean, dotPrototype: PsiElement? = ...): MethodCallExpression defined in org.jetbrains.kotlin.j2k.ast.MethodCallExpression.Companion[SimpleFunctionDescriptorImpl]

'qualifier' @ [403:52] ==> val qualifier: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'origin' @ [404:52] ==> val origin: KtDeclaration? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'name' @ [404:59] ==> public final val KtFunction.name: String?[MyPropertyDescriptor]

'convertArguments' @ [405:52] ==> private final fun convertArguments(expression: PsiCallExpression, isExtension: Boolean = ...): ArgumentList defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[SimpleFunctionDescriptorImpl]

'expression' @ [405:69] ==> value-parameter expression: PsiMethodCallExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[ValueParameterDescriptorImpl]

'typeArguments' @ [406:52] ==> val typeArguments: List<Type> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'isNullable' @ [407:52] ==> val isNullable: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'dot' @ [408:52] ==> val dot: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'build' @ [411:46] ==> public final fun build(receiver: Expression?, methodName: String, argumentList: ArgumentList, typeArguments: List<Type>, isNullable: Boolean, dotPrototype: PsiElement? = ...): MethodCallExpression defined in org.jetbrains.kotlin.j2k.ast.MethodCallExpression.Companion[SimpleFunctionDescriptorImpl]

'origin' @ [412:52] ==> val origin: KtDeclaration? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'name' @ [412:59] ==> public final val KtFunction.name: String?[MyPropertyDescriptor]

'convertArguments' @ [413:52] ==> private final fun convertArguments(expression: PsiCallExpression, isExtension: Boolean = ...): ArgumentList defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[SimpleFunctionDescriptorImpl]

'expression' @ [413:69] ==> value-parameter expression: PsiMethodCallExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[ValueParameterDescriptorImpl]

'typeArguments' @ [414:52] ==> val typeArguments: List<Type> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'isNullable' @ [415:52] ==> val isNullable: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'methodExpr' @ [420:46] ==> val methodExpr: PsiReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'qualifier' @ [420:57] ==> public final val PsiReferenceExpression.qualifier: PsiElement?[MyPropertyDescriptor]

'resolve' @ [420:96] ==> @Nullable public abstract fun resolve(): PsiElement? defined in com.intellij.psi.PsiReferenceExpression[JavaMethodDescriptor]

'isFacadeClassFromLibrary' @ [421:25] ==> public fun isFacadeClassFromLibrary(element: PsiElement?): Boolean defined in org.jetbrains.kotlin.j2k in file Utils.kt[SimpleFunctionDescriptorImpl]

'resolvedQualifier' @ [421:50] ==> val resolvedQualifier: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'result' @ [422:25] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'if (target.isKotlinExtensionFunction()) {
                            val qualifier = codeConverter.convertExpression(arguments.firstOrNull(), shouldParenthesize = true)
                            MethodCallExpression.build(qualifier,
                                                       methodExpr.referenceName!!,
                                                       convertArguments(expression, isExtension = true),
                                                       typeArguments,
                                                       isNullable,
                                                       dot)
                        }
                        else {
                            MethodCallExpression.build(null,
                                                       methodExpr.referenceName!!,
                                                       convertArguments(expression),
                                                       typeArguments,
                                                       isNullable)
                        }' @ [422:34] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Expression, elseBranch: Expression): Expression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Expression

'target' @ [422:38] ==> val target: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'isKotlinExtensionFunction' @ [422:45] ==> private final fun KtLightMethod.isKotlinExtensionFunction(): Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[SimpleFunctionDescriptorImpl]

'codeConverter' @ [423:45] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [423:59] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'arguments' @ [423:77] ==> val arguments: (Array<(PsiExpression..PsiExpression?)>..Array<out (PsiExpression..PsiExpression?)>) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'firstOrNull' @ [423:87] ==> public fun <T> Array<out (PsiExpression..PsiExpression?)>.firstOrNull(): PsiExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiExpression..com.intellij.psi.PsiExpression?)

'build' @ [424:50] ==> public final fun build(receiver: Expression?, methodName: String, argumentList: ArgumentList, typeArguments: List<Type>, isNullable: Boolean, dotPrototype: PsiElement? = ...): MethodCallExpression defined in org.jetbrains.kotlin.j2k.ast.MethodCallExpression.Companion[SimpleFunctionDescriptorImpl]

'qualifier' @ [424:56] ==> val qualifier: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'methodExpr' @ [425:56] ==> val methodExpr: PsiReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'referenceName' @ [425:67] ==> public final val PsiReferenceExpression.referenceName: String?[MyPropertyDescriptor]

'convertArguments' @ [426:56] ==> private final fun convertArguments(expression: PsiCallExpression, isExtension: Boolean = ...): ArgumentList defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[SimpleFunctionDescriptorImpl]

'expression' @ [426:73] ==> value-parameter expression: PsiMethodCallExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[ValueParameterDescriptorImpl]

'typeArguments' @ [427:56] ==> val typeArguments: List<Type> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'isNullable' @ [428:56] ==> val isNullable: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'dot' @ [429:56] ==> val dot: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'build' @ [432:50] ==> public final fun build(receiver: Expression?, methodName: String, argumentList: ArgumentList, typeArguments: List<Type>, isNullable: Boolean, dotPrototype: PsiElement? = ...): MethodCallExpression defined in org.jetbrains.kotlin.j2k.ast.MethodCallExpression.Companion[SimpleFunctionDescriptorImpl]

'methodExpr' @ [433:56] ==> val methodExpr: PsiReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'referenceName' @ [433:67] ==> public final val PsiReferenceExpression.referenceName: String?[MyPropertyDescriptor]

'convertArguments' @ [434:56] ==> private final fun convertArguments(expression: PsiCallExpression, isExtension: Boolean = ...): ArgumentList defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[SimpleFunctionDescriptorImpl]

'expression' @ [434:73] ==> value-parameter expression: PsiMethodCallExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[ValueParameterDescriptorImpl]

'typeArguments' @ [435:56] ==> val typeArguments: List<Type> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'isNullable' @ [436:56] ==> val isNullable: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'target' @ [444:13] ==> val target: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'SpecialMethod' @ [445:33] ==> public companion object defined in org.jetbrains.kotlin.j2k.SpecialMethod[FakeCallableDescriptorForObject]

'match' @ [445:47] ==> public final fun match(method: PsiMethod, argumentCount: Int, services: JavaToKotlinConverterServices): SpecialMethod? defined in org.jetbrains.kotlin.j2k.SpecialMethod.Companion[SimpleFunctionDescriptorImpl]

'target' @ [445:53] ==> val target: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'arguments' @ [445:61] ==> val arguments: (Array<(PsiExpression..PsiExpression?)>..Array<out (PsiExpression..PsiExpression?)>) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'size' @ [445:71] ==> public final val size: Int defined in kotlin.Array[DeserializedPropertyDescriptor]

'converter' @ [445:77] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'services' @ [445:87] ==> public final val services: JavaToKotlinConverterServices defined in org.jetbrains.kotlin.j2k.Converter[PropertyDescriptorImpl]

'specialMethod' @ [446:17] ==> val specialMethod: SpecialMethod? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'expression' @ [447:28] ==> value-parameter expression: PsiMethodCallExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[ValueParameterDescriptorImpl]

'argumentList' @ [447:39] ==> public final val PsiMethodCallExpression.argumentList: PsiExpressionList[MyPropertyDescriptor]

'lPar' @ [447:52] ==> public fun PsiExpressionList.lPar(): PsiElement? defined in org.jetbrains.kotlin.j2k in file Utils.kt[SimpleFunctionDescriptorImpl]

'expression' @ [448:28] ==> value-parameter expression: PsiMethodCallExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[ValueParameterDescriptorImpl]

'argumentList' @ [448:39] ==> public final val PsiMethodCallExpression.argumentList: PsiExpressionList[MyPropertyDescriptor]

'rPar' @ [448:52] ==> public fun PsiExpressionList.rPar(): PsiElement? defined in org.jetbrains.kotlin.j2k in file Utils.kt[SimpleFunctionDescriptorImpl]

'SpecialMethod' @ [449:28] ==> public companion object defined in org.jetbrains.kotlin.j2k.SpecialMethod[FakeCallableDescriptorForObject]

'ConvertCallData' @ [449:42] ==> public constructor ConvertCallData(qualifier: PsiExpression?, @Suppress arguments: List<PsiExpression>, typeArgumentsConverted: List<Type>, dot: PsiElement?, lPar: PsiElement?, rPar: PsiElement?, codeConverter: CodeConverter) defined in org.jetbrains.kotlin.j2k.SpecialMethod.ConvertCallData[ClassConstructorDescriptorImpl]

'qualifier' @ [449:58] ==> val qualifier: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'arguments' @ [449:69] ==> val arguments: (Array<(PsiExpression..PsiExpression?)>..Array<out (PsiExpression..PsiExpression?)>) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'asList' @ [449:79] ==> public fun <T> Array<out (PsiExpression..PsiExpression?)>.asList(): List<(PsiExpression..PsiExpression?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiExpression..com.intellij.psi.PsiExpression?)

'typeArguments' @ [449:89] ==> val typeArguments: List<Type> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'dot' @ [449:104] ==> val dot: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'lPar' @ [449:109] ==> val lPar: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'rPar' @ [449:115] ==> val rPar: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'codeConverter' @ [449:121] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'specialMethod' @ [450:33] ==> val specialMethod: SpecialMethod? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'convertCall' @ [450:47] ==> @JvmName public final fun convertCall(data: SpecialMethod.ConvertCallData): Expression? defined in org.jetbrains.kotlin.j2k.SpecialMethod[SimpleFunctionDescriptorImpl]

'data' @ [450:59] ==> val data: SpecialMethod.ConvertCallData defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'converted' @ [451:21] ==> val converted: Expression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'result' @ [452:21] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'converted' @ [452:30] ==> val converted: Expression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'codeConverter' @ [463:32] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [463:46] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'methodExpr' @ [463:64] ==> val methodExpr: PsiReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'result' @ [464:9] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'MethodCallExpression' @ [464:18] ==> public constructor MethodCallExpression(methodExpression: Expression, argumentList: ArgumentList, typeArguments: List<Type>, isNullable: Boolean) defined in org.jetbrains.kotlin.j2k.ast.MethodCallExpression[ClassConstructorDescriptorImpl]

'methodExpression' @ [464:39] ==> val methodExpression: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'convertArguments' @ [465:39] ==> private final fun convertArguments(expression: PsiCallExpression, isExtension: Boolean = ...): ArgumentList defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[SimpleFunctionDescriptorImpl]

'expression' @ [465:56] ==> value-parameter expression: PsiMethodCallExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[ValueParameterDescriptorImpl]

'typeArguments' @ [466:39] ==> val typeArguments: List<Type> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'isNullable' @ [467:39] ==> val isNullable: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'assignPrototypesFrom' @ [467:51] ==> public fun <TElement : Element> MethodCallExpression.assignPrototypesFrom(element: Element, inheritance: CommentsAndSpacesInheritance? = ...): MethodCallExpression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> MethodCallExpression

'methodExpression' @ [467:72] ==> val methodExpression: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'methodExpression' @ [468:9] ==> val methodExpression: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodCallExpression[LocalVariableDescriptor]

'assignNoPrototype' @ [468:26] ==> public fun <TElement : Element> Expression.assignNoPrototype(): Expression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Expression

'this' @ [472:22] ==> <this> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.isKotlinExtensionFunction[ReceiverParameterDescriptorImpl]

'kotlinOrigin' @ [472:27] ==> public abstract val kotlinOrigin: KtDeclaration? defined in org.jetbrains.kotlin.asJava.elements.KtLightMethod[DeserializedPropertyDescriptor]

'origin' @ [473:13] ==> val origin: KtDeclaration? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.isKotlinExtensionFunction[LocalVariableDescriptor]

'origin' @ [473:36] ==> val origin: KtDeclaration? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.isKotlinExtensionFunction[LocalVariableDescriptor]

'isExtensionDeclaration' @ [473:43] ==> public fun PsiElement.isExtensionDeclaration(): Boolean defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'parameterList' @ [475:26] ==> public final val KtLightMethod.parameterList: PsiParameterList[MyPropertyDescriptor]

'parameters' @ [475:40] ==> public final val PsiParameterList.parameters: (Array<(PsiParameter..PsiParameter?)>..Array<out (PsiParameter..PsiParameter?)>)[MyPropertyDescriptor]

'parameters' @ [476:16] ==> val parameters: (Array<(PsiParameter..PsiParameter?)>..Array<out (PsiParameter..PsiParameter?)>) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.isKotlinExtensionFunction[LocalVariableDescriptor]

'size' @ [476:27] ==> public final val size: Int defined in kotlin.Array[DeserializedPropertyDescriptor]

'parameters' @ [476:39] ==> val parameters: (Array<(PsiParameter..PsiParameter?)>..Array<out (PsiParameter..PsiParameter?)>) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.isKotlinExtensionFunction[LocalVariableDescriptor]

'name' @ [476:53] ==> public final val PsiParameter.name: String?[MyPropertyDescriptor]

'call' @ [480:24] ==> value-parameter call: PsiCallExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertTypeArguments[ValueParameterDescriptorImpl]

'typeArguments' @ [480:29] ==> public final val PsiCallExpression.typeArguments: (Array<(PsiType..PsiType?)>..Array<out (PsiType..PsiType?)>)[MyPropertyDescriptor]

'toList' @ [480:43] ==> public fun <T> Array<out (PsiType..PsiType?)>.toList(): List<(PsiType..PsiType?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiType..com.intellij.psi.PsiType?)

'typeArgs' @ [483:13] ==> var typeArgs: List<(PsiType..PsiType?)> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertTypeArguments[LocalVariableDescriptor]

'size' @ [483:22] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'call' @ [484:27] ==> value-parameter call: PsiCallExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertTypeArguments[ValueParameterDescriptorImpl]

'resolveMethodGenerics' @ [484:32] ==> @NotNull public abstract fun resolveMethodGenerics(): JavaResolveResult defined in com.intellij.psi.PsiCallExpression[JavaMethodDescriptor]

'resolve' @ [485:17] ==> val resolve: JavaResolveResult defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertTypeArguments[LocalVariableDescriptor]

'isValidResult' @ [485:25] ==> public final val JavaResolveResult.isValidResult: Boolean[MyPropertyDescriptor]

'resolve' @ [486:30] ==> val resolve: JavaResolveResult defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertTypeArguments[LocalVariableDescriptor]

'element' @ [486:38] ==> public final val JavaResolveResult.element: PsiElement?[MyPropertyDescriptor]

'method' @ [487:21] ==> val method: PsiMethod? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertTypeArguments[LocalVariableDescriptor]

'method' @ [488:42] ==> val method: PsiMethod? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertTypeArguments[LocalVariableDescriptor]

'typeParameters' @ [488:49] ==> public final val PsiMethod.typeParameters: (Array<(PsiTypeParameter..PsiTypeParameter?)>..Array<out (PsiTypeParameter..PsiTypeParameter?)>)[MyPropertyDescriptor]

'typeParameters' @ [489:25] ==> val typeParameters: (Array<(PsiTypeParameter..PsiTypeParameter?)>..Array<out (PsiTypeParameter..PsiTypeParameter?)>) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertTypeArguments[LocalVariableDescriptor]

'isNotEmpty' @ [489:40] ==> @InlineOnly public inline fun <T> Array<out (PsiTypeParameter..PsiTypeParameter?)>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiTypeParameter..com.intellij.psi.PsiTypeParameter?)

'resolve' @ [490:35] ==> val resolve: JavaResolveResult defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertTypeArguments[LocalVariableDescriptor]

'substitutor' @ [490:43] ==> public final val JavaResolveResult.substitutor: PsiSubstitutor[MyPropertyDescriptor]

'substitutionMap' @ [490:55] ==> public final val PsiSubstitutor.substitutionMap: (MutableMap<(PsiTypeParameter..PsiTypeParameter?), (PsiType..PsiType?)>..Map<(PsiTypeParameter..PsiTypeParameter?), (PsiType..PsiType?)>)[MyPropertyDescriptor]

'typeArgs' @ [491:25] ==> var typeArgs: List<(PsiType..PsiType?)> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertTypeArguments[LocalVariableDescriptor]

'typeParameters' @ [491:36] ==> val typeParameters: (Array<(PsiTypeParameter..PsiTypeParameter?)>..Array<out (PsiTypeParameter..PsiTypeParameter?)>) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertTypeArguments[LocalVariableDescriptor]

'map' @ [491:51] ==> public inline fun <T, R> Array<out (PsiTypeParameter..PsiTypeParameter?)>.map(transform: ((PsiTypeParameter..PsiTypeParameter?)) -> PsiType): List<PsiType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiTypeParameter..com.intellij.psi.PsiTypeParameter?)
    <R> -> PsiType

'map' @ [491:57] ==> val map: (MutableMap<(PsiTypeParameter..PsiTypeParameter?), (PsiType..PsiType?)>..Map<(PsiTypeParameter..PsiTypeParameter?), (PsiType..PsiType?)>) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertTypeArguments[LocalVariableDescriptor]

'it' @ [491:61] ==> value-parameter it: (PsiTypeParameter..PsiTypeParameter?) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertTypeArguments.<anonymous>[ValueParameterDescriptorImpl]

'listOf' @ [491:75] ==> @InlineOnly public inline fun <T> listOf(): List<Type> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Type

'typeArgs' @ [497:16] ==> var typeArgs: List<(PsiType..PsiType?)> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertTypeArguments[LocalVariableDescriptor]

'map' @ [497:25] ==> public inline fun <T, R> Iterable<(PsiType..PsiType?)>.map(transform: ((PsiType..PsiType?)) -> Type): List<Type> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiType..com.intellij.psi.PsiType?)
    <R> -> Type

'typeConverter' @ [497:31] ==> private final val typeConverter: TypeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertType' @ [497:45] ==> public final fun convertType(type: PsiType?, nullability: Nullability = ..., mutability: Mutability = ..., inAnnotationType: Boolean = ...): Type defined in org.jetbrains.kotlin.j2k.TypeConverter[SimpleFunctionDescriptorImpl]

'it' @ [497:57] ==> value-parameter it: (PsiType..PsiType?) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertTypeArguments.<anonymous>[ValueParameterDescriptorImpl]

'expression' @ [501:20] ==> value-parameter expression: PsiNewExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[ValueParameterDescriptorImpl]

'type' @ [501:31] ==> public final val PsiNewExpression.type: PsiType?[MyPropertyDescriptor]

'if (expression.arrayInitializer != null) {
            result = codeConverter.convertExpression(expression.arrayInitializer)
        }
        else if (expression.arrayDimensions.size > 0 && expression.type is PsiArrayType) {
            result = ArrayWithoutInitializationExpression(
                    typeConverter.convertType(expression.type, Nullability.NotNull) as ArrayType,
                    codeConverter.convertExpressionsInList(expression.arrayDimensions.asList()))
        }
        else {
            if (type?.canonicalText in PsiPrimitiveType.getAllBoxedTypeNames()) {
                val argument = expression.argumentList?.expressions?.singleOrNull()
                if (argument != null && argument.type is PsiPrimitiveType) {
                    result = codeConverter.convertExpression(argument)
                    return
                }
            }

            val qualifier = expression.qualifier
            val classRef = expression.classOrAnonymousClassReference
            val classRefConverted = if (classRef != null) converter.convertCodeReferenceElement(classRef, hasExternalQualifier = qualifier != null) else null

            val anonymousClass = expression.anonymousClass?.let { converter.convertAnonymousClassBody(it) }
            if (isFunctionType(expression.type)) {
                val function = anonymousClass?.body?.members?.singleOrNull() as? Function
                if (function != null) {
                    result = AnonymousFunction(function.returnType.toNotNullType(), function.typeParameterList, function.parameterList, function.body)
                    return
                }
            }
            result = NewClassExpression(classRefConverted,
                                        convertArguments(expression),
                                        codeConverter.convertExpression(qualifier),
                                        anonymousClass)
        }' @ [502:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'expression' @ [502:13] ==> value-parameter expression: PsiNewExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[ValueParameterDescriptorImpl]

'arrayInitializer' @ [502:24] ==> public final val PsiNewExpression.arrayInitializer: PsiArrayInitializerExpression?[MyPropertyDescriptor]

'result' @ [503:13] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'codeConverter' @ [503:22] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [503:36] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'expression' @ [503:54] ==> value-parameter expression: PsiNewExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[ValueParameterDescriptorImpl]

'arrayInitializer' @ [503:65] ==> public final val PsiNewExpression.arrayInitializer: PsiArrayInitializerExpression?[MyPropertyDescriptor]

'if (expression.arrayDimensions.size > 0 && expression.type is PsiArrayType) {
            result = ArrayWithoutInitializationExpression(
                    typeConverter.convertType(expression.type, Nullability.NotNull) as ArrayType,
                    codeConverter.convertExpressionsInList(expression.arrayDimensions.asList()))
        }
        else {
            if (type?.canonicalText in PsiPrimitiveType.getAllBoxedTypeNames()) {
                val argument = expression.argumentList?.expressions?.singleOrNull()
                if (argument != null && argument.type is PsiPrimitiveType) {
                    result = codeConverter.convertExpression(argument)
                    return
                }
            }

            val qualifier = expression.qualifier
            val classRef = expression.classOrAnonymousClassReference
            val classRefConverted = if (classRef != null) converter.convertCodeReferenceElement(classRef, hasExternalQualifier = qualifier != null) else null

            val anonymousClass = expression.anonymousClass?.let { converter.convertAnonymousClassBody(it) }
            if (isFunctionType(expression.type)) {
                val function = anonymousClass?.body?.members?.singleOrNull() as? Function
                if (function != null) {
                    result = AnonymousFunction(function.returnType.toNotNullType(), function.typeParameterList, function.parameterList, function.body)
                    return
                }
            }
            result = NewClassExpression(classRefConverted,
                                        convertArguments(expression),
                                        codeConverter.convertExpression(qualifier),
                                        anonymousClass)
        }' @ [505:14] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'expression' @ [505:18] ==> value-parameter expression: PsiNewExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[ValueParameterDescriptorImpl]

'arrayDimensions' @ [505:29] ==> public final val PsiNewExpression.arrayDimensions: (Array<(PsiExpression..PsiExpression?)>..Array<out (PsiExpression..PsiExpression?)>)[MyPropertyDescriptor]

'size' @ [505:45] ==> public final val size: Int defined in kotlin.Array[DeserializedPropertyDescriptor]

'expression' @ [505:57] ==> value-parameter expression: PsiNewExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[ValueParameterDescriptorImpl]

'type' @ [505:68] ==> public final val PsiNewExpression.type: PsiType?[MyPropertyDescriptor]

'result' @ [506:13] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'ArrayWithoutInitializationExpression' @ [506:22] ==> public constructor ArrayWithoutInitializationExpression(type: ArrayType, expressions: List<Expression>) defined in org.jetbrains.kotlin.j2k.ast.ArrayWithoutInitializationExpression[ClassConstructorDescriptorImpl]

'typeConverter' @ [507:21] ==> private final val typeConverter: TypeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertType' @ [507:35] ==> public final fun convertType(type: PsiType?, nullability: Nullability = ..., mutability: Mutability = ..., inAnnotationType: Boolean = ...): Type defined in org.jetbrains.kotlin.j2k.TypeConverter[SimpleFunctionDescriptorImpl]

'expression' @ [507:47] ==> value-parameter expression: PsiNewExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[ValueParameterDescriptorImpl]

'type' @ [507:58] ==> public final val PsiNewExpression.type: PsiType?[MyPropertyDescriptor]

'NotNull' @ [507:76] ==> enum entry NotNull defined in org.jetbrains.kotlin.j2k.ast.Nullability[FakeCallableDescriptorForObject]

'codeConverter' @ [508:21] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpressionsInList' @ [508:35] ==> public final fun convertExpressionsInList(expressions: List<PsiExpression>): List<Expression> defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'expression' @ [508:60] ==> value-parameter expression: PsiNewExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[ValueParameterDescriptorImpl]

'arrayDimensions' @ [508:71] ==> public final val PsiNewExpression.arrayDimensions: (Array<(PsiExpression..PsiExpression?)>..Array<out (PsiExpression..PsiExpression?)>)[MyPropertyDescriptor]

'asList' @ [508:87] ==> public fun <T> Array<out (PsiExpression..PsiExpression?)>.asList(): List<(PsiExpression..PsiExpression?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiExpression..com.intellij.psi.PsiExpression?)

'type' @ [511:17] ==> val type: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[LocalVariableDescriptor]

'canonicalText' @ [511:23] ==> public final val PsiType.canonicalText: String[MyPropertyDescriptor]

'getAllBoxedTypeNames' @ [511:57] ==> public open fun getAllBoxedTypeNames(): (MutableCollection<(String..String?)>..Collection<(String..String?)>?) defined in com.intellij.psi.PsiPrimitiveType[JavaMethodDescriptor]

'expression' @ [512:32] ==> value-parameter expression: PsiNewExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[ValueParameterDescriptorImpl]

'argumentList' @ [512:43] ==> public final val PsiNewExpression.argumentList: PsiExpressionList?[MyPropertyDescriptor]

'expressions' @ [512:57] ==> public final val PsiExpressionList.expressions: (Array<(PsiExpression..PsiExpression?)>..Array<out (PsiExpression..PsiExpression?)>)[MyPropertyDescriptor]

'singleOrNull' @ [512:70] ==> public fun <T> Array<out (PsiExpression..PsiExpression?)>.singleOrNull(): PsiExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiExpression..com.intellij.psi.PsiExpression?)

'argument' @ [513:21] ==> val argument: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[LocalVariableDescriptor]

'argument' @ [513:41] ==> val argument: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[LocalVariableDescriptor]

'type' @ [513:50] ==> public final val PsiExpression.type: PsiType?[MyPropertyDescriptor]

'result' @ [514:21] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'codeConverter' @ [514:30] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [514:44] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'argument' @ [514:62] ==> val argument: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[LocalVariableDescriptor]

'expression' @ [519:29] ==> value-parameter expression: PsiNewExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[ValueParameterDescriptorImpl]

'qualifier' @ [519:40] ==> public final val PsiNewExpression.qualifier: PsiExpression?[MyPropertyDescriptor]

'expression' @ [520:28] ==> value-parameter expression: PsiNewExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[ValueParameterDescriptorImpl]

'classOrAnonymousClassReference' @ [520:39] ==> public final val PsiNewExpression.classOrAnonymousClassReference: PsiJavaCodeReferenceElement?[MyPropertyDescriptor]

'if (classRef != null) converter.convertCodeReferenceElement(classRef, hasExternalQualifier = qualifier != null) else null' @ [521:37] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: ReferenceElement?, elseBranch: ReferenceElement?): ReferenceElement?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> ReferenceElement?

'classRef' @ [521:41] ==> val classRef: PsiJavaCodeReferenceElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[LocalVariableDescriptor]

'converter' @ [521:59] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertCodeReferenceElement' @ [521:69] ==> public final fun convertCodeReferenceElement(element: PsiJavaCodeReferenceElement, hasExternalQualifier: Boolean, typeArgsConverted: List<Element>? = ...): ReferenceElement defined in org.jetbrains.kotlin.j2k.Converter[SimpleFunctionDescriptorImpl]

'classRef' @ [521:97] ==> val classRef: PsiJavaCodeReferenceElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[LocalVariableDescriptor]

'qualifier' @ [521:130] ==> val qualifier: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[LocalVariableDescriptor]

'expression' @ [523:34] ==> value-parameter expression: PsiNewExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[ValueParameterDescriptorImpl]

'anonymousClass' @ [523:45] ==> public final val PsiNewExpression.anonymousClass: PsiAnonymousClass?[MyPropertyDescriptor]

'let' @ [523:61] ==> @InlineOnly public inline fun <T, R> PsiAnonymousClass.let(block: (PsiAnonymousClass) -> AnonymousClassBody): AnonymousClassBody defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiAnonymousClass
    <R> -> AnonymousClassBody

'converter' @ [523:67] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertAnonymousClassBody' @ [523:77] ==> public final fun convertAnonymousClassBody(anonymousClass: PsiAnonymousClass): AnonymousClassBody defined in org.jetbrains.kotlin.j2k.Converter[SimpleFunctionDescriptorImpl]

'it' @ [523:103] ==> value-parameter it: PsiAnonymousClass defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression.<anonymous>[ValueParameterDescriptorImpl]

'isFunctionType' @ [524:17] ==> private final fun isFunctionType(functionalType: PsiType?): Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[SimpleFunctionDescriptorImpl]

'expression' @ [524:32] ==> value-parameter expression: PsiNewExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[ValueParameterDescriptorImpl]

'type' @ [524:43] ==> public final val PsiNewExpression.type: PsiType?[MyPropertyDescriptor]

'anonymousClass' @ [525:32] ==> val anonymousClass: AnonymousClassBody? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[LocalVariableDescriptor]

'body' @ [525:48] ==> public final val body: ClassBody defined in org.jetbrains.kotlin.j2k.ast.AnonymousClassBody[PropertyDescriptorImpl]

'members' @ [525:54] ==> public final val members: List<Member> defined in org.jetbrains.kotlin.j2k.ast.ClassBody[PropertyDescriptorImpl]

'singleOrNull' @ [525:63] ==> public fun <T> List<Member>.singleOrNull(): Member? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Member

'function' @ [526:21] ==> val function: Function? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[LocalVariableDescriptor]

'result' @ [527:21] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'AnonymousFunction' @ [527:30] ==> public constructor AnonymousFunction(returnType: Type, typeParameterList: TypeParameterList, parameterList: ParameterList, body: DeferredElement<Block>?) defined in org.jetbrains.kotlin.j2k.ast.AnonymousFunction[ClassConstructorDescriptorImpl]

'function' @ [527:48] ==> val function: Function? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[LocalVariableDescriptor]

'returnType' @ [527:57] ==> public final val returnType: Type defined in org.jetbrains.kotlin.j2k.ast.Function[PropertyDescriptorImpl]

'toNotNullType' @ [527:68] ==> public open fun toNotNullType(): Type defined in org.jetbrains.kotlin.j2k.ast.Type[SimpleFunctionDescriptorImpl]

'function' @ [527:85] ==> val function: Function? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[LocalVariableDescriptor]

'typeParameterList' @ [527:94] ==> public final val typeParameterList: TypeParameterList defined in org.jetbrains.kotlin.j2k.ast.Function[PropertyDescriptorImpl]

'function' @ [527:113] ==> val function: Function? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[LocalVariableDescriptor]

'parameterList' @ [527:122] ==> public open val parameterList: ParameterList defined in org.jetbrains.kotlin.j2k.ast.Function[PropertyDescriptorImpl]

'function' @ [527:137] ==> val function: Function? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[LocalVariableDescriptor]

'body' @ [527:146] ==> public final val body: DeferredElement<Block>? defined in org.jetbrains.kotlin.j2k.ast.Function[PropertyDescriptorImpl]

'result' @ [531:13] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'NewClassExpression' @ [531:22] ==> public constructor NewClassExpression(name: ReferenceElement?, argumentList: ArgumentList, qualifier: Expression = ..., anonymousClass: AnonymousClassBody? = ...) defined in org.jetbrains.kotlin.j2k.ast.NewClassExpression[ClassConstructorDescriptorImpl]

'classRefConverted' @ [531:41] ==> val classRefConverted: ReferenceElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[LocalVariableDescriptor]

'convertArguments' @ [532:41] ==> private final fun convertArguments(expression: PsiCallExpression, isExtension: Boolean = ...): ArgumentList defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[SimpleFunctionDescriptorImpl]

'expression' @ [532:58] ==> value-parameter expression: PsiNewExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[ValueParameterDescriptorImpl]

'codeConverter' @ [533:41] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [533:55] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'qualifier' @ [533:73] ==> val qualifier: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[LocalVariableDescriptor]

'anonymousClass' @ [534:41] ==> val anonymousClass: AnonymousClassBody? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitNewExpression[LocalVariableDescriptor]

'result' @ [539:9] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'ParenthesizedExpression' @ [539:18] ==> public constructor ParenthesizedExpression(expression: Expression) defined in org.jetbrains.kotlin.j2k.ast.ParenthesizedExpression[ClassConstructorDescriptorImpl]

'codeConverter' @ [539:42] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [539:56] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'expression' @ [539:74] ==> value-parameter expression: PsiParenthesizedExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitParenthesizedExpression[ValueParameterDescriptorImpl]

'expression' @ [539:85] ==> public final val PsiParenthesizedExpression.expression: PsiExpression?[MyPropertyDescriptor]

'result' @ [543:9] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'PostfixExpression' @ [543:18] ==> public constructor PostfixExpression(op: Operator, expression: Expression) defined in org.jetbrains.kotlin.j2k.ast.PostfixExpression[ClassConstructorDescriptorImpl]

'Operator' @ [543:36] ==> public constructor Operator(operatorType: IElementType) defined in org.jetbrains.kotlin.j2k.ast.Operator[ClassConstructorDescriptorImpl]

'expression' @ [543:45] ==> value-parameter expression: PsiPostfixExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPostfixExpression[ValueParameterDescriptorImpl]

'operationSign' @ [543:56] ==> public final val PsiPostfixExpression.operationSign: PsiJavaToken[MyPropertyDescriptor]

'tokenType' @ [543:70] ==> public final val PsiJavaToken.tokenType: (IElementType..IElementType?)[MyPropertyDescriptor]

'assignPrototype' @ [543:81] ==> public fun <TElement : Element> Operator.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Operator defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Operator

'expression' @ [543:97] ==> value-parameter expression: PsiPostfixExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPostfixExpression[ValueParameterDescriptorImpl]

'operationSign' @ [543:108] ==> public final val PsiPostfixExpression.operationSign: PsiJavaToken[MyPropertyDescriptor]

'codeConverter' @ [544:36] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [544:50] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'expression' @ [544:68] ==> value-parameter expression: PsiPostfixExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPostfixExpression[ValueParameterDescriptorImpl]

'operand' @ [544:79] ==> public final val PsiPostfixExpression.operand: PsiExpression[MyPropertyDescriptor]

'codeConverter' @ [548:23] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [548:37] ==> public final fun convertExpression(expression: PsiExpression?, expectedType: PsiType?, expectedNullability: Nullability? = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'expression' @ [548:55] ==> value-parameter expression: PsiPrefixExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPrefixExpression[ValueParameterDescriptorImpl]

'operand' @ [548:66] ==> public final val PsiPrefixExpression.operand: PsiExpression?[MyPropertyDescriptor]

'expression' @ [548:75] ==> value-parameter expression: PsiPrefixExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPrefixExpression[ValueParameterDescriptorImpl]

'operand' @ [548:86] ==> public final val PsiPrefixExpression.operand: PsiExpression?[MyPropertyDescriptor]

'type' @ [548:96] ==> public final val PsiExpression.type: PsiType?[MyPropertyDescriptor]

'expression' @ [549:21] ==> value-parameter expression: PsiPrefixExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPrefixExpression[ValueParameterDescriptorImpl]

'operationTokenType' @ [549:32] ==> public final val PsiPrefixExpression.operationTokenType: IElementType[MyPropertyDescriptor]

'result' @ [550:9] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'if (token == JavaTokenType.TILDE) {
            MethodCallExpression.buildNonNull(operand, "inv")
        }
        else if (token == JavaTokenType.EXCL && operand is BinaryExpression && operand.op.asString() == "==") { // happens when equals is converted to ==
            BinaryExpression(operand.left, operand.right, Operator(JavaTokenType.NE).assignPrototype(expression.operand))
        }
        else {
            PrefixExpression(Operator(token).assignPrototype(expression.operand), operand)
        }' @ [550:18] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Expression, elseBranch: Expression): Expression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Expression

'token' @ [550:22] ==> val token: IElementType defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPrefixExpression[LocalVariableDescriptor]

'TILDE' @ [550:45] ==> public final val TILDE: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'buildNonNull' @ [551:34] ==> public final fun buildNonNull(receiver: Expression?, methodName: String, argumentList: ArgumentList = ..., typeArguments: List<Type> = ..., dotPrototype: PsiElement? = ...): MethodCallExpression defined in org.jetbrains.kotlin.j2k.ast.MethodCallExpression.Companion[SimpleFunctionDescriptorImpl]

'operand' @ [551:47] ==> val operand: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPrefixExpression[LocalVariableDescriptor]

'if (token == JavaTokenType.EXCL && operand is BinaryExpression && operand.op.asString() == "==") { // happens when equals is converted to ==
            BinaryExpression(operand.left, operand.right, Operator(JavaTokenType.NE).assignPrototype(expression.operand))
        }
        else {
            PrefixExpression(Operator(token).assignPrototype(expression.operand), operand)
        }' @ [553:14] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Expression, elseBranch: Expression): Expression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Expression

'token' @ [553:18] ==> val token: IElementType defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPrefixExpression[LocalVariableDescriptor]

'EXCL' @ [553:41] ==> public final val EXCL: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'operand' @ [553:49] ==> val operand: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPrefixExpression[LocalVariableDescriptor]

'operand' @ [553:80] ==> val operand: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPrefixExpression[LocalVariableDescriptor]

'op' @ [553:88] ==> public final val op: Operator defined in org.jetbrains.kotlin.j2k.ast.BinaryExpression[PropertyDescriptorImpl]

'asString' @ [553:91] ==> public final fun asString(): String defined in org.jetbrains.kotlin.j2k.ast.Operator[SimpleFunctionDescriptorImpl]

'BinaryExpression' @ [554:13] ==> public constructor BinaryExpression(left: Expression, right: Expression, op: Operator) defined in org.jetbrains.kotlin.j2k.ast.BinaryExpression[ClassConstructorDescriptorImpl]

'operand' @ [554:30] ==> val operand: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPrefixExpression[LocalVariableDescriptor]

'left' @ [554:38] ==> public final val left: Expression defined in org.jetbrains.kotlin.j2k.ast.BinaryExpression[PropertyDescriptorImpl]

'operand' @ [554:44] ==> val operand: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPrefixExpression[LocalVariableDescriptor]

'right' @ [554:52] ==> public final val right: Expression defined in org.jetbrains.kotlin.j2k.ast.BinaryExpression[PropertyDescriptorImpl]

'Operator' @ [554:59] ==> public constructor Operator(operatorType: IElementType) defined in org.jetbrains.kotlin.j2k.ast.Operator[ClassConstructorDescriptorImpl]

'NE' @ [554:82] ==> public final val NE: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'assignPrototype' @ [554:86] ==> public fun <TElement : Element> Operator.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Operator defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Operator

'expression' @ [554:102] ==> value-parameter expression: PsiPrefixExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPrefixExpression[ValueParameterDescriptorImpl]

'operand' @ [554:113] ==> public final val PsiPrefixExpression.operand: PsiExpression?[MyPropertyDescriptor]

'PrefixExpression' @ [557:13] ==> public constructor PrefixExpression(op: Operator, expression: Expression) defined in org.jetbrains.kotlin.j2k.ast.PrefixExpression[ClassConstructorDescriptorImpl]

'Operator' @ [557:30] ==> public constructor Operator(operatorType: IElementType) defined in org.jetbrains.kotlin.j2k.ast.Operator[ClassConstructorDescriptorImpl]

'token' @ [557:39] ==> val token: IElementType defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPrefixExpression[LocalVariableDescriptor]

'assignPrototype' @ [557:46] ==> public fun <TElement : Element> Operator.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Operator defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Operator

'expression' @ [557:62] ==> value-parameter expression: PsiPrefixExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPrefixExpression[ValueParameterDescriptorImpl]

'operand' @ [557:73] ==> public final val PsiPrefixExpression.operand: PsiExpression?[MyPropertyDescriptor]

'operand' @ [557:83] ==> val operand: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPrefixExpression[LocalVariableDescriptor]

'expression' @ [563:13] ==> value-parameter expression: PsiReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[ValueParameterDescriptorImpl]

'text' @ [563:24] ==> public final val PsiReferenceExpression.text: (String..String?)[MyPropertyDescriptor]

'result' @ [564:13] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'ThisExpression' @ [564:22] ==> public constructor ThisExpression(identifier: Identifier) defined in org.jetbrains.kotlin.j2k.ast.ThisExpression[ClassConstructorDescriptorImpl]

'Empty' @ [564:48] ==> public final val Empty: Identifier defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[PropertyDescriptorImpl]

'expression' @ [567:13] ==> value-parameter expression: PsiReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[ValueParameterDescriptorImpl]

'text' @ [567:24] ==> public final val PsiReferenceExpression.text: (String..String?)[MyPropertyDescriptor]

'result' @ [568:13] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'SuperExpression' @ [568:22] ==> public constructor SuperExpression(identifier: Identifier) defined in org.jetbrains.kotlin.j2k.ast.SuperExpression[ClassConstructorDescriptorImpl]

'Empty' @ [568:49] ==> public final val Empty: Identifier defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[PropertyDescriptorImpl]

'expression' @ [572:29] ==> value-parameter expression: PsiReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[ValueParameterDescriptorImpl]

'referenceName' @ [572:40] ==> public final val PsiReferenceExpression.referenceName: String?[MyPropertyDescriptor]

'run' @ [572:57] ==> @InlineOnly public inline fun <T, R> DefaultExpressionConverter.run(block: DefaultExpressionConverter.() -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DefaultExpressionConverter
    <R> -> Nothing

'result' @ [573:13] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'LiteralExpression' @ [573:22] ==> public constructor LiteralExpression(literalText: String) defined in org.jetbrains.kotlin.j2k.ast.LiteralExpression[ClassConstructorDescriptorImpl]

'expression' @ [573:40] ==> value-parameter expression: PsiReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[ValueParameterDescriptorImpl]

'text' @ [573:51] ==> public final val PsiReferenceExpression.text: (String..String?)[MyPropertyDescriptor]

'assignNoPrototype' @ [573:57] ==> public fun <TElement : Element> LiteralExpression.assignNoPrototype(): LiteralExpression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> LiteralExpression

'expression' @ [577:22] ==> value-parameter expression: PsiReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[ValueParameterDescriptorImpl]

'resolve' @ [577:33] ==> @Nullable public abstract fun resolve(): PsiElement? defined in com.intellij.psi.PsiReferenceExpression[JavaMethodDescriptor]

'target' @ [579:26] ==> val target: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'isNullable' @ [579:51] ==> private final fun isNullable(target: PsiVariable): Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[SimpleFunctionDescriptorImpl]

'target' @ [579:62] ==> val target: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'expression' @ [581:25] ==> value-parameter expression: PsiReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[ValueParameterDescriptorImpl]

'qualifierExpression' @ [581:36] ==> public final var PsiReferenceExpression.qualifierExpression: PsiExpression?[MyPropertyDescriptor]

'Identifier' @ [583:26] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.Identifier[FakeCallableDescriptorForObject]

'withNoPrototype' @ [583:37] ==> public final fun withNoPrototype(name: String, isNullable: Boolean = ..., quotingNeeded: Boolean = ..., imports: Collection<FqName> = ...): Identifier defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[SimpleFunctionDescriptorImpl]

'referenceName' @ [583:53] ==> val referenceName: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'isNullable' @ [583:68] ==> val isNullable: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'if (qualifier != null && qualifier.type is PsiArrayType && referenceName == "length") {
            identifier = Identifier.withNoPrototype("size", isNullable)
        }
        else if (qualifier != null) {
            if (target is KtLightField && target.kotlinOrigin is KtObjectDeclaration) {
                result = codeConverter.convertExpression(qualifier)
                return
            }
        }
        else {
            if (target is PsiClass) {
                if (PrimitiveType.values().any { it.typeName.asString() == target.name }) {
                    result = Identifier.withNoPrototype(target.qualifiedName!!, isNullable = false)
                    return
                }
            }

            // add qualification for static members from base classes and also this works for enum constants in switch
            if (target is PsiMember
                && target.hasModifierProperty(PsiModifier.STATIC)
                && target.containingClass != null
                && !PsiTreeUtil.isAncestor(target.containingClass, expression, true)
                && !target.isImported(expression.containingFile as PsiJavaFile)) {
                var member: PsiMember = target
                var code = Identifier.toKotlin(referenceName)
                while (true) {
                    val containingClass = member.containingClass ?: break
                    code = Identifier.toKotlin(containingClass.name!!) + "." + code
                    member = containingClass
                }
                result = Identifier.withNoPrototype(code, isNullable = false, quotingNeeded = false)
                return
            }
        }' @ [584:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'qualifier' @ [584:13] ==> val qualifier: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'qualifier' @ [584:34] ==> val qualifier: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'type' @ [584:44] ==> public final val PsiExpression.type: PsiType?[MyPropertyDescriptor]

'referenceName' @ [584:68] ==> val referenceName: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'identifier' @ [585:13] ==> var identifier: Identifier defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'Identifier' @ [585:26] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.Identifier[FakeCallableDescriptorForObject]

'withNoPrototype' @ [585:37] ==> public final fun withNoPrototype(name: String, isNullable: Boolean = ..., quotingNeeded: Boolean = ..., imports: Collection<FqName> = ...): Identifier defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[SimpleFunctionDescriptorImpl]

'isNullable' @ [585:61] ==> val isNullable: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'if (qualifier != null) {
            if (target is KtLightField && target.kotlinOrigin is KtObjectDeclaration) {
                result = codeConverter.convertExpression(qualifier)
                return
            }
        }
        else {
            if (target is PsiClass) {
                if (PrimitiveType.values().any { it.typeName.asString() == target.name }) {
                    result = Identifier.withNoPrototype(target.qualifiedName!!, isNullable = false)
                    return
                }
            }

            // add qualification for static members from base classes and also this works for enum constants in switch
            if (target is PsiMember
                && target.hasModifierProperty(PsiModifier.STATIC)
                && target.containingClass != null
                && !PsiTreeUtil.isAncestor(target.containingClass, expression, true)
                && !target.isImported(expression.containingFile as PsiJavaFile)) {
                var member: PsiMember = target
                var code = Identifier.toKotlin(referenceName)
                while (true) {
                    val containingClass = member.containingClass ?: break
                    code = Identifier.toKotlin(containingClass.name!!) + "." + code
                    member = containingClass
                }
                result = Identifier.withNoPrototype(code, isNullable = false, quotingNeeded = false)
                return
            }
        }' @ [587:14] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'qualifier' @ [587:18] ==> val qualifier: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'target' @ [588:17] ==> val target: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'target' @ [588:43] ==> val target: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'kotlinOrigin' @ [588:50] ==> public abstract val kotlinOrigin: KtDeclaration? defined in org.jetbrains.kotlin.asJava.elements.KtLightField[DeserializedPropertyDescriptor]

'result' @ [589:17] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'codeConverter' @ [589:26] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [589:40] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'qualifier' @ [589:58] ==> val qualifier: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'target' @ [594:17] ==> val target: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'values' @ [595:35] ==> public final fun values(): Array<PrimitiveType> defined in org.jetbrains.kotlin.builtins.PrimitiveType[SimpleFunctionDescriptorImpl]

'any' @ [595:44] ==> public inline fun <T> Array<out PrimitiveType>.any(predicate: (PrimitiveType) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PrimitiveType

'it' @ [595:50] ==> value-parameter it: PrimitiveType defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression.<anonymous>[ValueParameterDescriptorImpl]

'typeName' @ [595:53] ==> public final val PrimitiveType.typeName: Name[MyPropertyDescriptor]

'asString' @ [595:62] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'target' @ [595:76] ==> val target: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'name' @ [595:83] ==> public final val PsiClass.name: String?[MyPropertyDescriptor]

'result' @ [596:21] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'Identifier' @ [596:30] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.Identifier[FakeCallableDescriptorForObject]

'withNoPrototype' @ [596:41] ==> public final fun withNoPrototype(name: String, isNullable: Boolean = ..., quotingNeeded: Boolean = ..., imports: Collection<FqName> = ...): Identifier defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[SimpleFunctionDescriptorImpl]

'target' @ [596:57] ==> val target: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'qualifiedName' @ [596:64] ==> public final val PsiClass.qualifiedName: String?[MyPropertyDescriptor]

'target' @ [602:17] ==> val target: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'target' @ [603:20] ==> val target: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'hasModifierProperty' @ [603:27] ==> public abstract fun hasModifierProperty(@PsiModifier.ModifierConstant @NonNls @NotNull p0: String): Boolean defined in com.intellij.psi.PsiMember[JavaMethodDescriptor]

'STATIC' @ [603:59] ==> public const final val STATIC: String defined in com.intellij.psi.PsiModifier[JavaPropertyDescriptor]

'target' @ [604:20] ==> val target: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'containingClass' @ [604:27] ==> public final val PsiMember.containingClass: PsiClass?[MyPropertyDescriptor]

'!' @ [605:20] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isAncestor' @ [605:33] ==> @Contract public open fun isAncestor(@Nullable p0: PsiElement?, @NotNull p1: PsiElement, p2: Boolean): Boolean defined in com.intellij.psi.util.PsiTreeUtil[JavaMethodDescriptor]

'target' @ [605:44] ==> val target: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'containingClass' @ [605:51] ==> public final val PsiMember.containingClass: PsiClass?[MyPropertyDescriptor]

'expression' @ [605:68] ==> value-parameter expression: PsiReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[ValueParameterDescriptorImpl]

'!' @ [606:20] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'target' @ [606:21] ==> val target: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'isImported' @ [606:28] ==> public fun PsiMember.isImported(file: PsiJavaFile): Boolean defined in org.jetbrains.kotlin.j2k in file Utils.kt[SimpleFunctionDescriptorImpl]

'expression' @ [606:39] ==> value-parameter expression: PsiReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[ValueParameterDescriptorImpl]

'containingFile' @ [606:50] ==> public final val PsiReferenceExpression.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'target' @ [607:41] ==> val target: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'Identifier' @ [608:28] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.Identifier[FakeCallableDescriptorForObject]

'toKotlin' @ [608:39] ==> public final fun toKotlin(name: String): String defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[SimpleFunctionDescriptorImpl]

'referenceName' @ [608:48] ==> val referenceName: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'member' @ [610:43] ==> var member: PsiMember defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'containingClass' @ [610:50] ==> public final val PsiMember.containingClass: PsiClass?[MyPropertyDescriptor]

'code' @ [611:21] ==> var code: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'Identifier' @ [611:28] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.Identifier[FakeCallableDescriptorForObject]

'toKotlin' @ [611:39] ==> public final fun toKotlin(name: String): String defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[SimpleFunctionDescriptorImpl]

'containingClass' @ [611:48] ==> val containingClass: PsiClass defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'name' @ [611:64] ==> public final val PsiClass.name: String?[MyPropertyDescriptor]

'code' @ [611:80] ==> var code: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'member' @ [612:21] ==> var member: PsiMember defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'containingClass' @ [612:30] ==> val containingClass: PsiClass defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'result' @ [614:17] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'Identifier' @ [614:26] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.Identifier[FakeCallableDescriptorForObject]

'withNoPrototype' @ [614:37] ==> public final fun withNoPrototype(name: String, isNullable: Boolean = ..., quotingNeeded: Boolean = ..., imports: Collection<FqName> = ...): Identifier defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[SimpleFunctionDescriptorImpl]

'code' @ [614:53] ==> var code: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'result' @ [619:9] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'if (qualifier != null)
            QualifiedExpression(codeConverter.convertExpression(qualifier), identifier, expression.dot())
        else
            identifier' @ [619:18] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Expression, elseBranch: Expression): Expression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Expression

'qualifier' @ [619:22] ==> val qualifier: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'QualifiedExpression' @ [620:13] ==> public constructor QualifiedExpression(qualifier: Expression, identifier: Expression, dotPrototype: PsiElement?) defined in org.jetbrains.kotlin.j2k.ast.QualifiedExpression[ClassConstructorDescriptorImpl]

'codeConverter' @ [620:33] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [620:47] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'qualifier' @ [620:65] ==> val qualifier: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'identifier' @ [620:77] ==> var identifier: Identifier defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'expression' @ [620:89] ==> value-parameter expression: PsiReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[ValueParameterDescriptorImpl]

'dot' @ [620:100] ==> public fun PsiReferenceExpression.dot(): PsiElement? defined in org.jetbrains.kotlin.j2k in file Utils.kt[SimpleFunctionDescriptorImpl]

'identifier' @ [622:13] ==> var identifier: Identifier defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitReferenceExpression[LocalVariableDescriptor]

'typeConverter' @ [626:13] ==> private final val typeConverter: TypeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'variableNullability' @ [626:27] ==> public final fun variableNullability(variable: PsiVariable): Nullability defined in org.jetbrains.kotlin.j2k.TypeConverter[SimpleFunctionDescriptorImpl]

'target' @ [626:47] ==> value-parameter target: PsiVariable defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.isNullable[ValueParameterDescriptorImpl]

'isNullable' @ [626:55] ==> public fun Nullability.isNullable(settings: ConverterSettings): Boolean defined in org.jetbrains.kotlin.j2k.ast in file Types.kt[SimpleFunctionDescriptorImpl]

'codeConverter' @ [626:66] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'settings' @ [626:80] ==> public final val settings: ConverterSettings defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'!' @ [628:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'converter' @ [628:14] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'invoke' @ [628:24] ==> public abstract operator fun invoke(p1: PsiElement): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'target' @ [628:42] ==> value-parameter target: PsiVariable defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.isNullable[ValueParameterDescriptorImpl]

'when (target) {
            is PsiLocalVariable -> {
                if (converter.settings.specifyLocalVariableTypeByDefault) return false
                codeConverter.canChangeType(target)
            }

            is PsiField -> {
                if (converter.settings.specifyFieldTypeByDefault) return false
                target.hasModifierProperty(PsiModifier.PRIVATE)
            }

            else -> return false
        }' @ [630:38] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean, entry2: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'target' @ [630:44] ==> value-parameter target: PsiVariable defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.isNullable[ValueParameterDescriptorImpl]

'converter' @ [632:21] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'settings' @ [632:31] ==> public final val settings: ConverterSettings defined in org.jetbrains.kotlin.j2k.Converter[PropertyDescriptorImpl]

'specifyLocalVariableTypeByDefault' @ [632:40] ==> public final var specifyLocalVariableTypeByDefault: Boolean defined in org.jetbrains.kotlin.j2k.ConverterSettings[PropertyDescriptorImpl]

'codeConverter' @ [633:17] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'canChangeType' @ [633:31] ==> public final fun canChangeType(variable: PsiLocalVariable): Boolean defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'target' @ [633:45] ==> value-parameter target: PsiVariable defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.isNullable[ValueParameterDescriptorImpl]

'converter' @ [637:21] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'settings' @ [637:31] ==> public final val settings: ConverterSettings defined in org.jetbrains.kotlin.j2k.Converter[PropertyDescriptorImpl]

'specifyFieldTypeByDefault' @ [637:40] ==> public final var specifyFieldTypeByDefault: Boolean defined in org.jetbrains.kotlin.j2k.ConverterSettings[PropertyDescriptorImpl]

'target' @ [638:17] ==> value-parameter target: PsiVariable defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.isNullable[ValueParameterDescriptorImpl]

'hasModifierProperty' @ [638:24] ==> public abstract fun hasModifierProperty(@PsiModifier.ModifierConstant @NonNls @NotNull p0: String): Boolean defined in com.intellij.psi.PsiVariable[JavaMethodDescriptor]

'PRIVATE' @ [638:56] ==> public const final val PRIVATE: String defined in com.intellij.psi.PsiModifier[JavaPropertyDescriptor]

'converter' @ [644:13] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'shouldDeclareVariableType' @ [644:23] ==> public final fun shouldDeclareVariableType(variable: PsiVariable, type: Type, canChangeType: Boolean): Boolean defined in org.jetbrains.kotlin.j2k.Converter[SimpleFunctionDescriptorImpl]

'target' @ [644:49] ==> value-parameter target: PsiVariable defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.isNullable[ValueParameterDescriptorImpl]

'converter' @ [644:57] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'typeConverter' @ [644:67] ==> public final val typeConverter: TypeConverter defined in org.jetbrains.kotlin.j2k.Converter[PropertyDescriptorImpl]

'convertVariableType' @ [644:81] ==> public final fun convertVariableType(variable: PsiVariable): Type defined in org.jetbrains.kotlin.j2k.TypeConverter[SimpleFunctionDescriptorImpl]

'target' @ [644:101] ==> value-parameter target: PsiVariable defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.isNullable[ValueParameterDescriptorImpl]

'canChangeType' @ [644:110] ==> val canChangeType: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.isNullable[LocalVariableDescriptor]

'converter' @ [647:16] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'codeConverterForType' @ [647:26] ==> public final val codeConverterForType: CodeConverter defined in org.jetbrains.kotlin.j2k.Converter[PropertyDescriptorImpl]

'convertExpression' @ [647:47] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'target' @ [647:65] ==> value-parameter target: PsiVariable defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.isNullable[ValueParameterDescriptorImpl]

'initializer' @ [647:72] ==> public final val PsiVariable.initializer: PsiExpression?[MyPropertyDescriptor]

'isNullable' @ [647:85] ==> public open val isNullable: Boolean defined in org.jetbrains.kotlin.j2k.ast.Expression[PropertyDescriptorImpl]

'expression' @ [651:28] ==> value-parameter expression: PsiSuperExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitSuperExpression[ValueParameterDescriptorImpl]

'qualifier' @ [651:39] ==> public final val PsiSuperExpression.qualifier: PsiJavaCodeReferenceElement?[MyPropertyDescriptor]

'psiQualifier' @ [652:25] ==> val psiQualifier: PsiJavaCodeReferenceElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitSuperExpression[LocalVariableDescriptor]

'referenceName' @ [652:39] ==> public final val PsiJavaCodeReferenceElement.referenceName: String?[MyPropertyDescriptor]

'result' @ [653:9] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'SuperExpression' @ [653:18] ==> public constructor SuperExpression(identifier: Identifier) defined in org.jetbrains.kotlin.j2k.ast.SuperExpression[ClassConstructorDescriptorImpl]

'if (qualifier != null) Identifier(qualifier).assignPrototype(psiQualifier) else Identifier.Empty' @ [653:34] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Identifier, elseBranch: Identifier): Identifier[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Identifier

'qualifier' @ [653:38] ==> val qualifier: String? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitSuperExpression[LocalVariableDescriptor]

'Identifier' @ [653:57] ==> public constructor Identifier(name: String, isNullable: Boolean = ..., quotingNeeded: Boolean = ..., imports: Collection<FqName> = ...) defined in org.jetbrains.kotlin.j2k.ast.Identifier[ClassConstructorDescriptorImpl]

'qualifier' @ [653:68] ==> val qualifier: String? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitSuperExpression[LocalVariableDescriptor]

'assignPrototype' @ [653:79] ==> public fun <TElement : Element> Identifier.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Identifier defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Identifier

'psiQualifier' @ [653:95] ==> val psiQualifier: PsiJavaCodeReferenceElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitSuperExpression[LocalVariableDescriptor]

'Empty' @ [653:125] ==> public final val Empty: Identifier defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[PropertyDescriptorImpl]

'expression' @ [657:28] ==> value-parameter expression: PsiThisExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitThisExpression[ValueParameterDescriptorImpl]

'qualifier' @ [657:39] ==> public final val PsiThisExpression.qualifier: PsiJavaCodeReferenceElement?[MyPropertyDescriptor]

'psiQualifier' @ [658:25] ==> val psiQualifier: PsiJavaCodeReferenceElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitThisExpression[LocalVariableDescriptor]

'referenceName' @ [658:39] ==> public final val PsiJavaCodeReferenceElement.referenceName: String?[MyPropertyDescriptor]

'result' @ [659:9] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'ThisExpression' @ [659:18] ==> public constructor ThisExpression(identifier: Identifier) defined in org.jetbrains.kotlin.j2k.ast.ThisExpression[ClassConstructorDescriptorImpl]

'if (qualifier != null) Identifier(qualifier).assignPrototype(psiQualifier) else Identifier.Empty' @ [659:33] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Identifier, elseBranch: Identifier): Identifier[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Identifier

'qualifier' @ [659:37] ==> val qualifier: String? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitThisExpression[LocalVariableDescriptor]

'Identifier' @ [659:56] ==> public constructor Identifier(name: String, isNullable: Boolean = ..., quotingNeeded: Boolean = ..., imports: Collection<FqName> = ...) defined in org.jetbrains.kotlin.j2k.ast.Identifier[ClassConstructorDescriptorImpl]

'qualifier' @ [659:67] ==> val qualifier: String? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitThisExpression[LocalVariableDescriptor]

'assignPrototype' @ [659:78] ==> public fun <TElement : Element> Identifier.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Identifier defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Identifier

'psiQualifier' @ [659:94] ==> val psiQualifier: PsiJavaCodeReferenceElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitThisExpression[LocalVariableDescriptor]

'Empty' @ [659:124] ==> public final val Empty: Identifier defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[PropertyDescriptorImpl]

'expression' @ [663:24] ==> value-parameter expression: PsiTypeCastExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitTypeCastExpression[ValueParameterDescriptorImpl]

'castType' @ [663:35] ==> public final val PsiTypeCastExpression.castType: PsiTypeElement?[MyPropertyDescriptor]

'expression' @ [664:23] ==> value-parameter expression: PsiTypeCastExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitTypeCastExpression[ValueParameterDescriptorImpl]

'operand' @ [664:34] ==> public final val PsiTypeCastExpression.operand: PsiExpression?[MyPropertyDescriptor]

'operand' @ [665:27] ==> val operand: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitTypeCastExpression[LocalVariableDescriptor]

'type' @ [665:36] ==> public final val PsiExpression.type: PsiType?[MyPropertyDescriptor]

'castType' @ [666:24] ==> val castType: PsiTypeElement defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitTypeCastExpression[LocalVariableDescriptor]

'type' @ [666:33] ==> public final val PsiTypeElement.type: PsiType[MyPropertyDescriptor]

'canonicalText' @ [666:38] ==> public final val PsiType.canonicalText: String[MyPropertyDescriptor]

'PRIMITIVE_TYPE_CONVERSIONS' @ [667:30] ==> public val PRIMITIVE_TYPE_CONVERSIONS: Map<String, String> defined in org.jetbrains.kotlin.j2k in file Converter.kt[PropertyDescriptorImpl]

'typeText' @ [667:57] ==> val typeText: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitTypeCastExpression[LocalVariableDescriptor]

'codeConverter' @ [668:32] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [668:46] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'operand' @ [668:64] ==> val operand: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitTypeCastExpression[LocalVariableDescriptor]

'result' @ [669:9] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'if (operandType is PsiPrimitiveType && typeConversion != null) {
            MethodCallExpression.buildNonNull(operandConverted, typeConversion)
        }
        else {
            val nullability = if (operandConverted.isNullable && !expression.isQualifier())
                Nullability.Nullable
            else
                Nullability.NotNull
            val typeConverted = typeConverter.convertType(castType.type, nullability)
            TypeCastExpression(typeConverted, operandConverted)
        }' @ [669:18] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Expression, elseBranch: Expression): Expression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Expression

'operandType' @ [669:22] ==> val operandType: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitTypeCastExpression[LocalVariableDescriptor]

'typeConversion' @ [669:57] ==> val typeConversion: String? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitTypeCastExpression[LocalVariableDescriptor]

'buildNonNull' @ [670:34] ==> public final fun buildNonNull(receiver: Expression?, methodName: String, argumentList: ArgumentList = ..., typeArguments: List<Type> = ..., dotPrototype: PsiElement? = ...): MethodCallExpression defined in org.jetbrains.kotlin.j2k.ast.MethodCallExpression.Companion[SimpleFunctionDescriptorImpl]

'operandConverted' @ [670:47] ==> val operandConverted: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitTypeCastExpression[LocalVariableDescriptor]

'typeConversion' @ [670:65] ==> val typeConversion: String? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitTypeCastExpression[LocalVariableDescriptor]

'if (operandConverted.isNullable && !expression.isQualifier())
                Nullability.Nullable
            else
                Nullability.NotNull' @ [673:31] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nullability, elseBranch: Nullability): Nullability[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nullability

'operandConverted' @ [673:35] ==> val operandConverted: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitTypeCastExpression[LocalVariableDescriptor]

'isNullable' @ [673:52] ==> public open val isNullable: Boolean defined in org.jetbrains.kotlin.j2k.ast.Expression[PropertyDescriptorImpl]

'!' @ [673:66] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'expression' @ [673:67] ==> value-parameter expression: PsiTypeCastExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitTypeCastExpression[ValueParameterDescriptorImpl]

'isQualifier' @ [673:78] ==> private final fun PsiExpression.isQualifier(): Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[SimpleFunctionDescriptorImpl]

'Nullable' @ [674:29] ==> enum entry Nullable defined in org.jetbrains.kotlin.j2k.ast.Nullability[FakeCallableDescriptorForObject]

'NotNull' @ [676:29] ==> enum entry NotNull defined in org.jetbrains.kotlin.j2k.ast.Nullability[FakeCallableDescriptorForObject]

'typeConverter' @ [677:33] ==> private final val typeConverter: TypeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertType' @ [677:47] ==> public final fun convertType(type: PsiType?, nullability: Nullability = ..., mutability: Mutability = ..., inAnnotationType: Boolean = ...): Type defined in org.jetbrains.kotlin.j2k.TypeConverter[SimpleFunctionDescriptorImpl]

'castType' @ [677:59] ==> val castType: PsiTypeElement defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitTypeCastExpression[LocalVariableDescriptor]

'type' @ [677:68] ==> public final val PsiTypeElement.type: PsiType[MyPropertyDescriptor]

'nullability' @ [677:74] ==> val nullability: Nullability defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitTypeCastExpression[LocalVariableDescriptor]

'TypeCastExpression' @ [678:13] ==> public constructor TypeCastExpression(type: Type, expression: Expression) defined in org.jetbrains.kotlin.j2k.ast.TypeCastExpression[ClassConstructorDescriptorImpl]

'typeConverted' @ [678:32] ==> val typeConverted: Type defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitTypeCastExpression[LocalVariableDescriptor]

'operandConverted' @ [678:47] ==> val operandConverted: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitTypeCastExpression[LocalVariableDescriptor]

'parent' @ [683:22] ==> public final val PsiExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'when (parent) {
            is PsiParenthesizedExpression -> parent.isQualifier()
            is PsiReferenceExpression -> this == parent.qualifierExpression
            else -> false
        }' @ [684:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean, entry2: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'parent' @ [684:22] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.isQualifier[LocalVariableDescriptor]

'parent' @ [685:46] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.isQualifier[LocalVariableDescriptor]

'isQualifier' @ [685:53] ==> private final fun PsiExpression.isQualifier(): Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[SimpleFunctionDescriptorImpl]

'this' @ [686:42] ==> <this> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.isQualifier[ReceiverParameterDescriptorImpl]

'parent' @ [686:50] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.isQualifier[LocalVariableDescriptor]

'qualifierExpression' @ [686:57] ==> public final var PsiReferenceExpression.qualifierExpression: PsiExpression?[MyPropertyDescriptor]

'if (operators.isEmpty())
            return operands.first()
        else {
            var op: Operator = operators.first()
            var index = 0
            operators.forEachIndexed { i, operator ->
                if (operator.precedence >= op.precedence) {
                    op = operator
                    index = i
                }
            }
            val left = polyadicExpressionToBinaryExpressions(operands.subList(0, index + 1), operators.subList(0, index))
            val right = polyadicExpressionToBinaryExpressions(operands.subList(index + 1, operands.size),
                                                              operators.subList(index + 1, operators.size))
            return BinaryExpression(left, right, op).assignNoPrototype()
        }' @ [693:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nothing, elseBranch: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nothing

'operators' @ [693:13] ==> value-parameter operators: List<Operator> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.polyadicExpressionToBinaryExpressions[ValueParameterDescriptorImpl]

'isEmpty' @ [693:23] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'operands' @ [694:20] ==> value-parameter operands: List<Expression> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.polyadicExpressionToBinaryExpressions[ValueParameterDescriptorImpl]

'first' @ [694:29] ==> public fun <T> List<Expression>.first(): Expression defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Expression

'operators' @ [696:32] ==> value-parameter operators: List<Operator> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.polyadicExpressionToBinaryExpressions[ValueParameterDescriptorImpl]

'first' @ [696:42] ==> public fun <T> List<Operator>.first(): Operator defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Operator

'operators' @ [698:13] ==> value-parameter operators: List<Operator> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.polyadicExpressionToBinaryExpressions[ValueParameterDescriptorImpl]

'forEachIndexed' @ [698:23] ==> public inline fun <T> Iterable<Operator>.forEachIndexed(action: (index: Int, Operator) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Operator

'operator' @ [699:21] ==> value-parameter operator: Operator defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.polyadicExpressionToBinaryExpressions.<anonymous>[ValueParameterDescriptorImpl]

'precedence' @ [699:30] ==> public final val precedence: Int defined in org.jetbrains.kotlin.j2k.ast.Operator[PropertyDescriptorImpl]

'op' @ [699:44] ==> var op: Operator defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.polyadicExpressionToBinaryExpressions[LocalVariableDescriptor]

'precedence' @ [699:47] ==> public final val precedence: Int defined in org.jetbrains.kotlin.j2k.ast.Operator[PropertyDescriptorImpl]

'op' @ [700:21] ==> var op: Operator defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.polyadicExpressionToBinaryExpressions[LocalVariableDescriptor]

'operator' @ [700:26] ==> value-parameter operator: Operator defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.polyadicExpressionToBinaryExpressions.<anonymous>[ValueParameterDescriptorImpl]

'index' @ [701:21] ==> var index: Int defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.polyadicExpressionToBinaryExpressions[LocalVariableDescriptor]

'i' @ [701:29] ==> value-parameter i: Int defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.polyadicExpressionToBinaryExpressions.<anonymous>[ValueParameterDescriptorImpl]

'polyadicExpressionToBinaryExpressions' @ [704:24] ==> private final fun polyadicExpressionToBinaryExpressions(operands: List<Expression>, operators: List<Operator>): Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[SimpleFunctionDescriptorImpl]

'operands' @ [704:62] ==> value-parameter operands: List<Expression> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.polyadicExpressionToBinaryExpressions[ValueParameterDescriptorImpl]

'subList' @ [704:71] ==> public abstract fun subList(fromIndex: Int, toIndex: Int): List<Expression> defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'index' @ [704:82] ==> var index: Int defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.polyadicExpressionToBinaryExpressions[LocalVariableDescriptor]

'operators' @ [704:94] ==> value-parameter operators: List<Operator> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.polyadicExpressionToBinaryExpressions[ValueParameterDescriptorImpl]

'subList' @ [704:104] ==> public abstract fun subList(fromIndex: Int, toIndex: Int): List<Operator> defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'index' @ [704:115] ==> var index: Int defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.polyadicExpressionToBinaryExpressions[LocalVariableDescriptor]

'polyadicExpressionToBinaryExpressions' @ [705:25] ==> private final fun polyadicExpressionToBinaryExpressions(operands: List<Expression>, operators: List<Operator>): Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[SimpleFunctionDescriptorImpl]

'operands' @ [705:63] ==> value-parameter operands: List<Expression> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.polyadicExpressionToBinaryExpressions[ValueParameterDescriptorImpl]

'subList' @ [705:72] ==> public abstract fun subList(fromIndex: Int, toIndex: Int): List<Expression> defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'index' @ [705:80] ==> var index: Int defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.polyadicExpressionToBinaryExpressions[LocalVariableDescriptor]

'operands' @ [705:91] ==> value-parameter operands: List<Expression> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.polyadicExpressionToBinaryExpressions[ValueParameterDescriptorImpl]

'size' @ [705:100] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'operators' @ [706:63] ==> value-parameter operators: List<Operator> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.polyadicExpressionToBinaryExpressions[ValueParameterDescriptorImpl]

'subList' @ [706:73] ==> public abstract fun subList(fromIndex: Int, toIndex: Int): List<Operator> defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'index' @ [706:81] ==> var index: Int defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.polyadicExpressionToBinaryExpressions[LocalVariableDescriptor]

'operators' @ [706:92] ==> value-parameter operators: List<Operator> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.polyadicExpressionToBinaryExpressions[ValueParameterDescriptorImpl]

'size' @ [706:102] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'BinaryExpression' @ [707:20] ==> public constructor BinaryExpression(left: Expression, right: Expression, op: Operator) defined in org.jetbrains.kotlin.j2k.ast.BinaryExpression[ClassConstructorDescriptorImpl]

'left' @ [707:37] ==> val left: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.polyadicExpressionToBinaryExpressions[LocalVariableDescriptor]

'right' @ [707:43] ==> val right: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.polyadicExpressionToBinaryExpressions[LocalVariableDescriptor]

'op' @ [707:50] ==> var op: Operator defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.polyadicExpressionToBinaryExpressions[LocalVariableDescriptor]

'assignNoPrototype' @ [707:54] ==> public fun <TElement : Element> BinaryExpression.assignNoPrototype(): BinaryExpression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> BinaryExpression

'expression' @ [712:20] ==> value-parameter expression: PsiPolyadicExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPolyadicExpression[ValueParameterDescriptorImpl]

'operands' @ [712:31] ==> public final val PsiPolyadicExpression.operands: (Array<(PsiExpression..PsiExpression?)>..Array<out (PsiExpression..PsiExpression?)>)[MyPropertyDescriptor]

'map' @ [712:40] ==> public inline fun <T, R> Array<out (PsiExpression..PsiExpression?)>.map(transform: ((PsiExpression..PsiExpression?)) -> Expression): List<Expression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiExpression..com.intellij.psi.PsiExpression?)
    <R> -> Expression

'codeConverter' @ [713:13] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [713:27] ==> public final fun convertExpression(expression: PsiExpression?, expectedType: PsiType?, expectedNullability: Nullability? = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'it' @ [713:45] ==> value-parameter it: (PsiExpression..PsiExpression?) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPolyadicExpression.<anonymous>[ValueParameterDescriptorImpl]

'expression' @ [713:49] ==> value-parameter expression: PsiPolyadicExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPolyadicExpression[ValueParameterDescriptorImpl]

'type' @ [713:60] ==> public final val PsiPolyadicExpression.type: PsiType?[MyPropertyDescriptor]

'assignPrototype' @ [713:66] ==> public fun <TElement : Element> Expression.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Expression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Expression

'it' @ [713:82] ==> value-parameter it: (PsiExpression..PsiExpression?) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPolyadicExpression.<anonymous>[ValueParameterDescriptorImpl]

'LINE_BREAKS' @ [713:115] ==> public final val LINE_BREAKS: CommentsAndSpacesInheritance defined in org.jetbrains.kotlin.j2k.ast.CommentsAndSpacesInheritance.Companion[PropertyDescriptorImpl]

'expression' @ [715:25] ==> value-parameter expression: PsiPolyadicExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPolyadicExpression[ValueParameterDescriptorImpl]

'operands' @ [715:36] ==> public final val PsiPolyadicExpression.operands: (Array<(PsiExpression..PsiExpression?)>..Array<out (PsiExpression..PsiExpression?)>)[MyPropertyDescriptor]

'mapNotNull' @ [715:45] ==> public inline fun <T, R : Any> Array<out (PsiExpression..PsiExpression?)>.mapNotNull(transform: ((PsiExpression..PsiExpression?)) -> Operator?): List<Operator> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiExpression..com.intellij.psi.PsiExpression?)
    <R : Any> -> Operator

'expression' @ [716:13] ==> value-parameter expression: PsiPolyadicExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPolyadicExpression[ValueParameterDescriptorImpl]

'getTokenBeforeOperand' @ [716:24] ==> @Nullable public abstract fun getTokenBeforeOperand(@NotNull p0: PsiExpression): PsiJavaToken? defined in com.intellij.psi.PsiPolyadicExpression[JavaMethodDescriptor]

'it' @ [716:46] ==> value-parameter it: (PsiExpression..PsiExpression?) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPolyadicExpression.<anonymous>[ValueParameterDescriptorImpl]

'let' @ [716:51] ==> @InlineOnly public inline fun <T, R> PsiJavaToken.let(block: (PsiJavaToken) -> Operator): Operator defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiJavaToken
    <R> -> Operator

'Operator' @ [716:57] ==> public constructor Operator(operatorType: IElementType) defined in org.jetbrains.kotlin.j2k.ast.Operator[ClassConstructorDescriptorImpl]

'it' @ [716:66] ==> value-parameter it: PsiJavaToken defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPolyadicExpression.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'tokenType' @ [716:69] ==> public final val PsiJavaToken.tokenType: (IElementType..IElementType?)[MyPropertyDescriptor]

'assignPrototype' @ [716:80] ==> public fun <TElement : Element> Operator.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Operator defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Operator

'it' @ [716:96] ==> value-parameter it: PsiJavaToken defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPolyadicExpression.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'LINE_BREAKS' @ [716:129] ==> public final val LINE_BREAKS: CommentsAndSpacesInheritance defined in org.jetbrains.kotlin.j2k.ast.CommentsAndSpacesInheritance.Companion[PropertyDescriptorImpl]

'result' @ [718:9] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'polyadicExpressionToBinaryExpressions' @ [718:18] ==> private final fun polyadicExpressionToBinaryExpressions(operands: List<Expression>, operators: List<Operator>): Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[SimpleFunctionDescriptorImpl]

'args' @ [718:56] ==> val args: List<Expression> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPolyadicExpression[LocalVariableDescriptor]

'operators' @ [718:62] ==> val operators: List<Operator> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPolyadicExpression[LocalVariableDescriptor]

'!' @ [719:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'expression' @ [719:14] ==> value-parameter expression: PsiPolyadicExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitPolyadicExpression[ValueParameterDescriptorImpl]

'isInSingleLine' @ [719:25] ==> public fun PsiElement.isInSingleLine(): Boolean defined in org.jetbrains.kotlin.j2k in file Utils.kt[SimpleFunctionDescriptorImpl]

'result' @ [720:13] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'ParenthesizedExpression' @ [720:22] ==> public constructor ParenthesizedExpression(expression: Expression) defined in org.jetbrains.kotlin.j2k.ast.ParenthesizedExpression[ClassConstructorDescriptorImpl]

'result' @ [720:46] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'assignNoPrototype' @ [720:53] ==> public fun <TElement : Element> Expression.assignNoPrototype(): Expression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Expression

'expression' @ [725:28] ==> value-parameter expression: PsiCallExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments[ValueParameterDescriptorImpl]

'argumentList' @ [725:39] ==> public final val PsiCallExpression.argumentList: PsiExpressionList?[MyPropertyDescriptor]

'argumentList' @ [726:25] ==> val argumentList: PsiExpressionList? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments[LocalVariableDescriptor]

'expressions' @ [726:39] ==> public final val PsiExpressionList.expressions: (Array<(PsiExpression..PsiExpression?)>..Array<out (PsiExpression..PsiExpression?)>)[MyPropertyDescriptor]

'toList' @ [726:52] ==> public fun <T> Array<out (PsiExpression..PsiExpression?)>.toList(): List<(PsiExpression..PsiExpression?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiExpression..com.intellij.psi.PsiExpression?)

'listOf' @ [726:64] ==> @InlineOnly public inline fun <T> listOf(): List<(PsiExpression..PsiExpression?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiExpression..com.intellij.psi.PsiExpression?)

'isExtension' @ [727:13] ==> value-parameter isExtension: Boolean = ... defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments[ValueParameterDescriptorImpl]

'arguments' @ [727:28] ==> var arguments: List<(PsiExpression..PsiExpression?)> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments[LocalVariableDescriptor]

'isNotEmpty' @ [727:38] ==> @InlineOnly public inline fun <T> Collection<(PsiExpression..PsiExpression?)>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiExpression..com.intellij.psi.PsiExpression?)

'arguments' @ [728:13] ==> var arguments: List<(PsiExpression..PsiExpression?)> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments[LocalVariableDescriptor]

'arguments' @ [728:25] ==> var arguments: List<(PsiExpression..PsiExpression?)> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments[LocalVariableDescriptor]

'drop' @ [728:35] ==> public fun <T> Iterable<(PsiExpression..PsiExpression?)>.drop(n: Int): List<(PsiExpression..PsiExpression?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiExpression..com.intellij.psi.PsiExpression?)

'expression' @ [731:24] ==> value-parameter expression: PsiCallExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments[ValueParameterDescriptorImpl]

'resolveMethod' @ [731:35] ==> @Nullable public abstract fun resolveMethod(): PsiMethod? defined in com.intellij.psi.PsiCallExpression[JavaMethodDescriptor]

'resolved' @ [732:26] ==> val resolved: PsiMethod? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments[LocalVariableDescriptor]

'parameterList' @ [732:36] ==> public final val PsiMethod.parameterList: PsiParameterList[MyPropertyDescriptor]

'parameters' @ [732:51] ==> public final val PsiParameterList.parameters: (Array<(PsiParameter..PsiParameter?)>..Array<out (PsiParameter..PsiParameter?)>)[MyPropertyDescriptor]

'arrayOf' @ [732:65] ==> public inline fun <reified @PureReifiable T> arrayOf(vararg elements: (PsiParameter..PsiParameter?)): Array<(PsiParameter..PsiParameter?)> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified @PureReifiable T> -> (com.intellij.psi.PsiParameter..com.intellij.psi.PsiParameter?)

'CommentsAndSpacesInheritance' @ [734:44] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.CommentsAndSpacesInheritance[FakeCallableDescriptorForObject]

'LINE_BREAKS' @ [734:73] ==> public final val LINE_BREAKS: CommentsAndSpacesInheritance defined in org.jetbrains.kotlin.j2k.ast.CommentsAndSpacesInheritance.Companion[PropertyDescriptorImpl]

'if (arguments.size == parameters.size) {
            arguments.mapIndexed { i, argument ->
                val expectedNullability = typeConverter.variableNullability(parameters[i])
                val converted = codeConverter.convertExpression(argument, parameters[i].type, expectedNullability)

                val result = if (i == arguments.lastIndex && parameters[i].isVarArgs && argument.type is PsiArrayType)
                    StarExpression(converted)
                else
                    converted
                result.assignPrototype(argument, commentsAndSpacesInheritance)
            }
        }
        else {
            codeConverter.convertExpressionsInList(arguments)
        }' @ [736:34] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<Expression>, elseBranch: List<Expression>): List<Expression>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<Expression>

'arguments' @ [736:38] ==> var arguments: List<(PsiExpression..PsiExpression?)> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments[LocalVariableDescriptor]

'size' @ [736:48] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'parameters' @ [736:56] ==> val parameters: (Array<(PsiParameter..PsiParameter?)>..Array<out (PsiParameter..PsiParameter?)>) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments[LocalVariableDescriptor]

'size' @ [736:67] ==> public final val size: Int defined in kotlin.Array[DeserializedPropertyDescriptor]

'arguments' @ [737:13] ==> var arguments: List<(PsiExpression..PsiExpression?)> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments[LocalVariableDescriptor]

'mapIndexed' @ [737:23] ==> public inline fun <T, R> Iterable<(PsiExpression..PsiExpression?)>.mapIndexed(transform: (index: Int, (PsiExpression..PsiExpression?)) -> Expression): List<Expression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiExpression..com.intellij.psi.PsiExpression?)
    <R> -> Expression

'typeConverter' @ [738:43] ==> private final val typeConverter: TypeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'variableNullability' @ [738:57] ==> public final fun variableNullability(variable: PsiVariable): Nullability defined in org.jetbrains.kotlin.j2k.TypeConverter[SimpleFunctionDescriptorImpl]

'parameters' @ [738:77] ==> val parameters: (Array<(PsiParameter..PsiParameter?)>..Array<out (PsiParameter..PsiParameter?)>) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments[LocalVariableDescriptor]

'i' @ [738:88] ==> value-parameter i: Int defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments.<anonymous>[ValueParameterDescriptorImpl]

'codeConverter' @ [739:33] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [739:47] ==> public final fun convertExpression(expression: PsiExpression?, expectedType: PsiType?, expectedNullability: Nullability? = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'argument' @ [739:65] ==> value-parameter argument: (PsiExpression..PsiExpression?) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments.<anonymous>[ValueParameterDescriptorImpl]

'parameters' @ [739:75] ==> val parameters: (Array<(PsiParameter..PsiParameter?)>..Array<out (PsiParameter..PsiParameter?)>) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments[LocalVariableDescriptor]

'i' @ [739:86] ==> value-parameter i: Int defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [739:89] ==> public final val PsiParameter.type: PsiType[MyPropertyDescriptor]

'expectedNullability' @ [739:95] ==> val expectedNullability: Nullability defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments.<anonymous>[LocalVariableDescriptor]

'if (i == arguments.lastIndex && parameters[i].isVarArgs && argument.type is PsiArrayType)
                    StarExpression(converted)
                else
                    converted' @ [741:30] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Expression, elseBranch: Expression): Expression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Expression

'i' @ [741:34] ==> value-parameter i: Int defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments.<anonymous>[ValueParameterDescriptorImpl]

'arguments' @ [741:39] ==> var arguments: List<(PsiExpression..PsiExpression?)> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments[LocalVariableDescriptor]

'lastIndex' @ [741:49] ==> public val <T> List<(PsiExpression..PsiExpression?)>.lastIndex: Int defined in kotlin.collections[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiExpression..com.intellij.psi.PsiExpression?)

'parameters' @ [741:62] ==> val parameters: (Array<(PsiParameter..PsiParameter?)>..Array<out (PsiParameter..PsiParameter?)>) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments[LocalVariableDescriptor]

'i' @ [741:73] ==> value-parameter i: Int defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments.<anonymous>[ValueParameterDescriptorImpl]

'isVarArgs' @ [741:76] ==> public final val PsiParameter.isVarArgs: Boolean[MyPropertyDescriptor]

'argument' @ [741:89] ==> value-parameter argument: (PsiExpression..PsiExpression?) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [741:98] ==> public final val PsiExpression.type: PsiType?[MyPropertyDescriptor]

'StarExpression' @ [742:21] ==> public constructor StarExpression(operand: Expression) defined in org.jetbrains.kotlin.j2k.ast.StarExpression[ClassConstructorDescriptorImpl]

'converted' @ [742:36] ==> val converted: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments.<anonymous>[LocalVariableDescriptor]

'converted' @ [744:21] ==> val converted: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments.<anonymous>[LocalVariableDescriptor]

'result' @ [745:17] ==> val result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments.<anonymous>[LocalVariableDescriptor]

'assignPrototype' @ [745:24] ==> public fun <TElement : Element> Expression.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Expression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Expression

'argument' @ [745:40] ==> value-parameter argument: (PsiExpression..PsiExpression?) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments.<anonymous>[ValueParameterDescriptorImpl]

'commentsAndSpacesInheritance' @ [745:50] ==> val commentsAndSpacesInheritance: CommentsAndSpacesInheritance defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments[LocalVariableDescriptor]

'codeConverter' @ [749:13] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpressionsInList' @ [749:27] ==> public final fun convertExpressionsInList(expressions: List<PsiExpression>): List<Expression> defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'arguments' @ [749:52] ==> var arguments: List<(PsiExpression..PsiExpression?)> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments[LocalVariableDescriptor]

'argumentList' @ [752:20] ==> val argumentList: PsiExpressionList? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments[LocalVariableDescriptor]

'lPar' @ [752:34] ==> public fun PsiExpressionList.lPar(): PsiElement? defined in org.jetbrains.kotlin.j2k in file Utils.kt[SimpleFunctionDescriptorImpl]

'argumentList' @ [753:20] ==> val argumentList: PsiExpressionList? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments[LocalVariableDescriptor]

'rPar' @ [753:34] ==> public fun PsiExpressionList.rPar(): PsiElement? defined in org.jetbrains.kotlin.j2k in file Utils.kt[SimpleFunctionDescriptorImpl]

'ArgumentList' @ [754:16] ==> public constructor ArgumentList(expressions: List<Expression>, lPar: LPar, rPar: RPar) defined in org.jetbrains.kotlin.j2k.ast.ArgumentList[ClassConstructorDescriptorImpl]

'convertedArguments' @ [754:29] ==> val convertedArguments: List<Expression> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments[LocalVariableDescriptor]

'withPrototype' @ [754:54] ==> public final fun withPrototype(element: PsiElement?): LPar defined in org.jetbrains.kotlin.j2k.ast.LPar.Companion[SimpleFunctionDescriptorImpl]

'lPar' @ [754:68] ==> val lPar: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments[LocalVariableDescriptor]

'withPrototype' @ [754:80] ==> public final fun withPrototype(element: PsiElement?): RPar defined in org.jetbrains.kotlin.j2k.ast.RPar.Companion[SimpleFunctionDescriptorImpl]

'rPar' @ [754:94] ==> val rPar: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments[LocalVariableDescriptor]

'assignPrototype' @ [754:101] ==> public fun <TElement : Element> ArgumentList.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): ArgumentList defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> ArgumentList

'argumentList' @ [754:117] ==> val argumentList: PsiExpressionList? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertArguments[LocalVariableDescriptor]

'expression' @ [758:26] ==> value-parameter expression: PsiLambdaExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression[ValueParameterDescriptorImpl]

'parameterList' @ [758:37] ==> public final val PsiLambdaExpression.parameterList: PsiParameterList[MyPropertyDescriptor]

'ParameterList' @ [759:35] ==> public constructor ParameterList(parameters: List<Parameter>, lPar: LPar?, rPar: RPar?) defined in org.jetbrains.kotlin.j2k.ast.ParameterList[ClassConstructorDescriptorImpl]

'parameters' @ [759:49] ==> val parameters: PsiParameterList defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression[LocalVariableDescriptor]

'parameters' @ [759:60] ==> public final val PsiParameterList.parameters: (Array<(PsiParameter..PsiParameter?)>..Array<out (PsiParameter..PsiParameter?)>)[MyPropertyDescriptor]

'map' @ [759:71] ==> public inline fun <T, R> Array<out (PsiParameter..PsiParameter?)>.map(transform: ((PsiParameter..PsiParameter?)) -> LambdaParameter): List<LambdaParameter> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiParameter..com.intellij.psi.PsiParameter?)
    <R> -> LambdaParameter

'Identifier' @ [760:29] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.Identifier[FakeCallableDescriptorForObject]

'withNoPrototype' @ [760:40] ==> public final fun withNoPrototype(name: String, isNullable: Boolean = ..., quotingNeeded: Boolean = ..., imports: Collection<FqName> = ...): Identifier defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[SimpleFunctionDescriptorImpl]

'it' @ [760:56] ==> value-parameter it: (PsiParameter..PsiParameter?) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [760:59] ==> public final val PsiParameter.name: String?[MyPropertyDescriptor]

'if (it.typeElement != null) converter.typeConverter.convertType(it.type) else null' @ [761:29] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Type?, elseBranch: Type?): Type?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Type?

'it' @ [761:33] ==> value-parameter it: (PsiParameter..PsiParameter?) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression.<anonymous>[ValueParameterDescriptorImpl]

'typeElement' @ [761:36] ==> public final val PsiParameter.typeElement: PsiTypeElement?[MyPropertyDescriptor]

'converter' @ [761:57] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'typeConverter' @ [761:67] ==> public final val typeConverter: TypeConverter defined in org.jetbrains.kotlin.j2k.Converter[PropertyDescriptorImpl]

'convertType' @ [761:81] ==> public final fun convertType(type: PsiType?, nullability: Nullability = ..., mutability: Mutability = ..., inAnnotationType: Boolean = ...): Type defined in org.jetbrains.kotlin.j2k.TypeConverter[SimpleFunctionDescriptorImpl]

'it' @ [761:93] ==> value-parameter it: (PsiParameter..PsiParameter?) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [761:96] ==> public final val PsiParameter.type: PsiType[MyPropertyDescriptor]

'LambdaParameter' @ [762:13] ==> public constructor LambdaParameter(identifier: Identifier, type: Type?) defined in org.jetbrains.kotlin.j2k.ast.LambdaParameter[ClassConstructorDescriptorImpl]

'paramName' @ [762:29] ==> val paramName: Identifier defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression.<anonymous>[LocalVariableDescriptor]

'paramType' @ [762:40] ==> val paramType: Type? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression.<anonymous>[LocalVariableDescriptor]

'assignPrototype' @ [762:51] ==> public fun <TElement : Element> LambdaParameter.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): LambdaParameter defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> LambdaParameter

'it' @ [762:67] ==> value-parameter it: (PsiParameter..PsiParameter?) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression.<anonymous>[ValueParameterDescriptorImpl]

'assignPrototype' @ [763:38] ==> public fun <TElement : Element> ParameterList.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): ParameterList defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> ParameterList

'parameters' @ [763:54] ==> val parameters: PsiParameterList defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression[LocalVariableDescriptor]

'expression' @ [765:20] ==> value-parameter expression: PsiLambdaExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression[ValueParameterDescriptorImpl]

'body' @ [765:31] ==> public final val PsiLambdaExpression.body: PsiElement?[MyPropertyDescriptor]

'when (body) {
            is PsiExpression -> {
                val convertedBody = codeConverter.convertExpression(body).assignPrototype(body)
                result = LambdaExpression(convertedParameters, Block.of(convertedBody).assignNoPrototype())
            }
            is PsiCodeBlock -> {
                val convertedBlock = codeConverter.withSpecialStatementConverter(object : SpecialStatementConverter {
                    override fun convertStatement(statement: PsiStatement, codeConverter: CodeConverter): Statement? {
                        if (statement !is PsiReturnStatement) return null

                        val returnValue = statement.returnValue
                        val methodReturnType = codeConverter.methodReturnType
                        val expressionForReturn = if (returnValue != null && methodReturnType != null)
                            codeConverter.convertExpression(returnValue, methodReturnType)
                        else
                            codeConverter.convertExpression(returnValue)

                        if (body.statements.lastOrNull() == statement) {
                            return expressionForReturn
                        }

                        val callExpression = expression.getParentOfType<PsiMethodCallExpression>(false)
                        if (callExpression != null) {
                            return ReturnStatement(expressionForReturn, Identifier.withNoPrototype(callExpression.methodExpression.text))
                        }

                        return ReturnStatement(expressionForReturn)
                    }

                }).convertBlock(body).assignPrototype(body)
                result = LambdaExpression(convertedParameters, convertedBlock)
            }
        }' @ [766:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'body' @ [766:15] ==> val body: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression[LocalVariableDescriptor]

'codeConverter' @ [768:37] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [768:51] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'body' @ [768:69] ==> val body: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression[LocalVariableDescriptor]

'assignPrototype' @ [768:75] ==> public fun <TElement : Element> Expression.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Expression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Expression

'body' @ [768:91] ==> val body: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression[LocalVariableDescriptor]

'result' @ [769:17] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'LambdaExpression' @ [769:26] ==> public constructor LambdaExpression(parameterList: ParameterList?, block: Block) defined in org.jetbrains.kotlin.j2k.ast.LambdaExpression[ClassConstructorDescriptorImpl]

'convertedParameters' @ [769:43] ==> val convertedParameters: ParameterList defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression[LocalVariableDescriptor]

'of' @ [769:70] ==> public final fun of(statement: Statement): Block defined in org.jetbrains.kotlin.j2k.ast.Block.Companion[SimpleFunctionDescriptorImpl]

'convertedBody' @ [769:73] ==> val convertedBody: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression[LocalVariableDescriptor]

'assignNoPrototype' @ [769:88] ==> public fun <TElement : Element> Block.assignNoPrototype(): Block defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Block

'codeConverter' @ [772:38] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'withSpecialStatementConverter' @ [772:52] ==> public final fun withSpecialStatementConverter(specialConverter: SpecialStatementConverter): CodeConverter defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'statement' @ [774:29] ==> value-parameter statement: PsiStatement defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression.<no name provided>.convertStatement[ValueParameterDescriptorImpl]

'statement' @ [776:43] ==> value-parameter statement: PsiStatement defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression.<no name provided>.convertStatement[ValueParameterDescriptorImpl]

'returnValue' @ [776:53] ==> public final val PsiReturnStatement.returnValue: PsiExpression?[MyPropertyDescriptor]

'codeConverter' @ [777:48] ==> value-parameter codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression.<no name provided>.convertStatement[ValueParameterDescriptorImpl]

'methodReturnType' @ [777:62] ==> public final val methodReturnType: PsiType? defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'if (returnValue != null && methodReturnType != null)
                            codeConverter.convertExpression(returnValue, methodReturnType)
                        else
                            codeConverter.convertExpression(returnValue)' @ [778:51] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Expression, elseBranch: Expression): Expression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Expression

'returnValue' @ [778:55] ==> val returnValue: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression.<no name provided>.convertStatement[LocalVariableDescriptor]

'methodReturnType' @ [778:78] ==> val methodReturnType: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression.<no name provided>.convertStatement[LocalVariableDescriptor]

'codeConverter' @ [779:29] ==> value-parameter codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression.<no name provided>.convertStatement[ValueParameterDescriptorImpl]

'convertExpression' @ [779:43] ==> public final fun convertExpression(expression: PsiExpression?, expectedType: PsiType?, expectedNullability: Nullability? = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'returnValue' @ [779:61] ==> val returnValue: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression.<no name provided>.convertStatement[LocalVariableDescriptor]

'methodReturnType' @ [779:74] ==> val methodReturnType: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression.<no name provided>.convertStatement[LocalVariableDescriptor]

'codeConverter' @ [781:29] ==> value-parameter codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression.<no name provided>.convertStatement[ValueParameterDescriptorImpl]

'convertExpression' @ [781:43] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'returnValue' @ [781:61] ==> val returnValue: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression.<no name provided>.convertStatement[LocalVariableDescriptor]

'body' @ [783:29] ==> val body: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression[LocalVariableDescriptor]

'statements' @ [783:34] ==> public final val PsiCodeBlock.statements: (Array<(PsiStatement..PsiStatement?)>..Array<out (PsiStatement..PsiStatement?)>)[MyPropertyDescriptor]

'lastOrNull' @ [783:45] ==> public fun <T> Array<out (PsiStatement..PsiStatement?)>.lastOrNull(): PsiStatement? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiStatement..com.intellij.psi.PsiStatement?)

'statement' @ [783:61] ==> value-parameter statement: PsiStatement defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression.<no name provided>.convertStatement[ValueParameterDescriptorImpl]

'expressionForReturn' @ [784:36] ==> val expressionForReturn: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression.<no name provided>.convertStatement[LocalVariableDescriptor]

'expression' @ [787:46] ==> value-parameter expression: PsiLambdaExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression[ValueParameterDescriptorImpl]

'getParentOfType' @ [787:57] ==> public inline fun <reified T : PsiElement> PsiElement.getParentOfType(strict: Boolean): PsiMethodCallExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> PsiMethodCallExpression

'callExpression' @ [788:29] ==> val callExpression: PsiMethodCallExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression.<no name provided>.convertStatement[LocalVariableDescriptor]

'ReturnStatement' @ [789:36] ==> public constructor ReturnStatement(expression: Expression, label: Identifier? = ...) defined in org.jetbrains.kotlin.j2k.ast.ReturnStatement[ClassConstructorDescriptorImpl]

'expressionForReturn' @ [789:52] ==> val expressionForReturn: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression.<no name provided>.convertStatement[LocalVariableDescriptor]

'withNoPrototype' @ [789:84] ==> public final fun withNoPrototype(name: String, isNullable: Boolean = ..., quotingNeeded: Boolean = ..., imports: Collection<FqName> = ...): Identifier defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[SimpleFunctionDescriptorImpl]

'callExpression' @ [789:100] ==> val callExpression: PsiMethodCallExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression.<no name provided>.convertStatement[LocalVariableDescriptor]

'methodExpression' @ [789:115] ==> public final val PsiMethodCallExpression.methodExpression: PsiReferenceExpression[MyPropertyDescriptor]

'text' @ [789:132] ==> public final val PsiReferenceExpression.text: (String..String?)[MyPropertyDescriptor]

'ReturnStatement' @ [792:32] ==> public constructor ReturnStatement(expression: Expression, label: Identifier? = ...) defined in org.jetbrains.kotlin.j2k.ast.ReturnStatement[ClassConstructorDescriptorImpl]

'expressionForReturn' @ [792:48] ==> val expressionForReturn: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression.<no name provided>.convertStatement[LocalVariableDescriptor]

'convertBlock' @ [795:20] ==> public final fun convertBlock(block: PsiCodeBlock?, notEmpty: Boolean = ..., statementFilter: (PsiStatement) -> Boolean = ...): Block defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'body' @ [795:33] ==> val body: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression[LocalVariableDescriptor]

'assignPrototype' @ [795:39] ==> public fun <TElement : Element> Block.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Block defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Block

'body' @ [795:55] ==> val body: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression[LocalVariableDescriptor]

'result' @ [796:17] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'LambdaExpression' @ [796:26] ==> public constructor LambdaExpression(parameterList: ParameterList?, block: Block) defined in org.jetbrains.kotlin.j2k.ast.LambdaExpression[ClassConstructorDescriptorImpl]

'convertedParameters' @ [796:43] ==> val convertedParameters: ParameterList defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression[LocalVariableDescriptor]

'convertedBlock' @ [796:64] ==> val convertedBlock: Block defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitLambdaExpression[LocalVariableDescriptor]

'getQualifierType' @ [802:52] ==> @Nullable public open fun getQualifierType(p0: (PsiMethodReferenceExpression..PsiMethodReferenceExpression?)): PsiType? defined in com.intellij.psi.PsiMethodReferenceUtil[JavaMethodDescriptor]

'expression' @ [802:69] ==> value-parameter expression: PsiMethodReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[ValueParameterDescriptorImpl]

'qualifierType' @ [803:13] ==> val qualifierType: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'result' @ [804:13] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'DummyStringExpression' @ [804:22] ==> public constructor DummyStringExpression(string: String) defined in org.jetbrains.kotlin.j2k.ast.DummyStringExpression[ClassConstructorDescriptorImpl]

'expression' @ [804:44] ==> value-parameter expression: PsiMethodReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[ValueParameterDescriptorImpl]

'text' @ [804:55] ==> public final val PsiMethodReferenceExpression.text: (String..String?)[MyPropertyDescriptor]

'expression' @ [808:25] ==> value-parameter expression: PsiMethodReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[ValueParameterDescriptorImpl]

'qualifier' @ [808:36] ==> public final val PsiMethodReferenceExpression.qualifier: PsiElement?[MyPropertyDescriptor]

'qualifier' @ [809:13] ==> val qualifier: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'result' @ [811:13] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'DummyStringExpression' @ [811:22] ==> public constructor DummyStringExpression(string: String) defined in org.jetbrains.kotlin.j2k.ast.DummyStringExpression[ClassConstructorDescriptorImpl]

'expression' @ [811:44] ==> value-parameter expression: PsiMethodReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[ValueParameterDescriptorImpl]

'text' @ [811:55] ==> public final val PsiMethodReferenceExpression.text: (String..String?)[MyPropertyDescriptor]

'expression' @ [816:28] ==> value-parameter expression: PsiMethodReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[ValueParameterDescriptorImpl]

'getParentOfType' @ [816:39] ==> public inline fun <reified T : PsiElement> PsiElement.getParentOfType(strict: Boolean): PsiClass? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> PsiClass

'expression' @ [817:30] ==> value-parameter expression: PsiMethodReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[ValueParameterDescriptorImpl]

'functionalInterfaceType' @ [817:41] ==> public final val PsiMethodReferenceExpression.functionalInterfaceType: PsiType?[MyPropertyDescriptor]

'qualifier' @ [819:34] ==> val qualifier: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'resolve' @ [819:63] ==> @Nullable public abstract fun resolve(): PsiElement? defined in com.intellij.psi.PsiReference[JavaMethodDescriptor]

'isFunctionType' @ [820:36] ==> private final fun isFunctionType(functionalType: PsiType?): Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[SimpleFunctionDescriptorImpl]

'functionalType' @ [820:51] ==> val functionalType: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'expression' @ [823:22] ==> value-parameter expression: PsiMethodReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[ValueParameterDescriptorImpl]

'resolve' @ [823:33] ==> @Nullable public abstract fun resolve(): PsiElement? defined in com.intellij.psi.PsiMethodReferenceExpression[JavaMethodDescriptor]

'method' @ [825:33] ==> val method: PsiMethod? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'hasModifierProperty' @ [825:41] ==> public abstract fun hasModifierProperty(@PsiModifier.ModifierConstant @NonNls @NotNull p0: String): Boolean defined in com.intellij.psi.PsiMethod[JavaMethodDescriptor]

'STATIC' @ [825:73] ==> public const final val STATIC: String defined in com.intellij.psi.PsiModifier[JavaPropertyDescriptor]

'!' @ [826:24] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'hasStaticModifier' @ [826:25] ==> val hasStaticModifier: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'!' @ [826:46] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'expression' @ [826:47] ==> value-parameter expression: PsiMethodReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[ValueParameterDescriptorImpl]

'isConstructor' @ [826:58] ==> public final val PsiMethodReferenceExpression.isConstructor: Boolean[MyPropertyDescriptor]

'isTypeInQualifier' @ [826:75] ==> val isTypeInQualifier: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'method' @ [828:26] ==> val method: PsiMethod? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'getParametersForMethodReference' @ [828:34] ==> private final fun PsiMethod.getParametersForMethodReference(needThis: Boolean, isKotlinFunctionType: Boolean): List<Pair<Identifier, Type?>> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[SimpleFunctionDescriptorImpl]

'needThis' @ [828:66] ==> val needThis: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'isKotlinFunctionType' @ [828:76] ==> val isKotlinFunctionType: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'emptyList' @ [828:101] ==> public fun <T> emptyList(): List<Pair<Identifier, Type?>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<Identifier, Type?>

'when {
            expression.isConstructor -> null
            needThis -> parameters.firstOrNull()
            isTypeInQualifier && method?.containingClass == contextClass -> null
            qualifier is PsiExpression -> codeConverter.convertExpression(qualifier) to null
            else -> null
        }' @ [830:24] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Pair<Expression, Type?>?, entry1: Pair<Expression, Type?>?, entry2: Pair<Expression, Type?>?, entry3: Pair<Expression, Type?>?, entry4: Pair<Expression, Type?>?): Pair<Expression, Type?>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Pair<Expression, Type?>?

'expression' @ [831:13] ==> value-parameter expression: PsiMethodReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[ValueParameterDescriptorImpl]

'isConstructor' @ [831:24] ==> public final val PsiMethodReferenceExpression.isConstructor: Boolean[MyPropertyDescriptor]

'needThis' @ [832:13] ==> val needThis: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'parameters' @ [832:25] ==> val parameters: List<Pair<Identifier, Type?>> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'firstOrNull' @ [832:36] ==> public fun <T> List<Pair<Identifier, Type?>>.firstOrNull(): Pair<Identifier, Type?>? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<Identifier, Type?>

'isTypeInQualifier' @ [833:13] ==> val isTypeInQualifier: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'method' @ [833:34] ==> val method: PsiMethod? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'containingClass' @ [833:42] ==> public final val PsiMethod.containingClass: PsiClass?[MyPropertyDescriptor]

'contextClass' @ [833:61] ==> val contextClass: PsiClass? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'qualifier' @ [834:13] ==> val qualifier: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'codeConverter' @ [834:43] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [834:57] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'qualifier' @ [834:75] ==> val qualifier: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'if (needThis) parameters.drop(1) else parameters' @ [838:26] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<Pair<Identifier, Type?>>, elseBranch: List<Pair<Identifier, Type?>>): List<Pair<Identifier, Type?>>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<Pair<Identifier, Type?>>

'needThis' @ [838:30] ==> val needThis: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'parameters' @ [838:40] ==> val parameters: List<Pair<Identifier, Type?>> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'drop' @ [838:51] ==> public fun <T> Iterable<Pair<Identifier, Type?>>.drop(n: Int): List<Pair<Identifier, Type?>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<Identifier, Type?>

'parameters' @ [838:64] ==> val parameters: List<Pair<Identifier, Type?>> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'method' @ [840:29] ==> val method: PsiMethod? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'let' @ [840:37] ==> @InlineOnly public inline fun <T, R> PsiMethod.let(block: (PsiMethod) -> SpecialMethod?): SpecialMethod? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiMethod
    <R> -> SpecialMethod?

'SpecialMethod' @ [840:43] ==> public companion object defined in org.jetbrains.kotlin.j2k.SpecialMethod[FakeCallableDescriptorForObject]

'match' @ [840:57] ==> public final fun match(method: PsiMethod, argumentCount: Int, services: JavaToKotlinConverterServices): SpecialMethod? defined in org.jetbrains.kotlin.j2k.SpecialMethod.Companion[SimpleFunctionDescriptorImpl]

'it' @ [840:63] ==> value-parameter it: PsiMethod defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression.<anonymous>[ValueParameterDescriptorImpl]

'callParams' @ [840:67] ==> val callParams: List<Pair<Identifier, Type?>> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'size' @ [840:78] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'converter' @ [840:84] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'services' @ [840:94] ==> public final val services: JavaToKotlinConverterServices defined in org.jetbrains.kotlin.j2k.Converter[PropertyDescriptorImpl]

'when {
            expression.isConstructor -> {
                val argumentList = ArgumentList.withNoPrototype(callParams.map { it.first })
                statement = MethodCallExpression.buildNonNull(null, convertMethodReferenceQualifier(qualifier), argumentList)
            }
            specialMethod != null -> {
                val factory = PsiElementFactory.SERVICE.getInstance(converter.project)
                val fakeReceiver = receiver?.let {
                    val psiExpression = qualifier as? PsiExpression ?: factory.createExpressionFromText("fakeReceiver", null)
                    psiExpression.convertedExpression = it.first
                    psiExpression
                }
                val fakeParams = callParams.mapIndexed { i, param ->
                    with(factory.createExpressionFromText("fake$i", null)) {
                        this.convertedExpression = param.first
                        this
                    }
                }
                val patchedConverter = codeConverter.withSpecialExpressionConverter(object : SpecialExpressionConverter {
                    override fun convertExpression(expression: PsiExpression, codeConverter: CodeConverter): Expression? {
                        val convertedExpression = expression.convertedExpression
                        expression.convertedExpression = null
                        return convertedExpression
                    }
                })

                val callData = SpecialMethod.ConvertCallData(fakeReceiver, fakeParams, emptyList(), null, null, null, patchedConverter)
                statement = specialMethod.convertCall(callData)!!
            }
            else -> {
                val referenceName = expression.referenceName!!
                val argumentList = ArgumentList.withNoPrototype(callParams.map { it.first })
                statement = MethodCallExpression.buildNonNull(receiver?.first, referenceName, argumentList)
            }
        }' @ [842:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'expression' @ [843:13] ==> value-parameter expression: PsiMethodReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[ValueParameterDescriptorImpl]

'isConstructor' @ [843:24] ==> public final val PsiMethodReferenceExpression.isConstructor: Boolean[MyPropertyDescriptor]

'ArgumentList' @ [844:36] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.ArgumentList[FakeCallableDescriptorForObject]

'withNoPrototype' @ [844:49] ==> public final fun withNoPrototype(arguments: List<Expression>): ArgumentList defined in org.jetbrains.kotlin.j2k.ast.ArgumentList.Companion[SimpleFunctionDescriptorImpl]

'callParams' @ [844:65] ==> val callParams: List<Pair<Identifier, Type?>> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'map' @ [844:76] ==> public inline fun <T, R> Iterable<Pair<Identifier, Type?>>.map(transform: (Pair<Identifier, Type?>) -> Identifier): List<Identifier> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<Identifier, Type?>
    <R> -> Identifier

'it' @ [844:82] ==> value-parameter it: Pair<Identifier, Type?> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression.<anonymous>[ValueParameterDescriptorImpl]

'first' @ [844:85] ==> public final val first: Identifier defined in kotlin.Pair[DeserializedPropertyDescriptor]

'statement' @ [845:17] ==> val statement: Statement defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'MethodCallExpression' @ [845:29] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.MethodCallExpression[FakeCallableDescriptorForObject]

'buildNonNull' @ [845:50] ==> public final fun buildNonNull(receiver: Expression?, methodName: String, argumentList: ArgumentList = ..., typeArguments: List<Type> = ..., dotPrototype: PsiElement? = ...): MethodCallExpression defined in org.jetbrains.kotlin.j2k.ast.MethodCallExpression.Companion[SimpleFunctionDescriptorImpl]

'convertMethodReferenceQualifier' @ [845:69] ==> private final fun convertMethodReferenceQualifier(qualifier: PsiElement): String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[SimpleFunctionDescriptorImpl]

'qualifier' @ [845:101] ==> val qualifier: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'argumentList' @ [845:113] ==> val argumentList: ArgumentList defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'specialMethod' @ [847:13] ==> val specialMethod: SpecialMethod? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'getInstance' @ [848:57] ==> public open fun getInstance(p0: (Project..Project?)): (PsiElementFactory..PsiElementFactory?) defined in com.intellij.psi.PsiElementFactory.SERVICE[JavaMethodDescriptor]

'converter' @ [848:69] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'project' @ [848:79] ==> public final val project: Project defined in org.jetbrains.kotlin.j2k.Converter[PropertyDescriptorImpl]

'receiver' @ [849:36] ==> val receiver: Pair<Expression, Type?>? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'let' @ [849:46] ==> @InlineOnly public inline fun <T, R> Pair<Expression, Type?>.let(block: (Pair<Expression, Type?>) -> PsiExpression): PsiExpression defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<Expression, Type?>
    <R> -> PsiExpression

'qualifier' @ [850:41] ==> val qualifier: PsiElement? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'factory' @ [850:72] ==> val factory: (PsiElementFactory..PsiElementFactory?) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'createExpressionFromText' @ [850:80] ==> @NotNull public abstract fun createExpressionFromText(@NotNull p0: String, @Nullable p1: PsiElement?): PsiExpression defined in com.intellij.psi.PsiElementFactory[JavaMethodDescriptor]

'psiExpression' @ [851:21] ==> val psiExpression: PsiExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression.<anonymous>[LocalVariableDescriptor]

'convertedExpression' @ [851:35] ==> private final var PsiExpression.convertedExpression: Expression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'it' @ [851:57] ==> value-parameter it: Pair<Expression, Type?> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression.<anonymous>[ValueParameterDescriptorImpl]

'first' @ [851:60] ==> public final val first: Expression defined in kotlin.Pair[DeserializedPropertyDescriptor]

'psiExpression' @ [852:21] ==> val psiExpression: PsiExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression.<anonymous>[LocalVariableDescriptor]

'callParams' @ [854:34] ==> val callParams: List<Pair<Identifier, Type?>> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'mapIndexed' @ [854:45] ==> public inline fun <T, R> Iterable<Pair<Identifier, Type?>>.mapIndexed(transform: (index: Int, Pair<Identifier, Type?>) -> PsiExpression): List<PsiExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<Identifier, Type?>
    <R> -> PsiExpression

'with' @ [855:21] ==> @InlineOnly public inline fun <T, R> with(receiver: PsiExpression, block: (PsiExpression).() -> PsiExpression): PsiExpression defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiExpression
    <R> -> PsiExpression

'factory' @ [855:26] ==> val factory: (PsiElementFactory..PsiElementFactory?) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'createExpressionFromText' @ [855:34] ==> @NotNull public abstract fun createExpressionFromText(@NotNull p0: String, @Nullable p1: PsiElement?): PsiExpression defined in com.intellij.psi.PsiElementFactory[JavaMethodDescriptor]

'i' @ [855:65] ==> value-parameter i: Int defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression.<anonymous>[ValueParameterDescriptorImpl]

'this' @ [856:25] ==> <this> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression.<anonymous>.<anonymous>[ReceiverParameterDescriptorImpl]

'convertedExpression' @ [856:30] ==> private final var PsiExpression.convertedExpression: Expression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'param' @ [856:52] ==> value-parameter param: Pair<Identifier, Type?> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression.<anonymous>[ValueParameterDescriptorImpl]

'first' @ [856:58] ==> public final val first: Identifier defined in kotlin.Pair[DeserializedPropertyDescriptor]

'this' @ [857:25] ==> <this> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression.<anonymous>.<anonymous>[ReceiverParameterDescriptorImpl]

'codeConverter' @ [860:40] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'withSpecialExpressionConverter' @ [860:54] ==> public final fun withSpecialExpressionConverter(specialConverter: SpecialExpressionConverter): CodeConverter defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'expression' @ [862:51] ==> value-parameter expression: PsiExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression.<no name provided>.convertExpression[ValueParameterDescriptorImpl]

'convertedExpression' @ [862:62] ==> private final var PsiExpression.convertedExpression: Expression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'expression' @ [863:25] ==> value-parameter expression: PsiExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression.<no name provided>.convertExpression[ValueParameterDescriptorImpl]

'convertedExpression' @ [863:36] ==> private final var PsiExpression.convertedExpression: Expression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertedExpression' @ [864:32] ==> val convertedExpression: Expression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression.<no name provided>.convertExpression[LocalVariableDescriptor]

'SpecialMethod' @ [868:32] ==> public companion object defined in org.jetbrains.kotlin.j2k.SpecialMethod[FakeCallableDescriptorForObject]

'ConvertCallData' @ [868:46] ==> public constructor ConvertCallData(qualifier: PsiExpression?, @Suppress arguments: List<PsiExpression>, typeArgumentsConverted: List<Type>, dot: PsiElement?, lPar: PsiElement?, rPar: PsiElement?, codeConverter: CodeConverter) defined in org.jetbrains.kotlin.j2k.SpecialMethod.ConvertCallData[ClassConstructorDescriptorImpl]

'fakeReceiver' @ [868:62] ==> val fakeReceiver: PsiExpression? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'fakeParams' @ [868:76] ==> val fakeParams: List<PsiExpression> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'emptyList' @ [868:88] ==> public fun <T> emptyList(): List<Type> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Type

'patchedConverter' @ [868:119] ==> val patchedConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'statement' @ [869:17] ==> val statement: Statement defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'specialMethod' @ [869:29] ==> val specialMethod: SpecialMethod? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'convertCall' @ [869:43] ==> @JvmName public final fun convertCall(data: SpecialMethod.ConvertCallData): Expression? defined in org.jetbrains.kotlin.j2k.SpecialMethod[SimpleFunctionDescriptorImpl]

'callData' @ [869:55] ==> val callData: SpecialMethod.ConvertCallData defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'expression' @ [872:37] ==> value-parameter expression: PsiMethodReferenceExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[ValueParameterDescriptorImpl]

'referenceName' @ [872:48] ==> public final val PsiMethodReferenceExpression.referenceName: String?[MyPropertyDescriptor]

'ArgumentList' @ [873:36] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.ArgumentList[FakeCallableDescriptorForObject]

'withNoPrototype' @ [873:49] ==> public final fun withNoPrototype(arguments: List<Expression>): ArgumentList defined in org.jetbrains.kotlin.j2k.ast.ArgumentList.Companion[SimpleFunctionDescriptorImpl]

'callParams' @ [873:65] ==> val callParams: List<Pair<Identifier, Type?>> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'map' @ [873:76] ==> public inline fun <T, R> Iterable<Pair<Identifier, Type?>>.map(transform: (Pair<Identifier, Type?>) -> Identifier): List<Identifier> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<Identifier, Type?>
    <R> -> Identifier

'it' @ [873:82] ==> value-parameter it: Pair<Identifier, Type?> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression.<anonymous>[ValueParameterDescriptorImpl]

'first' @ [873:85] ==> public final val first: Identifier defined in kotlin.Pair[DeserializedPropertyDescriptor]

'statement' @ [874:17] ==> val statement: Statement defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'MethodCallExpression' @ [874:29] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.MethodCallExpression[FakeCallableDescriptorForObject]

'buildNonNull' @ [874:50] ==> public final fun buildNonNull(receiver: Expression?, methodName: String, argumentList: ArgumentList = ..., typeArguments: List<Type> = ..., dotPrototype: PsiElement? = ...): MethodCallExpression defined in org.jetbrains.kotlin.j2k.ast.MethodCallExpression.Companion[SimpleFunctionDescriptorImpl]

'receiver' @ [874:63] ==> val receiver: Pair<Expression, Type?>? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'first' @ [874:73] ==> public final val first: Expression defined in kotlin.Pair[DeserializedPropertyDescriptor]

'referenceName' @ [874:80] ==> val referenceName: String defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'argumentList' @ [874:95] ==> val argumentList: ArgumentList defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'statement' @ [878:9] ==> val statement: Statement defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'assignNoPrototype' @ [878:19] ==> public fun <TElement : Element> Statement.assignNoPrototype(): Statement defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Statement

'ParameterList' @ [880:35] ==> public constructor ParameterList(parameters: List<Parameter>, lPar: LPar?, rPar: RPar?) defined in org.jetbrains.kotlin.j2k.ast.ParameterList[ClassConstructorDescriptorImpl]

'if (parameters.size == 1 && !isKotlinFunctionType) {
                    // for lambdas all parameters with types should be present
                    emptyList()
                }
                else {
                    parameters.map { LambdaParameter(it.first, it.second).assignNoPrototype() }
                }' @ [881:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<LambdaParameter>, elseBranch: List<LambdaParameter>): List<LambdaParameter>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<LambdaParameter>

'parameters' @ [881:21] ==> val parameters: List<Pair<Identifier, Type?>> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'size' @ [881:32] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'!' @ [881:45] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isKotlinFunctionType' @ [881:46] ==> val isKotlinFunctionType: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'emptyList' @ [883:21] ==> public fun <T> emptyList(): List<LambdaParameter> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> LambdaParameter

'parameters' @ [886:21] ==> val parameters: List<Pair<Identifier, Type?>> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'map' @ [886:32] ==> public inline fun <T, R> Iterable<Pair<Identifier, Type?>>.map(transform: (Pair<Identifier, Type?>) -> LambdaParameter): List<LambdaParameter> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<Identifier, Type?>
    <R> -> LambdaParameter

'LambdaParameter' @ [886:38] ==> public constructor LambdaParameter(identifier: Identifier, type: Type?) defined in org.jetbrains.kotlin.j2k.ast.LambdaParameter[ClassConstructorDescriptorImpl]

'it' @ [886:54] ==> value-parameter it: Pair<Identifier, Type?> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression.<anonymous>[ValueParameterDescriptorImpl]

'first' @ [886:57] ==> public final val first: Identifier defined in kotlin.Pair[DeserializedPropertyDescriptor]

'it' @ [886:64] ==> value-parameter it: Pair<Identifier, Type?> defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression.<anonymous>[ValueParameterDescriptorImpl]

'second' @ [886:67] ==> public final val second: Type? defined in kotlin.Pair[DeserializedPropertyDescriptor]

'assignNoPrototype' @ [886:75] ==> public fun <TElement : Element> LambdaParameter.assignNoPrototype(): LambdaParameter defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> LambdaParameter

'assignNoPrototype' @ [889:30] ==> public fun <TElement : Element> ParameterList.assignNoPrototype(): ParameterList defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> ParameterList

'LambdaExpression' @ [891:32] ==> public constructor LambdaExpression(parameterList: ParameterList?, block: Block) defined in org.jetbrains.kotlin.j2k.ast.LambdaExpression[ClassConstructorDescriptorImpl]

'lambdaParameterList' @ [891:49] ==> val lambdaParameterList: ParameterList defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'of' @ [891:76] ==> public final fun of(statement: Statement): Block defined in org.jetbrains.kotlin.j2k.ast.Block.Companion[SimpleFunctionDescriptorImpl]

'statement' @ [891:79] ==> val statement: Statement defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'assignNoPrototype' @ [891:90] ==> public fun <TElement : Element> Block.assignNoPrototype(): Block defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Block

'assignNoPrototype' @ [891:111] ==> public fun <TElement : Element> LambdaExpression.assignNoPrototype(): LambdaExpression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> LambdaExpression

'result' @ [893:9] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'if (isKotlinFunctionType) {
            lambdaExpression
        }
        else {
            val convertedFunctionalType = converter.typeConverter.convertType(functionalType)
            MethodCallExpression.buildNonNull(
                    null,
                    convertedFunctionalType.canonicalCode(),
                    ArgumentList.withNoPrototype(lambdaExpression)
            )
        }' @ [893:18] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Expression, elseBranch: Expression): Expression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Expression

'isKotlinFunctionType' @ [893:22] ==> val isKotlinFunctionType: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'lambdaExpression' @ [894:13] ==> val lambdaExpression: LambdaExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'converter' @ [897:43] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'typeConverter' @ [897:53] ==> public final val typeConverter: TypeConverter defined in org.jetbrains.kotlin.j2k.Converter[PropertyDescriptorImpl]

'convertType' @ [897:67] ==> public final fun convertType(type: PsiType?, nullability: Nullability = ..., mutability: Mutability = ..., inAnnotationType: Boolean = ...): Type defined in org.jetbrains.kotlin.j2k.TypeConverter[SimpleFunctionDescriptorImpl]

'functionalType' @ [897:79] ==> val functionalType: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'buildNonNull' @ [898:34] ==> public final fun buildNonNull(receiver: Expression?, methodName: String, argumentList: ArgumentList = ..., typeArguments: List<Type> = ..., dotPrototype: PsiElement? = ...): MethodCallExpression defined in org.jetbrains.kotlin.j2k.ast.MethodCallExpression.Companion[SimpleFunctionDescriptorImpl]

'convertedFunctionalType' @ [900:21] ==> val convertedFunctionalType: Type defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'canonicalCode' @ [900:45] ==> public fun Element.canonicalCode(): String defined in org.jetbrains.kotlin.j2k.ast in file Element.kt[SimpleFunctionDescriptorImpl]

'withNoPrototype' @ [901:34] ==> public final fun withNoPrototype(vararg arguments: Expression): ArgumentList defined in org.jetbrains.kotlin.j2k.ast.ArgumentList.Companion[SimpleFunctionDescriptorImpl]

'lambdaExpression' @ [901:50] ==> val lambdaExpression: LambdaExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitMethodReferenceExpression[LocalVariableDescriptor]

'getValue' @ [906:67] ==> public final operator fun getValue(thisRef: R, desc: KProperty<*>): T? defined in org.jetbrains.kotlin.psi.UserDataProperty[DeserializedSimpleFunctionDescriptor]

'create' @ [906:88] ==> @NotNull public open fun <T : (Any..Any?)> create(@NotNull @NonNls p0: String): Key<(Expression..Expression?)> defined in com.intellij.openapi.util.Key[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> (org.jetbrains.kotlin.j2k.ast.Expression..org.jetbrains.kotlin.j2k.ast.Expression?)

'functionalType' @ [908:60] ==> value-parameter functionalType: PsiType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.isFunctionType[ValueParameterDescriptorImpl]

'canonicalText' @ [908:76] ==> public final val PsiType.canonicalText: String[MyPropertyDescriptor]

'startsWith' @ [908:91] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'when (qualifier) {
            is PsiExpression -> codeConverter.convertExpression(qualifier).canonicalCode()
            is PsiTypeElement -> converter.convertTypeElement(qualifier, Nullability.NotNull).canonicalCode()
            else -> qualifier.text
        }' @ [911:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: String, entry1: String, entry2: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> String

'qualifier' @ [911:22] ==> value-parameter qualifier: PsiElement defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertMethodReferenceQualifier[ValueParameterDescriptorImpl]

'codeConverter' @ [912:33] ==> private final val codeConverter: CodeConverter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertExpression' @ [912:47] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'qualifier' @ [912:65] ==> value-parameter qualifier: PsiElement defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertMethodReferenceQualifier[ValueParameterDescriptorImpl]

'canonicalCode' @ [912:76] ==> public fun Element.canonicalCode(): String defined in org.jetbrains.kotlin.j2k.ast in file Element.kt[SimpleFunctionDescriptorImpl]

'converter' @ [913:34] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertTypeElement' @ [913:44] ==> public final fun convertTypeElement(element: PsiTypeElement?, nullability: Nullability): Type defined in org.jetbrains.kotlin.j2k.Converter[SimpleFunctionDescriptorImpl]

'qualifier' @ [913:63] ==> value-parameter qualifier: PsiElement defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertMethodReferenceQualifier[ValueParameterDescriptorImpl]

'NotNull' @ [913:86] ==> enum entry NotNull defined in org.jetbrains.kotlin.j2k.ast.Nullability[FakeCallableDescriptorForObject]

'canonicalCode' @ [913:95] ==> public fun Element.canonicalCode(): String defined in org.jetbrains.kotlin.j2k.ast in file Element.kt[SimpleFunctionDescriptorImpl]

'qualifier' @ [914:21] ==> value-parameter qualifier: PsiElement defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.convertMethodReferenceQualifier[ValueParameterDescriptorImpl]

'text' @ [914:31] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'arrayListOf' @ [919:29] ==> @SinceKotlin @InlineOnly public inline fun <T> arrayListOf(): ArrayList<Pair<Identifier, Type?>> /* = ArrayList<Pair<Identifier, Type?>> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<Identifier, Type?>

'containingClass' @ [922:25] ==> public final val PsiMethod.containingClass: PsiClass?[MyPropertyDescriptor]

'thisClass' @ [923:13] ==> val thisClass: PsiClass? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getParametersForMethodReference[LocalVariableDescriptor]

'isKotlinFunctionType' @ [923:34] ==> value-parameter isKotlinFunctionType: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getParametersForMethodReference[ValueParameterDescriptorImpl]

'thisClass' @ [924:39] ==> val thisClass: PsiClass? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getParametersForMethodReference[LocalVariableDescriptor]

'qualifiedName' @ [924:49] ==> public final val PsiClass.qualifiedName: String?[MyPropertyDescriptor]

'containingClass' @ [924:66] ==> public final val PsiMethod.containingClass: PsiClass?[MyPropertyDescriptor]

'name' @ [924:84] ==> public final val PsiClass.name: String?[MyPropertyDescriptor]

'containingClassName' @ [925:17] ==> val containingClassName: String? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getParametersForMethodReference[LocalVariableDescriptor]

'FqName' @ [926:30] ==> public constructor FqName(@NotNull p0: String) defined in org.jetbrains.kotlin.name.FqName[JavaClassConstructorDescriptor]

'containingClassName' @ [926:37] ==> val containingClassName: String? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getParametersForMethodReference[LocalVariableDescriptor]

'Identifier' @ [927:34] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.Identifier[FakeCallableDescriptorForObject]

'withNoPrototype' @ [927:45] ==> public final fun withNoPrototype(name: String, isNullable: Boolean = ..., quotingNeeded: Boolean = ..., imports: Collection<FqName> = ...): Identifier defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[SimpleFunctionDescriptorImpl]

'fqName' @ [927:61] ==> val fqName: FqName defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getParametersForMethodReference[LocalVariableDescriptor]

'shortName' @ [927:68] ==> @NotNull public open fun shortName(): Name defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'identifier' @ [927:80] ==> public final val Name.identifier: String[MyPropertyDescriptor]

'listOf' @ [927:102] ==> public fun <T> listOf(element: FqName): List<FqName> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FqName

'fqName' @ [927:109] ==> val fqName: FqName defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getParametersForMethodReference[LocalVariableDescriptor]

'thisClassType' @ [928:17] ==> var thisClassType: ClassType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getParametersForMethodReference[LocalVariableDescriptor]

'ClassType' @ [928:33] ==> public constructor ClassType(referenceElement: ReferenceElement, nullability: Nullability, settings: ConverterSettings) defined in org.jetbrains.kotlin.j2k.ast.ClassType[ClassConstructorDescriptorImpl]

'ReferenceElement' @ [929:25] ==> public constructor ReferenceElement(name: Identifier, typeArgs: List<Element>) defined in org.jetbrains.kotlin.j2k.ast.ReferenceElement[ClassConstructorDescriptorImpl]

'identifier' @ [929:42] ==> val identifier: Identifier defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getParametersForMethodReference[LocalVariableDescriptor]

'converter' @ [929:54] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'convertTypeParameterList' @ [929:64] ==> public fun Converter.convertTypeParameterList(typeParameterList: PsiTypeParameterList?): TypeParameterList defined in org.jetbrains.kotlin.j2k.ast in file TypeParameters.kt[SimpleFunctionDescriptorImpl]

'thisClass' @ [929:89] ==> val thisClass: PsiClass? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getParametersForMethodReference[LocalVariableDescriptor]

'typeParameterList' @ [929:99] ==> public final val PsiClass.typeParameterList: PsiTypeParameterList?[MyPropertyDescriptor]

'parameters' @ [929:118] ==> public final val parameters: List<TypeParameter> defined in org.jetbrains.kotlin.j2k.ast.TypeParameterList[PropertyDescriptorImpl]

'assignNoPrototype' @ [929:130] ==> public fun <TElement : Element> ReferenceElement.assignNoPrototype(): ReferenceElement defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> ReferenceElement

'NotNull' @ [930:37] ==> enum entry NotNull defined in org.jetbrains.kotlin.j2k.ast.Nullability[FakeCallableDescriptorForObject]

'converter' @ [931:25] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'settings' @ [931:35] ==> public final val settings: ConverterSettings defined in org.jetbrains.kotlin.j2k.Converter[PropertyDescriptorImpl]

'assignNoPrototype' @ [931:45] ==> public fun <TElement : Element> ClassType.assignNoPrototype(): ClassType defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> ClassType

'needThis' @ [934:13] ==> value-parameter needThis: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getParametersForMethodReference[ValueParameterDescriptorImpl]

'newParameters' @ [934:23] ==> val newParameters: ArrayList<Pair<Identifier, Type?>> /* = ArrayList<Pair<Identifier, Type?>> */ defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getParametersForMethodReference[LocalVariableDescriptor]

'add' @ [934:37] ==> public open fun add(element: Pair<Identifier, Type?>): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'Identifier' @ [934:41] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.Identifier[FakeCallableDescriptorForObject]

'withNoPrototype' @ [934:52] ==> public final fun withNoPrototype(name: String, isNullable: Boolean = ..., quotingNeeded: Boolean = ..., imports: Collection<FqName> = ...): Identifier defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[SimpleFunctionDescriptorImpl]

'thisClassType' @ [934:98] ==> var thisClassType: ClassType? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getParametersForMethodReference[LocalVariableDescriptor]

'parameterList' @ [936:9] ==> public final val PsiMethod.parameterList: PsiParameterList[MyPropertyDescriptor]

'parameters' @ [936:23] ==> public final val PsiParameterList.parameters: (Array<(PsiParameter..PsiParameter?)>..Array<out (PsiParameter..PsiParameter?)>)[MyPropertyDescriptor]

'forEach' @ [936:34] ==> public inline fun <T> Array<out (PsiParameter..PsiParameter?)>.forEach(action: ((PsiParameter..PsiParameter?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiParameter..com.intellij.psi.PsiParameter?)

'if (isKotlinFunctionType) converter.typeConverter.convertType(it.type, Nullability.NotNull) else null' @ [937:33] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Type?, elseBranch: Type?): Type?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Type?

'isKotlinFunctionType' @ [937:37] ==> value-parameter isKotlinFunctionType: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getParametersForMethodReference[ValueParameterDescriptorImpl]

'converter' @ [937:59] ==> private final val converter: Converter defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'typeConverter' @ [937:69] ==> public final val typeConverter: TypeConverter defined in org.jetbrains.kotlin.j2k.Converter[PropertyDescriptorImpl]

'convertType' @ [937:83] ==> public final fun convertType(type: PsiType?, nullability: Nullability = ..., mutability: Mutability = ..., inAnnotationType: Boolean = ...): Type defined in org.jetbrains.kotlin.j2k.TypeConverter[SimpleFunctionDescriptorImpl]

'it' @ [937:95] ==> value-parameter it: (PsiParameter..PsiParameter?) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getParametersForMethodReference.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [937:98] ==> public final val PsiParameter.type: PsiType[MyPropertyDescriptor]

'NotNull' @ [937:116] ==> enum entry NotNull defined in org.jetbrains.kotlin.j2k.ast.Nullability[FakeCallableDescriptorForObject]

'newParameters' @ [938:13] ==> val newParameters: ArrayList<Pair<Identifier, Type?>> /* = ArrayList<Pair<Identifier, Type?>> */ defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getParametersForMethodReference[LocalVariableDescriptor]

'add' @ [938:27] ==> public open fun add(element: Pair<Identifier, Type?>): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'Identifier' @ [938:31] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.Identifier[FakeCallableDescriptorForObject]

'withNoPrototype' @ [938:42] ==> public final fun withNoPrototype(name: String, isNullable: Boolean = ..., quotingNeeded: Boolean = ..., imports: Collection<FqName> = ...): Identifier defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[SimpleFunctionDescriptorImpl]

'it' @ [938:58] ==> value-parameter it: (PsiParameter..PsiParameter?) defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getParametersForMethodReference.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [938:61] ==> public final val PsiParameter.name: String?[MyPropertyDescriptor]

'parameterType' @ [938:97] ==> val parameterType: Type? defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getParametersForMethodReference.<anonymous>[LocalVariableDescriptor]

'newParameters' @ [941:13] ==> val newParameters: ArrayList<Pair<Identifier, Type?>> /* = ArrayList<Pair<Identifier, Type?>> */ defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getParametersForMethodReference[LocalVariableDescriptor]

'size' @ [941:27] ==> public open val size: Int defined in java.util.ArrayList[JavaPropertyDescriptor]

'!' @ [941:40] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isKotlinFunctionType' @ [941:41] ==> value-parameter isKotlinFunctionType: Boolean defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getParametersForMethodReference[ValueParameterDescriptorImpl]

'newParameters' @ [942:13] ==> val newParameters: ArrayList<Pair<Identifier, Type?>> /* = ArrayList<Pair<Identifier, Type?>> */ defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getParametersForMethodReference[LocalVariableDescriptor]

'clear' @ [942:27] ==> public open fun clear(): Unit defined in java.util.ArrayList[JavaMethodDescriptor]

'newParameters' @ [943:13] ==> val newParameters: ArrayList<Pair<Identifier, Type?>> /* = ArrayList<Pair<Identifier, Type?>> */ defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getParametersForMethodReference[LocalVariableDescriptor]

'add' @ [943:27] ==> public open fun add(element: Pair<Identifier, Type?>): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'Identifier' @ [943:31] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.Identifier[FakeCallableDescriptorForObject]

'withNoPrototype' @ [943:42] ==> public final fun withNoPrototype(name: String, isNullable: Boolean = ..., quotingNeeded: Boolean = ..., imports: Collection<FqName> = ...): Identifier defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[SimpleFunctionDescriptorImpl]

'newParameters' @ [946:16] ==> val newParameters: ArrayList<Pair<Identifier, Type?>> /* = ArrayList<Pair<Identifier, Type?>> */ defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.getParametersForMethodReference[LocalVariableDescriptor]

'result' @ [950:9] ==> private final var result: Expression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter[PropertyDescriptorImpl]

'DummyStringExpression' @ [950:18] ==> public constructor DummyStringExpression(string: String) defined in org.jetbrains.kotlin.j2k.ast.DummyStringExpression[ClassConstructorDescriptorImpl]

'expression' @ [950:40] ==> value-parameter expression: PsiExpression defined in org.jetbrains.kotlin.j2k.DefaultExpressionConverter.visitExpression[ValueParameterDescriptorImpl]

'text' @ [950:51] ==> public final val PsiExpression.text: (String..String?)[MyPropertyDescriptor]

