'converter' @ [30:40] ==> public final val converter: Converter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'typeConverter' @ [30:50] ==> public final val typeConverter: TypeConverter defined in org.jetbrains.kotlin.j2k.Converter[PropertyDescriptorImpl]

'converter' @ [31:39] ==> public final val converter: Converter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'settings' @ [31:49] ==> public final val settings: ConverterSettings defined in org.jetbrains.kotlin.j2k.Converter[PropertyDescriptorImpl]

'CodeConverter' @ [34:15] ==> public constructor CodeConverter(converter: Converter, expressionConverter: ExpressionConverter, statementConverter: StatementConverter, methodReturnType: PsiType?) defined in org.jetbrains.kotlin.j2k.CodeConverter[ClassConstructorDescriptorImpl]

'converter' @ [34:29] ==> public final val converter: Converter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'expressionConverter' @ [34:40] ==> private final val expressionConverter: ExpressionConverter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'withSpecialConverter' @ [34:60] ==> public fun ExpressionConverter.withSpecialConverter(specialConverter: SpecialExpressionConverter): ExpressionConverter defined in org.jetbrains.kotlin.j2k in file ExpressionConverter.kt[SimpleFunctionDescriptorImpl]

'specialConverter' @ [34:81] ==> value-parameter specialConverter: SpecialExpressionConverter defined in org.jetbrains.kotlin.j2k.CodeConverter.withSpecialExpressionConverter[ValueParameterDescriptorImpl]

'statementConverter' @ [34:100] ==> private final val statementConverter: StatementConverter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'methodReturnType' @ [34:120] ==> public final val methodReturnType: PsiType? defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'CodeConverter' @ [37:15] ==> public constructor CodeConverter(converter: Converter, expressionConverter: ExpressionConverter, statementConverter: StatementConverter, methodReturnType: PsiType?) defined in org.jetbrains.kotlin.j2k.CodeConverter[ClassConstructorDescriptorImpl]

'converter' @ [37:29] ==> public final val converter: Converter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'expressionConverter' @ [37:40] ==> private final val expressionConverter: ExpressionConverter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'statementConverter' @ [37:61] ==> private final val statementConverter: StatementConverter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'withSpecialConverter' @ [37:80] ==> public fun StatementConverter.withSpecialConverter(specialConverter: SpecialStatementConverter): StatementConverter defined in org.jetbrains.kotlin.j2k in file StatementConverter.kt[SimpleFunctionDescriptorImpl]

'specialConverter' @ [37:101] ==> value-parameter specialConverter: SpecialStatementConverter defined in org.jetbrains.kotlin.j2k.CodeConverter.withSpecialStatementConverter[ValueParameterDescriptorImpl]

'methodReturnType' @ [37:120] ==> public final val methodReturnType: PsiType? defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'CodeConverter' @ [40:15] ==> public constructor CodeConverter(converter: Converter, expressionConverter: ExpressionConverter, statementConverter: StatementConverter, methodReturnType: PsiType?) defined in org.jetbrains.kotlin.j2k.CodeConverter[ClassConstructorDescriptorImpl]

'converter' @ [40:29] ==> public final val converter: Converter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'expressionConverter' @ [40:40] ==> private final val expressionConverter: ExpressionConverter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'statementConverter' @ [40:61] ==> private final val statementConverter: StatementConverter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'methodReturnType' @ [40:81] ==> value-parameter methodReturnType: PsiType? defined in org.jetbrains.kotlin.j2k.CodeConverter.withMethodReturnType[ValueParameterDescriptorImpl]

'CodeConverter' @ [43:15] ==> public constructor CodeConverter(converter: Converter, expressionConverter: ExpressionConverter, statementConverter: StatementConverter, methodReturnType: PsiType?) defined in org.jetbrains.kotlin.j2k.CodeConverter[ClassConstructorDescriptorImpl]

'converter' @ [43:29] ==> value-parameter converter: Converter defined in org.jetbrains.kotlin.j2k.CodeConverter.withConverter[ValueParameterDescriptorImpl]

'expressionConverter' @ [43:40] ==> private final val expressionConverter: ExpressionConverter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'statementConverter' @ [43:61] ==> private final val statementConverter: StatementConverter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'methodReturnType' @ [43:81] ==> public final val methodReturnType: PsiType? defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'block' @ [46:13] ==> value-parameter block: PsiCodeBlock? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertBlock[ValueParameterDescriptorImpl]

'Block' @ [46:35] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.Block[FakeCallableDescriptorForObject]

'Empty' @ [46:41] ==> public final val Empty: Block defined in org.jetbrains.kotlin.j2k.ast.Block.Companion[PropertyDescriptorImpl]

'LBrace' @ [48:22] ==> public constructor LBrace() defined in org.jetbrains.kotlin.j2k.ast.LBrace[ClassConstructorDescriptorImpl]

'assignPrototype' @ [48:31] ==> public fun <TElement : Element> LBrace.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): LBrace defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> LBrace

'block' @ [48:47] ==> value-parameter block: PsiCodeBlock? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertBlock[ValueParameterDescriptorImpl]

'lBrace' @ [48:53] ==> public final val PsiCodeBlock.lBrace: PsiJavaToken?[MyPropertyDescriptor]

'RBrace' @ [49:22] ==> public constructor RBrace() defined in org.jetbrains.kotlin.j2k.ast.RBrace[ClassConstructorDescriptorImpl]

'assignPrototype' @ [49:31] ==> public fun <TElement : Element> RBrace.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): RBrace defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> RBrace

'block' @ [49:47] ==> value-parameter block: PsiCodeBlock? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertBlock[ValueParameterDescriptorImpl]

'rBrace' @ [49:53] ==> public final val PsiCodeBlock.rBrace: PsiJavaToken?[MyPropertyDescriptor]

'Block' @ [50:16] ==> public constructor Block(statements: List<Statement>, lBrace: LBrace, rBrace: RBrace, notEmpty: Boolean = ...) defined in org.jetbrains.kotlin.j2k.ast.Block[ClassConstructorDescriptorImpl]

'block' @ [50:22] ==> value-parameter block: PsiCodeBlock? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertBlock[ValueParameterDescriptorImpl]

'statements' @ [50:28] ==> public final val PsiCodeBlock.statements: (Array<(PsiStatement..PsiStatement?)>..Array<out (PsiStatement..PsiStatement?)>)[MyPropertyDescriptor]

'filter' @ [50:39] ==> public inline fun <T> Array<out (PsiStatement..PsiStatement?)>.filter(predicate: ((PsiStatement..PsiStatement?)) -> Boolean): List<(PsiStatement..PsiStatement?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiStatement..com.intellij.psi.PsiStatement?)

'statementFilter' @ [50:46] ==> value-parameter statementFilter: (PsiStatement) -> Boolean = ... defined in org.jetbrains.kotlin.j2k.CodeConverter.convertBlock[ValueParameterDescriptorImpl]

'map' @ [50:63] ==> public inline fun <T, R> Iterable<(PsiStatement..PsiStatement?)>.map(transform: ((PsiStatement..PsiStatement?)) -> Statement): List<Statement> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiStatement..com.intellij.psi.PsiStatement?)
    <R> -> Statement

'convertStatement' @ [50:69] ==> public final fun convertStatement(statement: PsiStatement?): Statement defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'it' @ [50:86] ==> value-parameter it: (PsiStatement..PsiStatement?) defined in org.jetbrains.kotlin.j2k.CodeConverter.convertBlock.<anonymous>[ValueParameterDescriptorImpl]

'lBrace' @ [50:93] ==> val lBrace: LBrace defined in org.jetbrains.kotlin.j2k.CodeConverter.convertBlock[LocalVariableDescriptor]

'rBrace' @ [50:101] ==> val rBrace: RBrace defined in org.jetbrains.kotlin.j2k.CodeConverter.convertBlock[LocalVariableDescriptor]

'notEmpty' @ [50:109] ==> value-parameter notEmpty: Boolean = ... defined in org.jetbrains.kotlin.j2k.CodeConverter.convertBlock[ValueParameterDescriptorImpl]

'assignPrototype' @ [50:119] ==> public fun <TElement : Element> Block.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Block defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Block

'block' @ [50:135] ==> value-parameter block: PsiCodeBlock? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertBlock[ValueParameterDescriptorImpl]

'statement' @ [54:13] ==> value-parameter statement: PsiStatement? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertStatement[ValueParameterDescriptorImpl]

'Empty' @ [54:49] ==> public object Empty : Statement defined in org.jetbrains.kotlin.j2k.ast.Statement[FakeCallableDescriptorForObject]

'statementConverter' @ [56:16] ==> private final val statementConverter: StatementConverter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'convertStatement' @ [56:35] ==> public abstract fun convertStatement(statement: PsiStatement, codeConverter: CodeConverter): Statement defined in org.jetbrains.kotlin.j2k.StatementConverter[SimpleFunctionDescriptorImpl]

'statement' @ [56:52] ==> value-parameter statement: PsiStatement? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertStatement[ValueParameterDescriptorImpl]

'this' @ [56:63] ==> <this> defined in org.jetbrains.kotlin.j2k.CodeConverter[LazyClassReceiverParameterDescriptor]

'assignPrototype' @ [56:69] ==> public fun <TElement : Element> Statement.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Statement defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Statement

'statement' @ [56:85] ==> value-parameter statement: PsiStatement? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertStatement[ValueParameterDescriptorImpl]

'expressions' @ [60:15] ==> value-parameter expressions: List<PsiExpression> defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpressionsInList[ValueParameterDescriptorImpl]

'map' @ [60:27] ==> public inline fun <T, R> Iterable<PsiExpression>.map(transform: (PsiExpression) -> Expression): List<Expression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiExpression
    <R> -> Expression

'convertExpression' @ [60:33] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'it' @ [60:51] ==> value-parameter it: PsiExpression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpressionsInList.<anonymous>[ValueParameterDescriptorImpl]

'assignPrototype' @ [60:55] ==> public fun <TElement : Element> Expression.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Expression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Expression

'it' @ [60:71] ==> value-parameter it: PsiExpression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpressionsInList.<anonymous>[ValueParameterDescriptorImpl]

'LINE_BREAKS' @ [60:104] ==> public final val LINE_BREAKS: CommentsAndSpacesInheritance defined in org.jetbrains.kotlin.j2k.ast.CommentsAndSpacesInheritance.Companion[PropertyDescriptorImpl]

'ArgumentList' @ [63:16] ==> public constructor ArgumentList(expressions: List<Expression>, lPar: LPar, rPar: RPar) defined in org.jetbrains.kotlin.j2k.ast.ArgumentList[ClassConstructorDescriptorImpl]

'convertExpressionsInList' @ [64:17] ==> public final fun convertExpressionsInList(expressions: List<PsiExpression>): List<Expression> defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'list' @ [64:42] ==> value-parameter list: PsiExpressionList defined in org.jetbrains.kotlin.j2k.CodeConverter.convertArgumentList[ValueParameterDescriptorImpl]

'expressions' @ [64:47] ==> public final val PsiExpressionList.expressions: (Array<(PsiExpression..PsiExpression?)>..Array<out (PsiExpression..PsiExpression?)>)[MyPropertyDescriptor]

'asList' @ [64:59] ==> public fun <T> Array<out (PsiExpression..PsiExpression?)>.asList(): List<(PsiExpression..PsiExpression?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiExpression..com.intellij.psi.PsiExpression?)

'withPrototype' @ [65:22] ==> public final fun withPrototype(element: PsiElement?): LPar defined in org.jetbrains.kotlin.j2k.ast.LPar.Companion[SimpleFunctionDescriptorImpl]

'list' @ [65:36] ==> value-parameter list: PsiExpressionList defined in org.jetbrains.kotlin.j2k.CodeConverter.convertArgumentList[ValueParameterDescriptorImpl]

'lPar' @ [65:41] ==> public fun PsiExpressionList.lPar(): PsiElement? defined in org.jetbrains.kotlin.j2k in file Utils.kt[SimpleFunctionDescriptorImpl]

'withPrototype' @ [66:22] ==> public final fun withPrototype(element: PsiElement?): RPar defined in org.jetbrains.kotlin.j2k.ast.RPar.Companion[SimpleFunctionDescriptorImpl]

'list' @ [66:36] ==> value-parameter list: PsiExpressionList defined in org.jetbrains.kotlin.j2k.CodeConverter.convertArgumentList[ValueParameterDescriptorImpl]

'rPar' @ [66:41] ==> public fun PsiExpressionList.rPar(): PsiElement? defined in org.jetbrains.kotlin.j2k in file Utils.kt[SimpleFunctionDescriptorImpl]

'assignPrototype' @ [67:11] ==> public fun <TElement : Element> ArgumentList.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): ArgumentList defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> ArgumentList

'list' @ [67:27] ==> value-parameter list: PsiExpressionList defined in org.jetbrains.kotlin.j2k.CodeConverter.convertArgumentList[ValueParameterDescriptorImpl]

'expression' @ [71:13] ==> value-parameter expression: PsiExpression? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[ValueParameterDescriptorImpl]

'Empty' @ [71:51] ==> public object Empty : Expression defined in org.jetbrains.kotlin.j2k.ast.Expression[FakeCallableDescriptorForObject]

'expressionConverter' @ [73:25] ==> private final val expressionConverter: ExpressionConverter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'convertExpression' @ [73:45] ==> public abstract fun convertExpression(expression: PsiExpression, codeConverter: CodeConverter): Expression defined in org.jetbrains.kotlin.j2k.ExpressionConverter[SimpleFunctionDescriptorImpl]

'expression' @ [73:63] ==> value-parameter expression: PsiExpression? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[ValueParameterDescriptorImpl]

'this' @ [73:75] ==> <this> defined in org.jetbrains.kotlin.j2k.CodeConverter[LazyClassReceiverParameterDescriptor]

'assignPrototype' @ [73:81] ==> public fun <TElement : Element> Expression.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Expression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Expression

'expression' @ [73:97] ==> value-parameter expression: PsiExpression? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[ValueParameterDescriptorImpl]

'shouldParenthesize' @ [74:13] ==> value-parameter shouldParenthesize: Boolean = ... defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[ValueParameterDescriptorImpl]

'ParenthesizedExpression' @ [75:20] ==> public constructor ParenthesizedExpression(expression: Expression) defined in org.jetbrains.kotlin.j2k.ast.ParenthesizedExpression[ClassConstructorDescriptorImpl]

'converted' @ [75:44] ==> val converted: Expression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'assignNoPrototype' @ [75:55] ==> public fun <TElement : Element> ParenthesizedExpression.assignNoPrototype(): ParenthesizedExpression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> ParenthesizedExpression

'converted' @ [77:16] ==> val converted: Expression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'canChangeType' @ [81:21] ==> public final fun canChangeType(variable: PsiLocalVariable): Boolean defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'variable' @ [81:35] ==> value-parameter variable: PsiLocalVariable defined in org.jetbrains.kotlin.j2k.CodeConverter.convertLocalVariable[ValueParameterDescriptorImpl]

'typeConverter' @ [82:20] ==> public final val typeConverter: TypeConverter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'convertVariableType' @ [82:34] ==> public final fun convertVariableType(variable: PsiVariable): Type defined in org.jetbrains.kotlin.j2k.TypeConverter[SimpleFunctionDescriptorImpl]

'variable' @ [82:54] ==> value-parameter variable: PsiLocalVariable defined in org.jetbrains.kotlin.j2k.CodeConverter.convertLocalVariable[ValueParameterDescriptorImpl]

'type' @ [83:28] ==> val type: Type defined in org.jetbrains.kotlin.j2k.CodeConverter.convertLocalVariable[LocalVariableDescriptor]

'takeIf' @ [83:33] ==> @InlineOnly @SinceKotlin public inline fun <T> Type.takeIf(predicate: (Type) -> Boolean): Type? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Type

'settings' @ [83:42] ==> public final val settings: ConverterSettings defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'specifyLocalVariableTypeByDefault' @ [83:51] ==> public final var specifyLocalVariableTypeByDefault: Boolean defined in org.jetbrains.kotlin.j2k.ConverterSettings[PropertyDescriptorImpl]

'converter' @ [83:88] ==> public final val converter: Converter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'shouldDeclareVariableType' @ [83:98] ==> public final fun shouldDeclareVariableType(variable: PsiVariable, type: Type, canChangeType: Boolean): Boolean defined in org.jetbrains.kotlin.j2k.Converter[SimpleFunctionDescriptorImpl]

'variable' @ [83:124] ==> value-parameter variable: PsiLocalVariable defined in org.jetbrains.kotlin.j2k.CodeConverter.convertLocalVariable[ValueParameterDescriptorImpl]

'type' @ [83:134] ==> val type: Type defined in org.jetbrains.kotlin.j2k.CodeConverter.convertLocalVariable[LocalVariableDescriptor]

'isVal' @ [83:140] ==> val isVal: Boolean defined in org.jetbrains.kotlin.j2k.CodeConverter.convertLocalVariable[LocalVariableDescriptor]

'LocalVariable' @ [84:16] ==> public constructor LocalVariable(identifier: Identifier, annotations: Annotations, modifiers: Modifiers, explicitType: Type?, initializer: Expression, isVal: Boolean) defined in org.jetbrains.kotlin.j2k.ast.LocalVariable[ClassConstructorDescriptorImpl]

'variable' @ [84:30] ==> value-parameter variable: PsiLocalVariable defined in org.jetbrains.kotlin.j2k.CodeConverter.convertLocalVariable[ValueParameterDescriptorImpl]

'declarationIdentifier' @ [84:39] ==> public fun PsiNameIdentifierOwner.declarationIdentifier(): Identifier defined in org.jetbrains.kotlin.j2k.ast in file Identifier.kt[SimpleFunctionDescriptorImpl]

'converter' @ [85:30] ==> public final val converter: Converter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'convertAnnotations' @ [85:40] ==> public final fun convertAnnotations(owner: PsiModifierListOwner, target: AnnotationUseTarget? = ...): Annotations defined in org.jetbrains.kotlin.j2k.Converter[SimpleFunctionDescriptorImpl]

'variable' @ [85:59] ==> value-parameter variable: PsiLocalVariable defined in org.jetbrains.kotlin.j2k.CodeConverter.convertLocalVariable[ValueParameterDescriptorImpl]

'converter' @ [86:30] ==> public final val converter: Converter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'convertModifiers' @ [86:40] ==> public final fun convertModifiers(owner: PsiModifierListOwner, isMethodInOpenClass: Boolean): Modifiers defined in org.jetbrains.kotlin.j2k.Converter[SimpleFunctionDescriptorImpl]

'variable' @ [86:57] ==> value-parameter variable: PsiLocalVariable defined in org.jetbrains.kotlin.j2k.CodeConverter.convertLocalVariable[ValueParameterDescriptorImpl]

'explicitType' @ [87:30] ==> val explicitType: Type? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertLocalVariable[LocalVariableDescriptor]

'convertExpression' @ [88:30] ==> public final fun convertExpression(expression: PsiExpression?, expectedType: PsiType?, expectedNullability: Nullability? = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'variable' @ [88:48] ==> value-parameter variable: PsiLocalVariable defined in org.jetbrains.kotlin.j2k.CodeConverter.convertLocalVariable[ValueParameterDescriptorImpl]

'initializer' @ [88:57] ==> public final var PsiLocalVariable.initializer: PsiExpression?[MyPropertyDescriptor]

'variable' @ [88:70] ==> value-parameter variable: PsiLocalVariable defined in org.jetbrains.kotlin.j2k.CodeConverter.convertLocalVariable[ValueParameterDescriptorImpl]

'type' @ [88:79] ==> public final val PsiLocalVariable.type: PsiType[MyPropertyDescriptor]

'isVal' @ [89:30] ==> val isVal: Boolean defined in org.jetbrains.kotlin.j2k.CodeConverter.convertLocalVariable[LocalVariableDescriptor]

'assignPrototype' @ [89:37] ==> public fun <TElement : Element> LocalVariable.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): LocalVariable defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> LocalVariable

'variable' @ [89:53] ==> value-parameter variable: PsiLocalVariable defined in org.jetbrains.kotlin.j2k.CodeConverter.convertLocalVariable[ValueParameterDescriptorImpl]

'variable' @ [93:16] ==> value-parameter variable: PsiLocalVariable defined in org.jetbrains.kotlin.j2k.CodeConverter.canChangeType[ValueParameterDescriptorImpl]

'hasModifierProperty' @ [93:25] ==> public abstract fun hasModifierProperty(@PsiModifier.ModifierConstant @NonNls @NotNull p0: String): Boolean defined in com.intellij.psi.PsiLocalVariable[JavaMethodDescriptor]

'FINAL' @ [93:57] ==> public const final val FINAL: String defined in com.intellij.psi.PsiModifier[JavaPropertyDescriptor]

'variable' @ [94:21] ==> value-parameter variable: PsiLocalVariable defined in org.jetbrains.kotlin.j2k.CodeConverter.canChangeType[ValueParameterDescriptorImpl]

'initializer' @ [94:30] ==> public final var PsiLocalVariable.initializer: PsiExpression?[MyPropertyDescriptor]

'!' @ [95:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'variable' @ [95:22] ==> value-parameter variable: PsiLocalVariable defined in org.jetbrains.kotlin.j2k.CodeConverter.canChangeType[ValueParameterDescriptorImpl]

'hasWriteAccesses' @ [95:31] ==> public fun PsiVariable.hasWriteAccesses(searcher: ReferenceSearcher, scope: PsiElement?): Boolean defined in org.jetbrains.kotlin.j2k in file ReferenceSearcher.kt[SimpleFunctionDescriptorImpl]

'converter' @ [95:48] ==> public final val converter: Converter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'referenceSearcher' @ [95:58] ==> public final val referenceSearcher: ReferenceSearcher defined in org.jetbrains.kotlin.j2k.Converter[PropertyDescriptorImpl]

'variable' @ [95:77] ==> value-parameter variable: PsiLocalVariable defined in org.jetbrains.kotlin.j2k.CodeConverter.canChangeType[ValueParameterDescriptorImpl]

'getContainingMethod' @ [95:86] ==> public fun PsiElement.getContainingMethod(): PsiMethod? defined in org.jetbrains.kotlin.j2k in file Utils.kt[SimpleFunctionDescriptorImpl]

'expression' @ [99:13] ==> value-parameter expression: PsiExpression? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[ValueParameterDescriptorImpl]

'Identifier' @ [99:40] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.Identifier[FakeCallableDescriptorForObject]

'Empty' @ [99:51] ==> public final val Empty: Identifier defined in org.jetbrains.kotlin.j2k.ast.Identifier.Companion[PropertyDescriptorImpl]

'convertExpression' @ [101:35] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'expression' @ [101:53] ==> value-parameter expression: PsiExpression? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[ValueParameterDescriptorImpl]

'convertedExpression' @ [103:13] ==> var convertedExpression: Expression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'isNullable' @ [103:33] ==> public open val isNullable: Boolean defined in org.jetbrains.kotlin.j2k.ast.Expression[PropertyDescriptorImpl]

'expectedNullability' @ [103:47] ==> value-parameter expectedNullability: Nullability? = ... defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[ValueParameterDescriptorImpl]

'expectedNullability' @ [103:78] ==> value-parameter expectedNullability: Nullability? = ... defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[ValueParameterDescriptorImpl]

'NotNull' @ [103:113] ==> enum entry NotNull defined in org.jetbrains.kotlin.j2k.ast.Nullability[FakeCallableDescriptorForObject]

'convertedExpression' @ [104:13] ==> var convertedExpression: Expression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'BangBangExpression' @ [104:35] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.BangBangExpression[FakeCallableDescriptorForObject]

'surroundIfNullable' @ [104:54] ==> public final fun surroundIfNullable(expression: Expression): Expression defined in org.jetbrains.kotlin.j2k.ast.BangBangExpression.Companion[SimpleFunctionDescriptorImpl]

'convertedExpression' @ [104:73] ==> var convertedExpression: Expression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'expectedType' @ [107:13] ==> value-parameter expectedType: PsiType? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[ValueParameterDescriptorImpl]

'expectedType' @ [107:37] ==> value-parameter expectedType: PsiType? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[ValueParameterDescriptorImpl]

'VOID' @ [107:61] ==> public final val VOID: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'convertedExpression' @ [107:74] ==> var convertedExpression: Expression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'expression' @ [109:26] ==> value-parameter expression: PsiExpression? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[ValueParameterDescriptorImpl]

'type' @ [109:37] ==> public final val PsiExpression.type: PsiType?[MyPropertyDescriptor]

'convertedExpression' @ [109:52] ==> var convertedExpression: Expression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'actualType' @ [111:14] ==> val actualType: PsiType defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'actualType' @ [111:48] ==> val actualType: PsiType defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'NULL' @ [111:70] ==> public final val NULL: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'actualType' @ [111:79] ==> val actualType: PsiType defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'expectedType' @ [111:109] ==> value-parameter expectedType: PsiType? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[ValueParameterDescriptorImpl]

'convertedExpression' @ [112:13] ==> var convertedExpression: Expression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'BangBangExpression' @ [112:35] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.BangBangExpression[FakeCallableDescriptorForObject]

'surroundIfNullable' @ [112:54] ==> public final fun surroundIfNullable(expression: Expression): Expression defined in org.jetbrains.kotlin.j2k.ast.BangBangExpression.Companion[SimpleFunctionDescriptorImpl]

'convertedExpression' @ [112:73] ==> var convertedExpression: Expression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'needConversion' @ [115:13] ==> private final fun needConversion(actual: PsiType, expected: PsiType): Boolean defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'actualType' @ [115:28] ==> val actualType: PsiType defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'expectedType' @ [115:40] ==> value-parameter expectedType: PsiType? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[ValueParameterDescriptorImpl]

'expectedType' @ [116:35] ==> value-parameter expectedType: PsiType? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[ValueParameterDescriptorImpl]

'canonicalText' @ [116:48] ==> public final val PsiType.canonicalText: String[MyPropertyDescriptor]

'if (expression is PsiLiteralExpression) {
                if (expectedTypeStr == "float" || expectedTypeStr == "double") {
                    var text = convertedExpression.canonicalCode()
                    if (text.last() in setOf('f', 'L')) {
                        text = text.substring(0, text.length - 1)
                    }
                    if (expectedTypeStr == "float") {
                        text += "f"
                    }
                    if (expectedTypeStr == "double") {
                        if (!text.contains(".") && !text.contains("e", true)) {
                            text += ".0"
                        }
                    }
                    convertedExpression = LiteralExpression(text)
                }
                else if (expectedTypeStr == "long") {
                    if (expression.parent is PsiBinaryExpression) {
                        convertedExpression = LiteralExpression("${convertedExpression.canonicalCode()}L")
                    }
                }
                else if (expectedTypeStr == "char") {
                    convertedExpression = MethodCallExpression.buildNonNull(convertedExpression, "toChar")
                }
            }
            else if (expression is PsiPrefixExpression && expression.isLiteralWithSign()) {
                val operandConverted = convertExpression(expression.operand, expectedType)
                convertedExpression = PrefixExpression(Operator(expression.operationSign.tokenType).assignPrototype(expression.operationSign), operandConverted)
            }
            else {
                val conversion = PRIMITIVE_TYPE_CONVERSIONS[expectedTypeStr]
                if (conversion != null) {
                    convertedExpression = MethodCallExpression.buildNonNull(convertedExpression, conversion)
                }
            }' @ [117:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'expression' @ [117:17] ==> value-parameter expression: PsiExpression? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[ValueParameterDescriptorImpl]

'if (expectedTypeStr == "float" || expectedTypeStr == "double") {
                    var text = convertedExpression.canonicalCode()
                    if (text.last() in setOf('f', 'L')) {
                        text = text.substring(0, text.length - 1)
                    }
                    if (expectedTypeStr == "float") {
                        text += "f"
                    }
                    if (expectedTypeStr == "double") {
                        if (!text.contains(".") && !text.contains("e", true)) {
                            text += ".0"
                        }
                    }
                    convertedExpression = LiteralExpression(text)
                }
                else if (expectedTypeStr == "long") {
                    if (expression.parent is PsiBinaryExpression) {
                        convertedExpression = LiteralExpression("${convertedExpression.canonicalCode()}L")
                    }
                }
                else if (expectedTypeStr == "char") {
                    convertedExpression = MethodCallExpression.buildNonNull(convertedExpression, "toChar")
                }' @ [118:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'expectedTypeStr' @ [118:21] ==> val expectedTypeStr: String defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'expectedTypeStr' @ [118:51] ==> val expectedTypeStr: String defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'convertedExpression' @ [119:32] ==> var convertedExpression: Expression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'canonicalCode' @ [119:52] ==> public fun Element.canonicalCode(): String defined in org.jetbrains.kotlin.j2k.ast in file Element.kt[SimpleFunctionDescriptorImpl]

'text' @ [120:25] ==> var text: String defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'last' @ [120:30] ==> public fun CharSequence.last(): Char defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'setOf' @ [120:40] ==> public fun <T> setOf(vararg elements: Char): Set<Char> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Char

'text' @ [121:25] ==> var text: String defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'text' @ [121:32] ==> var text: String defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'substring' @ [121:37] ==> @InlineOnly public inline fun String.substring(startIndex: Int, endIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'text' @ [121:50] ==> var text: String defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'length' @ [121:55] ==> public open val length: Int defined in kotlin.String[DeserializedPropertyDescriptor]

'expectedTypeStr' @ [123:25] ==> val expectedTypeStr: String defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'text' @ [124:25] ==> var text: String defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'expectedTypeStr' @ [126:25] ==> val expectedTypeStr: String defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'!' @ [127:29] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'text' @ [127:30] ==> var text: String defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'contains' @ [127:35] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'!' @ [127:52] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'text' @ [127:53] ==> var text: String defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'contains' @ [127:58] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'text' @ [128:29] ==> var text: String defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'convertedExpression' @ [131:21] ==> var convertedExpression: Expression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'LiteralExpression' @ [131:43] ==> public constructor LiteralExpression(literalText: String) defined in org.jetbrains.kotlin.j2k.ast.LiteralExpression[ClassConstructorDescriptorImpl]

'text' @ [131:61] ==> var text: String defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'if (expectedTypeStr == "long") {
                    if (expression.parent is PsiBinaryExpression) {
                        convertedExpression = LiteralExpression("${convertedExpression.canonicalCode()}L")
                    }
                }
                else if (expectedTypeStr == "char") {
                    convertedExpression = MethodCallExpression.buildNonNull(convertedExpression, "toChar")
                }' @ [133:22] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'expectedTypeStr' @ [133:26] ==> val expectedTypeStr: String defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'expression' @ [134:25] ==> value-parameter expression: PsiExpression? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[ValueParameterDescriptorImpl]

'parent' @ [134:36] ==> public final val PsiLiteralExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'convertedExpression' @ [135:25] ==> var convertedExpression: Expression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'LiteralExpression' @ [135:47] ==> public constructor LiteralExpression(literalText: String) defined in org.jetbrains.kotlin.j2k.ast.LiteralExpression[ClassConstructorDescriptorImpl]

'convertedExpression' @ [135:68] ==> var convertedExpression: Expression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'canonicalCode' @ [135:88] ==> public fun Element.canonicalCode(): String defined in org.jetbrains.kotlin.j2k.ast in file Element.kt[SimpleFunctionDescriptorImpl]

'expectedTypeStr' @ [138:26] ==> val expectedTypeStr: String defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'convertedExpression' @ [139:21] ==> var convertedExpression: Expression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'MethodCallExpression' @ [139:43] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.MethodCallExpression[FakeCallableDescriptorForObject]

'buildNonNull' @ [139:64] ==> public final fun buildNonNull(receiver: Expression?, methodName: String, argumentList: ArgumentList = ..., typeArguments: List<Type> = ..., dotPrototype: PsiElement? = ...): MethodCallExpression defined in org.jetbrains.kotlin.j2k.ast.MethodCallExpression.Companion[SimpleFunctionDescriptorImpl]

'convertedExpression' @ [139:77] ==> var convertedExpression: Expression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'if (expression is PsiPrefixExpression && expression.isLiteralWithSign()) {
                val operandConverted = convertExpression(expression.operand, expectedType)
                convertedExpression = PrefixExpression(Operator(expression.operationSign.tokenType).assignPrototype(expression.operationSign), operandConverted)
            }
            else {
                val conversion = PRIMITIVE_TYPE_CONVERSIONS[expectedTypeStr]
                if (conversion != null) {
                    convertedExpression = MethodCallExpression.buildNonNull(convertedExpression, conversion)
                }
            }' @ [142:18] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'expression' @ [142:22] ==> value-parameter expression: PsiExpression? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[ValueParameterDescriptorImpl]

'expression' @ [142:59] ==> value-parameter expression: PsiExpression? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[ValueParameterDescriptorImpl]

'isLiteralWithSign' @ [142:70] ==> private final fun PsiPrefixExpression.isLiteralWithSign(): Boolean defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'convertExpression' @ [143:40] ==> public final fun convertExpression(expression: PsiExpression?, expectedType: PsiType?, expectedNullability: Nullability? = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'expression' @ [143:58] ==> value-parameter expression: PsiExpression? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[ValueParameterDescriptorImpl]

'operand' @ [143:69] ==> public final val PsiPrefixExpression.operand: PsiExpression?[MyPropertyDescriptor]

'expectedType' @ [143:78] ==> value-parameter expectedType: PsiType? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[ValueParameterDescriptorImpl]

'convertedExpression' @ [144:17] ==> var convertedExpression: Expression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'PrefixExpression' @ [144:39] ==> public constructor PrefixExpression(op: Operator, expression: Expression) defined in org.jetbrains.kotlin.j2k.ast.PrefixExpression[ClassConstructorDescriptorImpl]

'Operator' @ [144:56] ==> public constructor Operator(operatorType: IElementType) defined in org.jetbrains.kotlin.j2k.ast.Operator[ClassConstructorDescriptorImpl]

'expression' @ [144:65] ==> value-parameter expression: PsiExpression? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[ValueParameterDescriptorImpl]

'operationSign' @ [144:76] ==> public final val PsiPrefixExpression.operationSign: PsiJavaToken[MyPropertyDescriptor]

'tokenType' @ [144:90] ==> public final val PsiJavaToken.tokenType: (IElementType..IElementType?)[MyPropertyDescriptor]

'assignPrototype' @ [144:101] ==> public fun <TElement : Element> Operator.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Operator defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Operator

'expression' @ [144:117] ==> value-parameter expression: PsiExpression? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[ValueParameterDescriptorImpl]

'operationSign' @ [144:128] ==> public final val PsiPrefixExpression.operationSign: PsiJavaToken[MyPropertyDescriptor]

'operandConverted' @ [144:144] ==> val operandConverted: Expression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'PRIMITIVE_TYPE_CONVERSIONS' @ [147:34] ==> public val PRIMITIVE_TYPE_CONVERSIONS: Map<String, String> defined in org.jetbrains.kotlin.j2k in file Converter.kt[PropertyDescriptorImpl]

'expectedTypeStr' @ [147:61] ==> val expectedTypeStr: String defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'conversion' @ [148:21] ==> val conversion: String? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'convertedExpression' @ [149:21] ==> var convertedExpression: Expression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'MethodCallExpression' @ [149:43] ==> public companion object defined in org.jetbrains.kotlin.j2k.ast.MethodCallExpression[FakeCallableDescriptorForObject]

'buildNonNull' @ [149:64] ==> public final fun buildNonNull(receiver: Expression?, methodName: String, argumentList: ArgumentList = ..., typeArguments: List<Type> = ..., dotPrototype: PsiElement? = ...): MethodCallExpression defined in org.jetbrains.kotlin.j2k.ast.MethodCallExpression.Companion[SimpleFunctionDescriptorImpl]

'convertedExpression' @ [149:77] ==> var convertedExpression: Expression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'conversion' @ [149:98] ==> val conversion: String? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'convertedExpression' @ [154:16] ==> var convertedExpression: Expression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[LocalVariableDescriptor]

'assignPrototype' @ [154:36] ==> public fun <TElement : Element> Expression.assignPrototype(prototype: PsiElement?, inheritance: CommentsAndSpacesInheritance = ...): Expression defined in org.jetbrains.kotlin.j2k.ast[SimpleFunctionDescriptorImpl]
Inferred types:
    <TElement : Element> -> Expression

'expression' @ [154:52] ==> value-parameter expression: PsiExpression? defined in org.jetbrains.kotlin.j2k.CodeConverter.convertExpression[ValueParameterDescriptorImpl]

'with' @ [158:9] ==> @InlineOnly public inline fun <T, R> with(receiver: CodeConverter, block: CodeConverter.() -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> CodeConverter
    <R> -> Nothing

'converter' @ [158:14] ==> public final val converter: Converter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'codeConverterForType' @ [158:24] ==> public final val codeConverterForType: CodeConverter defined in org.jetbrains.kotlin.j2k.Converter[PropertyDescriptorImpl]

'convertExpression' @ [159:39] ==> public final fun convertExpression(expression: PsiExpression?, shouldParenthesize: Boolean = ...): Expression defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'expression' @ [159:57] ==> value-parameter expression: PsiExpression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertedExpressionType[ValueParameterDescriptorImpl]

'expression' @ [160:30] ==> value-parameter expression: PsiExpression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertedExpressionType[ValueParameterDescriptorImpl]

'type' @ [160:41] ==> public final val PsiExpression.type: PsiType?[MyPropertyDescriptor]

'ErrorType' @ [160:56] ==> public constructor ErrorType() defined in org.jetbrains.kotlin.j2k.ast.ErrorType[ClassConstructorDescriptorImpl]

'typeConverter' @ [161:30] ==> public final val typeConverter: TypeConverter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'convertType' @ [161:44] ==> public final fun convertType(type: PsiType?, nullability: Nullability = ..., mutability: Mutability = ..., inAnnotationType: Boolean = ...): Type defined in org.jetbrains.kotlin.j2k.TypeConverter[SimpleFunctionDescriptorImpl]

'actualType' @ [161:56] ==> val actualType: PsiType defined in org.jetbrains.kotlin.j2k.CodeConverter.convertedExpressionType.<anonymous>[LocalVariableDescriptor]

'if (convertedExpression.isNullable) Nullability.Nullable else Nullability.NotNull' @ [161:68] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nullability, elseBranch: Nullability): Nullability[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nullability

'convertedExpression' @ [161:72] ==> val convertedExpression: Expression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertedExpressionType.<anonymous>[LocalVariableDescriptor]

'isNullable' @ [161:92] ==> public open val isNullable: Boolean defined in org.jetbrains.kotlin.j2k.ast.Expression[PropertyDescriptorImpl]

'Nullable' @ [161:116] ==> enum entry Nullable defined in org.jetbrains.kotlin.j2k.ast.Nullability[FakeCallableDescriptorForObject]

'NotNull' @ [161:142] ==> enum entry NotNull defined in org.jetbrains.kotlin.j2k.ast.Nullability[FakeCallableDescriptorForObject]

'actualType' @ [163:17] ==> val actualType: PsiType defined in org.jetbrains.kotlin.j2k.CodeConverter.convertedExpressionType.<anonymous>[LocalVariableDescriptor]

'resultType' @ [163:51] ==> var resultType: Type defined in org.jetbrains.kotlin.j2k.CodeConverter.convertedExpressionType.<anonymous>[LocalVariableDescriptor]

'isNullable' @ [163:62] ==> public abstract val isNullable: Boolean defined in org.jetbrains.kotlin.j2k.ast.Type[PropertyDescriptorImpl]

'expectedType' @ [164:17] ==> value-parameter expectedType: PsiType defined in org.jetbrains.kotlin.j2k.CodeConverter.convertedExpressionType[ValueParameterDescriptorImpl]

'actualType' @ [164:53] ==> val actualType: PsiType defined in org.jetbrains.kotlin.j2k.CodeConverter.convertedExpressionType.<anonymous>[LocalVariableDescriptor]

'resultType' @ [165:17] ==> var resultType: Type defined in org.jetbrains.kotlin.j2k.CodeConverter.convertedExpressionType.<anonymous>[LocalVariableDescriptor]

'resultType' @ [165:30] ==> var resultType: Type defined in org.jetbrains.kotlin.j2k.CodeConverter.convertedExpressionType.<anonymous>[LocalVariableDescriptor]

'toNotNullType' @ [165:41] ==> public open fun toNotNullType(): Type defined in org.jetbrains.kotlin.j2k.ast.Type[SimpleFunctionDescriptorImpl]

'needConversion' @ [168:17] ==> private final fun needConversion(actual: PsiType, expected: PsiType): Boolean defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'actualType' @ [168:32] ==> val actualType: PsiType defined in org.jetbrains.kotlin.j2k.CodeConverter.convertedExpressionType.<anonymous>[LocalVariableDescriptor]

'expectedType' @ [168:44] ==> value-parameter expectedType: PsiType defined in org.jetbrains.kotlin.j2k.CodeConverter.convertedExpressionType[ValueParameterDescriptorImpl]

'expectedType' @ [169:39] ==> value-parameter expectedType: PsiType defined in org.jetbrains.kotlin.j2k.CodeConverter.convertedExpressionType[ValueParameterDescriptorImpl]

'canonicalText' @ [169:52] ==> public final val PsiType.canonicalText: String[MyPropertyDescriptor]

'if (convertedExpression is LiteralExpression
                                      || expression is PsiPrefixExpression && expression.isLiteralWithSign())
                    expectedTypeStr == "float" || expectedTypeStr == "double"
                else
                    PRIMITIVE_TYPE_CONVERSIONS[expectedTypeStr] != null' @ [171:35] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Boolean, elseBranch: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Boolean

'convertedExpression' @ [171:39] ==> val convertedExpression: Expression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertedExpressionType.<anonymous>[LocalVariableDescriptor]

'expression' @ [172:42] ==> value-parameter expression: PsiExpression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertedExpressionType[ValueParameterDescriptorImpl]

'expression' @ [172:79] ==> value-parameter expression: PsiExpression defined in org.jetbrains.kotlin.j2k.CodeConverter.convertedExpressionType[ValueParameterDescriptorImpl]

'isLiteralWithSign' @ [172:90] ==> private final fun PsiPrefixExpression.isLiteralWithSign(): Boolean defined in org.jetbrains.kotlin.j2k.CodeConverter[SimpleFunctionDescriptorImpl]

'expectedTypeStr' @ [173:21] ==> val expectedTypeStr: String defined in org.jetbrains.kotlin.j2k.CodeConverter.convertedExpressionType.<anonymous>[LocalVariableDescriptor]

'expectedTypeStr' @ [173:51] ==> val expectedTypeStr: String defined in org.jetbrains.kotlin.j2k.CodeConverter.convertedExpressionType.<anonymous>[LocalVariableDescriptor]

'PRIMITIVE_TYPE_CONVERSIONS' @ [175:21] ==> public val PRIMITIVE_TYPE_CONVERSIONS: Map<String, String> defined in org.jetbrains.kotlin.j2k in file Converter.kt[PropertyDescriptorImpl]

'expectedTypeStr' @ [175:48] ==> val expectedTypeStr: String defined in org.jetbrains.kotlin.j2k.CodeConverter.convertedExpressionType.<anonymous>[LocalVariableDescriptor]

'willConvert' @ [177:21] ==> val willConvert: Boolean defined in org.jetbrains.kotlin.j2k.CodeConverter.convertedExpressionType.<anonymous>[LocalVariableDescriptor]

'resultType' @ [178:21] ==> var resultType: Type defined in org.jetbrains.kotlin.j2k.CodeConverter.convertedExpressionType.<anonymous>[LocalVariableDescriptor]

'typeConverter' @ [178:34] ==> public final val typeConverter: TypeConverter defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'convertType' @ [178:48] ==> public final fun convertType(type: PsiType?, nullability: Nullability = ..., mutability: Mutability = ..., inAnnotationType: Boolean = ...): Type defined in org.jetbrains.kotlin.j2k.TypeConverter[SimpleFunctionDescriptorImpl]

'expectedType' @ [178:60] ==> value-parameter expectedType: PsiType defined in org.jetbrains.kotlin.j2k.CodeConverter.convertedExpressionType[ValueParameterDescriptorImpl]

'NotNull' @ [178:86] ==> enum entry NotNull defined in org.jetbrains.kotlin.j2k.ast.Nullability[FakeCallableDescriptorForObject]

'resultType' @ [182:20] ==> var resultType: Type defined in org.jetbrains.kotlin.j2k.CodeConverter.convertedExpressionType.<anonymous>[LocalVariableDescriptor]

'operand' @ [187:15] ==> public final val PsiPrefixExpression.operand: PsiExpression?[MyPropertyDescriptor]

'operationTokenType' @ [187:50] ==> public final val PsiPrefixExpression.operationTokenType: IElementType[MyPropertyDescriptor]

'setOf' @ [187:72] ==> public fun <T> setOf(vararg elements: (IElementType..IElementType?)): Set<(IElementType..IElementType?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.tree.IElementType..com.intellij.psi.tree.IElementType?)

'PLUS' @ [187:92] ==> public final val PLUS: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'MINUS' @ [187:112] ==> public final val MINUS: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'expected' @ [190:27] ==> value-parameter expected: PsiType defined in org.jetbrains.kotlin.j2k.CodeConverter.needConversion[ValueParameterDescriptorImpl]

'canonicalText' @ [190:36] ==> public final val PsiType.canonicalText: String[MyPropertyDescriptor]

'actual' @ [191:25] ==> value-parameter actual: PsiType defined in org.jetbrains.kotlin.j2k.CodeConverter.needConversion[ValueParameterDescriptorImpl]

'canonicalText' @ [191:32] ==> public final val PsiType.canonicalText: String[MyPropertyDescriptor]

'expectedStr' @ [192:16] ==> val expectedStr: String defined in org.jetbrains.kotlin.j2k.CodeConverter.needConversion[LocalVariableDescriptor]

'actualStr' @ [192:31] ==> val actualStr: String defined in org.jetbrains.kotlin.j2k.CodeConverter.needConversion[LocalVariableDescriptor]

'expectedStr' @ [193:16] ==> val expectedStr: String defined in org.jetbrains.kotlin.j2k.CodeConverter.needConversion[LocalVariableDescriptor]

'typeConversionMap' @ [193:31] ==> private final val typeConversionMap: Map<String, String> defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'actualStr' @ [193:49] ==> val actualStr: String defined in org.jetbrains.kotlin.j2k.CodeConverter.needConversion[LocalVariableDescriptor]

'actualStr' @ [194:16] ==> val actualStr: String defined in org.jetbrains.kotlin.j2k.CodeConverter.needConversion[LocalVariableDescriptor]

'typeConversionMap' @ [194:29] ==> private final val typeConversionMap: Map<String, String> defined in org.jetbrains.kotlin.j2k.CodeConverter[PropertyDescriptorImpl]

'expectedStr' @ [194:47] ==> val expectedStr: String defined in org.jetbrains.kotlin.j2k.CodeConverter.needConversion[LocalVariableDescriptor]

'mapOf' @ [197:58] ==> public fun <K, V> mapOf(vararg pairs: Pair<String, String>): Map<String, String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> String
    <V> -> String

'JAVA_LANG_BYTE' @ [198:13] ==> @NonNls public const final val JAVA_LANG_BYTE: String defined in com.intellij.psi.CommonClassNames[JavaPropertyDescriptor]

'JAVA_LANG_SHORT' @ [199:13] ==> @NonNls public const final val JAVA_LANG_SHORT: String defined in com.intellij.psi.CommonClassNames[JavaPropertyDescriptor]

'JAVA_LANG_INTEGER' @ [200:13] ==> @NonNls public const final val JAVA_LANG_INTEGER: String defined in com.intellij.psi.CommonClassNames[JavaPropertyDescriptor]

'JAVA_LANG_LONG' @ [201:13] ==> @NonNls public const final val JAVA_LANG_LONG: String defined in com.intellij.psi.CommonClassNames[JavaPropertyDescriptor]

'JAVA_LANG_FLOAT' @ [202:13] ==> @NonNls public const final val JAVA_LANG_FLOAT: String defined in com.intellij.psi.CommonClassNames[JavaPropertyDescriptor]

'JAVA_LANG_DOUBLE' @ [203:13] ==> @NonNls public const final val JAVA_LANG_DOUBLE: String defined in com.intellij.psi.CommonClassNames[JavaPropertyDescriptor]

'JAVA_LANG_CHARACTER' @ [204:13] ==> @NonNls public const final val JAVA_LANG_CHARACTER: String defined in com.intellij.psi.CommonClassNames[JavaPropertyDescriptor]

