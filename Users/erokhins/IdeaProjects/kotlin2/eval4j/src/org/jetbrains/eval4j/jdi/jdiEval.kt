'getType' @ [29:26] ==> public open fun getType(p0: (Class<*>..Class<*>?)): (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaMethodDescriptor]

'Class' @ [29:34] ==> private constructor Class<T : (Any..Any?)>(p0: (ClassLoader..ClassLoader?)) defined in java.lang.Class[JavaClassConstructorDescriptor]
Inferred types:
    <T : (Any..Any?)> -> org.jetbrains.kotlin.types.ErrorUtils$UninferredParameterTypeConstructor@c85ef7d

'java' @ [29:47] ==> public val <T> KClass<Class<*>>.java: Class<Class<*>> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> Class<*>

'getType' @ [30:27] ==> public open fun getType(p0: (Class<*>..Class<*>?)): (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaMethodDescriptor]

'Any' @ [30:35] ==> public constructor Any() defined in kotlin.Any[DeserializedClassConstructorDescriptor]

'java' @ [30:46] ==> public val <T> KClass<Any>.java: Class<Any> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> Any

'setOf' @ [31:43] ==> public fun <T> setOf(vararg elements: String): Set<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'mapOf' @ [40:34] ==> public fun <K, V> mapOf(vararg pairs: Pair<(String..String?), (Type..Type?)>): Map<(String..String?), (Type..Type?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (kotlin.String..kotlin.String?)
    <V> -> (com.sun.jdi.Type..com.sun.jdi.Type?)

'to' @ [41:13] ==> public infix fun <A, B> (String..String?).to(that: (Type..Type?)): Pair<(String..String?), (Type..Type?)> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> (kotlin.String..kotlin.String?)
    <B> -> (com.sun.jdi.Type..com.sun.jdi.Type?)

'BOOLEAN_TYPE' @ [41:18] ==> public final val BOOLEAN_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'className' @ [41:31] ==> public final val Type.className: (String..String?)[MyPropertyDescriptor]

'vm' @ [41:44] ==> private final val vm: VirtualMachine defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'mirrorOf' @ [41:47] ==> public abstract fun mirrorOf(p0: Boolean): (BooleanValue..BooleanValue?) defined in com.sun.jdi.VirtualMachine[JavaMethodDescriptor]

'type' @ [41:62] ==> public abstract fun type(): (Type..Type?) defined in com.sun.jdi.BooleanValue[JavaMethodDescriptor]

'to' @ [42:13] ==> public infix fun <A, B> (String..String?).to(that: (Type..Type?)): Pair<(String..String?), (Type..Type?)> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> (kotlin.String..kotlin.String?)
    <B> -> (com.sun.jdi.Type..com.sun.jdi.Type?)

'BYTE_TYPE' @ [42:18] ==> public final val BYTE_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'className' @ [42:28] ==> public final val Type.className: (String..String?)[MyPropertyDescriptor]

'vm' @ [42:41] ==> private final val vm: VirtualMachine defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'mirrorOf' @ [42:44] ==> public abstract fun mirrorOf(p0: Byte): (ByteValue..ByteValue?) defined in com.sun.jdi.VirtualMachine[JavaMethodDescriptor]

'toByte' @ [42:55] ==> public open fun toByte(): Byte defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'type' @ [42:65] ==> public abstract fun type(): (Type..Type?) defined in com.sun.jdi.ByteValue[JavaMethodDescriptor]

'to' @ [43:13] ==> public infix fun <A, B> (String..String?).to(that: (Type..Type?)): Pair<(String..String?), (Type..Type?)> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> (kotlin.String..kotlin.String?)
    <B> -> (com.sun.jdi.Type..com.sun.jdi.Type?)

'SHORT_TYPE' @ [43:18] ==> public final val SHORT_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'className' @ [43:29] ==> public final val Type.className: (String..String?)[MyPropertyDescriptor]

'vm' @ [43:42] ==> private final val vm: VirtualMachine defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'mirrorOf' @ [43:45] ==> public abstract fun mirrorOf(p0: Short): (ShortValue..ShortValue?) defined in com.sun.jdi.VirtualMachine[JavaMethodDescriptor]

'toShort' @ [43:56] ==> public open fun toShort(): Short defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'type' @ [43:67] ==> public abstract fun type(): (Type..Type?) defined in com.sun.jdi.ShortValue[JavaMethodDescriptor]

'to' @ [44:13] ==> public infix fun <A, B> (String..String?).to(that: (Type..Type?)): Pair<(String..String?), (Type..Type?)> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> (kotlin.String..kotlin.String?)
    <B> -> (com.sun.jdi.Type..com.sun.jdi.Type?)

'INT_TYPE' @ [44:18] ==> public final val INT_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'className' @ [44:27] ==> public final val Type.className: (String..String?)[MyPropertyDescriptor]

'vm' @ [44:40] ==> private final val vm: VirtualMachine defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'mirrorOf' @ [44:43] ==> public abstract fun mirrorOf(p0: Int): (IntegerValue..IntegerValue?) defined in com.sun.jdi.VirtualMachine[JavaMethodDescriptor]

'type' @ [44:55] ==> public abstract fun type(): (Type..Type?) defined in com.sun.jdi.IntegerValue[JavaMethodDescriptor]

'to' @ [45:13] ==> public infix fun <A, B> (String..String?).to(that: (Type..Type?)): Pair<(String..String?), (Type..Type?)> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> (kotlin.String..kotlin.String?)
    <B> -> (com.sun.jdi.Type..com.sun.jdi.Type?)

'CHAR_TYPE' @ [45:18] ==> public final val CHAR_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'className' @ [45:28] ==> public final val Type.className: (String..String?)[MyPropertyDescriptor]

'vm' @ [45:41] ==> private final val vm: VirtualMachine defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'mirrorOf' @ [45:44] ==> public abstract fun mirrorOf(p0: Char): (CharValue..CharValue?) defined in com.sun.jdi.VirtualMachine[JavaMethodDescriptor]

'type' @ [45:58] ==> public abstract fun type(): (Type..Type?) defined in com.sun.jdi.CharValue[JavaMethodDescriptor]

'to' @ [46:13] ==> public infix fun <A, B> (String..String?).to(that: (Type..Type?)): Pair<(String..String?), (Type..Type?)> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> (kotlin.String..kotlin.String?)
    <B> -> (com.sun.jdi.Type..com.sun.jdi.Type?)

'LONG_TYPE' @ [46:18] ==> public final val LONG_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'className' @ [46:28] ==> public final val Type.className: (String..String?)[MyPropertyDescriptor]

'vm' @ [46:41] ==> private final val vm: VirtualMachine defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'mirrorOf' @ [46:44] ==> public abstract fun mirrorOf(p0: Long): (LongValue..LongValue?) defined in com.sun.jdi.VirtualMachine[JavaMethodDescriptor]

'type' @ [46:57] ==> public abstract fun type(): (Type..Type?) defined in com.sun.jdi.LongValue[JavaMethodDescriptor]

'to' @ [47:13] ==> public infix fun <A, B> (String..String?).to(that: (Type..Type?)): Pair<(String..String?), (Type..Type?)> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> (kotlin.String..kotlin.String?)
    <B> -> (com.sun.jdi.Type..com.sun.jdi.Type?)

'FLOAT_TYPE' @ [47:18] ==> public final val FLOAT_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'className' @ [47:29] ==> public final val Type.className: (String..String?)[MyPropertyDescriptor]

'vm' @ [47:42] ==> private final val vm: VirtualMachine defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'mirrorOf' @ [47:45] ==> public abstract fun mirrorOf(p0: Float): (FloatValue..FloatValue?) defined in com.sun.jdi.VirtualMachine[JavaMethodDescriptor]

'type' @ [47:60] ==> public abstract fun type(): (Type..Type?) defined in com.sun.jdi.FloatValue[JavaMethodDescriptor]

'to' @ [48:13] ==> public infix fun <A, B> (String..String?).to(that: (Type..Type?)): Pair<(String..String?), (Type..Type?)> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> (kotlin.String..kotlin.String?)
    <B> -> (com.sun.jdi.Type..com.sun.jdi.Type?)

'DOUBLE_TYPE' @ [48:18] ==> public final val DOUBLE_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'className' @ [48:30] ==> public final val Type.className: (String..String?)[MyPropertyDescriptor]

'vm' @ [48:43] ==> private final val vm: VirtualMachine defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'mirrorOf' @ [48:46] ==> public abstract fun mirrorOf(p0: Double): (DoubleValue..DoubleValue?) defined in com.sun.jdi.VirtualMachine[JavaMethodDescriptor]

'type' @ [48:60] ==> public abstract fun type(): (Type..Type?) defined in com.sun.jdi.DoubleValue[JavaMethodDescriptor]

'loadClass' @ [52:16] ==> public final fun loadClass(classType: Type, classLoader: ClassLoaderReference?): Value defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'classType' @ [52:26] ==> value-parameter classType: Type defined in org.jetbrains.eval4j.jdi.JDIEval.loadClass[ValueParameterDescriptorImpl]

'defaultClassLoader' @ [52:37] ==> private final val defaultClassLoader: ClassLoaderReference? defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'vm' @ [56:29] ==> private final val vm: VirtualMachine defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'classesByName' @ [56:32] ==> public abstract fun classesByName(p0: (String..String?)): (MutableList<(ReferenceType..ReferenceType?)>..List<(ReferenceType..ReferenceType?)>?) defined in com.sun.jdi.VirtualMachine[JavaMethodDescriptor]

'classType' @ [56:46] ==> value-parameter classType: Type defined in org.jetbrains.eval4j.jdi.JDIEval.loadClass[ValueParameterDescriptorImpl]

'internalName' @ [56:56] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'!' @ [57:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'loadedClasses' @ [57:14] ==> val loadedClasses: (MutableList<(ReferenceType..ReferenceType?)>..List<(ReferenceType..ReferenceType?)>?) defined in org.jetbrains.eval4j.jdi.JDIEval.loadClass[LocalVariableDescriptor]

'isEmpty' @ [57:28] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'loadedClasses' @ [58:33] ==> val loadedClasses: (MutableList<(ReferenceType..ReferenceType?)>..List<(ReferenceType..ReferenceType?)>?) defined in org.jetbrains.eval4j.jdi.JDIEval.loadClass[LocalVariableDescriptor]

'loadedClass' @ [59:21] ==> val loadedClass: (ReferenceType..ReferenceType?) defined in org.jetbrains.eval4j.jdi.JDIEval.loadClass[LocalVariableDescriptor]

'isPrepared' @ [59:33] ==> public final val ReferenceType.isPrepared: Boolean[MyPropertyDescriptor]

'classType' @ [59:48] ==> value-parameter classType: Type defined in org.jetbrains.eval4j.jdi.JDIEval.loadClass[ValueParameterDescriptorImpl]

'descriptor' @ [59:58] ==> public final val Type.descriptor: (String..String?)[MyPropertyDescriptor]

'BOOTSTRAP_CLASS_DESCRIPTORS' @ [59:72] ==> private val BOOTSTRAP_CLASS_DESCRIPTORS: Set<String> defined in org.jetbrains.eval4j.jdi in file jdiEval.kt[PropertyDescriptorImpl]

'loadedClass' @ [59:103] ==> val loadedClass: (ReferenceType..ReferenceType?) defined in org.jetbrains.eval4j.jdi.JDIEval.loadClass[LocalVariableDescriptor]

'classLoader' @ [59:115] ==> public abstract fun classLoader(): (ClassLoaderReference..ClassLoaderReference?) defined in com.sun.jdi.ReferenceType[JavaMethodDescriptor]

'classLoader' @ [59:132] ==> value-parameter classLoader: ClassLoaderReference? defined in org.jetbrains.eval4j.jdi.JDIEval.loadClass[ValueParameterDescriptorImpl]

'loadedClass' @ [60:28] ==> val loadedClass: (ReferenceType..ReferenceType?) defined in org.jetbrains.eval4j.jdi.JDIEval.loadClass[LocalVariableDescriptor]

'classObject' @ [60:40] ==> public abstract fun classObject(): (ClassObjectReference..ClassObjectReference?) defined in com.sun.jdi.ReferenceType[JavaMethodDescriptor]

'asValue' @ [60:54] ==> public fun ObjectReference?.asValue(): ObjectValue defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'if (classLoader == null) {
            return invokeStaticMethod(
                    MethodDescription(
                            CLASS.internalName,
                            "forName",
                            "(Ljava/lang/String;)Ljava/lang/Class;",
                            true
                    ),
                    listOf(vm.mirrorOf(classType.internalName.replace('/', '.')).asValue())
            )
        }
        else {
            return invokeStaticMethod(
                    MethodDescription(
                            CLASS.internalName,
                            "forName",
                            "(Ljava/lang/String;ZLjava/lang/ClassLoader;)Ljava/lang/Class;",
                            true
                    ),
                    listOf(
                            vm.mirrorOf(classType.internalName.replace('/', '.')).asValue(),
                            boolean(true),
                            classLoader.asValue()
                    )
            )
        }' @ [64:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nothing, elseBranch: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nothing

'classLoader' @ [64:13] ==> value-parameter classLoader: ClassLoaderReference? defined in org.jetbrains.eval4j.jdi.JDIEval.loadClass[ValueParameterDescriptorImpl]

'invokeStaticMethod' @ [65:20] ==> public open fun invokeStaticMethod(methodDesc: MethodDescription, arguments: List<Value>): Value defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'MethodDescription' @ [66:21] ==> public constructor MethodDescription(ownerInternalName: String, name: String, desc: String, isStatic: Boolean) defined in org.jetbrains.eval4j.MethodDescription[ClassConstructorDescriptorImpl]

'CLASS' @ [67:29] ==> private val CLASS: (Type..Type?) defined in org.jetbrains.eval4j.jdi in file jdiEval.kt[PropertyDescriptorImpl]

'internalName' @ [67:35] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'listOf' @ [72:21] ==> public fun <T> listOf(element: ObjectValue): List<ObjectValue> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ObjectValue

'vm' @ [72:28] ==> private final val vm: VirtualMachine defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'mirrorOf' @ [72:31] ==> public abstract fun mirrorOf(p0: (String..String?)): (StringReference..StringReference?) defined in com.sun.jdi.VirtualMachine[JavaMethodDescriptor]

'classType' @ [72:40] ==> value-parameter classType: Type defined in org.jetbrains.eval4j.jdi.JDIEval.loadClass[ValueParameterDescriptorImpl]

'internalName' @ [72:50] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'replace' @ [72:63] ==> public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'asValue' @ [72:82] ==> public fun ObjectReference?.asValue(): ObjectValue defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'invokeStaticMethod' @ [76:20] ==> public open fun invokeStaticMethod(methodDesc: MethodDescription, arguments: List<Value>): Value defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'MethodDescription' @ [77:21] ==> public constructor MethodDescription(ownerInternalName: String, name: String, desc: String, isStatic: Boolean) defined in org.jetbrains.eval4j.MethodDescription[ClassConstructorDescriptorImpl]

'CLASS' @ [78:29] ==> private val CLASS: (Type..Type?) defined in org.jetbrains.eval4j.jdi in file jdiEval.kt[PropertyDescriptorImpl]

'internalName' @ [78:35] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'listOf' @ [83:21] ==> public fun <T> listOf(vararg elements: AbstractValue<out Any?>): List<AbstractValue<out Any?>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> AbstractValue<out Any?>

'vm' @ [84:29] ==> private final val vm: VirtualMachine defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'mirrorOf' @ [84:32] ==> public abstract fun mirrorOf(p0: (String..String?)): (StringReference..StringReference?) defined in com.sun.jdi.VirtualMachine[JavaMethodDescriptor]

'classType' @ [84:41] ==> value-parameter classType: Type defined in org.jetbrains.eval4j.jdi.JDIEval.loadClass[ValueParameterDescriptorImpl]

'internalName' @ [84:51] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'replace' @ [84:64] ==> public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'asValue' @ [84:83] ==> public fun ObjectReference?.asValue(): ObjectValue defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'boolean' @ [85:29] ==> public fun boolean(v: Boolean): IntValue defined in org.jetbrains.eval4j in file values.kt[SimpleFunctionDescriptorImpl]

'classLoader' @ [86:29] ==> value-parameter classLoader: ClassLoaderReference? defined in org.jetbrains.eval4j.jdi.JDIEval.loadClass[ValueParameterDescriptorImpl]

'asValue' @ [86:41] ==> public fun ObjectReference?.asValue(): ObjectValue defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'vm' @ [92:51] ==> private final val vm: VirtualMachine defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'mirrorOf' @ [92:54] ==> public abstract fun mirrorOf(p0: (String..String?)): (StringReference..StringReference?) defined in com.sun.jdi.VirtualMachine[JavaMethodDescriptor]

'str' @ [92:63] ==> value-parameter str: String defined in org.jetbrains.eval4j.jdi.JDIEval.loadString[ValueParameterDescriptorImpl]

'asValue' @ [92:68] ==> public fun ObjectReference?.asValue(): ObjectValue defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'NewObjectValue' @ [95:16] ==> public constructor NewObjectValue(asmType: Type) defined in org.jetbrains.eval4j.NewObjectValue[ClassConstructorDescriptorImpl]

'classType' @ [95:31] ==> value-parameter classType: Type defined in org.jetbrains.eval4j.jdi.JDIEval.newInstance[ValueParameterDescriptorImpl]

'assert' @ [99:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'targetType' @ [99:16] ==> value-parameter targetType: Type defined in org.jetbrains.eval4j.jdi.JDIEval.isInstanceOf[ValueParameterDescriptorImpl]

'sort' @ [99:27] ==> public final val Type.sort: Int[MyPropertyDescriptor]

'OBJECT' @ [99:40] ==> public const final val OBJECT: Int defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'targetType' @ [99:50] ==> value-parameter targetType: Type defined in org.jetbrains.eval4j.jdi.JDIEval.isInstanceOf[ValueParameterDescriptorImpl]

'sort' @ [99:61] ==> public final val Type.sort: Int[MyPropertyDescriptor]

'ARRAY' @ [99:74] ==> public const final val ARRAY: Int defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'targetType' @ [100:62] ==> value-parameter targetType: Type defined in org.jetbrains.eval4j.jdi.JDIEval.isInstanceOf[ValueParameterDescriptorImpl]

'loadClass' @ [103:22] ==> public open fun loadClass(classType: Type): Value defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'targetType' @ [103:32] ==> value-parameter targetType: Type defined in org.jetbrains.eval4j.jdi.JDIEval.isInstanceOf[ValueParameterDescriptorImpl]

'invokeMethod' @ [104:16] ==> public open fun invokeMethod(instance: Value, methodDesc: MethodDescription, arguments: List<Value>, invokespecial: Boolean): Value defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'_class' @ [105:17] ==> val _class: Value defined in org.jetbrains.eval4j.jdi.JDIEval.isInstanceOf[LocalVariableDescriptor]

'MethodDescription' @ [106:17] ==> public constructor MethodDescription(ownerInternalName: String, name: String, desc: String, isStatic: Boolean) defined in org.jetbrains.eval4j.MethodDescription[ClassConstructorDescriptorImpl]

'CLASS' @ [107:25] ==> private val CLASS: (Type..Type?) defined in org.jetbrains.eval4j.jdi in file jdiEval.kt[PropertyDescriptorImpl]

'internalName' @ [107:31] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'listOf' @ [112:17] ==> public fun <T> listOf(element: Value): List<Value> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Value

'value' @ [112:24] ==> value-parameter value: Value defined in org.jetbrains.eval4j.jdi.JDIEval.isInstanceOf[ValueParameterDescriptorImpl]

'boolean' @ [112:32] ==> public val Value.boolean: Boolean defined in org.jetbrains.eval4j in file values.kt[PropertyDescriptorImpl]

'this@JDIEval' @ [115:67] ==> <this> defined in org.jetbrains.eval4j.jdi.JDIEval[LazyClassReceiverParameterDescriptor]

'defaultClassLoader' @ [115:80] ==> private final val defaultClassLoader: ClassLoaderReference? defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'loadClass' @ [115:117] ==> public final fun loadClass(classType: Type, classLoader: ClassLoaderReference?): Value defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'this' @ [115:127] ==> <this> defined in org.jetbrains.eval4j.jdi.JDIEval.asReferenceType[ReceiverParameterDescriptorImpl]

'classLoader' @ [115:133] ==> value-parameter classLoader: ClassLoaderReference? = ... defined in org.jetbrains.eval4j.jdi.JDIEval.asReferenceType[ValueParameterDescriptorImpl]

'jdiClass' @ [115:146] ==> public val Value.jdiClass: ClassObjectReference? defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[PropertyDescriptorImpl]

'reflectedType' @ [115:157] ==> public abstract fun reflectedType(): (ReferenceType..ReferenceType?) defined in com.sun.jdi.ClassObjectReference[JavaMethodDescriptor]

'this@JDIEval' @ [116:63] ==> <this> defined in org.jetbrains.eval4j.jdi.JDIEval[LazyClassReceiverParameterDescriptor]

'defaultClassLoader' @ [116:76] ==> private final val defaultClassLoader: ClassLoaderReference? defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'asReferenceType' @ [116:109] ==> public final fun Type.asReferenceType(classLoader: ClassLoaderReference? = ...): ReferenceType defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'classLoader' @ [116:125] ==> value-parameter classLoader: ClassLoaderReference? = ... defined in org.jetbrains.eval4j.jdi.JDIEval.asArrayType[ValueParameterDescriptorImpl]

'arrayType' @ [119:28] ==> value-parameter arrayType: Type defined in org.jetbrains.eval4j.jdi.JDIEval.newArray[ValueParameterDescriptorImpl]

'asArrayType' @ [119:38] ==> public final fun Type.asArrayType(classLoader: ClassLoaderReference? = ...): ArrayType defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'jdiArrayType' @ [120:16] ==> val jdiArrayType: ArrayType defined in org.jetbrains.eval4j.jdi.JDIEval.newArray[LocalVariableDescriptor]

'newInstance' @ [120:29] ==> public abstract fun newInstance(p0: Int): (ArrayReference..ArrayReference?) defined in com.sun.jdi.ArrayType[JavaMethodDescriptor]

'size' @ [120:41] ==> value-parameter size: Int defined in org.jetbrains.eval4j.jdi.JDIEval.newArray[ValueParameterDescriptorImpl]

'asValue' @ [120:47] ==> public fun ObjectReference?.asValue(): ObjectValue defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'assert' @ [125:13] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'sort' @ [125:20] ==> public final val Type.sort: Int[MyPropertyDescriptor]

'ARRAY' @ [125:33] ==> public const final val ARRAY: Int defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'this' @ [125:63] ==> <this> defined in org.jetbrains.eval4j.jdi.JDIEval.arrayElementType[ReceiverParameterDescriptorImpl]

'getType' @ [126:25] ==> public open fun getType(p0: (String..String?)): (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaMethodDescriptor]

'descriptor' @ [126:33] ==> public final val Type.descriptor: (String..String?)[MyPropertyDescriptor]

'substring' @ [126:44] ==> @InlineOnly public inline fun String.substring(startIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'newArray' @ [130:19] ==> public open fun newArray(arrayType: Type, size: Int): Value defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'getType' @ [130:33] ==> public open fun getType(p0: (String..String?)): (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaMethodDescriptor]

'+' @ [130:41] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'elementType' @ [130:47] ==> value-parameter elementType: Type defined in org.jetbrains.eval4j.jdi.JDIEval.fillArray[ValueParameterDescriptorImpl]

'descriptor' @ [130:59] ==> public final val Type.descriptor: (String..String?)[MyPropertyDescriptor]

'size' @ [130:72] ==> value-parameter size: Int defined in org.jetbrains.eval4j.jdi.JDIEval.fillArray[ValueParameterDescriptorImpl]

'!' @ [131:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'nestedSizes' @ [131:14] ==> value-parameter nestedSizes: List<Int> defined in org.jetbrains.eval4j.jdi.JDIEval.fillArray[ValueParameterDescriptorImpl]

'isEmpty' @ [131:26] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'elementType' @ [132:37] ==> value-parameter elementType: Type defined in org.jetbrains.eval4j.jdi.JDIEval.fillArray[ValueParameterDescriptorImpl]

'arrayElementType' @ [132:49] ==> private final val Type.arrayElementType: Type defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'nestedSizes' @ [133:30] ==> value-parameter nestedSizes: List<Int> defined in org.jetbrains.eval4j.jdi.JDIEval.fillArray[ValueParameterDescriptorImpl]

'nestedSizes' @ [134:24] ==> value-parameter nestedSizes: List<Int> defined in org.jetbrains.eval4j.jdi.JDIEval.fillArray[ValueParameterDescriptorImpl]

'drop' @ [134:36] ==> public fun <T> Iterable<Int>.drop(n: Int): List<Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Int

'..' @ [135:23] ==> public final operator fun rangeTo(other: Int): IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'size' @ [135:26] ==> value-parameter size: Int defined in org.jetbrains.eval4j.jdi.JDIEval.fillArray[ValueParameterDescriptorImpl]

'setArrayElement' @ [136:17] ==> public open fun setArrayElement(array: Value, index: Value, newValue: Value): Unit defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'arr' @ [136:33] ==> val arr: Value defined in org.jetbrains.eval4j.jdi.JDIEval.fillArray[LocalVariableDescriptor]

'int' @ [136:38] ==> public fun int(v: Int): IntValue defined in org.jetbrains.eval4j in file values.kt[SimpleFunctionDescriptorImpl]

'i' @ [136:42] ==> val i: Int defined in org.jetbrains.eval4j.jdi.JDIEval.fillArray[LocalVariableDescriptor]

'fillArray' @ [136:46] ==> private final fun fillArray(elementType: Type, size: Int, nestedSizes: List<Int>): Value defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'nestedElementType' @ [136:56] ==> val nestedElementType: Type defined in org.jetbrains.eval4j.jdi.JDIEval.fillArray[LocalVariableDescriptor]

'nestedSize' @ [136:75] ==> val nestedSize: Int defined in org.jetbrains.eval4j.jdi.JDIEval.fillArray[LocalVariableDescriptor]

'tail' @ [136:87] ==> val tail: List<Int> defined in org.jetbrains.eval4j.jdi.JDIEval.fillArray[LocalVariableDescriptor]

'arr' @ [139:16] ==> val arr: Value defined in org.jetbrains.eval4j.jdi.JDIEval.fillArray[LocalVariableDescriptor]

'fillArray' @ [143:16] ==> private final fun fillArray(elementType: Type, size: Int, nestedSizes: List<Int>): Value defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'arrayType' @ [143:26] ==> value-parameter arrayType: Type defined in org.jetbrains.eval4j.jdi.JDIEval.newMultiDimensionalArray[ValueParameterDescriptorImpl]

'arrayElementType' @ [143:36] ==> private final val Type.arrayElementType: Type defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'dimensionSizes' @ [143:54] ==> value-parameter dimensionSizes: List<Int> defined in org.jetbrains.eval4j.jdi.JDIEval.newMultiDimensionalArray[ValueParameterDescriptorImpl]

'dimensionSizes' @ [143:73] ==> value-parameter dimensionSizes: List<Int> defined in org.jetbrains.eval4j.jdi.JDIEval.newMultiDimensionalArray[ValueParameterDescriptorImpl]

'drop' @ [143:88] ==> public fun <T> Iterable<Int>.drop(n: Int): List<Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Int

'jdiObj' @ [146:33] ==> public val Value.jdiObj: ObjectReference? defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[PropertyDescriptorImpl]

'checkNull' @ [146:40] ==> public fun <T : Any> ObjectReference?.checkNull(): ObjectReference defined in org.jetbrains.eval4j[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> ObjectReference

'int' @ [149:16] ==> public fun int(v: Int): IntValue defined in org.jetbrains.eval4j in file values.kt[SimpleFunctionDescriptorImpl]

'array' @ [149:20] ==> value-parameter array: Value defined in org.jetbrains.eval4j.jdi.JDIEval.getArrayLength[ValueParameterDescriptorImpl]

'array' @ [149:26] ==> private final fun Value.array(): ArrayReference defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'length' @ [149:34] ==> public abstract fun length(): Int defined in com.sun.jdi.ArrayReference[JavaMethodDescriptor]

'array' @ [154:20] ==> value-parameter array: Value defined in org.jetbrains.eval4j.jdi.JDIEval.getArrayElement[ValueParameterDescriptorImpl]

'array' @ [154:26] ==> private final fun Value.array(): ArrayReference defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'getValue' @ [154:34] ==> public abstract fun getValue(p0: Int): (Value..Value?) defined in com.sun.jdi.ArrayReference[JavaMethodDescriptor]

'index' @ [154:43] ==> value-parameter index: Value defined in org.jetbrains.eval4j.jdi.JDIEval.getArrayElement[ValueParameterDescriptorImpl]

'int' @ [154:49] ==> public val Value.int: Int defined in org.jetbrains.eval4j in file values.kt[PropertyDescriptorImpl]

'asValue' @ [154:54] ==> public fun Value?.asValue(): Value defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'throwEvalException' @ [157:13] ==> public fun throwEvalException(e: Throwable): Nothing defined in org.jetbrains.eval4j in file values.kt[SimpleFunctionDescriptorImpl]

'ArrayIndexOutOfBoundsException' @ [157:32] ==> public constructor ArrayIndexOutOfBoundsException(p0: (String..String?)) defined in java.lang.ArrayIndexOutOfBoundsException[JavaClassConstructorDescriptor]

'e' @ [157:63] ==> val e: IndexOutOfBoundsException /* = IndexOutOfBoundsException */ defined in org.jetbrains.eval4j.jdi.JDIEval.getArrayElement[LocalVariableDescriptor]

'message' @ [157:65] ==> public open val message: String? defined in java.lang.IndexOutOfBoundsException[DeserializedPropertyDescriptor]

'array' @ [163:20] ==> value-parameter array: Value defined in org.jetbrains.eval4j.jdi.JDIEval.setArrayElement[ValueParameterDescriptorImpl]

'array' @ [163:26] ==> private final fun Value.array(): ArrayReference defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'setValue' @ [163:34] ==> public abstract fun setValue(p0: Int, p1: (Value..Value?)): Unit defined in com.sun.jdi.ArrayReference[JavaMethodDescriptor]

'index' @ [163:43] ==> value-parameter index: Value defined in org.jetbrains.eval4j.jdi.JDIEval.setArrayElement[ValueParameterDescriptorImpl]

'int' @ [163:49] ==> public val Value.int: Int defined in org.jetbrains.eval4j in file values.kt[PropertyDescriptorImpl]

'newValue' @ [163:54] ==> value-parameter newValue: Value defined in org.jetbrains.eval4j.jdi.JDIEval.setArrayElement[ValueParameterDescriptorImpl]

'asJdiValue' @ [163:63] ==> public fun Value.asJdiValue(vm: VirtualMachine, expectedType: Type): Value? defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'vm' @ [163:74] ==> private final val vm: VirtualMachine defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'array' @ [163:78] ==> value-parameter array: Value defined in org.jetbrains.eval4j.jdi.JDIEval.setArrayElement[ValueParameterDescriptorImpl]

'asmType' @ [163:84] ==> public abstract val asmType: Type defined in org.jetbrains.eval4j.Value[PropertyDescriptorImpl]

'arrayElementType' @ [163:92] ==> private final val Type.arrayElementType: Type defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'throwEvalException' @ [166:13] ==> public fun throwEvalException(e: Throwable): Nothing defined in org.jetbrains.eval4j in file values.kt[SimpleFunctionDescriptorImpl]

'ArrayIndexOutOfBoundsException' @ [166:32] ==> public constructor ArrayIndexOutOfBoundsException(p0: (String..String?)) defined in java.lang.ArrayIndexOutOfBoundsException[JavaClassConstructorDescriptor]

'e' @ [166:63] ==> val e: IndexOutOfBoundsException /* = IndexOutOfBoundsException */ defined in org.jetbrains.eval4j.jdi.JDIEval.setArrayElement[LocalVariableDescriptor]

'message' @ [166:65] ==> public open val message: String? defined in java.lang.IndexOutOfBoundsException[DeserializedPropertyDescriptor]

'fieldDesc' @ [171:22] ==> value-parameter fieldDesc: FieldDescription defined in org.jetbrains.eval4j.jdi.JDIEval.findField[ValueParameterDescriptorImpl]

'ownerType' @ [171:32] ==> public val MemberDescription.ownerType: Type defined in org.jetbrains.eval4j in file members.kt[PropertyDescriptorImpl]

'asReferenceType' @ [171:42] ==> public final fun Type.asReferenceType(classLoader: ClassLoaderReference? = ...): ReferenceType defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'_class' @ [172:21] ==> val _class: ReferenceType defined in org.jetbrains.eval4j.jdi.JDIEval.findField[LocalVariableDescriptor]

'fieldByName' @ [172:28] ==> public abstract fun fieldByName(p0: (String..String?)): (Field..Field?) defined in com.sun.jdi.ReferenceType[JavaMethodDescriptor]

'fieldDesc' @ [172:40] ==> value-parameter fieldDesc: FieldDescription defined in org.jetbrains.eval4j.jdi.JDIEval.findField[ValueParameterDescriptorImpl]

'name' @ [172:50] ==> public final val name: String defined in org.jetbrains.eval4j.FieldDescription[PropertyDescriptorImpl]

'field' @ [173:13] ==> val field: (Field..Field?) defined in org.jetbrains.eval4j.jdi.JDIEval.findField[LocalVariableDescriptor]

'throwBrokenCodeException' @ [174:13] ==> public fun throwBrokenCodeException(e: Throwable): Nothing defined in org.jetbrains.eval4j in file values.kt[SimpleFunctionDescriptorImpl]

'NoSuchFieldError' @ [174:38] ==> public constructor NoSuchFieldError(p0: (String..String?)) defined in java.lang.NoSuchFieldError[JavaClassConstructorDescriptor]

'fieldDesc' @ [174:74] ==> value-parameter fieldDesc: FieldDescription defined in org.jetbrains.eval4j.jdi.JDIEval.findField[ValueParameterDescriptorImpl]

'field' @ [176:16] ==> val field: (Field..Field?) defined in org.jetbrains.eval4j.jdi.JDIEval.findField[LocalVariableDescriptor]

'findField' @ [180:21] ==> private final fun findField(fieldDesc: FieldDescription): Field defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'fieldDesc' @ [180:31] ==> value-parameter fieldDesc: FieldDescription defined in org.jetbrains.eval4j.jdi.JDIEval.findStaticField[ValueParameterDescriptorImpl]

'!' @ [181:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'field' @ [181:14] ==> val field: Field defined in org.jetbrains.eval4j.jdi.JDIEval.findStaticField[LocalVariableDescriptor]

'isStatic' @ [181:20] ==> public final val Field.isStatic: Boolean[MyPropertyDescriptor]

'throwBrokenCodeException' @ [182:13] ==> public fun throwBrokenCodeException(e: Throwable): Nothing defined in org.jetbrains.eval4j in file values.kt[SimpleFunctionDescriptorImpl]

'NoSuchFieldError' @ [182:38] ==> public constructor NoSuchFieldError(p0: (String..String?)) defined in java.lang.NoSuchFieldError[JavaClassConstructorDescriptor]

'fieldDesc' @ [182:78] ==> value-parameter fieldDesc: FieldDescription defined in org.jetbrains.eval4j.jdi.JDIEval.findStaticField[ValueParameterDescriptorImpl]

'field' @ [184:16] ==> val field: Field defined in org.jetbrains.eval4j.jdi.JDIEval.findStaticField[LocalVariableDescriptor]

'findStaticField' @ [188:21] ==> private final fun findStaticField(fieldDesc: FieldDescription): Field defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'fieldDesc' @ [188:37] ==> value-parameter fieldDesc: FieldDescription defined in org.jetbrains.eval4j.jdi.JDIEval.getStaticField[ValueParameterDescriptorImpl]

'mayThrow' @ [189:16] ==> private fun <T> mayThrow(f: () -> (Value..Value?)): JdiOperationResult<(Value..Value?)> defined in org.jetbrains.eval4j.jdi[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> (com.sun.jdi.Value..com.sun.jdi.Value?)

'field' @ [189:27] ==> val field: Field defined in org.jetbrains.eval4j.jdi.JDIEval.getStaticField[LocalVariableDescriptor]

'declaringType' @ [189:33] ==> public abstract fun declaringType(): (ReferenceType..ReferenceType?) defined in com.sun.jdi.Field[JavaMethodDescriptor]

'getValue' @ [189:49] ==> public abstract fun getValue(p0: (Field..Field?)): (Value..Value?) defined in com.sun.jdi.ReferenceType[JavaMethodDescriptor]

'field' @ [189:58] ==> val field: Field defined in org.jetbrains.eval4j.jdi.JDIEval.getStaticField[LocalVariableDescriptor]

'ifFail' @ [189:67] ==> private fun <T> JdiOperationResult<(Value..Value?)>.ifFail(member: TypeComponent, thisObj: ObjectReference? = ...): (Value..Value?) defined in org.jetbrains.eval4j.jdi[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> (com.sun.jdi.Value..com.sun.jdi.Value?)

'field' @ [189:74] ==> val field: Field defined in org.jetbrains.eval4j.jdi.JDIEval.getStaticField[LocalVariableDescriptor]

'asValue' @ [189:81] ==> public fun Value?.asValue(): Value defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'findStaticField' @ [193:21] ==> private final fun findStaticField(fieldDesc: FieldDescription): Field defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'fieldDesc' @ [193:37] ==> value-parameter fieldDesc: FieldDescription defined in org.jetbrains.eval4j.jdi.JDIEval.setStaticField[ValueParameterDescriptorImpl]

'field' @ [195:13] ==> val field: Field defined in org.jetbrains.eval4j.jdi.JDIEval.setStaticField[LocalVariableDescriptor]

'isFinal' @ [195:19] ==> public final val Field.isFinal: Boolean[MyPropertyDescriptor]

'throwBrokenCodeException' @ [196:13] ==> public fun throwBrokenCodeException(e: Throwable): Nothing defined in org.jetbrains.eval4j in file values.kt[SimpleFunctionDescriptorImpl]

'NoSuchFieldError' @ [196:38] ==> public constructor NoSuchFieldError(p0: (String..String?)) defined in java.lang.NoSuchFieldError[JavaClassConstructorDescriptor]

'field' @ [196:85] ==> val field: Field defined in org.jetbrains.eval4j.jdi.JDIEval.setStaticField[LocalVariableDescriptor]

'field' @ [199:22] ==> val field: Field defined in org.jetbrains.eval4j.jdi.JDIEval.setStaticField[LocalVariableDescriptor]

'declaringType' @ [199:28] ==> public abstract fun declaringType(): (ReferenceType..ReferenceType?) defined in com.sun.jdi.Field[JavaMethodDescriptor]

'_class' @ [200:13] ==> val _class: (ReferenceType..ReferenceType?) defined in org.jetbrains.eval4j.jdi.JDIEval.setStaticField[LocalVariableDescriptor]

'throwBrokenCodeException' @ [201:13] ==> public fun throwBrokenCodeException(e: Throwable): Nothing defined in org.jetbrains.eval4j in file values.kt[SimpleFunctionDescriptorImpl]

'NoSuchFieldError' @ [201:38] ==> public constructor NoSuchFieldError(p0: (String..String?)) defined in java.lang.NoSuchFieldError[JavaClassConstructorDescriptor]

'field' @ [201:87] ==> val field: Field defined in org.jetbrains.eval4j.jdi.JDIEval.setStaticField[LocalVariableDescriptor]

'newValue' @ [204:24] ==> value-parameter newValue: Value defined in org.jetbrains.eval4j.jdi.JDIEval.setStaticField[ValueParameterDescriptorImpl]

'asJdiValue' @ [204:33] ==> public fun Value.asJdiValue(vm: VirtualMachine, expectedType: Type): Value? defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'vm' @ [204:44] ==> private final val vm: VirtualMachine defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'field' @ [204:48] ==> val field: Field defined in org.jetbrains.eval4j.jdi.JDIEval.setStaticField[LocalVariableDescriptor]

'type' @ [204:54] ==> public abstract fun type(): (Type..Type?) defined in com.sun.jdi.Field[JavaMethodDescriptor]

'asType' @ [204:61] ==> public fun Type.asType(): Type defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'mayThrow' @ [205:9] ==> private fun <T> mayThrow(f: () -> Unit): JdiOperationResult<Unit> defined in org.jetbrains.eval4j.jdi[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> Unit

'_class' @ [205:20] ==> val _class: (ReferenceType..ReferenceType?) defined in org.jetbrains.eval4j.jdi.JDIEval.setStaticField[LocalVariableDescriptor]

'setValue' @ [205:27] ==> public abstract fun setValue(p0: (Field..Field?), p1: (Value..Value?)): Unit defined in com.sun.jdi.ClassType[JavaMethodDescriptor]

'field' @ [205:36] ==> val field: Field defined in org.jetbrains.eval4j.jdi.JDIEval.setStaticField[LocalVariableDescriptor]

'jdiValue' @ [205:43] ==> val jdiValue: Value? defined in org.jetbrains.eval4j.jdi.JDIEval.setStaticField[LocalVariableDescriptor]

'ifFail' @ [205:55] ==> private fun <T> JdiOperationResult<Unit>.ifFail(member: TypeComponent, thisObj: ObjectReference? = ...): Unit defined in org.jetbrains.eval4j.jdi[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> Unit

'field' @ [205:62] ==> val field: Field defined in org.jetbrains.eval4j.jdi.JDIEval.setStaticField[LocalVariableDescriptor]

'methodDesc' @ [208:83] ==> value-parameter methodDesc: MethodDescription defined in org.jetbrains.eval4j.jdi.JDIEval.findMethod[ValueParameterDescriptorImpl]

'ownerType' @ [208:94] ==> public val MemberDescription.ownerType: Type defined in org.jetbrains.eval4j in file members.kt[PropertyDescriptorImpl]

'asReferenceType' @ [208:104] ==> public final fun Type.asReferenceType(classLoader: ClassLoaderReference? = ...): ReferenceType defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'methodDesc' @ [209:26] ==> value-parameter methodDesc: MethodDescription defined in org.jetbrains.eval4j.jdi.JDIEval.findMethod[ValueParameterDescriptorImpl]

'name' @ [209:37] ==> public final val name: String defined in org.jetbrains.eval4j.MethodDescription[PropertyDescriptorImpl]

'when (_class) {
            is ClassType ->
                _class.concreteMethodByName(methodName, methodDesc.desc)
            else ->
                _class.methodsByName(methodName, methodDesc.desc).firstOrNull()
        }' @ [210:22] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Method?, entry1: Method?): Method?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Method?

'_class' @ [210:28] ==> value-parameter _class: ReferenceType = ... defined in org.jetbrains.eval4j.jdi.JDIEval.findMethod[ValueParameterDescriptorImpl]

'_class' @ [212:17] ==> value-parameter _class: ReferenceType = ... defined in org.jetbrains.eval4j.jdi.JDIEval.findMethod[ValueParameterDescriptorImpl]

'concreteMethodByName' @ [212:24] ==> public abstract fun concreteMethodByName(p0: (String..String?), p1: (String..String?)): (Method..Method?) defined in com.sun.jdi.ClassType[JavaMethodDescriptor]

'methodName' @ [212:45] ==> val methodName: String defined in org.jetbrains.eval4j.jdi.JDIEval.findMethod[LocalVariableDescriptor]

'methodDesc' @ [212:57] ==> value-parameter methodDesc: MethodDescription defined in org.jetbrains.eval4j.jdi.JDIEval.findMethod[ValueParameterDescriptorImpl]

'desc' @ [212:68] ==> public final val desc: String defined in org.jetbrains.eval4j.MethodDescription[PropertyDescriptorImpl]

'_class' @ [214:17] ==> value-parameter _class: ReferenceType = ... defined in org.jetbrains.eval4j.jdi.JDIEval.findMethod[ValueParameterDescriptorImpl]

'methodsByName' @ [214:24] ==> public abstract fun methodsByName(p0: (String..String?), p1: (String..String?)): (MutableList<(Method..Method?)>..List<(Method..Method?)>?) defined in com.sun.jdi.ReferenceType[JavaMethodDescriptor]

'methodName' @ [214:38] ==> val methodName: String defined in org.jetbrains.eval4j.jdi.JDIEval.findMethod[LocalVariableDescriptor]

'methodDesc' @ [214:50] ==> value-parameter methodDesc: MethodDescription defined in org.jetbrains.eval4j.jdi.JDIEval.findMethod[ValueParameterDescriptorImpl]

'desc' @ [214:61] ==> public final val desc: String defined in org.jetbrains.eval4j.MethodDescription[PropertyDescriptorImpl]

'firstOrNull' @ [214:67] ==> public fun <T> List<(Method..Method?)>.firstOrNull(): Method? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Method..com.sun.jdi.Method?)

'method' @ [217:13] ==> val method: Method? defined in org.jetbrains.eval4j.jdi.JDIEval.findMethod[LocalVariableDescriptor]

'method' @ [218:20] ==> val method: Method? defined in org.jetbrains.eval4j.jdi.JDIEval.findMethod[LocalVariableDescriptor]

'internalNameWithoutModuleSuffix' @ [222:41] ==> @Nullable public open fun internalNameWithoutModuleSuffix(@NotNull p0: String): String? defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper.InternalNameMapper[JavaMethodDescriptor]

'methodName' @ [222:73] ==> val methodName: String defined in org.jetbrains.eval4j.jdi.JDIEval.findMethod[LocalVariableDescriptor]

'internalNameWithoutSuffix' @ [223:13] ==> val internalNameWithoutSuffix: String? defined in org.jetbrains.eval4j.jdi.JDIEval.findMethod[LocalVariableDescriptor]

'_class' @ [224:35] ==> value-parameter _class: ReferenceType = ... defined in org.jetbrains.eval4j.jdi.JDIEval.findMethod[ValueParameterDescriptorImpl]

'visibleMethods' @ [224:42] ==> public abstract fun visibleMethods(): (MutableList<(Method..Method?)>..List<(Method..Method?)>?) defined in com.sun.jdi.ReferenceType[JavaMethodDescriptor]

'filter' @ [224:59] ==> public inline fun <T> Iterable<(Method..Method?)>.filter(predicate: ((Method..Method?)) -> Boolean): List<(Method..Method?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Method..com.sun.jdi.Method?)

'it' @ [225:28] ==> value-parameter it: (Method..Method?) defined in org.jetbrains.eval4j.jdi.JDIEval.findMethod.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [225:31] ==> public abstract fun name(): (String..String?) defined in com.sun.jdi.Method[JavaMethodDescriptor]

'name' @ [226:17] ==> val name: (String..String?) defined in org.jetbrains.eval4j.jdi.JDIEval.findMethod.<anonymous>[LocalVariableDescriptor]

'startsWith' @ [226:22] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'internalNameWithoutSuffix' @ [226:33] ==> val internalNameWithoutSuffix: String? defined in org.jetbrains.eval4j.jdi.JDIEval.findMethod[LocalVariableDescriptor]

'canBeMangledInternalName' @ [226:63] ==> public open fun canBeMangledInternalName(@NotNull p0: String): Boolean defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper.InternalNameMapper[JavaMethodDescriptor]

'name' @ [226:88] ==> val name: (String..String?) defined in org.jetbrains.eval4j.jdi.JDIEval.findMethod.<anonymous>[LocalVariableDescriptor]

'it' @ [226:97] ==> value-parameter it: (Method..Method?) defined in org.jetbrains.eval4j.jdi.JDIEval.findMethod.<anonymous>[ValueParameterDescriptorImpl]

'signature' @ [226:100] ==> public abstract fun signature(): (String..String?) defined in com.sun.jdi.Method[JavaMethodDescriptor]

'methodDesc' @ [226:115] ==> value-parameter methodDesc: MethodDescription defined in org.jetbrains.eval4j.jdi.JDIEval.findMethod[ValueParameterDescriptorImpl]

'desc' @ [226:126] ==> public final val desc: String defined in org.jetbrains.eval4j.MethodDescription[PropertyDescriptorImpl]

'!' @ [229:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'internalMethods' @ [229:18] ==> val internalMethods: List<(Method..Method?)> defined in org.jetbrains.eval4j.jdi.JDIEval.findMethod[LocalVariableDescriptor]

'isEmpty' @ [229:34] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'internalMethods' @ [230:24] ==> val internalMethods: List<(Method..Method?)> defined in org.jetbrains.eval4j.jdi.JDIEval.findMethod[LocalVariableDescriptor]

'singleOrNull' @ [230:40] ==> public fun <T> List<(Method..Method?)>.singleOrNull(): Method? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Method..com.sun.jdi.Method?)

'throwBrokenCodeException' @ [231:24] ==> public fun throwBrokenCodeException(e: Throwable): Nothing defined in org.jetbrains.eval4j in file values.kt[SimpleFunctionDescriptorImpl]

'IllegalArgumentException' @ [231:49] ==> public final fun <init>(p0: (String..String?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'methodDesc' @ [231:111] ==> value-parameter methodDesc: MethodDescription defined in org.jetbrains.eval4j.jdi.JDIEval.findMethod[ValueParameterDescriptorImpl]

'throwBrokenCodeException' @ [235:9] ==> public fun throwBrokenCodeException(e: Throwable): Nothing defined in org.jetbrains.eval4j in file values.kt[SimpleFunctionDescriptorImpl]

'NoSuchMethodError' @ [235:34] ==> public constructor NoSuchMethodError(p0: (String..String?)) defined in java.lang.NoSuchMethodError[JavaClassConstructorDescriptor]

'methodDesc' @ [235:72] ==> value-parameter methodDesc: MethodDescription defined in org.jetbrains.eval4j.jdi.JDIEval.findMethod[ValueParameterDescriptorImpl]

'findMethod' @ [239:22] ==> private final fun findMethod(methodDesc: MethodDescription, _class: ReferenceType = ...): Method defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'methodDesc' @ [239:33] ==> value-parameter methodDesc: MethodDescription defined in org.jetbrains.eval4j.jdi.JDIEval.invokeStaticMethod[ValueParameterDescriptorImpl]

'!' @ [240:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'method' @ [240:14] ==> val method: Method defined in org.jetbrains.eval4j.jdi.JDIEval.invokeStaticMethod[LocalVariableDescriptor]

'isStatic' @ [240:21] ==> public final val Method.isStatic: Boolean[MyPropertyDescriptor]

'throwBrokenCodeException' @ [241:13] ==> public fun throwBrokenCodeException(e: Throwable): Nothing defined in org.jetbrains.eval4j in file values.kt[SimpleFunctionDescriptorImpl]

'NoSuchMethodError' @ [241:38] ==> public constructor NoSuchMethodError(p0: (String..String?)) defined in java.lang.NoSuchMethodError[JavaClassConstructorDescriptor]

'methodDesc' @ [241:80] ==> value-parameter methodDesc: MethodDescription defined in org.jetbrains.eval4j.jdi.JDIEval.invokeStaticMethod[ValueParameterDescriptorImpl]

'method' @ [243:22] ==> val method: Method defined in org.jetbrains.eval4j.jdi.JDIEval.invokeStaticMethod[LocalVariableDescriptor]

'declaringType' @ [243:29] ==> public abstract fun declaringType(): (ReferenceType..ReferenceType?) defined in com.sun.jdi.Method[JavaMethodDescriptor]

'_class' @ [244:13] ==> val _class: (ReferenceType..ReferenceType?) defined in org.jetbrains.eval4j.jdi.JDIEval.invokeStaticMethod[LocalVariableDescriptor]

'throwBrokenCodeException' @ [244:35] ==> public fun throwBrokenCodeException(e: Throwable): Nothing defined in org.jetbrains.eval4j in file values.kt[SimpleFunctionDescriptorImpl]

'NoSuchMethodError' @ [244:60] ==> public constructor NoSuchMethodError(p0: (String..String?)) defined in java.lang.NoSuchMethodError[JavaClassConstructorDescriptor]

'method' @ [244:115] ==> val method: Method defined in org.jetbrains.eval4j.jdi.JDIEval.invokeStaticMethod[LocalVariableDescriptor]

'mapArguments' @ [246:20] ==> private final fun mapArguments(arguments: List<Value>, expecetedTypes: List<Type>): List<Value?> defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'arguments' @ [246:33] ==> value-parameter arguments: List<Value> defined in org.jetbrains.eval4j.jdi.JDIEval.invokeStaticMethod[ValueParameterDescriptorImpl]

'method' @ [246:44] ==> val method: Method defined in org.jetbrains.eval4j.jdi.JDIEval.invokeStaticMethod[LocalVariableDescriptor]

'safeArgumentTypes' @ [246:51] ==> private final fun Method.safeArgumentTypes(): List<Type> defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'shouldInvokeMethodWithReflection' @ [248:13] ==> private final fun shouldInvokeMethodWithReflection(method: Method, args: List<Value?>): Boolean defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'method' @ [248:46] ==> val method: Method defined in org.jetbrains.eval4j.jdi.JDIEval.invokeStaticMethod[LocalVariableDescriptor]

'args' @ [248:54] ==> val args: List<Value?> defined in org.jetbrains.eval4j.jdi.JDIEval.invokeStaticMethod[LocalVariableDescriptor]

'invokeMethodWithReflection' @ [249:20] ==> private final fun invokeMethodWithReflection(ownerType: Type, instance: Value, args: List<Value?>, methodDesc: MethodDescription): Value defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'_class' @ [249:47] ==> val _class: (ReferenceType..ReferenceType?) defined in org.jetbrains.eval4j.jdi.JDIEval.invokeStaticMethod[LocalVariableDescriptor]

'asType' @ [249:54] ==> public fun Type.asType(): Type defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'NULL_VALUE' @ [249:64] ==> public val NULL_VALUE: ObjectValue defined in org.jetbrains.eval4j in file values.kt[PropertyDescriptorImpl]

'args' @ [249:76] ==> val args: List<Value?> defined in org.jetbrains.eval4j.jdi.JDIEval.invokeStaticMethod[LocalVariableDescriptor]

'methodDesc' @ [249:82] ==> value-parameter methodDesc: MethodDescription defined in org.jetbrains.eval4j.jdi.JDIEval.invokeStaticMethod[ValueParameterDescriptorImpl]

'args' @ [252:9] ==> val args: List<Value?> defined in org.jetbrains.eval4j.jdi.JDIEval.invokeStaticMethod[LocalVariableDescriptor]

'disableCollection' @ [252:14] ==> private final fun List<Value?>.disableCollection(): Unit defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'mayThrow' @ [253:22] ==> private fun <T> mayThrow(f: () -> (Value..Value?)): JdiOperationResult<(Value..Value?)> defined in org.jetbrains.eval4j.jdi[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> (com.sun.jdi.Value..com.sun.jdi.Value?)

'_class' @ [253:33] ==> val _class: (ReferenceType..ReferenceType?) defined in org.jetbrains.eval4j.jdi.JDIEval.invokeStaticMethod[LocalVariableDescriptor]

'invokeMethod' @ [253:40] ==> public abstract fun invokeMethod(p0: (ThreadReference..ThreadReference?), p1: (Method..Method?), p2: (MutableList<out (Value..Value?)>..List<(Value..Value?)>?), p3: Int): (Value..Value?) defined in com.sun.jdi.ClassType[JavaMethodDescriptor]

'thread' @ [253:53] ==> private final val thread: ThreadReference defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'method' @ [253:61] ==> val method: Method defined in org.jetbrains.eval4j.jdi.JDIEval.invokeStaticMethod[LocalVariableDescriptor]

'args' @ [253:69] ==> val args: List<Value?> defined in org.jetbrains.eval4j.jdi.JDIEval.invokeStaticMethod[LocalVariableDescriptor]

'invokePolicy' @ [253:75] ==> private final val invokePolicy: Int defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'ifFail' @ [253:91] ==> private fun <T> JdiOperationResult<(Value..Value?)>.ifFail(member: TypeComponent, thisObj: ObjectReference? = ...): (Value..Value?) defined in org.jetbrains.eval4j.jdi[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> (com.sun.jdi.Value..com.sun.jdi.Value?)

'method' @ [253:98] ==> val method: Method defined in org.jetbrains.eval4j.jdi.JDIEval.invokeStaticMethod[LocalVariableDescriptor]

'args' @ [254:9] ==> val args: List<Value?> defined in org.jetbrains.eval4j.jdi.JDIEval.invokeStaticMethod[LocalVariableDescriptor]

'enableCollection' @ [254:14] ==> private final fun List<Value?>.enableCollection(): Unit defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'result' @ [255:16] ==> val result: (Value..Value?) defined in org.jetbrains.eval4j.jdi.JDIEval.invokeStaticMethod[LocalVariableDescriptor]

'asValue' @ [255:23] ==> public fun Value?.asValue(): Value defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'findField' @ [259:21] ==> private final fun findField(fieldDesc: FieldDescription): Field defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'fieldDesc' @ [259:31] ==> value-parameter fieldDesc: FieldDescription defined in org.jetbrains.eval4j.jdi.JDIEval.getField[ValueParameterDescriptorImpl]

'instance' @ [260:19] ==> value-parameter instance: Value defined in org.jetbrains.eval4j.jdi.JDIEval.getField[ValueParameterDescriptorImpl]

'jdiObj' @ [260:28] ==> public val Value.jdiObj: ObjectReference? defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[PropertyDescriptorImpl]

'checkNull' @ [260:35] ==> public fun <T : Any> ObjectReference?.checkNull(): ObjectReference defined in org.jetbrains.eval4j[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> ObjectReference

'mayThrow' @ [262:16] ==> private fun <T> mayThrow(f: () -> (Value..Value?)): JdiOperationResult<(Value..Value?)> defined in org.jetbrains.eval4j.jdi[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> (com.sun.jdi.Value..com.sun.jdi.Value?)

'obj' @ [262:27] ==> val obj: ObjectReference defined in org.jetbrains.eval4j.jdi.JDIEval.getField[LocalVariableDescriptor]

'getValue' @ [262:31] ==> public abstract fun getValue(p0: (Field..Field?)): (Value..Value?) defined in com.sun.jdi.ObjectReference[JavaMethodDescriptor]

'field' @ [262:40] ==> val field: Field defined in org.jetbrains.eval4j.jdi.JDIEval.getField[LocalVariableDescriptor]

'ifFail' @ [262:49] ==> private fun <T> JdiOperationResult<(Value..Value?)>.ifFail(member: TypeComponent, thisObj: ObjectReference? = ...): (Value..Value?) defined in org.jetbrains.eval4j.jdi[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> (com.sun.jdi.Value..com.sun.jdi.Value?)

'field' @ [262:56] ==> val field: Field defined in org.jetbrains.eval4j.jdi.JDIEval.getField[LocalVariableDescriptor]

'obj' @ [262:63] ==> val obj: ObjectReference defined in org.jetbrains.eval4j.jdi.JDIEval.getField[LocalVariableDescriptor]

'asValue' @ [262:68] ==> public fun Value?.asValue(): Value defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'findField' @ [266:21] ==> private final fun findField(fieldDesc: FieldDescription): Field defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'fieldDesc' @ [266:31] ==> value-parameter fieldDesc: FieldDescription defined in org.jetbrains.eval4j.jdi.JDIEval.setField[ValueParameterDescriptorImpl]

'instance' @ [267:19] ==> value-parameter instance: Value defined in org.jetbrains.eval4j.jdi.JDIEval.setField[ValueParameterDescriptorImpl]

'jdiObj' @ [267:28] ==> public val Value.jdiObj: ObjectReference? defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[PropertyDescriptorImpl]

'checkNull' @ [267:35] ==> public fun <T : Any> ObjectReference?.checkNull(): ObjectReference defined in org.jetbrains.eval4j[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> ObjectReference

'newValue' @ [269:24] ==> value-parameter newValue: Value defined in org.jetbrains.eval4j.jdi.JDIEval.setField[ValueParameterDescriptorImpl]

'asJdiValue' @ [269:33] ==> public fun Value.asJdiValue(vm: VirtualMachine, expectedType: Type): Value? defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'vm' @ [269:44] ==> private final val vm: VirtualMachine defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'field' @ [269:48] ==> val field: Field defined in org.jetbrains.eval4j.jdi.JDIEval.setField[LocalVariableDescriptor]

'type' @ [269:54] ==> public abstract fun type(): (Type..Type?) defined in com.sun.jdi.Field[JavaMethodDescriptor]

'asType' @ [269:61] ==> public fun Type.asType(): Type defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'mayThrow' @ [270:9] ==> private fun <T> mayThrow(f: () -> Unit): JdiOperationResult<Unit> defined in org.jetbrains.eval4j.jdi[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> Unit

'obj' @ [270:20] ==> val obj: ObjectReference defined in org.jetbrains.eval4j.jdi.JDIEval.setField[LocalVariableDescriptor]

'setValue' @ [270:24] ==> public abstract fun setValue(p0: (Field..Field?), p1: (Value..Value?)): Unit defined in com.sun.jdi.ObjectReference[JavaMethodDescriptor]

'field' @ [270:33] ==> val field: Field defined in org.jetbrains.eval4j.jdi.JDIEval.setField[LocalVariableDescriptor]

'jdiValue' @ [270:40] ==> val jdiValue: Value? defined in org.jetbrains.eval4j.jdi.JDIEval.setField[LocalVariableDescriptor]

'when (type) {
            Type.INT_TYPE -> MethodDescription("java/lang/Integer", "intValue", "()I", false)
            Type.BOOLEAN_TYPE -> MethodDescription("java/lang/Boolean", "booleanValue", "()Z", false)
            Type.CHAR_TYPE -> MethodDescription("java/lang/Character", "charValue", "()C", false)
            Type.SHORT_TYPE -> MethodDescription("java/lang/Character", "shortValue", "()S", false)
            Type.LONG_TYPE -> MethodDescription("java/lang/Long", "longValue", "()J", false)
            Type.BYTE_TYPE -> MethodDescription("java/lang/Byte", "byteValue", "()B", false)
            Type.FLOAT_TYPE -> MethodDescription("java/lang/Float", "floatValue", "()F", false)
            Type.DOUBLE_TYPE -> MethodDescription("java/lang/Double", "doubleValue", "()D", false)
            else -> throw UnsupportedOperationException("Couldn't unbox non primitive type ${type.internalName}")
        }' @ [274:22] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: MethodDescription, entry1: MethodDescription, entry2: MethodDescription, entry3: MethodDescription, entry4: MethodDescription, entry5: MethodDescription, entry6: MethodDescription, entry7: MethodDescription, entry8: MethodDescription): MethodDescription[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> MethodDescription

'type' @ [274:28] ==> value-parameter type: Type defined in org.jetbrains.eval4j.jdi.JDIEval.unboxType[ValueParameterDescriptorImpl]

'INT_TYPE' @ [275:18] ==> public final val INT_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'MethodDescription' @ [275:30] ==> public constructor MethodDescription(ownerInternalName: String, name: String, desc: String, isStatic: Boolean) defined in org.jetbrains.eval4j.MethodDescription[ClassConstructorDescriptorImpl]

'BOOLEAN_TYPE' @ [276:18] ==> public final val BOOLEAN_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'MethodDescription' @ [276:34] ==> public constructor MethodDescription(ownerInternalName: String, name: String, desc: String, isStatic: Boolean) defined in org.jetbrains.eval4j.MethodDescription[ClassConstructorDescriptorImpl]

'CHAR_TYPE' @ [277:18] ==> public final val CHAR_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'MethodDescription' @ [277:31] ==> public constructor MethodDescription(ownerInternalName: String, name: String, desc: String, isStatic: Boolean) defined in org.jetbrains.eval4j.MethodDescription[ClassConstructorDescriptorImpl]

'SHORT_TYPE' @ [278:18] ==> public final val SHORT_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'MethodDescription' @ [278:32] ==> public constructor MethodDescription(ownerInternalName: String, name: String, desc: String, isStatic: Boolean) defined in org.jetbrains.eval4j.MethodDescription[ClassConstructorDescriptorImpl]

'LONG_TYPE' @ [279:18] ==> public final val LONG_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'MethodDescription' @ [279:31] ==> public constructor MethodDescription(ownerInternalName: String, name: String, desc: String, isStatic: Boolean) defined in org.jetbrains.eval4j.MethodDescription[ClassConstructorDescriptorImpl]

'BYTE_TYPE' @ [280:18] ==> public final val BYTE_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'MethodDescription' @ [280:31] ==> public constructor MethodDescription(ownerInternalName: String, name: String, desc: String, isStatic: Boolean) defined in org.jetbrains.eval4j.MethodDescription[ClassConstructorDescriptorImpl]

'FLOAT_TYPE' @ [281:18] ==> public final val FLOAT_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'MethodDescription' @ [281:32] ==> public constructor MethodDescription(ownerInternalName: String, name: String, desc: String, isStatic: Boolean) defined in org.jetbrains.eval4j.MethodDescription[ClassConstructorDescriptorImpl]

'DOUBLE_TYPE' @ [282:18] ==> public final val DOUBLE_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'MethodDescription' @ [282:33] ==> public constructor MethodDescription(ownerInternalName: String, name: String, desc: String, isStatic: Boolean) defined in org.jetbrains.eval4j.MethodDescription[ClassConstructorDescriptorImpl]

'UnsupportedOperationException' @ [283:27] ==> public final fun <init>(p0: (String..String?)): UnsupportedOperationException /* = UnsupportedOperationException */ defined in kotlin.UnsupportedOperationException[TypeAliasConstructorDescriptorImpl]

'type' @ [283:94] ==> value-parameter type: Type defined in org.jetbrains.eval4j.jdi.JDIEval.unboxType[ValueParameterDescriptorImpl]

'internalName' @ [283:99] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'invokeMethod' @ [285:16] ==> public open fun invokeMethod(instance: Value, methodDesc: MethodDescription, arguments: List<Value>, invokespecial: Boolean): Value defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'boxedValue' @ [285:29] ==> value-parameter boxedValue: Value defined in org.jetbrains.eval4j.jdi.JDIEval.unboxType[ValueParameterDescriptorImpl]

'method' @ [285:41] ==> val method: MethodDescription defined in org.jetbrains.eval4j.jdi.JDIEval.unboxType[LocalVariableDescriptor]

'listOf' @ [285:49] ==> @InlineOnly public inline fun <T> listOf(): List<Value> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Value

'when (value.asmType) {
            Type.INT_TYPE -> MethodDescription("java/lang/Integer", "valueOf", "(I)Ljava/lang/Integer;", false)
            Type.BYTE_TYPE -> MethodDescription("java/lang/Byte", "valueOf", "(B)Ljava/lang/Byte;", false)
            Type.SHORT_TYPE -> MethodDescription("java/lang/Short", "valueOf", "(S)Ljava/lang/Short;", false)
            Type.LONG_TYPE -> MethodDescription("java/lang/Long", "valueOf", "(J)Ljava/lang/Long;", false)
            Type.BOOLEAN_TYPE -> MethodDescription("java/lang/Boolean", "valueOf", "(Z)Ljava/lang/Boolean;", false)
            Type.CHAR_TYPE -> MethodDescription("java/lang/Character", "valueOf", "(C)Ljava/lang/Character;", false)
            Type.FLOAT_TYPE -> MethodDescription("java/lang/Float", "valueOf", "(F)Ljava/lang/Float;", false)
            Type.DOUBLE_TYPE -> MethodDescription("java/lang/Double", "valueOf", "(D)Ljava/lang/Double;", false)
            else -> throw UnsupportedOperationException("Couldn't box non primitive type ${value.asmType.internalName}")
        }' @ [289:22] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: MethodDescription, entry1: MethodDescription, entry2: MethodDescription, entry3: MethodDescription, entry4: MethodDescription, entry5: MethodDescription, entry6: MethodDescription, entry7: MethodDescription, entry8: MethodDescription): MethodDescription[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> MethodDescription

'value' @ [289:28] ==> value-parameter value: Value defined in org.jetbrains.eval4j.jdi.JDIEval.boxType[ValueParameterDescriptorImpl]

'asmType' @ [289:34] ==> public abstract val asmType: Type defined in org.jetbrains.eval4j.Value[PropertyDescriptorImpl]

'INT_TYPE' @ [290:18] ==> public final val INT_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'MethodDescription' @ [290:30] ==> public constructor MethodDescription(ownerInternalName: String, name: String, desc: String, isStatic: Boolean) defined in org.jetbrains.eval4j.MethodDescription[ClassConstructorDescriptorImpl]

'BYTE_TYPE' @ [291:18] ==> public final val BYTE_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'MethodDescription' @ [291:31] ==> public constructor MethodDescription(ownerInternalName: String, name: String, desc: String, isStatic: Boolean) defined in org.jetbrains.eval4j.MethodDescription[ClassConstructorDescriptorImpl]

'SHORT_TYPE' @ [292:18] ==> public final val SHORT_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'MethodDescription' @ [292:32] ==> public constructor MethodDescription(ownerInternalName: String, name: String, desc: String, isStatic: Boolean) defined in org.jetbrains.eval4j.MethodDescription[ClassConstructorDescriptorImpl]

'LONG_TYPE' @ [293:18] ==> public final val LONG_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'MethodDescription' @ [293:31] ==> public constructor MethodDescription(ownerInternalName: String, name: String, desc: String, isStatic: Boolean) defined in org.jetbrains.eval4j.MethodDescription[ClassConstructorDescriptorImpl]

'BOOLEAN_TYPE' @ [294:18] ==> public final val BOOLEAN_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'MethodDescription' @ [294:34] ==> public constructor MethodDescription(ownerInternalName: String, name: String, desc: String, isStatic: Boolean) defined in org.jetbrains.eval4j.MethodDescription[ClassConstructorDescriptorImpl]

'CHAR_TYPE' @ [295:18] ==> public final val CHAR_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'MethodDescription' @ [295:31] ==> public constructor MethodDescription(ownerInternalName: String, name: String, desc: String, isStatic: Boolean) defined in org.jetbrains.eval4j.MethodDescription[ClassConstructorDescriptorImpl]

'FLOAT_TYPE' @ [296:18] ==> public final val FLOAT_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'MethodDescription' @ [296:32] ==> public constructor MethodDescription(ownerInternalName: String, name: String, desc: String, isStatic: Boolean) defined in org.jetbrains.eval4j.MethodDescription[ClassConstructorDescriptorImpl]

'DOUBLE_TYPE' @ [297:18] ==> public final val DOUBLE_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'MethodDescription' @ [297:33] ==> public constructor MethodDescription(ownerInternalName: String, name: String, desc: String, isStatic: Boolean) defined in org.jetbrains.eval4j.MethodDescription[ClassConstructorDescriptorImpl]

'UnsupportedOperationException' @ [298:27] ==> public final fun <init>(p0: (String..String?)): UnsupportedOperationException /* = UnsupportedOperationException */ defined in kotlin.UnsupportedOperationException[TypeAliasConstructorDescriptorImpl]

'value' @ [298:92] ==> value-parameter value: Value defined in org.jetbrains.eval4j.jdi.JDIEval.boxType[ValueParameterDescriptorImpl]

'asmType' @ [298:98] ==> public abstract val asmType: Type defined in org.jetbrains.eval4j.Value[PropertyDescriptorImpl]

'internalName' @ [298:106] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'invokeStaticMethod' @ [300:16] ==> public open fun invokeStaticMethod(methodDesc: MethodDescription, arguments: List<Value>): Value defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'method' @ [300:35] ==> val method: MethodDescription defined in org.jetbrains.eval4j.jdi.JDIEval.boxType[LocalVariableDescriptor]

'listOf' @ [300:43] ==> public fun <T> listOf(element: Value): List<Value> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Value

'value' @ [300:50] ==> value-parameter value: Value defined in org.jetbrains.eval4j.jdi.JDIEval.boxType[ValueParameterDescriptorImpl]

'invokespecial' @ [304:13] ==> value-parameter invokespecial: Boolean defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[ValueParameterDescriptorImpl]

'methodDesc' @ [304:30] ==> value-parameter methodDesc: MethodDescription defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[ValueParameterDescriptorImpl]

'name' @ [304:41] ==> public final val name: String defined in org.jetbrains.eval4j.MethodDescription[PropertyDescriptorImpl]

'findMethod' @ [306:24] ==> private final fun findMethod(methodDesc: MethodDescription, _class: ReferenceType = ...): Method defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'methodDesc' @ [306:35] ==> value-parameter methodDesc: MethodDescription defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[ValueParameterDescriptorImpl]

'instance' @ [307:27] ==> value-parameter instance: Value defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[ValueParameterDescriptorImpl]

'asmType' @ [307:55] ==> public open val asmType: Type defined in org.jetbrains.eval4j.NewObjectValue[PropertyDescriptorImpl]

'asReferenceType' @ [307:63] ==> public final fun Type.asReferenceType(classLoader: ClassLoaderReference? = ...): ReferenceType defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'mapArguments' @ [308:24] ==> private final fun mapArguments(arguments: List<Value>, expecetedTypes: List<Type>): List<Value?> defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'arguments' @ [308:37] ==> value-parameter arguments: List<Value> defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[ValueParameterDescriptorImpl]

'ctor' @ [308:48] ==> val ctor: Method defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[LocalVariableDescriptor]

'safeArgumentTypes' @ [308:53] ==> private final fun Method.safeArgumentTypes(): List<Type> defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'args' @ [309:13] ==> val args: List<Value?> defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[LocalVariableDescriptor]

'disableCollection' @ [309:18] ==> private final fun List<Value?>.disableCollection(): Unit defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'mayThrow' @ [310:26] ==> private fun <T> mayThrow(f: () -> (ObjectReference..ObjectReference?)): JdiOperationResult<(ObjectReference..ObjectReference?)> defined in org.jetbrains.eval4j.jdi[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> (com.sun.jdi.ObjectReference..com.sun.jdi.ObjectReference?)

'_class' @ [310:37] ==> val _class: ClassType defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[LocalVariableDescriptor]

'newInstance' @ [310:44] ==> public abstract fun newInstance(p0: (ThreadReference..ThreadReference?), p1: (Method..Method?), p2: (MutableList<out (Value..Value?)>..List<(Value..Value?)>?), p3: Int): (ObjectReference..ObjectReference?) defined in com.sun.jdi.ClassType[JavaMethodDescriptor]

'thread' @ [310:56] ==> private final val thread: ThreadReference defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'ctor' @ [310:64] ==> val ctor: Method defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[LocalVariableDescriptor]

'args' @ [310:70] ==> val args: List<Value?> defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[LocalVariableDescriptor]

'invokePolicy' @ [310:76] ==> private final val invokePolicy: Int defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'ifFail' @ [310:92] ==> private fun <T> JdiOperationResult<(ObjectReference..ObjectReference?)>.ifFail(member: TypeComponent, thisObj: ObjectReference? = ...): (ObjectReference..ObjectReference?) defined in org.jetbrains.eval4j.jdi[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> (com.sun.jdi.ObjectReference..com.sun.jdi.ObjectReference?)

'ctor' @ [310:99] ==> val ctor: Method defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[LocalVariableDescriptor]

'args' @ [311:13] ==> val args: List<Value?> defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[LocalVariableDescriptor]

'enableCollection' @ [311:18] ==> private final fun List<Value?>.enableCollection(): Unit defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'instance' @ [312:13] ==> value-parameter instance: Value defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[ValueParameterDescriptorImpl]

'value' @ [312:22] ==> public open var value: Any? defined in org.jetbrains.eval4j.NewObjectValue[PropertyDescriptorImpl]

'result' @ [312:30] ==> val result: (ObjectReference..ObjectReference?) defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[LocalVariableDescriptor]

'result' @ [313:20] ==> val result: (ObjectReference..ObjectReference?) defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[LocalVariableDescriptor]

'asValue' @ [313:27] ==> public fun ObjectReference?.asValue(): ObjectValue defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'mapArguments' @ [317:24] ==> private final fun mapArguments(arguments: List<Value>, expecetedTypes: List<Type>): List<Value?> defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'arguments' @ [317:37] ==> value-parameter arguments: List<Value> defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[ValueParameterDescriptorImpl]

'method' @ [317:48] ==> value-parameter method: Method defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod.doInvokeMethod[ValueParameterDescriptorImpl]

'safeArgumentTypes' @ [317:55] ==> private final fun Method.safeArgumentTypes(): List<Type> defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'shouldInvokeMethodWithReflection' @ [319:17] ==> private final fun shouldInvokeMethodWithReflection(method: Method, args: List<Value?>): Boolean defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'method' @ [319:50] ==> value-parameter method: Method defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod.doInvokeMethod[ValueParameterDescriptorImpl]

'args' @ [319:58] ==> val args: List<Value?> defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod.doInvokeMethod[LocalVariableDescriptor]

'invokeMethodWithReflection' @ [320:24] ==> private final fun invokeMethodWithReflection(ownerType: Type, instance: Value, args: List<Value?>, methodDesc: MethodDescription): Value defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'instance' @ [320:51] ==> value-parameter instance: Value defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[ValueParameterDescriptorImpl]

'asmType' @ [320:60] ==> public abstract val asmType: Type defined in org.jetbrains.eval4j.Value[PropertyDescriptorImpl]

'instance' @ [320:69] ==> value-parameter instance: Value defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[ValueParameterDescriptorImpl]

'args' @ [320:79] ==> val args: List<Value?> defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod.doInvokeMethod[LocalVariableDescriptor]

'methodDesc' @ [320:85] ==> value-parameter methodDesc: MethodDescription defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[ValueParameterDescriptorImpl]

'args' @ [323:13] ==> val args: List<Value?> defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod.doInvokeMethod[LocalVariableDescriptor]

'disableCollection' @ [323:18] ==> private final fun List<Value?>.disableCollection(): Unit defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'mayThrow' @ [324:26] ==> private fun <T> mayThrow(f: () -> (Value..Value?)): JdiOperationResult<(Value..Value?)> defined in org.jetbrains.eval4j.jdi[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> (com.sun.jdi.Value..com.sun.jdi.Value?)

'obj' @ [324:37] ==> value-parameter obj: ObjectReference defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod.doInvokeMethod[ValueParameterDescriptorImpl]

'invokeMethod' @ [324:41] ==> public abstract fun invokeMethod(p0: (ThreadReference..ThreadReference?), p1: (Method..Method?), p2: (MutableList<out (Value..Value?)>..List<(Value..Value?)>?), p3: Int): (Value..Value?) defined in com.sun.jdi.ObjectReference[JavaMethodDescriptor]

'thread' @ [324:54] ==> private final val thread: ThreadReference defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'method' @ [324:62] ==> value-parameter method: Method defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod.doInvokeMethod[ValueParameterDescriptorImpl]

'args' @ [324:70] ==> val args: List<Value?> defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod.doInvokeMethod[LocalVariableDescriptor]

'policy' @ [324:76] ==> value-parameter policy: Int defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod.doInvokeMethod[ValueParameterDescriptorImpl]

'ifFail' @ [324:86] ==> private fun <T> JdiOperationResult<(Value..Value?)>.ifFail(member: TypeComponent, thisObj: ObjectReference? = ...): (Value..Value?) defined in org.jetbrains.eval4j.jdi[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> (com.sun.jdi.Value..com.sun.jdi.Value?)

'method' @ [324:93] ==> value-parameter method: Method defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod.doInvokeMethod[ValueParameterDescriptorImpl]

'obj' @ [324:101] ==> value-parameter obj: ObjectReference defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod.doInvokeMethod[ValueParameterDescriptorImpl]

'args' @ [325:13] ==> val args: List<Value?> defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod.doInvokeMethod[LocalVariableDescriptor]

'enableCollection' @ [325:18] ==> private final fun List<Value?>.enableCollection(): Unit defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'result' @ [326:20] ==> val result: (Value..Value?) defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod.doInvokeMethod[LocalVariableDescriptor]

'asValue' @ [326:27] ==> public fun Value?.asValue(): Value defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'instance' @ [329:19] ==> value-parameter instance: Value defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[ValueParameterDescriptorImpl]

'jdiObj' @ [329:28] ==> public val Value.jdiObj: ObjectReference? defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[PropertyDescriptorImpl]

'checkNull' @ [329:35] ==> public fun <T : Any> ObjectReference?.checkNull(): ObjectReference defined in org.jetbrains.eval4j[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> ObjectReference

'if (invokespecial) {
            val method = findMethod(methodDesc)
            doInvokeMethod(obj, method, invokePolicy or ObjectReference.INVOKE_NONVIRTUAL)
        }
        else {
            val method = findMethod(methodDesc, obj.referenceType() ?: methodDesc.ownerType.asReferenceType())
            doInvokeMethod(obj, method, invokePolicy)
        }' @ [330:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Value, elseBranch: Value): Value[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Value

'invokespecial' @ [330:20] ==> value-parameter invokespecial: Boolean defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[ValueParameterDescriptorImpl]

'findMethod' @ [331:26] ==> private final fun findMethod(methodDesc: MethodDescription, _class: ReferenceType = ...): Method defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'methodDesc' @ [331:37] ==> value-parameter methodDesc: MethodDescription defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[ValueParameterDescriptorImpl]

'doInvokeMethod' @ [332:13] ==> local final fun doInvokeMethod(obj: ObjectReference, method: Method, policy: Int): Value defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[SimpleFunctionDescriptorImpl]

'obj' @ [332:28] ==> val obj: ObjectReference defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[LocalVariableDescriptor]

'method' @ [332:33] ==> val method: Method defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[LocalVariableDescriptor]

'invokePolicy' @ [332:41] ==> private final val invokePolicy: Int defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'INVOKE_NONVIRTUAL' @ [332:73] ==> public const final val INVOKE_NONVIRTUAL: Int defined in com.sun.jdi.ObjectReference[JavaPropertyDescriptor]

'findMethod' @ [335:26] ==> private final fun findMethod(methodDesc: MethodDescription, _class: ReferenceType = ...): Method defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'methodDesc' @ [335:37] ==> value-parameter methodDesc: MethodDescription defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[ValueParameterDescriptorImpl]

'obj' @ [335:49] ==> val obj: ObjectReference defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[LocalVariableDescriptor]

'referenceType' @ [335:53] ==> public abstract fun referenceType(): (ReferenceType..ReferenceType?) defined in com.sun.jdi.ObjectReference[JavaMethodDescriptor]

'methodDesc' @ [335:72] ==> value-parameter methodDesc: MethodDescription defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[ValueParameterDescriptorImpl]

'ownerType' @ [335:83] ==> public val MemberDescription.ownerType: Type defined in org.jetbrains.eval4j in file members.kt[PropertyDescriptorImpl]

'asReferenceType' @ [335:93] ==> public final fun Type.asReferenceType(classLoader: ClassLoaderReference? = ...): ReferenceType defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'doInvokeMethod' @ [336:13] ==> local final fun doInvokeMethod(obj: ObjectReference, method: Method, policy: Int): Value defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[SimpleFunctionDescriptorImpl]

'obj' @ [336:28] ==> val obj: ObjectReference defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[LocalVariableDescriptor]

'method' @ [336:33] ==> val method: Method defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethod[LocalVariableDescriptor]

'invokePolicy' @ [336:41] ==> private final val invokePolicy: Int defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'!' @ [341:16] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'method' @ [341:17] ==> value-parameter method: Method defined in org.jetbrains.eval4j.jdi.JDIEval.shouldInvokeMethodWithReflection[ValueParameterDescriptorImpl]

'isVarArgs' @ [341:24] ==> public final val Method.isVarArgs: Boolean[MyPropertyDescriptor]

'args' @ [341:37] ==> value-parameter args: List<Value?> defined in org.jetbrains.eval4j.jdi.JDIEval.shouldInvokeMethodWithReflection[ValueParameterDescriptorImpl]

'zip' @ [341:42] ==> public infix fun <T, R> Iterable<Value?>.zip(other: Iterable<(Type..Type?)>): List<Pair<Value?, (Type..Type?)>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Value?
    <R> -> (com.sun.jdi.Type..com.sun.jdi.Type?)

'method' @ [341:46] ==> value-parameter method: Method defined in org.jetbrains.eval4j.jdi.JDIEval.shouldInvokeMethodWithReflection[ValueParameterDescriptorImpl]

'argumentTypes' @ [341:53] ==> public abstract fun argumentTypes(): (MutableList<(Type..Type?)>..List<(Type..Type?)>?) defined in com.sun.jdi.Method[JavaMethodDescriptor]

'any' @ [341:70] ==> public inline fun <T> Iterable<Pair<Value?, (Type..Type?)>>.any(predicate: (Pair<Value?, (Type..Type?)>) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<Value?, (com.sun.jdi.Type..com.sun.jdi.Type?)>

'isArrayOfInterfaces' @ [341:76] ==> private final fun isArrayOfInterfaces(valueType: Type?, expectedType: Type?): Boolean defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'it' @ [341:96] ==> value-parameter it: Pair<Value?, (Type..Type?)> defined in org.jetbrains.eval4j.jdi.JDIEval.shouldInvokeMethodWithReflection.<anonymous>[ValueParameterDescriptorImpl]

'first' @ [341:99] ==> public final val first: Value? defined in kotlin.Pair[DeserializedPropertyDescriptor]

'type' @ [341:106] ==> public abstract fun type(): (Type..Type?) defined in com.sun.jdi.Value[JavaMethodDescriptor]

'it' @ [341:114] ==> value-parameter it: Pair<Value?, (Type..Type?)> defined in org.jetbrains.eval4j.jdi.JDIEval.shouldInvokeMethodWithReflection.<anonymous>[ValueParameterDescriptorImpl]

'second' @ [341:117] ==> public final val second: (Type..Type?) defined in kotlin.Pair[DeserializedPropertyDescriptor]

'valueType' @ [345:17] ==> value-parameter valueType: Type? defined in org.jetbrains.eval4j.jdi.JDIEval.isArrayOfInterfaces[ValueParameterDescriptorImpl]

'componentType' @ [345:43] ==> public abstract fun componentType(): (Type..Type?) defined in com.sun.jdi.ArrayType[JavaMethodDescriptor]

'==' @ [345:79] ==> public open fun equals(other: Any?): Boolean defined in com.sun.jdi.Type[DeserializedSimpleFunctionDescriptor]

'expectedType' @ [345:80] ==> value-parameter expectedType: Type? defined in org.jetbrains.eval4j.jdi.JDIEval.isArrayOfInterfaces[ValueParameterDescriptorImpl]

'componentType' @ [345:109] ==> public abstract fun componentType(): (Type..Type?) defined in com.sun.jdi.ArrayType[JavaMethodDescriptor]

'OBJECT' @ [345:128] ==> private val OBJECT: (Type..Type?) defined in org.jetbrains.eval4j.jdi in file jdiEval.kt[PropertyDescriptorImpl]

'asReferenceType' @ [345:135] ==> public final fun Type.asReferenceType(classLoader: ClassLoaderReference? = ...): ReferenceType defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'invokeMethod' @ [349:30] ==> public open fun invokeMethod(instance: Value, methodDesc: MethodDescription, arguments: List<Value>, invokespecial: Boolean): Value defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'loadClass' @ [350:17] ==> public open fun loadClass(classType: Type): Value defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'ownerType' @ [350:27] ==> value-parameter ownerType: Type defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethodWithReflection[ValueParameterDescriptorImpl]

'MethodDescription' @ [351:17] ==> public constructor MethodDescription(ownerInternalName: String, name: String, desc: String, isStatic: Boolean) defined in org.jetbrains.eval4j.MethodDescription[ClassConstructorDescriptorImpl]

'CLASS' @ [352:25] ==> private val CLASS: (Type..Type?) defined in org.jetbrains.eval4j.jdi in file jdiEval.kt[PropertyDescriptorImpl]

'internalName' @ [352:31] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'CLASS' @ [354:49] ==> private val CLASS: (Type..Type?) defined in org.jetbrains.eval4j.jdi in file jdiEval.kt[PropertyDescriptorImpl]

'internalName' @ [354:55] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'listOf' @ [357:17] ==> public fun <T> listOf(vararg elements: Value): List<Value> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Value

'vm' @ [357:24] ==> private final val vm: VirtualMachine defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'mirrorOf' @ [357:27] ==> public abstract fun mirrorOf(p0: (String..String?)): (StringReference..StringReference?) defined in com.sun.jdi.VirtualMachine[JavaMethodDescriptor]

'methodDesc' @ [357:36] ==> value-parameter methodDesc: MethodDescription defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethodWithReflection[ValueParameterDescriptorImpl]

'name' @ [357:47] ==> public final val name: String defined in org.jetbrains.eval4j.MethodDescription[PropertyDescriptorImpl]

'asValue' @ [357:53] ==> public fun ObjectReference?.asValue(): ObjectValue defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'methodDesc' @ [357:65] ==> value-parameter methodDesc: MethodDescription defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethodWithReflection[ValueParameterDescriptorImpl]

'parameterTypes' @ [357:76] ==> public val MethodDescription.parameterTypes: List<Type> defined in org.jetbrains.eval4j in file members.kt[PropertyDescriptorImpl]

'map' @ [357:91] ==> public inline fun <T, R> Iterable<Type>.map(transform: (Type) -> Value): List<Value> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Type
    <R> -> Value

'loadClass' @ [357:97] ==> public open fun loadClass(classType: Type): Value defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'it' @ [357:107] ==> value-parameter it: Type defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethodWithReflection.<anonymous>[ValueParameterDescriptorImpl]

'toTypedArray' @ [357:113] ==> public inline fun <reified T> Collection<Value>.toTypedArray(): Array<Value> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T> -> Value

'invokeMethod' @ [360:9] ==> public open fun invokeMethod(instance: Value, methodDesc: MethodDescription, arguments: List<Value>, invokespecial: Boolean): Value defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'methodToInvoke' @ [361:17] ==> val methodToInvoke: Value defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethodWithReflection[LocalVariableDescriptor]

'MethodDescription' @ [362:17] ==> public constructor MethodDescription(ownerInternalName: String, name: String, desc: String, isStatic: Boolean) defined in org.jetbrains.eval4j.MethodDescription[ClassConstructorDescriptorImpl]

'getType' @ [363:30] ==> public open fun getType(p0: (Class<*>..Class<*>?)): (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaMethodDescriptor]

'AccessibleObject' @ [363:38] ==> protected/*protected and package*/ constructor AccessibleObject() defined in java.lang.reflect.AccessibleObject[JavaClassConstructorDescriptor]

'java' @ [363:62] ==> public val <T> KClass<AccessibleObject>.java: Class<AccessibleObject> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> AccessibleObject

'internalName' @ [363:68] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'listOf' @ [368:17] ==> public fun <T> listOf(element: Value): List<Value> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Value

'vm' @ [368:24] ==> private final val vm: VirtualMachine defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'mirrorOf' @ [368:27] ==> public abstract fun mirrorOf(p0: Boolean): (BooleanValue..BooleanValue?) defined in com.sun.jdi.VirtualMachine[JavaMethodDescriptor]

'asValue' @ [368:42] ==> public fun Value?.asValue(): Value defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'invokeMethod' @ [371:32] ==> public open fun invokeMethod(instance: Value, methodDesc: MethodDescription, arguments: List<Value>, invokespecial: Boolean): Value defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'methodToInvoke' @ [372:17] ==> val methodToInvoke: Value defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethodWithReflection[LocalVariableDescriptor]

'MethodDescription' @ [373:17] ==> public constructor MethodDescription(ownerInternalName: String, name: String, desc: String, isStatic: Boolean) defined in org.jetbrains.eval4j.MethodDescription[ClassConstructorDescriptorImpl]

'methodToInvoke' @ [374:25] ==> val methodToInvoke: Value defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethodWithReflection[LocalVariableDescriptor]

'asmType' @ [374:40] ==> public abstract val asmType: Type defined in org.jetbrains.eval4j.Value[PropertyDescriptorImpl]

'internalName' @ [374:48] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'OBJECT' @ [376:30] ==> private val OBJECT: (Type..Type?) defined in org.jetbrains.eval4j.jdi in file jdiEval.kt[PropertyDescriptorImpl]

'internalName' @ [376:37] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'OBJECT' @ [376:55] ==> private val OBJECT: (Type..Type?) defined in org.jetbrains.eval4j.jdi in file jdiEval.kt[PropertyDescriptorImpl]

'internalName' @ [376:62] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'OBJECT' @ [376:80] ==> private val OBJECT: (Type..Type?) defined in org.jetbrains.eval4j.jdi in file jdiEval.kt[PropertyDescriptorImpl]

'internalName' @ [376:87] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'listOf' @ [379:17] ==> public fun <T> listOf(vararg elements: Value): List<Value> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Value

'instance' @ [379:24] ==> value-parameter instance: Value defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethodWithReflection[ValueParameterDescriptorImpl]

'args' @ [379:35] ==> value-parameter args: List<Value?> defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethodWithReflection[ValueParameterDescriptorImpl]

'map' @ [379:40] ==> public inline fun <T, R> Iterable<Value?>.map(transform: (Value?) -> Value): List<Value> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Value?
    <R> -> Value

'it' @ [379:46] ==> value-parameter it: Value? defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethodWithReflection.<anonymous>[ValueParameterDescriptorImpl]

'asValue' @ [379:49] ==> public fun Value?.asValue(): Value defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'toTypedArray' @ [379:61] ==> public inline fun <reified T> Collection<Value>.toTypedArray(): Array<Value> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T> -> Value

'methodDesc' @ [382:13] ==> value-parameter methodDesc: MethodDescription defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethodWithReflection[ValueParameterDescriptorImpl]

'returnType' @ [382:24] ==> public val MethodDescription.returnType: Type defined in org.jetbrains.eval4j in file members.kt[PropertyDescriptorImpl]

'sort' @ [382:35] ==> public final val Type.sort: Int[MyPropertyDescriptor]

'OBJECT' @ [382:48] ==> public const final val OBJECT: Int defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'methodDesc' @ [382:58] ==> value-parameter methodDesc: MethodDescription defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethodWithReflection[ValueParameterDescriptorImpl]

'returnType' @ [382:69] ==> public val MethodDescription.returnType: Type defined in org.jetbrains.eval4j in file members.kt[PropertyDescriptorImpl]

'sort' @ [382:80] ==> public final val Type.sort: Int[MyPropertyDescriptor]

'ARRAY' @ [382:93] ==> public const final val ARRAY: Int defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'methodDesc' @ [382:102] ==> value-parameter methodDesc: MethodDescription defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethodWithReflection[ValueParameterDescriptorImpl]

'returnType' @ [382:113] ==> public val MethodDescription.returnType: Type defined in org.jetbrains.eval4j in file members.kt[PropertyDescriptorImpl]

'sort' @ [382:124] ==> public final val Type.sort: Int[MyPropertyDescriptor]

'VOID' @ [382:137] ==> public const final val VOID: Int defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'unboxType' @ [383:20] ==> public final fun unboxType(boxedValue: Value, type: Type): Value defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'invocationResult' @ [383:30] ==> val invocationResult: Value defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethodWithReflection[LocalVariableDescriptor]

'methodDesc' @ [383:48] ==> value-parameter methodDesc: MethodDescription defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethodWithReflection[ValueParameterDescriptorImpl]

'returnType' @ [383:59] ==> public val MethodDescription.returnType: Type defined in org.jetbrains.eval4j in file members.kt[PropertyDescriptorImpl]

'invocationResult' @ [385:16] ==> val invocationResult: Value defined in org.jetbrains.eval4j.jdi.JDIEval.invokeMethodWithReflection[LocalVariableDescriptor]

'forEach' @ [389:9] ==> @HidesMembers public inline fun <T> Iterable<Value?>.forEach(action: (Value?) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Value?

'it' @ [389:20] ==> value-parameter it: Value? defined in org.jetbrains.eval4j.jdi.JDIEval.disableCollection.<anonymous>[ValueParameterDescriptorImpl]

'disableCollection' @ [389:45] ==> public abstract fun disableCollection(): Unit defined in com.sun.jdi.ObjectReference[JavaMethodDescriptor]

'forEach' @ [393:9] ==> @HidesMembers public inline fun <T> Iterable<Value?>.forEach(action: (Value?) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Value?

'it' @ [393:20] ==> value-parameter it: Value? defined in org.jetbrains.eval4j.jdi.JDIEval.enableCollection.<anonymous>[ValueParameterDescriptorImpl]

'enableCollection' @ [393:45] ==> public abstract fun enableCollection(): Unit defined in com.sun.jdi.ObjectReference[JavaMethodDescriptor]

'arguments' @ [398:16] ==> value-parameter arguments: List<Value> defined in org.jetbrains.eval4j.jdi.JDIEval.mapArguments[ValueParameterDescriptorImpl]

'zip' @ [398:26] ==> public infix fun <T, R> Iterable<Value>.zip(other: Iterable<Type>): List<Pair<Value, Type>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Value
    <R> -> Type

'expecetedTypes' @ [398:30] ==> value-parameter expecetedTypes: List<Type> defined in org.jetbrains.eval4j.jdi.JDIEval.mapArguments[ValueParameterDescriptorImpl]

'map' @ [398:46] ==> public inline fun <T, R> Iterable<Pair<Value, Type>>.map(transform: (Pair<Value, Type>) -> Value?): List<Value?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<Value, Type>
    <R> -> Value?

'component1' @ [399:18] ==> public final operator fun component1(): Value defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [399:23] ==> public final operator fun component2(): Type defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'it' @ [399:39] ==> value-parameter it: Pair<Value, Type> defined in org.jetbrains.eval4j.jdi.JDIEval.mapArguments.<anonymous>[ValueParameterDescriptorImpl]

'arg' @ [400:13] ==> val arg: Value defined in org.jetbrains.eval4j.jdi.JDIEval.mapArguments.<anonymous>[LocalVariableDescriptor]

'asJdiValue' @ [400:17] ==> public fun Value.asJdiValue(vm: VirtualMachine, expectedType: Type): Value? defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'vm' @ [400:28] ==> private final val vm: VirtualMachine defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'expectedType' @ [400:32] ==> val expectedType: Type defined in org.jetbrains.eval4j.jdi.JDIEval.mapArguments.<anonymous>[LocalVariableDescriptor]

'asType' @ [400:45] ==> public fun Type.asType(): Type defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'argumentTypes' @ [406:20] ==> public abstract fun argumentTypes(): (MutableList<(Type..Type?)>..List<(Type..Type?)>?) defined in com.sun.jdi.Method[JavaMethodDescriptor]

'argumentTypeNames' @ [409:20] ==> public abstract fun argumentTypeNames(): (MutableList<(String..String?)>..List<(String..String?)>?) defined in com.sun.jdi.Method[JavaMethodDescriptor]

'map' @ [409:42] ==> public inline fun <T, R> Iterable<(String..String?)>.map(transform: ((String..String?)) -> Type): List<Type> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.String..kotlin.String?)
    <R> -> Type

'name' @ [411:34] ==> value-parameter name: (String..String?) defined in org.jetbrains.eval4j.jdi.JDIEval.safeArgumentTypes.<anonymous>[ValueParameterDescriptorImpl]

'count' @ [411:39] ==> public inline fun CharSequence.count(predicate: (Char) -> Boolean): Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'it' @ [411:47] ==> value-parameter it: Char defined in org.jetbrains.eval4j.jdi.JDIEval.safeArgumentTypes.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'if (dimensions > 0) name.substring(0, name.indexOf('[')) else name' @ [412:36] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (String..String?), elseBranch: (String..String?)): (String..String?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (kotlin.String..kotlin.String?)

'dimensions' @ [412:40] ==> val dimensions: Int defined in org.jetbrains.eval4j.jdi.JDIEval.safeArgumentTypes.<anonymous>[LocalVariableDescriptor]

'name' @ [412:56] ==> value-parameter name: (String..String?) defined in org.jetbrains.eval4j.jdi.JDIEval.safeArgumentTypes.<anonymous>[ValueParameterDescriptorImpl]

'substring' @ [412:61] ==> @InlineOnly public inline fun String.substring(startIndex: Int, endIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'name' @ [412:74] ==> value-parameter name: (String..String?) defined in org.jetbrains.eval4j.jdi.JDIEval.safeArgumentTypes.<anonymous>[ValueParameterDescriptorImpl]

'indexOf' @ [412:79] ==> public fun CharSequence.indexOf(char: Char, startIndex: Int = ..., ignoreCase: Boolean = ...): Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'name' @ [412:98] ==> value-parameter name: (String..String?) defined in org.jetbrains.eval4j.jdi.JDIEval.safeArgumentTypes.<anonymous>[ValueParameterDescriptorImpl]

'primitiveTypes' @ [414:32] ==> private final val primitiveTypes: Map<(String..String?), (Type..Type?)> defined in org.jetbrains.eval4j.jdi.JDIEval[PropertyDescriptorImpl]

'baseTypeName' @ [414:47] ==> val baseTypeName: (String..String?) defined in org.jetbrains.eval4j.jdi.JDIEval.safeArgumentTypes.<anonymous>[LocalVariableDescriptor]

'getType' @ [414:69] ==> public open fun getType(p0: (String..String?)): (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaMethodDescriptor]

'baseTypeName' @ [414:80] ==> val baseTypeName: (String..String?) defined in org.jetbrains.eval4j.jdi.JDIEval.safeArgumentTypes.<anonymous>[LocalVariableDescriptor]

'asReferenceType' @ [414:96] ==> public final fun Type.asReferenceType(classLoader: ClassLoaderReference? = ...): ReferenceType defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'declaringType' @ [414:112] ==> public abstract fun declaringType(): (ReferenceType..ReferenceType?) defined in com.sun.jdi.Method[JavaMethodDescriptor]

'classLoader' @ [414:128] ==> public abstract fun classLoader(): (ClassLoaderReference..ClassLoaderReference?) defined in com.sun.jdi.ReferenceType[JavaMethodDescriptor]

'if (dimensions == 0)
                    baseType
                else
                    Type.getType("[".repeat(dimensions) + baseType.asType().descriptor).asReferenceType(declaringType().classLoader())' @ [416:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Type, elseBranch: Type): Type[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Type

'dimensions' @ [416:21] ==> val dimensions: Int defined in org.jetbrains.eval4j.jdi.JDIEval.safeArgumentTypes.<anonymous>[LocalVariableDescriptor]

'baseType' @ [417:21] ==> val baseType: Type defined in org.jetbrains.eval4j.jdi.JDIEval.safeArgumentTypes.<anonymous>[LocalVariableDescriptor]

'getType' @ [419:26] ==> public open fun getType(p0: (String..String?)): (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaMethodDescriptor]

'+' @ [419:34] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'repeat' @ [419:38] ==> public fun CharSequence.repeat(n: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'dimensions' @ [419:45] ==> val dimensions: Int defined in org.jetbrains.eval4j.jdi.JDIEval.safeArgumentTypes.<anonymous>[LocalVariableDescriptor]

'baseType' @ [419:59] ==> val baseType: Type defined in org.jetbrains.eval4j.jdi.JDIEval.safeArgumentTypes.<anonymous>[LocalVariableDescriptor]

'asType' @ [419:68] ==> public fun Type.asType(): Type defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'descriptor' @ [419:77] ==> public final val Type.descriptor: (String..String?)[MyPropertyDescriptor]

'asReferenceType' @ [419:89] ==> public final fun Type.asReferenceType(classLoader: ClassLoaderReference? = ...): ReferenceType defined in org.jetbrains.eval4j.jdi.JDIEval[SimpleFunctionDescriptorImpl]

'declaringType' @ [419:105] ==> public abstract fun declaringType(): (ReferenceType..ReferenceType?) defined in com.sun.jdi.Method[JavaMethodDescriptor]

'classLoader' @ [419:121] ==> public abstract fun classLoader(): (ClassLoaderReference..ClassLoaderReference?) defined in com.sun.jdi.ReferenceType[JavaMethodDescriptor]

'Suppress' @ [425:1] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'JdiOperationResult<T>' @ [427:42] ==> private constructor JdiOperationResult<T>() defined in org.jetbrains.eval4j.jdi.JdiOperationResult[ClassConstructorDescriptorImpl]
Inferred types:
    <T> -> T

'JdiOperationResult<T>' @ [428:32] ==> private constructor JdiOperationResult<T>() defined in org.jetbrains.eval4j.jdi.JdiOperationResult[ClassConstructorDescriptorImpl]
Inferred types:
    <T> -> T

'OK' @ [433:35] ==> public constructor OK<T>(value: T) defined in org.jetbrains.eval4j.jdi.JdiOperationResult.OK[ClassConstructorDescriptorImpl]
Inferred types:
    <T> -> T

'invoke' @ [433:38] ==> public abstract operator fun invoke(): T defined in kotlin.Function0[FunctionInvokeDescriptor]

'Fail' @ [436:35] ==> public constructor Fail<T>(cause: Exception /* = Exception */) defined in org.jetbrains.eval4j.jdi.JdiOperationResult.Fail[ClassConstructorDescriptorImpl]
Inferred types:
    <T> -> T

'e' @ [436:43] ==> val e: IllegalArgumentException /* = IllegalArgumentException */ defined in org.jetbrains.eval4j.jdi.mayThrow[LocalVariableDescriptor]

'ThrownFromEvaluatedCodeException' @ [439:15] ==> public constructor ThrownFromEvaluatedCodeException(exception: ObjectValue) defined in org.jetbrains.eval4j.ThrownFromEvaluatedCodeException[ClassConstructorDescriptorImpl]

'e' @ [439:48] ==> val e: InvocationException defined in org.jetbrains.eval4j.jdi.mayThrow[LocalVariableDescriptor]

'exception' @ [439:50] ==> public open fun exception(): (ObjectReference..ObjectReference?) defined in com.sun.jdi.InvocationException[JavaMethodDescriptor]

'asValue' @ [439:62] ==> public fun ObjectReference?.asValue(): ObjectValue defined in org.jetbrains.eval4j.jdi in file jdiValues.kt[SimpleFunctionDescriptorImpl]

'member' @ [444:25] ==> value-parameter member: TypeComponent defined in org.jetbrains.eval4j.jdi.memberInfo[ValueParameterDescriptorImpl]

'thisObj' @ [444:46] ==> value-parameter thisObj: ObjectReference? defined in org.jetbrains.eval4j.jdi.memberInfo[ValueParameterDescriptorImpl]

'ifFail' @ [448:12] ==> private fun <T> JdiOperationResult<T>.ifFail(lazyMessage: () -> String): T defined in org.jetbrains.eval4j.jdi[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> T

'memberInfo' @ [448:21] ==> private fun memberInfo(member: TypeComponent, thisObj: ObjectReference?): String defined in org.jetbrains.eval4j.jdi in file jdiEval.kt[SimpleFunctionDescriptorImpl]

'member' @ [448:32] ==> value-parameter member: TypeComponent defined in org.jetbrains.eval4j.jdi.ifFail[ValueParameterDescriptorImpl]

'thisObj' @ [448:40] ==> value-parameter thisObj: ObjectReference? = ... defined in org.jetbrains.eval4j.jdi.ifFail[ValueParameterDescriptorImpl]

'when(this) {
        is JdiOperationResult.OK -> this.value
        is JdiOperationResult.Fail -> {
            if (cause is IllegalArgumentException) {
                throwBrokenCodeException(IllegalArgumentException(lazyMessage(), this.cause))
            }
            else {
                throwBrokenCodeException(IllegalStateException(lazyMessage(), this.cause))
            }
        }
    }' @ [452:12] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: T, entry1: T): T[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> T

'this' @ [452:17] ==> <this> defined in org.jetbrains.eval4j.jdi.ifFail[ReceiverParameterDescriptorImpl]

'this' @ [453:37] ==> <this> defined in org.jetbrains.eval4j.jdi.ifFail[ReceiverParameterDescriptorImpl]

'value' @ [453:42] ==> public final val value: T defined in org.jetbrains.eval4j.jdi.JdiOperationResult.OK[PropertyDescriptorImpl]

'if (cause is IllegalArgumentException) {
                throwBrokenCodeException(IllegalArgumentException(lazyMessage(), this.cause))
            }
            else {
                throwBrokenCodeException(IllegalStateException(lazyMessage(), this.cause))
            }' @ [455:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nothing, elseBranch: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nothing

'cause' @ [455:17] ==> public final val cause: Exception /* = Exception */ defined in org.jetbrains.eval4j.jdi.JdiOperationResult.Fail[PropertyDescriptorImpl]

'throwBrokenCodeException' @ [456:17] ==> public fun throwBrokenCodeException(e: Throwable): Nothing defined in org.jetbrains.eval4j in file values.kt[SimpleFunctionDescriptorImpl]

'IllegalArgumentException' @ [456:42] ==> public final fun <init>(p0: (String..String?), p1: (Throwable..Throwable?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'invoke' @ [456:67] ==> public abstract operator fun invoke(): String defined in kotlin.Function0[FunctionInvokeDescriptor]

'this' @ [456:82] ==> <this> defined in org.jetbrains.eval4j.jdi.ifFail[ReceiverParameterDescriptorImpl]

'cause' @ [456:87] ==> public final val cause: Exception /* = Exception */ defined in org.jetbrains.eval4j.jdi.JdiOperationResult.Fail[PropertyDescriptorImpl]

'throwBrokenCodeException' @ [459:17] ==> public fun throwBrokenCodeException(e: Throwable): Nothing defined in org.jetbrains.eval4j in file values.kt[SimpleFunctionDescriptorImpl]

'IllegalStateException' @ [459:42] ==> public final fun <init>(p0: (String..String?), p1: (Throwable..Throwable?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'invoke' @ [459:64] ==> public abstract operator fun invoke(): String defined in kotlin.Function0[FunctionInvokeDescriptor]

'this' @ [459:79] ==> <this> defined in org.jetbrains.eval4j.jdi.ifFail[ReceiverParameterDescriptorImpl]

'cause' @ [459:84] ==> public final val cause: Exception /* = Exception */ defined in org.jetbrains.eval4j.jdi.JdiOperationResult.Fail[PropertyDescriptorImpl]

