'KotlinDebuggerTestBase' @ [65:55] ==> public constructor KotlinDebuggerTestBase() defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[ClassConstructorDescriptorImpl]

'!!' @ [66:26] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: Logger?): Logger[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> Logger

'getLogger' @ [66:33] ==> public open fun getLogger(p0: raw (Class<(Any..Any?)>..Class<*>?)): (Logger..Logger?) defined in org.apache.log4j.Logger[JavaMethodDescriptor]

'KotlinDebuggerCaches' @ [66:43] ==> public companion object defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinDebuggerCaches[FakeCallableDescriptorForObject]

'java' @ [66:71] ==> public val <T> KClass<KotlinDebuggerCaches>.java: Class<KotlinDebuggerCaches> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KotlinDebuggerCaches

'super' @ [74:9] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[LazyClassReceiverParameterDescriptor]

'setUp' @ [74:15] ==> @SuppressWarnings @Override protected/*protected and package*/ open fun setUp(): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[JavaMethodDescriptor]

'!!' @ [76:29] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: NodeRendererSettings?): NodeRendererSettings[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> NodeRendererSettings

'getInstance' @ [76:50] ==> public open fun getInstance(): (NodeRendererSettings..NodeRendererSettings?) defined in com.intellij.debugger.settings.NodeRendererSettings[JavaMethodDescriptor]

'classRenderer' @ [76:66] ==> public final val NodeRendererSettings.classRenderer: (ClassRenderer..ClassRenderer?)[MyPropertyDescriptor]

'oldShowFqTypeNames' @ [77:9] ==> private final var oldShowFqTypeNames: Boolean defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[PropertyDescriptorImpl]

'classRenderer' @ [77:30] ==> val classRenderer: ClassRenderer defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.setUp[LocalVariableDescriptor]

'SHOW_FQ_TYPE_NAMES' @ [77:44] ==> public final var SHOW_FQ_TYPE_NAMES: Boolean defined in com.intellij.debugger.ui.tree.render.ClassRenderer[JavaPropertyDescriptor]

'classRenderer' @ [78:9] ==> val classRenderer: ClassRenderer defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.setUp[LocalVariableDescriptor]

'SHOW_FQ_TYPE_NAMES' @ [78:23] ==> public final var SHOW_FQ_TYPE_NAMES: Boolean defined in com.intellij.debugger.ui.tree.render.ClassRenderer[JavaPropertyDescriptor]

'oldLogLevel' @ [80:9] ==> private final var oldLogLevel: Level? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[PropertyDescriptorImpl]

'logger' @ [80:23] ==> private final val logger: Logger defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[PropertyDescriptorImpl]

'level' @ [80:30] ==> public final var Logger.level: (Level..Level?)[MyPropertyDescriptor]

'logger' @ [81:9] ==> private final val logger: Logger defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[PropertyDescriptorImpl]

'level' @ [81:16] ==> public final var Logger.level: (Level..Level?)[MyPropertyDescriptor]

'DEBUG' @ [81:30] ==> public final val DEBUG: (Level..Level?) defined in org.apache.log4j.Level[JavaPropertyDescriptor]

'appender' @ [83:9] ==> private final var appender: AppenderSkeleton? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[PropertyDescriptorImpl]

'AppenderSkeleton' @ [83:29] ==> public constructor AppenderSkeleton() defined in org.apache.log4j.AppenderSkeleton[JavaClassConstructorDescriptor]

'println' @ [85:17] ==> public open fun println(@NonNls p0: (String..String?), p1: raw (Key<(Any..Any?)>..Key<*>?)): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[JavaMethodDescriptor]

'event' @ [85:25] ==> value-parameter event: LoggingEvent? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.setUp.<no name provided>.append[ValueParameterDescriptorImpl]

'renderedMessage' @ [85:32] ==> public final val LoggingEvent.renderedMessage: (String..String?)[MyPropertyDescriptor]

'SYSTEM' @ [85:68] ==> public final val SYSTEM: raw (Key<(Any..Any?)>..Key<*>?) defined in com.intellij.execution.process.ProcessOutputTypes[JavaPropertyDescriptor]

'logger' @ [91:9] ==> private final val logger: Logger defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[PropertyDescriptorImpl]

'addAppender' @ [91:16] ==> public open fun addAppender(p0: (Appender..Appender?)): Unit defined in org.apache.log4j.Logger[JavaMethodDescriptor]

'appender' @ [91:28] ==> private final var appender: AppenderSkeleton? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[PropertyDescriptorImpl]

'logger' @ [95:9] ==> private final val logger: Logger defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[PropertyDescriptorImpl]

'level' @ [95:16] ==> public final var Logger.level: (Level..Level?)[MyPropertyDescriptor]

'oldLogLevel' @ [95:24] ==> private final var oldLogLevel: Level? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[PropertyDescriptorImpl]

'logger' @ [96:9] ==> private final val logger: Logger defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[PropertyDescriptorImpl]

'removeAppender' @ [96:16] ==> public open fun removeAppender(p0: (Appender..Appender?)): Unit defined in org.apache.log4j.Logger[JavaMethodDescriptor]

'appender' @ [96:31] ==> private final var appender: AppenderSkeleton? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[PropertyDescriptorImpl]

'appender' @ [98:9] ==> private final var appender: AppenderSkeleton? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[PropertyDescriptorImpl]

'oldLogLevel' @ [99:9] ==> private final var oldLogLevel: Level? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[PropertyDescriptorImpl]

'!!' @ [101:9] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: NodeRendererSettings?): NodeRendererSettings[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> NodeRendererSettings

'getInstance' @ [101:30] ==> public open fun getInstance(): (NodeRendererSettings..NodeRendererSettings?) defined in com.intellij.debugger.settings.NodeRendererSettings[JavaMethodDescriptor]

'classRenderer' @ [101:46] ==> public final val NodeRendererSettings.classRenderer: (ClassRenderer..ClassRenderer?)[MyPropertyDescriptor]

'SHOW_FQ_TYPE_NAMES' @ [101:62] ==> public final var SHOW_FQ_TYPE_NAMES: Boolean defined in com.intellij.debugger.ui.tree.render.ClassRenderer[JavaPropertyDescriptor]

'oldShowFqTypeNames' @ [101:83] ==> private final var oldShowFqTypeNames: Boolean defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[PropertyDescriptorImpl]

'super' @ [103:9] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[LazyClassReceiverParameterDescriptor]

'tearDown' @ [103:15] ==> protected open fun tearDown(): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'File' @ [107:20] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'path' @ [107:25] ==> value-parameter path: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[ValueParameterDescriptorImpl]

'loadFile' @ [108:33] ==> @NotNull public open fun loadFile(@NotNull p0: File, p1: Boolean): String defined in com.intellij.openapi.util.io.FileUtil[JavaMethodDescriptor]

'file' @ [108:42] ==> val file: File defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[LocalVariableDescriptor]

'configureSettings' @ [110:9] ==> protected final fun configureSettings(fileText: String): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'fileText' @ [110:27] ==> val fileText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[LocalVariableDescriptor]

'createAdditionalBreakpoints' @ [111:9] ==> protected final fun createAdditionalBreakpoints(fileText: String): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'fileText' @ [111:37] ==> val fileText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[LocalVariableDescriptor]

'isDirectiveDefined' @ [113:32] ==> public open fun isDirectiveDefined(p0: (String..String?), p1: (String..String?)): Boolean defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'fileText' @ [113:51] ==> val fileText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[LocalVariableDescriptor]

'if (shouldPrintFrame) findListWithPrefixes(fileText, "// SKIP: ") else emptyList()' @ [114:32] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (MutableList<(String..String?)>..List<(String..String?)>), elseBranch: (MutableList<(String..String?)>..List<(String..String?)>)): (MutableList<(String..String?)>..List<(String..String?)>)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (kotlin.collections.MutableList<(kotlin.String..kotlin.String?)>..kotlin.collections.List<(kotlin.String..kotlin.String?)>)

'shouldPrintFrame' @ [114:36] ==> val shouldPrintFrame: Boolean defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[LocalVariableDescriptor]

'findListWithPrefixes' @ [114:54] ==> @NotNull public open fun findListWithPrefixes(@NotNull p0: String, @NotNull vararg p1: (String..String?)): (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'fileText' @ [114:75] ==> val fileText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[LocalVariableDescriptor]

'emptyList' @ [114:103] ==> public fun <T> emptyList(): List<(String..String?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.String..kotlin.String?)

'valueOf' @ [115:59] ==> public final fun valueOf(value: String): AbstractKotlinEvaluateExpressionTest.PrinterConfig.DescriptorViewOptions defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.PrinterConfig.DescriptorViewOptions[SimpleFunctionDescriptorImpl]

'findStringWithPrefixes' @ [115:67] ==> @Nullable public open fun findStringWithPrefixes(p0: (String..String?), vararg p1: (String..String?)): String? defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'fileText' @ [115:90] ==> val fileText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[LocalVariableDescriptor]

'loadTestDirectivesPairs' @ [117:27] ==> private final fun loadTestDirectivesPairs(fileContent: String, directivePrefix: String, expectedPrefix: String): List<Pair<String, String>> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'fileText' @ [117:51] ==> val fileText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[LocalVariableDescriptor]

'findFilesWithBlocks' @ [119:22] ==> private final fun findFilesWithBlocks(mainFile: File): List<File> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'file' @ [119:42] ==> val file: File defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[LocalVariableDescriptor]

'map' @ [119:48] ==> public inline fun <T, R> Iterable<File>.map(transform: (File) -> String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> File
    <R> -> String

'loadFile' @ [119:63] ==> @NotNull public open fun loadFile(@NotNull p0: File, p1: Boolean): String defined in com.intellij.openapi.util.io.FileUtil[JavaMethodDescriptor]

'it' @ [119:72] ==> value-parameter it: File defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest.<anonymous>[ValueParameterDescriptorImpl]

'blocks' @ [120:36] ==> val blocks: List<String> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[LocalVariableDescriptor]

'map' @ [120:43] ==> public inline fun <T, R> Iterable<String>.map(transform: (String) -> String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String
    <R> -> String

'findLinesWithPrefixesRemoved' @ [120:49] ==> @NotNull public open fun findLinesWithPrefixesRemoved(p0: (String..String?), vararg p1: (String..String?)): (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'it' @ [120:78] ==> value-parameter it: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest.<anonymous>[ValueParameterDescriptorImpl]

'joinToString' @ [120:97] ==> public fun <T> Iterable<(String..String?)>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: (((String..String?)) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.String..kotlin.String?)

'createDebugProcess' @ [122:9] ==> @SuppressWarnings protected/*protected and package*/ open fun createDebugProcess(@NotNull path: String): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[JavaMethodDescriptor]

'path' @ [122:28] ==> value-parameter path: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[ValueParameterDescriptorImpl]

'doStepping' @ [124:9] ==> protected final fun doStepping(path: String): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'path' @ [124:20] ==> value-parameter path: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[ValueParameterDescriptorImpl]

'getApplication' @ [129:28] ==> public open fun getApplication(): (Application..Application?) defined in com.intellij.openapi.application.ApplicationManager[JavaMethodDescriptor]

'invokeAndWait' @ [129:45] ==> public final fun invokeAndWait(@NotNull p0: () -> Unit, @NotNull p1: ModalityState): Unit defined in com.intellij.openapi.application.Application[MyFunctionDescriptor]

'variablesView' @ [130:13] ==> var variablesView: XVariablesView? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[LocalVariableDescriptor]

'createVariablesView' @ [130:29] ==> private final fun createVariablesView(): XVariablesView defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'watchesView' @ [131:13] ==> var watchesView: XWatchesViewImpl? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[LocalVariableDescriptor]

'createWatchesView' @ [131:27] ==> private final fun createWatchesView(): XWatchesViewImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'any' @ [132:26] ==> @NotNull public open fun any(): ModalityState defined in com.intellij.openapi.application.ModalityState[JavaMethodDescriptor]

'doOnBreakpoint' @ [134:9] ==> public final fun doOnBreakpoint(action: SuspendContextImpl.() -> Unit): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'linkedMapOf' @ [135:30] ==> @SinceKotlin @InlineOnly public inline fun <K, V> linkedMapOf(): LinkedHashMap<String, Throwable> /* = LinkedHashMap<String, Throwable> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> String
    <V> -> Throwable

'createMarkers' @ [137:17] ==> private final fun createMarkers(fileText: String): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'fileText' @ [137:31] ==> val fileText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[LocalVariableDescriptor]

'component1' @ [139:23] ==> public final operator fun component1(): String defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [139:35] ==> public final operator fun component2(): String defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'expressions' @ [139:48] ==> val expressions: List<Pair<String, String>> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[LocalVariableDescriptor]

'mayThrow' @ [140:21] ==> private final fun mayThrow(map: MutableMap<String, Throwable>, expression: String, f: () -> Unit): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'exceptions' @ [140:30] ==> val exceptions: LinkedHashMap<String, Throwable> /* = LinkedHashMap<String, Throwable> */ defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest.<anonymous>[LocalVariableDescriptor]

'expression' @ [140:42] ==> val expression: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest.<anonymous>[LocalVariableDescriptor]

'evaluate' @ [141:25] ==> private final fun SuspendContextImpl.evaluate(text: String, codeFragmentKind: CodeFragmentKind, expectedResult: String?): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'expression' @ [141:34] ==> val expression: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest.<anonymous>[LocalVariableDescriptor]

'EXPRESSION' @ [141:63] ==> enum entry EXPRESSION defined in com.intellij.debugger.engine.evaluation.CodeFragmentKind[FakeCallableDescriptorForObject]

'expected' @ [141:75] ==> val expected: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest.<anonymous>[LocalVariableDescriptor]

'component1' @ [145:23] ==> public final operator fun component1(): Int defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'component2' @ [145:26] ==> public final operator fun component2(): String defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'blocks' @ [145:36] ==> val blocks: List<String> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[LocalVariableDescriptor]

'withIndex' @ [145:43] ==> public fun <T> Iterable<String>.withIndex(): Iterable<IndexedValue<String>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'mayThrow' @ [146:21] ==> private final fun mayThrow(map: MutableMap<String, Throwable>, expression: String, f: () -> Unit): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'exceptions' @ [146:30] ==> val exceptions: LinkedHashMap<String, Throwable> /* = LinkedHashMap<String, Throwable> */ defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest.<anonymous>[LocalVariableDescriptor]

'block' @ [146:42] ==> val block: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest.<anonymous>[LocalVariableDescriptor]

'evaluate' @ [147:25] ==> private final fun SuspendContextImpl.evaluate(text: String, codeFragmentKind: CodeFragmentKind, expectedResult: String?): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'block' @ [147:34] ==> val block: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest.<anonymous>[LocalVariableDescriptor]

'CODE_BLOCK' @ [147:58] ==> enum entry CODE_BLOCK defined in com.intellij.debugger.engine.evaluation.CodeFragmentKind[FakeCallableDescriptorForObject]

'expectedBlockResults' @ [147:70] ==> val expectedBlockResults: List<String> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[LocalVariableDescriptor]

'i' @ [147:91] ==> val i: Int defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest.<anonymous>[LocalVariableDescriptor]

'if (shouldPrintFrame) {
                    printFrame(variablesView!!, watchesView!!, PrinterConfig(skipInPrintFrame, descriptorViewOptions))
                    println(fileText, ProcessOutputTypes.SYSTEM)
                }
                else {
                    resume(this)
                }' @ [152:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'shouldPrintFrame' @ [152:20] ==> val shouldPrintFrame: Boolean defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[LocalVariableDescriptor]

'printFrame' @ [153:21] ==> private final fun SuspendContextImpl.printFrame(variablesView: XVariablesView, watchesView: XWatchesViewImpl, config: AbstractKotlinEvaluateExpressionTest.PrinterConfig): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'variablesView' @ [153:32] ==> var variablesView: XVariablesView? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[LocalVariableDescriptor]

'watchesView' @ [153:49] ==> var watchesView: XWatchesViewImpl? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[LocalVariableDescriptor]

'PrinterConfig' @ [153:64] ==> public constructor PrinterConfig(variablesToSkipInPrintFrame: List<String> = ..., viewOptions: AbstractKotlinEvaluateExpressionTest.PrinterConfig.DescriptorViewOptions = ...) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.PrinterConfig[ClassConstructorDescriptorImpl]

'skipInPrintFrame' @ [153:78] ==> val skipInPrintFrame: (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[LocalVariableDescriptor]

'descriptorViewOptions' @ [153:96] ==> val descriptorViewOptions: AbstractKotlinEvaluateExpressionTest.PrinterConfig.DescriptorViewOptions defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[LocalVariableDescriptor]

'println' @ [154:21] ==> public open fun println(@NonNls p0: (String..String?), p1: raw (Key<(Any..Any?)>..Key<*>?)): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[JavaMethodDescriptor]

'fileText' @ [154:29] ==> val fileText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest[LocalVariableDescriptor]

'SYSTEM' @ [154:58] ==> public final val SYSTEM: raw (Key<(Any..Any?)>..Key<*>?) defined in com.intellij.execution.process.ProcessOutputTypes[JavaPropertyDescriptor]

'resume' @ [157:21] ==> protected/*protected and package*/ open fun resume(p0: (SuspendContextImpl..SuspendContextImpl?)): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[JavaMethodDescriptor]

'this' @ [157:28] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest.<anonymous>[ReceiverParameterDescriptorImpl]

'checkExceptions' @ [161:13] ==> private final fun checkExceptions(exceptions: MutableMap<String, Throwable>): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'exceptions' @ [161:29] ==> val exceptions: LinkedHashMap<String, Throwable> /* = LinkedHashMap<String, Throwable> */ defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doSingleBreakpointTest.<anonymous>[LocalVariableDescriptor]

'finish' @ [164:9] ==> protected final fun finish(): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'File' @ [168:20] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'path' @ [168:25] ==> value-parameter path: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doMultipleBreakpointsTest[ValueParameterDescriptorImpl]

'loadFile' @ [169:33] ==> @NotNull public open fun loadFile(@NotNull p0: File, p1: Boolean): String defined in com.intellij.openapi.util.io.FileUtil[JavaMethodDescriptor]

'file' @ [169:42] ==> val file: File defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doMultipleBreakpointsTest[LocalVariableDescriptor]

'createAdditionalBreakpoints' @ [171:9] ==> protected final fun createAdditionalBreakpoints(fileText: String): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'fileText' @ [171:37] ==> val fileText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doMultipleBreakpointsTest[LocalVariableDescriptor]

'createDebugProcess' @ [173:9] ==> @SuppressWarnings protected/*protected and package*/ open fun createDebugProcess(@NotNull path: String): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[JavaMethodDescriptor]

'path' @ [173:28] ==> value-parameter path: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doMultipleBreakpointsTest[ValueParameterDescriptorImpl]

'loadTestDirectivesPairs' @ [175:27] ==> private final fun loadTestDirectivesPairs(fileContent: String, directivePrefix: String, expectedPrefix: String): List<Pair<String, String>> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'fileText' @ [175:51] ==> val fileText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doMultipleBreakpointsTest[LocalVariableDescriptor]

'linkedMapOf' @ [177:26] ==> @SinceKotlin @InlineOnly public inline fun <K, V> linkedMapOf(): LinkedHashMap<String, Throwable> /* = LinkedHashMap<String, Throwable> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> String
    <V> -> Throwable

'component1' @ [178:15] ==> public final operator fun component1(): String defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [178:27] ==> public final operator fun component2(): String defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'expressions' @ [178:40] ==> val expressions: List<Pair<String, String>> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doMultipleBreakpointsTest[LocalVariableDescriptor]

'mayThrow' @ [179:13] ==> private final fun mayThrow(map: MutableMap<String, Throwable>, expression: String, f: () -> Unit): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'exceptions' @ [179:22] ==> val exceptions: LinkedHashMap<String, Throwable> /* = LinkedHashMap<String, Throwable> */ defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doMultipleBreakpointsTest[LocalVariableDescriptor]

'expression' @ [179:34] ==> val expression: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doMultipleBreakpointsTest[LocalVariableDescriptor]

'doOnBreakpoint' @ [180:17] ==> public final fun doOnBreakpoint(action: SuspendContextImpl.() -> Unit): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'evaluate' @ [182:25] ==> private final fun SuspendContextImpl.evaluate(text: String, codeFragmentKind: CodeFragmentKind, expectedResult: String?): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'expression' @ [182:34] ==> val expression: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doMultipleBreakpointsTest[LocalVariableDescriptor]

'EXPRESSION' @ [182:63] ==> enum entry EXPRESSION defined in com.intellij.debugger.engine.evaluation.CodeFragmentKind[FakeCallableDescriptorForObject]

'expected' @ [182:75] ==> val expected: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doMultipleBreakpointsTest[LocalVariableDescriptor]

'resume' @ [185:25] ==> protected/*protected and package*/ open fun resume(p0: (SuspendContextImpl..SuspendContextImpl?)): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[JavaMethodDescriptor]

'this' @ [185:32] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doMultipleBreakpointsTest.<anonymous>.<anonymous>[ReceiverParameterDescriptorImpl]

'checkExceptions' @ [191:9] ==> private final fun checkExceptions(exceptions: MutableMap<String, Throwable>): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'exceptions' @ [191:25] ==> val exceptions: LinkedHashMap<String, Throwable> /* = LinkedHashMap<String, Throwable> */ defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.doMultipleBreakpointsTest[LocalVariableDescriptor]

'finish' @ [193:9] ==> protected final fun finish(): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'myDebuggerSession' @ [197:23] ==> protected/*protected and package*/ final var myDebuggerSession: (DebuggerSession..DebuggerSession?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[JavaPropertyDescriptor]

'xDebugSession' @ [197:41] ==> public final val DebuggerSession.xDebugSession: XDebugSession?[MyPropertyDescriptor]

'XWatchesViewImpl' @ [198:27] ==> public constructor XWatchesViewImpl(@NotNull p0: XDebugSessionImpl, p1: Boolean) defined in com.intellij.xdebugger.impl.frame.XWatchesViewImpl[JavaClassConstructorDescriptor]

'session' @ [198:44] ==> val session: XDebugSessionImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createWatchesView[LocalVariableDescriptor]

'register' @ [199:18] ==> public open fun register(@NotNull p0: Disposable, @NotNull p1: Disposable): Unit defined in com.intellij.openapi.util.Disposer[JavaMethodDescriptor]

'testRootDisposable' @ [199:27] ==> public final val AbstractKotlinEvaluateExpressionTest.testRootDisposable: Disposable[MyPropertyDescriptor]

'watchesView' @ [199:47] ==> val watchesView: XWatchesViewImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createWatchesView[LocalVariableDescriptor]

'attach' @ [200:35] ==> public open fun attach(@NotNull p0: XDebugView, @NotNull p1: XDebugSession): Unit defined in com.intellij.xdebugger.impl.frame.XDebugViewSessionListener[JavaMethodDescriptor]

'watchesView' @ [200:42] ==> val watchesView: XWatchesViewImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createWatchesView[LocalVariableDescriptor]

'session' @ [200:55] ==> val session: XDebugSessionImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createWatchesView[LocalVariableDescriptor]

'watchesView' @ [201:16] ==> val watchesView: XWatchesViewImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createWatchesView[LocalVariableDescriptor]

'myDebuggerSession' @ [205:23] ==> protected/*protected and package*/ final var myDebuggerSession: (DebuggerSession..DebuggerSession?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[JavaPropertyDescriptor]

'xDebugSession' @ [205:41] ==> public final val DebuggerSession.xDebugSession: XDebugSession?[MyPropertyDescriptor]

'XVariablesView' @ [206:29] ==> public constructor XVariablesView(@NotNull p0: XDebugSessionImpl) defined in com.intellij.xdebugger.impl.frame.XVariablesView[JavaClassConstructorDescriptor]

'session' @ [206:44] ==> val session: XDebugSessionImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createVariablesView[LocalVariableDescriptor]

'register' @ [207:18] ==> public open fun register(@NotNull p0: Disposable, @NotNull p1: Disposable): Unit defined in com.intellij.openapi.util.Disposer[JavaMethodDescriptor]

'testRootDisposable' @ [207:27] ==> public final val AbstractKotlinEvaluateExpressionTest.testRootDisposable: Disposable[MyPropertyDescriptor]

'variablesView' @ [207:47] ==> val variablesView: XVariablesView defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createVariablesView[LocalVariableDescriptor]

'attach' @ [208:35] ==> public open fun attach(@NotNull p0: XDebugView, @NotNull p1: XDebugSession): Unit defined in com.intellij.xdebugger.impl.frame.XDebugViewSessionListener[JavaMethodDescriptor]

'variablesView' @ [208:42] ==> val variablesView: XVariablesView defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createVariablesView[LocalVariableDescriptor]

'session' @ [208:57] ==> val session: XDebugSessionImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createVariablesView[LocalVariableDescriptor]

'variablesView' @ [209:16] ==> val variablesView: XVariablesView defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createVariablesView[LocalVariableDescriptor]

'variablesView' @ [213:20] ==> value-parameter variablesView: XVariablesView defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.printFrame[ValueParameterDescriptorImpl]

'tree' @ [213:34] ==> public final val XVariablesView.tree: XDebuggerTree[MyPropertyDescriptor]

'expandAll' @ [214:9] ==> protected/*protected and package*/ for synthetic extension final fun expandAll(p0: (Tree..Tree?), p1: (() -> Unit..(() -> Unit)?), p2: (MutableSet<(Value..Value?)>..Set<(Value..Value?)>?), p3: (((TreeNode..TreeNode?)) -> Boolean..(((TreeNode..TreeNode?)) -> Boolean)?), p4: (SuspendContextImpl..SuspendContextImpl?)): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[MyFunctionDescriptor]

'tree' @ [215:17] ==> val tree: XDebuggerTree defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.printFrame[LocalVariableDescriptor]

'Printer' @ [218:25] ==> public constructor Printer(config: AbstractKotlinEvaluateExpressionTest.PrinterConfig) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer[ClassConstructorDescriptorImpl]

'config' @ [218:33] ==> value-parameter config: AbstractKotlinEvaluateExpressionTest.PrinterConfig defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.printFrame[ValueParameterDescriptorImpl]

'printTree' @ [218:41] ==> public final fun printTree(tree: XDebuggerTree): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer[SimpleFunctionDescriptorImpl]

'tree' @ [218:51] ==> val tree: XDebuggerTree defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.printFrame[LocalVariableDescriptor]

'getExtraVars' @ [220:39] ==> public final fun getExtraVars(): Set<TextWithImports> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'watchesView' @ [221:29] ==> value-parameter watchesView: XWatchesViewImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.printFrame[ValueParameterDescriptorImpl]

'addWatchExpression' @ [221:41] ==> public open fun addWatchExpression(@NotNull p0: XExpression, p1: Int, p2: Boolean): Unit defined in com.intellij.xdebugger.impl.frame.XWatchesViewImpl[JavaMethodDescriptor]

'fromText' @ [221:76] ==> @Contract public open fun fromText(@Nullable p0: String?): (XExpressionImpl..XExpressionImpl?) defined in com.intellij.xdebugger.impl.breakpoints.XExpressionImpl[JavaMethodDescriptor]

'extra' @ [221:85] ==> val extra: TextWithImports defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.printFrame.<anonymous>[LocalVariableDescriptor]

'text' @ [221:91] ==> public final var TextWithImports.text: (String..String?)[MyPropertyDescriptor]

'-' @ [221:98] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'Printer' @ [223:25] ==> public constructor Printer(config: AbstractKotlinEvaluateExpressionTest.PrinterConfig) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer[ClassConstructorDescriptorImpl]

'config' @ [223:33] ==> value-parameter config: AbstractKotlinEvaluateExpressionTest.PrinterConfig defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.printFrame[ValueParameterDescriptorImpl]

'printTree' @ [223:41] ==> public final fun printTree(tree: XDebuggerTree): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer[SimpleFunctionDescriptorImpl]

'watchesView' @ [223:51] ==> value-parameter watchesView: XWatchesViewImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.printFrame[ValueParameterDescriptorImpl]

'tree' @ [223:63] ==> public final val XWatchesViewImpl.tree: XDebuggerTree[MyPropertyDescriptor]

'resume' @ [226:25] ==> protected/*protected and package*/ open fun resume(p0: (SuspendContextImpl..SuspendContextImpl?)): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[JavaMethodDescriptor]

'this' @ [226:32] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.printFrame[ReceiverParameterDescriptorImpl]

'hashSetOf' @ [229:17] ==> @SinceKotlin @InlineOnly public inline fun <T> hashSetOf(): HashSet<(Value..Value?)> /* = HashSet<(Value..Value?)> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Value..com.sun.jdi.Value?)

'it' @ [231:19] ==> value-parameter it: (TreeNode..TreeNode?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.printFrame.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [231:44] ==> value-parameter it: (TreeNode..TreeNode?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.printFrame.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [231:47] ==> public final val XValueNodeImpl.name: String?[MyPropertyDescriptor]

'this' @ [232:17] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.printFrame[ReceiverParameterDescriptorImpl]

'KotlinFrameExtraVariablesProvider' @ [237:16] ==> public constructor KotlinFrameExtraVariablesProvider() defined in org.jetbrains.kotlin.idea.debugger.KotlinFrameExtraVariablesProvider[DeserializedClassConstructorDescriptor]

'collectVariables' @ [237:52] ==> public open fun collectVariables(sourcePosition: SourcePosition, evalContext: EvaluationContext, alreadyCollected: MutableSet<String>): Set<TextWithImports> defined in org.jetbrains.kotlin.idea.debugger.KotlinFrameExtraVariablesProvider[DeserializedSimpleFunctionDescriptor]

'debuggerContext' @ [237:69] ==> protected final val debuggerContext: DebuggerContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[PropertyDescriptorImpl]

'sourcePosition' @ [237:85] ==> public final val DebuggerContextImpl.sourcePosition: (SourcePosition..SourcePosition?)[MyPropertyDescriptor]

'evaluationContext' @ [237:101] ==> protected final val evaluationContext: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[PropertyDescriptorImpl]

'hashSetOf' @ [237:120] ==> @SinceKotlin @InlineOnly public inline fun <T> hashSetOf(): HashSet<String> /* = HashSet<String> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'emptyList' @ [241:61] ==> public fun <T> emptyList(): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'FULL' @ [242:76] ==> enum entry FULL defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.PrinterConfig.DescriptorViewOptions[FakeCallableDescriptorForObject]

'when(viewOptions) {
                DescriptorViewOptions.FULL -> true
                else -> false
            }' @ [251:20] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'viewOptions' @ [251:25] ==> public final val viewOptions: AbstractKotlinEvaluateExpressionTest.PrinterConfig.DescriptorViewOptions defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.PrinterConfig[PropertyDescriptorImpl]

'FULL' @ [252:39] ==> enum entry FULL defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.PrinterConfig.DescriptorViewOptions[FakeCallableDescriptorForObject]

'when {
                viewOptions.toString().contains("EXPRESSION") -> true
                else -> false
            }' @ [258:20] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'viewOptions' @ [259:17] ==> public final val viewOptions: AbstractKotlinEvaluateExpressionTest.PrinterConfig.DescriptorViewOptions defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.PrinterConfig[PropertyDescriptorImpl]

'toString' @ [259:29] ==> public open fun toString(): String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.PrinterConfig.DescriptorViewOptions[DeserializedSimpleFunctionDescriptor]

'contains' @ [259:40] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'when {
                descriptor is WatchItemDescriptor -> descriptor.calcValueName()
                viewOptions.toString().contains("NAME") -> descriptor.name ?: descriptor.label
                else -> descriptor.label
            }' @ [265:20] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: String, entry1: String, entry2: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> String

'descriptor' @ [266:17] ==> value-parameter descriptor: NodeDescriptorImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.PrinterConfig.renderLabel[ValueParameterDescriptorImpl]

'descriptor' @ [266:54] ==> value-parameter descriptor: NodeDescriptorImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.PrinterConfig.renderLabel[ValueParameterDescriptorImpl]

'calcValueName' @ [266:65] ==> public open fun calcValueName(): (String..String?) defined in com.intellij.debugger.ui.impl.watch.WatchItemDescriptor[JavaMethodDescriptor]

'viewOptions' @ [267:17] ==> public final val viewOptions: AbstractKotlinEvaluateExpressionTest.PrinterConfig.DescriptorViewOptions defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.PrinterConfig[PropertyDescriptorImpl]

'toString' @ [267:29] ==> public open fun toString(): String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.PrinterConfig.DescriptorViewOptions[DeserializedSimpleFunctionDescriptor]

'contains' @ [267:40] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'descriptor' @ [267:60] ==> value-parameter descriptor: NodeDescriptorImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.PrinterConfig.renderLabel[ValueParameterDescriptorImpl]

'name' @ [267:71] ==> public final val NodeDescriptorImpl.name: (String..String?)[MyPropertyDescriptor]

'descriptor' @ [267:79] ==> value-parameter descriptor: NodeDescriptorImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.PrinterConfig.renderLabel[ValueParameterDescriptorImpl]

'label' @ [267:90] ==> public final var NodeDescriptorImpl.label: (String..String?)[MyPropertyDescriptor]

'descriptor' @ [268:25] ==> value-parameter descriptor: NodeDescriptorImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.PrinterConfig.renderLabel[ValueParameterDescriptorImpl]

'label' @ [268:36] ==> public final var NodeDescriptorImpl.label: (String..String?)[MyPropertyDescriptor]

'viewOptions' @ [273:19] ==> public final val viewOptions: AbstractKotlinEvaluateExpressionTest.PrinterConfig.DescriptorViewOptions defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.PrinterConfig[PropertyDescriptorImpl]

'NAME_EXPRESSION_RESULT' @ [273:56] ==> enum entry NAME_EXPRESSION_RESULT defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.PrinterConfig.DescriptorViewOptions[FakeCallableDescriptorForObject]

'tree' @ [279:24] ==> value-parameter tree: XDebuggerTree defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printTree[ValueParameterDescriptorImpl]

'treeModel' @ [279:29] ==> public final val XDebuggerTree.treeModel: (DefaultTreeModel..DefaultTreeModel?)[MyPropertyDescriptor]

'root' @ [279:39] ==> public final val DefaultTreeModel.root: (Any..Any?)[MyPropertyDescriptor]

'printNode' @ [280:13] ==> private final fun printNode(node: TreeNode, indent: Int): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer[SimpleFunctionDescriptorImpl]

'root' @ [280:23] ==> val root: TreeNode defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printTree[LocalVariableDescriptor]

'when {
                node is DebuggerTreeNodeImpl -> node.descriptor
                node is XValueNodeImpl -> (node.valueContainer as? JavaValue)?.descriptor ?: MessageDescriptor(node.text.toString())
                node is XStackFrameNode -> (node.valueContainer as? JavaStackFrame)?.descriptor
                node is XValueGroupNodeImpl -> (node.valueContainer as? JavaStaticGroup)?.descriptor
                node is WatchesRootNode -> null
                node is WatchNodeImpl -> WatchItemDescriptor(project, TextWithImportsImpl(CodeFragmentKind.EXPRESSION, node.expression.expression))
                node is MessageTreeNode -> MessageDescriptor(node.text.toString())
                else -> MessageDescriptor(node.toString())
            }' @ [284:30] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: NodeDescriptorImpl?, entry1: NodeDescriptorImpl?, entry2: NodeDescriptorImpl?, entry3: NodeDescriptorImpl?, entry4: NodeDescriptorImpl?, entry5: NodeDescriptorImpl?, entry6: NodeDescriptorImpl?, entry7: NodeDescriptorImpl?): NodeDescriptorImpl?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> NodeDescriptorImpl?

'node' @ [285:17] ==> value-parameter node: TreeNode defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printNode[ValueParameterDescriptorImpl]

'node' @ [285:49] ==> value-parameter node: TreeNode defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printNode[ValueParameterDescriptorImpl]

'descriptor' @ [285:54] ==> public final val DebuggerTreeNodeImpl.descriptor: (NodeDescriptorImpl..NodeDescriptorImpl?)[MyPropertyDescriptor]

'node' @ [286:17] ==> value-parameter node: TreeNode defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printNode[ValueParameterDescriptorImpl]

'?:' @ [286:43] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: NodeDescriptorImpl?, right: NodeDescriptorImpl): NodeDescriptorImpl[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> NodeDescriptorImpl

'node' @ [286:44] ==> value-parameter node: TreeNode defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printNode[ValueParameterDescriptorImpl]

'valueContainer' @ [286:49] ==> public final val XValueNodeImpl.valueContainer: XValue[MyPropertyDescriptor]

'descriptor' @ [286:80] ==> public final val JavaValue.descriptor: ValueDescriptorImpl[MyPropertyDescriptor]

'MessageDescriptor' @ [286:94] ==> public constructor MessageDescriptor(p0: (String..String?)) defined in com.intellij.debugger.ui.impl.watch.MessageDescriptor[JavaClassConstructorDescriptor]

'node' @ [286:112] ==> value-parameter node: TreeNode defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printNode[ValueParameterDescriptorImpl]

'text' @ [286:117] ==> public final val XValueNodeImpl.text: SimpleColoredText[MyPropertyDescriptor]

'toString' @ [286:122] ==> public open fun toString(): String defined in com.intellij.ui.SimpleColoredText[JavaMethodDescriptor]

'node' @ [287:17] ==> value-parameter node: TreeNode defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printNode[ValueParameterDescriptorImpl]

'node' @ [287:45] ==> value-parameter node: TreeNode defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printNode[ValueParameterDescriptorImpl]

'valueContainer' @ [287:50] ==> public final val XStackFrameNode.valueContainer: XStackFrame[MyPropertyDescriptor]

'descriptor' @ [287:86] ==> public final val JavaStackFrame.descriptor: StackFrameDescriptorImpl[MyPropertyDescriptor]

'node' @ [288:17] ==> value-parameter node: TreeNode defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printNode[ValueParameterDescriptorImpl]

'node' @ [288:49] ==> value-parameter node: TreeNode defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printNode[ValueParameterDescriptorImpl]

'valueContainer' @ [288:54] ==> public final val XValueGroupNodeImpl.valueContainer: XValueGroup[MyPropertyDescriptor]

'descriptor' @ [288:91] ==> public final val JavaStaticGroup.descriptor: (NodeDescriptorImpl..NodeDescriptorImpl?)[MyPropertyDescriptor]

'node' @ [289:17] ==> value-parameter node: TreeNode defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printNode[ValueParameterDescriptorImpl]

'node' @ [290:17] ==> value-parameter node: TreeNode defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printNode[ValueParameterDescriptorImpl]

'WatchItemDescriptor' @ [290:42] ==> public constructor WatchItemDescriptor(p0: (Project..Project?), p1: (TextWithImports..TextWithImports?)) defined in com.intellij.debugger.ui.impl.watch.WatchItemDescriptor[JavaClassConstructorDescriptor]

'project' @ [290:62] ==> public final val AbstractKotlinEvaluateExpressionTest.project: (Project..Project?)[MyPropertyDescriptor]

'TextWithImportsImpl' @ [290:71] ==> public constructor TextWithImportsImpl(p0: (CodeFragmentKind..CodeFragmentKind?), @NotNull p1: String) defined in com.intellij.debugger.engine.evaluation.TextWithImportsImpl[JavaClassConstructorDescriptor]

'EXPRESSION' @ [290:108] ==> enum entry EXPRESSION defined in com.intellij.debugger.engine.evaluation.CodeFragmentKind[FakeCallableDescriptorForObject]

'node' @ [290:120] ==> value-parameter node: TreeNode defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printNode[ValueParameterDescriptorImpl]

'expression' @ [290:125] ==> public final val WatchNodeImpl.expression: XExpression[MyPropertyDescriptor]

'expression' @ [290:136] ==> public final val XExpression.expression: String[MyPropertyDescriptor]

'node' @ [291:17] ==> value-parameter node: TreeNode defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printNode[ValueParameterDescriptorImpl]

'MessageDescriptor' @ [291:44] ==> public constructor MessageDescriptor(p0: (String..String?)) defined in com.intellij.debugger.ui.impl.watch.MessageDescriptor[JavaClassConstructorDescriptor]

'node' @ [291:62] ==> value-parameter node: TreeNode defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printNode[ValueParameterDescriptorImpl]

'text' @ [291:67] ==> public final val MessageTreeNode.text: SimpleColoredText[MyPropertyDescriptor]

'toString' @ [291:72] ==> public open fun toString(): String defined in com.intellij.ui.SimpleColoredText[JavaMethodDescriptor]

'MessageDescriptor' @ [292:25] ==> public constructor MessageDescriptor(p0: (String..String?)) defined in com.intellij.debugger.ui.impl.watch.MessageDescriptor[JavaClassConstructorDescriptor]

'node' @ [292:43] ==> value-parameter node: TreeNode defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printNode[ValueParameterDescriptorImpl]

'toString' @ [292:48] ==> public open fun toString(): String defined in javax.swing.tree.TreeNode[DeserializedSimpleFunctionDescriptor]

'descriptor' @ [295:17] ==> val descriptor: NodeDescriptorImpl? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printNode[LocalVariableDescriptor]

'printDescriptor' @ [295:39] ==> public final fun printDescriptor(node: TreeNode, descriptor: NodeDescriptorImpl, indent: Int): Boolean defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer[SimpleFunctionDescriptorImpl]

'node' @ [295:55] ==> value-parameter node: TreeNode defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printNode[ValueParameterDescriptorImpl]

'descriptor' @ [295:61] ==> val descriptor: NodeDescriptorImpl? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printNode[LocalVariableDescriptor]

'indent' @ [295:73] ==> value-parameter indent: Int defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printNode[ValueParameterDescriptorImpl]

'printChildren' @ [297:13] ==> private final fun printChildren(node: TreeNode, indent: Int): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer[SimpleFunctionDescriptorImpl]

'node' @ [297:27] ==> value-parameter node: TreeNode defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printNode[ValueParameterDescriptorImpl]

'indent' @ [297:33] ==> value-parameter indent: Int defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printNode[ValueParameterDescriptorImpl]

'descriptor' @ [301:17] ==> value-parameter descriptor: NodeDescriptorImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor[ValueParameterDescriptorImpl]

'config' @ [302:17] ==> private final val config: AbstractKotlinEvaluateExpressionTest.PrinterConfig defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer[PropertyDescriptorImpl]

'variablesToSkipInPrintFrame' @ [302:24] ==> public final val variablesToSkipInPrintFrame: List<String> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.PrinterConfig[PropertyDescriptorImpl]

'contains' @ [302:52] ==> public abstract fun contains(element: String): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'descriptor' @ [302:61] ==> value-parameter descriptor: NodeDescriptorImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor[ValueParameterDescriptorImpl]

'name' @ [302:72] ==> public final val NodeDescriptorImpl.name: (String..String?)[MyPropertyDescriptor]

'config' @ [304:25] ==> private final val config: AbstractKotlinEvaluateExpressionTest.PrinterConfig defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer[PropertyDescriptorImpl]

'renderLabel' @ [304:32] ==> public final fun renderLabel(descriptor: NodeDescriptorImpl): String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.PrinterConfig[SimpleFunctionDescriptorImpl]

'descriptor' @ [304:44] ==> value-parameter descriptor: NodeDescriptorImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor[ValueParameterDescriptorImpl]

'label' @ [307:17] ==> var label: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor[LocalVariableDescriptor]

'UNKNOWN_VALUE_MESSAGE' @ [307:45] ==> public const final val UNKNOWN_VALUE_MESSAGE: String defined in com.intellij.debugger.ui.impl.watch.NodeDescriptorImpl[JavaPropertyDescriptor]

'descriptor' @ [307:70] ==> value-parameter descriptor: NodeDescriptorImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor[ValueParameterDescriptorImpl]

'label' @ [308:17] ==> var label: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor[LocalVariableDescriptor]

'+' @ [308:25] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'getInstance' @ [308:60] ==> public open fun getInstance(): (NodeRendererSettings..NodeRendererSettings?) defined in com.intellij.debugger.settings.NodeRendererSettings[JavaMethodDescriptor]

'classRenderer' @ [308:74] ==> public final val NodeRendererSettings.classRenderer: (ClassRenderer..ClassRenderer?)[MyPropertyDescriptor]

'renderTypeName' @ [308:88] ==> @Nullable public final fun renderTypeName(@Nullable p0: String?): String? defined in com.intellij.debugger.ui.tree.render.ClassRenderer[JavaMethodDescriptor]

'descriptor' @ [308:103] ==> value-parameter descriptor: NodeDescriptorImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor[ValueParameterDescriptorImpl]

'type' @ [308:114] ==> public final val StaticDescriptor.type: (ReferenceType..ReferenceType?)[MyPropertyDescriptor]

'name' @ [308:119] ==> public abstract fun name(): (String..String?) defined in com.sun.jdi.ReferenceType[JavaMethodDescriptor]

'label' @ [310:17] ==> var label: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor[LocalVariableDescriptor]

'endsWith' @ [310:23] ==> public fun String.endsWith(suffix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'COLLECTING_DATA_MESSAGE' @ [310:53] ==> public const final val COLLECTING_DATA_MESSAGE: (String..String?) defined in com.intellij.xdebugger.impl.ui.XDebuggerUIConstants[JavaPropertyDescriptor]

'StringBuilder' @ [312:27] ==> public final fun <init>(): StringBuilder /* = StringBuilder */ defined in kotlin.text.StringBuilder[TypeAliasConstructorDescriptorImpl]

'with' @ [314:13] ==> @InlineOnly public inline fun <T, R> with(receiver: StringBuilder /* = StringBuilder */, block: StringBuilder /* = StringBuilder */.() -> (StringBuilder..StringBuilder?)): (StringBuilder..StringBuilder?) defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> StringBuilder
    <R> -> (java.lang.StringBuilder..java.lang.StringBuilder?)

'builder' @ [314:18] ==> val builder: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor[LocalVariableDescriptor]

'append' @ [315:17] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'repeat' @ [315:28] ==> public fun CharSequence.repeat(n: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'indent' @ [315:35] ==> value-parameter indent: Int defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor[ValueParameterDescriptorImpl]

'append' @ [316:17] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'getPrefix' @ [316:24] ==> private final fun getPrefix(descriptor: NodeDescriptorImpl): String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer[SimpleFunctionDescriptorImpl]

'descriptor' @ [316:34] ==> value-parameter descriptor: NodeDescriptorImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor[ValueParameterDescriptorImpl]

'append' @ [317:17] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'label' @ [317:24] ==> var label: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor[LocalVariableDescriptor]

'config' @ [318:21] ==> private final val config: AbstractKotlinEvaluateExpressionTest.PrinterConfig defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer[PropertyDescriptorImpl]

'shouldRenderSourcesPosition' @ [318:28] ==> public final fun shouldRenderSourcesPosition(): Boolean defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.PrinterConfig[SimpleFunctionDescriptorImpl]

'hasSourcePosition' @ [318:61] ==> private final fun hasSourcePosition(descriptor: NodeDescriptorImpl): Boolean defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer[SimpleFunctionDescriptorImpl]

'descriptor' @ [318:79] ==> value-parameter descriptor: NodeDescriptorImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor[ValueParameterDescriptorImpl]

'debugProcess' @ [319:30] ==> protected/*protected and package*/ for synthetic extension final val AbstractKotlinEvaluateExpressionTest.debugProcess: (DebugProcessImpl..DebugProcessImpl?)[MyPropertyDescriptor]

'invokeInManagerThread' @ [319:43] ==> public fun <T : Any> DebugProcessImpl.invokeInManagerThread(f: (DebuggerContextImpl) -> SourcePosition?): SourcePosition? defined in org.jetbrains.kotlin.idea.debugger[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> SourcePosition

'getSourcePosition' @ [320:48] ==> @Nullable public open fun getSourcePosition(@NotNull p0: NodeDescriptor, @NotNull p1: Project, @NotNull p2: DebuggerContextImpl): SourcePosition? defined in com.intellij.debugger.engine.SourcePositionProvider[JavaMethodDescriptor]

'descriptor' @ [320:66] ==> value-parameter descriptor: NodeDescriptorImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor[ValueParameterDescriptorImpl]

'myProject' @ [320:78] ==> protected/*protected and package*/ final var myProject: (Project..Project?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[JavaPropertyDescriptor]

'debuggerContext' @ [320:89] ==> protected final val debuggerContext: DebuggerContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[PropertyDescriptorImpl]

'append' @ [322:21] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'render' @ [322:38] ==> private final fun render(sp: SourcePosition?): String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer[SimpleFunctionDescriptorImpl]

'sp' @ [322:45] ==> val sp: SourcePosition? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor.<anonymous>[LocalVariableDescriptor]

'config' @ [325:21] ==> private final val config: AbstractKotlinEvaluateExpressionTest.PrinterConfig defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer[PropertyDescriptorImpl]

'shouldRenderExpression' @ [325:28] ==> public final fun shouldRenderExpression(): Boolean defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.PrinterConfig[SimpleFunctionDescriptorImpl]

'descriptor' @ [325:56] ==> value-parameter descriptor: NodeDescriptorImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor[ValueParameterDescriptorImpl]

'debugProcess' @ [326:38] ==> protected/*protected and package*/ for synthetic extension final val AbstractKotlinEvaluateExpressionTest.debugProcess: (DebugProcessImpl..DebugProcessImpl?)[MyPropertyDescriptor]

'invokeInManagerThread' @ [326:51] ==> public fun <T : Any> DebugProcessImpl.invokeInManagerThread(f: (DebuggerContextImpl) -> PsiExpression?): PsiExpression? defined in org.jetbrains.kotlin.idea.debugger[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> PsiExpression

'descriptor' @ [327:25] ==> value-parameter descriptor: NodeDescriptorImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor[ValueParameterDescriptorImpl]

'getTreeEvaluation' @ [327:36] ==> @Nullable public open fun getTreeEvaluation(p0: (JavaValue..JavaValue?), p1: (DebuggerContextImpl..DebuggerContextImpl?)): PsiElement? defined in com.intellij.debugger.ui.impl.watch.ValueDescriptorImpl[JavaMethodDescriptor]

'node' @ [327:55] ==> value-parameter node: TreeNode defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor[ValueParameterDescriptorImpl]

'valueContainer' @ [327:79] ==> public final val XValueNodeImpl.valueContainer: XValue[MyPropertyDescriptor]

'it' @ [327:108] ==> value-parameter it: DebuggerContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'expression' @ [330:25] ==> val expression: PsiExpression? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor.<anonymous>[LocalVariableDescriptor]

'TextWithImportsImpl' @ [331:36] ==> public constructor TextWithImportsImpl(@NotNull p0: PsiElement) defined in com.intellij.debugger.engine.evaluation.TextWithImportsImpl[JavaClassConstructorDescriptor]

'expression' @ [331:56] ==> val expression: PsiExpression? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor.<anonymous>[LocalVariableDescriptor]

'expression' @ [332:39] ==> val expression: PsiExpression? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor.<anonymous>[LocalVariableDescriptor]

'getUserData' @ [332:50] ==> @Nullable public abstract fun <T : (Any..Any?)> getUserData(@NotNull p0: Key<(MutableSet<(String..String?)>..Set<(String..String?)>?)>): (MutableSet<(String..String?)>?..Set<(String..String?)>?) defined in com.intellij.psi.PsiExpression[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> (kotlin.collections.MutableSet<(kotlin.String..kotlin.String?)>..kotlin.collections.Set<(kotlin.String..kotlin.String?)>)

'ADDITIONAL_IMPORTS_KEY' @ [332:89] ==> public final val ADDITIONAL_IMPORTS_KEY: (Key<(MutableSet<(String..String?)>..Set<(String..String?)>?)>..Key<(MutableSet<(String..String?)>..Set<(String..String?)>?)>?) defined in com.intellij.debugger.ui.impl.watch.DebuggerTreeNodeExpression[JavaPropertyDescriptor]

'joinToString' @ [332:114] ==> public fun <T> Iterable<(String..String?)>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: (((String..String?)) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.String..kotlin.String?)

'it' @ [332:129] ==> value-parameter it: (String..String?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'KotlinCodeFragmentFactory' @ [334:44] ==> public constructor KotlinCodeFragmentFactory() defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinCodeFragmentFactory[DeserializedClassConstructorDescriptor]

'createPresentationCodeFragment' @ [334:72] ==> public open fun createPresentationCodeFragment(item: TextWithImports, context: PsiElement?, project: Project): JavaCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinCodeFragmentFactory[DeserializedSimpleFunctionDescriptor]

'TextWithImportsImpl' @ [335:33] ==> public constructor TextWithImportsImpl(p0: (CodeFragmentKind..CodeFragmentKind?), @NotNull p1: String, @NotNull p2: String, @Nullable p3: FileType?) defined in com.intellij.debugger.engine.evaluation.TextWithImportsImpl[JavaClassConstructorDescriptor]

'text' @ [335:53] ==> val text: TextWithImportsImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor.<anonymous>[LocalVariableDescriptor]

'kind' @ [335:58] ==> public final val TextWithImportsImpl.kind: (CodeFragmentKind..CodeFragmentKind?)[MyPropertyDescriptor]

'text' @ [335:64] ==> val text: TextWithImportsImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor.<anonymous>[LocalVariableDescriptor]

'text' @ [335:69] ==> public final var TextWithImportsImpl.text: (String..String?)[MyPropertyDescriptor]

'text' @ [335:75] ==> val text: TextWithImportsImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor.<anonymous>[LocalVariableDescriptor]

'imports' @ [335:80] ==> public final val TextWithImportsImpl.imports: String[MyPropertyDescriptor]

'imports' @ [335:90] ==> val imports: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor.<anonymous>[LocalVariableDescriptor]

'text' @ [335:99] ==> val text: TextWithImportsImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor.<anonymous>[LocalVariableDescriptor]

'fileType' @ [335:104] ==> public final val TextWithImportsImpl.fileType: FileType?[MyPropertyDescriptor]

'debuggerContext' @ [336:33] ==> protected final val debuggerContext: DebuggerContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[PropertyDescriptorImpl]

'sourcePosition' @ [336:49] ==> public final val DebuggerContextImpl.sourcePosition: (SourcePosition..SourcePosition?)[MyPropertyDescriptor]

'elementAt' @ [336:64] ==> public final val SourcePosition.elementAt: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'project' @ [336:75] ==> public final val AbstractKotlinEvaluateExpressionTest.project: (Project..Project?)[MyPropertyDescriptor]

'codeFragment' @ [338:48] ==> val codeFragment: JavaCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor.<anonymous>[LocalVariableDescriptor]

'text' @ [338:61] ==> public final val JavaCodeFragment.text: (String..String?)[MyPropertyDescriptor]

'config' @ [340:29] ==> private final val config: AbstractKotlinEvaluateExpressionTest.PrinterConfig defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer[PropertyDescriptorImpl]

'shouldComputeResultOfCreateExpression' @ [340:36] ==> public final fun shouldComputeResultOfCreateExpression(): Boolean defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.PrinterConfig[SimpleFunctionDescriptorImpl]

'debugProcess' @ [341:29] ==> protected/*protected and package*/ for synthetic extension final val AbstractKotlinEvaluateExpressionTest.debugProcess: (DebugProcessImpl..DebugProcessImpl?)[MyPropertyDescriptor]

'invokeInManagerThread' @ [341:42] ==> public fun <T : Any> DebugProcessImpl.invokeInManagerThread(f: (DebuggerContextImpl) -> Unit?): Unit? defined in org.jetbrains.kotlin.idea.debugger[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> Unit

'it' @ [342:33] ==> value-parameter it: DebuggerContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'suspendContext' @ [342:36] ==> public final val DebuggerContextImpl.suspendContext: SuspendContextImpl?[MyPropertyDescriptor]

'evaluate' @ [342:52] ==> private final fun SuspendContextImpl.evaluate(item: TextWithImportsImpl, expectedResult: String?): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'TextWithImportsImpl' @ [343:41] ==> public constructor TextWithImportsImpl(p0: (CodeFragmentKind..CodeFragmentKind?), @NotNull p1: String, @NotNull p2: String, @Nullable p3: FileType?) defined in com.intellij.debugger.engine.evaluation.TextWithImportsImpl[JavaClassConstructorDescriptor]

'text' @ [343:61] ==> val text: TextWithImportsImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor.<anonymous>[LocalVariableDescriptor]

'kind' @ [343:66] ==> public final val TextWithImportsImpl.kind: (CodeFragmentKind..CodeFragmentKind?)[MyPropertyDescriptor]

'codeFragmentText' @ [343:72] ==> val codeFragmentText: (String..String?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor.<anonymous>[LocalVariableDescriptor]

'codeFragment' @ [343:90] ==> val codeFragment: JavaCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor.<anonymous>[LocalVariableDescriptor]

'importsToString' @ [343:103] ==> public abstract fun importsToString(): (String..String?) defined in com.intellij.psi.JavaCodeFragment[JavaMethodDescriptor]

'text' @ [343:122] ==> val text: TextWithImportsImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor.<anonymous>[LocalVariableDescriptor]

'fileType' @ [343:127] ==> public final val TextWithImportsImpl.fileType: FileType?[MyPropertyDescriptor]

'append' @ [348:25] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'codeFragmentText' @ [348:49] ==> val codeFragmentText: (String..String?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor.<anonymous>[LocalVariableDescriptor]

'append' @ [351:17] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'logDescriptor' @ [354:13] ==> protected/*protected and package*/ open fun logDescriptor(p0: (NodeDescriptorImpl..NodeDescriptorImpl?), p1: (String..String?)): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[JavaMethodDescriptor]

'descriptor' @ [354:27] ==> value-parameter descriptor: NodeDescriptorImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor[ValueParameterDescriptorImpl]

'builder' @ [354:39] ==> val builder: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printDescriptor[LocalVariableDescriptor]

'toString' @ [354:47] ==> public open fun toString(): String defined in java.lang.StringBuilder[JavaMethodDescriptor]

'when (descriptor) {
                is StackFrameDescriptor -> "frame"
                is WatchItemDescriptor -> "extra"
                is LocalVariableDescriptor -> "local"
                is StaticDescriptor -> "static"
                is ThisDescriptorImpl -> "this"
                is FieldDescriptor -> "field"
                is ArrayElementDescriptor -> "element"
                is MessageDescriptor -> ""
                else -> "unknown"
            }' @ [360:26] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: String, entry1: String, entry2: String, entry3: String, entry4: String, entry5: String, entry6: String, entry7: String, entry8: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> String

'descriptor' @ [360:32] ==> value-parameter descriptor: NodeDescriptorImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.getPrefix[ValueParameterDescriptorImpl]

'prefix' @ [371:20] ==> val prefix: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.getPrefix[LocalVariableDescriptor]

'repeat' @ [371:33] ==> public fun CharSequence.repeat(n: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'-' @ [371:40] ==> public final operator fun minus(other: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'length' @ [371:51] ==> public open val length: Int defined in kotlin.String[DeserializedPropertyDescriptor]

'prefix' @ [371:60] ==> val prefix: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.getPrefix[LocalVariableDescriptor]

'length' @ [371:67] ==> public open val length: Int defined in kotlin.String[DeserializedPropertyDescriptor]

'if (descriptor is MessageDescriptor) " - " else " = "' @ [371:77] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'descriptor' @ [371:81] ==> value-parameter descriptor: NodeDescriptorImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.getPrefix[ValueParameterDescriptorImpl]

'when (descriptor) {
                is LocalVariableDescriptor,
                is FieldDescriptor -> true
                else -> false
            }' @ [375:20] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'descriptor' @ [375:26] ==> value-parameter descriptor: NodeDescriptorImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.hasSourcePosition[ValueParameterDescriptorImpl]

'node' @ [383:21] ==> value-parameter node: TreeNode defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printChildren[ValueParameterDescriptorImpl]

'children' @ [383:26] ==> public abstract fun children(): raw (Enumeration<(Any..Any?)>..Enumeration<*>?) defined in javax.swing.tree.TreeNode[JavaMethodDescriptor]

'e' @ [384:20] ==> val e: raw (Enumeration<(Any..Any?)>..Enumeration<*>?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printChildren[LocalVariableDescriptor]

'hasMoreElements' @ [384:22] ==> public abstract fun hasMoreElements(): Boolean defined in java.util.Enumeration[JavaMethodDescriptor]

'printNode' @ [385:17] ==> private final fun printNode(node: TreeNode, indent: Int): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer[SimpleFunctionDescriptorImpl]

'e' @ [385:27] ==> val e: raw (Enumeration<(Any..Any?)>..Enumeration<*>?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printChildren[LocalVariableDescriptor]

'nextElement' @ [385:29] ==> public abstract fun nextElement(): (Any..Any?) defined in java.util.Enumeration[JavaMethodDescriptor]

'indent' @ [385:56] ==> value-parameter indent: Int defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.printChildren[ValueParameterDescriptorImpl]

'renderSourcePosition' @ [390:20] ==> protected final fun renderSourcePosition(sourcePosition: SourcePosition?): String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'sp' @ [390:41] ==> value-parameter sp: SourcePosition? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.Printer.render[ValueParameterDescriptorImpl]

'replace' @ [390:45] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'!' @ [395:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'exceptions' @ [395:14] ==> value-parameter exceptions: MutableMap<String, Throwable> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.checkExceptions[ValueParameterDescriptorImpl]

'isEmpty' @ [395:25] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.MutableMap[DeserializedSimpleFunctionDescriptor]

'exceptions' @ [396:25] ==> value-parameter exceptions: MutableMap<String, Throwable> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.checkExceptions[ValueParameterDescriptorImpl]

'values' @ [396:36] ==> public abstract val values: MutableCollection<Throwable> defined in kotlin.collections.MutableMap[DeserializedPropertyDescriptor]

'exc' @ [397:17] ==> val exc: Throwable defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.checkExceptions[LocalVariableDescriptor]

'printStackTrace' @ [397:21] ==> public open fun printStackTrace(): Unit defined in kotlin.Throwable[JavaMethodDescriptor]

'AssertionError' @ [399:19] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'+' @ [399:34] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'exceptions' @ [399:53] ==> value-parameter exceptions: MutableMap<String, Throwable> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.checkExceptions[ValueParameterDescriptorImpl]

'map' @ [399:64] ==> public inline fun <K, V, R> Map<out String, Throwable>.map(transform: (Map.Entry<String, Throwable>) -> String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> String
    <V> -> Throwable
    <R> -> String

'it' @ [399:85] ==> value-parameter it: Map.Entry<String, Throwable> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.checkExceptions.<anonymous>[ValueParameterDescriptorImpl]

'key' @ [399:88] ==> public abstract val key: String defined in kotlin.collections.Map.Entry[DeserializedPropertyDescriptor]

'it' @ [399:107] ==> value-parameter it: Map.Entry<String, Throwable> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.checkExceptions.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [399:110] ==> public abstract val value: Throwable defined in kotlin.collections.Map.Entry[DeserializedPropertyDescriptor]

'message' @ [399:116] ==> public open val message: String? defined in kotlin.Throwable[DeserializedPropertyDescriptor]

'joinToString' @ [399:128] ==> public fun <T> Iterable<String>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((String) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'invoke' @ [405:13] ==> public abstract operator fun invoke(): Unit defined in kotlin.Function0[FunctionInvokeDescriptor]

'map' @ [408:13] ==> value-parameter map: MutableMap<String, Throwable> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.mayThrow[ValueParameterDescriptorImpl]

'put' @ [408:17] ==> public abstract fun put(key: String, value: Throwable): Throwable? defined in kotlin.collections.MutableMap[DeserializedSimpleFunctionDescriptor]

'expression' @ [408:21] ==> value-parameter expression: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.mayThrow[ValueParameterDescriptorImpl]

'e' @ [408:33] ==> val e: Throwable defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.mayThrow[LocalVariableDescriptor]

'findLinesWithPrefixesRemoved' @ [413:26] ==> @NotNull public open fun findLinesWithPrefixesRemoved(p0: (String..String?), vararg p1: (String..String?)): (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'fileContent' @ [413:55] ==> value-parameter fileContent: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.loadTestDirectivesPairs[ValueParameterDescriptorImpl]

'directivePrefix' @ [413:68] ==> value-parameter directivePrefix: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.loadTestDirectivesPairs[ValueParameterDescriptorImpl]

'findLinesWithPrefixesRemoved' @ [414:24] ==> @NotNull public open fun findLinesWithPrefixesRemoved(p0: (String..String?), vararg p1: (String..String?)): (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'fileContent' @ [414:53] ==> value-parameter fileContent: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.loadTestDirectivesPairs[ValueParameterDescriptorImpl]

'expectedPrefix' @ [414:66] ==> value-parameter expectedPrefix: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.loadTestDirectivesPairs[ValueParameterDescriptorImpl]

'assert' @ [415:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'directives' @ [415:16] ==> val directives: (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.loadTestDirectivesPairs[LocalVariableDescriptor]

'size' @ [415:27] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'expected' @ [415:35] ==> val expected: (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.loadTestDirectivesPairs[LocalVariableDescriptor]

'size' @ [415:44] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'directives' @ [416:16] ==> val directives: (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.loadTestDirectivesPairs[LocalVariableDescriptor]

'zip' @ [416:27] ==> public infix fun <T, R> Iterable<(String..String?)>.zip(other: Iterable<(String..String?)>): List<Pair<(String..String?), (String..String?)>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.String..kotlin.String?)
    <R> -> (kotlin.String..kotlin.String?)

'expected' @ [416:31] ==> val expected: (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.loadTestDirectivesPairs[LocalVariableDescriptor]

'mainFile' @ [420:28] ==> value-parameter mainFile: File defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.findFilesWithBlocks[ValueParameterDescriptorImpl]

'name' @ [420:37] ==> public final val File.name: (String..String?)[MyPropertyDescriptor]

'mainFile' @ [421:16] ==> value-parameter mainFile: File defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.findFilesWithBlocks[ValueParameterDescriptorImpl]

'parentFile' @ [421:25] ==> public final val File.parentFile: (File..File?)[MyPropertyDescriptor]

'listFiles' @ [421:37] ==> public open fun listFiles(): (Array<(File..File?)>..Array<out (File..File?)>?) defined in java.io.File[JavaMethodDescriptor]

'filter' @ [421:50] ==> public inline fun <T> Array<out (File..File?)>.filter(predicate: ((File..File?)) -> Boolean): List<(File..File?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (java.io.File..java.io.File?)

'it' @ [421:59] ==> value-parameter it: (File..File?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.findFilesWithBlocks.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [421:62] ==> public final val File.name: (String..String?)[MyPropertyDescriptor]

'startsWith' @ [421:67] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'mainFileName' @ [421:78] ==> val mainFileName: (String..String?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.findFilesWithBlocks[LocalVariableDescriptor]

'it' @ [421:95] ==> value-parameter it: (File..File?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.findFilesWithBlocks.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [421:98] ==> public final val File.name: (String..String?)[MyPropertyDescriptor]

'mainFileName' @ [421:106] ==> val mainFileName: (String..String?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.findFilesWithBlocks[LocalVariableDescriptor]

'emptyList' @ [421:136] ==> public final fun <T : (Any..Any?)> emptyList(): (MutableList<(File..File?)>..List<(File..File?)>?) defined in java.util.Collections[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> File

'findLinesWithPrefixesRemoved' @ [425:28] ==> @NotNull public open fun findLinesWithPrefixesRemoved(p0: (String..String?), vararg p1: (String..String?)): (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'fileText' @ [425:57] ==> value-parameter fileText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createMarkers[ValueParameterDescriptorImpl]

'labelsAsText' @ [426:13] ==> val labelsAsText: (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createMarkers[LocalVariableDescriptor]

'isEmpty' @ [426:26] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'getMarkupMap' @ [428:44] ==> @Nullable public open fun getMarkupMap(p0: (DebugProcess..DebugProcess?)): (MutableMap<(ObjectReference..ObjectReference?), (ValueMarkup..ValueMarkup?)>?..Map<(ObjectReference..ObjectReference?), (ValueMarkup..ValueMarkup?)>?) defined in com.intellij.debugger.ui.impl.watch.NodeDescriptorImpl[JavaMethodDescriptor]

'debugProcess' @ [428:57] ==> protected/*protected and package*/ for synthetic extension final val AbstractKotlinEvaluateExpressionTest.debugProcess: (DebugProcessImpl..DebugProcessImpl?)[MyPropertyDescriptor]

'labelsAsText' @ [430:29] ==> val labelsAsText: (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createMarkers[LocalVariableDescriptor]

'labelAsText' @ [431:30] ==> val labelAsText: (String..String?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createMarkers[LocalVariableDescriptor]

'split' @ [431:42] ==> public fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = ..., limit: Int = ...): List<String> defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'assert' @ [432:13] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'labelParts' @ [432:20] ==> val labelParts: List<String> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createMarkers[LocalVariableDescriptor]

'size' @ [432:31] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'labelParts' @ [433:37] ==> val labelParts: List<String> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createMarkers[LocalVariableDescriptor]

'trim' @ [433:51] ==> @InlineOnly public inline fun String.trim(): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'labelParts' @ [434:29] ==> val labelParts: List<String> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createMarkers[LocalVariableDescriptor]

'trim' @ [434:43] ==> @InlineOnly public inline fun String.trim(): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'debuggerContext' @ [435:33] ==> protected final val debuggerContext: DebuggerContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[PropertyDescriptorImpl]

'frameProxy' @ [435:49] ==> public final val DebuggerContextImpl.frameProxy: StackFrameProxyImpl?[MyPropertyDescriptor]

'visibleVariableByName' @ [435:62] ==> public open fun visibleVariableByName(p0: (String..String?)): (LocalVariableProxyImpl..LocalVariableProxyImpl?) defined in com.intellij.debugger.jdi.StackFrameProxyImpl[JavaMethodDescriptor]

'localVariableName' @ [435:84] ==> val localVariableName: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createMarkers[LocalVariableDescriptor]

'assert' @ [436:13] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'localVariable' @ [436:20] ==> val localVariable: (LocalVariableProxyImpl..LocalVariableProxyImpl?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createMarkers[LocalVariableDescriptor]

'localVariableName' @ [436:93] ==> val localVariableName: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createMarkers[LocalVariableDescriptor]

'debuggerContext' @ [437:38] ==> protected final val debuggerContext: DebuggerContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[PropertyDescriptorImpl]

'frameProxy' @ [437:54] ==> public final val DebuggerContextImpl.frameProxy: StackFrameProxyImpl?[MyPropertyDescriptor]

'getValue' @ [437:67] ==> public open fun getValue(p0: (LocalVariableProxyImpl..LocalVariableProxyImpl?)): (Value..Value?) defined in com.intellij.debugger.jdi.StackFrameProxyImpl[JavaMethodDescriptor]

'localVariable' @ [437:76] ==> val localVariable: (LocalVariableProxyImpl..LocalVariableProxyImpl?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createMarkers[LocalVariableDescriptor]

'assert' @ [438:13] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'localVariableValue' @ [438:20] ==> val localVariableValue: ObjectReference? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createMarkers[LocalVariableDescriptor]

'localVariableName' @ [438:67] ==> val localVariableName: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createMarkers[LocalVariableDescriptor]

'localVariableValue' @ [439:13] ==> val localVariableValue: ObjectReference? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createMarkers[LocalVariableDescriptor]

'markupMap' @ [440:13] ==> val markupMap: (MutableMap<(ObjectReference..ObjectReference?), (ValueMarkup..ValueMarkup?)>?..Map<(ObjectReference..ObjectReference?), (ValueMarkup..ValueMarkup?)>?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createMarkers[LocalVariableDescriptor]

'put' @ [440:24] ==> public abstract fun put(key: (ObjectReference..ObjectReference?), value: (ValueMarkup..ValueMarkup?)): ValueMarkup? defined in kotlin.collections.MutableMap[DeserializedSimpleFunctionDescriptor]

'localVariableValue' @ [440:28] ==> val localVariableValue: ObjectReference? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createMarkers[LocalVariableDescriptor]

'ValueMarkup' @ [440:48] ==> public constructor ValueMarkup(p0: (String..String?), p1: (Color..Color?), @Nullable p2: String?) defined in com.intellij.xdebugger.impl.ui.tree.ValueMarkup[JavaClassConstructorDescriptor]

'labelName' @ [440:60] ==> val labelName: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createMarkers[LocalVariableDescriptor]

'labelName' @ [440:77] ==> val labelName: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.createMarkers[LocalVariableDescriptor]

'evaluate' @ [445:16] ==> private final fun SuspendContextImpl.evaluate(item: TextWithImportsImpl, expectedResult: String?): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'TextWithImportsImpl' @ [445:25] ==> public constructor TextWithImportsImpl(p0: (CodeFragmentKind..CodeFragmentKind?), @NotNull p1: String, @NotNull p2: String, @Nullable p3: FileType?) defined in com.intellij.debugger.engine.evaluation.TextWithImportsImpl[JavaClassConstructorDescriptor]

'codeFragmentKind' @ [445:45] ==> value-parameter codeFragmentKind: CodeFragmentKind defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.evaluate[ValueParameterDescriptorImpl]

'text' @ [445:63] ==> value-parameter text: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.evaluate[ValueParameterDescriptorImpl]

'INSTANCE' @ [445:88] ==> public final val INSTANCE: (KotlinFileType..KotlinFileType?) defined in org.jetbrains.kotlin.idea.KotlinFileType[JavaPropertyDescriptor]

'expectedResult' @ [445:99] ==> value-parameter expectedResult: String? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.evaluate[ValueParameterDescriptorImpl]

'runReadAction' @ [449:9] ==> public fun <T> runReadAction(action: () -> Unit): Unit defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Unit

'getSourcePosition' @ [450:46] ==> @Nullable public open fun getSourcePosition(@Nullable p0: StackFrameContext?): SourcePosition? defined in com.intellij.debugger.engine.ContextUtil[JavaMethodDescriptor]

'this' @ [450:64] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.evaluate[ReceiverParameterDescriptorImpl]

'!!' @ [452:34] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: PsiElement?): PsiElement[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> PsiElement

'getContextElement' @ [452:46] ==> @Nullable public open fun getContextElement(p0: (StackFrameContext..StackFrameContext?)): PsiElement? defined in com.intellij.debugger.engine.ContextUtil[JavaMethodDescriptor]

'debuggerContext' @ [452:64] ==> protected final val debuggerContext: DebuggerContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[PropertyDescriptorImpl]

'assertTrue' @ [453:20] ==> public open fun assertTrue(p0: (String..String?), p1: Boolean): Unit defined in org.junit.Assert[JavaMethodDescriptor]

'contextElement' @ [453:160] ==> val contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.evaluate.<anonymous>[LocalVariableDescriptor]

'text' @ [453:175] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'KotlinCodeFragmentFactory' @ [454:31] ==> public constructor KotlinCodeFragmentFactory() defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinCodeFragmentFactory[DeserializedClassConstructorDescriptor]

'isContextAccepted' @ [454:59] ==> public open fun isContextAccepted(contextElement: PsiElement?): Boolean defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinCodeFragmentFactory[DeserializedSimpleFunctionDescriptor]

'contextElement' @ [454:77] ==> val contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.evaluate.<anonymous>[LocalVariableDescriptor]

'contextElement' @ [456:13] ==> val contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.evaluate.<anonymous>[LocalVariableDescriptor]

'putCopyableUserData' @ [456:28] ==> public abstract fun <T : (Any..Any?)> putCopyableUserData(p0: (Key<(DebuggerContextImpl..DebuggerContextImpl?)>..Key<(DebuggerContextImpl..DebuggerContextImpl?)>?), @Nullable p1: DebuggerContextImpl?): Unit defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> DebuggerContextImpl

'KotlinCodeFragmentFactory' @ [456:48] ==> public companion object defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinCodeFragmentFactory[FakeCallableDescriptorForObject]

'DEBUG_CONTEXT_FOR_TESTS' @ [456:74] ==> public final val DEBUG_CONTEXT_FOR_TESTS: Key<DebuggerContextImpl> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinCodeFragmentFactory.Companion[DeserializedPropertyDescriptor]

'this@AbstractKotlinEvaluateExpressionTest' @ [456:99] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[LazyClassReceiverParameterDescriptor]

'debuggerContext' @ [456:141] ==> protected final val debuggerContext: DebuggerContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[PropertyDescriptorImpl]

'runActionInSuspendCommand' @ [459:13] ==> private final fun SuspendContextImpl.runActionInSuspendCommand(action: SuspendContextImpl.() -> Unit): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'?:' @ [461:37] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: ExpressionEvaluator?, right: ExpressionEvaluator): ExpressionEvaluator[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> ExpressionEvaluator

'build' @ [461:58] ==> public open fun build(p0: (TextWithImports..TextWithImports?), @Nullable p1: PsiElement?, @Nullable p2: SourcePosition?, @NotNull p3: Project): (ExpressionEvaluator..ExpressionEvaluator?) defined in com.intellij.debugger.engine.evaluation.expression.EvaluatorBuilderImpl[JavaMethodDescriptor]

'item' @ [461:64] ==> value-parameter item: TextWithImportsImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.evaluate[ValueParameterDescriptorImpl]

'contextElement' @ [461:70] ==> val contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.evaluate.<anonymous>[LocalVariableDescriptor]

'sourcePosition' @ [461:86] ==> val sourcePosition: SourcePosition? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.evaluate.<anonymous>[LocalVariableDescriptor]

'project' @ [461:102] ==> public final val AbstractKotlinEvaluateExpressionTest.project: (Project..Project?)[MyPropertyDescriptor]

'AssertionError' @ [462:46] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'evaluator' @ [464:33] ==> val evaluator: ExpressionEvaluator defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.evaluate.<anonymous>.<anonymous>[LocalVariableDescriptor]

'evaluate' @ [464:43] ==> public abstract fun evaluate(p0: (EvaluationContext..EvaluationContext?)): (Value..Value?) defined in com.intellij.debugger.engine.evaluation.expression.ExpressionEvaluator[JavaMethodDescriptor]

'this@AbstractKotlinEvaluateExpressionTest' @ [464:52] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[LazyClassReceiverParameterDescriptor]

'evaluationContext' @ [464:94] ==> protected final val evaluationContext: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[PropertyDescriptorImpl]

'value' @ [465:40] ==> val value: (Value..Value?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.evaluate.<anonymous>.<anonymous>[LocalVariableDescriptor]

'asValue' @ [465:46] ==> public fun Value?.asValue(): Value defined in org.jetbrains.eval4j.jdi[DeserializedSimpleFunctionDescriptor]

'asString' @ [465:56] ==> private final fun Value.asString(): String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[SimpleFunctionDescriptorImpl]

'expectedResult' @ [466:25] ==> value-parameter expectedResult: String? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.evaluate[ValueParameterDescriptorImpl]

'assertTrue' @ [467:32] ==> public open fun assertTrue(p0: (String..String?), p1: Boolean): Unit defined in org.junit.Assert[JavaMethodDescriptor]

'+' @ [467:43] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'item' @ [467:91] ==> value-parameter item: TextWithImportsImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.evaluate[ValueParameterDescriptorImpl]

'text' @ [467:96] ==> public final var TextWithImportsImpl.text: (String..String?)[MyPropertyDescriptor]

'expectedResult' @ [468:58] ==> value-parameter expectedResult: String? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.evaluate[ValueParameterDescriptorImpl]

'actualResult' @ [468:86] ==> val actualResult: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.evaluate.<anonymous>.<anonymous>[LocalVariableDescriptor]

'expectedResult' @ [468:103] ==> value-parameter expectedResult: String? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.evaluate[ValueParameterDescriptorImpl]

'actualResult' @ [468:121] ==> val actualResult: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.evaluate.<anonymous>.<anonymous>[LocalVariableDescriptor]

'assertTrue' @ [472:28] ==> public open fun assertTrue(p0: (String..String?), p1: Boolean): Unit defined in org.junit.Assert[JavaMethodDescriptor]

'+' @ [472:39] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'item' @ [472:89] ==> value-parameter item: TextWithImportsImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.evaluate[ValueParameterDescriptorImpl]

'text' @ [472:94] ==> public final var TextWithImportsImpl.text: (String..String?)[MyPropertyDescriptor]

'expectedResult' @ [473:54] ==> value-parameter expectedResult: String? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.evaluate[ValueParameterDescriptorImpl]

'e' @ [473:83] ==> val e: EvaluateException defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.evaluate.<anonymous>.<anonymous>[LocalVariableDescriptor]

'message' @ [473:85] ==> public open val message: String? defined in com.intellij.debugger.engine.evaluation.EvaluateException[JavaPropertyDescriptor]

'expectedResult' @ [473:98] ==> value-parameter expectedResult: String? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.evaluate[ValueParameterDescriptorImpl]

'e' @ [473:116] ==> val e: EvaluateException defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.evaluate.<anonymous>.<anonymous>[LocalVariableDescriptor]

'message' @ [473:118] ==> public open val message: String? defined in com.intellij.debugger.engine.evaluation.EvaluateException[JavaPropertyDescriptor]

'replaceFirst' @ [473:127] ==> @InlineOnly public inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'ID_PART_REGEX' @ [473:140] ==> private val ID_PART_REGEX: Regex defined in org.jetbrains.kotlin.idea.debugger.evaluate in file AbstractKotlinEvaluateExpressionTest.kt[PropertyDescriptorImpl]

'if (myInProgress) {
            action()
        } else {
            val command = object : SuspendContextCommandImpl(this) {
                override fun contextAction(suspendContext: SuspendContextImpl) {
                    action(suspendContext)
                }
            }

            // Try to execute the action inside a command if we aren't already inside it.
            debuggerContext.debugProcess?.managerThread?.invoke(command) ?: command.contextAction(this)
        }' @ [480:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'myInProgress' @ [480:13] ==> public final var myInProgress: Boolean defined in com.intellij.debugger.engine.SuspendContextImpl[JavaPropertyDescriptor]

'invoke' @ [481:13] ==> public abstract operator fun SuspendContextImpl.invoke(): Unit defined in kotlin.Function1[FunctionInvokeDescriptor]

'SuspendContextCommandImpl' @ [483:36] ==> protected/*protected and package*/ constructor SuspendContextCommandImpl(@Nullable p0: SuspendContextImpl?) defined in com.intellij.debugger.engine.events.SuspendContextCommandImpl[JavaClassConstructorDescriptor]

'this' @ [483:62] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.runActionInSuspendCommand[ReceiverParameterDescriptorImpl]

'invoke' @ [485:21] ==> public abstract operator fun invoke(p1: SuspendContextImpl): Unit defined in kotlin.Function1[FunctionInvokeDescriptor]

'suspendContext' @ [485:28] ==> value-parameter suspendContext: SuspendContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.runActionInSuspendCommand.<no name provided>.contextAction[ValueParameterDescriptorImpl]

'debuggerContext' @ [490:13] ==> protected final val debuggerContext: DebuggerContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest[PropertyDescriptorImpl]

'debugProcess' @ [490:29] ==> public final val DebuggerContextImpl.debugProcess: DebugProcessImpl?[MyPropertyDescriptor]

'managerThread' @ [490:43] ==> public final val DebugProcessImpl.managerThread: (DebuggerManagerThreadImpl..DebuggerManagerThreadImpl?)[MyPropertyDescriptor]

'invoke' @ [490:58] ==> public open operator fun invoke(p0: (DebuggerCommandImpl..DebuggerCommandImpl?)): Unit defined in com.intellij.debugger.engine.DebuggerManagerThreadImpl[JavaMethodDescriptor]

'command' @ [490:65] ==> val command: <no name provided> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.runActionInSuspendCommand[LocalVariableDescriptor]

'command' @ [490:77] ==> val command: <no name provided> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.runActionInSuspendCommand[LocalVariableDescriptor]

'contextAction' @ [490:85] ==> public open fun contextAction(suspendContext: SuspendContextImpl): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.runActionInSuspendCommand.<no name provided>[SimpleFunctionDescriptorImpl]

'this' @ [490:99] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.runActionInSuspendCommand[ReceiverParameterDescriptorImpl]

'this' @ [495:13] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.asString[ReceiverParameterDescriptorImpl]

'this' @ [495:36] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.asString[ReceiverParameterDescriptorImpl]

'value' @ [495:41] ==> public open val value: Any? defined in org.jetbrains.eval4j.ObjectValue[DeserializedPropertyDescriptor]

'this' @ [496:20] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.asString[ReceiverParameterDescriptorImpl]

'toString' @ [496:25] ==> public abstract fun toString(): String defined in org.jetbrains.eval4j.Value[DeserializedSimpleFunctionDescriptor]

'replaceFirst' @ [496:36] ==> @InlineOnly public inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'ID_PART_REGEX' @ [496:49] ==> private val ID_PART_REGEX: Regex defined in org.jetbrains.kotlin.idea.debugger.evaluate in file AbstractKotlinEvaluateExpressionTest.kt[PropertyDescriptorImpl]

'this' @ [498:16] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractKotlinEvaluateExpressionTest.asString[ReceiverParameterDescriptorImpl]

'toString' @ [498:21] ==> public abstract fun toString(): String defined in org.jetbrains.eval4j.Value[DeserializedSimpleFunctionDescriptor]

'toRegex' @ [502:41] ==> @InlineOnly public inline fun String.toRegex(): Regex defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

