'KotlinTestWithEnvironment' @ [27:33] ==> public constructor KotlinTestWithEnvironment() defined in org.jetbrains.kotlin.test.KotlinTestWithEnvironment[JavaClassConstructorDescriptor]

'with' @ [29:9] ==> @InlineOnly public inline fun <T, R> with(receiver: KtStringTemplateExpression, block: KtStringTemplateExpression.() -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtStringTemplateExpression
    <R> -> Unit

'quoted' @ [29:15] ==> private final fun quoted(s: String): KtStringTemplateExpression defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'checkInjection' @ [30:13] ==> private final fun KtStringTemplateExpression.checkInjection(decoded: String, targetToSourceOffsets: Map<Int, Int>, rangeInHost: TextRange? = ...): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'mapOf' @ [30:32] ==> public fun <K, V> mapOf(pair: Pair<Int, Int>): Map<Int, Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Int
    <V> -> Int

'to' @ [30:38] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'assertOneLine' @ [31:13] ==> private final fun KtStringTemplateExpression.assertOneLine(): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'with' @ [33:9] ==> @InlineOnly public inline fun <T, R> with(receiver: KtStringTemplateExpression, block: KtStringTemplateExpression.() -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtStringTemplateExpression
    <R> -> Unit

'quoted' @ [33:15] ==> private final fun quoted(s: String): KtStringTemplateExpression defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'checkInjection' @ [34:13] ==> private final fun KtStringTemplateExpression.checkInjection(decoded: String, targetToSourceOffsets: Map<Int, Int>, rangeInHost: TextRange? = ...): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'mapOf' @ [34:33] ==> public fun <K, V> mapOf(vararg pairs: Pair<Int, Int>): Map<Int, Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Int
    <V> -> Int

'to' @ [34:39] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [34:47] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'assertOneLine' @ [35:13] ==> private final fun KtStringTemplateExpression.assertOneLine(): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'with' @ [37:9] ==> @InlineOnly public inline fun <T, R> with(receiver: KtStringTemplateExpression, block: KtStringTemplateExpression.() -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtStringTemplateExpression
    <R> -> Unit

'quoted' @ [37:15] ==> private final fun quoted(s: String): KtStringTemplateExpression defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'checkInjection' @ [38:13] ==> private final fun KtStringTemplateExpression.checkInjection(decoded: String, targetToSourceOffsets: Map<Int, Int>, rangeInHost: TextRange? = ...): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'mapOf' @ [38:34] ==> public fun <K, V> mapOf(vararg pairs: Pair<Int, Int>): Map<Int, Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Int
    <V> -> Int

'to' @ [38:40] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [38:48] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [38:56] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'checkInjection' @ [39:13] ==> private final fun KtStringTemplateExpression.checkInjection(decoded: String, targetToSourceOffsets: Map<Int, Int>, rangeInHost: TextRange? = ...): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'mapOf' @ [39:33] ==> public fun <K, V> mapOf(vararg pairs: Pair<Int, Int>): Map<Int, Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Int
    <V> -> Int

'to' @ [39:39] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [39:47] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'TextRange' @ [39:70] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'checkInjection' @ [40:13] ==> private final fun KtStringTemplateExpression.checkInjection(decoded: String, targetToSourceOffsets: Map<Int, Int>, rangeInHost: TextRange? = ...): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'mapOf' @ [40:33] ==> public fun <K, V> mapOf(vararg pairs: Pair<Int, Int>): Map<Int, Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Int
    <V> -> Int

'to' @ [40:39] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [40:47] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'TextRange' @ [40:70] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'assertOneLine' @ [41:13] ==> private final fun KtStringTemplateExpression.assertOneLine(): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'checkAllRanges' @ [45:38] ==> private final fun checkAllRanges(str: String): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'checkAllRanges' @ [46:38] ==> private final fun checkAllRanges(str: String): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'checkAllRanges' @ [47:38] ==> private final fun checkAllRanges(str: String): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'checkAllRanges' @ [48:38] ==> private final fun checkAllRanges(str: String): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'assertFalse' @ [51:9] ==> public open fun assertFalse(p0: Boolean): Unit defined in org.jetbrains.kotlin.test.KotlinTestWithEnvironment[JavaMethodDescriptor]

'stringExpression' @ [51:21] ==> private final fun stringExpression(s: String): KtStringTemplateExpression defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'isValidHost' @ [51:44] ==> public final val KtStringTemplateExpression.isValidHost: Boolean[MyPropertyDescriptor]

'assertFalse' @ [52:9] ==> public open fun assertFalse(p0: Boolean): Unit defined in org.jetbrains.kotlin.test.KotlinTestWithEnvironment[JavaMethodDescriptor]

'stringExpression' @ [52:21] ==> private final fun stringExpression(s: String): KtStringTemplateExpression defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'isValidHost' @ [52:45] ==> public final val KtStringTemplateExpression.isValidHost: Boolean[MyPropertyDescriptor]

'with' @ [56:9] ==> @InlineOnly public inline fun <T, R> with(receiver: KtStringTemplateExpression, block: KtStringTemplateExpression.() -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtStringTemplateExpression
    <R> -> Unit

'quoted' @ [56:15] ==> private final fun quoted(s: String): KtStringTemplateExpression defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'checkInjection' @ [57:13] ==> private final fun KtStringTemplateExpression.checkInjection(decoded: String, targetToSourceOffsets: Map<Int, Int>, rangeInHost: TextRange? = ...): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'mapOf' @ [57:34] ==> public fun <K, V> mapOf(vararg pairs: Pair<Int, Int>): Map<Int, Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Int
    <V> -> Int

'to' @ [57:40] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [57:48] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'assertNoInjection' @ [58:13] ==> private final fun KtStringTemplateExpression.assertNoInjection(range: TextRange): KtStringTemplateExpression defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'TextRange' @ [58:31] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'assertNoInjection' @ [59:13] ==> private final fun KtStringTemplateExpression.assertNoInjection(range: TextRange): KtStringTemplateExpression defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'TextRange' @ [59:31] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'assertOneLine' @ [60:13] ==> private final fun KtStringTemplateExpression.assertOneLine(): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'with' @ [63:9] ==> @InlineOnly public inline fun <T, R> with(receiver: KtStringTemplateExpression, block: KtStringTemplateExpression.() -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtStringTemplateExpression
    <R> -> Unit

'quoted' @ [63:15] ==> private final fun quoted(s: String): KtStringTemplateExpression defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'checkInjection' @ [64:13] ==> private final fun KtStringTemplateExpression.checkInjection(decoded: String, targetToSourceOffsets: Map<Int, Int>, rangeInHost: TextRange? = ...): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'mapOf' @ [64:36] ==> public fun <K, V> mapOf(vararg pairs: Pair<Int, Int>): Map<Int, Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Int
    <V> -> Int

'to' @ [64:42] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [64:50] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [64:58] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [64:66] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'checkInjection' @ [65:13] ==> private final fun KtStringTemplateExpression.checkInjection(decoded: String, targetToSourceOffsets: Map<Int, Int>, rangeInHost: TextRange? = ...): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'mapOf' @ [65:33] ==> public fun <K, V> mapOf(vararg pairs: Pair<Int, Int>): Map<Int, Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Int
    <V> -> Int

'to' @ [65:39] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [65:47] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'TextRange' @ [65:70] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'assertNoInjection' @ [66:13] ==> private final fun KtStringTemplateExpression.assertNoInjection(range: TextRange): KtStringTemplateExpression defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'TextRange' @ [66:31] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'checkInjection' @ [67:13] ==> private final fun KtStringTemplateExpression.checkInjection(decoded: String, targetToSourceOffsets: Map<Int, Int>, rangeInHost: TextRange? = ...): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'mapOf' @ [67:35] ==> public fun <K, V> mapOf(vararg pairs: Pair<Int, Int>): Map<Int, Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Int
    <V> -> Int

'to' @ [67:41] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [67:49] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [67:57] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'TextRange' @ [67:80] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'checkInjection' @ [68:13] ==> private final fun KtStringTemplateExpression.checkInjection(decoded: String, targetToSourceOffsets: Map<Int, Int>, rangeInHost: TextRange? = ...): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'mapOf' @ [68:34] ==> public fun <K, V> mapOf(vararg pairs: Pair<Int, Int>): Map<Int, Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Int
    <V> -> Int

'to' @ [68:40] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [68:48] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'TextRange' @ [68:71] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'checkInjection' @ [69:13] ==> private final fun KtStringTemplateExpression.checkInjection(decoded: String, targetToSourceOffsets: Map<Int, Int>, rangeInHost: TextRange? = ...): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'mapOf' @ [69:35] ==> public fun <K, V> mapOf(vararg pairs: Pair<Int, Int>): Map<Int, Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Int
    <V> -> Int

'to' @ [69:41] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [69:49] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [69:57] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'TextRange' @ [69:80] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'assertOneLine' @ [70:13] ==> private final fun KtStringTemplateExpression.assertOneLine(): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'with' @ [75:9] ==> @InlineOnly public inline fun <T, R> with(receiver: KtStringTemplateExpression, block: KtStringTemplateExpression.() -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtStringTemplateExpression
    <R> -> Unit

'tripleQuoted' @ [75:15] ==> private final fun tripleQuoted(s: String): KtStringTemplateExpression defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'checkInjection' @ [76:13] ==> private final fun KtStringTemplateExpression.checkInjection(decoded: String, targetToSourceOffsets: Map<Int, Int>, rangeInHost: TextRange? = ...): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'mapOf' @ [76:32] ==> public fun <K, V> mapOf(pair: Pair<Int, Int>): Map<Int, Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Int
    <V> -> Int

'to' @ [76:38] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'assertMultiLine' @ [77:13] ==> private final fun KtStringTemplateExpression.assertMultiLine(): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'with' @ [79:9] ==> @InlineOnly public inline fun <T, R> with(receiver: KtStringTemplateExpression, block: KtStringTemplateExpression.() -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtStringTemplateExpression
    <R> -> Unit

'tripleQuoted' @ [79:15] ==> private final fun tripleQuoted(s: String): KtStringTemplateExpression defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'checkInjection' @ [80:13] ==> private final fun KtStringTemplateExpression.checkInjection(decoded: String, targetToSourceOffsets: Map<Int, Int>, rangeInHost: TextRange? = ...): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'mapOf' @ [80:33] ==> public fun <K, V> mapOf(vararg pairs: Pair<Int, Int>): Map<Int, Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Int
    <V> -> Int

'to' @ [80:39] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [80:47] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'assertMultiLine' @ [81:13] ==> private final fun KtStringTemplateExpression.assertMultiLine(): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'with' @ [83:9] ==> @InlineOnly public inline fun <T, R> with(receiver: KtStringTemplateExpression, block: KtStringTemplateExpression.() -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtStringTemplateExpression
    <R> -> Unit

'tripleQuoted' @ [83:15] ==> private final fun tripleQuoted(s: String): KtStringTemplateExpression defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'checkInjection' @ [84:13] ==> private final fun KtStringTemplateExpression.checkInjection(decoded: String, targetToSourceOffsets: Map<Int, Int>, rangeInHost: TextRange? = ...): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'mapOf' @ [84:34] ==> public fun <K, V> mapOf(vararg pairs: Pair<Int, Int>): Map<Int, Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Int
    <V> -> Int

'to' @ [84:40] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [84:48] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [84:56] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'checkInjection' @ [85:13] ==> private final fun KtStringTemplateExpression.checkInjection(decoded: String, targetToSourceOffsets: Map<Int, Int>, rangeInHost: TextRange? = ...): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'mapOf' @ [85:33] ==> public fun <K, V> mapOf(vararg pairs: Pair<Int, Int>): Map<Int, Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Int
    <V> -> Int

'to' @ [85:39] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [85:47] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'TextRange' @ [85:70] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'checkInjection' @ [86:13] ==> private final fun KtStringTemplateExpression.checkInjection(decoded: String, targetToSourceOffsets: Map<Int, Int>, rangeInHost: TextRange? = ...): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'mapOf' @ [86:33] ==> public fun <K, V> mapOf(vararg pairs: Pair<Int, Int>): Map<Int, Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Int
    <V> -> Int

'to' @ [86:39] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [86:47] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'TextRange' @ [86:70] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'assertMultiLine' @ [87:13] ==> private final fun KtStringTemplateExpression.assertMultiLine(): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'with' @ [92:9] ==> @InlineOnly public inline fun <T, R> with(receiver: KtStringTemplateExpression, block: KtStringTemplateExpression.() -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtStringTemplateExpression
    <R> -> Unit

'tripleQuoted' @ [92:15] ==> private final fun tripleQuoted(s: String): KtStringTemplateExpression defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'checkInjection' @ [93:13] ==> private final fun KtStringTemplateExpression.checkInjection(decoded: String, targetToSourceOffsets: Map<Int, Int>, rangeInHost: TextRange? = ...): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'mapOf' @ [93:35] ==> public fun <K, V> mapOf(vararg pairs: Pair<Int, Int>): Map<Int, Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Int
    <V> -> Int

'to' @ [93:41] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [93:49] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [93:57] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'checkInjection' @ [94:13] ==> private final fun KtStringTemplateExpression.checkInjection(decoded: String, targetToSourceOffsets: Map<Int, Int>, rangeInHost: TextRange? = ...): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'mapOf' @ [94:34] ==> public fun <K, V> mapOf(vararg pairs: Pair<Int, Int>): Map<Int, Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Int
    <V> -> Int

'to' @ [94:40] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [94:48] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'TextRange' @ [94:71] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'checkInjection' @ [95:13] ==> private final fun KtStringTemplateExpression.checkInjection(decoded: String, targetToSourceOffsets: Map<Int, Int>, rangeInHost: TextRange? = ...): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'mapOf' @ [95:33] ==> public fun <K, V> mapOf(vararg pairs: Pair<Int, Int>): Map<Int, Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Int
    <V> -> Int

'to' @ [95:39] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [95:47] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'TextRange' @ [95:70] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'assertMultiLine' @ [96:13] ==> private final fun KtStringTemplateExpression.assertMultiLine(): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'with' @ [101:9] ==> @InlineOnly public inline fun <T, R> with(receiver: KtStringTemplateExpression, block: KtStringTemplateExpression.() -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtStringTemplateExpression
    <R> -> Unit

'tripleQuoted' @ [101:15] ==> private final fun tripleQuoted(s: String): KtStringTemplateExpression defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'checkInjection' @ [102:13] ==> private final fun KtStringTemplateExpression.checkInjection(decoded: String, targetToSourceOffsets: Map<Int, Int>, rangeInHost: TextRange? = ...): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'mapOf' @ [102:36] ==> public fun <K, V> mapOf(vararg pairs: Pair<Int, Int>): Map<Int, Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Int
    <V> -> Int

'to' @ [102:42] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [102:50] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [102:58] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'to' @ [102:66] ==> public infix fun <A, B> Int.to(that: Int): Pair<Int, Int> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Int
    <B> -> Int

'assertMultiLine' @ [103:13] ==> private final fun KtStringTemplateExpression.assertMultiLine(): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'stringExpression' @ [108:16] ==> private final fun stringExpression(s: String): KtStringTemplateExpression defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

's' @ [108:37] ==> value-parameter s: String defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.quoted[ValueParameterDescriptorImpl]

'stringExpression' @ [112:16] ==> private final fun stringExpression(s: String): KtStringTemplateExpression defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

's' @ [112:41] ==> value-parameter s: String defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.tripleQuoted[ValueParameterDescriptorImpl]

'KtPsiFactory' @ [116:16] ==> @JvmOverloads public constructor KtPsiFactory(project: Project, markGenerated: Boolean = ...) defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedClassConstructorDescriptor]

'project' @ [116:29] ==> public final val StringInjectionHostTest.project: Project[MyPropertyDescriptor]

'createExpression' @ [116:38] ==> public final fun createExpression(text: String): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

's' @ [116:55] ==> value-parameter s: String defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.stringExpression[ValueParameterDescriptorImpl]

'assertTrue' @ [120:9] ==> public open fun assertTrue(p0: Boolean): Unit defined in org.jetbrains.kotlin.test.KotlinTestWithEnvironment[JavaMethodDescriptor]

'isValidHost' @ [120:20] ==> public final val KtStringTemplateExpression.isValidHost: Boolean[MyPropertyDescriptor]

'assertFalse' @ [121:9] ==> public open fun assertFalse(p0: Boolean): Unit defined in org.jetbrains.kotlin.test.KotlinTestWithEnvironment[JavaMethodDescriptor]

'createLiteralTextEscaper' @ [121:21] ==> @NotNull public open fun createLiteralTextEscaper(): LiteralTextEscaper<out (PsiLanguageInjectionHost..PsiLanguageInjectionHost?)> defined in org.jetbrains.kotlin.psi.KtStringTemplateExpression[JavaMethodDescriptor]

'decode' @ [121:48] ==> public abstract fun decode(@NotNull p0: TextRange, @NotNull p1: StringBuilder): Boolean defined in com.intellij.psi.LiteralTextEscaper[JavaMethodDescriptor]

'range' @ [121:55] ==> value-parameter range: TextRange defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.assertNoInjection[ValueParameterDescriptorImpl]

'StringBuilder' @ [121:62] ==> public final fun <init>(): StringBuilder /* = StringBuilder */ defined in kotlin.text.StringBuilder[TypeAliasConstructorDescriptorImpl]

'this' @ [122:16] ==> <this> defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.assertNoInjection[ReceiverParameterDescriptorImpl]

'assertTrue' @ [126:9] ==> public open fun assertTrue(p0: Boolean): Unit defined in org.jetbrains.kotlin.test.KotlinTestWithEnvironment[JavaMethodDescriptor]

'createLiteralTextEscaper' @ [126:20] ==> @NotNull public open fun createLiteralTextEscaper(): LiteralTextEscaper<out (PsiLanguageInjectionHost..PsiLanguageInjectionHost?)> defined in org.jetbrains.kotlin.psi.KtStringTemplateExpression[JavaMethodDescriptor]

'isOneLine' @ [126:47] ==> public final val <T : (PsiLanguageInjectionHost..PsiLanguageInjectionHost?)> LiteralTextEscaper<out (PsiLanguageInjectionHost..PsiLanguageInjectionHost?)>.isOneLine: Boolean[MyPropertyDescriptor]
Inferred types:
    <T : (PsiLanguageInjectionHost..PsiLanguageInjectionHost?)> -> Captured(out (com.intellij.psi.PsiLanguageInjectionHost..com.intellij.psi.PsiLanguageInjectionHost?))

'assertFalse' @ [130:9] ==> public open fun assertFalse(p0: Boolean): Unit defined in org.jetbrains.kotlin.test.KotlinTestWithEnvironment[JavaMethodDescriptor]

'createLiteralTextEscaper' @ [130:21] ==> @NotNull public open fun createLiteralTextEscaper(): LiteralTextEscaper<out (PsiLanguageInjectionHost..PsiLanguageInjectionHost?)> defined in org.jetbrains.kotlin.psi.KtStringTemplateExpression[JavaMethodDescriptor]

'isOneLine' @ [130:48] ==> public final val <T : (PsiLanguageInjectionHost..PsiLanguageInjectionHost?)> LiteralTextEscaper<out (PsiLanguageInjectionHost..PsiLanguageInjectionHost?)>.isOneLine: Boolean[MyPropertyDescriptor]
Inferred types:
    <T : (PsiLanguageInjectionHost..PsiLanguageInjectionHost?)> -> Captured(out (com.intellij.psi.PsiLanguageInjectionHost..com.intellij.psi.PsiLanguageInjectionHost?))

'with' @ [134:9] ==> @InlineOnly public inline fun <T, R> with(receiver: KtStringTemplateExpression, block: KtStringTemplateExpression.() -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtStringTemplateExpression
    <R> -> Unit

'quoted' @ [134:15] ==> private final fun quoted(s: String): KtStringTemplateExpression defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'str' @ [134:22] ==> value-parameter str: String defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkAllRanges[ValueParameterDescriptorImpl]

'checkInjection' @ [135:13] ==> private final fun KtStringTemplateExpression.checkInjection(decoded: String, targetToSourceOffsets: Map<Int, Int>, rangeInHost: TextRange? = ...): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'str' @ [135:28] ==> value-parameter str: String defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkAllRanges[ValueParameterDescriptorImpl]

'..' @ [135:34] ==> public final operator fun rangeTo(other: Int): IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'str' @ [135:37] ==> value-parameter str: String defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkAllRanges[ValueParameterDescriptorImpl]

'length' @ [135:41] ==> public open val length: Int defined in kotlin.String[DeserializedPropertyDescriptor]

'keysToMap' @ [135:49] ==> public fun <K, V> Iterable<Int>.keysToMap(value: (Int) -> Int): Map<Int, Int> defined in org.jetbrains.kotlin.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Int
    <V> -> Int

'it' @ [135:61] ==> value-parameter it: Int defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkAllRanges.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'assertOneLine' @ [136:13] ==> private final fun KtStringTemplateExpression.assertOneLine(): Unit defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[SimpleFunctionDescriptorImpl]

'assertTrue' @ [143:9] ==> public open fun assertTrue(p0: Boolean): Unit defined in org.jetbrains.kotlin.test.KotlinTestWithEnvironment[JavaMethodDescriptor]

'isValidHost' @ [143:20] ==> public final val KtStringTemplateExpression.isValidHost: Boolean[MyPropertyDescriptor]

'listOf' @ [144:24] ==> public fun <T> listOf(vararg elements: String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'createLiteralTextEscaper' @ [145:27] ==> @NotNull public open fun createLiteralTextEscaper(): LiteralTextEscaper<out (PsiLanguageInjectionHost..PsiLanguageInjectionHost?)> defined in org.jetbrains.kotlin.psi.KtStringTemplateExpression[JavaMethodDescriptor]

'StringBuilder' @ [146:25] ==> public final fun <init>(p0: (String..String?)): StringBuilder /* = StringBuilder */ defined in kotlin.text.StringBuilder[TypeAliasConstructorDescriptorImpl]

'prefix' @ [146:39] ==> val prefix: String defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkInjection[LocalVariableDescriptor]

'rangeInHost' @ [147:25] ==> value-parameter rangeInHost: TextRange? = ... defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkInjection[ValueParameterDescriptorImpl]

'escaper' @ [147:40] ==> val escaper: LiteralTextEscaper<out (PsiLanguageInjectionHost..PsiLanguageInjectionHost?)> defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkInjection[LocalVariableDescriptor]

'relevantTextRange' @ [147:48] ==> public final val <T : (PsiLanguageInjectionHost..PsiLanguageInjectionHost?)> LiteralTextEscaper<out (PsiLanguageInjectionHost..PsiLanguageInjectionHost?)>.relevantTextRange: TextRange[MyPropertyDescriptor]
Inferred types:
    <T : (PsiLanguageInjectionHost..PsiLanguageInjectionHost?)> -> Captured(out (com.intellij.psi.PsiLanguageInjectionHost..com.intellij.psi.PsiLanguageInjectionHost?))

'assertTrue' @ [149:13] ==> public open fun assertTrue(p0: Boolean): Unit defined in org.jetbrains.kotlin.test.KotlinTestWithEnvironment[JavaMethodDescriptor]

'escaper' @ [149:24] ==> val escaper: LiteralTextEscaper<out (PsiLanguageInjectionHost..PsiLanguageInjectionHost?)> defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkInjection[LocalVariableDescriptor]

'decode' @ [149:32] ==> public abstract fun decode(@NotNull p0: TextRange, @NotNull p1: StringBuilder): Boolean defined in com.intellij.psi.LiteralTextEscaper[JavaMethodDescriptor]

'range' @ [149:39] ==> val range: TextRange defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkInjection[LocalVariableDescriptor]

'chars' @ [149:46] ==> val chars: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkInjection[LocalVariableDescriptor]

'assertEquals' @ [150:13] ==> public open fun assertEquals(p0: (String..String?), p1: (String..String?)): Unit defined in org.jetbrains.kotlin.test.KotlinTestWithEnvironment[JavaMethodDescriptor]

'decoded' @ [150:26] ==> value-parameter decoded: String defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkInjection[ValueParameterDescriptorImpl]

'chars' @ [150:35] ==> val chars: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkInjection[LocalVariableDescriptor]

'substring' @ [150:41] ==> public open fun substring(p0: Int): (String..String?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'prefix' @ [150:51] ==> val prefix: String defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkInjection[LocalVariableDescriptor]

'length' @ [150:58] ==> public open val length: Int defined in kotlin.String[DeserializedPropertyDescriptor]

'HashMap' @ [152:35] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>(p0: (MutableMap<out (Int..Int?), out (Int..Int?)>..Map<out (Int..Int?), (Int..Int?)>?)) defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (kotlin.Int..kotlin.Int?)
    <V : (Any..Any?)> -> (kotlin.Int..kotlin.Int?)

'targetToSourceOffsets' @ [152:43] ==> value-parameter targetToSourceOffsets: Map<Int, Int> defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkInjection[ValueParameterDescriptorImpl]

'targetToSourceOffsets' @ [153:31] ==> value-parameter targetToSourceOffsets: Map<Int, Int> defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkInjection[ValueParameterDescriptorImpl]

'keys' @ [153:53] ==> public abstract val keys: Set<Int> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'min' @ [153:58] ==> public fun <T : Comparable<Int>> Iterable<Int>.min(): Int? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Comparable<T>> -> Int

'beforeStart' @ [154:17] ==> val beforeStart: Int defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkInjection[LocalVariableDescriptor]

'extendedOffsets' @ [155:17] ==> val extendedOffsets: HashMap<(Int..Int?), (Int..Int?)> defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkInjection[LocalVariableDescriptor]

'beforeStart' @ [155:33] ==> val beforeStart: Int defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkInjection[LocalVariableDescriptor]

'-' @ [155:48] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'extendedOffsets' @ [157:13] ==> val extendedOffsets: HashMap<(Int..Int?), (Int..Int?)> defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkInjection[LocalVariableDescriptor]

'targetToSourceOffsets' @ [157:29] ==> value-parameter targetToSourceOffsets: Map<Int, Int> defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkInjection[ValueParameterDescriptorImpl]

'keys' @ [157:51] ==> public abstract val keys: Set<Int> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'max' @ [157:56] ==> public fun <T : Comparable<Int>> Iterable<Int>.max(): Int? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Comparable<T>> -> Int

'-' @ [157:71] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'component1' @ [158:19] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(Int..Int?), (Int..Int?)>.component1(): (Int..Int?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (kotlin.Int..kotlin.Int?)
    <V> -> (kotlin.Int..kotlin.Int?)

'component2' @ [158:27] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(Int..Int?), (Int..Int?)>.component2(): (Int..Int?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (kotlin.Int..kotlin.Int?)
    <V> -> (kotlin.Int..kotlin.Int?)

'extendedOffsets' @ [158:38] ==> val extendedOffsets: HashMap<(Int..Int?), (Int..Int?)> defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkInjection[LocalVariableDescriptor]

'assertEquals' @ [159:17] ==> public open fun assertEquals(p0: (String..String?), p1: Int, p2: Int): Unit defined in org.jetbrains.kotlin.test.KotlinTestWithEnvironment[JavaMethodDescriptor]

'target' @ [159:56] ==> val target: (Int..Int?) defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkInjection[LocalVariableDescriptor]

'source' @ [159:65] ==> val source: (Int..Int?) defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkInjection[LocalVariableDescriptor]

'escaper' @ [159:73] ==> val escaper: LiteralTextEscaper<out (PsiLanguageInjectionHost..PsiLanguageInjectionHost?)> defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkInjection[LocalVariableDescriptor]

'getOffsetInHost' @ [159:81] ==> public abstract fun getOffsetInHost(p0: Int, @NotNull p1: TextRange): Int defined in com.intellij.psi.LiteralTextEscaper[JavaMethodDescriptor]

'target' @ [159:97] ==> val target: (Int..Int?) defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkInjection[LocalVariableDescriptor]

'range' @ [159:105] ==> val range: TextRange defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest.checkInjection[LocalVariableDescriptor]

'createEnvironmentWithMockJdk' @ [164:40] ==> @NotNull protected/*protected and package*/ open fun createEnvironmentWithMockJdk(@NotNull p0: ConfigurationKind): KotlinCoreEnvironment defined in org.jetbrains.kotlin.psi.injection.StringInjectionHostTest[JavaMethodDescriptor]

'JDK_ONLY' @ [164:87] ==> enum entry JDK_ONLY defined in org.jetbrains.kotlin.test.ConfigurationKind[FakeCallableDescriptorForObject]

