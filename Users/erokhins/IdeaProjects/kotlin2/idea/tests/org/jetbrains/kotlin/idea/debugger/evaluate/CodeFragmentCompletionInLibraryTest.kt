'+' @ [36:32] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'getHomeDirectory' @ [36:48] ==> @NotNull public open fun getHomeDirectory(): String defined in org.jetbrains.kotlin.test.KotlinTestUtils[JavaMethodDescriptor]

'AbstractJvmBasicCompletionTest' @ [38:45] ==> public constructor AbstractJvmBasicCompletionTest() defined in org.jetbrains.kotlin.idea.completion.test.AbstractJvmBasicCompletionTest[JavaClassConstructorDescriptor]

'JdkAndMockLibraryProjectDescriptor' @ [40:51] ==> public constructor JdkAndMockLibraryProjectDescriptor(sourcesPath: (String..String?), withSources: Boolean) defined in org.jetbrains.kotlin.idea.test.JdkAndMockLibraryProjectDescriptor[JavaClassConstructorDescriptor]

'LIBRARY_SRC_PATH' @ [40:86] ==> private val LIBRARY_SRC_PATH: String defined in org.jetbrains.kotlin.idea.debugger.evaluate in file CodeFragmentCompletionInLibraryTest.kt[PropertyDescriptorImpl]

'super' @ [42:13] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest.getProjectDescriptor.<no name provided>[LazyClassReceiverParameterDescriptor]

'configureModule' @ [42:19] ==> @Override public open fun configureModule(@NotNull module: Module, @NotNull model: ModifiableRootModel): Unit defined in org.jetbrains.kotlin.idea.test.JdkAndMockLibraryProjectDescriptor[JavaMethodDescriptor]

'module' @ [42:35] ==> value-parameter module: Module defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest.getProjectDescriptor.<no name provided>.configureModule[ValueParameterDescriptorImpl]

'model' @ [42:43] ==> value-parameter model: ModifiableRootModel defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest.getProjectDescriptor.<no name provided>.configureModule[ValueParameterDescriptorImpl]

'model' @ [44:27] ==> value-parameter model: ModifiableRootModel defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest.getProjectDescriptor.<no name provided>.configureModule[ValueParameterDescriptorImpl]

'moduleLibraryTable' @ [44:33] ==> public final val ModifiableRootModel.moduleLibraryTable: LibraryTable[MyPropertyDescriptor]

'getLibraryByName' @ [44:52] ==> @Nullable public abstract fun getLibraryByName(@NotNull p0: String): Library? defined in com.intellij.openapi.roots.libraries.LibraryTable[JavaMethodDescriptor]

'LIBRARY_NAME' @ [44:104] ==> public const final val LIBRARY_NAME: String defined in org.jetbrains.kotlin.idea.test.JdkAndMockLibraryProjectDescriptor[JavaPropertyDescriptor]

'library' @ [45:35] ==> val library: Library defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest.getProjectDescriptor.<no name provided>.configureModule[LocalVariableDescriptor]

'modifiableModel' @ [45:43] ==> public final val Library.modifiableModel: Library.ModifiableModel[MyPropertyDescriptor]

'modifiableModel' @ [47:13] ==> val modifiableModel: Library.ModifiableModel defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest.getProjectDescriptor.<no name provided>.configureModule[LocalVariableDescriptor]

'addRoot' @ [47:29] ==> public abstract fun addRoot(@NotNull p0: VirtualFile, @NotNull p1: OrderRootType): Unit defined in com.intellij.openapi.roots.libraries.Library.ModifiableModel[JavaMethodDescriptor]

'findLibrarySourceDir' @ [47:37] ==> private final fun findLibrarySourceDir(): VirtualFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest[SimpleFunctionDescriptorImpl]

'SOURCES' @ [47:75] ==> public final val SOURCES: (OrderRootType..OrderRootType?) defined in com.intellij.openapi.roots.OrderRootType[JavaPropertyDescriptor]

'modifiableModel' @ [48:13] ==> val modifiableModel: Library.ModifiableModel defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest.getProjectDescriptor.<no name provided>.configureModule[LocalVariableDescriptor]

'commit' @ [48:29] ==> public abstract fun commit(): Unit defined in com.intellij.openapi.roots.libraries.Library.ModifiableModel[JavaMethodDescriptor]

'testCompletionInLibraryCodeFragment' @ [53:9] ==> private final fun testCompletionInLibraryCodeFragment(fragmentText: String, vararg completionDirectives: String): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest[SimpleFunctionDescriptorImpl]

'testCompletionInLibraryCodeFragment' @ [57:9] ==> private final fun testCompletionInLibraryCodeFragment(fragmentText: String, vararg completionDirectives: String): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest[SimpleFunctionDescriptorImpl]

'testCompletionInLibraryCodeFragment' @ [61:9] ==> private final fun testCompletionInLibraryCodeFragment(fragmentText: String, vararg completionDirectives: String): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest[SimpleFunctionDescriptorImpl]

'testCompletionInLibraryCodeFragment' @ [65:9] ==> private final fun testCompletionInLibraryCodeFragment(fragmentText: String, vararg completionDirectives: String): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest[SimpleFunctionDescriptorImpl]

'setupFixtureByCodeFragment' @ [69:9] ==> private final fun setupFixtureByCodeFragment(fragmentText: String): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest[SimpleFunctionDescriptorImpl]

'fragmentText' @ [69:36] ==> value-parameter fragmentText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest.testCompletionInLibraryCodeFragment[ValueParameterDescriptorImpl]

'completionDirectives' @ [70:26] ==> value-parameter vararg completionDirectives: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest.testCompletionInLibraryCodeFragment[ValueParameterDescriptorImpl]

'map' @ [70:47] ==> public inline fun <T, R> Array<out String>.map(transform: (String) -> String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String
    <R> -> String

'it' @ [70:57] ==> value-parameter it: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest.testCompletionInLibraryCodeFragment.<anonymous>[ValueParameterDescriptorImpl]

'joinToString' @ [70:63] ==> public fun <T> Iterable<String>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((String) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'testCompletion' @ [71:9] ==> public fun testCompletion(fileText: String, platform: TargetPlatform?, complete: (CompletionType, Int) -> Array<LookupElement>?, defaultCompletionType: CompletionType = ..., defaultInvocationCount: Int = ..., additionalValidDirectives: Collection<String> = ...): Unit defined in org.jetbrains.kotlin.idea.completion.test in file CompletionTestUtil.kt[SimpleFunctionDescriptorImpl]

'directives' @ [71:24] ==> val directives: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest.testCompletionInLibraryCodeFragment[LocalVariableDescriptor]

'JvmPlatform' @ [71:36] ==> public object JvmPlatform : TargetPlatform defined in org.jetbrains.kotlin.resolve.jvm.platform[FakeCallableDescriptorForObject]

'myFixture' @ [71:76] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest[JavaPropertyDescriptor]

'complete' @ [71:86] ==> public abstract fun complete(@NotNull p0: CompletionType, p1: Int): (Array<(LookupElement..LookupElement?)>..Array<out (LookupElement..LookupElement?)>?) defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'completionType' @ [71:95] ==> value-parameter completionType: CompletionType defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest.testCompletionInLibraryCodeFragment.<anonymous>[ValueParameterDescriptorImpl]

'count' @ [71:111] ==> value-parameter count: Int defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest.testCompletionInLibraryCodeFragment.<anonymous>[ValueParameterDescriptorImpl]

'findLibrarySourceDir' @ [75:26] ==> private final fun findLibrarySourceDir(): VirtualFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest[SimpleFunctionDescriptorImpl]

'findChild' @ [75:49] ==> @Nullable public open fun findChild(@NotNull p0: String): VirtualFile? defined in com.intellij.openapi.vfs.VirtualFile[JavaMethodDescriptor]

'getInstance' @ [76:34] ==> @NotNull public open fun getInstance(@NotNull p0: Project): PsiManager defined in com.intellij.psi.PsiManager[JavaMethodDescriptor]

'project' @ [76:46] ==> public final val CodeFragmentCompletionInLibraryTest.project: Project[MyPropertyDescriptor]

'findFile' @ [76:55] ==> @Nullable public abstract fun findFile(@NotNull p0: VirtualFile): PsiFile? defined in com.intellij.psi.PsiManager[JavaMethodDescriptor]

'sourceFile' @ [76:64] ==> val sourceFile: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest.setupFixtureByCodeFragment[LocalVariableDescriptor]

'jetFile' @ [77:38] ==> val jetFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest.setupFixtureByCodeFragment[LocalVariableDescriptor]

'declarations' @ [77:46] ==> public final val KtFile.declarations: List<(KtDeclaration..KtDeclaration?)>[MyPropertyDescriptor]

'first' @ [77:59] ==> public fun <T> List<(KtDeclaration..KtDeclaration?)>.first(): (KtDeclaration..KtDeclaration?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtDeclaration..org.jetbrains.kotlin.psi.KtDeclaration?)

'KtPsiFactory' @ [78:28] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'fooFunctionFromLibrary' @ [78:41] ==> val fooFunctionFromLibrary: KtFunction defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest.setupFixtureByCodeFragment[LocalVariableDescriptor]

'createExpressionCodeFragment' @ [78:65] ==> public final fun createExpressionCodeFragment(text: String, context: PsiElement?): KtExpressionCodeFragment defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'fragmentText' @ [79:17] ==> value-parameter fragmentText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest.setupFixtureByCodeFragment[ValueParameterDescriptorImpl]

'getContextElement' @ [80:43] ==> public final fun getContextElement(elementAt: PsiElement?): PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinCodeFragmentFactory.Companion[DeserializedSimpleFunctionDescriptor]

'fooFunctionFromLibrary' @ [80:61] ==> val fooFunctionFromLibrary: KtFunction defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest.setupFixtureByCodeFragment[LocalVariableDescriptor]

'bodyExpression' @ [80:84] ==> public final val KtFunction.bodyExpression: KtExpression?[MyPropertyDescriptor]

'codeFragment' @ [82:9] ==> val codeFragment: KtExpressionCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest.setupFixtureByCodeFragment[LocalVariableDescriptor]

'forceResolveScope' @ [82:22] ==> public open fun forceResolveScope(scope: GlobalSearchScope?): Unit defined in org.jetbrains.kotlin.psi.KtExpressionCodeFragment[DeserializedSimpleFunctionDescriptor]

'allScope' @ [82:58] ==> @NotNull public open fun allScope(@NotNull p0: Project): GlobalSearchScope defined in com.intellij.psi.search.GlobalSearchScope[JavaMethodDescriptor]

'project' @ [82:67] ==> public final val CodeFragmentCompletionInLibraryTest.project: Project[MyPropertyDescriptor]

'myFixture' @ [83:9] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest[JavaPropertyDescriptor]

'configureFromExistingVirtualFile' @ [83:19] ==> public abstract fun configureFromExistingVirtualFile(@NotNull p0: VirtualFile): Unit defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'codeFragment' @ [83:52] ==> val codeFragment: KtExpressionCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.CodeFragmentCompletionInLibraryTest.setupFixtureByCodeFragment[LocalVariableDescriptor]

'virtualFile' @ [83:65] ==> public final val KtExpressionCodeFragment.virtualFile: (VirtualFile..VirtualFile?)[MyPropertyDescriptor]

'!!' @ [87:16] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: VirtualFile?): VirtualFile[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> VirtualFile

'getInstance' @ [87:32] ==> public open fun getInstance(): (LocalFileSystem..LocalFileSystem?) defined in com.intellij.openapi.vfs.LocalFileSystem[JavaMethodDescriptor]

'findFileByIoFile' @ [87:46] ==> @Nullable public abstract fun findFileByIoFile(@NotNull p0: File): VirtualFile? defined in com.intellij.openapi.vfs.LocalFileSystem[JavaMethodDescriptor]

'File' @ [87:63] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'LIBRARY_SRC_PATH' @ [87:68] ==> private val LIBRARY_SRC_PATH: String defined in org.jetbrains.kotlin.idea.debugger.evaluate in file CodeFragmentCompletionInLibraryTest.kt[PropertyDescriptorImpl]

