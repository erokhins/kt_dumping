'AbstractHierarchyTest' @ [31:47] ==> public constructor AbstractHierarchyTest() defined in org.jetbrains.kotlin.idea.hierarchy.AbstractHierarchyTest[JavaClassConstructorDescriptor]

'super' @ [33:9] ==> <this> defined in org.jetbrains.kotlin.idea.hierarchy.AbstractHierarchyWithLibTest[LazyClassReceiverParameterDescriptor]

'setUp' @ [33:15] ==> @Override protected/*protected and package*/ open fun setUp(): Unit defined in org.jetbrains.kotlin.idea.hierarchy.AbstractHierarchyTest[JavaMethodDescriptor]

'myModule' @ [34:9] ==> protected/*protected and package*/ final var myModule: (Module..Module?) defined in org.jetbrains.kotlin.idea.hierarchy.AbstractHierarchyWithLibTest[JavaPropertyDescriptor]

'configureAs' @ [34:18] ==> public fun Module.configureAs(kind: ModuleKind): Unit defined in org.jetbrains.kotlin.idea.test in file testUtils.kt[SimpleFunctionDescriptorImpl]

'KOTLIN_JVM_WITH_STDLIB_SOURCES' @ [34:41] ==> enum entry KOTLIN_JVM_WITH_STDLIB_SOURCES defined in org.jetbrains.kotlin.idea.test.ModuleKind[FakeCallableDescriptorForObject]

'this' @ [38:9] ==> <this> defined in org.jetbrains.kotlin.idea.hierarchy.AbstractHierarchyWithLibTest[LazyClassReceiverParameterDescriptor]

'folderName' @ [38:14] ==> protected/*protected and package*/ final var folderName: (String..String?) defined in org.jetbrains.kotlin.idea.hierarchy.AbstractHierarchyWithLibTest[JavaPropertyDescriptor]

'folderName' @ [38:27] ==> value-parameter folderName: String defined in org.jetbrains.kotlin.idea.hierarchy.AbstractHierarchyWithLibTest.doTest[ValueParameterDescriptorImpl]

'filesToConfigure' @ [40:32] ==> protected/*protected and package*/ for synthetic extension final val AbstractHierarchyWithLibTest.filesToConfigure: (Array<(String..String?)>..Array<out (String..String?)>?)[MyPropertyDescriptor]

'filesToConfigure' @ [41:20] ==> val filesToConfigure: (Array<(String..String?)>..Array<out (String..String?)>?) defined in org.jetbrains.kotlin.idea.hierarchy.AbstractHierarchyWithLibTest.doTest[LocalVariableDescriptor]

'first' @ [41:37] ==> public fun <T> Array<out (String..String?)>.first(): (String..String?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.String..kotlin.String?)

'?:' @ [42:25] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: String?, right: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> String

'findLinesWithPrefixesRemoved' @ [42:47] ==> @NotNull public open fun findLinesWithPrefixesRemoved(p0: (String..String?), vararg p1: (String..String?)): (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'File' @ [43:17] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'getHomeDirectory' @ [43:41] ==> @NotNull public open fun getHomeDirectory(): String defined in org.jetbrains.kotlin.test.KotlinTestUtils[JavaMethodDescriptor]

'folderName' @ [43:62] ==> value-parameter folderName: String defined in org.jetbrains.kotlin.idea.hierarchy.AbstractHierarchyWithLibTest.doTest[ValueParameterDescriptorImpl]

'file' @ [43:74] ==> val file: (String..String?) defined in org.jetbrains.kotlin.idea.hierarchy.AbstractHierarchyWithLibTest.doTest[LocalVariableDescriptor]

'readText' @ [43:81] ==> public fun File.readText(charset: Charset = ...): String defined in kotlin.io[DeserializedSimpleFunctionDescriptor]

'singleOrNull' @ [45:11] ==> public fun <T> List<(String..String?)>.singleOrNull(): String? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.String..kotlin.String?)

'error' @ [45:29] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'findTargetJavaClass' @ [47:27] ==> private final fun findTargetJavaClass(targetClass: String): PsiClass defined in org.jetbrains.kotlin.idea.hierarchy.AbstractHierarchyWithLibTest[SimpleFunctionDescriptorImpl]

'directive' @ [47:47] ==> val directive: String defined in org.jetbrains.kotlin.idea.hierarchy.AbstractHierarchyWithLibTest.doTest[LocalVariableDescriptor]

'trim' @ [47:57] ==> @InlineOnly public inline fun String.trim(): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'doHierarchyTest' @ [48:9] ==> @Override protected/*protected and package*/ open fun doHierarchyTest(treeStructureComputable: (Computable<(HierarchyTreeStructure..HierarchyTreeStructure?)>..Computable<(HierarchyTreeStructure..HierarchyTreeStructure?)>?), vararg fileNames: (String..String?)): Unit defined in org.jetbrains.kotlin.idea.hierarchy.AbstractHierarchyWithLibTest[JavaMethodDescriptor]

'Computable' @ [49:17] ==> public fun <T : (Any..Any?)> Computable(function: () -> (HierarchyTreeStructure..HierarchyTreeStructure?)): Computable<(HierarchyTreeStructure..HierarchyTreeStructure?)> defined in com.intellij.openapi.util[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : (Any..Any?)> -> (com.intellij.ide.hierarchy.HierarchyTreeStructure..com.intellij.ide.hierarchy.HierarchyTreeStructure?)

'TypeHierarchyTreeStructure' @ [50:21] ==> public constructor TypeHierarchyTreeStructure(p0: (Project..Project?), p1: (PsiClass..PsiClass?), p2: (String..String?)) defined in com.intellij.ide.hierarchy.type.TypeHierarchyTreeStructure[JavaClassConstructorDescriptor]

'project' @ [51:29] ==> public final val AbstractHierarchyWithLibTest.project: (Project..Project?)[MyPropertyDescriptor]

'targetClass' @ [52:29] ==> val targetClass: PsiClass defined in org.jetbrains.kotlin.idea.hierarchy.AbstractHierarchyWithLibTest.doTest[LocalVariableDescriptor]

'if (folderName.contains("annotation")) HierarchyBrowserBaseEx.SCOPE_PROJECT else HierarchyBrowserBaseEx.SCOPE_ALL' @ [53:29] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (String..String?), elseBranch: (String..String?)): (String..String?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (kotlin.String..kotlin.String?)

'folderName' @ [53:33] ==> value-parameter folderName: String defined in org.jetbrains.kotlin.idea.hierarchy.AbstractHierarchyWithLibTest.doTest[ValueParameterDescriptorImpl]

'contains' @ [53:44] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'SCOPE_PROJECT' @ [53:91] ==> public const final val SCOPE_PROJECT: (String..String?) defined in com.intellij.ide.hierarchy.HierarchyBrowserBaseEx[JavaPropertyDescriptor]

'SCOPE_ALL' @ [53:133] ==> public const final val SCOPE_ALL: (String..String?) defined in com.intellij.ide.hierarchy.HierarchyBrowserBaseEx[JavaPropertyDescriptor]

'filesToConfigure' @ [54:21] ==> val filesToConfigure: (Array<(String..String?)>..Array<out (String..String?)>?) defined in org.jetbrains.kotlin.idea.hierarchy.AbstractHierarchyWithLibTest.doTest[LocalVariableDescriptor]

'?:' @ [58:16] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: PsiClass?, right: PsiClass): PsiClass[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> PsiClass

'getInstance' @ [58:39] ==> public open fun getInstance(): (JavaFullClassNameIndex..JavaFullClassNameIndex?) defined in com.intellij.psi.impl.java.stubs.index.JavaFullClassNameIndex[JavaMethodDescriptor]

'get' @ [58:53] ==> public open fun get(@NotNull p0: Int, @NotNull p1: Project, @NotNull p2: GlobalSearchScope): (MutableCollection<(PsiClass..PsiClass?)>..Collection<(PsiClass..PsiClass?)>?) defined in com.intellij.psi.impl.java.stubs.index.JavaFullClassNameIndex[JavaMethodDescriptor]

'targetClass' @ [58:57] ==> value-parameter targetClass: String defined in org.jetbrains.kotlin.idea.hierarchy.AbstractHierarchyWithLibTest.findTargetJavaClass[ValueParameterDescriptorImpl]

'hashCode' @ [58:69] ==> public open fun hashCode(): Int defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'project' @ [58:81] ==> public final val AbstractHierarchyWithLibTest.project: (Project..Project?)[MyPropertyDescriptor]

'allScope' @ [58:108] ==> @NotNull public open fun allScope(@NotNull p0: Project): GlobalSearchScope defined in com.intellij.psi.search.GlobalSearchScope[JavaMethodDescriptor]

'project' @ [58:117] ==> public final val AbstractHierarchyWithLibTest.project: (Project..Project?)[MyPropertyDescriptor]

'find' @ [58:127] ==> @InlineOnly public inline fun <T> Iterable<(PsiClass..PsiClass?)>.find(predicate: ((PsiClass..PsiClass?)) -> Boolean): PsiClass? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiClass..com.intellij.psi.PsiClass?)

'it' @ [59:13] ==> value-parameter it: (PsiClass..PsiClass?) defined in org.jetbrains.kotlin.idea.hierarchy.AbstractHierarchyWithLibTest.findTargetJavaClass.<anonymous>[ValueParameterDescriptorImpl]

'qualifiedName' @ [59:16] ==> public final val PsiClass.qualifiedName: String?[MyPropertyDescriptor]

'targetClass' @ [59:33] ==> value-parameter targetClass: String defined in org.jetbrains.kotlin.idea.hierarchy.AbstractHierarchyWithLibTest.findTargetJavaClass[ValueParameterDescriptorImpl]

'error' @ [60:14] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'targetClass' @ [60:49] ==> value-parameter targetClass: String defined in org.jetbrains.kotlin.idea.hierarchy.AbstractHierarchyWithLibTest.findTargetJavaClass[ValueParameterDescriptorImpl]

