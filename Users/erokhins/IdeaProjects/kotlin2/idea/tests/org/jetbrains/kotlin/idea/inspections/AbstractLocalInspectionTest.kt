'KotlinLightCodeInsightFixtureTestCase' @ [41:46] ==> public constructor KotlinLightCodeInsightFixtureTestCase() defined in org.jetbrains.kotlin.idea.test.KotlinLightCodeInsightFixtureTestCase[ClassConstructorDescriptorImpl]

'newArrayList' @ [58:36] ==> @GwtCompatible public open fun <E : (Any..Any?)> newArrayList(): (ArrayList<(File..File?)>..ArrayList<(File..File?)>?) defined in com.google.common.collect.Lists[JavaMethodDescriptor]
Inferred types:
    <E : (Any..Any?)> -> File

'testDataFile' @ [60:30] ==> value-parameter testDataFile: File defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.createInspection[ValueParameterDescriptorImpl]

'parentFile' @ [60:43] ==> public final val File.parentFile: (File..File?)[MyPropertyDescriptor]

'current' @ [61:16] ==> var current: File? defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.createInspection[LocalVariableDescriptor]

'File' @ [62:29] ==> public constructor File(p0: (File..File?), p1: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'current' @ [62:34] ==> var current: File? defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.createInspection[LocalVariableDescriptor]

'inspectionFileName' @ [62:43] ==> private final val inspectionFileName: String defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest[PropertyDescriptorImpl]

'candidate' @ [63:17] ==> val candidate: File defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.createInspection[LocalVariableDescriptor]

'exists' @ [63:27] ==> public open fun exists(): Boolean defined in java.io.File[JavaMethodDescriptor]

'candidateFiles' @ [64:17] ==> val candidateFiles: (ArrayList<(File..File?)>..ArrayList<(File..File?)>?) defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.createInspection[LocalVariableDescriptor]

'add' @ [64:32] ==> public open fun add(element: (File..File?)): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'candidate' @ [64:36] ==> val candidate: File defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.createInspection[LocalVariableDescriptor]

'current' @ [66:13] ==> var current: File? defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.createInspection[LocalVariableDescriptor]

'current' @ [66:23] ==> var current: File? defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.createInspection[LocalVariableDescriptor]

'parentFile' @ [66:31] ==> public final val File.parentFile: (File..File?)[MyPropertyDescriptor]

'candidateFiles' @ [69:13] ==> val candidateFiles: (ArrayList<(File..File?)>..ArrayList<(File..File?)>?) defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.createInspection[LocalVariableDescriptor]

'isEmpty' @ [69:28] ==> public open fun isEmpty(): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'AssertionError' @ [70:19] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'+' @ [70:34] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'testDataFile' @ [70:73] ==> value-parameter testDataFile: File defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.createInspection[ValueParameterDescriptorImpl]

'candidateFiles' @ [73:13] ==> val candidateFiles: (ArrayList<(File..File?)>..ArrayList<(File..File?)>?) defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.createInspection[LocalVariableDescriptor]

'size' @ [73:28] ==> public open val size: Int defined in java.util.ArrayList[JavaPropertyDescriptor]

'AssertionError' @ [74:19] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'+' @ [74:34] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'testDataFile' @ [74:83] ==> value-parameter testDataFile: File defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.createInspection[ValueParameterDescriptorImpl]

'candidateFiles' @ [75:69] ==> val candidateFiles: (ArrayList<(File..File?)>..ArrayList<(File..File?)>?) defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.createInspection[LocalVariableDescriptor]

'loadFile' @ [78:34] ==> @NotNull public open fun loadFile(@NotNull p0: File): String defined in com.intellij.openapi.util.io.FileUtil[JavaMethodDescriptor]

'candidateFiles' @ [78:43] ==> val candidateFiles: (ArrayList<(File..File?)>..ArrayList<(File..File?)>?) defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.createInspection[LocalVariableDescriptor]

'trim' @ [78:62] ==> public inline fun String.trim(predicate: (Char) -> Boolean): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'it' @ [78:69] ==> value-parameter it: Char defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.createInspection.<anonymous>[ValueParameterDescriptorImpl]

'forName' @ [79:22] ==> @CallerSensitive public open fun forName(p0: (String..String?)): (Class<*>..Class<*>?) defined in java.lang.Class[JavaMethodDescriptor]

'className' @ [79:30] ==> val className: String defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.createInspection[LocalVariableDescriptor]

'newInstance' @ [79:41] ==> @CallerSensitive public open fun newInstance(): (Any..Any?) defined in java.lang.Class[JavaMethodDescriptor]

'File' @ [83:24] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'path' @ [83:29] ==> value-parameter path: String defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTest[ValueParameterDescriptorImpl]

'createInspection' @ [84:26] ==> private final fun createInspection(testDataFile: File): AbstractKotlinInspection defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest[SimpleFunctionDescriptorImpl]

'mainFile' @ [84:43] ==> val mainFile: File defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTest[LocalVariableDescriptor]

'loadFile' @ [86:33] ==> @NotNull public open fun loadFile(@NotNull p0: File, p1: Boolean): String defined in com.intellij.openapi.util.io.FileUtil[JavaMethodDescriptor]

'mainFile' @ [86:42] ==> val mainFile: File defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTest[LocalVariableDescriptor]

'assertTrue' @ [87:18] ==> public open fun assertTrue(p0: (String..String?), p1: Boolean): Unit defined in junit.framework.TestCase[JavaMethodDescriptor]

'mainFile' @ [87:64] ==> val mainFile: File defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTest[LocalVariableDescriptor]

'fileText' @ [87:77] ==> val fileText: String defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTest[LocalVariableDescriptor]

'contains' @ [87:86] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'findStringWithPrefixes' @ [89:45] ==> @Nullable public open fun findStringWithPrefixes(p0: (String..String?), vararg p1: (String..String?)): String? defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'fileText' @ [89:68] ==> val fileText: String defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTest[LocalVariableDescriptor]

'version' @ [90:13] ==> val version: String? defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTest[LocalVariableDescriptor]

'start' @ [91:43] ==> @NotNull @Deprecated public open fun start(): AccessToken defined in com.intellij.openapi.application.WriteAction[JavaMethodDescriptor]

'IdeModifiableModelsProviderImpl' @ [93:38] ==> public constructor IdeModifiableModelsProviderImpl(p0: (Project..Project?)) defined in com.intellij.openapi.externalSystem.service.project.IdeModifiableModelsProviderImpl[JavaClassConstructorDescriptor]

'project' @ [93:70] ==> public final val AbstractLocalInspectionTest.project: Project[MyPropertyDescriptor]

'module' @ [94:29] ==> protected final val module: Module defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest[PropertyDescriptorImpl]

'getOrCreateFacet' @ [94:36] ==> public fun Module.getOrCreateFacet(modelsProvider: IdeModifiableModelsProvider, useProjectSettings: Boolean, commitModel: Boolean = ...): KotlinFacet defined in org.jetbrains.kotlin.idea.facet[DeserializedSimpleFunctionDescriptor]

'modelsProvider' @ [94:53] ==> val modelsProvider: IdeModifiableModelsProviderImpl defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTest[LocalVariableDescriptor]

'facet' @ [95:17] ==> val facet: KotlinFacet defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTest[LocalVariableDescriptor]

'configureFacet' @ [95:23] ==> public fun KotlinFacet.configureFacet(compilerVersion: String, coroutineSupport: LanguageFeature.State, platformKind: TargetPlatformKind<*>?, modelsProvider: IdeModifiableModelsProvider): Unit defined in org.jetbrains.kotlin.idea.facet[DeserializedSimpleFunctionDescriptor]

'version' @ [95:38] ==> val version: String? defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTest[LocalVariableDescriptor]

'LanguageFeature' @ [95:47] ==> public companion object defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'DISABLED' @ [95:69] ==> enum entry DISABLED defined in org.jetbrains.kotlin.config.LanguageFeature.State[FakeCallableDescriptorForObject]

'modelsProvider' @ [95:85] ==> val modelsProvider: IdeModifiableModelsProviderImpl defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTest[LocalVariableDescriptor]

'modelsProvider' @ [96:17] ==> val modelsProvider: IdeModifiableModelsProviderImpl defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTest[LocalVariableDescriptor]

'commit' @ [96:32] ==> public open fun commit(): Unit defined in com.intellij.openapi.externalSystem.service.project.IdeModifiableModelsProviderImpl[JavaMethodDescriptor]

'accessToken' @ [99:17] ==> val accessToken: AccessToken defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTest[LocalVariableDescriptor]

'finish' @ [99:29] ==> public abstract fun finish(): Unit defined in com.intellij.openapi.application.AccessToken[JavaMethodDescriptor]

'findStringWithPrefixes' @ [103:52] ==> @Nullable public open fun findStringWithPrefixes(p0: (String..String?), vararg p1: (String..String?)): String? defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'fileText' @ [103:75] ==> val fileText: String defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTest[LocalVariableDescriptor]

'minJavaVersion' @ [104:13] ==> val minJavaVersion: String? defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTest[LocalVariableDescriptor]

'!' @ [104:39] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isJavaVersionAtLeast' @ [104:51] ==> public open fun isJavaVersionAtLeast(p0: (String..String?)): Boolean defined in com.intellij.openapi.util.SystemInfo[JavaMethodDescriptor]

'minJavaVersion' @ [104:72] ==> val minJavaVersion: String? defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTest[LocalVariableDescriptor]

'file' @ [106:13] ==> public final val AbstractLocalInspectionTest.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'!' @ [106:31] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isDirectiveDefined' @ [106:54] ==> public open fun isDirectiveDefined(p0: (String..String?), p1: (String..String?)): Boolean defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'fileText' @ [106:73] ==> val fileText: String defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTest[LocalVariableDescriptor]

'DirectiveBasedActionUtils' @ [107:13] ==> public object DirectiveBasedActionUtils defined in org.jetbrains.kotlin.idea.test in file DirectiveBasedActionUtils.kt[FakeCallableDescriptorForObject]

'checkForUnexpectedErrors' @ [107:39] ==> public final fun checkForUnexpectedErrors(file: KtFile): Unit defined in org.jetbrains.kotlin.idea.test.DirectiveBasedActionUtils[SimpleFunctionDescriptorImpl]

'file' @ [107:64] ==> public final val AbstractLocalInspectionTest.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'myFixture' @ [110:23] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest[JavaPropertyDescriptor]

'configureByFiles' @ [110:33] ==> @NotNull public abstract fun configureByFiles(@NotNull vararg p0: (String..String?)): (Array<(PsiFile..PsiFile?)>..Array<out (PsiFile..PsiFile?)>) defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'mainFile' @ [110:50] ==> val mainFile: File defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTest[LocalVariableDescriptor]

'name' @ [110:59] ==> public final val File.name: (String..String?)[MyPropertyDescriptor]

'first' @ [110:65] ==> public fun <T> Array<out (PsiFile..PsiFile?)>.first(): (PsiFile..PsiFile?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiFile..com.intellij.psi.PsiFile?)

'doTestFor' @ [112:9] ==> private final fun doTestFor(mainFilePath: String, file: VirtualFile, inspection: AbstractKotlinInspection, fileText: String): Unit defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest[SimpleFunctionDescriptorImpl]

'mainFile' @ [112:19] ==> val mainFile: File defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTest[LocalVariableDescriptor]

'name' @ [112:28] ==> public final val File.name: (String..String?)[MyPropertyDescriptor]

'psiFile' @ [112:34] ==> val psiFile: (PsiFile..PsiFile?) defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTest[LocalVariableDescriptor]

'virtualFile' @ [112:42] ==> public final val PsiFile.virtualFile: (VirtualFile..VirtualFile?)[MyPropertyDescriptor]

'inspection' @ [112:57] ==> val inspection: AbstractKotlinInspection defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTest[LocalVariableDescriptor]

'fileText' @ [112:69] ==> val fileText: String defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTest[LocalVariableDescriptor]

'file' @ [114:13] ==> public final val AbstractLocalInspectionTest.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'!' @ [114:31] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isDirectiveDefined' @ [114:54] ==> public open fun isDirectiveDefined(p0: (String..String?), p1: (String..String?)): Boolean defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'fileText' @ [114:73] ==> val fileText: String defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTest[LocalVariableDescriptor]

'DirectiveBasedActionUtils' @ [115:13] ==> public object DirectiveBasedActionUtils defined in org.jetbrains.kotlin.idea.test in file DirectiveBasedActionUtils.kt[FakeCallableDescriptorForObject]

'checkForUnexpectedErrors' @ [115:39] ==> public final fun checkForUnexpectedErrors(file: KtFile): Unit defined in org.jetbrains.kotlin.idea.test.DirectiveBasedActionUtils[SimpleFunctionDescriptorImpl]

'file' @ [115:64] ==> public final val AbstractLocalInspectionTest.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'findStringWithPrefixes' @ [120:59] ==> @Nullable public open fun findStringWithPrefixes(p0: (String..String?), vararg p1: (String..String?)): String? defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'fileText' @ [121:17] ==> value-parameter fileText: String defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[ValueParameterDescriptorImpl]

'expectedProblemDirectiveName' @ [121:32] ==> private final val expectedProblemDirectiveName: String defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest[PropertyDescriptorImpl]

'problemExpectedString' @ [122:31] ==> val problemExpectedString: String? defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'problemExpectedString' @ [122:64] ==> val problemExpectedString: String? defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'findStringWithPrefixes' @ [123:61] ==> @Nullable public open fun findStringWithPrefixes(p0: (String..String?), vararg p1: (String..String?)): String? defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'fileText' @ [124:17] ==> value-parameter fileText: String defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[ValueParameterDescriptorImpl]

'expectedProblemHighlightType' @ [124:32] ==> private final val expectedProblemHighlightType: String defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest[PropertyDescriptorImpl]

'runInspection' @ [126:28] ==> public fun runInspection(inspection: LocalInspectionTool, project: Project, files: List<VirtualFile>? = ..., withTestDir: String? = ...): InspectionToolPresentation defined in org.jetbrains.kotlin.idea.inspections[SimpleFunctionDescriptorImpl]

'inspection' @ [126:42] ==> value-parameter inspection: AbstractKotlinInspection defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[ValueParameterDescriptorImpl]

'project' @ [126:54] ==> public final val AbstractLocalInspectionTest.project: Project[MyPropertyDescriptor]

'listOf' @ [126:63] ==> public fun <T> listOf(element: VirtualFile): List<VirtualFile> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> VirtualFile

'file' @ [126:70] ==> value-parameter file: VirtualFile defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[ValueParameterDescriptorImpl]

'presentation' @ [127:34] ==> val presentation: InspectionToolPresentation defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'problemDescriptors' @ [127:47] ==> public final val InspectionToolPresentation.problemDescriptors: (MutableCollection<(CommonProblemDescriptor..CommonProblemDescriptor?)>..Collection<(CommonProblemDescriptor..CommonProblemDescriptor?)>)[MyPropertyDescriptor]

'filterIsInstance' @ [128:18] ==> public inline fun <reified R> Iterable<*>.filterIsInstance(): List<ProblemDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified R> -> ProblemDescriptor

'filter' @ [129:18] ==> public inline fun <T> Iterable<ProblemDescriptor>.filter(predicate: (ProblemDescriptor) -> Boolean): List<ProblemDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ProblemDescriptor

'myFixture' @ [130:39] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest[JavaPropertyDescriptor]

'caretOffset' @ [130:49] ==> public final val JavaCodeInsightTestFixture.caretOffset: Int[MyPropertyDescriptor]

'caretOffset' @ [131:21] ==> val caretOffset: Int defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor.<anonymous>[LocalVariableDescriptor]

'it' @ [131:36] ==> value-parameter it: ProblemDescriptor defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor.<anonymous>[ValueParameterDescriptorImpl]

'textRangeInElement' @ [131:39] ==> public final val ProblemDescriptor.textRangeInElement: (TextRange..TextRange?)[MyPropertyDescriptor]

'shiftRight' @ [131:59] ==> @NotNull public open fun shiftRight(p0: Int): TextRange defined in com.intellij.openapi.util.TextRange[JavaMethodDescriptor]

'it' @ [131:70] ==> value-parameter it: ProblemDescriptor defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor.<anonymous>[ValueParameterDescriptorImpl]

'psiElement' @ [131:73] ==> public final val ProblemDescriptor.psiElement: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'startOffset' @ [131:84] ==> public val PsiElement.startOffset: Int defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'it' @ [131:100] ==> value-parameter it: ProblemDescriptor defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor.<anonymous>[ValueParameterDescriptorImpl]

'psiElement' @ [131:103] ==> public final val ProblemDescriptor.psiElement: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'textRange' @ [131:114] ==> public final val PsiElement.textRange: (TextRange..TextRange?)[MyPropertyDescriptor]

'assertTrue' @ [133:16] ==> public open fun assertTrue(p0: (String..String?), p1: Boolean): Unit defined in org.junit.Assert[JavaMethodDescriptor]

'if (!problemExpected)
                    "No problems should be detected at caret\n" +
                    "Detected problems: ${problemDescriptors.joinToString { it.descriptionTemplate }}"
                else
                    "Expected at least one problem at caret"' @ [134:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'!' @ [134:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'problemExpected' @ [134:22] ==> val problemExpected: Boolean defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'+' @ [135:21] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'problemDescriptors' @ [136:43] ==> val problemDescriptors: List<ProblemDescriptor> defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'joinToString' @ [136:62] ==> public fun <T> Iterable<ProblemDescriptor>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((ProblemDescriptor) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ProblemDescriptor

'it' @ [136:77] ==> value-parameter it: ProblemDescriptor defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor.<anonymous>[ValueParameterDescriptorImpl]

'descriptionTemplate' @ [136:80] ==> public final val ProblemDescriptor.descriptionTemplate: String[MyPropertyDescriptor]

'problemExpected' @ [139:17] ==> val problemExpected: Boolean defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'problemDescriptors' @ [139:36] ==> val problemDescriptors: List<ProblemDescriptor> defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'isNotEmpty' @ [139:55] ==> @InlineOnly public inline fun <T> Collection<ProblemDescriptor>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ProblemDescriptor

'!' @ [140:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'problemExpected' @ [140:14] ==> val problemExpected: Boolean defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'problemExpectedString' @ [141:13] ==> val problemExpectedString: String? defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'assertTrue' @ [142:20] ==> public open fun assertTrue(p0: (String..String?), p1: Boolean): Unit defined in org.junit.Assert[JavaMethodDescriptor]

'+' @ [142:31] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'problemExpectedString' @ [142:74] ==> val problemExpectedString: String? defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'problemDescriptors' @ [143:51] ==> val problemDescriptors: List<ProblemDescriptor> defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'joinToString' @ [143:70] ==> public fun <T> Iterable<ProblemDescriptor>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((ProblemDescriptor) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ProblemDescriptor

'it' @ [143:85] ==> value-parameter it: ProblemDescriptor defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor.<anonymous>[ValueParameterDescriptorImpl]

'descriptionTemplate' @ [143:88] ==> public final val ProblemDescriptor.descriptionTemplate: String[MyPropertyDescriptor]

'problemDescriptors' @ [144:31] ==> val problemDescriptors: List<ProblemDescriptor> defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'any' @ [144:50] ==> public inline fun <T> Iterable<ProblemDescriptor>.any(predicate: (ProblemDescriptor) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ProblemDescriptor

'it' @ [144:56] ==> value-parameter it: ProblemDescriptor defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor.<anonymous>[ValueParameterDescriptorImpl]

'descriptionTemplate' @ [144:59] ==> public final val ProblemDescriptor.descriptionTemplate: String[MyPropertyDescriptor]

'problemExpectedString' @ [144:82] ==> val problemExpectedString: String? defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'highlightExpectedString' @ [146:13] ==> val highlightExpectedString: String? defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'assertTrue' @ [147:20] ==> public open fun assertTrue(p0: (String..String?), p1: Boolean): Unit defined in org.junit.Assert[JavaMethodDescriptor]

'+' @ [147:31] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'problemDescriptors' @ [148:48] ==> val problemDescriptors: List<ProblemDescriptor> defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'joinToString' @ [148:67] ==> public fun <T> Iterable<ProblemDescriptor>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((ProblemDescriptor) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ProblemDescriptor

'it' @ [148:82] ==> value-parameter it: ProblemDescriptor defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor.<anonymous>[ValueParameterDescriptorImpl]

'highlightType' @ [148:85] ==> public final val ProblemDescriptor.highlightType: ProblemHighlightType[MyPropertyDescriptor]

'toString' @ [148:99] ==> public open fun toString(): String defined in com.intellij.codeInspection.ProblemHighlightType[DeserializedSimpleFunctionDescriptor]

'problemDescriptors' @ [149:31] ==> val problemDescriptors: List<ProblemDescriptor> defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'all' @ [149:50] ==> public inline fun <T> Iterable<ProblemDescriptor>.all(predicate: (ProblemDescriptor) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ProblemDescriptor

'it' @ [149:56] ==> value-parameter it: ProblemDescriptor defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor.<anonymous>[ValueParameterDescriptorImpl]

'highlightType' @ [149:59] ==> public final val ProblemDescriptor.highlightType: ProblemHighlightType[MyPropertyDescriptor]

'toString' @ [149:73] ==> public open fun toString(): String defined in com.intellij.codeInspection.ProblemHighlightType[DeserializedSimpleFunctionDescriptor]

'highlightExpectedString' @ [149:87] ==> val highlightExpectedString: String? defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'findStringWithPrefixes' @ [152:56] ==> @Nullable public open fun findStringWithPrefixes(p0: (String..String?), vararg p1: (String..String?)): String? defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'fileText' @ [152:79] ==> value-parameter fileText: String defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[ValueParameterDescriptorImpl]

'fixTextDirectiveName' @ [152:94] ==> private final val fixTextDirectiveName: String defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest[PropertyDescriptorImpl]

'problemDescriptors' @ [153:31] ==> val problemDescriptors: List<ProblemDescriptor> defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'flatMap' @ [153:50] ==> public inline fun <T, R> Iterable<ProblemDescriptor>.flatMap(transform: (ProblemDescriptor) -> Iterable<raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?)>): List<raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ProblemDescriptor
    <R> -> raw (com.intellij.codeInspection.QuickFix<(com.intellij.codeInspection.CommonProblemDescriptor..com.intellij.codeInspection.CommonProblemDescriptor?)>..com.intellij.codeInspection.QuickFix<*>?)

'problem' @ [155:25] ==> value-parameter problem: ProblemDescriptor defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor.<anonymous>[ValueParameterDescriptorImpl]

'fixes' @ [155:33] ==> public final val ProblemDescriptor.fixes: (Array<raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?)>?..Array<out raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?)>?)[MyPropertyDescriptor]

'fixes' @ [156:13] ==> val fixes: (Array<raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?)>?..Array<out raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?)>?) defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor.<anonymous>[LocalVariableDescriptor]

'toList' @ [156:20] ==> public fun <T> Array<out raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?)>.toList(): List<raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> raw (com.intellij.codeInspection.QuickFix<(com.intellij.codeInspection.CommonProblemDescriptor..com.intellij.codeInspection.CommonProblemDescriptor?)>..com.intellij.codeInspection.QuickFix<*>?)

'emptyList' @ [156:32] ==> public fun <T> emptyList(): List<raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> raw (com.intellij.codeInspection.QuickFix<(com.intellij.codeInspection.CommonProblemDescriptor..com.intellij.codeInspection.CommonProblemDescriptor?)>..com.intellij.codeInspection.QuickFix<*>?)

'filter' @ [157:11] ==> public inline fun <T> Iterable<raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?)>.filter(predicate: (raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?)) -> Boolean): List<raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> raw (com.intellij.codeInspection.QuickFix<(com.intellij.codeInspection.CommonProblemDescriptor..com.intellij.codeInspection.CommonProblemDescriptor?)>..com.intellij.codeInspection.QuickFix<*>?)

'localFixTextString' @ [157:27] ==> val localFixTextString: String? defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'fix' @ [157:57] ==> value-parameter fix: raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?) defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [157:61] ==> public final val <D : (CommonProblemDescriptor..CommonProblemDescriptor?)> QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>.name: String[MyPropertyDescriptor]
Inferred types:
    <D : (CommonProblemDescriptor..CommonProblemDescriptor?)> -> (com.intellij.codeInspection.CommonProblemDescriptor..com.intellij.codeInspection.CommonProblemDescriptor?)

'localFixTextString' @ [157:69] ==> val localFixTextString: String? defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'localFixActions' @ [159:36] ==> val localFixActions: List<raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?)> defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'joinToString' @ [159:52] ==> public fun <T> Iterable<raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?)>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?)) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> raw (com.intellij.codeInspection.QuickFix<(com.intellij.codeInspection.CommonProblemDescriptor..com.intellij.codeInspection.CommonProblemDescriptor?)>..com.intellij.codeInspection.QuickFix<*>?)

'it' @ [159:67] ==> value-parameter it: raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?) defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [159:70] ==> public final val <D : (CommonProblemDescriptor..CommonProblemDescriptor?)> QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>.name: String[MyPropertyDescriptor]
Inferred types:
    <D : (CommonProblemDescriptor..CommonProblemDescriptor?)> -> (com.intellij.codeInspection.CommonProblemDescriptor..com.intellij.codeInspection.CommonProblemDescriptor?)

'localFixTextString' @ [161:30] ==> val localFixTextString: String? defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'let' @ [161:50] ==> @InlineOnly public inline fun <T, R> String.let(block: (String) -> String): String defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String
    <R> -> String

'localFixTextString' @ [161:79] ==> val localFixTextString: String? defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'assertTrue' @ [162:18] ==> public open fun assertTrue(p0: (String..String?), p1: Boolean): Unit defined in junit.framework.TestCase[JavaMethodDescriptor]

'+' @ [162:29] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'fixDescription' @ [162:45] ==> val fixDescription: String defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'availableDescription' @ [163:50] ==> val availableDescription: String defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'localFixActions' @ [164:29] ==> val localFixActions: List<raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?)> defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'isNotEmpty' @ [164:45] ==> @InlineOnly public inline fun <T> Collection<raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?)>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> raw (com.intellij.codeInspection.QuickFix<(com.intellij.codeInspection.CommonProblemDescriptor..com.intellij.codeInspection.CommonProblemDescriptor?)>..com.intellij.codeInspection.QuickFix<*>?)

'localFixActions' @ [166:30] ==> val localFixActions: List<raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?)> defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'singleOrNull' @ [166:46] ==> public fun <T> List<raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?)>.singleOrNull(): raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>?..QuickFix<*>?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> raw (com.intellij.codeInspection.QuickFix<(com.intellij.codeInspection.CommonProblemDescriptor..com.intellij.codeInspection.CommonProblemDescriptor?)>..com.intellij.codeInspection.QuickFix<*>?)

'assertTrue' @ [167:18] ==> public open fun assertTrue(p0: (String..String?), p1: Boolean): Unit defined in junit.framework.TestCase[JavaMethodDescriptor]

'+' @ [167:29] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'fixDescription' @ [167:56] ==> val fixDescription: String defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'availableDescription' @ [168:50] ==> val availableDescription: String defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'localFixAction' @ [169:29] ==> val localFixAction: raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>?..QuickFix<*>?) defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'problemDescriptors' @ [171:33] ==> val problemDescriptors: List<ProblemDescriptor> defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'find' @ [171:52] ==> @InlineOnly public inline fun <T> Iterable<ProblemDescriptor>.find(predicate: (ProblemDescriptor) -> Boolean): ProblemDescriptor? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ProblemDescriptor

'localFixAction' @ [171:59] ==> val localFixAction: raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>?..QuickFix<*>?) defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'it' @ [171:77] ==> value-parameter it: ProblemDescriptor defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor.<anonymous>[ValueParameterDescriptorImpl]

'fixes' @ [171:80] ==> public final val ProblemDescriptor.fixes: (Array<raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?)>?..Array<out raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?)>?)[MyPropertyDescriptor]

'toList' @ [171:87] ==> public fun <T> Array<out raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?)>.toList(): List<raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> raw (com.intellij.codeInspection.QuickFix<(com.intellij.codeInspection.CommonProblemDescriptor..com.intellij.codeInspection.CommonProblemDescriptor?)>..com.intellij.codeInspection.QuickFix<*>?)

'emptyList' @ [171:99] ==> public fun <T> emptyList(): List<raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>..QuickFix<*>?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> raw (com.intellij.codeInspection.QuickFix<(com.intellij.codeInspection.CommonProblemDescriptor..com.intellij.codeInspection.CommonProblemDescriptor?)>..com.intellij.codeInspection.QuickFix<*>?)

'project' @ [173:9] ==> public final val AbstractLocalInspectionTest.project: Project[MyPropertyDescriptor]

'executeWriteCommand' @ [173:17] ==> public fun <T> Project.executeWriteCommand(name: String, groupId: Any? = ..., command: () -> Unit): Unit defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Unit

'localFixAction' @ [173:37] ==> val localFixAction: raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>?..QuickFix<*>?) defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'name' @ [173:54] ==> public final val <D : (CommonProblemDescriptor..CommonProblemDescriptor?)> QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>.name: String[MyPropertyDescriptor]
Inferred types:
    <D : (CommonProblemDescriptor..CommonProblemDescriptor?)> -> (com.intellij.codeInspection.CommonProblemDescriptor..com.intellij.codeInspection.CommonProblemDescriptor?)

'localFixAction' @ [174:13] ==> val localFixAction: raw (QuickFix<(CommonProblemDescriptor..CommonProblemDescriptor?)>?..QuickFix<*>?) defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'applyFix' @ [174:28] ==> public abstract fun applyFix(@NotNull p0: Project, @NotNull p1: CommonProblemDescriptor): Unit defined in com.intellij.codeInspection.QuickFix[JavaMethodDescriptor]

'project' @ [174:37] ==> public final val AbstractLocalInspectionTest.project: Project[MyPropertyDescriptor]

'problemDescriptor' @ [174:46] ==> val problemDescriptor: ProblemDescriptor defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'mainFilePath' @ [176:43] ==> value-parameter mainFilePath: String defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[ValueParameterDescriptorImpl]

'afterFileNameSuffix' @ [176:58] ==> private final val afterFileNameSuffix: String defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest[PropertyDescriptorImpl]

'myFixture' @ [178:13] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest[JavaPropertyDescriptor]

'checkResultByFile' @ [178:23] ==> public abstract fun checkResultByFile(@NotNull p0: String): Unit defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'canonicalPathToExpectedFile' @ [178:41] ==> val canonicalPathToExpectedFile: String defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'assertEqualsToFile' @ [181:29] ==> public open fun assertEqualsToFile(@NotNull p0: File, @NotNull p1: String): Unit defined in org.jetbrains.kotlin.test.KotlinTestUtils[JavaMethodDescriptor]

'File' @ [182:21] ==> public constructor File(p0: (String..String?), p1: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'testDataPath' @ [182:26] ==> protected for synthetic extension final val AbstractLocalInspectionTest.testDataPath: String[MyPropertyDescriptor]

'canonicalPathToExpectedFile' @ [182:40] ==> val canonicalPathToExpectedFile: String defined in org.jetbrains.kotlin.idea.inspections.AbstractLocalInspectionTest.doTestFor[LocalVariableDescriptor]

'editor' @ [183:21] ==> public final val AbstractLocalInspectionTest.editor: Editor[MyPropertyDescriptor]

'document' @ [183:28] ==> public final val Editor.document: Document[MyPropertyDescriptor]

'text' @ [183:37] ==> public final val Document.text: String[MyPropertyDescriptor]

