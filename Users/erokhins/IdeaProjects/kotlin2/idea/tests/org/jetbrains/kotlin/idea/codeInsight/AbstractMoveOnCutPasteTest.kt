'AbstractCopyPasteTest' @ [35:45] ==> public constructor AbstractCopyPasteTest() defined in org.jetbrains.kotlin.idea.AbstractCopyPasteTest[ClassConstructorDescriptorImpl]

'+' @ [36:29] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'getTestDataPathBase' @ [36:48] ==> @NotNull public open fun getTestDataPathBase(): String defined in org.jetbrains.kotlin.idea.test.PluginTestCaseBase[JavaMethodDescriptor]

'BASE_PATH' @ [42:38] ==> private final val BASE_PATH: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest[PropertyDescriptorImpl]

'myFixture' @ [45:9] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest[JavaPropertyDescriptor]

'testDataPath' @ [45:19] ==> public final var JavaCodeInsightTestFixture.testDataPath: String[MyPropertyDescriptor]

'BASE_PATH' @ [45:34] ==> private final val BASE_PATH: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest[PropertyDescriptorImpl]

'File' @ [46:24] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'sourceFilePath' @ [46:29] ==> value-parameter sourceFilePath: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[ValueParameterDescriptorImpl]

'testFile' @ [47:30] ==> val testFile: File defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'name' @ [47:39] ==> public final val File.name: (String..String?)[MyPropertyDescriptor]

'loadFile' @ [48:37] ==> @NotNull public open fun loadFile(@NotNull p0: File, p1: Boolean): String defined in com.intellij.openapi.util.io.FileUtil[JavaMethodDescriptor]

'testFile' @ [48:46] ==> val testFile: File defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'sourceFileName' @ [50:34] ==> val sourceFileName: (String..String?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'replace' @ [50:49] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'configureByDependencyIfExists' @ [51:33] ==> protected final fun configureByDependencyIfExists(dependencyFileName: String): PsiFile? defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest[SimpleFunctionDescriptorImpl]

'dependencyFileName' @ [51:63] ==> val dependencyFileName: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'myFixture' @ [52:29] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest[JavaPropertyDescriptor]

'configureByFile' @ [52:39] ==> public abstract fun configureByFile(@NotNull p0: String): (PsiFile..PsiFile?) defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'sourceFileName' @ [52:55] ==> val sourceFileName: (String..String?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'isDirectiveDefined' @ [53:45] ==> public open fun isDirectiveDefined(p0: (String..String?), p1: (String..String?)): Boolean defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'testFileText' @ [53:64] ==> val testFileText: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'COPY_DIRECTIVE' @ [53:78] ==> private final val COPY_DIRECTIVE: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest[PropertyDescriptorImpl]

'myFixture' @ [54:27] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest[JavaPropertyDescriptor]

'editor' @ [54:37] ==> public final val JavaCodeInsightTestFixture.editor: (Editor..Editor?)[MyPropertyDescriptor]

'document' @ [54:44] ==> public final val Editor.document: Document[MyPropertyDescriptor]

'createRangeMarker' @ [54:53] ==> @NotNull public open fun createRangeMarker(p0: Int, p1: Int): RangeMarker defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'myFixture' @ [54:71] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest[JavaPropertyDescriptor]

'caretOffset' @ [54:81] ==> public final val JavaCodeInsightTestFixture.caretOffset: Int[MyPropertyDescriptor]

'myFixture' @ [54:94] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest[JavaPropertyDescriptor]

'caretOffset' @ [54:104] ==> public final val JavaCodeInsightTestFixture.caretOffset: Int[MyPropertyDescriptor]

'myFixture' @ [55:9] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest[JavaPropertyDescriptor]

'performEditorAction' @ [55:19] ==> public abstract fun performEditorAction(@NotNull p0: String): Unit defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'if (useCopy) IdeActions.ACTION_COPY else IdeActions.ACTION_CUT' @ [55:39] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'useCopy' @ [55:43] ==> val useCopy: Boolean defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'ACTION_COPY' @ [55:63] ==> @NonNls public const final val ACTION_COPY: String defined in com.intellij.openapi.actionSystem.IdeActions[JavaPropertyDescriptor]

'ACTION_CUT' @ [55:91] ==> @NonNls public const final val ACTION_CUT: String defined in com.intellij.openapi.actionSystem.IdeActions[JavaPropertyDescriptor]

'myFixture' @ [56:9] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest[JavaPropertyDescriptor]

'editor' @ [56:19] ==> public final val JavaCodeInsightTestFixture.editor: (Editor..Editor?)[MyPropertyDescriptor]

'moveCaret' @ [56:26] ==> public fun Editor.moveCaret(offset: Int, scrollType: ScrollType = ...): Unit defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]

'caretMarker' @ [56:36] ==> val caretMarker: RangeMarker defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'startOffset' @ [56:48] ==> public final val RangeMarker.startOffset: Int[MyPropertyDescriptor]

'getInstance' @ [57:28] ==> public open fun getInstance(@NotNull p0: Project): (PsiDocumentManager..PsiDocumentManager?) defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'project' @ [57:40] ==> public final val AbstractMoveOnCutPasteTest.project: Project[MyPropertyDescriptor]

'commitAllDocuments' @ [57:49] ==> public abstract fun commitAllDocuments(): Unit defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'isDirectiveDefined' @ [59:35] ==> public open fun isDirectiveDefined(p0: (String..String?), p1: (String..String?)): Boolean defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'testFileText' @ [59:54] ==> val testFileText: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'OPTIMIZE_IMPORTS_AFTER_CUT_DIRECTIVE' @ [59:68] ==> private final val OPTIMIZE_IMPORTS_AFTER_CUT_DIRECTIVE: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest[PropertyDescriptorImpl]

'OptimizeImportsProcessor' @ [60:13] ==> public constructor OptimizeImportsProcessor(p0: (Project..Project?), p1: (PsiFile..PsiFile?)) defined in com.intellij.codeInsight.actions.OptimizeImportsProcessor[JavaClassConstructorDescriptor]

'project' @ [60:38] ==> public final val AbstractMoveOnCutPasteTest.project: Project[MyPropertyDescriptor]

'sourcePsiFile' @ [60:47] ==> val sourcePsiFile: KtFile defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'run' @ [60:62] ==> public open fun run(): Unit defined in com.intellij.codeInsight.actions.OptimizeImportsProcessor[JavaMethodDescriptor]

'editor' @ [63:9] ==> public final val AbstractMoveOnCutPasteTest.editor: Editor[MyPropertyDescriptor]

'putUserData' @ [63:16] ==> public abstract fun <T : (Any..Any?)> putUserData(@NotNull p0: Key<(MoveDeclarationsEditorCookie..MoveDeclarationsEditorCookie?)>, @Nullable p1: MoveDeclarationsEditorCookie?): Unit defined in com.intellij.openapi.editor.Editor[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> MoveDeclarationsEditorCookie

'MoveDeclarationsEditorCookie' @ [63:28] ==> public companion object defined in org.jetbrains.kotlin.idea.refactoring.cutPaste.MoveDeclarationsEditorCookie[FakeCallableDescriptorForObject]

'KEY' @ [63:57] ==> public final val KEY: Key<MoveDeclarationsEditorCookie> defined in org.jetbrains.kotlin.idea.refactoring.cutPaste.MoveDeclarationsEditorCookie.Companion[DeserializedPropertyDescriptor]

'sourceFileName' @ [65:30] ==> val sourceFileName: (String..String?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'replace' @ [65:45] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'File' @ [66:32] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'testDataPath' @ [66:37] ==> protected for synthetic extension final val AbstractMoveOnCutPasteTest.testDataPath: String[MyPropertyDescriptor]

'separator' @ [66:57] ==> public const final val separator: (String..String?) defined in java.io.File[JavaPropertyDescriptor]

'targetFileName' @ [66:69] ==> val targetFileName: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'exists' @ [66:85] ==> public open fun exists(): Boolean defined in java.io.File[JavaMethodDescriptor]

'if (targetFileExists) configureTargetFile(targetFileName) else null' @ [67:29] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtFile?, elseBranch: KtFile?): KtFile?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtFile?

'targetFileExists' @ [67:33] ==> val targetFileExists: Boolean defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'configureTargetFile' @ [67:51] ==> protected final fun configureTargetFile(fileName: String): KtFile defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest[SimpleFunctionDescriptorImpl]

'targetFileName' @ [67:71] ==> val targetFileName: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'performNotWriteEditorAction' @ [68:9] ==> protected final fun performNotWriteEditorAction(actionId: String): Boolean defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest[SimpleFunctionDescriptorImpl]

'ACTION_PASTE' @ [68:48] ==> @NonNls public const final val ACTION_PASTE: String defined in com.intellij.openapi.actionSystem.IdeActions[JavaPropertyDescriptor]

'?:' @ [70:33] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: Boolean?, right: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> Boolean

'getPrefixedBoolean' @ [70:55] ==> @Nullable public open fun getPrefixedBoolean(p0: (String..String?), p1: (String..String?)): Boolean? defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'testFileText' @ [70:74] ==> val testFileText: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'IS_AVAILABLE_DIRECTIVE' @ [70:88] ==> private final val IS_AVAILABLE_DIRECTIVE: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest[PropertyDescriptorImpl]

'editor' @ [71:22] ==> public final val AbstractMoveOnCutPasteTest.editor: Editor[MyPropertyDescriptor]

'getUserData' @ [71:29] ==> @Nullable public abstract fun <T : (Any..Any?)> getUserData(@NotNull p0: Key<(MoveDeclarationsEditorCookie..MoveDeclarationsEditorCookie?)>): MoveDeclarationsEditorCookie? defined in com.intellij.openapi.editor.Editor[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> MoveDeclarationsEditorCookie

'MoveDeclarationsEditorCookie' @ [71:41] ==> public companion object defined in org.jetbrains.kotlin.idea.refactoring.cutPaste.MoveDeclarationsEditorCookie[FakeCallableDescriptorForObject]

'KEY' @ [71:70] ==> public final val KEY: Key<MoveDeclarationsEditorCookie> defined in org.jetbrains.kotlin.idea.refactoring.cutPaste.MoveDeclarationsEditorCookie.Companion[DeserializedPropertyDescriptor]

'cookie' @ [72:25] ==> val cookie: MoveDeclarationsEditorCookie? defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'let' @ [72:33] ==> @InlineOnly public inline fun <T, R> MoveDeclarationsEditorCookie.let(block: (MoveDeclarationsEditorCookie) -> MoveDeclarationsProcessor?): MoveDeclarationsProcessor? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> MoveDeclarationsEditorCookie
    <R> -> MoveDeclarationsProcessor?

'MoveDeclarationsProcessor' @ [72:39] ==> public companion object defined in org.jetbrains.kotlin.idea.refactoring.cutPaste.MoveDeclarationsProcessor[FakeCallableDescriptorForObject]

'build' @ [72:65] ==> public final fun build(editor: Editor, cookie: MoveDeclarationsEditorCookie): MoveDeclarationsProcessor? defined in org.jetbrains.kotlin.idea.refactoring.cutPaste.MoveDeclarationsProcessor.Companion[DeserializedSimpleFunctionDescriptor]

'editor' @ [72:71] ==> public final val AbstractMoveOnCutPasteTest.editor: Editor[MyPropertyDescriptor]

'cookie' @ [72:79] ==> val cookie: MoveDeclarationsEditorCookie? defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'assertEquals' @ [74:18] ==> public open fun assertEquals(p0: Boolean, p1: Boolean): Unit defined in junit.framework.TestCase[JavaMethodDescriptor]

'shouldBeAvailable' @ [74:31] ==> val shouldBeAvailable: Boolean defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'processor' @ [74:50] ==> val processor: MoveDeclarationsProcessor? defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'processor' @ [76:13] ==> val processor: MoveDeclarationsProcessor? defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'processor' @ [77:13] ==> val processor: MoveDeclarationsProcessor? defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'performRefactoring' @ [77:23] ==> public final fun performRefactoring(): Unit defined in org.jetbrains.kotlin.idea.refactoring.cutPaste.MoveDeclarationsProcessor[DeserializedSimpleFunctionDescriptor]

'getInstance' @ [79:32] ==> public open fun getInstance(@NotNull p0: Project): (PsiDocumentManager..PsiDocumentManager?) defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'project' @ [79:44] ==> public final val AbstractMoveOnCutPasteTest.project: Project[MyPropertyDescriptor]

'commitAllDocuments' @ [79:53] ==> public abstract fun commitAllDocuments(): Unit defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'dependencyPsiFile' @ [81:17] ==> val dependencyPsiFile: KtFile? defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'assertEqualsToFile' @ [82:33] ==> public open fun assertEqualsToFile(@NotNull p0: File, @NotNull p1: String): Unit defined in org.jetbrains.kotlin.test.KotlinTestUtils[JavaMethodDescriptor]

'File' @ [82:52] ==> public constructor File(p0: (String..String?), p1: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'BASE_PATH' @ [82:57] ==> private final val BASE_PATH: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest[PropertyDescriptorImpl]

'dependencyFileName' @ [82:68] ==> val dependencyFileName: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'replace' @ [82:87] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'dependencyPsiFile' @ [83:52] ==> val dependencyPsiFile: KtFile? defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'dumpTextWithErrors' @ [83:70] ==> public fun KtFile.dumpTextWithErrors(): String defined in org.jetbrains.kotlin.idea.test in file testUtils.kt[SimpleFunctionDescriptorImpl]

'assertEqualsToFile' @ [86:29] ==> public open fun assertEqualsToFile(@NotNull p0: File, @NotNull p1: String): Unit defined in org.jetbrains.kotlin.test.KotlinTestUtils[JavaMethodDescriptor]

'File' @ [86:48] ==> public constructor File(p0: (String..String?), p1: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'BASE_PATH' @ [86:53] ==> private final val BASE_PATH: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest[PropertyDescriptorImpl]

'sourceFileName' @ [86:64] ==> val sourceFileName: (String..String?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'replace' @ [86:79] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'sourcePsiFile' @ [87:48] ==> val sourcePsiFile: KtFile defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'dumpTextWithErrors' @ [87:62] ==> public fun KtFile.dumpTextWithErrors(): String defined in org.jetbrains.kotlin.idea.test in file testUtils.kt[SimpleFunctionDescriptorImpl]

'targetPsiFile' @ [88:17] ==> val targetPsiFile: KtFile? defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'assertEqualsToFile' @ [89:33] ==> public open fun assertEqualsToFile(@NotNull p0: File, @NotNull p1: String): Unit defined in org.jetbrains.kotlin.test.KotlinTestUtils[JavaMethodDescriptor]

'File' @ [89:52] ==> public constructor File(p0: (String..String?), p1: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'BASE_PATH' @ [89:57] ==> private final val BASE_PATH: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest[PropertyDescriptorImpl]

'targetFileName' @ [89:68] ==> val targetFileName: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'replace' @ [89:83] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'targetPsiFile' @ [90:52] ==> val targetPsiFile: KtFile? defined in org.jetbrains.kotlin.idea.codeInsight.AbstractMoveOnCutPasteTest.doTest[LocalVariableDescriptor]

'dumpTextWithErrors' @ [90:66] ==> public fun KtFile.dumpTextWithErrors(): String defined in org.jetbrains.kotlin.idea.test in file testUtils.kt[SimpleFunctionDescriptorImpl]

