'KotlinLightCodeInsightFixtureTestCase' @ [43:39] ==> public constructor KotlinLightCodeInsightFixtureTestCase() defined in org.jetbrains.kotlin.idea.test.KotlinLightCodeInsightFixtureTestCase[ClassConstructorDescriptorImpl]

'Throws' @ [44:5] ==> public constructor Throws(vararg exceptionClasses: KClass<out Throwable>) defined in kotlin.jvm.Throws[DeserializedClassConstructorDescriptor]

'Exception' @ [44:13] ==> public final fun <init>(): Exception /* = Exception */ defined in kotlin.Exception[TypeAliasConstructorDescriptorImpl]

'enableInspections' @ [46:9] ==> private final fun enableInspections(beforeFileName: String): Unit defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[SimpleFunctionDescriptorImpl]

'beforeFileName' @ [46:27] ==> value-parameter beforeFileName: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doTest[ValueParameterDescriptorImpl]

'doKotlinQuickFixTest' @ [48:9] ==> private final fun doKotlinQuickFixTest(beforeFileName: String): Unit defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[SimpleFunctionDescriptorImpl]

'beforeFileName' @ [48:30] ==> value-parameter beforeFileName: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doTest[ValueParameterDescriptorImpl]

'checkForUnexpectedErrors' @ [49:9] ==> public final fun checkForUnexpectedErrors(): Unit defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[SimpleFunctionDescriptorImpl]

'in' @ [53:13] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'testDataPath' @ [53:34] ==> protected for synthetic extension final val AbstractQuickFixTest.testDataPath: String[MyPropertyDescriptor]

'toLowerCase' @ [53:47] ==> @InlineOnly public inline fun String.toLowerCase(): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'INSTANCE' @ [54:66] ==> @NotNull public final val INSTANCE: KotlinWithJdkAndRuntimeLightProjectDescriptor defined in org.jetbrains.kotlin.idea.test.KotlinWithJdkAndRuntimeLightProjectDescriptor[JavaPropertyDescriptor]

'super' @ [56:16] ==> <this> defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[LazyClassReceiverParameterDescriptor]

'getProjectDescriptor' @ [56:22] ==> protected open fun getProjectDescriptor(): LightProjectDescriptor defined in org.jetbrains.kotlin.idea.test.KotlinLightCodeInsightFixtureTestCase[SimpleFunctionDescriptorImpl]

'isDirectiveDefined' @ [63:38] ==> public open fun isDirectiveDefined(p0: (String..String?), p1: (String..String?)): Boolean defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'myFixture' @ [63:57] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[JavaPropertyDescriptor]

'file' @ [63:67] ==> public final val JavaCodeInsightTestFixture.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'text' @ [63:72] ==> public final val PsiFile.text: (String..String?)[MyPropertyDescriptor]

'File' @ [71:24] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'beforeFileName' @ [71:29] ==> value-parameter beforeFileName: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest[ValueParameterDescriptorImpl]

'getInstance' @ [72:26] ==> public open fun getInstance(): (CommandProcessor..CommandProcessor?) defined in com.intellij.openapi.command.CommandProcessor[JavaMethodDescriptor]

'executeCommand' @ [72:40] ==> public final fun executeCommand(@Nullable p0: Project?, @NotNull p1: () -> Unit, @Nullable p2: String?, @Nullable p3: Any?): Unit defined in com.intellij.openapi.command.CommandProcessor[MyFunctionDescriptor]

'project' @ [72:55] ==> public final val AbstractQuickFixTest.project: Project[MyPropertyDescriptor]

'emptyList' @ [75:34] ==> public fun <T> emptyList(): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'fileText' @ [77:17] ==> var fileText: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest.<anonymous>[LocalVariableDescriptor]

'loadFile' @ [77:37] ==> @NotNull public open fun loadFile(@NotNull p0: File, @NotNull p1: Charset): String defined in com.intellij.openapi.util.io.FileUtil[JavaMethodDescriptor]

'testFile' @ [77:46] ==> val testFile: File defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest[LocalVariableDescriptor]

'UTF8_CHARSET' @ [77:71] ==> public final val UTF8_CHARSET: (Charset..Charset?) defined in com.intellij.openapi.vfs.CharsetToolkit[JavaPropertyDescriptor]

'assertTrue' @ [78:26] ==> public open fun assertTrue(p0: (String..String?), p1: Boolean): Unit defined in junit.framework.TestCase[JavaMethodDescriptor]

'testFile' @ [78:73] ==> val testFile: File defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest[LocalVariableDescriptor]

'path' @ [78:82] ==> public final val File.path: (String..String?)[MyPropertyDescriptor]

'fileText' @ [78:92] ==> var fileText: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest.<anonymous>[LocalVariableDescriptor]

'contains' @ [78:101] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'fixtureClasses' @ [80:17] ==> var fixtureClasses: List<String> defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest.<anonymous>[LocalVariableDescriptor]

'findListWithPrefixes' @ [80:56] ==> @NotNull public open fun findListWithPrefixes(@NotNull p0: String, @NotNull vararg p1: (String..String?)): (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'fileText' @ [80:77] ==> var fileText: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest.<anonymous>[LocalVariableDescriptor]

'fixtureClasses' @ [81:38] ==> var fixtureClasses: List<String> defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest.<anonymous>[LocalVariableDescriptor]

'TestFixtureExtension' @ [82:21] ==> public companion object defined in org.jetbrains.kotlin.idea.test.TestFixtureExtension[FakeCallableDescriptorForObject]

'loadFixture' @ [82:42] ==> @Suppress public final fun loadFixture(className: String, module: Module): TestFixtureExtension defined in org.jetbrains.kotlin.idea.test.TestFixtureExtension.Companion[SimpleFunctionDescriptorImpl]

'fixtureClass' @ [82:54] ==> val fixtureClass: (String..String?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest.<anonymous>[LocalVariableDescriptor]

'getModule' @ [82:90] ==> public open fun getModule(): (Module..Module?) defined in com.intellij.testFramework.LightPlatformTestCase[JavaMethodDescriptor]

'expectedErrorMessage' @ [85:17] ==> var expectedErrorMessage: String? defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest.<anonymous>[LocalVariableDescriptor]

'findStringWithPrefixes' @ [85:62] ==> @Nullable public open fun findStringWithPrefixes(p0: (String..String?), vararg p1: (String..String?)): String? defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'fileText' @ [85:85] ==> var fileText: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest.<anonymous>[LocalVariableDescriptor]

'convertLineSeparators' @ [86:43] ==> @NotNull @Contract public open fun convertLineSeparators(@NotNull p0: String): String defined in com.intellij.openapi.util.text.StringUtil[JavaMethodDescriptor]

'fileText' @ [86:65] ==> var fileText: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest.<anonymous>[LocalVariableDescriptor]

'myFixture' @ [87:17] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[JavaPropertyDescriptor]

'configureByText' @ [87:27] ==> public abstract fun configureByText(@NotNull p0: String, @NotNull p1: String): (PsiFile..PsiFile?) defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'testFile' @ [87:43] ==> val testFile: File defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest[LocalVariableDescriptor]

'canonicalFile' @ [87:52] ==> public final val File.canonicalFile: (File..File?)[MyPropertyDescriptor]

'name' @ [87:66] ==> public final val File.name: (String..String?)[MyPropertyDescriptor]

'contents' @ [87:72] ==> val contents: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest.<anonymous>[LocalVariableDescriptor]

'checkForUnexpectedActions' @ [89:17] ==> @Throws private final fun checkForUnexpectedActions(): Unit defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[SimpleFunctionDescriptorImpl]

'configExtra' @ [91:17] ==> protected open fun configExtra(options: String): Unit defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[SimpleFunctionDescriptorImpl]

'fileText' @ [91:29] ==> var fileText: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest.<anonymous>[LocalVariableDescriptor]

'applyAction' @ [93:17] ==> private final fun applyAction(contents: String, testFullPath: String): Unit defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[SimpleFunctionDescriptorImpl]

'contents' @ [93:29] ==> val contents: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest.<anonymous>[LocalVariableDescriptor]

'testFile' @ [93:39] ==> val testFile: File defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest[LocalVariableDescriptor]

'canonicalPath' @ [93:48] ==> public final val File.canonicalPath: (String..String?)[MyPropertyDescriptor]

'assertEmpty' @ [95:32] ==> public open fun assertEmpty(p0: (String..String?)): Unit defined in com.intellij.testFramework.UsefulTestCase[JavaMethodDescriptor]

'expectedErrorMessage' @ [95:44] ==> var expectedErrorMessage: String? defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest.<anonymous>[LocalVariableDescriptor]

'e' @ [98:23] ==> val e: FileComparisonFailure defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest.<anonymous>[LocalVariableDescriptor]

'e' @ [101:23] ==> val e: AssertionError /* = AssertionError */ defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest.<anonymous>[LocalVariableDescriptor]

'expectedErrorMessage' @ [104:21] ==> var expectedErrorMessage: String? defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest.<anonymous>[LocalVariableDescriptor]

'expectedErrorMessage' @ [104:53] ==> var expectedErrorMessage: String? defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest.<anonymous>[LocalVariableDescriptor]

'e' @ [104:77] ==> val e: Throwable defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest.<anonymous>[LocalVariableDescriptor]

'message' @ [104:79] ==> public open val message: String? defined in kotlin.Throwable[DeserializedPropertyDescriptor]

'e' @ [105:21] ==> val e: Throwable defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest.<anonymous>[LocalVariableDescriptor]

'printStackTrace' @ [105:23] ==> public open fun printStackTrace(): Unit defined in kotlin.Throwable[JavaMethodDescriptor]

'fail' @ [106:30] ==> public open fun fail(p0: (String..String?)): Unit defined in junit.framework.TestCase[JavaMethodDescriptor]

'getTestName' @ [106:35] ==> @NotNull protected/*protected and package*/ open fun getTestName(p0: Boolean): String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[JavaMethodDescriptor]

'fixtureClasses' @ [110:38] ==> var fixtureClasses: List<String> defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest.<anonymous>[LocalVariableDescriptor]

'TestFixtureExtension' @ [111:21] ==> public companion object defined in org.jetbrains.kotlin.idea.test.TestFixtureExtension[FakeCallableDescriptorForObject]

'unloadFixture' @ [111:42] ==> public final fun unloadFixture(className: String): Unit defined in org.jetbrains.kotlin.idea.test.TestFixtureExtension.Companion[SimpleFunctionDescriptorImpl]

'fixtureClass' @ [111:56] ==> val fixtureClass: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest.<anonymous>[LocalVariableDescriptor]

'ConfigLibraryUtil' @ [113:17] ==> public object ConfigLibraryUtil defined in org.jetbrains.kotlin.idea.test in file ConfigLibraryUtil.kt[FakeCallableDescriptorForObject]

'unconfigureLibrariesByDirective' @ [113:35] ==> public final fun unconfigureLibrariesByDirective(module: Module, fileText: String): Unit defined in org.jetbrains.kotlin.idea.test.ConfigLibraryUtil[SimpleFunctionDescriptorImpl]

'myFixture' @ [113:67] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[JavaPropertyDescriptor]

'module' @ [113:77] ==> public final val JavaCodeInsightTestFixture.module: (Module..Module?)[MyPropertyDescriptor]

'fileText' @ [113:85] ==> var fileText: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.doKotlinQuickFixTest.<anonymous>[LocalVariableDescriptor]

'testFullPath' @ [119:24] ==> value-parameter testFullPath: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.applyAction[ValueParameterDescriptorImpl]

'substringAfterLast' @ [119:37] ==> public fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'separatorChar' @ [119:61] ==> public const final val separatorChar: Char defined in java.io.File[JavaPropertyDescriptor]

'parse' @ [120:37] ==> @NotNull public open fun parse(@NotNull p0: PsiFile, @NotNull p1: String): ActionHint defined in com.intellij.codeInsight.daemon.quickFix.ActionHint[JavaMethodDescriptor]

'myFixture' @ [120:43] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[JavaPropertyDescriptor]

'file' @ [120:53] ==> public final val JavaCodeInsightTestFixture.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'contents' @ [120:59] ==> value-parameter contents: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.applyAction[ValueParameterDescriptorImpl]

'replace' @ [120:68] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'fileName' @ [120:88] ==> val fileName: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.applyAction[LocalVariableDescriptor]

'findActionWithText' @ [121:25] ==> public final fun findActionWithText(text: String): IntentionAction? defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[SimpleFunctionDescriptorImpl]

'actionHint' @ [121:44] ==> val actionHint: ActionHint defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.applyAction[LocalVariableDescriptor]

'expectedText' @ [121:55] ==> public final val ActionHint.expectedText: (String..String?)[MyPropertyDescriptor]

'if (actionHint.shouldPresent()) {
            if (intention == null) {
                fail("Action with text '" + actionHint.expectedText + "' not found\nAvailable actions: " +
                     myFixture.availableIntentions.joinToString(prefix = "[", postfix = "]") { it.text })
            }
            myFixture.launchAction(intention!!)
            UIUtil.dispatchAllInvocationEvents()
            UIUtil.dispatchAllInvocationEvents()

            if (!shouldBeAvailableAfterExecution()) {
                assertNull("Action '${actionHint.expectedText}' is still available after its invocation in test " + testFullPath,
                            findActionWithText(actionHint.expectedText))
            }

            myFixture.checkResultByFile(File(testFullPath).name + ".after")
        }
        else {
            assertNull("Action with text ${actionHint.expectedText} is present, but should not", intention)
        }' @ [122:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'actionHint' @ [122:13] ==> val actionHint: ActionHint defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.applyAction[LocalVariableDescriptor]

'shouldPresent' @ [122:24] ==> public open fun shouldPresent(): Boolean defined in com.intellij.codeInsight.daemon.quickFix.ActionHint[JavaMethodDescriptor]

'intention' @ [123:17] ==> val intention: IntentionAction? defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.applyAction[LocalVariableDescriptor]

'fail' @ [124:17] ==> public open fun fail(p0: (String..String?)): Unit defined in org.jetbrains.kotlin.idea.test.KotlinLightCodeInsightFixtureTestCaseBase[JavaMethodDescriptor]

'+' @ [124:22] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'actionHint' @ [124:45] ==> val actionHint: ActionHint defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.applyAction[LocalVariableDescriptor]

'expectedText' @ [124:56] ==> public final val ActionHint.expectedText: (String..String?)[MyPropertyDescriptor]

'myFixture' @ [125:22] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[JavaPropertyDescriptor]

'availableIntentions' @ [125:32] ==> public final val JavaCodeInsightTestFixture.availableIntentions: (MutableList<(IntentionAction..IntentionAction?)>..List<(IntentionAction..IntentionAction?)>)[MyPropertyDescriptor]

'joinToString' @ [125:52] ==> public fun <T> Iterable<(IntentionAction..IntentionAction?)>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: (((IntentionAction..IntentionAction?)) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.codeInsight.intention.IntentionAction..com.intellij.codeInsight.intention.IntentionAction?)

'it' @ [125:96] ==> value-parameter it: (IntentionAction..IntentionAction?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.applyAction.<anonymous>[ValueParameterDescriptorImpl]

'text' @ [125:99] ==> public final val IntentionAction.text: String[MyPropertyDescriptor]

'myFixture' @ [127:13] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[JavaPropertyDescriptor]

'launchAction' @ [127:23] ==> public abstract fun launchAction(@NotNull p0: IntentionAction): Unit defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'intention' @ [127:36] ==> val intention: IntentionAction? defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.applyAction[LocalVariableDescriptor]

'dispatchAllInvocationEvents' @ [128:20] ==> public open fun dispatchAllInvocationEvents(): Unit defined in com.intellij.util.ui.UIUtil[JavaMethodDescriptor]

'dispatchAllInvocationEvents' @ [129:20] ==> public open fun dispatchAllInvocationEvents(): Unit defined in com.intellij.util.ui.UIUtil[JavaMethodDescriptor]

'!' @ [131:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'shouldBeAvailableAfterExecution' @ [131:18] ==> public final fun shouldBeAvailableAfterExecution(): Boolean defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[SimpleFunctionDescriptorImpl]

'assertNull' @ [132:17] ==> public open fun assertNull(p0: (String..String?), p1: (Any..Any?)): Unit defined in org.jetbrains.kotlin.idea.test.KotlinLightCodeInsightFixtureTestCaseBase[JavaMethodDescriptor]

'+' @ [132:28] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'actionHint' @ [132:39] ==> val actionHint: ActionHint defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.applyAction[LocalVariableDescriptor]

'expectedText' @ [132:50] ==> public final val ActionHint.expectedText: (String..String?)[MyPropertyDescriptor]

'testFullPath' @ [132:117] ==> value-parameter testFullPath: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.applyAction[ValueParameterDescriptorImpl]

'findActionWithText' @ [133:29] ==> public final fun findActionWithText(text: String): IntentionAction? defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[SimpleFunctionDescriptorImpl]

'actionHint' @ [133:48] ==> val actionHint: ActionHint defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.applyAction[LocalVariableDescriptor]

'expectedText' @ [133:59] ==> public final val ActionHint.expectedText: (String..String?)[MyPropertyDescriptor]

'myFixture' @ [136:13] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[JavaPropertyDescriptor]

'checkResultByFile' @ [136:23] ==> public abstract fun checkResultByFile(@NotNull p0: String): Unit defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'File' @ [136:41] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'testFullPath' @ [136:46] ==> value-parameter testFullPath: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.applyAction[ValueParameterDescriptorImpl]

'name' @ [136:60] ==> public final val File.name: (String..String?)[MyPropertyDescriptor]

'assertNull' @ [139:13] ==> public open fun assertNull(p0: (String..String?), p1: (Any..Any?)): Unit defined in org.jetbrains.kotlin.idea.test.KotlinLightCodeInsightFixtureTestCaseBase[JavaMethodDescriptor]

'actionHint' @ [139:44] ==> val actionHint: ActionHint defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.applyAction[LocalVariableDescriptor]

'expectedText' @ [139:55] ==> public final val ActionHint.expectedText: (String..String?)[MyPropertyDescriptor]

'intention' @ [139:98] ==> val intention: IntentionAction? defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.applyAction[LocalVariableDescriptor]

'loadFile' @ [144:39] ==> @NotNull public open fun loadFile(@NotNull p0: File): String defined in com.intellij.openapi.util.io.FileUtil[JavaMethodDescriptor]

'File' @ [144:48] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'beforeFileName' @ [144:53] ==> value-parameter beforeFileName: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.enableInspections[ValueParameterDescriptorImpl]

'findListWithPrefixes' @ [145:50] ==> @NotNull public open fun findListWithPrefixes(@NotNull p0: String, @NotNull vararg p1: (String..String?)): (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'beforeFileText' @ [145:71] ==> val beforeFileText: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.enableInspections[LocalVariableDescriptor]

'toolsStrings' @ [146:13] ==> val toolsStrings: (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.enableInspections[LocalVariableDescriptor]

'isNotEmpty' @ [146:26] ==> @InlineOnly public inline fun <T> Collection<(String..String?)>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.String..kotlin.String?)

'toolsStrings' @ [147:32] ==> val toolsStrings: (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.enableInspections[LocalVariableDescriptor]

'map' @ [147:45] ==> public inline fun <T, R> Iterable<(String..String?)>.map(transform: ((String..String?)) -> LocalInspectionTool): List<LocalInspectionTool> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.String..kotlin.String?)
    <R> -> LocalInspectionTool

'forName' @ [149:40] ==> @CallerSensitive public open fun forName(p0: (String..String?)): (Class<*>..Class<*>?) defined in java.lang.Class[JavaMethodDescriptor]

'toolFqName' @ [149:48] ==> value-parameter toolFqName: (String..String?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.enableInspections.<anonymous>[ValueParameterDescriptorImpl]

'aClass' @ [150:32] ==> val aClass: (Class<*>..Class<*>?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.enableInspections.<anonymous>[LocalVariableDescriptor]

'newInstance' @ [150:39] ==> @CallerSensitive public open fun newInstance(): (Any..Any?) defined in java.lang.Class[JavaMethodDescriptor]

'IllegalArgumentException' @ [153:27] ==> public final fun <init>(p0: (String..String?), p1: (Throwable..Throwable?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'toolFqName' @ [153:91] ==> value-parameter toolFqName: (String..String?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.enableInspections.<anonymous>[ValueParameterDescriptorImpl]

'e' @ [153:105] ==> val e: Exception /* = Exception */ defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.enableInspections.<anonymous>[LocalVariableDescriptor]

'myFixture' @ [156:13] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[JavaPropertyDescriptor]

'enableInspections' @ [156:23] ==> public abstract fun enableInspections(@NotNull vararg p0: (InspectionProfileEntry..InspectionProfileEntry?)): Unit defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'inspections' @ [156:42] ==> val inspections: List<LocalInspectionTool> defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.enableInspections[LocalVariableDescriptor]

'toTypedArray' @ [156:54] ==> public inline fun <reified T> Collection<LocalInspectionTool>.toTypedArray(): Array<LocalInspectionTool> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T> -> LocalInspectionTool

'findInspectionFile' @ [160:30] ==> public fun findInspectionFile(startDir: File): File? defined in org.jetbrains.kotlin.idea.quickfix.utils in file quickfixTestUtils.kt[SimpleFunctionDescriptorImpl]

'File' @ [160:49] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'beforeFileName' @ [160:54] ==> value-parameter beforeFileName: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.enableInspections[ValueParameterDescriptorImpl]

'parentFile' @ [160:70] ==> public final val File.parentFile: (File..File?)[MyPropertyDescriptor]

'inspectionFile' @ [161:13] ==> val inspectionFile: File? defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.enableInspections[LocalVariableDescriptor]

'loadFile' @ [162:38] ==> @NotNull public open fun loadFile(@NotNull p0: File): String defined in com.intellij.openapi.util.io.FileUtil[JavaMethodDescriptor]

'inspectionFile' @ [162:47] ==> val inspectionFile: File? defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.enableInspections[LocalVariableDescriptor]

'trim' @ [162:63] ==> public inline fun String.trim(predicate: (Char) -> Boolean): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'it' @ [162:70] ==> value-parameter it: Char defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.enableInspections.<anonymous>[ValueParameterDescriptorImpl]

'forName' @ [163:41] ==> @CallerSensitive public open fun forName(p0: (String..String?)): (Class<*>..Class<*>?) defined in java.lang.Class[JavaMethodDescriptor]

'className' @ [163:49] ==> val className: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.enableInspections[LocalVariableDescriptor]

'instantiateTools' @ [164:44] ==> @NotNull public open fun <T : (InspectionProfileEntry..InspectionProfileEntry?)> instantiateTools(@NotNull p0: (MutableCollection<(Class<out (InspectionProfileEntry..InspectionProfileEntry?)>..Class<out (InspectionProfileEntry..InspectionProfileEntry?)>?)>..Collection<(Class<out (InspectionProfileEntry..InspectionProfileEntry?)>..Class<out (InspectionProfileEntry..InspectionProfileEntry?)>?)>)): (MutableList<(InspectionProfileEntry..InspectionProfileEntry?)>..List<(InspectionProfileEntry..InspectionProfileEntry?)>) defined in com.intellij.testFramework.InspectionTestUtil[JavaMethodDescriptor]
Inferred types:
    <T : (InspectionProfileEntry..InspectionProfileEntry?)> -> (com.intellij.codeInspection.InspectionProfileEntry..com.intellij.codeInspection.InspectionProfileEntry?)

'listOf' @ [165:21] ==> public fun <T> listOf(element: Class<out InspectionProfileEntry>): List<Class<out InspectionProfileEntry>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Class<out InspectionProfileEntry>

'inspectionClass' @ [165:63] ==> val inspectionClass: Class<InspectionProfileEntry> defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.enableInspections[LocalVariableDescriptor]

'myFixture' @ [166:13] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[JavaPropertyDescriptor]

'enableInspections' @ [166:23] ==> public abstract fun enableInspections(@NotNull vararg p0: (InspectionProfileEntry..InspectionProfileEntry?)): Unit defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'tools' @ [166:42] ==> val tools: (MutableList<(InspectionProfileEntry..InspectionProfileEntry?)>..List<(InspectionProfileEntry..InspectionProfileEntry?)>) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.enableInspections[LocalVariableDescriptor]

'toTypedArray' @ [166:48] ==> public inline fun <reified T> Collection<(InspectionProfileEntry..InspectionProfileEntry?)>.toTypedArray(): Array<(InspectionProfileEntry..InspectionProfileEntry?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T> -> (com.intellij.codeInspection.InspectionProfileEntry..com.intellij.codeInspection.InspectionProfileEntry?)

'Throws' @ [170:5] ==> public constructor Throws(vararg exceptionClasses: KClass<out Throwable>) defined in kotlin.jvm.Throws[DeserializedClassConstructorDescriptor]

'ClassNotFoundException' @ [170:13] ==> public constructor ClassNotFoundException() defined in java.lang.ClassNotFoundException[JavaClassConstructorDescriptor]

'myFixture' @ [172:20] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[JavaPropertyDescriptor]

'editor' @ [172:30] ==> public final val JavaCodeInsightTestFixture.editor: (Editor..Editor?)[MyPropertyDescriptor]

'document' @ [172:37] ==> public final val Editor.document: Document[MyPropertyDescriptor]

'text' @ [172:46] ==> public final val Document.text: String[MyPropertyDescriptor]

'parse' @ [173:37] ==> @NotNull public open fun parse(@NotNull p0: PsiFile, @NotNull p1: String): ActionHint defined in com.intellij.codeInsight.daemon.quickFix.ActionHint[JavaMethodDescriptor]

'myFixture' @ [173:43] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[JavaPropertyDescriptor]

'file' @ [173:53] ==> public final val JavaCodeInsightTestFixture.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'text' @ [173:59] ==> val text: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions[LocalVariableDescriptor]

'!' @ [174:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'actionHint' @ [174:14] ==> val actionHint: ActionHint defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions[LocalVariableDescriptor]

'shouldPresent' @ [174:25] ==> public open fun shouldPresent(): Boolean defined in com.intellij.codeInsight.daemon.quickFix.ActionHint[JavaMethodDescriptor]

'myFixture' @ [175:27] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[JavaPropertyDescriptor]

'availableIntentions' @ [175:37] ==> public final val JavaCodeInsightTestFixture.availableIntentions: (MutableList<(IntentionAction..IntentionAction?)>..List<(IntentionAction..IntentionAction?)>)[MyPropertyDescriptor]

'if (actionHint.expectedText.startsWith(prefix)) {
                val className = actionHint.expectedText.substring(prefix.length)
                val aClass = Class.forName(className)
                assert(IntentionAction::class.java.isAssignableFrom(aClass)) { className + " should be inheritor of IntentionAction" }

                val validActions = HashSet(InTextDirectivesUtils.findLinesWithPrefixesRemoved(text, "// ACTION:"))

                actions.removeAll { action -> !aClass.isAssignableFrom(action.javaClass) || validActions.contains(action.text) }

                if (!actions.isEmpty()) {
                    Assert.fail("Unexpected intention actions present\n " + actions.map { action -> action.javaClass.toString() + " " + action.toString() + "\n" }
                    )
                }

                for (action in actions) {
                    if (aClass.isAssignableFrom(action.javaClass) && !validActions.contains(action.text)) {
                        Assert.fail("Unexpected intention action " + action.javaClass + " found")
                    }
                }
            }
            else {
                // Action shouldn't be found. Check that other actions are expected and thus tested action isn't there under another name.
                DirectiveBasedActionUtils.checkAvailableActionsAreExpected(myFixture.file, actions)
            }' @ [178:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'actionHint' @ [178:17] ==> val actionHint: ActionHint defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions[LocalVariableDescriptor]

'expectedText' @ [178:28] ==> public final val ActionHint.expectedText: (String..String?)[MyPropertyDescriptor]

'startsWith' @ [178:41] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'prefix' @ [178:52] ==> val prefix: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions[LocalVariableDescriptor]

'actionHint' @ [179:33] ==> val actionHint: ActionHint defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions[LocalVariableDescriptor]

'expectedText' @ [179:44] ==> public final val ActionHint.expectedText: (String..String?)[MyPropertyDescriptor]

'substring' @ [179:57] ==> @InlineOnly public inline fun String.substring(startIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'prefix' @ [179:67] ==> val prefix: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions[LocalVariableDescriptor]

'length' @ [179:74] ==> public open val length: Int defined in kotlin.String[DeserializedPropertyDescriptor]

'forName' @ [180:36] ==> @CallerSensitive public open fun forName(p0: (String..String?)): (Class<*>..Class<*>?) defined in java.lang.Class[JavaMethodDescriptor]

'className' @ [180:44] ==> val className: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions[LocalVariableDescriptor]

'assert' @ [181:17] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'java' @ [181:47] ==> public val <T> KClass<IntentionAction>.java: Class<IntentionAction> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> IntentionAction

'isAssignableFrom' @ [181:52] ==> public open fun isAssignableFrom(p0: (Class<*>..Class<*>?)): Boolean defined in java.lang.Class[JavaMethodDescriptor]

'aClass' @ [181:69] ==> val aClass: (Class<*>..Class<*>?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions[LocalVariableDescriptor]

'className' @ [181:80] ==> val className: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions[LocalVariableDescriptor]

'HashSet' @ [183:36] ==> public final fun <E> <init>(p0: (MutableCollection<out (String..String?)>..Collection<(String..String?)>?)): HashSet<(String..String?)> /* = HashSet<(String..String?)> */ defined in kotlin.collections.HashSet[TypeAliasConstructorDescriptorImpl]
Inferred types:
    <E> -> (kotlin.String..kotlin.String?)

'findLinesWithPrefixesRemoved' @ [183:66] ==> @NotNull public open fun findLinesWithPrefixesRemoved(p0: (String..String?), vararg p1: (String..String?)): (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'text' @ [183:95] ==> val text: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions[LocalVariableDescriptor]

'actions' @ [185:17] ==> val actions: (MutableList<(IntentionAction..IntentionAction?)>..List<(IntentionAction..IntentionAction?)>) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions[LocalVariableDescriptor]

'removeAll' @ [185:25] ==> public fun <T> MutableList<(IntentionAction..IntentionAction?)>.removeAll(predicate: ((IntentionAction..IntentionAction?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.codeInsight.intention.IntentionAction..com.intellij.codeInsight.intention.IntentionAction?)

'!' @ [185:47] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'aClass' @ [185:48] ==> val aClass: (Class<*>..Class<*>?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions[LocalVariableDescriptor]

'isAssignableFrom' @ [185:55] ==> public open fun isAssignableFrom(p0: (Class<*>..Class<*>?)): Boolean defined in java.lang.Class[JavaMethodDescriptor]

'action' @ [185:72] ==> value-parameter action: (IntentionAction..IntentionAction?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions.<anonymous>[ValueParameterDescriptorImpl]

'javaClass' @ [185:79] ==> public val <T : Any> (IntentionAction..IntentionAction?).javaClass: Class<(IntentionAction..IntentionAction?)> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> (com.intellij.codeInsight.intention.IntentionAction..com.intellij.codeInsight.intention.IntentionAction?)

'validActions' @ [185:93] ==> val validActions: HashSet<(String..String?)> /* = HashSet<(String..String?)> */ defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions[LocalVariableDescriptor]

'contains' @ [185:106] ==> public open fun contains(element: (String..String?)): Boolean defined in java.util.HashSet[JavaMethodDescriptor]

'action' @ [185:115] ==> value-parameter action: (IntentionAction..IntentionAction?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions.<anonymous>[ValueParameterDescriptorImpl]

'text' @ [185:122] ==> public final val IntentionAction.text: String[MyPropertyDescriptor]

'!' @ [187:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'actions' @ [187:22] ==> val actions: (MutableList<(IntentionAction..IntentionAction?)>..List<(IntentionAction..IntentionAction?)>) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions[LocalVariableDescriptor]

'isEmpty' @ [187:30] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'fail' @ [188:28] ==> public open fun fail(p0: (String..String?)): Unit defined in org.junit.Assert[JavaMethodDescriptor]

'+' @ [188:33] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'actions' @ [188:77] ==> val actions: (MutableList<(IntentionAction..IntentionAction?)>..List<(IntentionAction..IntentionAction?)>) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions[LocalVariableDescriptor]

'map' @ [188:85] ==> public inline fun <T, R> Iterable<(IntentionAction..IntentionAction?)>.map(transform: ((IntentionAction..IntentionAction?)) -> String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.codeInsight.intention.IntentionAction..com.intellij.codeInsight.intention.IntentionAction?)
    <R> -> String

'action' @ [188:101] ==> value-parameter action: (IntentionAction..IntentionAction?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions.<anonymous>[ValueParameterDescriptorImpl]

'javaClass' @ [188:108] ==> public val <T : Any> (IntentionAction..IntentionAction?).javaClass: Class<(IntentionAction..IntentionAction?)> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> (com.intellij.codeInsight.intention.IntentionAction..com.intellij.codeInsight.intention.IntentionAction?)

'toString' @ [188:118] ==> public open fun toString(): String defined in java.lang.Class[JavaMethodDescriptor]

'action' @ [188:137] ==> value-parameter action: (IntentionAction..IntentionAction?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions.<anonymous>[ValueParameterDescriptorImpl]

'toString' @ [188:144] ==> public open fun toString(): String defined in com.intellij.codeInsight.intention.IntentionAction[DeserializedSimpleFunctionDescriptor]

'actions' @ [192:32] ==> val actions: (MutableList<(IntentionAction..IntentionAction?)>..List<(IntentionAction..IntentionAction?)>) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions[LocalVariableDescriptor]

'aClass' @ [193:25] ==> val aClass: (Class<*>..Class<*>?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions[LocalVariableDescriptor]

'isAssignableFrom' @ [193:32] ==> public open fun isAssignableFrom(p0: (Class<*>..Class<*>?)): Boolean defined in java.lang.Class[JavaMethodDescriptor]

'action' @ [193:49] ==> val action: (IntentionAction..IntentionAction?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions[LocalVariableDescriptor]

'javaClass' @ [193:56] ==> public val <T : Any> (IntentionAction..IntentionAction?).javaClass: Class<(IntentionAction..IntentionAction?)> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> (com.intellij.codeInsight.intention.IntentionAction..com.intellij.codeInsight.intention.IntentionAction?)

'!' @ [193:70] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'validActions' @ [193:71] ==> val validActions: HashSet<(String..String?)> /* = HashSet<(String..String?)> */ defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions[LocalVariableDescriptor]

'contains' @ [193:84] ==> public open fun contains(element: (String..String?)): Boolean defined in java.util.HashSet[JavaMethodDescriptor]

'action' @ [193:93] ==> val action: (IntentionAction..IntentionAction?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions[LocalVariableDescriptor]

'text' @ [193:100] ==> public final val IntentionAction.text: String[MyPropertyDescriptor]

'fail' @ [194:32] ==> public open fun fail(p0: (String..String?)): Unit defined in org.junit.Assert[JavaMethodDescriptor]

'+' @ [194:37] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'action' @ [194:70] ==> val action: (IntentionAction..IntentionAction?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions[LocalVariableDescriptor]

'javaClass' @ [194:77] ==> public val <T : Any> (IntentionAction..IntentionAction?).javaClass: Class<(IntentionAction..IntentionAction?)> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> (com.intellij.codeInsight.intention.IntentionAction..com.intellij.codeInsight.intention.IntentionAction?)

'checkAvailableActionsAreExpected' @ [200:43] ==> public final fun checkAvailableActionsAreExpected(file: PsiFile, availableActions: Collection<IntentionAction>): Unit defined in org.jetbrains.kotlin.idea.test.DirectiveBasedActionUtils[SimpleFunctionDescriptorImpl]

'myFixture' @ [200:76] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[JavaPropertyDescriptor]

'file' @ [200:86] ==> public final val JavaCodeInsightTestFixture.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'actions' @ [200:92] ==> val actions: (MutableList<(IntentionAction..IntentionAction?)>..List<(IntentionAction..IntentionAction?)>) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.checkForUnexpectedActions[LocalVariableDescriptor]

'myFixture' @ [206:26] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[JavaPropertyDescriptor]

'availableIntentions' @ [206:36] ==> public final val JavaCodeInsightTestFixture.availableIntentions: (MutableList<(IntentionAction..IntentionAction?)>..List<(IntentionAction..IntentionAction?)>)[MyPropertyDescriptor]

'filter' @ [206:56] ==> public inline fun <T> Iterable<(IntentionAction..IntentionAction?)>.filter(predicate: ((IntentionAction..IntentionAction?)) -> Boolean): List<(IntentionAction..IntentionAction?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.codeInsight.intention.IntentionAction..com.intellij.codeInsight.intention.IntentionAction?)

'it' @ [206:65] ==> value-parameter it: (IntentionAction..IntentionAction?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.findActionWithText.<anonymous>[ValueParameterDescriptorImpl]

'text' @ [206:68] ==> public final val IntentionAction.text: String[MyPropertyDescriptor]

'text' @ [206:76] ==> value-parameter text: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.findActionWithText[ValueParameterDescriptorImpl]

'intentions' @ [207:13] ==> val intentions: List<(IntentionAction..IntentionAction?)> defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.findActionWithText[LocalVariableDescriptor]

'isNotEmpty' @ [207:24] ==> @InlineOnly public inline fun <T> Collection<(IntentionAction..IntentionAction?)>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.codeInsight.intention.IntentionAction..com.intellij.codeInsight.intention.IntentionAction?)

'intentions' @ [207:45] ==> val intentions: List<(IntentionAction..IntentionAction?)> defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.findActionWithText[LocalVariableDescriptor]

'first' @ [207:56] ==> public fun <T> List<(IntentionAction..IntentionAction?)>.first(): (IntentionAction..IntentionAction?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.codeInsight.intention.IntentionAction..com.intellij.codeInsight.intention.IntentionAction?)

'myFixture' @ [210:27] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[JavaPropertyDescriptor]

'caretOffset' @ [210:37] ==> public final val JavaCodeInsightTestFixture.caretOffset: Int[MyPropertyDescriptor]

'myFixture' @ [211:27] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[JavaPropertyDescriptor]

'doHighlighting' @ [211:37] ==> @NotNull public abstract fun doHighlighting(): (MutableList<(HighlightInfo..HighlightInfo?)>..List<(HighlightInfo..HighlightInfo?)>) defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'highlight' @ [212:17] ==> val highlight: (HighlightInfo..HighlightInfo?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.findActionWithText[LocalVariableDescriptor]

'startOffset' @ [212:27] ==> public final val startOffset: Int defined in com.intellij.codeInsight.daemon.impl.HighlightInfo[JavaPropertyDescriptor]

'caretOffset' @ [212:42] ==> val caretOffset: Int defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.findActionWithText[LocalVariableDescriptor]

'caretOffset' @ [212:57] ==> val caretOffset: Int defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.findActionWithText[LocalVariableDescriptor]

'highlight' @ [212:72] ==> val highlight: (HighlightInfo..HighlightInfo?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.findActionWithText[LocalVariableDescriptor]

'endOffset' @ [212:82] ==> public final val endOffset: Int defined in com.intellij.codeInsight.daemon.impl.HighlightInfo[JavaPropertyDescriptor]

'highlight' @ [213:29] ==> val highlight: (HighlightInfo..HighlightInfo?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.findActionWithText[LocalVariableDescriptor]

'problemGroup' @ [213:39] ==> public final val HighlightInfo.problemGroup: ProblemGroup?[MyPropertyDescriptor]

'group' @ [214:21] ==> val group: ProblemGroup? defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.findActionWithText[LocalVariableDescriptor]

'myFixture' @ [215:30] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[JavaPropertyDescriptor]

'file' @ [215:40] ==> public final val JavaCodeInsightTestFixture.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'findElementAt' @ [215:45] ==> @Nullable @Contract public abstract fun findElementAt(p0: Int): PsiElement? defined in com.intellij.psi.PsiFile[JavaMethodDescriptor]

'highlight' @ [215:59] ==> val highlight: (HighlightInfo..HighlightInfo?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.findActionWithText[LocalVariableDescriptor]

'actualStartOffset' @ [215:69] ==> public final val HighlightInfo.actualStartOffset: Int[MyPropertyDescriptor]

'group' @ [216:35] ==> val group: ProblemGroup? defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.findActionWithText[LocalVariableDescriptor]

'getSuppressActions' @ [216:41] ==> @NotNull public abstract fun getSuppressActions(@Nullable p0: PsiElement?): (Array<(SuppressIntentionAction..SuppressIntentionAction?)>..Array<out (SuppressIntentionAction..SuppressIntentionAction?)>) defined in com.intellij.codeInspection.SuppressableProblemGroup[JavaMethodDescriptor]

'at' @ [216:60] ==> val at: PsiElement? defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.findActionWithText[LocalVariableDescriptor]

'actions' @ [217:36] ==> val actions: (Array<(SuppressIntentionAction..SuppressIntentionAction?)>..Array<out (SuppressIntentionAction..SuppressIntentionAction?)>) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.findActionWithText[LocalVariableDescriptor]

'action' @ [218:29] ==> val action: (SuppressIntentionAction..SuppressIntentionAction?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.findActionWithText[LocalVariableDescriptor]

'text' @ [218:36] ==> public final var SuppressIntentionAction.text: String[MyPropertyDescriptor]

'text' @ [218:44] ==> value-parameter text: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.findActionWithText[ValueParameterDescriptorImpl]

'action' @ [219:36] ==> val action: (SuppressIntentionAction..SuppressIntentionAction?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.findActionWithText[LocalVariableDescriptor]

'DirectiveBasedActionUtils' @ [229:9] ==> public object DirectiveBasedActionUtils defined in org.jetbrains.kotlin.idea.test in file DirectiveBasedActionUtils.kt[FakeCallableDescriptorForObject]

'checkForUnexpectedErrors' @ [229:35] ==> public final fun checkForUnexpectedErrors(file: KtFile): Unit defined in org.jetbrains.kotlin.idea.test.DirectiveBasedActionUtils[SimpleFunctionDescriptorImpl]

'myFixture' @ [229:60] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[JavaPropertyDescriptor]

'file' @ [229:70] ==> public final val JavaCodeInsightTestFixture.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'super' @ [234:28] ==> <this> defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest[LazyClassReceiverParameterDescriptor]

'getTestDataPath' @ [234:34] ==> protected open fun getTestDataPath(): String defined in org.jetbrains.kotlin.idea.test.KotlinLightCodeInsightFixtureTestCase[SimpleFunctionDescriptorImpl]

'File' @ [236:20] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'testDataPath' @ [236:25] ==> val testDataPath: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.getTestDataPath[LocalVariableDescriptor]

'getCanonicalPath' @ [236:39] ==> public open fun getCanonicalPath(): (String..String?) defined in java.io.File[JavaMethodDescriptor]

'e' @ [239:13] ==> val e: IOException defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.getTestDataPath[LocalVariableDescriptor]

'printStackTrace' @ [239:15] ==> public open fun printStackTrace(): Unit defined in java.io.IOException[JavaMethodDescriptor]

'testDataPath' @ [240:20] ==> val testDataPath: String defined in org.jetbrains.kotlin.idea.quickfix.AbstractQuickFixTest.getTestDataPath[LocalVariableDescriptor]

