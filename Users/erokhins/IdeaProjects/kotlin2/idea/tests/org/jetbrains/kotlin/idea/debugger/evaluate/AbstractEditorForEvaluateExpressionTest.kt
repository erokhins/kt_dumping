'AbstractPsiCheckerTest' @ [43:55] ==> public constructor AbstractPsiCheckerTest() defined in org.jetbrains.kotlin.checkers.AbstractPsiCheckerTest[JavaClassConstructorDescriptor]

'myFixture' @ [45:9] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentHighlightingTest[JavaPropertyDescriptor]

'configureByCodeFragment' @ [45:19] ==> private fun JavaCodeInsightTestFixture.configureByCodeFragment(filePath: String): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate in file AbstractEditorForEvaluateExpressionTest.kt[SimpleFunctionDescriptorImpl]

'filePath' @ [45:43] ==> value-parameter filePath: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentHighlightingTest.doTest[ValueParameterDescriptorImpl]

'myFixture' @ [46:9] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentHighlightingTest[JavaPropertyDescriptor]

'checkHighlighting' @ [46:19] ==> public abstract fun checkHighlighting(p0: Boolean, p1: Boolean, p2: Boolean): Long defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'myFixture' @ [50:9] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentHighlightingTest[JavaPropertyDescriptor]

'configureByCodeFragment' @ [50:19] ==> private fun JavaCodeInsightTestFixture.configureByCodeFragment(filePath: String): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate in file AbstractEditorForEvaluateExpressionTest.kt[SimpleFunctionDescriptorImpl]

'filePath' @ [50:43] ==> value-parameter filePath: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentHighlightingTest.doTestWithImport[ValueParameterDescriptorImpl]

'project' @ [52:9] ==> public final val AbstractCodeFragmentHighlightingTest.project: Project[MyPropertyDescriptor]

'executeWriteCommand' @ [52:17] ==> public fun Project.executeWriteCommand(name: String, command: () -> Unit): Unit defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]

'loadFile' @ [53:37] ==> @NotNull public open fun loadFile(@NotNull p0: File, p1: Boolean): String defined in com.intellij.openapi.util.io.FileUtil[JavaMethodDescriptor]

'File' @ [53:46] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'filePath' @ [53:51] ==> value-parameter filePath: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentHighlightingTest.doTestWithImport[ValueParameterDescriptorImpl]

'myFixture' @ [54:24] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentHighlightingTest[JavaPropertyDescriptor]

'file' @ [54:34] ==> public final val JavaCodeInsightTestFixture.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'findListWithPrefixes' @ [55:35] ==> @NotNull public open fun findListWithPrefixes(@NotNull p0: String, @NotNull vararg p1: (String..String?)): (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'fileText' @ [55:56] ==> val fileText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentHighlightingTest.doTestWithImport.<anonymous>[LocalVariableDescriptor]

'forEach' @ [55:81] ==> @HidesMembers public inline fun <T> Iterable<(String..String?)>.forEach(action: ((String..String?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.String..kotlin.String?)

'file' @ [56:34] ==> val file: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentHighlightingTest.doTestWithImport.<anonymous>[LocalVariableDescriptor]

'resolveImportReference' @ [56:39] ==> public fun KtFile.resolveImportReference(fqName: FqName): Collection<DeclarationDescriptor> defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'FqName' @ [56:62] ==> public constructor FqName(@NotNull p0: String) defined in org.jetbrains.kotlin.name.FqName[JavaClassConstructorDescriptor]

'it' @ [56:69] ==> value-parameter it: (String..String?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentHighlightingTest.doTestWithImport.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'singleOrNull' @ [56:74] ==> public fun <T> Iterable<DeclarationDescriptor>.singleOrNull(): DeclarationDescriptor? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DeclarationDescriptor

'error' @ [57:37] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'it' @ [57:85] ==> value-parameter it: (String..String?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentHighlightingTest.doTestWithImport.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'ImportInsertHelper' @ [58:17] ==> public companion object defined in org.jetbrains.kotlin.idea.util.ImportInsertHelper[FakeCallableDescriptorForObject]

'getInstance' @ [58:36] ==> @JvmStatic public final fun getInstance(project: Project): ImportInsertHelper defined in org.jetbrains.kotlin.idea.util.ImportInsertHelper.Companion[DeserializedSimpleFunctionDescriptor]

'project' @ [58:48] ==> public final val AbstractCodeFragmentHighlightingTest.project: Project[MyPropertyDescriptor]

'importDescriptor' @ [58:57] ==> public abstract fun importDescriptor(file: KtFile, descriptor: DeclarationDescriptor, forceAllUnderImport: Boolean = ...): ImportDescriptorResult defined in org.jetbrains.kotlin.idea.util.ImportInsertHelper[DeserializedSimpleFunctionDescriptor]

'file' @ [58:74] ==> val file: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentHighlightingTest.doTestWithImport.<anonymous>[LocalVariableDescriptor]

'descriptor' @ [58:80] ==> val descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentHighlightingTest.doTestWithImport.<anonymous>.<anonymous>[LocalVariableDescriptor]

'myFixture' @ [62:9] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentHighlightingTest[JavaPropertyDescriptor]

'checkHighlighting' @ [62:19] ==> public abstract fun checkHighlighting(p0: Boolean, p1: Boolean, p2: Boolean): Long defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'AbstractJvmBasicCompletionTest' @ [66:53] ==> public constructor AbstractJvmBasicCompletionTest() defined in org.jetbrains.kotlin.idea.completion.test.AbstractJvmBasicCompletionTest[JavaClassConstructorDescriptor]

'myFixture' @ [68:9] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentCompletionTest[JavaPropertyDescriptor]

'configureByCodeFragment' @ [68:19] ==> private fun JavaCodeInsightTestFixture.configureByCodeFragment(filePath: String): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate in file AbstractEditorForEvaluateExpressionTest.kt[SimpleFunctionDescriptorImpl]

'testPath' @ [68:43] ==> value-parameter testPath: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentCompletionTest.setUpFixture[ValueParameterDescriptorImpl]

'AbstractCompletionHandlerTest' @ [72:60] ==> public constructor AbstractCompletionHandlerTest(defaultCompletionType: CompletionType) defined in org.jetbrains.kotlin.idea.completion.test.handlers.AbstractCompletionHandlerTest[ClassConstructorDescriptorImpl]

'BASIC' @ [72:105] ==> enum entry BASIC defined in com.intellij.codeInsight.completion.CompletionType[FakeCallableDescriptorForObject]

'myFixture' @ [74:9] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentCompletionHandlerTest[JavaPropertyDescriptor]

'configureByCodeFragment' @ [74:19] ==> private fun JavaCodeInsightTestFixture.configureByCodeFragment(filePath: String): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate in file AbstractEditorForEvaluateExpressionTest.kt[SimpleFunctionDescriptorImpl]

'testPath' @ [74:43] ==> value-parameter testPath: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentCompletionHandlerTest.setUpFixture[ValueParameterDescriptorImpl]

'super' @ [78:9] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentCompletionHandlerTest[LazyClassReceiverParameterDescriptor]

'doTest' @ [78:15] ==> protected open fun doTest(testPath: String): Unit defined in org.jetbrains.kotlin.idea.completion.test.handlers.AbstractCompletionHandlerTest[SimpleFunctionDescriptorImpl]

'testPath' @ [78:22] ==> value-parameter testPath: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentCompletionHandlerTest.doTest[ValueParameterDescriptorImpl]

'myFixture' @ [80:24] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentCompletionHandlerTest[JavaPropertyDescriptor]

'file' @ [80:34] ==> public final val JavaCodeInsightTestFixture.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'fragment' @ [81:9] ==> val fragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentCompletionHandlerTest.doTest[LocalVariableDescriptor]

'checkImports' @ [81:18] ==> private fun KtCodeFragment.checkImports(testPath: String): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate in file AbstractEditorForEvaluateExpressionTest.kt[SimpleFunctionDescriptorImpl]

'testPath' @ [81:31] ==> value-parameter testPath: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentCompletionHandlerTest.doTest[ValueParameterDescriptorImpl]

'AbstractPsiCheckerTest' @ [85:53] ==> public constructor AbstractPsiCheckerTest() defined in org.jetbrains.kotlin.checkers.AbstractPsiCheckerTest[JavaClassConstructorDescriptor]

'myFixture' @ [87:9] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentAutoImportTest[JavaPropertyDescriptor]

'configureByCodeFragment' @ [87:19] ==> private fun JavaCodeInsightTestFixture.configureByCodeFragment(filePath: String): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate in file AbstractEditorForEvaluateExpressionTest.kt[SimpleFunctionDescriptorImpl]

'filePath' @ [87:43] ==> value-parameter filePath: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentAutoImportTest.doTest[ValueParameterDescriptorImpl]

'myFixture' @ [88:9] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentAutoImportTest[JavaPropertyDescriptor]

'doHighlighting' @ [88:19] ==> @NotNull public abstract fun doHighlighting(): (MutableList<(HighlightInfo..HighlightInfo?)>..List<(HighlightInfo..HighlightInfo?)>) defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'myFixture' @ [90:25] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentAutoImportTest[JavaPropertyDescriptor]

'availableIntentions' @ [90:35] ==> public final val JavaCodeInsightTestFixture.availableIntentions: (MutableList<(IntentionAction..IntentionAction?)>..List<(IntentionAction..IntentionAction?)>)[MyPropertyDescriptor]

'singleOrNull' @ [90:55] ==> public inline fun <T> Iterable<(IntentionAction..IntentionAction?)>.singleOrNull(predicate: ((IntentionAction..IntentionAction?)) -> Boolean): IntentionAction? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.codeInsight.intention.IntentionAction..com.intellij.codeInsight.intention.IntentionAction?)

'it' @ [90:70] ==> value-parameter it: (IntentionAction..IntentionAction?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentAutoImportTest.doTest.<anonymous>[ValueParameterDescriptorImpl]

'familyName' @ [90:73] ==> public final val IntentionAction.familyName: String[MyPropertyDescriptor]

'error' @ [91:28] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'importFix' @ [92:9] ==> val importFix: IntentionAction defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentAutoImportTest.doTest[LocalVariableDescriptor]

'invoke' @ [92:19] ==> public abstract operator fun invoke(@NotNull p0: Project, p1: (Editor..Editor?), p2: (PsiFile..PsiFile?)): Unit defined in com.intellij.codeInsight.intention.IntentionAction[JavaMethodDescriptor]

'project' @ [92:26] ==> public final val AbstractCodeFragmentAutoImportTest.project: Project[MyPropertyDescriptor]

'editor' @ [92:35] ==> public final val AbstractCodeFragmentAutoImportTest.editor: Editor[MyPropertyDescriptor]

'file' @ [92:43] ==> public final val AbstractCodeFragmentAutoImportTest.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'myFixture' @ [94:9] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentAutoImportTest[JavaPropertyDescriptor]

'checkResultByFile' @ [94:19] ==> public abstract fun checkResultByFile(@NotNull p0: String): Unit defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'filePath' @ [94:37] ==> value-parameter filePath: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentAutoImportTest.doTest[ValueParameterDescriptorImpl]

'myFixture' @ [96:24] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentAutoImportTest[JavaPropertyDescriptor]

'file' @ [96:34] ==> public final val JavaCodeInsightTestFixture.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'fragment' @ [97:9] ==> val fragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentAutoImportTest.doTest[LocalVariableDescriptor]

'checkImports' @ [97:18] ==> private fun KtCodeFragment.checkImports(testPath: String): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate in file AbstractEditorForEvaluateExpressionTest.kt[SimpleFunctionDescriptorImpl]

'testDataPath' @ [97:31] ==> protected for synthetic extension final val AbstractCodeFragmentAutoImportTest.testDataPath: String[MyPropertyDescriptor]

'separator' @ [97:51] ==> public const final val separator: (String..String?) defined in java.io.File[JavaPropertyDescriptor]

'filePath' @ [97:63] ==> value-parameter filePath: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentAutoImportTest.doTest[ValueParameterDescriptorImpl]

'myFixture' @ [99:24] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentAutoImportTest[JavaPropertyDescriptor]

'availableIntentions' @ [99:34] ==> public final val JavaCodeInsightTestFixture.availableIntentions: (MutableList<(IntentionAction..IntentionAction?)>..List<(IntentionAction..IntentionAction?)>)[MyPropertyDescriptor]

'firstOrNull' @ [99:54] ==> public inline fun <T> Iterable<(IntentionAction..IntentionAction?)>.firstOrNull(predicate: ((IntentionAction..IntentionAction?)) -> Boolean): IntentionAction? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.codeInsight.intention.IntentionAction..com.intellij.codeInsight.intention.IntentionAction?)

'it' @ [99:68] ==> value-parameter it: (IntentionAction..IntentionAction?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentAutoImportTest.doTest.<anonymous>[ValueParameterDescriptorImpl]

'familyName' @ [99:71] ==> public final val IntentionAction.familyName: String[MyPropertyDescriptor]

'assertNull' @ [100:9] ==> public fun assertNull(actual: Any?, message: String? = ...): Unit defined in kotlin.test[DeserializedSimpleFunctionDescriptor]

'fixAfter' @ [100:20] ==> val fixAfter: IntentionAction? defined in org.jetbrains.kotlin.idea.debugger.evaluate.AbstractCodeFragmentAutoImportTest.doTest[LocalVariableDescriptor]

'INSTANCE' @ [103:89] ==> @NotNull public final val INSTANCE: KotlinWithJdkAndRuntimeLightProjectDescriptor defined in org.jetbrains.kotlin.idea.test.KotlinWithJdkAndRuntimeLightProjectDescriptor[JavaPropertyDescriptor]

'getHomeDirectory' @ [104:54] ==> @NotNull public open fun getHomeDirectory(): String defined in org.jetbrains.kotlin.test.KotlinTestUtils[JavaMethodDescriptor]

'importsAsImportList' @ [108:22] ==> public final fun importsAsImportList(): KtImportList? defined in org.jetbrains.kotlin.psi.KtCodeFragment[DeserializedSimpleFunctionDescriptor]

'convertLineSeparators' @ [109:34] ==> @NotNull @Contract public open fun convertLineSeparators(@NotNull p0: String): String defined in com.intellij.openapi.util.text.StringUtil[JavaMethodDescriptor]

'importList' @ [109:56] ==> val importList: KtImportList? defined in org.jetbrains.kotlin.idea.debugger.evaluate.checkImports[LocalVariableDescriptor]

'text' @ [109:68] ==> public final val KtImportList.text: (String..String?)[MyPropertyDescriptor]

'File' @ [110:29] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'testPath' @ [110:34] ==> value-parameter testPath: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.checkImports[ValueParameterDescriptorImpl]

'if (fragmentAfterFile.exists()) {
        KotlinTestUtils.assertEqualsToFile(fragmentAfterFile, importsText)
    }
    else {
        assertTrue(importsText.isEmpty(), "Unexpected imports found: $importsText" )
    }' @ [112:5] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'fragmentAfterFile' @ [112:9] ==> val fragmentAfterFile: File defined in org.jetbrains.kotlin.idea.debugger.evaluate.checkImports[LocalVariableDescriptor]

'exists' @ [112:27] ==> public open fun exists(): Boolean defined in java.io.File[JavaMethodDescriptor]

'assertEqualsToFile' @ [113:25] ==> public open fun assertEqualsToFile(@NotNull p0: File, @NotNull p1: String): Unit defined in org.jetbrains.kotlin.test.KotlinTestUtils[JavaMethodDescriptor]

'fragmentAfterFile' @ [113:44] ==> val fragmentAfterFile: File defined in org.jetbrains.kotlin.idea.debugger.evaluate.checkImports[LocalVariableDescriptor]

'importsText' @ [113:63] ==> val importsText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.checkImports[LocalVariableDescriptor]

'assertTrue' @ [116:9] ==> public fun assertTrue(actual: Boolean, message: String? = ...): Unit defined in kotlin.test[DeserializedSimpleFunctionDescriptor]

'importsText' @ [116:20] ==> val importsText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.checkImports[LocalVariableDescriptor]

'isEmpty' @ [116:32] ==> @InlineOnly public inline fun CharSequence.isEmpty(): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'importsText' @ [116:71] ==> val importsText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.checkImports[LocalVariableDescriptor]

'configureByFile' @ [121:5] ==> public abstract fun configureByFile(@NotNull p0: String): (PsiFile..PsiFile?) defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'filePath' @ [121:21] ==> value-parameter filePath: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.configureByCodeFragment[ValueParameterDescriptorImpl]

'file' @ [123:21] ==> public final val JavaCodeInsightTestFixture.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'findElementAt' @ [123:27] ==> @Nullable @Contract public abstract fun findElementAt(p0: Int): PsiElement? defined in com.intellij.psi.PsiFile[JavaMethodDescriptor]

'caretOffset' @ [123:41] ==> public final val JavaCodeInsightTestFixture.caretOffset: Int[MyPropertyDescriptor]

'createCodeFragment' @ [124:16] ==> private fun createCodeFragment(filePath: String, contextElement: PsiElement): KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate in file AbstractEditorForEvaluateExpressionTest.kt[SimpleFunctionDescriptorImpl]

'filePath' @ [124:35] ==> value-parameter filePath: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.configureByCodeFragment[ValueParameterDescriptorImpl]

'elementAt' @ [124:45] ==> val elementAt: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.configureByCodeFragment[LocalVariableDescriptor]

'findStringWithPrefixes' @ [126:41] ==> @Nullable public open fun findStringWithPrefixes(p0: (String..String?), vararg p1: (String..String?)): String? defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'getFile' @ [126:64] ==> public abstract fun getFile(): (PsiFile..PsiFile?) defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'text' @ [126:74] ==> public final val PsiFile.text: (String..String?)[MyPropertyDescriptor]

'ExpectedCompletionUtils' @ [126:86] ==> public object ExpectedCompletionUtils defined in org.jetbrains.kotlin.idea.completion.test in file ExpectedCompletionUtils.kt[FakeCallableDescriptorForObject]

'RUNTIME_TYPE' @ [126:110] ==> public final val RUNTIME_TYPE: String defined in org.jetbrains.kotlin.idea.completion.test.ExpectedCompletionUtils[PropertyDescriptorImpl]

'typeStr' @ [127:9] ==> val typeStr: String? defined in org.jetbrains.kotlin.idea.debugger.evaluate.configureByCodeFragment[LocalVariableDescriptor]

'file' @ [128:9] ==> val file: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.configureByCodeFragment[LocalVariableDescriptor]

'putCopyableUserData' @ [128:14] ==> public open fun <T : (Any..Any?)> putCopyableUserData(@NotNull p0: Key<((KtExpression) -> KotlinType?..((KtExpression) -> KotlinType?)?)>, p1: ((KtExpression) -> KotlinType?)?): Unit defined in org.jetbrains.kotlin.psi.KtCodeFragment[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> ((org.jetbrains.kotlin.psi.KtExpression) -> org.jetbrains.kotlin.types.KotlinType?..((org.jetbrains.kotlin.psi.KtExpression) -> org.jetbrains.kotlin.types.KotlinType?)?)

'RUNTIME_TYPE_EVALUATOR' @ [128:49] ==> public final val RUNTIME_TYPE_EVALUATOR: Key<(KtExpression) -> KotlinType?> defined in org.jetbrains.kotlin.psi.KtCodeFragment.Companion[DeserializedPropertyDescriptor]

'KtPsiFactory' @ [129:32] ==> @JvmOverloads public constructor KtPsiFactory(project: Project, markGenerated: Boolean = ...) defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedClassConstructorDescriptor]

'project' @ [129:45] ==> public final val JavaCodeInsightTestFixture.project: (Project..Project?)[MyPropertyDescriptor]

'createBlockCodeFragment' @ [129:54] ==> public final fun createBlockCodeFragment(text: String, context: PsiElement?): KtBlockCodeFragment defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'typeStr' @ [129:89] ==> val typeStr: String? defined in org.jetbrains.kotlin.idea.debugger.evaluate.configureByCodeFragment[LocalVariableDescriptor]

'getParentOfType' @ [129:111] ==> @Nullable @Contract public open fun <T : (PsiElement..PsiElement?)> getParentOfType(@Nullable p0: PsiElement?, @NotNull p1: Class<(KtElement..KtElement?)>): KtElement? defined in com.intellij.psi.util.PsiTreeUtil[JavaMethodDescriptor]
Inferred types:
    <T : (PsiElement..PsiElement?)> -> (org.jetbrains.kotlin.psi.KtElement..org.jetbrains.kotlin.psi.KtElement?)

'elementAt' @ [129:127] ==> val elementAt: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.configureByCodeFragment[LocalVariableDescriptor]

'java' @ [129:155] ==> public val <T> KClass<KtElement>.java: Class<KtElement> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtElement

'codeFragment' @ [130:27] ==> val codeFragment: KtBlockCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.configureByCodeFragment.<anonymous>[LocalVariableDescriptor]

'analyzeFully' @ [130:40] ==> public fun KtElement.analyzeFully(): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'!!' @ [131:50] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: KtTypeReference?): KtTypeReference[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> KtTypeReference

'getChildOfType' @ [131:62] ==> @Nullable public open fun <T : (PsiElement..PsiElement?)> getChildOfType(@Nullable p0: PsiElement?, @NotNull p1: Class<(KtTypeReference..KtTypeReference?)>): KtTypeReference? defined in com.intellij.psi.util.PsiTreeUtil[JavaMethodDescriptor]
Inferred types:
    <T : (PsiElement..PsiElement?)> -> (org.jetbrains.kotlin.psi.KtTypeReference..org.jetbrains.kotlin.psi.KtTypeReference?)

'codeFragment' @ [131:77] ==> val codeFragment: KtBlockCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.configureByCodeFragment.<anonymous>[LocalVariableDescriptor]

'getContentElement' @ [131:90] ==> public open fun getContentElement(): KtBlockExpression defined in org.jetbrains.kotlin.psi.KtBlockCodeFragment[DeserializedSimpleFunctionDescriptor]

'firstChild' @ [131:110] ==> public final val KtBlockExpression.firstChild: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'java' @ [131:145] ==> public val <T> KClass<KtTypeReference>.java: Class<KtTypeReference> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtTypeReference

'context' @ [132:13] ==> val context: BindingContext defined in org.jetbrains.kotlin.idea.debugger.evaluate.configureByCodeFragment.<anonymous>[LocalVariableDescriptor]

'TYPE' @ [132:36] ==> public final val TYPE: (WritableSlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>..WritableSlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'typeReference' @ [132:42] ==> val typeReference: KtTypeReference defined in org.jetbrains.kotlin.idea.debugger.evaluate.configureByCodeFragment.<anonymous>[LocalVariableDescriptor]

'configureFromExistingVirtualFile' @ [136:5] ==> public abstract fun configureFromExistingVirtualFile(@NotNull p0: VirtualFile): Unit defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'file' @ [136:38] ==> val file: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.configureByCodeFragment[LocalVariableDescriptor]

'virtualFile' @ [136:43] ==> public final val KtCodeFragment.virtualFile: (VirtualFile..VirtualFile?)[MyPropertyDescriptor]

'File' @ [140:27] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'filePath' @ [140:32] ==> value-parameter filePath: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.createCodeFragment[ValueParameterDescriptorImpl]

'loadFile' @ [141:37] ==> @NotNull public open fun loadFile(@NotNull p0: File, p1: Boolean): String defined in com.intellij.openapi.util.io.FileUtil[JavaMethodDescriptor]

'fileForFragment' @ [141:46] ==> val fileForFragment: File defined in org.jetbrains.kotlin.idea.debugger.evaluate.createCodeFragment[LocalVariableDescriptor]

'trim' @ [141:69] ==> @InlineOnly public inline fun String.trim(): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'KtPsiFactory' @ [142:22] ==> @JvmOverloads public constructor KtPsiFactory(project: Project, markGenerated: Boolean = ...) defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedClassConstructorDescriptor]

'contextElement' @ [142:35] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.createCodeFragment[ValueParameterDescriptorImpl]

'project' @ [142:50] ==> public final val PsiElement.project: Project[MyPropertyDescriptor]

'fileForFragment' @ [143:9] ==> val fileForFragment: File defined in org.jetbrains.kotlin.idea.debugger.evaluate.createCodeFragment[LocalVariableDescriptor]

'readLines' @ [143:25] ==> public fun File.readLines(charset: Charset = ...): List<String> defined in kotlin.io[DeserializedSimpleFunctionDescriptor]

'size' @ [143:37] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'psiFactory' @ [144:16] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.debugger.evaluate.createCodeFragment[LocalVariableDescriptor]

'createExpressionCodeFragment' @ [144:27] ==> public final fun createExpressionCodeFragment(text: String, context: PsiElement?): KtExpressionCodeFragment defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'codeFragmentText' @ [145:17] ==> val codeFragmentText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.createCodeFragment[LocalVariableDescriptor]

'getContextElement' @ [146:43] ==> public final fun getContextElement(elementAt: PsiElement?): PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinCodeFragmentFactory.Companion[DeserializedSimpleFunctionDescriptor]

'contextElement' @ [146:61] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.createCodeFragment[ValueParameterDescriptorImpl]

'psiFactory' @ [149:12] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.debugger.evaluate.createCodeFragment[LocalVariableDescriptor]

'createBlockCodeFragment' @ [149:23] ==> public final fun createBlockCodeFragment(text: String, context: PsiElement?): KtBlockCodeFragment defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'codeFragmentText' @ [150:13] ==> val codeFragmentText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.createCodeFragment[LocalVariableDescriptor]

'getContextElement' @ [151:39] ==> public final fun getContextElement(elementAt: PsiElement?): PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinCodeFragmentFactory.Companion[DeserializedSimpleFunctionDescriptor]

'contextElement' @ [151:57] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.createCodeFragment[ValueParameterDescriptorImpl]

