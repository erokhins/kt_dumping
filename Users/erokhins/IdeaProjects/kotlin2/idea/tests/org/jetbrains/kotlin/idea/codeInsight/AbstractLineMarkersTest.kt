'KotlinLightCodeInsightFixtureTestCase' @ [42:42] ==> public constructor KotlinLightCodeInsightFixtureTestCase() defined in org.jetbrains.kotlin.idea.test.KotlinLightCodeInsightFixtureTestCase[ClassConstructorDescriptorImpl]

'+' @ [45:16] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'TEST_DATA_PROJECT_RELATIVE' @ [45:35] ==> public const final val TEST_DATA_PROJECT_RELATIVE: String defined in org.jetbrains.kotlin.idea.test.PluginTestCaseBase[JavaPropertyDescriptor]

'INSTANCE' @ [49:62] ==> @NotNull public final val INSTANCE: KotlinWithJdkAndRuntimeLightProjectDescriptor defined in org.jetbrains.kotlin.idea.test.KotlinWithJdkAndRuntimeLightProjectDescriptor[JavaPropertyDescriptor]

'loadFile' @ [54:37] ==> @NotNull public open fun loadFile(@NotNull p0: File): String defined in com.intellij.openapi.util.io.FileUtil[JavaMethodDescriptor]

'File' @ [54:46] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'path' @ [54:51] ==> value-parameter path: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.doTest[ValueParameterDescriptorImpl]

'ConfigLibraryUtil' @ [55:13] ==> public object ConfigLibraryUtil defined in org.jetbrains.kotlin.idea.test in file ConfigLibraryUtil.kt[FakeCallableDescriptorForObject]

'configureLibrariesByDirective' @ [55:31] ==> public final fun configureLibrariesByDirective(module: Module, rootPath: String, fileText: String): Unit defined in org.jetbrains.kotlin.idea.test.ConfigLibraryUtil[SimpleFunctionDescriptorImpl]

'myFixture' @ [55:61] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest[JavaPropertyDescriptor]

'module' @ [55:71] ==> public final val JavaCodeInsightTestFixture.module: (Module..Module?)[MyPropertyDescriptor]

'getCommunityPath' @ [55:96] ==> public open fun getCommunityPath(): (String..String?) defined in com.intellij.testFramework.PlatformTestUtil[JavaMethodDescriptor]

'fileText' @ [55:116] ==> val fileText: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.doTest[LocalVariableDescriptor]

'myFixture' @ [57:13] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest[JavaPropertyDescriptor]

'configureByFile' @ [57:23] ==> public abstract fun configureByFile(@NotNull p0: String): (PsiFile..PsiFile?) defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'path' @ [57:39] ==> value-parameter path: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.doTest[ValueParameterDescriptorImpl]

'myFixture' @ [58:27] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest[JavaPropertyDescriptor]

'project' @ [58:37] ==> public final val JavaCodeInsightTestFixture.project: (Project..Project?)[MyPropertyDescriptor]

'myFixture' @ [59:28] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest[JavaPropertyDescriptor]

'editor' @ [59:38] ==> public final val JavaCodeInsightTestFixture.editor: (Editor..Editor?)[MyPropertyDescriptor]

'document' @ [59:45] ==> public final val Editor.document: Document[MyPropertyDescriptor]

'ExpectedHighlightingData' @ [61:24] ==> public constructor ExpectedHighlightingData(@NotNull p0: Document, p1: Boolean, p2: Boolean, p3: Boolean, @Nullable p4: PsiFile?) defined in com.intellij.testFramework.ExpectedHighlightingData[JavaClassConstructorDescriptor]

'document' @ [62:21] ==> val document: Document defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.doTest[LocalVariableDescriptor]

'myFixture' @ [62:52] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest[JavaPropertyDescriptor]

'file' @ [62:62] ==> public final val JavaCodeInsightTestFixture.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'data' @ [63:13] ==> val data: ExpectedHighlightingData defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.doTest[LocalVariableDescriptor]

'init' @ [63:18] ==> public open fun init(): Unit defined in com.intellij.testFramework.ExpectedHighlightingData[JavaMethodDescriptor]

'getInstance' @ [65:32] ==> public open fun getInstance(@NotNull p0: Project): (PsiDocumentManager..PsiDocumentManager?) defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'project' @ [65:44] ==> val project: (Project..Project?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.doTest[LocalVariableDescriptor]

'commitAllDocuments' @ [65:53] ==> public abstract fun commitAllDocuments(): Unit defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'myFixture' @ [67:13] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest[JavaPropertyDescriptor]

'doHighlighting' @ [67:23] ==> @NotNull public abstract fun doHighlighting(): (MutableList<(HighlightInfo..HighlightInfo?)>..List<(HighlightInfo..HighlightInfo?)>) defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'getLineMarkers' @ [69:50] ==> @NotNull public open fun getLineMarkers(@NotNull p0: Document, @NotNull p1: Project): (MutableList<raw (LineMarkerInfo<(PsiElement..PsiElement?)>..LineMarkerInfo<*>?)>..List<raw (LineMarkerInfo<(PsiElement..PsiElement?)>..LineMarkerInfo<*>?)>) defined in com.intellij.codeInsight.daemon.impl.DaemonCodeAnalyzerImpl[JavaMethodDescriptor]

'document' @ [69:65] ==> val document: Document defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.doTest[LocalVariableDescriptor]

'project' @ [69:75] ==> val project: (Project..Project?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.doTest[LocalVariableDescriptor]

'data' @ [72:17] ==> val data: ExpectedHighlightingData defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.doTest[LocalVariableDescriptor]

'checkLineMarkers' @ [72:22] ==> public open fun checkLineMarkers(@NotNull p0: (MutableCollection<raw (LineMarkerInfo<(PsiElement..PsiElement?)>..LineMarkerInfo<*>?)>..Collection<raw (LineMarkerInfo<(PsiElement..PsiElement?)>..LineMarkerInfo<*>?)>), @NotNull p1: String): Unit defined in com.intellij.testFramework.ExpectedHighlightingData[JavaMethodDescriptor]

'markers' @ [72:39] ==> val markers: (MutableList<raw (LineMarkerInfo<(PsiElement..PsiElement?)>..LineMarkerInfo<*>?)>..List<raw (LineMarkerInfo<(PsiElement..PsiElement?)>..LineMarkerInfo<*>?)>) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.doTest[LocalVariableDescriptor]

'document' @ [72:48] ==> val document: Document defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.doTest[LocalVariableDescriptor]

'text' @ [72:57] ==> public final val Document.text: String[MyPropertyDescriptor]

'loadFile' @ [76:30] ==> @NotNull public open fun loadFile(@NotNull p0: File): String defined in com.intellij.openapi.util.io.FileUtil[JavaMethodDescriptor]

'File' @ [76:39] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'path' @ [76:44] ==> value-parameter path: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.doTest[ValueParameterDescriptorImpl]

'contains' @ [76:51] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'markers' @ [76:78] ==> val markers: (MutableList<raw (LineMarkerInfo<(PsiElement..PsiElement?)>..LineMarkerInfo<*>?)>..List<raw (LineMarkerInfo<(PsiElement..PsiElement?)>..LineMarkerInfo<*>?)>) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.doTest[LocalVariableDescriptor]

'isEmpty' @ [76:86] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'AssertionError' @ [77:27] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'insertInfoTags' @ [82:67] ==> public open fun insertInfoTags(lineMarkers: (MutableList<raw (LineMarkerInfo<(PsiElement..PsiElement?)>..LineMarkerInfo<*>?)>..List<raw (LineMarkerInfo<(PsiElement..PsiElement?)>..LineMarkerInfo<*>?)>?), withDescription: Boolean, text: (String..String?)): (String..String?) defined in org.jetbrains.kotlin.test.TagsTestDataUtil[JavaMethodDescriptor]

'markers' @ [82:82] ==> val markers: (MutableList<raw (LineMarkerInfo<(PsiElement..PsiElement?)>..LineMarkerInfo<*>?)>..List<raw (LineMarkerInfo<(PsiElement..PsiElement?)>..LineMarkerInfo<*>?)>) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.doTest[LocalVariableDescriptor]

'myFixture' @ [82:97] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest[JavaPropertyDescriptor]

'file' @ [82:107] ==> public final val JavaCodeInsightTestFixture.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'text' @ [82:112] ==> public final val PsiFile.text: (String..String?)[MyPropertyDescriptor]

'assertEqualsToFile' @ [83:37] ==> public open fun assertEqualsToFile(@NotNull p0: File, @NotNull p1: String): Unit defined in org.jetbrains.kotlin.test.KotlinTestUtils[JavaMethodDescriptor]

'File' @ [83:56] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'path' @ [83:61] ==> value-parameter path: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.doTest[ValueParameterDescriptorImpl]

'actualTextWithTestData' @ [83:68] ==> val actualTextWithTestData: (String..String?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.doTest[LocalVariableDescriptor]

'FileComparisonFailure' @ [86:27] ==> public constructor FileComparisonFailure(p0: (String..String?), p1: (String..String?), p2: (String..String?), p3: (String..String?)) defined in com.intellij.rt.execution.junit.FileComparisonFailure[JavaClassConstructorDescriptor]

'error' @ [86:49] ==> val error: AssertionError /* = AssertionError */ defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.doTest[LocalVariableDescriptor]

'message' @ [86:55] ==> public open val message: String? defined in java.lang.AssertionError[DeserializedPropertyDescriptor]

'failure' @ [86:72] ==> val failure: FileComparisonFailure defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.doTest[LocalVariableDescriptor]

'message' @ [86:80] ==> public open val message: String? defined in com.intellij.rt.execution.junit.FileComparisonFailure[JavaPropertyDescriptor]

'failure' @ [87:49] ==> val failure: FileComparisonFailure defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.doTest[LocalVariableDescriptor]

'expected' @ [87:57] ==> public final val FileComparisonFailure.expected: (String..String?)[MyPropertyDescriptor]

'failure' @ [88:49] ==> val failure: FileComparisonFailure defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.doTest[LocalVariableDescriptor]

'actual' @ [88:57] ==> public final val FileComparisonFailure.actual: (String..String?)[MyPropertyDescriptor]

'failure' @ [89:49] ==> val failure: FileComparisonFailure defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.doTest[LocalVariableDescriptor]

'filePath' @ [89:57] ==> public final val FileComparisonFailure.filePath: (String..String?)[MyPropertyDescriptor]

'assertNavigationElements' @ [94:13] ==> private final fun assertNavigationElements(markers: List<LineMarkerInfo<*>>): Unit defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest[SimpleFunctionDescriptorImpl]

'markers' @ [94:38] ==> val markers: (MutableList<raw (LineMarkerInfo<(PsiElement..PsiElement?)>..LineMarkerInfo<*>?)>..List<raw (LineMarkerInfo<(PsiElement..PsiElement?)>..LineMarkerInfo<*>?)>) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.doTest[LocalVariableDescriptor]

'RuntimeException' @ [97:19] ==> public final fun <init>(p0: (Throwable..Throwable?)): RuntimeException /* = RuntimeException */ defined in kotlin.RuntimeException[TypeAliasConstructorDescriptorImpl]

'exc' @ [97:36] ==> val exc: Exception /* = Exception */ defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.doTest[LocalVariableDescriptor]

'getLastCommentsInFile' @ [103:54] ==> @NotNull public open fun getLastCommentsInFile(@NotNull p0: KtFile, p1: (KotlinTestUtils.CommentType..KotlinTestUtils.CommentType?), p2: Boolean): (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.test.KotlinTestUtils[JavaMethodDescriptor]

'myFixture' @ [104:17] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest[JavaPropertyDescriptor]

'file' @ [104:27] ==> public final val JavaCodeInsightTestFixture.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'BLOCK_COMMENT' @ [104:71] ==> enum entry BLOCK_COMMENT defined in org.jetbrains.kotlin.test.KotlinTestUtils.CommentType[FakeCallableDescriptorForObject]

'navigationDataComments' @ [105:13] ==> val navigationDataComments: (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.assertNavigationElements[LocalVariableDescriptor]

'isEmpty' @ [105:36] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'navigationDataComments' @ [107:35] ==> val navigationDataComments: (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.assertNavigationElements[LocalVariableDescriptor]

'getLineMarkerDescription' @ [108:31] ==> private final fun getLineMarkerDescription(navigationComment: String): String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.Companion[SimpleFunctionDescriptorImpl]

'navigationComment' @ [108:56] ==> val navigationComment: (String..String?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.assertNavigationElements[LocalVariableDescriptor]

'markers' @ [109:34] ==> value-parameter markers: List<LineMarkerInfo<*>> defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.assertNavigationElements[ValueParameterDescriptorImpl]

'find' @ [109:42] ==> @InlineOnly public inline fun <T> Iterable<LineMarkerInfo<*>>.find(predicate: (LineMarkerInfo<*>) -> Boolean): LineMarkerInfo<*>? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> LineMarkerInfo<*>

'it' @ [109:49] ==> value-parameter it: LineMarkerInfo<*> defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.assertNavigationElements.<anonymous>[ValueParameterDescriptorImpl]

'lineMarkerTooltip' @ [109:52] ==> public final val <T : (PsiElement..PsiElement?)> LineMarkerInfo<out (PsiElement..PsiElement?)>.lineMarkerTooltip: String?[MyPropertyDescriptor]
Inferred types:
    <T : (PsiElement..PsiElement?)> -> Captured(*)

'startsWith' @ [109:71] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'description' @ [109:82] ==> val description: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.assertNavigationElements[LocalVariableDescriptor]

'assertNotNull' @ [111:22] ==> public open fun assertNotNull(p0: (String..String?), p1: (Any..Any?)): Unit defined in junit.framework.TestCase[JavaMethodDescriptor]

'format' @ [112:28] ==> @InlineOnly public inline fun String.Companion.format(format: String, vararg args: Any?): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'description' @ [112:101] ==> val description: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.assertNavigationElements[LocalVariableDescriptor]

'navigateMarker' @ [113:21] ==> val navigateMarker: LineMarkerInfo<*> defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.assertNavigationElements[LocalVariableDescriptor]

'navigateMarker' @ [115:27] ==> val navigateMarker: LineMarkerInfo<*> defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.assertNavigationElements[LocalVariableDescriptor]

'navigationHandler' @ [115:42] ==> public final val <T : (PsiElement..PsiElement?)> LineMarkerInfo<out (PsiElement..PsiElement?)>.navigationHandler: GutterIconNavigationHandler<out (PsiElement..PsiElement?)>?[MyPropertyDescriptor]
Inferred types:
    <T : (PsiElement..PsiElement?)> -> Captured(*)

'if (handler is TestableLineMarkerNavigator) {
                val navigateElements = handler.getTargetsPopupDescriptor(navigateMarker.element)?.targets?.sortedBy { it.renderAsGotoImplementation() }
                val actualNavigationData = NavigationTestUtils.getNavigateElementsText(myFixture.project, navigateElements)

                UsefulTestCase.assertSameLines(getExpectedNavigationText(navigationComment), actualNavigationData)
            }
            else {
                Assert.fail("Only SuperDeclarationMarkerNavigationHandler are supported in navigate check")
            }' @ [116:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'handler' @ [116:17] ==> val handler: GutterIconNavigationHandler<out (PsiElement..PsiElement?)>? defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.assertNavigationElements[LocalVariableDescriptor]

'handler' @ [117:40] ==> val handler: GutterIconNavigationHandler<out (PsiElement..PsiElement?)>? defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.assertNavigationElements[LocalVariableDescriptor]

'getTargetsPopupDescriptor' @ [117:48] ==> public abstract fun getTargetsPopupDescriptor(element: PsiElement?): NavigationPopupDescriptor? defined in org.jetbrains.kotlin.idea.highlighter.markers.TestableLineMarkerNavigator[DeserializedSimpleFunctionDescriptor]

'navigateMarker' @ [117:74] ==> val navigateMarker: LineMarkerInfo<*> defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.assertNavigationElements[LocalVariableDescriptor]

'element' @ [117:89] ==> public final val <T : (PsiElement..PsiElement?)> LineMarkerInfo<out (PsiElement..PsiElement?)>.element: PsiElement?[MyPropertyDescriptor]
Inferred types:
    <T : (PsiElement..PsiElement?)> -> Captured(*)

'targets' @ [117:99] ==> public final val targets: Collection<NavigatablePsiElement> defined in org.jetbrains.kotlin.idea.highlighter.markers.NavigationPopupDescriptor[DeserializedPropertyDescriptor]

'sortedBy' @ [117:108] ==> public inline fun <T, R : Comparable<String>> Iterable<NavigatablePsiElement>.sortedBy(crossinline selector: (NavigatablePsiElement) -> String?): List<NavigatablePsiElement> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> NavigatablePsiElement
    <R : Comparable<R>> -> String

'it' @ [117:119] ==> value-parameter it: NavigatablePsiElement defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.assertNavigationElements.<anonymous>[ValueParameterDescriptorImpl]

'renderAsGotoImplementation' @ [117:122] ==> public fun PsiElement.renderAsGotoImplementation(): String defined in org.jetbrains.kotlin.test.util in file ReferenceUtils.kt[SimpleFunctionDescriptorImpl]

'getNavigateElementsText' @ [118:64] ==> public open fun getNavigateElementsText(project: (Project..Project?), navigableElements: (MutableCollection<out (PsiElement..PsiElement?)>..Collection<(PsiElement..PsiElement?)>?)): (String..String?) defined in org.jetbrains.kotlin.idea.navigation.NavigationTestUtils[JavaMethodDescriptor]

'myFixture' @ [118:88] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest[JavaPropertyDescriptor]

'project' @ [118:98] ==> public final val JavaCodeInsightTestFixture.project: (Project..Project?)[MyPropertyDescriptor]

'navigateElements' @ [118:107] ==> val navigateElements: List<NavigatablePsiElement>? defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.assertNavigationElements[LocalVariableDescriptor]

'assertSameLines' @ [120:32] ==> public open fun assertSameLines(p0: (String..String?), p1: (String..String?)): Unit defined in com.intellij.testFramework.UsefulTestCase[JavaMethodDescriptor]

'getExpectedNavigationText' @ [120:48] ==> private final fun getExpectedNavigationText(navigationComment: String): String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.Companion[SimpleFunctionDescriptorImpl]

'navigationComment' @ [120:74] ==> val navigationComment: (String..String?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.assertNavigationElements[LocalVariableDescriptor]

'actualNavigationData' @ [120:94] ==> val actualNavigationData: (String..String?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.assertNavigationElements[LocalVariableDescriptor]

'fail' @ [123:24] ==> public open fun fail(p0: (String..String?)): Unit defined in org.junit.Assert[JavaMethodDescriptor]

'navigationComment' @ [134:32] ==> value-parameter navigationComment: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.Companion.getLineMarkerDescription[ValueParameterDescriptorImpl]

'indexOf' @ [134:50] ==> public fun CharSequence.indexOf(string: String, startIndex: Int = ..., ignoreCase: Boolean = ...): Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'assertTrue' @ [135:22] ==> public open fun assertTrue(p0: (String..String?), p1: Boolean): Unit defined in junit.framework.TestCase[JavaMethodDescriptor]

'firstLineEnd' @ [135:124] ==> val firstLineEnd: Int defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.Companion.getLineMarkerDescription[LocalVariableDescriptor]

'-' @ [135:140] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'navigationComment' @ [137:40] ==> value-parameter navigationComment: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.Companion.getLineMarkerDescription[ValueParameterDescriptorImpl]

'substring' @ [137:58] ==> @InlineOnly public inline fun String.substring(startIndex: Int, endIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'firstLineEnd' @ [137:71] ==> val firstLineEnd: Int defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.Companion.getLineMarkerDescription[LocalVariableDescriptor]

'assertTrue' @ [139:22] ==> public open fun assertTrue(p0: (String..String?), p1: Boolean): Unit defined in junit.framework.TestCase[JavaMethodDescriptor]

'format' @ [139:40] ==> @InlineOnly public inline fun String.Companion.format(format: String, vararg args: Any?): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'LINE_MARKER_PREFIX' @ [139:92] ==> private final val LINE_MARKER_PREFIX: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.Companion[PropertyDescriptorImpl]

'navigationMarkerText' @ [140:33] ==> var navigationMarkerText: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.Companion.getLineMarkerDescription[LocalVariableDescriptor]

'startsWith' @ [140:54] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'LINE_MARKER_PREFIX' @ [140:65] ==> private final val LINE_MARKER_PREFIX: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.Companion[PropertyDescriptorImpl]

'navigationMarkerText' @ [142:13] ==> var navigationMarkerText: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.Companion.getLineMarkerDescription[LocalVariableDescriptor]

'navigationMarkerText' @ [142:36] ==> var navigationMarkerText: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.Companion.getLineMarkerDescription[LocalVariableDescriptor]

'substring' @ [142:57] ==> @InlineOnly public inline fun String.substring(startIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'LINE_MARKER_PREFIX' @ [142:67] ==> private final val LINE_MARKER_PREFIX: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.Companion[PropertyDescriptorImpl]

'length' @ [142:86] ==> public open val length: Int defined in kotlin.String[DeserializedPropertyDescriptor]

'navigationMarkerText' @ [144:20] ==> var navigationMarkerText: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.Companion.getLineMarkerDescription[LocalVariableDescriptor]

'trim' @ [144:41] ==> public inline fun String.trim(predicate: (Char) -> Boolean): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'it' @ [144:48] ==> value-parameter it: Char defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.Companion.getLineMarkerDescription.<anonymous>[ValueParameterDescriptorImpl]

'navigationComment' @ [148:32] ==> value-parameter navigationComment: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.Companion.getExpectedNavigationText[ValueParameterDescriptorImpl]

'indexOf' @ [148:50] ==> public fun CharSequence.indexOf(string: String, startIndex: Int = ..., ignoreCase: Boolean = ...): Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'navigationComment' @ [150:42] ==> value-parameter navigationComment: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.Companion.getExpectedNavigationText[ValueParameterDescriptorImpl]

'substring' @ [150:60] ==> @InlineOnly public inline fun String.substring(startIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'firstLineEnd' @ [150:70] ==> val firstLineEnd: Int defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.Companion.getExpectedNavigationText[LocalVariableDescriptor]

'assertTrue' @ [152:22] ==> public open fun assertTrue(p0: (String..String?), p1: Boolean): Unit defined in junit.framework.TestCase[JavaMethodDescriptor]

'format' @ [153:28] ==> @InlineOnly public inline fun String.Companion.format(format: String, vararg args: Any?): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'TARGETS_PREFIX' @ [153:83] ==> private final val TARGETS_PREFIX: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.Companion[PropertyDescriptorImpl]

'expectedNavigationText' @ [154:21] ==> var expectedNavigationText: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.Companion.getExpectedNavigationText[LocalVariableDescriptor]

'startsWith' @ [154:44] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'TARGETS_PREFIX' @ [154:55] ==> private final val TARGETS_PREFIX: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.Companion[PropertyDescriptorImpl]

'expectedNavigationText' @ [156:13] ==> var expectedNavigationText: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.Companion.getExpectedNavigationText[LocalVariableDescriptor]

'expectedNavigationText' @ [156:38] ==> var expectedNavigationText: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.Companion.getExpectedNavigationText[LocalVariableDescriptor]

'substring' @ [156:61] ==> @InlineOnly public inline fun String.substring(startIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'expectedNavigationText' @ [156:71] ==> var expectedNavigationText: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.Companion.getExpectedNavigationText[LocalVariableDescriptor]

'indexOf' @ [156:94] ==> public fun CharSequence.indexOf(string: String, startIndex: Int = ..., ignoreCase: Boolean = ...): Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'expectedNavigationText' @ [158:20] ==> var expectedNavigationText: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractLineMarkersTest.Companion.getExpectedNavigationText[LocalVariableDescriptor]

