'KotlinDebuggerTestCase' @ [70:41] ==> public constructor KotlinDebuggerTestCase() defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestCase[JavaClassConstructorDescriptor]

'Volatile' @ [76:5] ==> public constructor Volatile() defined in kotlin.jvm.Volatile[DeserializedClassConstructorDescriptor]

'_evaluationContext' @ [78:45] ==> @Volatile protected final var _evaluationContext: EvaluationContextImpl? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'Volatile' @ [80:5] ==> public constructor Volatile() defined in kotlin.jvm.Volatile[DeserializedClassConstructorDescriptor]

'_debuggerContext' @ [82:43] ==> @Volatile protected final var _debuggerContext: DebuggerContextImpl? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'Volatile' @ [84:5] ==> public constructor Volatile() defined in kotlin.jvm.Volatile[DeserializedClassConstructorDescriptor]

'_commandProvider' @ [86:43] ==> @Volatile protected final var _commandProvider: KotlinSteppingCommandProvider? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'super' @ [89:9] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[LazyClassReceiverParameterDescriptor]

'initApplication' @ [89:15] ==> protected/*protected and package*/ open fun initApplication(): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestCase[JavaMethodDescriptor]

'saveDefaultSettings' @ [90:9] ==> private final fun saveDefaultSettings(): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'super' @ [94:9] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[LazyClassReceiverParameterDescriptor]

'tearDown' @ [94:15] ==> @Override protected/*protected and package*/ open fun tearDown(): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestCase[JavaMethodDescriptor]

'restoreDefaultSettings' @ [96:9] ==> private final fun restoreDefaultSettings(): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'_evaluationContext' @ [98:9] ==> @Volatile protected final var _evaluationContext: EvaluationContextImpl? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'_debuggerContext' @ [99:9] ==> @Volatile protected final var _debuggerContext: DebuggerContextImpl? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'_commandProvider' @ [100:9] ==> @Volatile protected final var _commandProvider: KotlinSteppingCommandProvider? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'KotlinDebuggerSettings' @ [104:30] ==> public companion object defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings[FakeCallableDescriptorForObject]

'getInstance' @ [104:53] ==> public final fun getInstance(): KotlinDebuggerSettings defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings.Companion[DeserializedSimpleFunctionDescriptor]

'kotlinSettings' @ [105:9] ==> val kotlinSettings: KotlinDebuggerSettings defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.configureSettings[LocalVariableDescriptor]

'DEBUG_IS_FILTER_FOR_STDLIB_ALREADY_ADDED' @ [105:24] ==> public final var DEBUG_IS_FILTER_FOR_STDLIB_ALREADY_ADDED: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings[DeserializedPropertyDescriptor]

'kotlinSettings' @ [106:9] ==> val kotlinSettings: KotlinDebuggerSettings defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.configureSettings[LocalVariableDescriptor]

'DEBUG_DISABLE_KOTLIN_INTERNAL_CLASSES' @ [106:24] ==> public final var DEBUG_DISABLE_KOTLIN_INTERNAL_CLASSES: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings[DeserializedPropertyDescriptor]

'fileText' @ [106:64] ==> value-parameter fileText: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.configureSettings[ValueParameterDescriptorImpl]

'getValueForSetting' @ [106:73] ==> private final fun String.getValueForSetting(name: String, defaultValue: Boolean): Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'oldDisableKotlinInternalClasses' @ [106:127] ==> private final var oldDisableKotlinInternalClasses: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'kotlinSettings' @ [107:9] ==> val kotlinSettings: KotlinDebuggerSettings defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.configureSettings[LocalVariableDescriptor]

'DEBUG_RENDER_DELEGATED_PROPERTIES' @ [107:24] ==> public final var DEBUG_RENDER_DELEGATED_PROPERTIES: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings[DeserializedPropertyDescriptor]

'fileText' @ [107:60] ==> value-parameter fileText: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.configureSettings[ValueParameterDescriptorImpl]

'getValueForSetting' @ [107:69] ==> private final fun String.getValueForSetting(name: String, defaultValue: Boolean): Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'oldRenderDelegatedProperties' @ [107:119] ==> private final var oldRenderDelegatedProperties: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'!!' @ [109:32] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: DebuggerSettings?): DebuggerSettings[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> DebuggerSettings

'getInstance' @ [109:49] ==> public open fun getInstance(): (DebuggerSettings..DebuggerSettings?) defined in com.intellij.debugger.settings.DebuggerSettings[JavaMethodDescriptor]

'debuggerSettings' @ [110:9] ==> val debuggerSettings: DebuggerSettings defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.configureSettings[LocalVariableDescriptor]

'SKIP_SYNTHETIC_METHODS' @ [110:26] ==> public final var SKIP_SYNTHETIC_METHODS: Boolean defined in com.intellij.debugger.settings.DebuggerSettings[JavaPropertyDescriptor]

'fileText' @ [110:51] ==> value-parameter fileText: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.configureSettings[ValueParameterDescriptorImpl]

'getValueForSetting' @ [110:60] ==> private final fun String.getValueForSetting(name: String, defaultValue: Boolean): Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'oldSettings' @ [110:105] ==> private final var oldSettings: DebuggerSettings? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'SKIP_SYNTHETIC_METHODS' @ [110:119] ==> public final var SKIP_SYNTHETIC_METHODS: Boolean defined in com.intellij.debugger.settings.DebuggerSettings[JavaPropertyDescriptor]

'debuggerSettings' @ [111:9] ==> val debuggerSettings: DebuggerSettings defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.configureSettings[LocalVariableDescriptor]

'SKIP_CONSTRUCTORS' @ [111:26] ==> public final var SKIP_CONSTRUCTORS: Boolean defined in com.intellij.debugger.settings.DebuggerSettings[JavaPropertyDescriptor]

'fileText' @ [111:46] ==> value-parameter fileText: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.configureSettings[ValueParameterDescriptorImpl]

'getValueForSetting' @ [111:55] ==> private final fun String.getValueForSetting(name: String, defaultValue: Boolean): Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'oldSettings' @ [111:95] ==> private final var oldSettings: DebuggerSettings? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'SKIP_CONSTRUCTORS' @ [111:109] ==> public final var SKIP_CONSTRUCTORS: Boolean defined in com.intellij.debugger.settings.DebuggerSettings[JavaPropertyDescriptor]

'debuggerSettings' @ [112:9] ==> val debuggerSettings: DebuggerSettings defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.configureSettings[LocalVariableDescriptor]

'SKIP_CLASSLOADERS' @ [112:26] ==> public final var SKIP_CLASSLOADERS: Boolean defined in com.intellij.debugger.settings.DebuggerSettings[JavaPropertyDescriptor]

'fileText' @ [112:46] ==> value-parameter fileText: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.configureSettings[ValueParameterDescriptorImpl]

'getValueForSetting' @ [112:55] ==> private final fun String.getValueForSetting(name: String, defaultValue: Boolean): Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'oldSettings' @ [112:95] ==> private final var oldSettings: DebuggerSettings? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'SKIP_CLASSLOADERS' @ [112:109] ==> public final var SKIP_CLASSLOADERS: Boolean defined in com.intellij.debugger.settings.DebuggerSettings[JavaPropertyDescriptor]

'debuggerSettings' @ [113:9] ==> val debuggerSettings: DebuggerSettings defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.configureSettings[LocalVariableDescriptor]

'TRACING_FILTERS_ENABLED' @ [113:26] ==> public final var TRACING_FILTERS_ENABLED: Boolean defined in com.intellij.debugger.settings.DebuggerSettings[JavaPropertyDescriptor]

'fileText' @ [113:52] ==> value-parameter fileText: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.configureSettings[ValueParameterDescriptorImpl]

'getValueForSetting' @ [113:61] ==> private final fun String.getValueForSetting(name: String, defaultValue: Boolean): Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'oldSettings' @ [113:107] ==> private final var oldSettings: DebuggerSettings? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'TRACING_FILTERS_ENABLED' @ [113:121] ==> public final var TRACING_FILTERS_ENABLED: Boolean defined in com.intellij.debugger.settings.DebuggerSettings[JavaPropertyDescriptor]

'debuggerSettings' @ [114:9] ==> val debuggerSettings: DebuggerSettings defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.configureSettings[LocalVariableDescriptor]

'SKIP_GETTERS' @ [114:26] ==> public final var SKIP_GETTERS: Boolean defined in com.intellij.debugger.settings.DebuggerSettings[JavaPropertyDescriptor]

'fileText' @ [114:41] ==> value-parameter fileText: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.configureSettings[ValueParameterDescriptorImpl]

'getValueForSetting' @ [114:50] ==> private final fun String.getValueForSetting(name: String, defaultValue: Boolean): Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'oldSettings' @ [114:85] ==> private final var oldSettings: DebuggerSettings? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'SKIP_GETTERS' @ [114:99] ==> public final var SKIP_GETTERS: Boolean defined in com.intellij.debugger.settings.DebuggerSettings[JavaPropertyDescriptor]

'findStringWithPrefixes' @ [118:16] ==> @Nullable public open fun findStringWithPrefixes(p0: (String..String?), vararg p1: (String..String?)): String? defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'this' @ [118:39] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.getValueForSetting[ReceiverParameterDescriptorImpl]

'name' @ [118:50] ==> value-parameter name: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.getValueForSetting[ValueParameterDescriptorImpl]

'toBoolean' @ [118:60] ==> @InlineOnly public inline fun String.toBoolean(): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'defaultValue' @ [118:75] ==> value-parameter defaultValue: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.getValueForSetting[ValueParameterDescriptorImpl]

'oldIsFilterForStdlibAlreadyAdded' @ [122:9] ==> private final var oldIsFilterForStdlibAlreadyAdded: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'KotlinDebuggerSettings' @ [122:44] ==> public companion object defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings[FakeCallableDescriptorForObject]

'getInstance' @ [122:67] ==> public final fun getInstance(): KotlinDebuggerSettings defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings.Companion[DeserializedSimpleFunctionDescriptor]

'DEBUG_IS_FILTER_FOR_STDLIB_ALREADY_ADDED' @ [122:81] ==> public final var DEBUG_IS_FILTER_FOR_STDLIB_ALREADY_ADDED: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings[DeserializedPropertyDescriptor]

'oldDisableKotlinInternalClasses' @ [123:9] ==> private final var oldDisableKotlinInternalClasses: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'KotlinDebuggerSettings' @ [123:43] ==> public companion object defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings[FakeCallableDescriptorForObject]

'getInstance' @ [123:66] ==> public final fun getInstance(): KotlinDebuggerSettings defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings.Companion[DeserializedSimpleFunctionDescriptor]

'DEBUG_DISABLE_KOTLIN_INTERNAL_CLASSES' @ [123:80] ==> public final var DEBUG_DISABLE_KOTLIN_INTERNAL_CLASSES: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings[DeserializedPropertyDescriptor]

'oldRenderDelegatedProperties' @ [124:9] ==> private final var oldRenderDelegatedProperties: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'KotlinDebuggerSettings' @ [124:40] ==> public companion object defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings[FakeCallableDescriptorForObject]

'getInstance' @ [124:63] ==> public final fun getInstance(): KotlinDebuggerSettings defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings.Companion[DeserializedSimpleFunctionDescriptor]

'DEBUG_RENDER_DELEGATED_PROPERTIES' @ [124:77] ==> public final var DEBUG_RENDER_DELEGATED_PROPERTIES: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings[DeserializedPropertyDescriptor]

'oldSettings' @ [125:9] ==> private final var oldSettings: DebuggerSettings? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'!!' @ [125:23] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: DebuggerSettings?): DebuggerSettings[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> DebuggerSettings

'getInstance' @ [125:40] ==> public open fun getInstance(): (DebuggerSettings..DebuggerSettings?) defined in com.intellij.debugger.settings.DebuggerSettings[JavaMethodDescriptor]

'clone' @ [125:56] ==> public open fun clone(): DebuggerSettings defined in com.intellij.debugger.settings.DebuggerSettings[JavaMethodDescriptor]

'KotlinDebuggerSettings' @ [129:9] ==> public companion object defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings[FakeCallableDescriptorForObject]

'getInstance' @ [129:32] ==> public final fun getInstance(): KotlinDebuggerSettings defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings.Companion[DeserializedSimpleFunctionDescriptor]

'DEBUG_IS_FILTER_FOR_STDLIB_ALREADY_ADDED' @ [129:46] ==> public final var DEBUG_IS_FILTER_FOR_STDLIB_ALREADY_ADDED: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings[DeserializedPropertyDescriptor]

'oldIsFilterForStdlibAlreadyAdded' @ [129:89] ==> private final var oldIsFilterForStdlibAlreadyAdded: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'KotlinDebuggerSettings' @ [130:9] ==> public companion object defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings[FakeCallableDescriptorForObject]

'getInstance' @ [130:32] ==> public final fun getInstance(): KotlinDebuggerSettings defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings.Companion[DeserializedSimpleFunctionDescriptor]

'DEBUG_DISABLE_KOTLIN_INTERNAL_CLASSES' @ [130:46] ==> public final var DEBUG_DISABLE_KOTLIN_INTERNAL_CLASSES: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings[DeserializedPropertyDescriptor]

'oldDisableKotlinInternalClasses' @ [130:86] ==> private final var oldDisableKotlinInternalClasses: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'KotlinDebuggerSettings' @ [131:9] ==> public companion object defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings[FakeCallableDescriptorForObject]

'getInstance' @ [131:32] ==> public final fun getInstance(): KotlinDebuggerSettings defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings.Companion[DeserializedSimpleFunctionDescriptor]

'DEBUG_RENDER_DELEGATED_PROPERTIES' @ [131:46] ==> public final var DEBUG_RENDER_DELEGATED_PROPERTIES: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings[DeserializedPropertyDescriptor]

'oldRenderDelegatedProperties' @ [131:82] ==> private final var oldRenderDelegatedProperties: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'!!' @ [133:32] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: DebuggerSettings?): DebuggerSettings[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> DebuggerSettings

'getInstance' @ [133:49] ==> public open fun getInstance(): (DebuggerSettings..DebuggerSettings?) defined in com.intellij.debugger.settings.DebuggerSettings[JavaMethodDescriptor]

'debuggerSettings' @ [134:9] ==> val debuggerSettings: DebuggerSettings defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.restoreDefaultSettings[LocalVariableDescriptor]

'SKIP_SYNTHETIC_METHODS' @ [134:26] ==> public final var SKIP_SYNTHETIC_METHODS: Boolean defined in com.intellij.debugger.settings.DebuggerSettings[JavaPropertyDescriptor]

'oldSettings' @ [134:51] ==> private final var oldSettings: DebuggerSettings? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'SKIP_SYNTHETIC_METHODS' @ [134:65] ==> public final var SKIP_SYNTHETIC_METHODS: Boolean defined in com.intellij.debugger.settings.DebuggerSettings[JavaPropertyDescriptor]

'debuggerSettings' @ [135:9] ==> val debuggerSettings: DebuggerSettings defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.restoreDefaultSettings[LocalVariableDescriptor]

'SKIP_CONSTRUCTORS' @ [135:26] ==> public final var SKIP_CONSTRUCTORS: Boolean defined in com.intellij.debugger.settings.DebuggerSettings[JavaPropertyDescriptor]

'oldSettings' @ [135:46] ==> private final var oldSettings: DebuggerSettings? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'SKIP_CONSTRUCTORS' @ [135:60] ==> public final var SKIP_CONSTRUCTORS: Boolean defined in com.intellij.debugger.settings.DebuggerSettings[JavaPropertyDescriptor]

'debuggerSettings' @ [136:9] ==> val debuggerSettings: DebuggerSettings defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.restoreDefaultSettings[LocalVariableDescriptor]

'SKIP_CLASSLOADERS' @ [136:26] ==> public final var SKIP_CLASSLOADERS: Boolean defined in com.intellij.debugger.settings.DebuggerSettings[JavaPropertyDescriptor]

'oldSettings' @ [136:46] ==> private final var oldSettings: DebuggerSettings? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'SKIP_CLASSLOADERS' @ [136:60] ==> public final var SKIP_CLASSLOADERS: Boolean defined in com.intellij.debugger.settings.DebuggerSettings[JavaPropertyDescriptor]

'debuggerSettings' @ [137:9] ==> val debuggerSettings: DebuggerSettings defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.restoreDefaultSettings[LocalVariableDescriptor]

'TRACING_FILTERS_ENABLED' @ [137:26] ==> public final var TRACING_FILTERS_ENABLED: Boolean defined in com.intellij.debugger.settings.DebuggerSettings[JavaPropertyDescriptor]

'oldSettings' @ [137:52] ==> private final var oldSettings: DebuggerSettings? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'TRACING_FILTERS_ENABLED' @ [137:66] ==> public final var TRACING_FILTERS_ENABLED: Boolean defined in com.intellij.debugger.settings.DebuggerSettings[JavaPropertyDescriptor]

'debuggerSettings' @ [138:9] ==> val debuggerSettings: DebuggerSettings defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.restoreDefaultSettings[LocalVariableDescriptor]

'SKIP_GETTERS' @ [138:26] ==> public final var SKIP_GETTERS: Boolean defined in com.intellij.debugger.settings.DebuggerSettings[JavaPropertyDescriptor]

'oldSettings' @ [138:41] ==> private final var oldSettings: DebuggerSettings? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'SKIP_GETTERS' @ [138:55] ==> public final var SKIP_GETTERS: Boolean defined in com.intellij.debugger.settings.DebuggerSettings[JavaPropertyDescriptor]

'debugProcess' @ [142:17] ==> protected/*protected and package*/ for synthetic extension final val KotlinDebuggerTestBase.debugProcess: (DebugProcessImpl..DebugProcessImpl?)[MyPropertyDescriptor]

'AssertionError' @ [142:39] ==> public constructor AssertionError(p0: (Any..Any?)) defined in java.lang.AssertionError[JavaClassConstructorDescriptor]

'super' @ [145:9] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[LazyClassReceiverParameterDescriptor]

'onBreakpoint' @ [145:15] ==> protected/*protected and package*/ for synthetic extension final fun onBreakpoint(p0: (((SuspendContextImpl..SuspendContextImpl?)) -> Unit..(((SuspendContextImpl..SuspendContextImpl?)) -> Unit)?)): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestCase[MyFunctionDescriptor]

'initContexts' @ [147:17] ==> protected final fun initContexts(suspendContext: SuspendContextImpl): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'it' @ [147:30] ==> value-parameter it: (SuspendContextImpl..SuspendContextImpl?) defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doOnBreakpoint.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [148:17] ==> value-parameter it: (SuspendContextImpl..SuspendContextImpl?) defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doOnBreakpoint.<anonymous>[ValueParameterDescriptorImpl]

'printContext' @ [148:20] ==> protected final fun SuspendContextImpl.printContext(): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'it' @ [149:17] ==> value-parameter it: (SuspendContextImpl..SuspendContextImpl?) defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doOnBreakpoint.<anonymous>[ValueParameterDescriptorImpl]

'invoke' @ [149:20] ==> public abstract operator fun SuspendContextImpl.invoke(): Unit defined in kotlin.Function1[FunctionInvokeDescriptor]

'e' @ [152:23] ==> val e: AssertionError defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doOnBreakpoint.<anonymous>[LocalVariableDescriptor]

'e' @ [155:17] ==> val e: Throwable defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doOnBreakpoint.<anonymous>[LocalVariableDescriptor]

'printStackTrace' @ [155:19] ==> public open fun printStackTrace(): Unit defined in kotlin.Throwable[JavaMethodDescriptor]

'resume' @ [156:17] ==> protected/*protected and package*/ open fun resume(p0: (SuspendContextImpl..SuspendContextImpl?)): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[JavaMethodDescriptor]

'it' @ [156:24] ==> value-parameter it: (SuspendContextImpl..SuspendContextImpl?) defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doOnBreakpoint.<anonymous>[ValueParameterDescriptorImpl]

'_evaluationContext' @ [162:9] ==> @Volatile protected final var _evaluationContext: EvaluationContextImpl? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'createEvaluationContext' @ [162:30] ==> protected/*protected and package*/ open fun createEvaluationContext(p0: (SuspendContextImpl..SuspendContextImpl?)): (EvaluationContextImpl..EvaluationContextImpl?) defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[JavaMethodDescriptor]

'suspendContext' @ [162:54] ==> value-parameter suspendContext: SuspendContextImpl defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.initContexts[ValueParameterDescriptorImpl]

'_debuggerContext' @ [163:9] ==> @Volatile protected final var _debuggerContext: DebuggerContextImpl? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'createDebuggerContext' @ [163:28] ==> public open fun createDebuggerContext(p0: (SuspendContextImpl..SuspendContextImpl?)): (DebuggerContextImpl..DebuggerContextImpl?) defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[JavaMethodDescriptor]

'suspendContext' @ [163:50] ==> value-parameter suspendContext: SuspendContextImpl defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.initContexts[ValueParameterDescriptorImpl]

'_commandProvider' @ [164:9] ==> @Volatile protected final var _commandProvider: KotlinSteppingCommandProvider? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'EP_NAME' @ [164:55] ==> public final val EP_NAME: (ExtensionPointName<(JvmSteppingCommandProvider..JvmSteppingCommandProvider?)>..ExtensionPointName<(JvmSteppingCommandProvider..JvmSteppingCommandProvider?)>?) defined in com.intellij.debugger.impl.JvmSteppingCommandProvider[JavaPropertyDescriptor]

'extensions' @ [164:63] ==> public final val <T : (Any..Any?)> ExtensionPointName<(JvmSteppingCommandProvider..JvmSteppingCommandProvider?)>.extensions: (Array<(JvmSteppingCommandProvider..JvmSteppingCommandProvider?)>..Array<out (JvmSteppingCommandProvider..JvmSteppingCommandProvider?)>)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> (com.intellij.debugger.impl.JvmSteppingCommandProvider..com.intellij.debugger.impl.JvmSteppingCommandProvider?)

'firstIsInstance' @ [164:74] ==> public inline fun <reified T> Array<*>.firstIsInstance(): KotlinSteppingCommandProvider defined in org.jetbrains.kotlin.utils.addToStdlib[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T> -> KotlinSteppingCommandProvider

'runReadAction' @ [168:31] ==> public fun <T> runReadAction(action: () -> (DebugProcessImpl.ResumeCommand..DebugProcessImpl.ResumeCommand?)): (DebugProcessImpl.ResumeCommand..DebugProcessImpl.ResumeCommand?) defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.debugger.engine.DebugProcessImpl.ResumeCommand..com.intellij.debugger.engine.DebugProcessImpl.ResumeCommand?)

'commandProvider' @ [169:13] ==> protected final val commandProvider: KotlinSteppingCommandProvider defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'getStepIntoCommand' @ [169:29] ==> public open fun getStepIntoCommand(p0: (SuspendContextImpl..SuspendContextImpl?), p1: Boolean, p2: (MethodFilter..MethodFilter?), p3: Int): (DebugProcessImpl.ResumeCommand..DebugProcessImpl.ResumeCommand?) defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider[JavaMethodDescriptor]

'this' @ [169:48] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doStepInto[ReceiverParameterDescriptorImpl]

'ignoreFilters' @ [169:54] ==> value-parameter ignoreFilters: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doStepInto[ValueParameterDescriptorImpl]

'smartStepFilter' @ [169:69] ==> value-parameter smartStepFilter: MethodFilter? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doStepInto[ValueParameterDescriptorImpl]

'STEP_LINE' @ [169:98] ==> public const final val STEP_LINE: Int defined in com.sun.jdi.request.StepRequest[JavaPropertyDescriptor]

'dp' @ [170:14] ==> protected final val dp: DebugProcessImpl defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'createStepIntoCommand' @ [170:17] ==> @NotNull public open fun createStepIntoCommand(p0: (SuspendContextImpl..SuspendContextImpl?), p1: Boolean, p2: (MethodFilter..MethodFilter?)): DebugProcessImpl.ResumeCommand defined in com.intellij.debugger.engine.DebugProcessImpl[JavaMethodDescriptor]

'this' @ [170:39] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doStepInto[ReceiverParameterDescriptorImpl]

'ignoreFilters' @ [170:45] ==> value-parameter ignoreFilters: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doStepInto[ValueParameterDescriptorImpl]

'smartStepFilter' @ [170:60] ==> value-parameter smartStepFilter: MethodFilter? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doStepInto[ValueParameterDescriptorImpl]

'dp' @ [171:9] ==> protected final val dp: DebugProcessImpl defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'managerThread' @ [171:12] ==> public final val DebugProcessImpl.managerThread: (DebuggerManagerThreadImpl..DebuggerManagerThreadImpl?)[MyPropertyDescriptor]

'schedule' @ [171:26] ==> public open fun schedule(p0: (DebuggerCommandImpl..DebuggerCommandImpl?)): Boolean defined in com.intellij.debugger.engine.DebuggerManagerThreadImpl[JavaMethodDescriptor]

'stepIntoCommand' @ [171:35] ==> val stepIntoCommand: DebugProcessImpl.ResumeCommand defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doStepInto[LocalVariableDescriptor]

'runReadAction' @ [175:30] ==> public fun <T> runReadAction(action: () -> DebugProcessImpl.ResumeCommand?): DebugProcessImpl.ResumeCommand? defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ResumeCommand?

'commandProvider' @ [175:46] ==> protected final val commandProvider: KotlinSteppingCommandProvider defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'getStepOutCommand' @ [175:62] ==> public final fun getStepOutCommand(suspendContext: SuspendContextImpl, debugContext: DebuggerContextImpl): DebugProcessImpl.ResumeCommand? defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider[DeserializedSimpleFunctionDescriptor]

'this' @ [175:80] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doStepOut[ReceiverParameterDescriptorImpl]

'debuggerContext' @ [175:86] ==> protected final val debuggerContext: DebuggerContextImpl defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'dp' @ [176:33] ==> protected final val dp: DebugProcessImpl defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'createStepOutCommand' @ [176:36] ==> @NotNull public open fun createStepOutCommand(p0: (SuspendContextImpl..SuspendContextImpl?)): DebugProcessImpl.ResumeCommand defined in com.intellij.debugger.engine.DebugProcessImpl[JavaMethodDescriptor]

'this' @ [176:57] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doStepOut[ReceiverParameterDescriptorImpl]

'dp' @ [177:9] ==> protected final val dp: DebugProcessImpl defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'managerThread' @ [177:12] ==> public final val DebugProcessImpl.managerThread: (DebuggerManagerThreadImpl..DebuggerManagerThreadImpl?)[MyPropertyDescriptor]

'schedule' @ [177:26] ==> public open fun schedule(p0: (DebuggerCommandImpl..DebuggerCommandImpl?)): Boolean defined in com.intellij.debugger.engine.DebuggerManagerThreadImpl[JavaMethodDescriptor]

'stepOutCommand' @ [177:35] ==> val stepOutCommand: DebugProcessImpl.ResumeCommand defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doStepOut[LocalVariableDescriptor]

'runReadAction' @ [182:17] ==> public fun <T> runReadAction(action: () -> DebugProcessImpl.ResumeCommand?): DebugProcessImpl.ResumeCommand? defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ResumeCommand?

'commandProvider' @ [182:33] ==> protected final val commandProvider: KotlinSteppingCommandProvider defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'getStepOverCommand' @ [182:49] ==> public final fun getStepOverCommand(suspendContext: SuspendContextImpl, ignoreBreakpoints: Boolean, debuggerContext: DebuggerContextImpl): DebugProcessImpl.ResumeCommand? defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider[DeserializedSimpleFunctionDescriptor]

'this' @ [182:68] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doStepOver[ReceiverParameterDescriptorImpl]

'ignoreBreakpoints' @ [182:74] ==> value-parameter ignoreBreakpoints: Boolean = ... defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doStepOver[ValueParameterDescriptorImpl]

'debuggerContext' @ [182:93] ==> protected final val debuggerContext: DebuggerContextImpl defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'dp' @ [183:17] ==> protected final val dp: DebugProcessImpl defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'createStepOverCommand' @ [183:20] ==> @NotNull public open fun createStepOverCommand(p0: (SuspendContextImpl..SuspendContextImpl?), p1: Boolean): DebugProcessImpl.ResumeCommand defined in com.intellij.debugger.engine.DebugProcessImpl[JavaMethodDescriptor]

'this' @ [183:42] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doStepOver[ReceiverParameterDescriptorImpl]

'ignoreBreakpoints' @ [183:48] ==> value-parameter ignoreBreakpoints: Boolean = ... defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doStepOver[ValueParameterDescriptorImpl]

'dp' @ [184:9] ==> protected final val dp: DebugProcessImpl defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'managerThread' @ [184:12] ==> public final val DebugProcessImpl.managerThread: (DebuggerManagerThreadImpl..DebuggerManagerThreadImpl?)[MyPropertyDescriptor]

'schedule' @ [184:26] ==> public open fun schedule(p0: (DebuggerCommandImpl..DebuggerCommandImpl?)): Boolean defined in com.intellij.debugger.engine.DebuggerManagerThreadImpl[JavaMethodDescriptor]

'stepOverCommand' @ [184:35] ==> val stepOverCommand: DebugProcessImpl.ResumeCommand defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doStepOver[LocalVariableDescriptor]

'File' @ [188:20] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'path' @ [188:25] ==> value-parameter path: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doStepping[ValueParameterDescriptorImpl]

'file' @ [189:9] ==> val file: File defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doStepping[LocalVariableDescriptor]

'readLines' @ [189:14] ==> public fun File.readLines(charset: Charset = ...): List<String> defined in kotlin.io[DeserializedSimpleFunctionDescriptor]

'forEach' @ [189:26] ==> @HidesMembers public inline fun <T> Iterable<String>.forEach(action: (String) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'it' @ [190:24] ==> value-parameter it: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doStepping.<anonymous>[ValueParameterDescriptorImpl]

'trim' @ [190:27] ==> @InlineOnly public inline fun String.trim(): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'processSteppingInstruction' @ [191:13] ==> protected final fun processSteppingInstruction(line: String): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'line' @ [191:40] ==> val line: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doStepping.<anonymous>[LocalVariableDescriptor]

'..' @ [197:23] ==> public final operator fun rangeTo(other: Int): IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'?:' @ [197:27] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: Int?, right: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> Int

'getPrefixedInt' @ [197:49] ==> @Nullable public open fun getPrefixedInt(p0: (String..String?), p1: (String..String?)): Int? defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'line' @ [197:64] ==> value-parameter line: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.processSteppingInstruction[ValueParameterDescriptorImpl]

'indexPrefix' @ [197:70] ==> value-parameter indexPrefix: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.processSteppingInstruction.repeat[ValueParameterDescriptorImpl]

'doOnBreakpoint' @ [198:17] ==> public final fun doOnBreakpoint(action: SuspendContextImpl.() -> Unit): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'f' @ [198:32] ==> value-parameter f: SuspendContextImpl.() -> Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.processSteppingInstruction.repeat[ValueParameterDescriptorImpl]

'when {
            !line.startsWith("//") -> return
            line.startsWith("// STEP_INTO: ") -> repeat("// STEP_INTO: ") { doStepInto(false, null) }
            line.startsWith("// STEP_OUT: ") -> repeat("// STEP_OUT: ") { doStepOut() }
            line.startsWith("// STEP_OVER: ") -> repeat("// STEP_OVER: ") { doStepOver() }
            line.startsWith("// STEP_OVER_FORCE: ") -> repeat("// STEP_OVER_FORCE: ") { doStepOver(true) }
            line.startsWith("// SMART_STEP_INTO_BY_INDEX: ") -> doOnBreakpoint { doSmartStepInto(InTextDirectivesUtils.getPrefixedInt(line, "// SMART_STEP_INTO_BY_INDEX: ")!!) }
            line.startsWith("// SMART_STEP_INTO: ") -> repeat("// SMART_STEP_INTO: ") { doSmartStepInto() }
            line.startsWith("// RESUME: ") -> repeat("// RESUME: ") { resume(this) }
        }' @ [202:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit, entry3: Unit, entry4: Unit, entry5: Unit, entry6: Unit, entry7: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'!' @ [203:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'line' @ [203:14] ==> value-parameter line: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.processSteppingInstruction[ValueParameterDescriptorImpl]

'startsWith' @ [203:19] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'line' @ [204:13] ==> value-parameter line: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.processSteppingInstruction[ValueParameterDescriptorImpl]

'startsWith' @ [204:18] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'repeat' @ [204:50] ==> local final fun repeat(indexPrefix: String, f: SuspendContextImpl.() -> Unit): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.processSteppingInstruction[SimpleFunctionDescriptorImpl]

'doStepInto' @ [204:77] ==> protected final fun SuspendContextImpl.doStepInto(ignoreFilters: Boolean, smartStepFilter: MethodFilter?): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'line' @ [205:13] ==> value-parameter line: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.processSteppingInstruction[ValueParameterDescriptorImpl]

'startsWith' @ [205:18] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'repeat' @ [205:49] ==> local final fun repeat(indexPrefix: String, f: SuspendContextImpl.() -> Unit): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.processSteppingInstruction[SimpleFunctionDescriptorImpl]

'doStepOut' @ [205:75] ==> protected final fun SuspendContextImpl.doStepOut(): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'line' @ [206:13] ==> value-parameter line: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.processSteppingInstruction[ValueParameterDescriptorImpl]

'startsWith' @ [206:18] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'repeat' @ [206:50] ==> local final fun repeat(indexPrefix: String, f: SuspendContextImpl.() -> Unit): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.processSteppingInstruction[SimpleFunctionDescriptorImpl]

'doStepOver' @ [206:77] ==> protected final fun SuspendContextImpl.doStepOver(ignoreBreakpoints: Boolean = ...): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'line' @ [207:13] ==> value-parameter line: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.processSteppingInstruction[ValueParameterDescriptorImpl]

'startsWith' @ [207:18] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'repeat' @ [207:56] ==> local final fun repeat(indexPrefix: String, f: SuspendContextImpl.() -> Unit): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.processSteppingInstruction[SimpleFunctionDescriptorImpl]

'doStepOver' @ [207:89] ==> protected final fun SuspendContextImpl.doStepOver(ignoreBreakpoints: Boolean = ...): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'line' @ [208:13] ==> value-parameter line: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.processSteppingInstruction[ValueParameterDescriptorImpl]

'startsWith' @ [208:18] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'doOnBreakpoint' @ [208:65] ==> public final fun doOnBreakpoint(action: SuspendContextImpl.() -> Unit): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'doSmartStepInto' @ [208:82] ==> protected final fun SuspendContextImpl.doSmartStepInto(chooseFromList: Int = ...): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'!!' @ [208:98] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: Int?): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> Int

'getPrefixedInt' @ [208:120] ==> @Nullable public open fun getPrefixedInt(p0: (String..String?), p1: (String..String?)): Int? defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'line' @ [208:135] ==> value-parameter line: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.processSteppingInstruction[ValueParameterDescriptorImpl]

'line' @ [209:13] ==> value-parameter line: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.processSteppingInstruction[ValueParameterDescriptorImpl]

'startsWith' @ [209:18] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'repeat' @ [209:56] ==> local final fun repeat(indexPrefix: String, f: SuspendContextImpl.() -> Unit): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.processSteppingInstruction[SimpleFunctionDescriptorImpl]

'doSmartStepInto' @ [209:89] ==> protected final fun SuspendContextImpl.doSmartStepInto(chooseFromList: Int = ...): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'line' @ [210:13] ==> value-parameter line: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.processSteppingInstruction[ValueParameterDescriptorImpl]

'startsWith' @ [210:18] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'repeat' @ [210:47] ==> local final fun repeat(indexPrefix: String, f: SuspendContextImpl.() -> Unit): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.processSteppingInstruction[SimpleFunctionDescriptorImpl]

'resume' @ [210:71] ==> protected/*protected and package*/ open fun resume(p0: (SuspendContextImpl..SuspendContextImpl?)): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[JavaMethodDescriptor]

'this' @ [210:78] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.processSteppingInstruction.<anonymous>[ReceiverParameterDescriptorImpl]

'this' @ [215:9] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doSmartStepInto[ReceiverParameterDescriptorImpl]

'doSmartStepInto' @ [215:14] ==> private final fun SuspendContextImpl.doSmartStepInto(chooseFromList: Int, ignoreFilters: Boolean): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'chooseFromList' @ [215:30] ==> value-parameter chooseFromList: Int = ... defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doSmartStepInto[ValueParameterDescriptorImpl]

'createSmartStepIntoFilters' @ [219:23] ==> private final fun createSmartStepIntoFilters(): List<MethodFilter> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'if (chooseFromList == 0) {
            filters.forEach {
                dp.managerThread!!.schedule(dp.createStepIntoCommand(this, ignoreFilters, it))
            }
        }
        else {
            try {
                dp.managerThread!!.schedule(dp.createStepIntoCommand(this, ignoreFilters, filters[chooseFromList - 1]))
            }
            catch(e: IndexOutOfBoundsException) {
                throw AssertionError("Couldn't find smart step into command at: \n" +
                                     runReadAction { debuggerContext.sourcePosition.elementAt.getElementTextWithContext() },
                                     e)
            }
        }' @ [220:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any, elseBranch: Any): Any[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any

'chooseFromList' @ [220:13] ==> value-parameter chooseFromList: Int defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doSmartStepInto[ValueParameterDescriptorImpl]

'filters' @ [221:13] ==> val filters: List<MethodFilter> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doSmartStepInto[LocalVariableDescriptor]

'forEach' @ [221:21] ==> @HidesMembers public inline fun <T> Iterable<MethodFilter>.forEach(action: (MethodFilter) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> MethodFilter

'dp' @ [222:17] ==> protected final val dp: DebugProcessImpl defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'managerThread' @ [222:20] ==> public final val DebugProcessImpl.managerThread: (DebuggerManagerThreadImpl..DebuggerManagerThreadImpl?)[MyPropertyDescriptor]

'schedule' @ [222:36] ==> public open fun schedule(p0: (DebuggerCommandImpl..DebuggerCommandImpl?)): Boolean defined in com.intellij.debugger.engine.DebuggerManagerThreadImpl[JavaMethodDescriptor]

'dp' @ [222:45] ==> protected final val dp: DebugProcessImpl defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'createStepIntoCommand' @ [222:48] ==> @NotNull public open fun createStepIntoCommand(p0: (SuspendContextImpl..SuspendContextImpl?), p1: Boolean, p2: (MethodFilter..MethodFilter?)): DebugProcessImpl.ResumeCommand defined in com.intellij.debugger.engine.DebugProcessImpl[JavaMethodDescriptor]

'this' @ [222:70] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doSmartStepInto[ReceiverParameterDescriptorImpl]

'ignoreFilters' @ [222:76] ==> value-parameter ignoreFilters: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doSmartStepInto[ValueParameterDescriptorImpl]

'it' @ [222:91] ==> value-parameter it: MethodFilter defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doSmartStepInto.<anonymous>[ValueParameterDescriptorImpl]

'dp' @ [227:17] ==> protected final val dp: DebugProcessImpl defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'managerThread' @ [227:20] ==> public final val DebugProcessImpl.managerThread: (DebuggerManagerThreadImpl..DebuggerManagerThreadImpl?)[MyPropertyDescriptor]

'schedule' @ [227:36] ==> public open fun schedule(p0: (DebuggerCommandImpl..DebuggerCommandImpl?)): Boolean defined in com.intellij.debugger.engine.DebuggerManagerThreadImpl[JavaMethodDescriptor]

'dp' @ [227:45] ==> protected final val dp: DebugProcessImpl defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'createStepIntoCommand' @ [227:48] ==> @NotNull public open fun createStepIntoCommand(p0: (SuspendContextImpl..SuspendContextImpl?), p1: Boolean, p2: (MethodFilter..MethodFilter?)): DebugProcessImpl.ResumeCommand defined in com.intellij.debugger.engine.DebugProcessImpl[JavaMethodDescriptor]

'this' @ [227:70] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doSmartStepInto[ReceiverParameterDescriptorImpl]

'ignoreFilters' @ [227:76] ==> value-parameter ignoreFilters: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doSmartStepInto[ValueParameterDescriptorImpl]

'filters' @ [227:91] ==> val filters: List<MethodFilter> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doSmartStepInto[LocalVariableDescriptor]

'chooseFromList' @ [227:99] ==> value-parameter chooseFromList: Int defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doSmartStepInto[ValueParameterDescriptorImpl]

'AssertionError' @ [230:23] ==> public constructor AssertionError(p0: (String..String?), p1: (Throwable..Throwable?)) defined in java.lang.AssertionError[JavaClassConstructorDescriptor]

'+' @ [230:38] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'runReadAction' @ [231:38] ==> public fun <T> runReadAction(action: () -> String): String defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'debuggerContext' @ [231:54] ==> protected final val debuggerContext: DebuggerContextImpl defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'sourcePosition' @ [231:70] ==> public final val DebuggerContextImpl.sourcePosition: (SourcePosition..SourcePosition?)[MyPropertyDescriptor]

'elementAt' @ [231:85] ==> public final val SourcePosition.elementAt: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'getElementTextWithContext' @ [231:95] ==> public fun PsiElement.getElementTextWithContext(): String defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'e' @ [232:38] ==> val e: IndexOutOfBoundsException /* = IndexOutOfBoundsException */ defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.doSmartStepInto[LocalVariableDescriptor]

'runReadAction' @ [238:16] ==> public fun <T> runReadAction(action: () -> List<MethodFilter>): List<MethodFilter> defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> List<MethodFilter>

'debuggerContext' @ [239:28] ==> protected final val debuggerContext: DebuggerContextImpl defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[PropertyDescriptorImpl]

'sourcePosition' @ [239:44] ==> public final val DebuggerContextImpl.sourcePosition: (SourcePosition..SourcePosition?)[MyPropertyDescriptor]

'KotlinSmartStepIntoHandler' @ [241:31] ==> public constructor KotlinSmartStepIntoHandler() defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSmartStepIntoHandler[DeserializedClassConstructorDescriptor]

'findSmartStepTargets' @ [241:60] ==> public open fun findSmartStepTargets(position: SourcePosition): List<SmartStepTarget> defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSmartStepIntoHandler[DeserializedSimpleFunctionDescriptor]

'position' @ [241:81] ==> val position: (SourcePosition..SourcePosition?) defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createSmartStepIntoFilters.<anonymous>[LocalVariableDescriptor]

'stepTargets' @ [242:13] ==> val stepTargets: List<SmartStepTarget> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createSmartStepIntoFilters.<anonymous>[LocalVariableDescriptor]

'filterIsInstance' @ [242:25] ==> public inline fun <reified R> Iterable<*>.filterIsInstance(): List<SmartStepTarget> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified R> -> SmartStepTarget

'mapNotNull' @ [242:61] ==> public inline fun <T, R : Any> Iterable<SmartStepTarget>.mapNotNull(transform: (SmartStepTarget) -> MethodFilter?): List<MethodFilter> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SmartStepTarget
    <R : Any> -> MethodFilter

'when (stepTarget) {
                    is KotlinLambdaSmartStepTarget ->
                        KotlinLambdaMethodFilter(
                                stepTarget.getLambda(), stepTarget.getCallingExpressionLines()!!, stepTarget.isInline, stepTarget.isSuspend)
                    is KotlinMethodSmartStepTarget ->
                        KotlinBasicStepMethodFilter(stepTarget.descriptor, stepTarget.getCallingExpressionLines()!!)
                    is MethodSmartStepTarget -> BasicStepMethodFilter(stepTarget.method, stepTarget.getCallingExpressionLines())
                    else -> null
                }' @ [244:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: MethodFilter?, entry1: MethodFilter?, entry2: MethodFilter?, entry3: MethodFilter?): MethodFilter?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> MethodFilter?

'stepTarget' @ [244:23] ==> value-parameter stepTarget: SmartStepTarget defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createSmartStepIntoFilters.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'KotlinLambdaMethodFilter' @ [246:25] ==> public constructor KotlinLambdaMethodFilter(lambda: KtFunction, myCallingExpressionLines: Range<Int>, isInline: Boolean, isSuspend: Boolean) defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinLambdaMethodFilter[DeserializedClassConstructorDescriptor]

'stepTarget' @ [247:33] ==> value-parameter stepTarget: SmartStepTarget defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createSmartStepIntoFilters.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'getLambda' @ [247:44] ==> public final fun getLambda(): KtFunction defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinLambdaSmartStepTarget[DeserializedSimpleFunctionDescriptor]

'stepTarget' @ [247:57] ==> value-parameter stepTarget: SmartStepTarget defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createSmartStepIntoFilters.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'getCallingExpressionLines' @ [247:68] ==> @Nullable public open fun getCallingExpressionLines(): Range<(Int..Int?)>? defined in com.intellij.debugger.actions.SmartStepTarget[JavaMethodDescriptor]

'stepTarget' @ [247:99] ==> value-parameter stepTarget: SmartStepTarget defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createSmartStepIntoFilters.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'isInline' @ [247:110] ==> public final val isInline: Boolean defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinLambdaSmartStepTarget[DeserializedPropertyDescriptor]

'stepTarget' @ [247:120] ==> value-parameter stepTarget: SmartStepTarget defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createSmartStepIntoFilters.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'isSuspend' @ [247:131] ==> public final val isSuspend: Boolean defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinLambdaSmartStepTarget[DeserializedPropertyDescriptor]

'KotlinBasicStepMethodFilter' @ [249:25] ==> public constructor KotlinBasicStepMethodFilter(targetDescriptor: CallableMemberDescriptor, myCallingExpressionLines: Range<Int>) defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinBasicStepMethodFilter[DeserializedClassConstructorDescriptor]

'stepTarget' @ [249:53] ==> value-parameter stepTarget: SmartStepTarget defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createSmartStepIntoFilters.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'descriptor' @ [249:64] ==> public final val descriptor: CallableMemberDescriptor defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinMethodSmartStepTarget[DeserializedPropertyDescriptor]

'stepTarget' @ [249:76] ==> value-parameter stepTarget: SmartStepTarget defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createSmartStepIntoFilters.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'getCallingExpressionLines' @ [249:87] ==> @Nullable public open fun getCallingExpressionLines(): Range<(Int..Int?)>? defined in com.intellij.debugger.actions.SmartStepTarget[JavaMethodDescriptor]

'BasicStepMethodFilter' @ [250:49] ==> public constructor BasicStepMethodFilter(@NotNull p0: PsiMethod, p1: (Range<(Int..Int?)>..Range<(Int..Int?)>?)) defined in com.intellij.debugger.engine.BasicStepMethodFilter[JavaClassConstructorDescriptor]

'stepTarget' @ [250:71] ==> value-parameter stepTarget: SmartStepTarget defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createSmartStepIntoFilters.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'method' @ [250:82] ==> public final val MethodSmartStepTarget.method: PsiMethod[MyPropertyDescriptor]

'stepTarget' @ [250:90] ==> value-parameter stepTarget: SmartStepTarget defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createSmartStepIntoFilters.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'getCallingExpressionLines' @ [250:101] ==> @Nullable public open fun getCallingExpressionLines(): Range<(Int..Int?)>? defined in com.intellij.debugger.actions.SmartStepTarget[JavaMethodDescriptor]

'runReadAction' @ [258:9] ==> public fun <T> runReadAction(action: () -> Unit): Unit defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Unit

'this' @ [259:17] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.printContext[ReceiverParameterDescriptorImpl]

'frameProxy' @ [259:22] ==> public final val SuspendContextImpl.frameProxy: StackFrameProxyImpl?[MyPropertyDescriptor]

'println' @ [260:38] ==> public open fun println(@NonNls p0: (String..String?), p1: raw (Key<(Any..Any?)>..Key<*>?)): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[JavaMethodDescriptor]

'SYSTEM' @ [260:91] ==> public final val SYSTEM: raw (Key<(Any..Any?)>..Key<*>?) defined in com.intellij.execution.process.ProcessOutputTypes[JavaPropertyDescriptor]

'getSourcePosition' @ [263:47] ==> public open fun getSourcePosition(p0: (StackFrameContext..StackFrameContext?)): (SourcePosition..SourcePosition?) defined in com.intellij.debugger.impl.PositionUtil[JavaMethodDescriptor]

'this' @ [263:65] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.printContext[ReceiverParameterDescriptorImpl]

'println' @ [264:13] ==> public open fun println(@NonNls p0: (String..String?), p1: raw (Key<(Any..Any?)>..Key<*>?)): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[JavaMethodDescriptor]

'renderSourcePosition' @ [264:21] ==> protected final fun renderSourcePosition(sourcePosition: SourcePosition?): String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'sourcePosition' @ [264:42] ==> val sourcePosition: (SourcePosition..SourcePosition?) defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.printContext.<anonymous>[LocalVariableDescriptor]

'SYSTEM' @ [264:78] ==> public final val SYSTEM: raw (Key<(Any..Any?)>..Key<*>?) defined in com.intellij.execution.process.ProcessOutputTypes[JavaPropertyDescriptor]

'sourcePosition' @ [269:13] ==> value-parameter sourcePosition: SourcePosition? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.renderSourcePosition[ValueParameterDescriptorImpl]

'sourcePosition' @ [273:27] ==> value-parameter sourcePosition: SourcePosition? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.renderSourcePosition[ValueParameterDescriptorImpl]

'file' @ [273:42] ==> public final val SourcePosition.file: PsiFile[MyPropertyDescriptor]

'originalFile' @ [273:47] ==> public final val PsiFile.originalFile: PsiFile[MyPropertyDescriptor]

'virtualFile' @ [273:60] ==> public final val PsiFile.virtualFile: (VirtualFile..VirtualFile?)[MyPropertyDescriptor]

'sourcePosition' @ [273:75] ==> value-parameter sourcePosition: SourcePosition? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.renderSourcePosition[ValueParameterDescriptorImpl]

'file' @ [273:90] ==> public final val SourcePosition.file: PsiFile[MyPropertyDescriptor]

'viewProvider' @ [273:95] ==> public final val PsiFile.viewProvider: FileViewProvider[MyPropertyDescriptor]

'virtualFile' @ [273:108] ==> public final val FileViewProvider.virtualFile: VirtualFile[MyPropertyDescriptor]

'findLibraryEntry' @ [276:40] ==> @Nullable public open fun findLibraryEntry(p0: (VirtualFile..VirtualFile?), p1: (Project..Project?)): OrderEntry? defined in com.intellij.openapi.roots.libraries.LibraryUtil[JavaMethodDescriptor]

'virtualFile' @ [276:57] ==> val virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.renderSourcePosition[LocalVariableDescriptor]

'project' @ [276:70] ==> public final val KotlinDebuggerTestBase.project: (Project..Project?)[MyPropertyDescriptor]

'libraryEntry' @ [277:13] ==> val libraryEntry: OrderEntry? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.renderSourcePosition[LocalVariableDescriptor]

'libraryEntry' @ [277:38] ==> val libraryEntry: OrderEntry? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.renderSourcePosition[LocalVariableDescriptor]

'libraryEntry' @ [277:71] ==> val libraryEntry: OrderEntry? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.renderSourcePosition[LocalVariableDescriptor]

'presentableName' @ [277:84] ==> public final val OrderEntry.presentableName: String[MyPropertyDescriptor]

'KOTLIN_LIBRARY_NAME' @ [277:103] ==> protected/*protected static*/ const final val KOTLIN_LIBRARY_NAME: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestCase[JavaPropertyDescriptor]

'+' @ [278:20] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'getNameWithoutExtension' @ [278:29] ==> @NotNull public open fun getNameWithoutExtension(@NotNull p0: String): String defined in com.intellij.openapi.util.io.FileUtil[JavaMethodDescriptor]

'virtualFile' @ [278:53] ==> val virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.renderSourcePosition[LocalVariableDescriptor]

'name' @ [278:65] ==> public final val VirtualFile.name: String[MyPropertyDescriptor]

'virtualFile' @ [281:16] ==> val virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.renderSourcePosition[LocalVariableDescriptor]

'name' @ [281:28] ==> public final val VirtualFile.name: String[MyPropertyDescriptor]

'sourcePosition' @ [281:42] ==> value-parameter sourcePosition: SourcePosition? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.renderSourcePosition[ValueParameterDescriptorImpl]

'line' @ [281:57] ==> public final val SourcePosition.line: Int[MyPropertyDescriptor]

'doOnBreakpoint' @ [285:9] ==> public final fun doOnBreakpoint(action: SuspendContextImpl.() -> Unit): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'resume' @ [286:13] ==> protected/*protected and package*/ open fun resume(p0: (SuspendContextImpl..SuspendContextImpl?)): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[JavaMethodDescriptor]

'this' @ [286:20] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.finish.<anonymous>[ReceiverParameterDescriptorImpl]

'file' @ [291:13] ==> value-parameter file: PsiFile? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints[ValueParameterDescriptorImpl]

'runReadAction' @ [293:24] ==> public fun <T> runReadAction(action: () -> Document?): Document? defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Document?

'getInstance' @ [293:59] ==> public open fun getInstance(@NotNull p0: Project): (PsiDocumentManager..PsiDocumentManager?) defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'myProject' @ [293:71] ==> protected/*protected and package*/ final var myProject: (Project..Project?) defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[JavaPropertyDescriptor]

'getDocument' @ [293:82] ==> @Nullable public abstract fun getDocument(@NotNull p0: PsiFile): Document? defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'file' @ [293:94] ==> value-parameter file: PsiFile? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints[ValueParameterDescriptorImpl]

'getInstance' @ [294:50] ==> public open fun getInstance(@NotNull p0: Project): (XDebuggerManager..XDebuggerManager?) defined in com.intellij.xdebugger.XDebuggerManager[JavaMethodDescriptor]

'myProject' @ [294:62] ==> protected/*protected and package*/ final var myProject: (Project..Project?) defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[JavaPropertyDescriptor]

'breakpointManager' @ [294:73] ==> public final val XDebuggerManager.breakpointManager: XBreakpointManager[MyPropertyDescriptor]

'findBreakpointType' @ [295:41] ==> @Suppress private final inline fun <reified T : XBreakpointType<*, *>> findBreakpointType(javaClass: Class<KotlinFieldBreakpointType>): XLineBreakpointType<XBreakpointProperties<*>> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]
Inferred types:
    <reified T : XBreakpointType<*, *>> -> KotlinFieldBreakpointType

'KotlinFieldBreakpointType' @ [295:60] ==> public constructor KotlinFieldBreakpointType() defined in org.jetbrains.kotlin.idea.debugger.breakpoints.KotlinFieldBreakpointType[DeserializedClassConstructorDescriptor]

'java' @ [295:93] ==> public val <T> KClass<KotlinFieldBreakpointType>.java: Class<KotlinFieldBreakpointType> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KotlinFieldBreakpointType

'file' @ [296:27] ==> value-parameter file: PsiFile? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints[ValueParameterDescriptorImpl]

'virtualFile' @ [296:32] ==> public final val PsiFile.virtualFile: (VirtualFile..VirtualFile?)[MyPropertyDescriptor]

'-' @ [299:26] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'document' @ [301:32] ==> val document: Document defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints[LocalVariableDescriptor]

'text' @ [301:41] ==> public final val Document.text: String[MyPropertyDescriptor]

'offset' @ [302:17] ==> var offset: Int defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'fileText' @ [302:26] ==> val fileText: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'indexOf' @ [302:35] ==> public fun CharSequence.indexOf(string: String, startIndex: Int = ..., ignoreCase: Boolean = ...): Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'offset' @ [302:53] ==> var offset: Int defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'offset' @ [303:21] ==> var offset: Int defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'-' @ [303:31] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'document' @ [305:35] ==> val document: Document defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints[LocalVariableDescriptor]

'getLineNumber' @ [305:44] ==> @Contract public abstract fun getLineNumber(p0: Int): Int defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'offset' @ [305:58] ==> var offset: Int defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'fileText' @ [307:31] ==> val fileText: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'substring' @ [307:40] ==> @InlineOnly public inline fun String.substring(startIndex: Int, endIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'document' @ [307:50] ==> val document: Document defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints[LocalVariableDescriptor]

'getLineStartOffset' @ [307:59] ==> @Contract public abstract fun getLineStartOffset(p0: Int): Int defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'commentLine' @ [307:78] ==> val commentLine: Int defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'document' @ [307:92] ==> val document: Document defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints[LocalVariableDescriptor]

'getLineEndOffset' @ [307:101] ==> @Contract public abstract fun getLineEndOffset(p0: Int): Int defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'commentLine' @ [307:118] ==> val commentLine: Int defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'trim' @ [307:132] ==> @InlineOnly public inline fun String.trim(): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'commentLine' @ [309:33] ==> val commentLine: Int defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'if (comment.startsWith("//FieldWatchpoint!")) {
                    val javaBreakpoint = createBreakpointOfType(
                            breakpointManager,
                            kotlinFieldBreakpointType,
                            lineIndex,
                            virtualFile)
                    if (javaBreakpoint is KotlinFieldBreakpoint) {
                        val fieldName = comment.substringAfter("//FieldWatchpoint! (").substringBefore(")")
                        javaBreakpoint.setFieldName(fieldName)
                        javaBreakpoint.setWatchAccess(fileText.getValueForSetting("WATCH_FIELD_ACCESS", true))
                        javaBreakpoint.setWatchModification(fileText.getValueForSetting("WATCH_FIELD_MODIFICATION", true))
                        javaBreakpoint.setWatchInitialization(fileText.getValueForSetting("WATCH_FIELD_INITIALISATION", false))
                        BreakpointManager.addBreakpoint(javaBreakpoint)
                        println("KotlinFieldBreakpoint created at ${file.virtualFile.name}:${lineIndex + 1}", ProcessOutputTypes.SYSTEM)
                    }
                }
                else if (comment.startsWith("//Breakpoint!")) {
                    val ordinal = getPropertyFromComment(comment, "lambdaOrdinal")?.toInt()
                    val condition = getPropertyFromComment(comment, "condition")
                    createLineBreakpoint(breakpointManager, file, lineIndex, ordinal, condition)
                }
                else {
                    throw AssertionError("Cannot create breakpoint at line ${lineIndex + 1}")
                }' @ [311:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'comment' @ [311:21] ==> val comment: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'startsWith' @ [311:29] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'createBreakpointOfType' @ [312:42] ==> private final fun createBreakpointOfType(breakpointManager: XBreakpointManager, breakpointType: XLineBreakpointType<XBreakpointProperties<*>>, lineIndex: Int, virtualFile: VirtualFile): Breakpoint<out JavaBreakpointProperties<*>>? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'breakpointManager' @ [313:29] ==> val breakpointManager: XBreakpointManager defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints[LocalVariableDescriptor]

'kotlinFieldBreakpointType' @ [314:29] ==> val kotlinFieldBreakpointType: XLineBreakpointType<XBreakpointProperties<*>> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints[LocalVariableDescriptor]

'lineIndex' @ [315:29] ==> val lineIndex: Int defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'virtualFile' @ [316:29] ==> val virtualFile: (VirtualFile..VirtualFile?) defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints[LocalVariableDescriptor]

'javaBreakpoint' @ [317:25] ==> val javaBreakpoint: Breakpoint<out JavaBreakpointProperties<*>>? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'comment' @ [318:41] ==> val comment: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'substringAfter' @ [318:49] ==> public fun String.substringAfter(delimiter: String, missingDelimiterValue: String = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'substringBefore' @ [318:88] ==> public fun String.substringBefore(delimiter: String, missingDelimiterValue: String = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'javaBreakpoint' @ [319:25] ==> val javaBreakpoint: Breakpoint<out JavaBreakpointProperties<*>>? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'setFieldName' @ [319:40] ==> public final fun setFieldName(fieldName: String): Unit defined in org.jetbrains.kotlin.idea.debugger.breakpoints.KotlinFieldBreakpoint[DeserializedSimpleFunctionDescriptor]

'fieldName' @ [319:53] ==> val fieldName: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'javaBreakpoint' @ [320:25] ==> val javaBreakpoint: Breakpoint<out JavaBreakpointProperties<*>>? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'setWatchAccess' @ [320:40] ==> public final fun setWatchAccess(value: Boolean): Unit defined in org.jetbrains.kotlin.idea.debugger.breakpoints.KotlinFieldBreakpoint[DeserializedSimpleFunctionDescriptor]

'fileText' @ [320:55] ==> val fileText: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'getValueForSetting' @ [320:64] ==> private final fun String.getValueForSetting(name: String, defaultValue: Boolean): Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'javaBreakpoint' @ [321:25] ==> val javaBreakpoint: Breakpoint<out JavaBreakpointProperties<*>>? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'setWatchModification' @ [321:40] ==> public final fun setWatchModification(value: Boolean): Unit defined in org.jetbrains.kotlin.idea.debugger.breakpoints.KotlinFieldBreakpoint[DeserializedSimpleFunctionDescriptor]

'fileText' @ [321:61] ==> val fileText: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'getValueForSetting' @ [321:70] ==> private final fun String.getValueForSetting(name: String, defaultValue: Boolean): Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'javaBreakpoint' @ [322:25] ==> val javaBreakpoint: Breakpoint<out JavaBreakpointProperties<*>>? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'setWatchInitialization' @ [322:40] ==> public final fun setWatchInitialization(value: Boolean): Unit defined in org.jetbrains.kotlin.idea.debugger.breakpoints.KotlinFieldBreakpoint[DeserializedSimpleFunctionDescriptor]

'fileText' @ [322:63] ==> val fileText: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'getValueForSetting' @ [322:72] ==> private final fun String.getValueForSetting(name: String, defaultValue: Boolean): Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'addBreakpoint' @ [323:43] ==> public open fun addBreakpoint(@NotNull p0: raw (Breakpoint<(JavaBreakpointProperties<*>..JavaBreakpointProperties<*>?)>..Breakpoint<out (JavaBreakpointProperties<*>..JavaBreakpointProperties<*>?)>)): Unit defined in com.intellij.debugger.ui.breakpoints.BreakpointManager[JavaMethodDescriptor]

'javaBreakpoint' @ [323:57] ==> val javaBreakpoint: Breakpoint<out JavaBreakpointProperties<*>>? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'println' @ [324:25] ==> public open fun println(@NonNls p0: (String..String?), p1: raw (Key<(Any..Any?)>..Key<*>?)): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[JavaMethodDescriptor]

'file' @ [324:69] ==> value-parameter file: PsiFile? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints[ValueParameterDescriptorImpl]

'virtualFile' @ [324:74] ==> public final val PsiFile.virtualFile: (VirtualFile..VirtualFile?)[MyPropertyDescriptor]

'name' @ [324:86] ==> public final val VirtualFile.name: String[MyPropertyDescriptor]

'lineIndex' @ [324:94] ==> val lineIndex: Int defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'SYSTEM' @ [324:130] ==> public final val SYSTEM: raw (Key<(Any..Any?)>..Key<*>?) defined in com.intellij.execution.process.ProcessOutputTypes[JavaPropertyDescriptor]

'if (comment.startsWith("//Breakpoint!")) {
                    val ordinal = getPropertyFromComment(comment, "lambdaOrdinal")?.toInt()
                    val condition = getPropertyFromComment(comment, "condition")
                    createLineBreakpoint(breakpointManager, file, lineIndex, ordinal, condition)
                }
                else {
                    throw AssertionError("Cannot create breakpoint at line ${lineIndex + 1}")
                }' @ [327:22] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'comment' @ [327:26] ==> val comment: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'startsWith' @ [327:34] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'getPropertyFromComment' @ [328:35] ==> private final fun getPropertyFromComment(comment: String, propertyName: String): String? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'comment' @ [328:58] ==> val comment: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'toInt' @ [328:85] ==> @InlineOnly public inline fun String.toInt(): Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'getPropertyFromComment' @ [329:37] ==> private final fun getPropertyFromComment(comment: String, propertyName: String): String? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'comment' @ [329:60] ==> val comment: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'createLineBreakpoint' @ [330:21] ==> private final fun createLineBreakpoint(breakpointManager: XBreakpointManager, file: PsiFile, lineIndex: Int, lambdaOrdinal: Int?, condition: String?): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'breakpointManager' @ [330:42] ==> val breakpointManager: XBreakpointManager defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints[LocalVariableDescriptor]

'file' @ [330:61] ==> value-parameter file: PsiFile? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints[ValueParameterDescriptorImpl]

'lineIndex' @ [330:67] ==> val lineIndex: Int defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'ordinal' @ [330:78] ==> val ordinal: Int? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'condition' @ [330:87] ==> val condition: String? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'AssertionError' @ [333:27] ==> public constructor AssertionError(p0: (Any..Any?)) defined in java.lang.AssertionError[JavaClassConstructorDescriptor]

'lineIndex' @ [333:78] ==> val lineIndex: Int defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints.<anonymous>[LocalVariableDescriptor]

'if (!SwingUtilities.isEventDispatchThread()) {
            DebuggerInvocationUtil.invokeAndWait(myProject, runnable, ModalityState.defaultModalityState())
        }
        else {
            runnable.invoke()
        }' @ [338:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'!' @ [338:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isEventDispatchThread' @ [338:29] ==> public open fun isEventDispatchThread(): Boolean defined in javax.swing.SwingUtilities[JavaMethodDescriptor]

'invokeAndWait' @ [339:36] ==> public final fun invokeAndWait(p0: (Project..Project?), @NotNull p1: () -> Unit, p2: (ModalityState..ModalityState?)): Unit defined in com.intellij.debugger.DebuggerInvocationUtil[SamAdapterFunctionDescriptor]

'myProject' @ [339:50] ==> protected/*protected and package*/ final var myProject: (Project..Project?) defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[JavaPropertyDescriptor]

'runnable' @ [339:61] ==> val runnable: () -> Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints[LocalVariableDescriptor]

'defaultModalityState' @ [339:85] ==> @NotNull public open fun defaultModalityState(): ModalityState defined in com.intellij.openapi.application.ModalityState[JavaMethodDescriptor]

'runnable' @ [342:13] ==> val runnable: () -> Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoints[LocalVariableDescriptor]

'invoke' @ [342:22] ==> public abstract operator fun invoke(): Unit defined in kotlin.Function0[FunctionInvokeDescriptor]

'comment' @ [347:13] ==> value-parameter comment: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.getPropertyFromComment[ValueParameterDescriptorImpl]

'contains' @ [347:21] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'propertyName' @ [347:32] ==> value-parameter propertyName: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.getPropertyFromComment[ValueParameterDescriptorImpl]

'comment' @ [348:26] ==> value-parameter comment: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.getPropertyFromComment[ValueParameterDescriptorImpl]

'substringAfter' @ [348:34] ==> public fun String.substringAfter(delimiter: String, missingDelimiterValue: String = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'propertyName' @ [348:51] ==> value-parameter propertyName: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.getPropertyFromComment[ValueParameterDescriptorImpl]

'result' @ [349:17] ==> val result: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.getPropertyFromComment[LocalVariableDescriptor]

'contains' @ [349:24] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'result' @ [350:24] ==> val result: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.getPropertyFromComment[LocalVariableDescriptor]

'substringBefore' @ [350:31] ==> public fun String.substringBefore(delimiter: String, missingDelimiterValue: String = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'result' @ [352:17] ==> val result: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.getPropertyFromComment[LocalVariableDescriptor]

'contains' @ [352:24] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'result' @ [353:24] ==> val result: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.getPropertyFromComment[LocalVariableDescriptor]

'substringBefore' @ [353:31] ==> public fun String.substringBefore(delimiter: String, missingDelimiterValue: String = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'findBreakpointType' @ [366:40] ==> @Suppress private final inline fun <reified T : XBreakpointType<*, *>> findBreakpointType(javaClass: Class<KotlinLineBreakpointType>): XLineBreakpointType<XBreakpointProperties<*>> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]
Inferred types:
    <reified T : XBreakpointType<*, *>> -> KotlinLineBreakpointType

'KotlinLineBreakpointType' @ [366:59] ==> public constructor KotlinLineBreakpointType() defined in org.jetbrains.kotlin.idea.debugger.breakpoints.KotlinLineBreakpointType[JavaClassConstructorDescriptor]

'java' @ [366:91] ==> public val <T> KClass<KotlinLineBreakpointType>.java: Class<KotlinLineBreakpointType> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KotlinLineBreakpointType

'createBreakpointOfType' @ [367:30] ==> private final fun createBreakpointOfType(breakpointManager: XBreakpointManager, breakpointType: XLineBreakpointType<XBreakpointProperties<*>>, lineIndex: Int, virtualFile: VirtualFile): Breakpoint<out JavaBreakpointProperties<*>>? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'breakpointManager' @ [368:17] ==> value-parameter breakpointManager: XBreakpointManager defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createLineBreakpoint[ValueParameterDescriptorImpl]

'kotlinLineBreakpointType' @ [369:17] ==> val kotlinLineBreakpointType: XLineBreakpointType<XBreakpointProperties<*>> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createLineBreakpoint[LocalVariableDescriptor]

'lineIndex' @ [370:17] ==> value-parameter lineIndex: Int defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createLineBreakpoint[ValueParameterDescriptorImpl]

'file' @ [371:17] ==> value-parameter file: PsiFile defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createLineBreakpoint[ValueParameterDescriptorImpl]

'virtualFile' @ [371:22] ==> public final val PsiFile.virtualFile: (VirtualFile..VirtualFile?)[MyPropertyDescriptor]

'javaBreakpoint' @ [372:13] ==> val javaBreakpoint: Breakpoint<out JavaBreakpointProperties<*>>? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createLineBreakpoint[LocalVariableDescriptor]

'javaBreakpoint' @ [373:30] ==> val javaBreakpoint: Breakpoint<out JavaBreakpointProperties<*>>? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createLineBreakpoint[LocalVariableDescriptor]

'xBreakpoint' @ [373:45] ==> public final val <P : raw (JavaBreakpointProperties<(JavaBreakpointProperties<*>..JavaBreakpointProperties<*>?)>..JavaBreakpointProperties<out (JavaBreakpointProperties<*>..JavaBreakpointProperties<*>?)>?)> LineBreakpoint<out raw (JavaBreakpointProperties<(JavaBreakpointProperties<*>..JavaBreakpointProperties<*>?)>..JavaBreakpointProperties<out (JavaBreakpointProperties<*>..JavaBreakpointProperties<*>?)>?)>.xBreakpoint: (XBreakpoint<out (JavaBreakpointProperties<(JavaBreakpointProperties<*>..JavaBreakpointProperties<*>?)>..JavaBreakpointProperties<out (JavaBreakpointProperties<*>..JavaBreakpointProperties<*>?)>?)>..XBreakpoint<out (JavaBreakpointProperties<(JavaBreakpointProperties<*>..JavaBreakpointProperties<*>?)>..JavaBreakpointProperties<out (JavaBreakpointProperties<*>..JavaBreakpointProperties<*>?)>?)>?)[MyPropertyDescriptor]
Inferred types:
    <P : raw (JavaBreakpointProperties<(JavaBreakpointProperties<*>..JavaBreakpointProperties<*>?)>..JavaBreakpointProperties<out (JavaBreakpointProperties<*>..JavaBreakpointProperties<*>?)>?)> -> Captured(*)

'properties' @ [373:57] ==> public final val <P : raw (XBreakpointProperties<(Any..Any?)>..XBreakpointProperties<*>?)> XBreakpoint<out (JavaBreakpointProperties<(JavaBreakpointProperties<*>..JavaBreakpointProperties<*>?)>..JavaBreakpointProperties<out (JavaBreakpointProperties<*>..JavaBreakpointProperties<*>?)>?)>.properties: (JavaBreakpointProperties<(JavaBreakpointProperties<*>..JavaBreakpointProperties<*>?)>..JavaBreakpointProperties<out (JavaBreakpointProperties<*>..JavaBreakpointProperties<*>?)>?)[MyPropertyDescriptor]
Inferred types:
    <P : raw (XBreakpointProperties<(Any..Any?)>..XBreakpointProperties<*>?)> -> Captured(out (org.jetbrains.java.debugger.breakpoints.properties.JavaBreakpointProperties<(org.jetbrains.java.debugger.breakpoints.properties.JavaBreakpointProperties<*>..org.jetbrains.java.debugger.breakpoints.properties.JavaBreakpointProperties<*>?)>..org.jetbrains.java.debugger.breakpoints.properties.JavaBreakpointProperties<out (org.jetbrains.java.debugger.breakpoints.properties.JavaBreakpointProperties<*>..org.jetbrains.java.debugger.breakpoints.properties.JavaBreakpointProperties<*>?)>?))

'lambdaOrdinal' @ [375:17] ==> value-parameter lambdaOrdinal: Int? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createLineBreakpoint[ValueParameterDescriptorImpl]

'if (lambdaOrdinal != -1) {
                    properties.lambdaOrdinal = lambdaOrdinal - 1
                }
                else {
                    properties.lambdaOrdinal = lambdaOrdinal
                }' @ [376:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'lambdaOrdinal' @ [376:21] ==> value-parameter lambdaOrdinal: Int? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createLineBreakpoint[ValueParameterDescriptorImpl]

'-' @ [376:38] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'properties' @ [377:21] ==> val properties: JavaLineBreakpointProperties defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createLineBreakpoint[LocalVariableDescriptor]

'lambdaOrdinal' @ [377:32] ==> public final var JavaLineBreakpointProperties.lambdaOrdinal: (Int..Int?)[MyPropertyDescriptor]

'lambdaOrdinal' @ [377:48] ==> value-parameter lambdaOrdinal: Int? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createLineBreakpoint[ValueParameterDescriptorImpl]

'properties' @ [380:21] ==> val properties: JavaLineBreakpointProperties defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createLineBreakpoint[LocalVariableDescriptor]

'lambdaOrdinal' @ [380:32] ==> public final var JavaLineBreakpointProperties.lambdaOrdinal: (Int..Int?)[MyPropertyDescriptor]

'lambdaOrdinal' @ [380:48] ==> value-parameter lambdaOrdinal: Int? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createLineBreakpoint[ValueParameterDescriptorImpl]

'suffix' @ [382:17] ==> var suffix: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createLineBreakpoint[LocalVariableDescriptor]

'lambdaOrdinal' @ [382:46] ==> value-parameter lambdaOrdinal: Int? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createLineBreakpoint[ValueParameterDescriptorImpl]

'condition' @ [384:17] ==> value-parameter condition: String? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createLineBreakpoint[ValueParameterDescriptorImpl]

'javaBreakpoint' @ [385:17] ==> val javaBreakpoint: Breakpoint<out JavaBreakpointProperties<*>>? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createLineBreakpoint[LocalVariableDescriptor]

'setCondition' @ [385:32] ==> public open fun setCondition(@Nullable p0: TextWithImports?): Unit defined in com.intellij.debugger.ui.breakpoints.Breakpoint[JavaMethodDescriptor]

'TextWithImportsImpl' @ [385:45] ==> public constructor TextWithImportsImpl(p0: (CodeFragmentKind..CodeFragmentKind?), @NotNull p1: String) defined in com.intellij.debugger.engine.evaluation.TextWithImportsImpl[JavaClassConstructorDescriptor]

'EXPRESSION' @ [385:82] ==> enum entry EXPRESSION defined in com.intellij.debugger.engine.evaluation.CodeFragmentKind[FakeCallableDescriptorForObject]

'condition' @ [385:94] ==> value-parameter condition: String? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createLineBreakpoint[ValueParameterDescriptorImpl]

'suffix' @ [386:17] ==> var suffix: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createLineBreakpoint[LocalVariableDescriptor]

'condition' @ [386:42] ==> value-parameter condition: String? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createLineBreakpoint[ValueParameterDescriptorImpl]

'addBreakpoint' @ [389:31] ==> public open fun addBreakpoint(@NotNull p0: raw (Breakpoint<(JavaBreakpointProperties<*>..JavaBreakpointProperties<*>?)>..Breakpoint<out (JavaBreakpointProperties<*>..JavaBreakpointProperties<*>?)>)): Unit defined in com.intellij.debugger.ui.breakpoints.BreakpointManager[JavaMethodDescriptor]

'javaBreakpoint' @ [389:45] ==> val javaBreakpoint: Breakpoint<out JavaBreakpointProperties<*>>? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createLineBreakpoint[LocalVariableDescriptor]

'println' @ [390:13] ==> public open fun println(@NonNls p0: (String..String?), p1: raw (Key<(Any..Any?)>..Key<*>?)): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[JavaMethodDescriptor]

'file' @ [390:50] ==> value-parameter file: PsiFile defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createLineBreakpoint[ValueParameterDescriptorImpl]

'virtualFile' @ [390:55] ==> public final val PsiFile.virtualFile: (VirtualFile..VirtualFile?)[MyPropertyDescriptor]

'name' @ [390:67] ==> public final val VirtualFile.name: String[MyPropertyDescriptor]

'lineIndex' @ [390:75] ==> value-parameter lineIndex: Int defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createLineBreakpoint[ValueParameterDescriptorImpl]

'suffix' @ [390:90] ==> var suffix: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createLineBreakpoint[LocalVariableDescriptor]

'SYSTEM' @ [390:118] ==> public final val SYSTEM: raw (Key<(Any..Any?)>..Key<*>?) defined in com.intellij.execution.process.ProcessOutputTypes[JavaPropertyDescriptor]

'!' @ [400:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'breakpointType' @ [400:14] ==> value-parameter breakpointType: XLineBreakpointType<XBreakpointProperties<*>> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpointOfType[ValueParameterDescriptorImpl]

'canPutAt' @ [400:29] ==> public open fun canPutAt(@NotNull p0: VirtualFile, p1: Int, @NotNull p2: Project): Boolean defined in com.intellij.xdebugger.breakpoints.XLineBreakpointType[JavaMethodDescriptor]

'virtualFile' @ [400:38] ==> value-parameter virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpointOfType[ValueParameterDescriptorImpl]

'lineIndex' @ [400:51] ==> value-parameter lineIndex: Int defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpointOfType[ValueParameterDescriptorImpl]

'myProject' @ [400:62] ==> protected/*protected and package*/ final var myProject: (Project..Project?) defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[JavaPropertyDescriptor]

'runWriteAction' @ [401:27] ==> public fun <T> runWriteAction(action: () -> XLineBreakpoint<(XBreakpointProperties<*>..XBreakpointProperties<*>?)>): XLineBreakpoint<(XBreakpointProperties<*>..XBreakpointProperties<*>?)> defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> XLineBreakpoint<(com.intellij.xdebugger.breakpoints.XBreakpointProperties<*>..com.intellij.xdebugger.breakpoints.XBreakpointProperties<*>?)>

'breakpointManager' @ [402:13] ==> value-parameter breakpointManager: XBreakpointManager defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpointOfType[ValueParameterDescriptorImpl]

'addLineBreakpoint' @ [402:31] ==> @NotNull public abstract fun <T : raw (XBreakpointProperties<(Any..Any?)>..XBreakpointProperties<*>?)> addLineBreakpoint(p0: (XLineBreakpointType<(XBreakpointProperties<*>..XBreakpointProperties<*>?)>..XLineBreakpointType<(XBreakpointProperties<*>..XBreakpointProperties<*>?)>?), @NotNull p1: String, p2: Int, @Nullable p3: XBreakpointProperties<*>?): XLineBreakpoint<(XBreakpointProperties<*>..XBreakpointProperties<*>?)> defined in com.intellij.xdebugger.breakpoints.XBreakpointManager[JavaMethodDescriptor]
Inferred types:
    <T : raw (XBreakpointProperties<(Any..Any?)>..XBreakpointProperties<*>?)> -> (com.intellij.xdebugger.breakpoints.XBreakpointProperties<*>..com.intellij.xdebugger.breakpoints.XBreakpointProperties<*>?)

'breakpointType' @ [403:21] ==> value-parameter breakpointType: XLineBreakpointType<XBreakpointProperties<*>> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpointOfType[ValueParameterDescriptorImpl]

'virtualFile' @ [404:21] ==> value-parameter virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpointOfType[ValueParameterDescriptorImpl]

'url' @ [404:33] ==> public final val VirtualFile.url: String[MyPropertyDescriptor]

'lineIndex' @ [405:21] ==> value-parameter lineIndex: Int defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpointOfType[ValueParameterDescriptorImpl]

'breakpointType' @ [406:21] ==> value-parameter breakpointType: XLineBreakpointType<XBreakpointProperties<*>> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpointOfType[ValueParameterDescriptorImpl]

'createBreakpointProperties' @ [406:36] ==> @Nullable public abstract fun createBreakpointProperties(@NotNull p0: VirtualFile, p1: Int): XBreakpointProperties<*>? defined in com.intellij.xdebugger.breakpoints.XLineBreakpointType[JavaMethodDescriptor]

'virtualFile' @ [406:63] ==> value-parameter virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpointOfType[ValueParameterDescriptorImpl]

'lineIndex' @ [406:76] ==> value-parameter lineIndex: Int defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpointOfType[ValueParameterDescriptorImpl]

'getJavaBreakpoint' @ [409:34] ==> @Nullable public open fun getJavaBreakpoint(@Nullable p0: raw (XBreakpoint<(XBreakpointProperties<*>..XBreakpointProperties<*>?)>?..XBreakpoint<out (XBreakpointProperties<*>..XBreakpointProperties<*>?)>?)): raw (Breakpoint<(JavaBreakpointProperties<*>..JavaBreakpointProperties<*>?)>?..Breakpoint<out (JavaBreakpointProperties<*>..JavaBreakpointProperties<*>?)>?) defined in com.intellij.debugger.ui.breakpoints.BreakpointManager[JavaMethodDescriptor]

'xBreakpoint' @ [409:52] ==> val xBreakpoint: XLineBreakpoint<(XBreakpointProperties<*>..XBreakpointProperties<*>?)> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpointOfType[LocalVariableDescriptor]

'Suppress' @ [412:5] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'getInstance' @ [414:30] ==> public open fun getInstance(): (XDebuggerUtil..XDebuggerUtil?) defined in com.intellij.xdebugger.XDebuggerUtil[JavaMethodDescriptor]

'findBreakpointType' @ [414:44] ==> public abstract fun <T : raw (XBreakpointType<(XBreakpoint<*>..XBreakpoint<*>?), (XBreakpointProperties<*>..XBreakpointProperties<*>?)>..XBreakpointType<out (XBreakpoint<*>..XBreakpoint<*>?), out (XBreakpointProperties<*>..XBreakpointProperties<*>?)>?)> findBreakpointType(@NotNull p0: Class<(T..T?)>): (T..T?) defined in com.intellij.xdebugger.XDebuggerUtil[JavaMethodDescriptor]
Inferred types:
    <T : raw (XBreakpointType<(XBreakpoint<*>..XBreakpoint<*>?), (XBreakpointProperties<*>..XBreakpointProperties<*>?)>..XBreakpointType<out (XBreakpoint<*>..XBreakpoint<*>?), out (XBreakpointProperties<*>..XBreakpointProperties<*>?)>?)> -> (T..T?)

'javaClass' @ [414:63] ==> value-parameter javaClass: Class<T> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.findBreakpointType[ValueParameterDescriptorImpl]

'findLinesWithPrefixesRemoved' @ [418:49] ==> @NotNull public open fun findLinesWithPrefixesRemoved(p0: (String..String?), vararg p1: (String..String?)): (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'fileText' @ [418:78] ==> value-parameter fileText: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createAdditionalBreakpoints[ValueParameterDescriptorImpl]

'breakpoints' @ [419:28] ==> val breakpoints: (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createAdditionalBreakpoints[LocalVariableDescriptor]

'breakpoint' @ [420:28] ==> val breakpoint: (String..String?) defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createAdditionalBreakpoints[LocalVariableDescriptor]

'split' @ [420:39] ==> public fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = ..., limit: Int = ...): List<String> defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'assert' @ [421:13] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'position' @ [421:20] ==> val position: List<String> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createAdditionalBreakpoints[LocalVariableDescriptor]

'size' @ [421:29] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'breakpoint' @ [421:101] ==> val breakpoint: (String..String?) defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createAdditionalBreakpoints[LocalVariableDescriptor]

'position' @ [422:30] ==> val position: List<String> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createAdditionalBreakpoints[LocalVariableDescriptor]

'lineMarker' @ [424:17] ==> var lineMarker: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createAdditionalBreakpoints[LocalVariableDescriptor]

'contains' @ [424:28] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'lineMarker' @ [424:46] ==> var lineMarker: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createAdditionalBreakpoints[LocalVariableDescriptor]

'endsWith' @ [424:57] ==> public fun String.endsWith(suffix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'lineMarker' @ [425:44] ==> var lineMarker: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createAdditionalBreakpoints[LocalVariableDescriptor]

'split' @ [425:55] ==> public fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = ..., limit: Int = ...): List<String> defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'lineMarker' @ [426:17] ==> var lineMarker: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createAdditionalBreakpoints[LocalVariableDescriptor]

'lineMarkerAndOrdinal' @ [426:30] ==> val lineMarkerAndOrdinal: List<String> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createAdditionalBreakpoints[LocalVariableDescriptor]

'ordinal' @ [427:17] ==> var ordinal: Int? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createAdditionalBreakpoints[LocalVariableDescriptor]

'lineMarkerAndOrdinal' @ [427:27] ==> val lineMarkerAndOrdinal: List<String> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createAdditionalBreakpoints[LocalVariableDescriptor]

'substringBefore' @ [427:51] ==> public fun String.substringBefore(delimiter: String, missingDelimiterValue: String = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'toInt' @ [427:72] ==> @InlineOnly public inline fun String.toInt(): Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'createBreakpoint' @ [429:13] ==> private final fun createBreakpoint(fileName: String, lineMarker: String, ordinal: Int?): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'position' @ [429:30] ==> val position: List<String> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createAdditionalBreakpoints[LocalVariableDescriptor]

'lineMarker' @ [429:43] ==> var lineMarker: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createAdditionalBreakpoints[LocalVariableDescriptor]

'ordinal' @ [429:55] ==> var ordinal: Int? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createAdditionalBreakpoints[LocalVariableDescriptor]

'project' @ [434:23] ==> public final val KotlinDebuggerTestBase.project: (Project..Project?)[MyPropertyDescriptor]

'runReadAction' @ [435:27] ==> public fun <T> runReadAction(action: () -> List<(VirtualFile..VirtualFile?)>): List<(VirtualFile..VirtualFile?)> defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> List<(com.intellij.openapi.vfs.VirtualFile..com.intellij.openapi.vfs.VirtualFile?)>

'getAllFilesByExt' @ [436:27] ==> @NotNull public open fun getAllFilesByExt(@NotNull p0: Project, @NotNull p1: String): (MutableCollection<(VirtualFile..VirtualFile?)>..Collection<(VirtualFile..VirtualFile?)>) defined in com.intellij.psi.search.FilenameIndex[JavaMethodDescriptor]

'project' @ [436:44] ==> val project: Project defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoint[LocalVariableDescriptor]

'filter' @ [436:59] ==> public inline fun <T> Iterable<(VirtualFile..VirtualFile?)>.filter(predicate: ((VirtualFile..VirtualFile?)) -> Boolean): List<(VirtualFile..VirtualFile?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.openapi.vfs.VirtualFile..com.intellij.openapi.vfs.VirtualFile?)

'it' @ [437:17] ==> value-parameter it: (VirtualFile..VirtualFile?) defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoint.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [437:20] ==> public final val VirtualFile.name: String[MyPropertyDescriptor]

'contains' @ [437:25] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'fileName' @ [437:34] ==> value-parameter fileName: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoint[ValueParameterDescriptorImpl]

'it' @ [438:17] ==> value-parameter it: (VirtualFile..VirtualFile?) defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoint.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'contentsToByteArray' @ [438:20] ==> @NotNull public abstract fun contentsToByteArray(): ByteArray defined in com.intellij.openapi.vfs.VirtualFile[JavaMethodDescriptor]

'toString' @ [438:42] ==> @InlineOnly public inline fun ByteArray.toString(charset: Charset): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]

'UTF_8' @ [438:60] ==> @field:JvmField public final val UTF_8: Charset defined in kotlin.text.Charsets[DeserializedPropertyDescriptor]

'contains' @ [438:67] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'lineMarker' @ [438:76] ==> value-parameter lineMarker: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoint[ValueParameterDescriptorImpl]

'assert' @ [442:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'sourceFiles' @ [442:16] ==> val sourceFiles: List<(VirtualFile..VirtualFile?)> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoint[LocalVariableDescriptor]

'size' @ [442:28] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'fileName' @ [442:83] ==> value-parameter fileName: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoint[ValueParameterDescriptorImpl]

'sourceFiles' @ [442:108] ==> val sourceFiles: List<(VirtualFile..VirtualFile?)> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoint[LocalVariableDescriptor]

'Runnable' @ [444:24] ==> @FunctionalInterface public fun Runnable(function: () -> Unit): Runnable defined in java.lang[SamConstructorDescriptorImpl]

'!!' @ [445:33] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: PsiFile?): PsiFile[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> PsiFile

'getInstance' @ [445:44] ==> @NotNull public open fun getInstance(@NotNull p0: Project): PsiManager defined in com.intellij.psi.PsiManager[JavaMethodDescriptor]

'project' @ [445:56] ==> val project: Project defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoint[LocalVariableDescriptor]

'findFile' @ [445:65] ==> @Nullable public abstract fun findFile(@NotNull p0: VirtualFile): PsiFile? defined in com.intellij.psi.PsiManager[JavaMethodDescriptor]

'sourceFiles' @ [445:74] ==> val sourceFiles: List<(VirtualFile..VirtualFile?)> defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoint[LocalVariableDescriptor]

'first' @ [445:86] ==> public fun <T> List<(VirtualFile..VirtualFile?)>.first(): (VirtualFile..VirtualFile?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.openapi.vfs.VirtualFile..com.intellij.openapi.vfs.VirtualFile?)

'getInstance' @ [447:54] ==> public open fun getInstance(@NotNull p0: Project): (XDebuggerManager..XDebuggerManager?) defined in com.intellij.xdebugger.XDebuggerManager[JavaMethodDescriptor]

'myProject' @ [447:66] ==> protected/*protected and package*/ final var myProject: (Project..Project?) defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[JavaPropertyDescriptor]

'breakpointManager' @ [447:77] ==> public final val XDebuggerManager.breakpointManager: XBreakpointManager[MyPropertyDescriptor]

'!!' @ [448:28] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: Document?): Document[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> Document

'getInstance' @ [448:47] ==> public open fun getInstance(@NotNull p0: Project): (PsiDocumentManager..PsiDocumentManager?) defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'project' @ [448:59] ==> val project: Project defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoint[LocalVariableDescriptor]

'getDocument' @ [448:68] ==> @Nullable public abstract fun getDocument(@NotNull p0: PsiFile): Document? defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'psiSourceFile' @ [448:80] ==> val psiSourceFile: PsiFile defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoint.<anonymous>[LocalVariableDescriptor]

'psiSourceFile' @ [450:25] ==> val psiSourceFile: PsiFile defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoint.<anonymous>[LocalVariableDescriptor]

'text' @ [450:39] ==> public final val PsiFile.text: (String..String?)[MyPropertyDescriptor]

'indexOf' @ [450:46] ==> public fun CharSequence.indexOf(string: String, startIndex: Int = ..., ignoreCase: Boolean = ...): Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'lineMarker' @ [450:54] ==> value-parameter lineMarker: String defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoint[ValueParameterDescriptorImpl]

'document' @ [451:30] ==> val document: Document defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoint.<anonymous>[LocalVariableDescriptor]

'getLineNumber' @ [451:39] ==> @Contract public abstract fun getLineNumber(p0: Int): Int defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'index' @ [451:53] ==> val index: Int defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoint.<anonymous>[LocalVariableDescriptor]

'createLineBreakpoint' @ [453:13] ==> private final fun createLineBreakpoint(breakpointManager: XBreakpointManager, file: PsiFile, lineIndex: Int, lambdaOrdinal: Int?, condition: String?): Unit defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase[SimpleFunctionDescriptorImpl]

'breakpointManager' @ [453:34] ==> val breakpointManager: XBreakpointManager defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoint.<anonymous>[LocalVariableDescriptor]

'psiSourceFile' @ [453:53] ==> val psiSourceFile: PsiFile defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoint.<anonymous>[LocalVariableDescriptor]

'lineNumber' @ [453:68] ==> val lineNumber: Int defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoint.<anonymous>[LocalVariableDescriptor]

'ordinal' @ [453:80] ==> value-parameter ordinal: Int? defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoint[ValueParameterDescriptorImpl]

'invokeAndWait' @ [456:32] ==> public open fun invokeAndWait(p0: (Project..Project?), @NotNull p1: Runnable, p2: (ModalityState..ModalityState?)): Unit defined in com.intellij.debugger.DebuggerInvocationUtil[JavaMethodDescriptor]

'project' @ [456:46] ==> val project: Project defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoint[LocalVariableDescriptor]

'runnable' @ [456:55] ==> val runnable: Runnable defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerTestBase.createBreakpoint[LocalVariableDescriptor]

'defaultModalityState' @ [456:79] ==> @NotNull public open fun defaultModalityState(): ModalityState defined in com.intellij.openapi.application.ModalityState[JavaMethodDescriptor]

