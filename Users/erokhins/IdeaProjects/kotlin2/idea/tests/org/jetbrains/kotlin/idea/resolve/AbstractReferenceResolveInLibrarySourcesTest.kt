'KotlinLightCodeInsightFixtureTestCase' @ [27:63] ==> public constructor KotlinLightCodeInsightFixtureTestCase() defined in org.jetbrains.kotlin.idea.test.KotlinLightCodeInsightFixtureTestCase[ClassConstructorDescriptorImpl]

'myFixture' @ [33:23] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest[JavaPropertyDescriptor]

'fixture' @ [35:9] ==> val fixture: JavaCodeInsightTestFixture defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'configureByFile' @ [35:17] ==> public abstract fun configureByFile(@NotNull p0: String): (PsiFile..PsiFile?) defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'path' @ [35:33] ==> value-parameter path: String defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[ValueParameterDescriptorImpl]

'AbstractReferenceResolveTest' @ [37:35] ==> public companion object defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveTest[FakeCallableDescriptorForObject]

'readResolveData' @ [37:64] ==> public final fun readResolveData(fileText: String, index: Int, refMarkerText: String = ...): AbstractReferenceResolveTest.ExpectedResolveData defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveTest.Companion[SimpleFunctionDescriptorImpl]

'fixture' @ [37:80] ==> val fixture: JavaCodeInsightTestFixture defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'file' @ [37:88] ==> public final val JavaCodeInsightTestFixture.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'text' @ [37:95] ==> public final val PsiFile.text: (String..String?)[MyPropertyDescriptor]

'!!' @ [39:24] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: GotoTargetHandler.GotoData?): GotoTargetHandler.GotoData[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> GotoData

'invokeGotoImplementations' @ [39:44] ==> public open fun invokeGotoImplementations(editor: (Editor..Editor?), psiFile: (PsiFile..PsiFile?)): (GotoTargetHandler.GotoData..GotoTargetHandler.GotoData?) defined in org.jetbrains.kotlin.idea.navigation.NavigationTestUtils[JavaMethodDescriptor]

'fixture' @ [39:70] ==> val fixture: JavaCodeInsightTestFixture defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'editor' @ [39:78] ==> public final val JavaCodeInsightTestFixture.editor: (Editor..Editor?)[MyPropertyDescriptor]

'fixture' @ [39:86] ==> val fixture: JavaCodeInsightTestFixture defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'file' @ [39:94] ==> public final val JavaCodeInsightTestFixture.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'assertEquals' @ [40:16] ==> public open fun assertEquals(p0: (String..String?), p1: (Any..Any?), p2: (Any..Any?)): Unit defined in org.junit.Assert[JavaMethodDescriptor]

'gotoData' @ [40:76] ==> val gotoData: GotoTargetHandler.GotoData defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'targets' @ [40:85] ==> public final var targets: (Array<(PsiElement..PsiElement?)>..Array<out (PsiElement..PsiElement?)>?) defined in com.intellij.codeInsight.navigation.GotoTargetHandler.GotoData[JavaPropertyDescriptor]

'size' @ [40:93] ==> public final val size: Int defined in kotlin.Array[DeserializedPropertyDescriptor]

'gotoData' @ [42:32] ==> val gotoData: GotoTargetHandler.GotoData defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'targets' @ [42:41] ==> public final var targets: (Array<(PsiElement..PsiElement?)>..Array<out (PsiElement..PsiElement?)>?) defined in com.intellij.codeInsight.navigation.GotoTargetHandler.GotoData[JavaPropertyDescriptor]

'navigationElement' @ [42:52] ==> public final val PsiElement.navigationElement: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'testedPsiElement' @ [43:33] ==> val testedPsiElement: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'containingFile' @ [43:50] ==> public final val PsiElement.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'findStringWithPrefixes' @ [45:49] ==> @Nullable public open fun findStringWithPrefixes(p0: (String..String?), vararg p1: (String..String?)): String? defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'fixture' @ [45:72] ==> val fixture: JavaCodeInsightTestFixture defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'file' @ [45:80] ==> public final val JavaCodeInsightTestFixture.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'text' @ [45:87] ==> public final val PsiFile.text: (String..String?)[MyPropertyDescriptor]

'lineContext' @ [46:13] ==> val lineContext: String? defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'AssertionFailedError' @ [47:19] ==> public constructor AssertionFailedError(p0: (String..String?)) defined in junit.framework.AssertionFailedError[JavaClassConstructorDescriptor]

'testedElementFile' @ [47:113] ==> val testedElementFile: PsiFile defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'name' @ [47:131] ==> public final var PsiFile.name: String[MyPropertyDescriptor]

'lineContext' @ [50:31] ==> val lineContext: String? defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'indexOf' @ [50:43] ==> public fun CharSequence.indexOf(string: String, startIndex: Int = ..., ignoreCase: Boolean = ...): Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'REF_CARET_MARKER' @ [50:51] ==> private final val REF_CARET_MARKER: String defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.Companion[PropertyDescriptorImpl]

'inContextOffset' @ [51:13] ==> val inContextOffset: Int defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'-' @ [51:32] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'IllegalStateException' @ [51:42] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'REF_CARET_MARKER' @ [51:70] ==> private final val REF_CARET_MARKER: String defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.Companion[PropertyDescriptorImpl]

'lineContext' @ [51:115] ==> val lineContext: String? defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'lineContext' @ [53:26] ==> val lineContext: String? defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'replace' @ [53:38] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'REF_CARET_MARKER' @ [53:46] ==> private final val REF_CARET_MARKER: String defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.Companion[PropertyDescriptorImpl]

'testedElementFile' @ [54:28] ==> val testedElementFile: PsiFile defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'text' @ [54:46] ==> public final val PsiFile.text: (String..String?)[MyPropertyDescriptor]

'indexOf' @ [54:53] ==> public fun CharSequence.indexOf(string: String, startIndex: Int = ..., ignoreCase: Boolean = ...): Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'contextStr' @ [54:61] ==> val contextStr: String defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'offsetInFile' @ [55:13] ==> val offsetInFile: Int defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'-' @ [55:29] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'IllegalStateException' @ [55:39] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'contextStr' @ [55:72] ==> val contextStr: String defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'testedElementFile' @ [55:107] ==> val testedElementFile: PsiFile defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'name' @ [55:125] ==> public final var PsiFile.name: String[MyPropertyDescriptor]

'offsetInFile' @ [57:22] ==> val offsetInFile: Int defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'inContextOffset' @ [57:37] ==> val inContextOffset: Int defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'testedElementFile' @ [59:25] ==> val testedElementFile: PsiFile defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'findReferenceAt' @ [59:43] ==> @Nullable @Contract public abstract fun findReferenceAt(p0: Int): PsiReference? defined in com.intellij.psi.PsiFile[JavaMethodDescriptor]

'offset' @ [59:59] ==> val offset: Int defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'AbstractReferenceResolveTest' @ [61:9] ==> public companion object defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveTest[FakeCallableDescriptorForObject]

'checkReferenceResolve' @ [61:38] ==> public final fun checkReferenceResolve(expectedResolveData: AbstractReferenceResolveTest.ExpectedResolveData, offset: Int, psiReference: PsiReference?, checkResolvedTo: (PsiElement) -> Unit = ...): Unit defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveTest.Companion[SimpleFunctionDescriptorImpl]

'expectedResolveData' @ [61:60] ==> val expectedResolveData: AbstractReferenceResolveTest.ExpectedResolveData defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'offset' @ [61:81] ==> val offset: Int defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'reference' @ [61:89] ==> val reference: PsiReference defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest.doTest[LocalVariableDescriptor]

'File' @ [64:47] ==> public constructor File(p0: (String..String?), p1: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'getTestDataPathBase' @ [64:71] ==> @NotNull public open fun getTestDataPathBase(): String defined in org.jetbrains.kotlin.idea.test.PluginTestCaseBase[JavaMethodDescriptor]

'path' @ [64:121] ==> public final val File.path: (String..String?)[MyPropertyDescriptor]

'separator' @ [64:133] ==> public const final val separator: (String..String?) defined in java.io.File[JavaPropertyDescriptor]

'getTestName' @ [65:39] ==> @NotNull protected/*protected and package*/ open fun getTestName(p0: Boolean): String defined in org.jetbrains.kotlin.idea.resolve.AbstractReferenceResolveInLibrarySourcesTest[JavaMethodDescriptor]

