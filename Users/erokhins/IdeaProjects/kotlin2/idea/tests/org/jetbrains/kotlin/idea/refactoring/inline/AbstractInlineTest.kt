'KotlinLightCodeInsightFixtureTestCase' @ [37:37] ==> public constructor KotlinLightCodeInsightFixtureTestCase() defined in org.jetbrains.kotlin.idea.test.KotlinLightCodeInsightFixtureTestCase[ClassConstructorDescriptorImpl]

'myFixture' @ [39:17] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest[JavaPropertyDescriptor]

'File' @ [42:24] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'path' @ [42:29] ==> value-parameter path: String defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[ValueParameterDescriptorImpl]

'File' @ [43:25] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'path' @ [43:30] ==> value-parameter path: String defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[ValueParameterDescriptorImpl]

'mainFile' @ [45:28] ==> val mainFile: File defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'name' @ [45:37] ==> public final val File.name: (String..String?)[MyPropertyDescriptor]

'getNameWithoutExtension' @ [46:41] ==> @NotNull public open fun getNameWithoutExtension(@NotNull p0: String): String defined in com.intellij.openapi.util.io.FileUtil[JavaMethodDescriptor]

'mainFileName' @ [46:65] ==> val mainFileName: (String..String?) defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'mainFile' @ [47:26] ==> val mainFile: File defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'parentFile' @ [47:35] ==> public final val File.parentFile: (File..File?)[MyPropertyDescriptor]

'listFiles' @ [47:46] ==> public final fun listFiles(p0: (((File..File?), (String..String?)) -> Boolean..(((File..File?), (String..String?)) -> Boolean)?)): (Array<(File..File?)>..Array<out (File..File?)>?) defined in java.io.File[MyFunctionDescriptor]

'name' @ [48:13] ==> value-parameter name: (String..String?) defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest.<anonymous>[ValueParameterDescriptorImpl]

'mainFileName' @ [48:21] ==> val mainFileName: (String..String?) defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'name' @ [48:37] ==> value-parameter name: (String..String?) defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest.<anonymous>[ValueParameterDescriptorImpl]

'startsWith' @ [48:42] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'mainFileBaseName' @ [48:55] ==> val mainFileBaseName: String defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'name' @ [48:79] ==> value-parameter name: (String..String?) defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest.<anonymous>[ValueParameterDescriptorImpl]

'endsWith' @ [48:84] ==> public fun String.endsWith(suffix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'name' @ [48:103] ==> value-parameter name: (String..String?) defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest.<anonymous>[ValueParameterDescriptorImpl]

'endsWith' @ [48:108] ==> public fun String.endsWith(suffix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'extraFiles' @ [50:31] ==> val extraFiles: (Array<(File..File?)>..Array<out (File..File?)>?) defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'associateBy' @ [50:42] ==> public inline fun <T, K> Array<out (File..File?)>.associateBy(keySelector: ((File..File?)) -> (PsiFile..PsiFile?)): Map<(PsiFile..PsiFile?), (File..File?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (java.io.File..java.io.File?)
    <K> -> (com.intellij.psi.PsiFile..com.intellij.psi.PsiFile?)

'fixture' @ [50:56] ==> public final val fixture: JavaCodeInsightTestFixture defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest[PropertyDescriptorImpl]

'configureByFile' @ [50:64] ==> public abstract fun configureByFile(@NotNull p0: String): (PsiFile..PsiFile?) defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'path' @ [50:80] ==> value-parameter path: String defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[ValueParameterDescriptorImpl]

'replace' @ [50:85] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'mainFileName' @ [50:93] ==> val mainFileName: (String..String?) defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'it' @ [50:107] ==> value-parameter it: (File..File?) defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [50:110] ==> public final val File.name: (String..String?)[MyPropertyDescriptor]

'myFixture' @ [51:20] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest[JavaPropertyDescriptor]

'configureByFile' @ [51:30] ==> public abstract fun configureByFile(@NotNull p0: String): (PsiFile..PsiFile?) defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'path' @ [51:46] ==> value-parameter path: String defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[ValueParameterDescriptorImpl]

'afterFile' @ [53:31] ==> val afterFile: File defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'exists' @ [53:41] ==> public open fun exists(): Boolean defined in java.io.File[JavaMethodDescriptor]

'!!' @ [55:29] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: PsiElement?): PsiElement[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> PsiElement

'findTargetElement' @ [55:47] ==> @Nullable public open fun findTargetElement(p0: (Editor..Editor?), p1: Int): PsiElement? defined in com.intellij.codeInsight.TargetElementUtil[JavaMethodDescriptor]

'myFixture' @ [55:65] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest[JavaPropertyDescriptor]

'editor' @ [55:75] ==> public final val JavaCodeInsightTestFixture.editor: (Editor..Editor?)[MyPropertyDescriptor]

'ELEMENT_NAME_ACCEPTED' @ [55:83] ==> public const final val ELEMENT_NAME_ACCEPTED: Int defined in com.intellij.codeInsight.TargetElementUtil[JavaPropertyDescriptor]

'REFERENCED_ELEMENT_ACCEPTED' @ [55:108] ==> public const final val REFERENCED_ELEMENT_ACCEPTED: Int defined in com.intellij.codeInsight.TargetElementUtil[JavaPropertyDescriptor]

'getExtensions' @ [56:34] ==> @NotNull public open fun <T : (Any..Any?)> getExtensions(@NotNull p0: ExtensionPointName<(InlineActionHandler..InlineActionHandler?)>): (Array<(InlineActionHandler..InlineActionHandler?)>..Array<out (InlineActionHandler..InlineActionHandler?)>) defined in com.intellij.openapi.extensions.Extensions[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> InlineActionHandler

'EP_NAME' @ [56:68] ==> public final val EP_NAME: (ExtensionPointName<(InlineActionHandler..InlineActionHandler?)>..ExtensionPointName<(InlineActionHandler..InlineActionHandler?)>?) defined in com.intellij.lang.refactoring.InlineActionHandler[JavaPropertyDescriptor]

'firstOrNull' @ [56:77] ==> public inline fun <T> Array<out (InlineActionHandler..InlineActionHandler?)>.firstOrNull(predicate: ((InlineActionHandler..InlineActionHandler?)) -> Boolean): InlineActionHandler? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.lang.refactoring.InlineActionHandler..com.intellij.lang.refactoring.InlineActionHandler?)

'it' @ [56:91] ==> value-parameter it: (InlineActionHandler..InlineActionHandler?) defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest.<anonymous>[ValueParameterDescriptorImpl]

'canInlineElement' @ [56:94] ==> public abstract fun canInlineElement(p0: (PsiElement..PsiElement?)): Boolean defined in com.intellij.lang.refactoring.InlineActionHandler[JavaMethodDescriptor]

'targetElement' @ [56:111] ==> val targetElement: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'findLinesWithPrefixesRemoved' @ [57:52] ==> @NotNull public open fun findLinesWithPrefixesRemoved(p0: (String..String?), vararg p1: (String..String?)): (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'myFixture' @ [57:81] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest[JavaPropertyDescriptor]

'file' @ [57:91] ==> public final val JavaCodeInsightTestFixture.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'text' @ [57:96] ==> public final val PsiFile.text: (String..String?)[MyPropertyDescriptor]

'if (handler != null) {
            try {
                runWriteAction { handler.inlineElement(myFixture.project, myFixture.editor, targetElement) }

                UsefulTestCase.assertEmpty(expectedErrors)
                KotlinTestUtils.assertEqualsToFile(afterFile, file.text)
                for ((extraPsiFile, extraFile) in extraFilesToPsi) {
                    KotlinTestUtils.assertEqualsToFile(File("${extraFile.path}.after"), extraPsiFile.text)
                }
            }
            catch (e: CommonRefactoringUtil.RefactoringErrorHintException) {
                TestCase.assertFalse("Refactoring not available: ${e.message}", afterFileExists)
                TestCase.assertEquals("Expected errors", 1, expectedErrors.size)
                TestCase.assertEquals("Error message", expectedErrors[0].replace("\\n", "\n"), e.message)
            }
            catch (e: BaseRefactoringProcessor.ConflictsInTestsException) {
                TestCase.assertFalse("Conflicts: ${e.message}", afterFileExists)
                TestCase.assertEquals("Expected errors", 1, expectedErrors.size)
                TestCase.assertEquals("Error message", expectedErrors[0].replace("\\n", "\n"), e.message)
            }
        }
        else {
            TestCase.assertFalse("No refactoring handler available", afterFileExists)
        }' @ [58:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'handler' @ [58:13] ==> val handler: InlineActionHandler? defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'runWriteAction' @ [60:17] ==> public fun <T> runWriteAction(action: () -> Unit): Unit defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Unit

'handler' @ [60:34] ==> val handler: InlineActionHandler? defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'inlineElement' @ [60:42] ==> public abstract fun inlineElement(p0: (Project..Project?), p1: (Editor..Editor?), p2: (PsiElement..PsiElement?)): Unit defined in com.intellij.lang.refactoring.InlineActionHandler[JavaMethodDescriptor]

'myFixture' @ [60:56] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest[JavaPropertyDescriptor]

'project' @ [60:66] ==> public final val JavaCodeInsightTestFixture.project: (Project..Project?)[MyPropertyDescriptor]

'myFixture' @ [60:75] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest[JavaPropertyDescriptor]

'editor' @ [60:85] ==> public final val JavaCodeInsightTestFixture.editor: (Editor..Editor?)[MyPropertyDescriptor]

'targetElement' @ [60:93] ==> val targetElement: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'assertEmpty' @ [62:32] ==> public open fun assertEmpty(@NotNull p0: (MutableCollection<*>..Collection<*>)): Unit defined in com.intellij.testFramework.UsefulTestCase[JavaMethodDescriptor]

'expectedErrors' @ [62:44] ==> val expectedErrors: (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'assertEqualsToFile' @ [63:33] ==> public open fun assertEqualsToFile(@NotNull p0: File, @NotNull p1: String): Unit defined in org.jetbrains.kotlin.test.KotlinTestUtils[JavaMethodDescriptor]

'afterFile' @ [63:52] ==> val afterFile: File defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'file' @ [63:63] ==> val file: (PsiFile..PsiFile?) defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'text' @ [63:68] ==> public final val PsiFile.text: (String..String?)[MyPropertyDescriptor]

'component1' @ [64:23] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(PsiFile..PsiFile?), (File..File?)>.component1(): (PsiFile..PsiFile?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (com.intellij.psi.PsiFile..com.intellij.psi.PsiFile?)
    <V> -> (java.io.File..java.io.File?)

'component2' @ [64:37] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(PsiFile..PsiFile?), (File..File?)>.component2(): (File..File?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (com.intellij.psi.PsiFile..com.intellij.psi.PsiFile?)
    <V> -> (java.io.File..java.io.File?)

'extraFilesToPsi' @ [64:51] ==> val extraFilesToPsi: Map<(PsiFile..PsiFile?), (File..File?)> defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'assertEqualsToFile' @ [65:37] ==> public open fun assertEqualsToFile(@NotNull p0: File, @NotNull p1: String): Unit defined in org.jetbrains.kotlin.test.KotlinTestUtils[JavaMethodDescriptor]

'File' @ [65:56] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'extraFile' @ [65:64] ==> val extraFile: (File..File?) defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'path' @ [65:74] ==> public final val File.path: (String..String?)[MyPropertyDescriptor]

'extraPsiFile' @ [65:89] ==> val extraPsiFile: (PsiFile..PsiFile?) defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'text' @ [65:102] ==> public final val PsiFile.text: (String..String?)[MyPropertyDescriptor]

'assertFalse' @ [69:26] ==> public open fun assertFalse(p0: (String..String?), p1: Boolean): Unit defined in junit.framework.TestCase[JavaMethodDescriptor]

'e' @ [69:68] ==> val e: CommonRefactoringUtil.RefactoringErrorHintException defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'message' @ [69:70] ==> public open val message: String? defined in com.intellij.refactoring.util.CommonRefactoringUtil.RefactoringErrorHintException[DeserializedPropertyDescriptor]

'afterFileExists' @ [69:81] ==> val afterFileExists: Boolean defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'assertEquals' @ [70:26] ==> public open fun assertEquals(p0: (String..String?), p1: Int, p2: Int): Unit defined in junit.framework.TestCase[JavaMethodDescriptor]

'expectedErrors' @ [70:61] ==> val expectedErrors: (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'size' @ [70:76] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'assertEquals' @ [71:26] ==> public open fun assertEquals(p0: (String..String?), p1: (String..String?), p2: (String..String?)): Unit defined in junit.framework.TestCase[JavaMethodDescriptor]

'expectedErrors' @ [71:56] ==> val expectedErrors: (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'replace' @ [71:74] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'e' @ [71:96] ==> val e: CommonRefactoringUtil.RefactoringErrorHintException defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'message' @ [71:98] ==> public open val message: String? defined in com.intellij.refactoring.util.CommonRefactoringUtil.RefactoringErrorHintException[DeserializedPropertyDescriptor]

'assertFalse' @ [74:26] ==> public open fun assertFalse(p0: (String..String?), p1: Boolean): Unit defined in junit.framework.TestCase[JavaMethodDescriptor]

'e' @ [74:52] ==> val e: BaseRefactoringProcessor.ConflictsInTestsException defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'message' @ [74:54] ==> public open val message: String? defined in com.intellij.refactoring.BaseRefactoringProcessor.ConflictsInTestsException[JavaPropertyDescriptor]

'afterFileExists' @ [74:65] ==> val afterFileExists: Boolean defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'assertEquals' @ [75:26] ==> public open fun assertEquals(p0: (String..String?), p1: Int, p2: Int): Unit defined in junit.framework.TestCase[JavaMethodDescriptor]

'expectedErrors' @ [75:61] ==> val expectedErrors: (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'size' @ [75:76] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'assertEquals' @ [76:26] ==> public open fun assertEquals(p0: (String..String?), p1: (String..String?), p2: (String..String?)): Unit defined in junit.framework.TestCase[JavaMethodDescriptor]

'expectedErrors' @ [76:56] ==> val expectedErrors: (MutableList<(String..String?)>..List<(String..String?)>) defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'replace' @ [76:74] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'e' @ [76:96] ==> val e: BaseRefactoringProcessor.ConflictsInTestsException defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'message' @ [76:98] ==> public open val message: String? defined in com.intellij.refactoring.BaseRefactoringProcessor.ConflictsInTestsException[JavaPropertyDescriptor]

'assertFalse' @ [80:22] ==> public open fun assertFalse(p0: (String..String?), p1: Boolean): Unit defined in junit.framework.TestCase[JavaMethodDescriptor]

'afterFileExists' @ [80:70] ==> val afterFileExists: Boolean defined in org.jetbrains.kotlin.idea.refactoring.inline.AbstractInlineTest.doTest[LocalVariableDescriptor]

'INSTANCE' @ [84:89] ==> @NotNull public final val INSTANCE: KotlinWithJdkAndRuntimeLightProjectDescriptor defined in org.jetbrains.kotlin.idea.test.KotlinWithJdkAndRuntimeLightProjectDescriptor[JavaPropertyDescriptor]

