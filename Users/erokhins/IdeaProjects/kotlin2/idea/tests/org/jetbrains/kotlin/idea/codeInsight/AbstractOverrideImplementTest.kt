'KotlinLightCodeInsightFixtureTestCase' @ [50:48] ==> public constructor KotlinLightCodeInsightFixtureTestCase() defined in org.jetbrains.kotlin.idea.test.KotlinLightCodeInsightFixtureTestCase[ClassConstructorDescriptorImpl]

'INSTANCE' @ [51:113] ==> @NotNull public final val INSTANCE: KotlinWithJdkAndRuntimeLightProjectDescriptor defined in org.jetbrains.kotlin.idea.test.KotlinWithJdkAndRuntimeLightProjectDescriptor[JavaPropertyDescriptor]

'doFileTest' @ [54:9] ==> private final fun doFileTest(handler: OverrideImplementMembersHandler, memberToOverride: String? = ...): Unit defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[SimpleFunctionDescriptorImpl]

'ImplementMembersHandler' @ [54:20] ==> public constructor ImplementMembersHandler() defined in org.jetbrains.kotlin.idea.core.overrideImplement.ImplementMembersHandler[DeserializedClassConstructorDescriptor]

'memberToOverride' @ [54:47] ==> value-parameter memberToOverride: String? = ... defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doImplementFileTest[ValueParameterDescriptorImpl]

'doFileTest' @ [58:9] ==> private final fun doFileTest(handler: OverrideImplementMembersHandler, memberToOverride: String? = ...): Unit defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[SimpleFunctionDescriptorImpl]

'OverrideMembersHandler' @ [58:20] ==> public constructor OverrideMembersHandler(preferConstructorParameters: Boolean = ...) defined in org.jetbrains.kotlin.idea.core.overrideImplement.OverrideMembersHandler[DeserializedClassConstructorDescriptor]

'memberToOverride' @ [58:46] ==> value-parameter memberToOverride: String? = ... defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doOverrideFileTest[ValueParameterDescriptorImpl]

'doMultiFileTest' @ [62:9] ==> private final fun doMultiFileTest(handler: OverrideImplementMembersHandler): Unit defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[SimpleFunctionDescriptorImpl]

'ImplementMembersHandler' @ [62:25] ==> public constructor ImplementMembersHandler() defined in org.jetbrains.kotlin.idea.core.overrideImplement.ImplementMembersHandler[DeserializedClassConstructorDescriptor]

'doMultiFileTest' @ [66:9] ==> private final fun doMultiFileTest(handler: OverrideImplementMembersHandler): Unit defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[SimpleFunctionDescriptorImpl]

'OverrideMembersHandler' @ [66:25] ==> public constructor OverrideMembersHandler(preferConstructorParameters: Boolean = ...) defined in org.jetbrains.kotlin.idea.core.overrideImplement.OverrideMembersHandler[DeserializedClassConstructorDescriptor]

'doDirectoryTest' @ [70:9] ==> private final fun doDirectoryTest(handler: OverrideImplementMembersHandler, memberToOverride: String? = ...): Unit defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[SimpleFunctionDescriptorImpl]

'ImplementMembersHandler' @ [70:25] ==> public constructor ImplementMembersHandler() defined in org.jetbrains.kotlin.idea.core.overrideImplement.ImplementMembersHandler[DeserializedClassConstructorDescriptor]

'memberToOverride' @ [70:52] ==> value-parameter memberToOverride: String? = ... defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doImplementDirectoryTest[ValueParameterDescriptorImpl]

'doDirectoryTest' @ [74:9] ==> private final fun doDirectoryTest(handler: OverrideImplementMembersHandler, memberToOverride: String? = ...): Unit defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[SimpleFunctionDescriptorImpl]

'OverrideMembersHandler' @ [74:25] ==> public constructor OverrideMembersHandler(preferConstructorParameters: Boolean = ...) defined in org.jetbrains.kotlin.idea.core.overrideImplement.OverrideMembersHandler[DeserializedClassConstructorDescriptor]

'memberToImplement' @ [74:51] ==> value-parameter memberToImplement: String? = ... defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doOverrideDirectoryTest[ValueParameterDescriptorImpl]

'doMultiDirectoryTest' @ [78:9] ==> private final fun doMultiDirectoryTest(handler: OverrideImplementMembersHandler): Unit defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[SimpleFunctionDescriptorImpl]

'OverrideMembersHandler' @ [78:30] ==> public constructor OverrideMembersHandler(preferConstructorParameters: Boolean = ...) defined in org.jetbrains.kotlin.idea.core.overrideImplement.OverrideMembersHandler[DeserializedClassConstructorDescriptor]

'myFixture' @ [82:9] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'copyDirectoryToProject' @ [82:19] ==> @NotNull public abstract fun copyDirectoryToProject(@NotNull p0: String, @NotNull p1: String): VirtualFile defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'getTestName' @ [82:42] ==> @NotNull protected/*protected and package*/ open fun getTestName(p0: Boolean): String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaMethodDescriptor]

'myFixture' @ [83:9] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'configureFromTempProjectFile' @ [83:19] ==> public abstract fun configureFromTempProjectFile(@NotNull p0: String): (PsiFile..PsiFile?) defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'myFixture' @ [85:23] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'project' @ [85:33] ==> public final val JavaCodeInsightTestFixture.project: (Project..Project?)[MyPropertyDescriptor]

'?:' @ [87:22] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: PsiClass?, right: PsiClass): PsiClass[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> PsiClass

'getInstance' @ [87:36] ==> public open fun getInstance(p0: (Project..Project?)): (JavaPsiFacade..JavaPsiFacade?) defined in com.intellij.psi.JavaPsiFacade[JavaMethodDescriptor]

'project' @ [87:48] ==> val project: (Project..Project?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doImplementJavaDirectoryTest[LocalVariableDescriptor]

'findClass' @ [87:57] ==> @Nullable public abstract fun findClass(@NonNls @NotNull p0: String, @NotNull p1: GlobalSearchScope): PsiClass? defined in com.intellij.psi.JavaPsiFacade[JavaMethodDescriptor]

'className' @ [87:67] ==> value-parameter className: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doImplementJavaDirectoryTest[ValueParameterDescriptorImpl]

'allScope' @ [87:96] ==> @NotNull public open fun allScope(@NotNull p0: Project): GlobalSearchScope defined in com.intellij.psi.search.GlobalSearchScope[JavaMethodDescriptor]

'project' @ [87:105] ==> val project: (Project..Project?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doImplementJavaDirectoryTest[LocalVariableDescriptor]

'error' @ [88:25] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'className' @ [88:51] ==> value-parameter className: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doImplementJavaDirectoryTest[ValueParameterDescriptorImpl]

'aClass' @ [90:22] ==> val aClass: PsiClass defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doImplementJavaDirectoryTest[LocalVariableDescriptor]

'findMethodsByName' @ [90:29] ==> @NotNull public abstract fun findMethodsByName(@NonNls p0: (String..String?), p1: Boolean): (Array<(PsiMethod..PsiMethod?)>..Array<out (PsiMethod..PsiMethod?)>) defined in com.intellij.psi.PsiClass[JavaMethodDescriptor]

'methodName' @ [90:47] ==> value-parameter methodName: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doImplementJavaDirectoryTest[ValueParameterDescriptorImpl]

'error' @ [91:25] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'methodName' @ [91:52] ==> value-parameter methodName: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doImplementJavaDirectoryTest[ValueParameterDescriptorImpl]

'className' @ [91:74] ==> value-parameter className: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doImplementJavaDirectoryTest[ValueParameterDescriptorImpl]

'generateImplementation' @ [93:9] ==> private final fun generateImplementation(method: PsiMethod): Unit defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[SimpleFunctionDescriptorImpl]

'method' @ [93:32] ==> val method: PsiMethod defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doImplementJavaDirectoryTest[LocalVariableDescriptor]

'myFixture' @ [95:9] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'checkResultByFile' @ [95:19] ==> public abstract fun checkResultByFile(@NotNull p0: String): Unit defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'getTestName' @ [95:37] ==> @NotNull protected/*protected and package*/ open fun getTestName(p0: Boolean): String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaMethodDescriptor]

'myFixture' @ [99:9] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'configureByFile' @ [99:19] ==> public abstract fun configureByFile(@NotNull p0: String): (PsiFile..PsiFile?) defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'getTestName' @ [99:35] ==> @NotNull protected/*protected and package*/ open fun getTestName(p0: Boolean): String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaMethodDescriptor]

'doOverrideImplement' @ [100:9] ==> private final fun doOverrideImplement(handler: OverrideImplementMembersHandler, memberToOverride: String?): Unit defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[SimpleFunctionDescriptorImpl]

'handler' @ [100:29] ==> value-parameter handler: OverrideImplementMembersHandler defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doFileTest[ValueParameterDescriptorImpl]

'memberToOverride' @ [100:38] ==> value-parameter memberToOverride: String? = ... defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doFileTest[ValueParameterDescriptorImpl]

'checkResultByFile' @ [101:9] ==> private final fun checkResultByFile(fileName: String): Unit defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[SimpleFunctionDescriptorImpl]

'getTestName' @ [101:27] ==> @NotNull protected/*protected and package*/ open fun getTestName(p0: Boolean): String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaMethodDescriptor]

'myFixture' @ [105:9] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'configureByFile' @ [105:19] ==> public abstract fun configureByFile(@NotNull p0: String): (PsiFile..PsiFile?) defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'getTestName' @ [105:35] ==> @NotNull protected/*protected and package*/ open fun getTestName(p0: Boolean): String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaMethodDescriptor]

'doMultiOverrideImplement' @ [106:9] ==> private final fun doMultiOverrideImplement(handler: OverrideImplementMembersHandler): Unit defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[SimpleFunctionDescriptorImpl]

'handler' @ [106:34] ==> value-parameter handler: OverrideImplementMembersHandler defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doMultiFileTest[ValueParameterDescriptorImpl]

'checkResultByFile' @ [107:9] ==> private final fun checkResultByFile(fileName: String): Unit defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[SimpleFunctionDescriptorImpl]

'getTestName' @ [107:27] ==> @NotNull protected/*protected and package*/ open fun getTestName(p0: Boolean): String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaMethodDescriptor]

'myFixture' @ [111:9] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'copyDirectoryToProject' @ [111:19] ==> @NotNull public abstract fun copyDirectoryToProject(@NotNull p0: String, @NotNull p1: String): VirtualFile defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'getTestName' @ [111:42] ==> @NotNull protected/*protected and package*/ open fun getTestName(p0: Boolean): String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaMethodDescriptor]

'myFixture' @ [112:9] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'configureFromTempProjectFile' @ [112:19] ==> public abstract fun configureFromTempProjectFile(@NotNull p0: String): (PsiFile..PsiFile?) defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'doOverrideImplement' @ [113:9] ==> private final fun doOverrideImplement(handler: OverrideImplementMembersHandler, memberToOverride: String?): Unit defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[SimpleFunctionDescriptorImpl]

'handler' @ [113:29] ==> value-parameter handler: OverrideImplementMembersHandler defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doDirectoryTest[ValueParameterDescriptorImpl]

'memberToOverride' @ [113:38] ==> value-parameter memberToOverride: String? = ... defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doDirectoryTest[ValueParameterDescriptorImpl]

'checkResultByFile' @ [114:9] ==> private final fun checkResultByFile(fileName: String): Unit defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[SimpleFunctionDescriptorImpl]

'getTestName' @ [114:27] ==> @NotNull protected/*protected and package*/ open fun getTestName(p0: Boolean): String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaMethodDescriptor]

'myFixture' @ [118:9] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'copyDirectoryToProject' @ [118:19] ==> @NotNull public abstract fun copyDirectoryToProject(@NotNull p0: String, @NotNull p1: String): VirtualFile defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'getTestName' @ [118:42] ==> @NotNull protected/*protected and package*/ open fun getTestName(p0: Boolean): String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaMethodDescriptor]

'myFixture' @ [119:9] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'configureFromTempProjectFile' @ [119:19] ==> public abstract fun configureFromTempProjectFile(@NotNull p0: String): (PsiFile..PsiFile?) defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'doMultiOverrideImplement' @ [120:9] ==> private final fun doMultiOverrideImplement(handler: OverrideImplementMembersHandler): Unit defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[SimpleFunctionDescriptorImpl]

'handler' @ [120:34] ==> value-parameter handler: OverrideImplementMembersHandler defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doMultiDirectoryTest[ValueParameterDescriptorImpl]

'checkResultByFile' @ [121:9] ==> private final fun checkResultByFile(fileName: String): Unit defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[SimpleFunctionDescriptorImpl]

'getTestName' @ [121:27] ==> @NotNull protected/*protected and package*/ open fun getTestName(p0: Boolean): String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaMethodDescriptor]

'myFixture' @ [125:30] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'file' @ [125:40] ==> public final val JavaCodeInsightTestFixture.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'findElementAt' @ [125:45] ==> @Nullable @Contract public abstract fun findElementAt(p0: Int): PsiElement? defined in com.intellij.psi.PsiFile[JavaMethodDescriptor]

'myFixture' @ [125:59] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'editor' @ [125:69] ==> public final val JavaCodeInsightTestFixture.editor: (Editor..Editor?)[MyPropertyDescriptor]

'caretModel' @ [125:76] ==> public final val Editor.caretModel: CaretModel[MyPropertyDescriptor]

'offset' @ [125:87] ==> public final val CaretModel.offset: Int[MyPropertyDescriptor]

'?:' @ [126:29] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtClassOrObject?, right: KtClassOrObject): KtClassOrObject[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtClassOrObject

'getParentOfType' @ [126:41] ==> @Nullable @Contract public open fun <T : (PsiElement..PsiElement?)> getParentOfType(@Nullable p0: PsiElement?, @NotNull p1: Class<(KtClassOrObject..KtClassOrObject?)>): KtClassOrObject? defined in com.intellij.psi.util.PsiTreeUtil[JavaMethodDescriptor]
Inferred types:
    <T : (PsiElement..PsiElement?)> -> KtClassOrObject

'elementAtCaret' @ [126:57] ==> val elementAtCaret: PsiElement? defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doOverrideImplement[LocalVariableDescriptor]

'java' @ [126:96] ==> public val <T> KClass<KtClassOrObject>.java: Class<KtClassOrObject> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtClassOrObject

'error' @ [127:32] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'handler' @ [129:30] ==> value-parameter handler: OverrideImplementMembersHandler defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doOverrideImplement[ValueParameterDescriptorImpl]

'collectMembersToGenerate' @ [129:38] ==> public final fun collectMembersToGenerate(classOrObject: KtClassOrObject): Collection<OverrideMemberChooserObject> defined in org.jetbrains.kotlin.idea.core.overrideImplement.OverrideImplementMembersHandler[DeserializedSimpleFunctionDescriptor]

'classOrObject' @ [129:63] ==> val classOrObject: KtClassOrObject defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doOverrideImplement[LocalVariableDescriptor]

'if (memberToOverride == null) {
            val filtered = chooserObjects.filter {
                (it.descriptor.containingDeclaration as? ClassDescriptor)?.let {
                    !KotlinBuiltIns.isAny(it)
                } ?: true
            }
            assertEquals(1, filtered.size, "Invalid number of available chooserObjects for override")
            filtered.single()
        }
        else {
            chooserObjects.single {
                chooserObject ->
                chooserObject.descriptor.name.asString() == memberToOverride
            }
        }' @ [131:32] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: OverrideMemberChooserObject, elseBranch: OverrideMemberChooserObject): OverrideMemberChooserObject[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> OverrideMemberChooserObject

'memberToOverride' @ [131:36] ==> value-parameter memberToOverride: String? defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doOverrideImplement[ValueParameterDescriptorImpl]

'chooserObjects' @ [132:28] ==> val chooserObjects: Collection<OverrideMemberChooserObject> defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doOverrideImplement[LocalVariableDescriptor]

'filter' @ [132:43] ==> public inline fun <T> Iterable<OverrideMemberChooserObject>.filter(predicate: (OverrideMemberChooserObject) -> Boolean): List<OverrideMemberChooserObject> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> OverrideMemberChooserObject

'?:' @ [133:17] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: Boolean?, right: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> Boolean

'it' @ [133:18] ==> value-parameter it: OverrideMemberChooserObject defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doOverrideImplement.<anonymous>[ValueParameterDescriptorImpl]

'descriptor' @ [133:21] ==> public abstract val descriptor: CallableMemberDescriptor defined in org.jetbrains.kotlin.idea.core.overrideImplement.OverrideMemberChooserObject[DeserializedPropertyDescriptor]

'containingDeclaration' @ [133:32] ==> public final val CallableMemberDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'let' @ [133:76] ==> @InlineOnly public inline fun <T, R> ClassDescriptor.let(block: (ClassDescriptor) -> Boolean): Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ClassDescriptor
    <R> -> Boolean

'!' @ [134:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isAny' @ [134:37] ==> public open fun isAny(@NotNull p0: ClassDescriptor): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'it' @ [134:43] ==> value-parameter it: ClassDescriptor defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doOverrideImplement.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'assertEquals' @ [137:13] ==> public fun <@OnlyInputTypes T> assertEquals(expected: Int, actual: Int, message: String? = ...): Unit defined in kotlin.test[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <@OnlyInputTypes T> -> Int

'filtered' @ [137:29] ==> val filtered: List<OverrideMemberChooserObject> defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doOverrideImplement[LocalVariableDescriptor]

'size' @ [137:38] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'filtered' @ [138:13] ==> val filtered: List<OverrideMemberChooserObject> defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doOverrideImplement[LocalVariableDescriptor]

'single' @ [138:22] ==> public fun <T> List<OverrideMemberChooserObject>.single(): OverrideMemberChooserObject defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> OverrideMemberChooserObject

'chooserObjects' @ [141:13] ==> val chooserObjects: Collection<OverrideMemberChooserObject> defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doOverrideImplement[LocalVariableDescriptor]

'single' @ [141:28] ==> public inline fun <T> Iterable<OverrideMemberChooserObject>.single(predicate: (OverrideMemberChooserObject) -> Boolean): OverrideMemberChooserObject defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> OverrideMemberChooserObject

'chooserObject' @ [143:17] ==> value-parameter chooserObject: OverrideMemberChooserObject defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doOverrideImplement.<anonymous>[ValueParameterDescriptorImpl]

'descriptor' @ [143:31] ==> public abstract val descriptor: CallableMemberDescriptor defined in org.jetbrains.kotlin.idea.core.overrideImplement.OverrideMemberChooserObject[DeserializedPropertyDescriptor]

'name' @ [143:42] ==> public final val CallableMemberDescriptor.name: Name[MyPropertyDescriptor]

'asString' @ [143:47] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'memberToOverride' @ [143:61] ==> value-parameter memberToOverride: String? defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doOverrideImplement[ValueParameterDescriptorImpl]

'performGenerateCommand' @ [147:9] ==> private final fun performGenerateCommand(classOrObject: KtClassOrObject, selectedElements: List<OverrideMemberChooserObject>): Unit defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[SimpleFunctionDescriptorImpl]

'classOrObject' @ [147:32] ==> val classOrObject: KtClassOrObject defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doOverrideImplement[LocalVariableDescriptor]

'listOf' @ [147:47] ==> public fun <T> listOf(element: OverrideMemberChooserObject): List<OverrideMemberChooserObject> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> OverrideMemberChooserObject

'singleToOverride' @ [147:54] ==> val singleToOverride: OverrideMemberChooserObject defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doOverrideImplement[LocalVariableDescriptor]

'myFixture' @ [151:30] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'file' @ [151:40] ==> public final val JavaCodeInsightTestFixture.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'findElementAt' @ [151:45] ==> @Nullable @Contract public abstract fun findElementAt(p0: Int): PsiElement? defined in com.intellij.psi.PsiFile[JavaMethodDescriptor]

'myFixture' @ [151:59] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'editor' @ [151:69] ==> public final val JavaCodeInsightTestFixture.editor: (Editor..Editor?)[MyPropertyDescriptor]

'caretModel' @ [151:76] ==> public final val Editor.caretModel: CaretModel[MyPropertyDescriptor]

'offset' @ [151:87] ==> public final val CaretModel.offset: Int[MyPropertyDescriptor]

'?:' @ [152:29] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtClassOrObject?, right: KtClassOrObject): KtClassOrObject[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtClassOrObject

'getParentOfType' @ [152:41] ==> @Nullable @Contract public open fun <T : (PsiElement..PsiElement?)> getParentOfType(@Nullable p0: PsiElement?, @NotNull p1: Class<(KtClassOrObject..KtClassOrObject?)>): KtClassOrObject? defined in com.intellij.psi.util.PsiTreeUtil[JavaMethodDescriptor]
Inferred types:
    <T : (PsiElement..PsiElement?)> -> KtClassOrObject

'elementAtCaret' @ [152:57] ==> val elementAtCaret: PsiElement? defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doMultiOverrideImplement[LocalVariableDescriptor]

'java' @ [152:96] ==> public val <T> KClass<KtClassOrObject>.java: Class<KtClassOrObject> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtClassOrObject

'error' @ [153:32] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'handler' @ [155:30] ==> value-parameter handler: OverrideImplementMembersHandler defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doMultiOverrideImplement[ValueParameterDescriptorImpl]

'collectMembersToGenerate' @ [155:38] ==> public final fun collectMembersToGenerate(classOrObject: KtClassOrObject): Collection<OverrideMemberChooserObject> defined in org.jetbrains.kotlin.idea.core.overrideImplement.OverrideImplementMembersHandler[DeserializedSimpleFunctionDescriptor]

'classOrObject' @ [155:63] ==> val classOrObject: KtClassOrObject defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doMultiOverrideImplement[LocalVariableDescriptor]

'sortedBy' @ [155:78] ==> public inline fun <T, R : Comparable<String>> Iterable<OverrideMemberChooserObject>.sortedBy(crossinline selector: (OverrideMemberChooserObject) -> String?): List<OverrideMemberChooserObject> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> OverrideMemberChooserObject
    <R : Comparable<R>> -> String

'it' @ [155:89] ==> value-parameter it: OverrideMemberChooserObject defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doMultiOverrideImplement.<anonymous>[ValueParameterDescriptorImpl]

'descriptor' @ [155:92] ==> public abstract val descriptor: CallableMemberDescriptor defined in org.jetbrains.kotlin.idea.core.overrideImplement.OverrideMemberChooserObject[DeserializedPropertyDescriptor]

'name' @ [155:103] ==> public final val CallableMemberDescriptor.name: Name[MyPropertyDescriptor]

'asString' @ [155:108] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'it' @ [155:130] ==> value-parameter it: OverrideMemberChooserObject defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doMultiOverrideImplement.<anonymous>[ValueParameterDescriptorImpl]

'immediateSuper' @ [155:133] ==> public abstract val immediateSuper: CallableMemberDescriptor defined in org.jetbrains.kotlin.idea.core.overrideImplement.OverrideMemberChooserObject[DeserializedPropertyDescriptor]

'containingDeclaration' @ [155:148] ==> public final val CallableMemberDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'name' @ [155:170] ==> public final val DeclarationDescriptor.name: Name[MyPropertyDescriptor]

'asString' @ [155:175] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'performGenerateCommand' @ [156:9] ==> private final fun performGenerateCommand(classOrObject: KtClassOrObject, selectedElements: List<OverrideMemberChooserObject>): Unit defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[SimpleFunctionDescriptorImpl]

'classOrObject' @ [156:32] ==> val classOrObject: KtClassOrObject defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doMultiOverrideImplement[LocalVariableDescriptor]

'chooserObjects' @ [156:47] ==> val chooserObjects: List<OverrideMemberChooserObject> defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.doMultiOverrideImplement[LocalVariableDescriptor]

'project' @ [160:9] ==> public final val AbstractOverrideImplementTest.project: Project[MyPropertyDescriptor]

'executeWriteCommand' @ [160:17] ==> public fun Project.executeWriteCommand(name: String, command: () -> Unit): Unit defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]

'(myFixture.file as PsiClassOwner).classes[0]' @ [161:26] ==> public final operator fun get(index: Int): (PsiClass..PsiClass?) defined in kotlin.Array[DeserializedSimpleFunctionDescriptor]

'myFixture' @ [161:27] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'file' @ [161:37] ==> public final val JavaCodeInsightTestFixture.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'classes' @ [161:60] ==> public final val PsiClassOwner.classes: (Array<(PsiClass..PsiClass?)>..Array<out (PsiClass..PsiClass?)>)[MyPropertyDescriptor]

'PsiMethodMember' @ [163:32] ==> public constructor PsiMethodMember(@NotNull p0: PsiMethod, @NotNull p1: PsiSubstitutor) defined in com.intellij.codeInsight.generation.PsiMethodMember[JavaClassConstructorDescriptor]

'method' @ [163:48] ==> value-parameter method: PsiMethod defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.generateImplementation[ValueParameterDescriptorImpl]

'EMPTY' @ [163:71] ==> @NotNull public final val EMPTY: PsiSubstitutor defined in com.intellij.psi.PsiSubstitutor[JavaPropertyDescriptor]

'overrideOrImplementMethodsInRightPlace' @ [165:35] ==> public open fun overrideOrImplementMethodsInRightPlace(p0: (Editor..Editor?), p1: (PsiClass..PsiClass?), p2: (MutableCollection<(PsiMethodMember..PsiMethodMember?)>..Collection<(PsiMethodMember..PsiMethodMember?)>?), p3: Boolean): Unit defined in com.intellij.codeInsight.generation.OverrideImplementUtil[JavaMethodDescriptor]

'myFixture' @ [165:74] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'editor' @ [165:84] ==> public final val JavaCodeInsightTestFixture.editor: (Editor..Editor?)[MyPropertyDescriptor]

'aClass' @ [165:92] ==> val aClass: (PsiClass..PsiClass?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.generateImplementation.<anonymous>[LocalVariableDescriptor]

'SmartList' @ [165:100] ==> public constructor SmartList<E : (Any..Any?)>(p0: (PsiMethodMember..PsiMethodMember?)) defined in com.intellij.util.SmartList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> PsiMethodMember

'methodMember' @ [165:110] ==> val methodMember: PsiMethodMember defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.generateImplementation.<anonymous>[LocalVariableDescriptor]

'getInstance' @ [167:43] ==> public open fun getInstance(p0: (Project..Project?)): (PostprocessReformattingAspect..PostprocessReformattingAspect?) defined in com.intellij.psi.impl.source.PostprocessReformattingAspect[JavaMethodDescriptor]

'myFixture' @ [167:55] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'project' @ [167:65] ==> public final val JavaCodeInsightTestFixture.project: (Project..Project?)[MyPropertyDescriptor]

'doPostponedFormatting' @ [167:74] ==> public open fun doPostponedFormatting(): Unit defined in com.intellij.psi.impl.source.PostprocessReformattingAspect[JavaMethodDescriptor]

'isDirectiveDefined' @ [175:49] ==> public open fun isDirectiveDefined(p0: (String..String?), p1: (String..String?)): Boolean defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'classOrObject' @ [175:68] ==> value-parameter classOrObject: KtClassOrObject defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.performGenerateCommand[ValueParameterDescriptorImpl]

'containingFile' @ [175:82] ==> public final val KtClassOrObject.containingFile: PsiFile[MyPropertyDescriptor]

'text' @ [175:97] ==> public final val PsiFile.text: (String..String?)[MyPropertyDescriptor]

'myFixture' @ [176:13] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'project' @ [176:23] ==> public final val JavaCodeInsightTestFixture.project: (Project..Project?)[MyPropertyDescriptor]

'executeWriteCommand' @ [176:31] ==> public fun Project.executeWriteCommand(name: String, command: () -> Unit): Unit defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]

'OverrideImplementMembersHandler' @ [177:17] ==> public companion object defined in org.jetbrains.kotlin.idea.core.overrideImplement.OverrideImplementMembersHandler[FakeCallableDescriptorForObject]

'generateMembers' @ [177:49] ==> public final fun generateMembers(editor: Editor?, classOrObject: KtClassOrObject, selectedElements: Collection<OverrideMemberChooserObject>, copyDoc: Boolean): Unit defined in org.jetbrains.kotlin.idea.core.overrideImplement.OverrideImplementMembersHandler.Companion[DeserializedSimpleFunctionDescriptor]

'myFixture' @ [177:65] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'editor' @ [177:75] ==> public final val JavaCodeInsightTestFixture.editor: (Editor..Editor?)[MyPropertyDescriptor]

'classOrObject' @ [177:83] ==> value-parameter classOrObject: KtClassOrObject defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.performGenerateCommand[ValueParameterDescriptorImpl]

'selectedElements' @ [177:98] ==> value-parameter selectedElements: List<OverrideMemberChooserObject> defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.performGenerateCommand[ValueParameterDescriptorImpl]

'copyDoc' @ [177:116] ==> val copyDoc: Boolean defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.performGenerateCommand[LocalVariableDescriptor]

'rethrow' @ [181:19] ==> public fun rethrow(e: Throwable): RuntimeException /* = RuntimeException */ defined in org.jetbrains.kotlin.utils[DeserializedSimpleFunctionDescriptor]

'throwable' @ [181:27] ==> val throwable: Throwable defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.performGenerateCommand[LocalVariableDescriptor]

'File' @ [187:28] ==> public constructor File(p0: (String..String?), p1: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'myFixture' @ [187:33] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'testDataPath' @ [187:43] ==> public final var JavaCodeInsightTestFixture.testDataPath: String[MyPropertyDescriptor]

'fileName' @ [187:57] ==> value-parameter fileName: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.checkResultByFile[ValueParameterDescriptorImpl]

'assertTrue' @ [189:20] ==> public open fun assertTrue(p0: Boolean): Unit defined in org.junit.Assert[JavaMethodDescriptor]

'expectedFile' @ [189:31] ==> val expectedFile: File defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.checkResultByFile[LocalVariableDescriptor]

'exists' @ [189:44] ==> public open fun exists(): Boolean defined in java.io.File[JavaMethodDescriptor]

'myFixture' @ [190:24] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'file' @ [190:34] ==> public final val JavaCodeInsightTestFixture.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'myFixture' @ [191:28] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'getDocument' @ [191:38] ==> public abstract fun getDocument(@NotNull p0: PsiFile): (Document..Document?) defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'file' @ [191:50] ==> val file: KtFile defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.checkResultByFile[LocalVariableDescriptor]

'myFixture' @ [192:13] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'project' @ [192:23] ==> public final val JavaCodeInsightTestFixture.project: (Project..Project?)[MyPropertyDescriptor]

'executeWriteCommand' @ [192:31] ==> public fun Project.executeWriteCommand(name: String, command: () -> Unit): Unit defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]

'document' @ [193:17] ==> val document: (Document..Document?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.checkResultByFile[LocalVariableDescriptor]

'replaceString' @ [193:26] ==> public abstract fun replaceString(p0: Int, p1: Int, @NotNull p2: CharSequence): Unit defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'document' @ [193:43] ==> val document: (Document..Document?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.checkResultByFile[LocalVariableDescriptor]

'textLength' @ [193:52] ==> public final val Document.textLength: Int[MyPropertyDescriptor]

'file' @ [193:64] ==> val file: KtFile defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.checkResultByFile[LocalVariableDescriptor]

'dumpTextWithErrors' @ [193:69] ==> public fun KtFile.dumpTextWithErrors(): String defined in org.jetbrains.kotlin.idea.test in file testUtils.kt[SimpleFunctionDescriptorImpl]

'myFixture' @ [195:13] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'checkResultByFile' @ [195:23] ==> public abstract fun checkResultByFile(@NotNull p0: String): Unit defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'fileName' @ [195:41] ==> value-parameter fileName: String defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.checkResultByFile[ValueParameterDescriptorImpl]

'assertEqualsToFile' @ [198:29] ==> public open fun assertEqualsToFile(@NotNull p0: File, @NotNull p1: String): Unit defined in org.jetbrains.kotlin.test.KotlinTestUtils[JavaMethodDescriptor]

'expectedFile' @ [198:48] ==> val expectedFile: File defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest.checkResultByFile[LocalVariableDescriptor]

'generateTextWithCaretAndSelection' @ [198:79] ==> public open fun generateTextWithCaretAndSelection(@NotNull editor: Editor): (String..String?) defined in org.jetbrains.kotlin.test.TagsTestDataUtil[JavaMethodDescriptor]

'myFixture' @ [198:113] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.codeInsight.AbstractOverrideImplementTest[JavaPropertyDescriptor]

'editor' @ [198:123] ==> public final val JavaCodeInsightTestFixture.editor: (Editor..Editor?)[MyPropertyDescriptor]

