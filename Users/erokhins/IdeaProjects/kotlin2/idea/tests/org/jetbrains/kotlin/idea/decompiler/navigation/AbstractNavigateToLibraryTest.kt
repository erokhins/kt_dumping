'KotlinCodeInsightTestCase' @ [31:48] ==> public constructor KotlinCodeInsightTestCase() defined in org.jetbrains.kotlin.idea.test.KotlinCodeInsightTestCase[JavaClassConstructorDescriptor]

'doTestEx' @ [33:48] ==> protected final fun doTestEx(path: String, additionalConfig: (() -> Unit)? = ...): Unit defined in org.jetbrains.kotlin.idea.decompiler.navigation.AbstractNavigateToLibraryTest[SimpleFunctionDescriptorImpl]

'path' @ [33:57] ==> value-parameter path: String defined in org.jetbrains.kotlin.idea.decompiler.navigation.AbstractNavigateToLibraryTest.doTest[ValueParameterDescriptorImpl]

'doTestEx' @ [35:60] ==> protected final fun doTestEx(path: String, additionalConfig: (() -> Unit)? = ...): Unit defined in org.jetbrains.kotlin.idea.decompiler.navigation.AbstractNavigateToLibraryTest[SimpleFunctionDescriptorImpl]

'path' @ [35:69] ==> value-parameter path: String defined in org.jetbrains.kotlin.idea.decompiler.navigation.AbstractNavigateToLibraryTest.doWithJSModuleTest[ValueParameterDescriptorImpl]

'this' @ [36:24] ==> <this> defined in org.jetbrains.kotlin.idea.decompiler.navigation.AbstractNavigateToLibraryTest[LazyClassReceiverParameterDescriptor]

'createModule' @ [36:29] ==> @NotNull protected/*protected and package*/ open fun createModule(@NonNls p0: (String..String?)): Module defined in org.jetbrains.kotlin.idea.decompiler.navigation.AbstractNavigateToLibraryTest[JavaMethodDescriptor]

'jsModule' @ [37:9] ==> val jsModule: Module defined in org.jetbrains.kotlin.idea.decompiler.navigation.AbstractNavigateToLibraryTest.doWithJSModuleTest.<anonymous>[LocalVariableDescriptor]

'configureAs' @ [37:18] ==> public fun Module.configureAs(kind: ModuleKind): Unit defined in org.jetbrains.kotlin.idea.test in file testUtils.kt[SimpleFunctionDescriptorImpl]

'KOTLIN_JAVASCRIPT' @ [37:41] ==> enum entry KOTLIN_JAVASCRIPT defined in org.jetbrains.kotlin.idea.test.ModuleKind[FakeCallableDescriptorForObject]

'configureByFile' @ [44:9] ==> protected/*protected and package*/ open fun configureByFile(p0: (String..String?)): Unit defined in org.jetbrains.kotlin.idea.decompiler.navigation.AbstractNavigateToLibraryTest[JavaMethodDescriptor]

'path' @ [44:25] ==> value-parameter path: String defined in org.jetbrains.kotlin.idea.decompiler.navigation.AbstractNavigateToLibraryTest.doTestEx[ValueParameterDescriptorImpl]

'module' @ [45:9] ==> public final val AbstractNavigateToLibraryTest.module: (Module..Module?)[MyPropertyDescriptor]

'configureAs' @ [45:16] ==> public fun Module.configureAs(descriptor: KotlinLightProjectDescriptor): Unit defined in org.jetbrains.kotlin.idea.test in file testUtils.kt[SimpleFunctionDescriptorImpl]

'getProjectDescriptor' @ [45:28] ==> public open fun getProjectDescriptor(): KotlinLightProjectDescriptor defined in org.jetbrains.kotlin.idea.decompiler.navigation.AbstractNavigateToLibraryTest[SimpleFunctionDescriptorImpl]

'additionalConfig' @ [47:13] ==> value-parameter additionalConfig: (() -> Unit)? = ... defined in org.jetbrains.kotlin.idea.decompiler.navigation.AbstractNavigateToLibraryTest.doTestEx[ValueParameterDescriptorImpl]

'invoke' @ [48:13] ==> public abstract operator fun invoke(): Unit defined in kotlin.Function0[FunctionInvokeDescriptor]

'NavigationChecker' @ [51:9] ==> public companion object defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker[FakeCallableDescriptorForObject]

'checkAnnotatedCode' @ [51:27] ==> public final fun checkAnnotatedCode(file: PsiFile, expectedFile: File, referenceTargetChecker: (PsiElement) -> Unit = ...): Unit defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.Companion[SimpleFunctionDescriptorImpl]

'file' @ [51:46] ==> public final val AbstractNavigateToLibraryTest.file: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'File' @ [51:52] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'path' @ [51:57] ==> value-parameter path: String defined in org.jetbrains.kotlin.idea.decompiler.navigation.AbstractNavigateToLibraryTest.doTestEx[ValueParameterDescriptorImpl]

'replace' @ [51:62] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'expectedFileExt' @ [51:77] ==> public abstract val expectedFileExt: String defined in org.jetbrains.kotlin.idea.decompiler.navigation.AbstractNavigateToLibraryTest[PropertyDescriptorImpl]

'SourceNavigationHelper' @ [55:9] ==> public object SourceNavigationHelper defined in org.jetbrains.kotlin.idea.decompiler.navigation[FakeCallableDescriptorForObject]

'setForceResolve' @ [55:32] ==> public final fun setForceResolve(forceResolve: Boolean): Unit defined in org.jetbrains.kotlin.idea.decompiler.navigation.SourceNavigationHelper[DeserializedSimpleFunctionDescriptor]

'super' @ [56:9] ==> <this> defined in org.jetbrains.kotlin.idea.decompiler.navigation.AbstractNavigateToLibraryTest[LazyClassReceiverParameterDescriptor]

'tearDown' @ [56:15] ==> @Override protected/*protected and package*/ open fun tearDown(): Unit defined in org.jetbrains.kotlin.idea.test.KotlinCodeInsightTestCase[JavaMethodDescriptor]

'+' @ [60:13] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'getHomeDirectory' @ [60:29] ==> @NotNull public open fun getHomeDirectory(): String defined in org.jetbrains.kotlin.test.KotlinTestUtils[JavaMethodDescriptor]

'separator' @ [60:55] ==> public const final val separator: (String..String?) defined in java.io.File[JavaPropertyDescriptor]

'JdkAndMockLibraryProjectDescriptor' @ [64:13] ==> public constructor JdkAndMockLibraryProjectDescriptor(sourcesPath: (String..String?), withSources: Boolean) defined in org.jetbrains.kotlin.idea.test.JdkAndMockLibraryProjectDescriptor[JavaClassConstructorDescriptor]

'+' @ [64:48] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'getTestDataPathBase' @ [64:67] ==> @NotNull public open fun getTestDataPathBase(): String defined in org.jetbrains.kotlin.idea.test.PluginTestCaseBase[JavaMethodDescriptor]

'withSource' @ [64:125] ==> public abstract val withSource: Boolean defined in org.jetbrains.kotlin.idea.decompiler.navigation.AbstractNavigateToLibraryTest[PropertyDescriptorImpl]

'AbstractNavigateToLibraryTest' @ [67:58] ==> public constructor AbstractNavigateToLibraryTest() defined in org.jetbrains.kotlin.idea.decompiler.navigation.AbstractNavigateToLibraryTest[ClassConstructorDescriptorImpl]

'AbstractNavigateToLibraryTest' @ [72:54] ==> public constructor AbstractNavigateToLibraryTest() defined in org.jetbrains.kotlin.idea.decompiler.navigation.AbstractNavigateToLibraryTest[ClassConstructorDescriptorImpl]

'getNavigateElementsText' @ [79:36] ==> public open fun getNavigateElementsText(project: (Project..Project?), navigableElements: (MutableCollection<out (PsiElement..PsiElement?)>..Collection<(PsiElement..PsiElement?)>?)): (String..String?) defined in org.jetbrains.kotlin.idea.navigation.NavigationTestUtils[JavaMethodDescriptor]

'file' @ [79:60] ==> public final val file: PsiFile defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker[PropertyDescriptorImpl]

'project' @ [79:65] ==> public final val PsiFile.project: Project[MyPropertyDescriptor]

'collectInterestingNavigationElements' @ [79:74] ==> private final fun collectInterestingNavigationElements(): List<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker[SimpleFunctionDescriptorImpl]

'collectInterestingReferences' @ [83:13] ==> private final fun collectInterestingReferences(): Collection<KtReference> defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker[SimpleFunctionDescriptorImpl]

'map' @ [83:44] ==> public inline fun <T, R> Iterable<KtReference>.map(transform: (KtReference) -> (PsiElement..PsiElement?)): List<(PsiElement..PsiElement?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtReference
    <R> -> (com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)

'it' @ [84:30] ==> value-parameter it: KtReference defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.collectInterestingNavigationElements.<anonymous>[ValueParameterDescriptorImpl]

'resolve' @ [84:33] ==> @Nullable public abstract fun resolve(): PsiElement? defined in org.jetbrains.kotlin.idea.references.KtReference[JavaMethodDescriptor]

'assertNotNull' @ [85:26] ==> public open fun assertNotNull(p0: (Any..Any?)): Unit defined in junit.framework.TestCase[JavaMethodDescriptor]

'target' @ [85:40] ==> val target: PsiElement? defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.collectInterestingNavigationElements.<anonymous>[LocalVariableDescriptor]

'target' @ [86:17] ==> val target: PsiElement? defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.collectInterestingNavigationElements.<anonymous>[LocalVariableDescriptor]

'navigationElement' @ [86:26] ==> public final val PsiElement.navigationElement: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'LinkedHashMap' @ [90:47] ==> public constructor LinkedHashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.LinkedHashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> PsiElement
    <V : (Any..Any?)> -> KtReference

'..' @ [91:24] ==> public final operator fun rangeTo(other: Int): IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'file' @ [91:27] ==> public final val file: PsiFile defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker[PropertyDescriptorImpl]

'textLength' @ [91:32] ==> public final val PsiFile.textLength: Int[MyPropertyDescriptor]

'file' @ [92:23] ==> public final val file: PsiFile defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker[PropertyDescriptorImpl]

'findReferenceAt' @ [92:28] ==> @Nullable @Contract public abstract fun findReferenceAt(p0: Int): PsiReference? defined in com.intellij.psi.PsiFile[JavaMethodDescriptor]

'offset' @ [92:44] ==> val offset: Int defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.collectInterestingReferences[LocalVariableDescriptor]

'when (ref) {
                is KtReference -> listOf(ref)
                is PsiMultiReference -> ref.references.filterIsInstance<KtReference>()
                else -> emptyList<KtReference>()
            }' @ [93:24] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: List<KtReference>, entry1: List<KtReference>, entry2: List<KtReference>): List<KtReference>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> List<KtReference>

'ref' @ [93:30] ==> val ref: PsiReference? defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.collectInterestingReferences[LocalVariableDescriptor]

'listOf' @ [94:35] ==> public fun <T> listOf(element: KtReference): List<KtReference> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtReference

'ref' @ [94:42] ==> val ref: PsiReference? defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.collectInterestingReferences[LocalVariableDescriptor]

'ref' @ [95:41] ==> val ref: PsiReference? defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.collectInterestingReferences[LocalVariableDescriptor]

'references' @ [95:45] ==> public final val PsiMultiReference.references: (Array<(PsiReference..PsiReference?)>..Array<out (PsiReference..PsiReference?)>)[MyPropertyDescriptor]

'filterIsInstance' @ [95:56] ==> public inline fun <reified R> Array<*>.filterIsInstance(): List<KtReference> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified R> -> KtReference

'emptyList' @ [96:25] ==> public fun <T> emptyList(): List<KtReference> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtReference

'refs' @ [99:13] ==> val refs: List<KtReference> defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.collectInterestingReferences[LocalVariableDescriptor]

'forEach' @ [99:18] ==> @HidesMembers public inline fun <T> Iterable<KtReference>.forEach(action: (KtReference) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtReference

'referenceContainersToReferences' @ [99:28] ==> val referenceContainersToReferences: LinkedHashMap<PsiElement, KtReference> defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.collectInterestingReferences[LocalVariableDescriptor]

'addReference' @ [99:60] ==> private final fun MutableMap<PsiElement, KtReference>.addReference(ref: KtReference): Unit defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker[SimpleFunctionDescriptorImpl]

'it' @ [99:73] ==> value-parameter it: KtReference defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.collectInterestingReferences.<anonymous>[ValueParameterDescriptorImpl]

'referenceContainersToReferences' @ [101:16] ==> val referenceContainersToReferences: LinkedHashMap<PsiElement, KtReference> defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.collectInterestingReferences[LocalVariableDescriptor]

'values' @ [101:48] ==> public open val values: MutableCollection<KtReference> defined in java.util.LinkedHashMap[JavaPropertyDescriptor]

'containsKey' @ [105:13] ==> public abstract fun containsKey(key: PsiElement): Boolean defined in kotlin.collections.MutableMap[DeserializedSimpleFunctionDescriptor]

'ref' @ [105:25] ==> value-parameter ref: KtReference defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.addReference[ValueParameterDescriptorImpl]

'element' @ [105:29] ==> public final val KtReference.element: KtElement[MyPropertyDescriptor]

'ref' @ [106:22] ==> value-parameter ref: KtReference defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.addReference[ValueParameterDescriptorImpl]

'resolve' @ [106:26] ==> @Nullable public abstract fun resolve(): PsiElement? defined in org.jetbrains.kotlin.idea.references.KtReference[JavaMethodDescriptor]

'invoke' @ [108:9] ==> public abstract operator fun invoke(p1: PsiElement): Unit defined in kotlin.Function1[FunctionInvokeDescriptor]

'target' @ [108:32] ==> val target: PsiElement defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.addReference[LocalVariableDescriptor]

'target' @ [110:32] ==> val target: PsiElement defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.addReference[LocalVariableDescriptor]

'navigationElement' @ [110:39] ==> public final val PsiElement.navigationElement: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'containingFile' @ [110:57] ==> public final val PsiElement.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'targetNavPsiFile' @ [112:29] ==> val targetNavPsiFile: PsiFile defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.addReference[LocalVariableDescriptor]

'virtualFile' @ [112:46] ==> public final val PsiFile.virtualFile: (VirtualFile..VirtualFile?)[MyPropertyDescriptor]

'!' @ [114:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'ProjectRootsUtil' @ [114:14] ==> public object ProjectRootsUtil defined in org.jetbrains.kotlin.idea.util[FakeCallableDescriptorForObject]

'isProjectSourceFile' @ [114:31] ==> @JvmStatic public final fun isProjectSourceFile(project: Project, file: VirtualFile): Boolean defined in org.jetbrains.kotlin.idea.util.ProjectRootsUtil[DeserializedSimpleFunctionDescriptor]

'target' @ [114:51] ==> val target: PsiElement defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.addReference[LocalVariableDescriptor]

'project' @ [114:58] ==> public final val PsiElement.project: Project[MyPropertyDescriptor]

'targetNavFile' @ [114:67] ==> val targetNavFile: VirtualFile defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.addReference[LocalVariableDescriptor]

'put' @ [115:13] ==> public abstract fun put(key: PsiElement, value: KtReference): KtReference? defined in kotlin.collections.MutableMap[DeserializedSimpleFunctionDescriptor]

'ref' @ [115:17] ==> value-parameter ref: KtReference defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.addReference[ValueParameterDescriptorImpl]

'element' @ [115:21] ==> public final val KtReference.element: KtElement[MyPropertyDescriptor]

'ref' @ [115:30] ==> value-parameter ref: KtReference defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.addReference[ValueParameterDescriptorImpl]

'NavigationChecker' @ [121:37] ==> public constructor NavigationChecker(file: PsiFile, referenceTargetChecker: (PsiElement) -> Unit) defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker[ClassConstructorDescriptorImpl]

'file' @ [121:55] ==> value-parameter file: PsiFile defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.Companion.checkAnnotatedCode[ValueParameterDescriptorImpl]

'referenceTargetChecker' @ [121:61] ==> value-parameter referenceTargetChecker: (PsiElement) -> Unit = ... defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.Companion.checkAnnotatedCode[ValueParameterDescriptorImpl]

'listOf' @ [122:34] ==> public fun <T> listOf(vararg elements: Boolean): List<Boolean> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Boolean

'SourceNavigationHelper' @ [123:17] ==> public object SourceNavigationHelper defined in org.jetbrains.kotlin.idea.decompiler.navigation[FakeCallableDescriptorForObject]

'setForceResolve' @ [123:40] ==> public final fun setForceResolve(forceResolve: Boolean): Unit defined in org.jetbrains.kotlin.idea.decompiler.navigation.SourceNavigationHelper[DeserializedSimpleFunctionDescriptor]

'forceResolve' @ [123:56] ==> val forceResolve: Boolean defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.Companion.checkAnnotatedCode[LocalVariableDescriptor]

'assertEqualsToFile' @ [124:33] ==> public open fun assertEqualsToFile(@NotNull p0: File, @NotNull p1: String): Unit defined in org.jetbrains.kotlin.test.KotlinTestUtils[JavaMethodDescriptor]

'expectedFile' @ [124:52] ==> value-parameter expectedFile: File defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.Companion.checkAnnotatedCode[ValueParameterDescriptorImpl]

'navigationChecker' @ [124:66] ==> val navigationChecker: NavigationChecker defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker.Companion.checkAnnotatedCode[LocalVariableDescriptor]

'annotatedLibraryCode' @ [124:84] ==> public final fun annotatedLibraryCode(): String defined in org.jetbrains.kotlin.idea.decompiler.navigation.NavigationChecker[SimpleFunctionDescriptorImpl]

