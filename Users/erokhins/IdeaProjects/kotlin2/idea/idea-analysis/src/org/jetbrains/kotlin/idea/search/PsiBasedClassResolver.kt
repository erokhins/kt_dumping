'TestOnly' @ [45:29] ==> public constructor TestOnly() defined in org.jetbrains.annotations.TestOnly[JavaClassConstructorDescriptor]

'targetClassFqName' @ [46:35] ==> private final val targetClassFqName: String defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'substringAfterLast' @ [46:53] ==> public fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'targetClassFqName' @ [47:33] ==> private final val targetClassFqName: String defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'substringBeforeLast' @ [47:51] ==> public fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'mutableListOf' @ [51:39] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableListOf(): MutableList<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'mutableListOf' @ [56:43] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableListOf(): MutableList<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'TestOnly' @ [61:9] ==> public constructor TestOnly() defined in org.jetbrains.annotations.TestOnly[JavaClassConstructorDescriptor]

'AtomicInteger' @ [61:34] ==> public constructor AtomicInteger() defined in java.util.concurrent.atomic.AtomicInteger[JavaClassConstructorDescriptor]

'TestOnly' @ [62:9] ==> public constructor TestOnly() defined in org.jetbrains.annotations.TestOnly[JavaClassConstructorDescriptor]

'AtomicInteger' @ [62:34] ==> public constructor AtomicInteger() defined in java.util.concurrent.atomic.AtomicInteger[JavaClassConstructorDescriptor]

'TestOnly' @ [63:9] ==> public constructor TestOnly() defined in org.jetbrains.annotations.TestOnly[JavaClassConstructorDescriptor]

'AtomicInteger' @ [63:35] ==> public constructor AtomicInteger() defined in java.util.concurrent.atomic.AtomicInteger[JavaClassConstructorDescriptor]

'this' @ [66:36] ==> @TestOnly public constructor PsiBasedClassResolver(targetClassFqName: String) defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[ClassConstructorDescriptorImpl]

'target' @ [66:41] ==> value-parameter target: PsiClass defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.<init>[ValueParameterDescriptorImpl]

'qualifiedName' @ [66:48] ==> public final val PsiClass.qualifiedName: String?[MyPropertyDescriptor]

'target' @ [67:13] ==> value-parameter target: PsiClass defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.<init>[ValueParameterDescriptorImpl]

'qualifiedName' @ [67:20] ==> public final val PsiClass.qualifiedName: String?[MyPropertyDescriptor]

'target' @ [67:45] ==> value-parameter target: PsiClass defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.<init>[ValueParameterDescriptorImpl]

'containingClass' @ [67:52] ==> public final val PsiClass.containingClass: PsiClass?[MyPropertyDescriptor]

'targetPackage' @ [67:79] ==> private final val targetPackage: String defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'isEmpty' @ [67:93] ==> @InlineOnly public inline fun CharSequence.isEmpty(): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'forceAmbiguity' @ [68:13] ==> private final var forceAmbiguity: Boolean defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'runReadAction' @ [72:9] ==> public fun <T> runReadAction(action: () -> Unit): Unit defined in org.jetbrains.kotlin.idea.util.application[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> Unit

'findPotentialClassConflicts' @ [73:13] ==> private final fun findPotentialClassConflicts(target: PsiClass): Unit defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[SimpleFunctionDescriptorImpl]

'target' @ [73:41] ==> value-parameter target: PsiClass defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.<init>[ValueParameterDescriptorImpl]

'findPotentialTypeAliasConflicts' @ [74:13] ==> private final fun findPotentialTypeAliasConflicts(target: PsiClass): Unit defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[SimpleFunctionDescriptorImpl]

'target' @ [74:45] ==> value-parameter target: PsiClass defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.<init>[ValueParameterDescriptorImpl]

'getInstance' @ [79:45] ==> public open fun getInstance(p0: (Project..Project?)): (PsiShortNamesCache..PsiShortNamesCache?) defined in com.intellij.psi.search.PsiShortNamesCache[JavaMethodDescriptor]

'target' @ [79:57] ==> value-parameter target: PsiClass defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.findPotentialClassConflicts[ValueParameterDescriptorImpl]

'project' @ [79:64] ==> public final val PsiClass.project: Project[MyPropertyDescriptor]

'getClassesByName' @ [79:73] ==> @NotNull public abstract fun getClassesByName(@NotNull @NonNls p0: String, @NotNull p1: GlobalSearchScope): (Array<(PsiClass..PsiClass?)>..Array<out (PsiClass..PsiClass?)>) defined in com.intellij.psi.search.PsiShortNamesCache[JavaMethodDescriptor]

'targetShortName' @ [79:90] ==> private final val targetShortName: String defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'target' @ [79:107] ==> value-parameter target: PsiClass defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.findPotentialClassConflicts[ValueParameterDescriptorImpl]

'project' @ [79:114] ==> public final val PsiClass.project: Project[MyPropertyDescriptor]

'allScope' @ [79:122] ==> public fun Project.allScope(): GlobalSearchScope defined in org.jetbrains.kotlin.idea.search in file searchUtil.kt[SimpleFunctionDescriptorImpl]

'candidates' @ [80:27] ==> val candidates: (Array<(PsiClass..PsiClass?)>..Array<out (PsiClass..PsiClass?)>) defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.findPotentialClassConflicts[LocalVariableDescriptor]

'candidate' @ [82:17] ==> val candidate: (PsiClass..PsiClass?) defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.findPotentialClassConflicts[LocalVariableDescriptor]

'containingClass' @ [82:27] ==> public final val PsiClass.containingClass: PsiClass?[MyPropertyDescriptor]

'!' @ [82:54] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'candidate' @ [82:55] ==> val candidate: (PsiClass..PsiClass?) defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.findPotentialClassConflicts[LocalVariableDescriptor]

'hasModifierProperty' @ [82:65] ==> public abstract fun hasModifierProperty(@PsiModifier.ModifierConstant @NonNls @NotNull p0: String): Boolean defined in com.intellij.psi.PsiClass[JavaMethodDescriptor]

'PRIVATE' @ [82:97] ==> public const final val PRIVATE: String defined in com.intellij.psi.PsiModifier[JavaPropertyDescriptor]

'if (candidate.isAnnotationType) {
                    forceAmbiguity = true
                }
                else {
                    forceAmbiguityForNonAnnotations = true
                }' @ [83:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'candidate' @ [83:21] ==> val candidate: (PsiClass..PsiClass?) defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.findPotentialClassConflicts[LocalVariableDescriptor]

'isAnnotationType' @ [83:31] ==> public final val PsiClass.isAnnotationType: Boolean[MyPropertyDescriptor]

'forceAmbiguity' @ [84:21] ==> private final var forceAmbiguity: Boolean defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'forceAmbiguityForNonAnnotations' @ [87:21] ==> private final var forceAmbiguityForNonAnnotations: Boolean defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'if (candidate.qualifiedName == target.qualifiedName) {
                // File with same FQ name in another module, don't bother with analyzing dependencies
                if (candidate.navigationElement.containingFile != target.navigationElement.containingFile) {
                    forceAmbiguity = true
                    break
                }
            }
            else {
                candidate.qualifiedName?.substringBeforeLast('.', "")?.let { candidatePackage ->
                    if (candidatePackage == "")
                        forceAmbiguity = true
                    else
                        conflictingPackages.add(candidatePackage)
                }
            }' @ [92:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any?, elseBranch: Any?): Any?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any?

'candidate' @ [92:17] ==> val candidate: (PsiClass..PsiClass?) defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.findPotentialClassConflicts[LocalVariableDescriptor]

'qualifiedName' @ [92:27] ==> public final val PsiClass.qualifiedName: String?[MyPropertyDescriptor]

'target' @ [92:44] ==> value-parameter target: PsiClass defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.findPotentialClassConflicts[ValueParameterDescriptorImpl]

'qualifiedName' @ [92:51] ==> public final val PsiClass.qualifiedName: String?[MyPropertyDescriptor]

'candidate' @ [94:21] ==> val candidate: (PsiClass..PsiClass?) defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.findPotentialClassConflicts[LocalVariableDescriptor]

'navigationElement' @ [94:31] ==> public final val PsiClass.navigationElement: PsiElement[MyPropertyDescriptor]

'containingFile' @ [94:49] ==> public final val PsiElement.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'target' @ [94:67] ==> value-parameter target: PsiClass defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.findPotentialClassConflicts[ValueParameterDescriptorImpl]

'navigationElement' @ [94:74] ==> public final val PsiClass.navigationElement: PsiElement[MyPropertyDescriptor]

'containingFile' @ [94:92] ==> public final val PsiElement.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'forceAmbiguity' @ [95:21] ==> private final var forceAmbiguity: Boolean defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'candidate' @ [100:17] ==> val candidate: (PsiClass..PsiClass?) defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.findPotentialClassConflicts[LocalVariableDescriptor]

'qualifiedName' @ [100:27] ==> public final val PsiClass.qualifiedName: String?[MyPropertyDescriptor]

'substringBeforeLast' @ [100:42] ==> public fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'let' @ [100:72] ==> @InlineOnly public inline fun <T, R> String.let(block: (String) -> Any): Any defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String
    <R> -> Any

'if (candidatePackage == "")
                        forceAmbiguity = true
                    else
                        conflictingPackages.add(candidatePackage)' @ [101:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any, elseBranch: Any): Any[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any

'candidatePackage' @ [101:25] ==> value-parameter candidatePackage: String defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.findPotentialClassConflicts.<anonymous>[ValueParameterDescriptorImpl]

'forceAmbiguity' @ [102:25] ==> private final var forceAmbiguity: Boolean defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'conflictingPackages' @ [104:25] ==> private final val conflictingPackages: MutableList<String> defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'add' @ [104:45] ==> public abstract fun add(element: String): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'candidatePackage' @ [104:49] ==> value-parameter candidatePackage: String defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.findPotentialClassConflicts.<anonymous>[ValueParameterDescriptorImpl]

'getInstance' @ [111:56] ==> public open fun getInstance(): (KotlinTypeAliasShortNameIndex..KotlinTypeAliasShortNameIndex?) defined in org.jetbrains.kotlin.idea.stubindex.KotlinTypeAliasShortNameIndex[JavaMethodDescriptor]

'get' @ [111:70] ==> @NotNull @Override public open fun get(@NotNull s: String, @NotNull project: Project, @NotNull scope: GlobalSearchScope): (MutableCollection<(KtTypeAlias..KtTypeAlias?)>..Collection<(KtTypeAlias..KtTypeAlias?)>) defined in org.jetbrains.kotlin.idea.stubindex.KotlinTypeAliasShortNameIndex[JavaMethodDescriptor]

'targetShortName' @ [111:74] ==> private final val targetShortName: String defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'target' @ [111:91] ==> value-parameter target: PsiClass defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.findPotentialTypeAliasConflicts[ValueParameterDescriptorImpl]

'project' @ [111:98] ==> public final val PsiClass.project: Project[MyPropertyDescriptor]

'target' @ [111:107] ==> value-parameter target: PsiClass defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.findPotentialTypeAliasConflicts[ValueParameterDescriptorImpl]

'project' @ [111:114] ==> public final val PsiClass.project: Project[MyPropertyDescriptor]

'allScope' @ [111:122] ==> public fun Project.allScope(): GlobalSearchScope defined in org.jetbrains.kotlin.idea.search in file searchUtil.kt[SimpleFunctionDescriptorImpl]

'candidates' @ [112:27] ==> val candidates: (MutableCollection<(KtTypeAlias..KtTypeAlias?)>..Collection<(KtTypeAlias..KtTypeAlias?)>) defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.findPotentialTypeAliasConflicts[LocalVariableDescriptor]

'packagesWithTypeAliases' @ [113:13] ==> private final val packagesWithTypeAliases: MutableList<String> defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'add' @ [113:37] ==> public abstract fun add(element: String): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'candidate' @ [113:41] ==> val candidate: (KtTypeAlias..KtTypeAlias?) defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.findPotentialTypeAliasConflicts[LocalVariableDescriptor]

'containingKtFile' @ [113:51] ==> public final val KtTypeAlias.containingKtFile: KtFile[MyPropertyDescriptor]

'packageFqName' @ [113:68] ==> public final val KtFile.packageFqName: FqName[MyPropertyDescriptor]

'asString' @ [113:82] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'TestOnly' @ [117:5] ==> public constructor TestOnly() defined in org.jetbrains.annotations.TestOnly[JavaClassConstructorDescriptor]

'conflictingPackages' @ [118:9] ==> private final val conflictingPackages: MutableList<String> defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'add' @ [118:29] ==> public abstract fun add(element: String): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'fqName' @ [118:33] ==> value-parameter fqName: String defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.addConflict[ValueParameterDescriptorImpl]

'substringBeforeLast' @ [118:40] ==> public fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'attempts' @ [129:9] ==> @TestOnly public final val attempts: AtomicInteger defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Companion[PropertyDescriptorImpl]

'incrementAndGet' @ [129:18] ==> public final fun incrementAndGet(): Int defined in java.util.concurrent.atomic.AtomicInteger[JavaMethodDescriptor]

'ref' @ [131:13] ==> value-parameter ref: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[ValueParameterDescriptorImpl]

'getReferencedName' @ [131:17] ==> public abstract fun getReferencedName(): String defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[DeserializedSimpleFunctionDescriptor]

'targetShortName' @ [131:40] ==> private final val targetShortName: String defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'UNSURE' @ [132:20] ==> enum entry UNSURE defined in org.jetbrains.kotlin.asJava.ImpreciseResolveResult[FakeCallableDescriptorForObject]

'ref' @ [137:24] ==> value-parameter ref: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[ValueParameterDescriptorImpl]

'getStrictParentOfType' @ [137:28] ==> public inline fun <reified T : PsiElement> PsiElement.getStrictParentOfType(): KtUserType? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtUserType

'UNSURE' @ [137:74] ==> enum entry UNSURE defined in org.jetbrains.kotlin.asJava.ImpreciseResolveResult[FakeCallableDescriptorForObject]

'forceAmbiguityForNonAnnotations' @ [138:13] ==> private final var forceAmbiguityForNonAnnotations: Boolean defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'userType' @ [138:48] ==> val userType: KtUserType defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'getParentOfTypeAndBranch' @ [138:57] ==> public inline fun <reified T : PsiElement> PsiElement.getParentOfTypeAndBranch(strict: Boolean = ..., noinline branch: KtAnnotationEntry.() -> PsiElement?): KtAnnotationEntry? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtAnnotationEntry

'typeReference' @ [138:103] ==> public final val KtAnnotationEntry.typeReference: KtTypeReference?[MyPropertyDescriptor]

'UNSURE' @ [139:20] ==> enum entry UNSURE defined in org.jetbrains.kotlin.asJava.ImpreciseResolveResult[FakeCallableDescriptorForObject]

'forceAmbiguity' @ [142:13] ==> private final var forceAmbiguity: Boolean defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'UNSURE' @ [143:20] ==> enum entry UNSURE defined in org.jetbrains.kotlin.asJava.ImpreciseResolveResult[FakeCallableDescriptorForObject]

'checkQualifiedReferenceToTarget' @ [146:36] ==> private final fun checkQualifiedReferenceToTarget(ref: KtSimpleNameExpression): PsiBasedClassResolver.Result? defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[SimpleFunctionDescriptorImpl]

'ref' @ [146:68] ==> value-parameter ref: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[ValueParameterDescriptorImpl]

'qualifiedCheckResult' @ [147:13] ==> val qualifiedCheckResult: PsiBasedClassResolver.Result? defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'qualifiedCheckResult' @ [148:20] ==> val qualifiedCheckResult: PsiBasedClassResolver.Result? defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'returnValue' @ [148:41] ==> public final val returnValue: ImpreciseResolveResult defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[PropertyDescriptorImpl]

'ref' @ [151:20] ==> value-parameter ref: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[ValueParameterDescriptorImpl]

'containingKtFile' @ [151:24] ==> public final val KtSimpleNameExpression.containingKtFile: KtFile[MyPropertyDescriptor]

'NothingFound' @ [152:37] ==> enum entry NothingFound defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[FakeCallableDescriptorForObject]

'file' @ [153:27] ==> val file: KtFile defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'packageFqName' @ [153:32] ==> public final val KtFile.packageFqName: FqName[MyPropertyDescriptor]

'asString' @ [153:46] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'when (filePackage) {
            targetPackage -> result = result.changeTo(Result.Found)
            in conflictingPackages -> result = result.changeTo(Result.FoundOther)
            in packagesWithTypeAliases -> return UNSURE
        }' @ [154:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'filePackage' @ [154:15] ==> val filePackage: String defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'targetPackage' @ [155:13] ==> private final val targetPackage: String defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'result' @ [155:30] ==> var result: PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'result' @ [155:39] ==> var result: PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'changeTo' @ [155:46] ==> private final fun PsiBasedClassResolver.Result.changeTo(newResult: PsiBasedClassResolver.Result): PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[SimpleFunctionDescriptorImpl]

'Found' @ [155:62] ==> enum entry Found defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[FakeCallableDescriptorForObject]

'in' @ [156:13] ==> public abstract fun contains(element: String): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'conflictingPackages' @ [156:16] ==> private final val conflictingPackages: MutableList<String> defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'result' @ [156:39] ==> var result: PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'result' @ [156:48] ==> var result: PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'changeTo' @ [156:55] ==> private final fun PsiBasedClassResolver.Result.changeTo(newResult: PsiBasedClassResolver.Result): PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[SimpleFunctionDescriptorImpl]

'FoundOther' @ [156:71] ==> enum entry FoundOther defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[FakeCallableDescriptorForObject]

'in' @ [157:13] ==> public abstract fun contains(element: String): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'packagesWithTypeAliases' @ [157:16] ==> private final val packagesWithTypeAliases: MutableList<String> defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'UNSURE' @ [157:50] ==> enum entry UNSURE defined in org.jetbrains.kotlin.asJava.ImpreciseResolveResult[FakeCallableDescriptorForObject]

'file' @ [160:28] ==> val file: KtFile defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'getDefaultImports' @ [160:33] ==> private fun KtFile.getDefaultImports(): List<ImportPath> defined in org.jetbrains.kotlin.idea.search[SimpleFunctionDescriptorImpl]

'result' @ [161:13] ==> var result: PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'analyzeSingleImport' @ [161:22] ==> private final fun analyzeSingleImport(result: PsiBasedClassResolver.Result, importedFqName: FqName?, isAllUnder: Boolean, aliasName: String?): PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[SimpleFunctionDescriptorImpl]

'result' @ [161:42] ==> var result: PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'importPath' @ [161:50] ==> val importPath: ImportPath defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'fqName' @ [161:61] ==> public final val fqName: FqName defined in org.jetbrains.kotlin.resolve.ImportPath[DeserializedPropertyDescriptor]

'importPath' @ [161:69] ==> val importPath: ImportPath defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'isAllUnder' @ [161:80] ==> public final val isAllUnder: Boolean defined in org.jetbrains.kotlin.resolve.ImportPath[DeserializedPropertyDescriptor]

'importPath' @ [161:92] ==> val importPath: ImportPath defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'alias' @ [161:103] ==> public final val alias: Name? defined in org.jetbrains.kotlin.resolve.ImportPath[DeserializedPropertyDescriptor]

'asString' @ [161:110] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'result' @ [162:17] ==> var result: PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'Ambiguity' @ [162:34] ==> enum entry Ambiguity defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[FakeCallableDescriptorForObject]

'UNSURE' @ [162:52] ==> enum entry UNSURE defined in org.jetbrains.kotlin.asJava.ImpreciseResolveResult[FakeCallableDescriptorForObject]

'file' @ [165:33] ==> val file: KtFile defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'importDirectives' @ [165:38] ==> public final val KtFile.importDirectives: (MutableList<(KtImportDirective..KtImportDirective?)>..List<(KtImportDirective..KtImportDirective?)>)[MyPropertyDescriptor]

'result' @ [166:13] ==> var result: PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'analyzeSingleImport' @ [166:22] ==> private final fun analyzeSingleImport(result: PsiBasedClassResolver.Result, importedFqName: FqName?, isAllUnder: Boolean, aliasName: String?): PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[SimpleFunctionDescriptorImpl]

'result' @ [166:42] ==> var result: PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'importDirective' @ [166:50] ==> val importDirective: (KtImportDirective..KtImportDirective?) defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'importedFqName' @ [166:66] ==> public final val KtImportDirective.importedFqName: FqName?[MyPropertyDescriptor]

'importDirective' @ [166:82] ==> val importDirective: (KtImportDirective..KtImportDirective?) defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'isAllUnder' @ [166:98] ==> public final val KtImportDirective.isAllUnder: Boolean[MyPropertyDescriptor]

'importDirective' @ [166:110] ==> val importDirective: (KtImportDirective..KtImportDirective?) defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'aliasName' @ [166:126] ==> public final val KtImportDirective.aliasName: String?[MyPropertyDescriptor]

'result' @ [167:17] ==> var result: PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'Ambiguity' @ [167:34] ==> enum entry Ambiguity defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[FakeCallableDescriptorForObject]

'UNSURE' @ [167:52] ==> enum entry UNSURE defined in org.jetbrains.kotlin.asJava.ImpreciseResolveResult[FakeCallableDescriptorForObject]

'if (result.returnValue == MATCH) {
            trueHits.incrementAndGet()
        }
        else if (result.returnValue == NO_MATCH) {
            falseHits.incrementAndGet()
        }' @ [170:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any, elseBranch: Any): Any[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any

'result' @ [170:13] ==> var result: PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'returnValue' @ [170:20] ==> public final val returnValue: ImpreciseResolveResult defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[PropertyDescriptorImpl]

'MATCH' @ [170:35] ==> enum entry MATCH defined in org.jetbrains.kotlin.asJava.ImpreciseResolveResult[FakeCallableDescriptorForObject]

'trueHits' @ [171:13] ==> @TestOnly public final val trueHits: AtomicInteger defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Companion[PropertyDescriptorImpl]

'incrementAndGet' @ [171:22] ==> public final fun incrementAndGet(): Int defined in java.util.concurrent.atomic.AtomicInteger[JavaMethodDescriptor]

'result' @ [173:18] ==> var result: PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'returnValue' @ [173:25] ==> public final val returnValue: ImpreciseResolveResult defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[PropertyDescriptorImpl]

'NO_MATCH' @ [173:40] ==> enum entry NO_MATCH defined in org.jetbrains.kotlin.asJava.ImpreciseResolveResult[FakeCallableDescriptorForObject]

'falseHits' @ [174:13] ==> @TestOnly public final val falseHits: AtomicInteger defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Companion[PropertyDescriptorImpl]

'incrementAndGet' @ [174:23] ==> public final fun incrementAndGet(): Int defined in java.util.concurrent.atomic.AtomicInteger[JavaMethodDescriptor]

'result' @ [176:16] ==> var result: PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.canBeTargetReference[LocalVariableDescriptor]

'returnValue' @ [176:23] ==> public final val returnValue: ImpreciseResolveResult defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[PropertyDescriptorImpl]

'if (!isAllUnder) {
            if (importedFqName?.asString() == targetClassFqName &&
                (aliasName == null || aliasName == targetShortName)) {
                return result.changeTo(Result.Found)
            }
            else if (importedFqName?.shortName()?.asString() == targetShortName &&
                     importedFqName.parent().asString() in conflictingPackages &&
                     aliasName == null) {
                return result.changeTo(Result.FoundOther)
            }
            else if (importedFqName?.shortName()?.asString() == targetShortName &&
                     importedFqName.parent().asString() in packagesWithTypeAliases &&
                     aliasName == null) {
                return Result.Ambiguity
            }
            else if (aliasName == targetShortName) {
                return result.changeTo(Result.FoundOther)
            }
        }
        else {
            when {
                importedFqName?.asString() == targetPackage -> return result.changeTo(Result.Found)
                importedFqName?.asString() in conflictingPackages -> return result.changeTo(Result.FoundOther)
                importedFqName?.asString() in packagesWithTypeAliases -> return Result.Ambiguity
            }
        }' @ [180:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'!' @ [180:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isAllUnder' @ [180:14] ==> value-parameter isAllUnder: Boolean defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.analyzeSingleImport[ValueParameterDescriptorImpl]

'if (importedFqName?.asString() == targetClassFqName &&
                (aliasName == null || aliasName == targetShortName)) {
                return result.changeTo(Result.Found)
            }
            else if (importedFqName?.shortName()?.asString() == targetShortName &&
                     importedFqName.parent().asString() in conflictingPackages &&
                     aliasName == null) {
                return result.changeTo(Result.FoundOther)
            }
            else if (importedFqName?.shortName()?.asString() == targetShortName &&
                     importedFqName.parent().asString() in packagesWithTypeAliases &&
                     aliasName == null) {
                return Result.Ambiguity
            }
            else if (aliasName == targetShortName) {
                return result.changeTo(Result.FoundOther)
            }' @ [181:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'importedFqName' @ [181:17] ==> value-parameter importedFqName: FqName? defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.analyzeSingleImport[ValueParameterDescriptorImpl]

'asString' @ [181:33] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'targetClassFqName' @ [181:47] ==> private final val targetClassFqName: String defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'aliasName' @ [182:18] ==> value-parameter aliasName: String? defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.analyzeSingleImport[ValueParameterDescriptorImpl]

'aliasName' @ [182:39] ==> value-parameter aliasName: String? defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.analyzeSingleImport[ValueParameterDescriptorImpl]

'targetShortName' @ [182:52] ==> private final val targetShortName: String defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'result' @ [183:24] ==> value-parameter result: PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.analyzeSingleImport[ValueParameterDescriptorImpl]

'changeTo' @ [183:31] ==> private final fun PsiBasedClassResolver.Result.changeTo(newResult: PsiBasedClassResolver.Result): PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[SimpleFunctionDescriptorImpl]

'Found' @ [183:47] ==> enum entry Found defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[FakeCallableDescriptorForObject]

'if (importedFqName?.shortName()?.asString() == targetShortName &&
                     importedFqName.parent().asString() in conflictingPackages &&
                     aliasName == null) {
                return result.changeTo(Result.FoundOther)
            }
            else if (importedFqName?.shortName()?.asString() == targetShortName &&
                     importedFqName.parent().asString() in packagesWithTypeAliases &&
                     aliasName == null) {
                return Result.Ambiguity
            }
            else if (aliasName == targetShortName) {
                return result.changeTo(Result.FoundOther)
            }' @ [185:18] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'importedFqName' @ [185:22] ==> value-parameter importedFqName: FqName? defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.analyzeSingleImport[ValueParameterDescriptorImpl]

'shortName' @ [185:38] ==> @NotNull public open fun shortName(): Name defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'asString' @ [185:51] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'targetShortName' @ [185:65] ==> private final val targetShortName: String defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'importedFqName' @ [186:22] ==> value-parameter importedFqName: FqName? defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.analyzeSingleImport[ValueParameterDescriptorImpl]

'parent' @ [186:37] ==> @NotNull public open fun parent(): FqName defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'asString' @ [186:46] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'conflictingPackages' @ [186:60] ==> private final val conflictingPackages: MutableList<String> defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'aliasName' @ [187:22] ==> value-parameter aliasName: String? defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.analyzeSingleImport[ValueParameterDescriptorImpl]

'result' @ [188:24] ==> value-parameter result: PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.analyzeSingleImport[ValueParameterDescriptorImpl]

'changeTo' @ [188:31] ==> private final fun PsiBasedClassResolver.Result.changeTo(newResult: PsiBasedClassResolver.Result): PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[SimpleFunctionDescriptorImpl]

'FoundOther' @ [188:47] ==> enum entry FoundOther defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[FakeCallableDescriptorForObject]

'if (importedFqName?.shortName()?.asString() == targetShortName &&
                     importedFqName.parent().asString() in packagesWithTypeAliases &&
                     aliasName == null) {
                return Result.Ambiguity
            }
            else if (aliasName == targetShortName) {
                return result.changeTo(Result.FoundOther)
            }' @ [190:18] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'importedFqName' @ [190:22] ==> value-parameter importedFqName: FqName? defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.analyzeSingleImport[ValueParameterDescriptorImpl]

'shortName' @ [190:38] ==> @NotNull public open fun shortName(): Name defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'asString' @ [190:51] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'targetShortName' @ [190:65] ==> private final val targetShortName: String defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'importedFqName' @ [191:22] ==> value-parameter importedFqName: FqName? defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.analyzeSingleImport[ValueParameterDescriptorImpl]

'parent' @ [191:37] ==> @NotNull public open fun parent(): FqName defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'asString' @ [191:46] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'packagesWithTypeAliases' @ [191:60] ==> private final val packagesWithTypeAliases: MutableList<String> defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'aliasName' @ [192:22] ==> value-parameter aliasName: String? defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.analyzeSingleImport[ValueParameterDescriptorImpl]

'Ambiguity' @ [193:31] ==> enum entry Ambiguity defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[FakeCallableDescriptorForObject]

'aliasName' @ [195:22] ==> value-parameter aliasName: String? defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.analyzeSingleImport[ValueParameterDescriptorImpl]

'targetShortName' @ [195:35] ==> private final val targetShortName: String defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'result' @ [196:24] ==> value-parameter result: PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.analyzeSingleImport[ValueParameterDescriptorImpl]

'changeTo' @ [196:31] ==> private final fun PsiBasedClassResolver.Result.changeTo(newResult: PsiBasedClassResolver.Result): PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[SimpleFunctionDescriptorImpl]

'FoundOther' @ [196:47] ==> enum entry FoundOther defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[FakeCallableDescriptorForObject]

'when {
                importedFqName?.asString() == targetPackage -> return result.changeTo(Result.Found)
                importedFqName?.asString() in conflictingPackages -> return result.changeTo(Result.FoundOther)
                importedFqName?.asString() in packagesWithTypeAliases -> return Result.Ambiguity
            }' @ [200:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'importedFqName' @ [201:17] ==> value-parameter importedFqName: FqName? defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.analyzeSingleImport[ValueParameterDescriptorImpl]

'asString' @ [201:33] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'targetPackage' @ [201:47] ==> private final val targetPackage: String defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'result' @ [201:71] ==> value-parameter result: PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.analyzeSingleImport[ValueParameterDescriptorImpl]

'changeTo' @ [201:78] ==> private final fun PsiBasedClassResolver.Result.changeTo(newResult: PsiBasedClassResolver.Result): PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[SimpleFunctionDescriptorImpl]

'Found' @ [201:94] ==> enum entry Found defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[FakeCallableDescriptorForObject]

'importedFqName' @ [202:17] ==> value-parameter importedFqName: FqName? defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.analyzeSingleImport[ValueParameterDescriptorImpl]

'asString' @ [202:33] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'conflictingPackages' @ [202:47] ==> private final val conflictingPackages: MutableList<String> defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'result' @ [202:77] ==> value-parameter result: PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.analyzeSingleImport[ValueParameterDescriptorImpl]

'changeTo' @ [202:84] ==> private final fun PsiBasedClassResolver.Result.changeTo(newResult: PsiBasedClassResolver.Result): PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[SimpleFunctionDescriptorImpl]

'FoundOther' @ [202:100] ==> enum entry FoundOther defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[FakeCallableDescriptorForObject]

'importedFqName' @ [203:17] ==> value-parameter importedFqName: FqName? defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.analyzeSingleImport[ValueParameterDescriptorImpl]

'asString' @ [203:33] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'packagesWithTypeAliases' @ [203:47] ==> private final val packagesWithTypeAliases: MutableList<String> defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'Ambiguity' @ [203:88] ==> enum entry Ambiguity defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[FakeCallableDescriptorForObject]

'result' @ [206:16] ==> value-parameter result: PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.analyzeSingleImport[ValueParameterDescriptorImpl]

'ref' @ [213:26] ==> value-parameter ref: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.checkQualifiedReferenceToTarget[ValueParameterDescriptorImpl]

'parent' @ [213:30] ==> public final val KtSimpleNameExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'qualifier' @ [213:54] ==> public final val KtUserType.qualifier: KtUserType?[MyPropertyDescriptor]

'qualifier' @ [214:13] ==> val qualifier: KtUserType? defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.checkQualifiedReferenceToTarget[LocalVariableDescriptor]

'qualifier' @ [215:17] ==> val qualifier: KtUserType? defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.checkQualifiedReferenceToTarget[LocalVariableDescriptor]

'text' @ [215:27] ==> public final val KtUserType.text: (String..String?)[MyPropertyDescriptor]

'targetPackage' @ [215:35] ==> private final val targetPackage: String defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver[PropertyDescriptorImpl]

'Ambiguity' @ [215:64] ==> enum entry Ambiguity defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[FakeCallableDescriptorForObject]

'FoundOther' @ [216:27] ==> enum entry FoundOther defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[FakeCallableDescriptorForObject]

'' @ [222:21] ==> private constructor Result(returnValue: ImpreciseResolveResult) defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[ClassConstructorDescriptorImpl]

'NO_MATCH' @ [222:22] ==> enum entry NO_MATCH defined in org.jetbrains.kotlin.asJava.ImpreciseResolveResult[FakeCallableDescriptorForObject]

'' @ [223:14] ==> private constructor Result(returnValue: ImpreciseResolveResult) defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[ClassConstructorDescriptorImpl]

'MATCH' @ [223:15] ==> enum entry MATCH defined in org.jetbrains.kotlin.asJava.ImpreciseResolveResult[FakeCallableDescriptorForObject]

'' @ [224:19] ==> private constructor Result(returnValue: ImpreciseResolveResult) defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[ClassConstructorDescriptorImpl]

'NO_MATCH' @ [224:20] ==> enum entry NO_MATCH defined in org.jetbrains.kotlin.asJava.ImpreciseResolveResult[FakeCallableDescriptorForObject]

'' @ [225:18] ==> private constructor Result(returnValue: ImpreciseResolveResult) defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[ClassConstructorDescriptorImpl]

'UNSURE' @ [225:19] ==> enum entry UNSURE defined in org.jetbrains.kotlin.asJava.ImpreciseResolveResult[FakeCallableDescriptorForObject]

'this' @ [229:13] ==> <this> defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.changeTo[ReceiverParameterDescriptorImpl]

'NothingFound' @ [229:28] ==> enum entry NothingFound defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[FakeCallableDescriptorForObject]

'this' @ [229:44] ==> <this> defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.changeTo[ReceiverParameterDescriptorImpl]

'returnValue' @ [229:49] ==> public final val returnValue: ImpreciseResolveResult defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[PropertyDescriptorImpl]

'newResult' @ [229:64] ==> value-parameter newResult: PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.changeTo[ValueParameterDescriptorImpl]

'returnValue' @ [229:74] ==> public final val returnValue: ImpreciseResolveResult defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[PropertyDescriptorImpl]

'newResult' @ [230:20] ==> value-parameter newResult: PsiBasedClassResolver.Result defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.changeTo[ValueParameterDescriptorImpl]

'Ambiguity' @ [232:23] ==> enum entry Ambiguity defined in org.jetbrains.kotlin.idea.search.PsiBasedClassResolver.Result[FakeCallableDescriptorForObject]

'getNullableModuleInfo' @ [237:22] ==> public fun PsiElement.getNullableModuleInfo(): IdeaModuleInfo? defined in org.jetbrains.kotlin.idea.caches.resolve in file getModuleInfo.kt[SimpleFunctionDescriptorImpl]

'emptyList' @ [237:56] ==> public fun <T> emptyList(): List<ImportPath> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ImportPath

'IDELanguageSettingsProvider' @ [238:27] ==> public object IDELanguageSettingsProvider : LanguageSettingsProvider defined in org.jetbrains.kotlin.idea.compiler in file IDELanguageSettingsProvider.kt[FakeCallableDescriptorForObject]

'getLanguageVersionSettings' @ [238:55] ==> public open fun getLanguageVersionSettings(moduleInfo: ModuleInfo, project: Project): LanguageVersionSettings defined in org.jetbrains.kotlin.idea.compiler.IDELanguageSettingsProvider[SimpleFunctionDescriptorImpl]

'moduleInfo' @ [238:82] ==> val moduleInfo: IdeaModuleInfo defined in org.jetbrains.kotlin.idea.search.getDefaultImports[LocalVariableDescriptor]

'project' @ [238:94] ==> public final val KtFile.project: Project[MyPropertyDescriptor]

'getPlatform' @ [239:35] ==> @NotNull public open fun getPlatform(@NotNull file: KtFile): TargetPlatform defined in org.jetbrains.kotlin.idea.project.TargetPlatformDetector[JavaMethodDescriptor]

'this' @ [239:47] ==> <this> defined in org.jetbrains.kotlin.idea.search.getDefaultImports[ReceiverParameterDescriptorImpl]

'getDefaultImports' @ [239:53] ==> public abstract fun getDefaultImports(includeKotlinComparisons: Boolean): List<ImportPath> defined in org.jetbrains.kotlin.resolve.TargetPlatform[DeserializedSimpleFunctionDescriptor]

'versionSettings' @ [240:13] ==> val versionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.idea.search.getDefaultImports[LocalVariableDescriptor]

'supportsFeature' @ [240:29] ==> public open fun supportsFeature(feature: LanguageFeature): Boolean defined in org.jetbrains.kotlin.config.LanguageVersionSettings[DeserializedSimpleFunctionDescriptor]

'LanguageFeature' @ [240:45] ==> public companion object defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'DefaultImportOfPackageKotlinComparisons' @ [240:61] ==> enum entry DefaultImportOfPackageKotlinComparisons defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

