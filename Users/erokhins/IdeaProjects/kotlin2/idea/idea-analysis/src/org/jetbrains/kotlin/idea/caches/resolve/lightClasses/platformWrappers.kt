'JavaToKotlinClassMap' @ [46:49] ==> public object JavaToKotlinClassMap : PlatformToKotlinClassMap defined in org.jetbrains.kotlin.platform[FakeCallableDescriptorForObject]

'mutabilityMappings' @ [46:70] ==> public final val mutabilityMappings: List<JavaToKotlinClassMap.PlatformMutabilityMapping> defined in org.jetbrains.kotlin.platform.JavaToKotlinClassMap[DeserializedPropertyDescriptor]

'associateBy' @ [46:89] ==> public inline fun <T, K> Iterable<JavaToKotlinClassMap.PlatformMutabilityMapping>.associateBy(keySelector: (JavaToKotlinClassMap.PlatformMutabilityMapping) -> FqName): Map<FqName, JavaToKotlinClassMap.PlatformMutabilityMapping> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PlatformMutabilityMapping
    <K> -> FqName

'component1' @ [47:6] ==> public final operator fun component1(): ClassId defined in org.jetbrains.kotlin.platform.JavaToKotlinClassMap.PlatformMutabilityMapping[DeserializedSimpleFunctionDescriptor]

'component2' @ [47:9] ==> public final operator fun component2(): ClassId defined in org.jetbrains.kotlin.platform.JavaToKotlinClassMap.PlatformMutabilityMapping[DeserializedSimpleFunctionDescriptor]

'component3' @ [47:19] ==> public final operator fun component3(): ClassId defined in org.jetbrains.kotlin.platform.JavaToKotlinClassMap.PlatformMutabilityMapping[DeserializedSimpleFunctionDescriptor]

'readOnly' @ [48:5] ==> val readOnly: ClassId defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.readOnlyQualifiedNamesToJavaClass.<anonymous>[LocalVariableDescriptor]

'asSingleFqName' @ [48:14] ==> @NotNull public open fun asSingleFqName(): FqName defined in org.jetbrains.kotlin.name.ClassId[JavaMethodDescriptor]

'JavaToKotlinClassMap' @ [51:48] ==> public object JavaToKotlinClassMap : PlatformToKotlinClassMap defined in org.jetbrains.kotlin.platform[FakeCallableDescriptorForObject]

'mutabilityMappings' @ [51:69] ==> public final val mutabilityMappings: List<JavaToKotlinClassMap.PlatformMutabilityMapping> defined in org.jetbrains.kotlin.platform.JavaToKotlinClassMap[DeserializedPropertyDescriptor]

'associateBy' @ [51:88] ==> public inline fun <T, K> Iterable<JavaToKotlinClassMap.PlatformMutabilityMapping>.associateBy(keySelector: (JavaToKotlinClassMap.PlatformMutabilityMapping) -> FqName): Map<FqName, JavaToKotlinClassMap.PlatformMutabilityMapping> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PlatformMutabilityMapping
    <K> -> FqName

'component1' @ [52:6] ==> public final operator fun component1(): ClassId defined in org.jetbrains.kotlin.platform.JavaToKotlinClassMap.PlatformMutabilityMapping[DeserializedSimpleFunctionDescriptor]

'component2' @ [52:9] ==> public final operator fun component2(): ClassId defined in org.jetbrains.kotlin.platform.JavaToKotlinClassMap.PlatformMutabilityMapping[DeserializedSimpleFunctionDescriptor]

'component3' @ [52:12] ==> public final operator fun component3(): ClassId defined in org.jetbrains.kotlin.platform.JavaToKotlinClassMap.PlatformMutabilityMapping[DeserializedSimpleFunctionDescriptor]

'mutable' @ [53:5] ==> val mutable: ClassId defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.mutableQualifiedNamesToJavaClass.<anonymous>[LocalVariableDescriptor]

'asSingleFqName' @ [53:13] ==> @NotNull public open fun asSingleFqName(): FqName defined in org.jetbrains.kotlin.name.ClassId[JavaMethodDescriptor]

'BuiltinMethodsWithSpecialGenericSignature' @ [57:9] ==> public object BuiltinMethodsWithSpecialGenericSignature defined in org.jetbrains.kotlin.load.java[FakeCallableDescriptorForObject]

'ERASED_VALUE_PARAMETERS_SIGNATURES' @ [57:51] ==> public final val ERASED_VALUE_PARAMETERS_SIGNATURES: Set<String> defined in org.jetbrains.kotlin.load.java.BuiltinMethodsWithSpecialGenericSignature[DeserializedPropertyDescriptor]

'mapTo' @ [57:86] ==> public inline fun <T, R, C : MutableCollection<in String>> Iterable<String>.mapTo(destination: LinkedHashSet<String> /* = LinkedHashSet<String> */, transform: (String) -> String): LinkedHashSet<String> /* = LinkedHashSet<String> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String
    <R> -> String
    <C : MutableCollection<in R>> -> LinkedHashSet<String>

'LinkedHashSet' @ [57:92] ==> public final fun <E> <init>(): LinkedHashSet<String> /* = LinkedHashSet<String> */ defined in kotlin.collections.LinkedHashSet[TypeAliasConstructorDescriptorImpl]
Inferred types:
    <E> -> String

'it' @ [58:32] ==> value-parameter it: String defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.membersWithSpecializedSignature.<anonymous>[ValueParameterDescriptorImpl]

'substringBefore' @ [58:35] ==> public fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'replace' @ [58:56] ==> public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'FqName' @ [59:13] ==> public constructor FqName(@NotNull p0: String) defined in org.jetbrains.kotlin.name.FqName[JavaClassConstructorDescriptor]

'fqNameString' @ [59:20] ==> val fqNameString: String defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.membersWithSpecializedSignature.<anonymous>[LocalVariableDescriptor]

'shortName' @ [59:34] ==> @NotNull public open fun shortName(): Name defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'asString' @ [59:46] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'BuiltinSpecialProperties' @ [62:69] ==> public object BuiltinSpecialProperties defined in org.jetbrains.kotlin.load.java[FakeCallableDescriptorForObject]

'PROPERTY_FQ_NAME_TO_JVM_GETTER_NAME_MAP' @ [62:94] ==> public final val PROPERTY_FQ_NAME_TO_JVM_GETTER_NAME_MAP: Map<FqName, Name> defined in org.jetbrains.kotlin.load.java.BuiltinSpecialProperties[DeserializedPropertyDescriptor]

'map' @ [62:134] ==> public inline fun <K, V, R> Map<out FqName, Name>.map(transform: (Map.Entry<FqName, Name>) -> Pair<String, String>): List<Pair<String, String>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> FqName
    <V> -> Name
    <R> -> Pair<String, String>

'component1' @ [63:6] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<FqName, Name>.component1(): FqName defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> FqName
    <V> -> Name

'component2' @ [63:22] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<FqName, Name>.component2(): Name defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> FqName
    <V> -> Name

'Pair' @ [64:5] ==> public constructor Pair<out A, out B>(first: String, second: String) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> String
    <out B> -> String

'javaGetterShortName' @ [64:10] ==> val javaGetterShortName: Name defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.javaGetterNameToKotlinGetterName.<anonymous>[LocalVariableDescriptor]

'asString' @ [64:30] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'getterName' @ [64:49] ==> @NotNull public open fun getterName(@NotNull p0: String): String defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaMethodDescriptor]

'propertyFqName' @ [64:60] ==> val propertyFqName: FqName defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.javaGetterNameToKotlinGetterName.<anonymous>[LocalVariableDescriptor]

'shortName' @ [64:75] ==> @NotNull public open fun shortName(): Name defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'asString' @ [64:87] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'toMap' @ [65:3] ==> public fun <K, V> Iterable<Pair<String, String>>.toMap(): Map<String, String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> String
    <V> -> String

'readOnlyQualifiedNamesToJavaClass' @ [68:5] ==> private val readOnlyQualifiedNamesToJavaClass: Map<FqName, JavaToKotlinClassMap.PlatformMutabilityMapping> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses in file platformWrappers.kt[PropertyDescriptorImpl]

'fqName' @ [68:39] ==> value-parameter fqName: FqName defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.platformMutabilityWrapper[ValueParameterDescriptorImpl]

'let' @ [68:48] ==> @InlineOnly public inline fun <T, R> JavaToKotlinClassMap.PlatformMutabilityMapping.let(block: (JavaToKotlinClassMap.PlatformMutabilityMapping) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PlatformMutabilityMapping
    <R> -> Nothing

'component1' @ [69:10] ==> public final operator fun component1(): ClassId defined in org.jetbrains.kotlin.platform.JavaToKotlinClassMap.PlatformMutabilityMapping[DeserializedSimpleFunctionDescriptor]

'component2' @ [69:21] ==> public final operator fun component2(): ClassId defined in org.jetbrains.kotlin.platform.JavaToKotlinClassMap.PlatformMutabilityMapping[DeserializedSimpleFunctionDescriptor]

'invoke' @ [70:29] ==> public abstract operator fun invoke(p1: String): PsiClass? defined in kotlin.Function1[FunctionInvokeDescriptor]

'javaClass' @ [70:43] ==> val javaClass: ClassId defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.platformMutabilityWrapper.<anonymous>[LocalVariableDescriptor]

'asSingleFqName' @ [70:53] ==> @NotNull public open fun asSingleFqName(): FqName defined in org.jetbrains.kotlin.name.ClassId[JavaMethodDescriptor]

'asString' @ [70:70] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'getOrCreateWrapper' @ [71:16] ==> private fun getOrCreateWrapper(javaBaseClass: PsiClass, kotlinFqName: FqName, isMutable: Boolean): KtLightMutabilityPlatformWrapper defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses in file platformWrappers.kt[SimpleFunctionDescriptorImpl]

'javaBaseClass' @ [71:35] ==> val javaBaseClass: PsiClass defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.platformMutabilityWrapper.<anonymous>[LocalVariableDescriptor]

'kotlinReadOnly' @ [71:50] ==> val kotlinReadOnly: ClassId defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.platformMutabilityWrapper.<anonymous>[LocalVariableDescriptor]

'asSingleFqName' @ [71:65] ==> @NotNull public open fun asSingleFqName(): FqName defined in org.jetbrains.kotlin.name.ClassId[JavaMethodDescriptor]

'mutableQualifiedNamesToJavaClass' @ [73:5] ==> private val mutableQualifiedNamesToJavaClass: Map<FqName, JavaToKotlinClassMap.PlatformMutabilityMapping> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses in file platformWrappers.kt[PropertyDescriptorImpl]

'fqName' @ [73:38] ==> value-parameter fqName: FqName defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.platformMutabilityWrapper[ValueParameterDescriptorImpl]

'let' @ [73:47] ==> @InlineOnly public inline fun <T, R> JavaToKotlinClassMap.PlatformMutabilityMapping.let(block: (JavaToKotlinClassMap.PlatformMutabilityMapping) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PlatformMutabilityMapping
    <R> -> Nothing

'component1' @ [74:10] ==> public final operator fun component1(): ClassId defined in org.jetbrains.kotlin.platform.JavaToKotlinClassMap.PlatformMutabilityMapping[DeserializedSimpleFunctionDescriptor]

'component2' @ [74:21] ==> public final operator fun component2(): ClassId defined in org.jetbrains.kotlin.platform.JavaToKotlinClassMap.PlatformMutabilityMapping[DeserializedSimpleFunctionDescriptor]

'component3' @ [74:24] ==> public final operator fun component3(): ClassId defined in org.jetbrains.kotlin.platform.JavaToKotlinClassMap.PlatformMutabilityMapping[DeserializedSimpleFunctionDescriptor]

'invoke' @ [75:29] ==> public abstract operator fun invoke(p1: String): PsiClass? defined in kotlin.Function1[FunctionInvokeDescriptor]

'javaClass' @ [75:43] ==> val javaClass: ClassId defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.platformMutabilityWrapper.<anonymous>[LocalVariableDescriptor]

'asSingleFqName' @ [75:53] ==> @NotNull public open fun asSingleFqName(): FqName defined in org.jetbrains.kotlin.name.ClassId[JavaMethodDescriptor]

'asString' @ [75:70] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'getOrCreateWrapper' @ [76:16] ==> private fun getOrCreateWrapper(javaBaseClass: PsiClass, kotlinFqName: FqName, isMutable: Boolean): KtLightMutabilityPlatformWrapper defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses in file platformWrappers.kt[SimpleFunctionDescriptorImpl]

'javaBaseClass' @ [76:35] ==> val javaBaseClass: PsiClass defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.platformMutabilityWrapper.<anonymous>[LocalVariableDescriptor]

'kotlinMutable' @ [76:50] ==> val kotlinMutable: ClassId defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.platformMutabilityWrapper.<anonymous>[LocalVariableDescriptor]

'asSingleFqName' @ [76:64] ==> @NotNull public open fun asSingleFqName(): FqName defined in org.jetbrains.kotlin.name.ClassId[JavaMethodDescriptor]

'if (isMutable) javaBaseClass::mutableWrapper else javaBaseClass::readOnlyWrapper' @ [82:27] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KMutableProperty0<KtLightMutabilityPlatformWrapper?>, elseBranch: KMutableProperty0<KtLightMutabilityPlatformWrapper?>): KMutableProperty0<KtLightMutabilityPlatformWrapper?>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KMutableProperty0<KtLightMutabilityPlatformWrapper?>

'isMutable' @ [82:31] ==> value-parameter isMutable: Boolean defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.getOrCreateWrapper[ValueParameterDescriptorImpl]

'javaBaseClass' @ [82:42] ==> value-parameter javaBaseClass: PsiClass defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.getOrCreateWrapper[ValueParameterDescriptorImpl]

'mutableWrapper' @ [82:57] ==> private var PsiClass.mutableWrapper: KtLightMutabilityPlatformWrapper? defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses in file platformWrappers.kt[PropertyDescriptorImpl]

'javaBaseClass' @ [82:77] ==> value-parameter javaBaseClass: PsiClass defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.getOrCreateWrapper[ValueParameterDescriptorImpl]

'readOnlyWrapper' @ [82:92] ==> private var PsiClass.readOnlyWrapper: KtLightMutabilityPlatformWrapper? defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses in file platformWrappers.kt[PropertyDescriptorImpl]

'userDataStorage' @ [83:12] ==> val userDataStorage: KMutableProperty0<KtLightMutabilityPlatformWrapper?> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.getOrCreateWrapper[LocalVariableDescriptor]

'get' @ [83:28] ==> public abstract fun get(): KtLightMutabilityPlatformWrapper? defined in kotlin.reflect.KMutableProperty0[DeserializedSimpleFunctionDescriptor]

'KtLightMutabilityPlatformWrapper' @ [83:37] ==> public constructor KtLightMutabilityPlatformWrapper(javaBaseClass: PsiClass, kotlinInterfaceFqName: FqName, isMutable: Boolean) defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[ClassConstructorDescriptorImpl]

'javaBaseClass' @ [83:70] ==> value-parameter javaBaseClass: PsiClass defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.getOrCreateWrapper[ValueParameterDescriptorImpl]

'kotlinFqName' @ [83:85] ==> value-parameter kotlinFqName: FqName defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.getOrCreateWrapper[ValueParameterDescriptorImpl]

'isMutable' @ [83:99] ==> value-parameter isMutable: Boolean defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.getOrCreateWrapper[ValueParameterDescriptorImpl]

'also' @ [83:110] ==> @InlineOnly @SinceKotlin public inline fun <T> KtLightMutabilityPlatformWrapper.also(block: (KtLightMutabilityPlatformWrapper) -> Unit): KtLightMutabilityPlatformWrapper defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtLightMutabilityPlatformWrapper

'userDataStorage' @ [83:117] ==> val userDataStorage: KMutableProperty0<KtLightMutabilityPlatformWrapper?> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.getOrCreateWrapper[LocalVariableDescriptor]

'set' @ [83:133] ==> public abstract fun set(value: KtLightMutabilityPlatformWrapper?): Unit defined in kotlin.reflect.KMutableProperty0[DeserializedSimpleFunctionDescriptor]

'it' @ [83:137] ==> value-parameter it: KtLightMutabilityPlatformWrapper defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.getOrCreateWrapper.<anonymous>[ValueParameterDescriptorImpl]

'getValue' @ [86:76] ==> public final operator fun getValue(thisRef: R, desc: KProperty<*>): T? defined in org.jetbrains.kotlin.psi.UserDataProperty[DeserializedSimpleFunctionDescriptor]

'create' @ [86:97] ==> @NotNull public open fun <T : (Any..Any?)> create(@NotNull @NonNls p0: String): Key<(KtLightMutabilityPlatformWrapper..KtLightMutabilityPlatformWrapper?)> defined in com.intellij.openapi.util.Key[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> (org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper..org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper?)

'getValue' @ [87:75] ==> public final operator fun getValue(thisRef: R, desc: KProperty<*>): T? defined in org.jetbrains.kotlin.psi.UserDataProperty[DeserializedSimpleFunctionDescriptor]

'create' @ [87:96] ==> @NotNull public open fun <T : (Any..Any?)> create(@NotNull @NonNls p0: String): Key<(KtLightMutabilityPlatformWrapper..KtLightMutabilityPlatformWrapper?)> defined in com.intellij.openapi.util.Key[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> (org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper..org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper?)

'KtAbstractContainerWrapper' @ [93:5] ==> public constructor KtAbstractContainerWrapper(fqName: FqName, superInterface: PsiClass) defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[ClassConstructorDescriptorImpl]

'kotlinInterfaceFqName' @ [93:32] ==> value-parameter kotlinInterfaceFqName: FqName defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.<init>[ValueParameterDescriptorImpl]

'javaBaseClass' @ [93:55] ==> value-parameter javaBaseClass: PsiClass defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.<init>[ValueParameterDescriptorImpl]

'getValue' @ [94:29] ==> @InlineOnly public operator inline fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> T

'calcMethods' @ [94:39] ==> private final fun calcMethods(): List<PsiMethod> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[SimpleFunctionDescriptorImpl]

'javaBaseClass' @ [96:33] ==> private final val javaBaseClass: PsiClass defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[PropertyDescriptorImpl]

'methods' @ [96:47] ==> public final val PsiClass.methods: (Array<(PsiMethod..PsiMethod?)>..Array<out (PsiMethod..PsiMethod?)>)[MyPropertyDescriptor]

'flatMap' @ [96:55] ==> public inline fun <T, R> Array<out (PsiMethod..PsiMethod?)>.flatMap(transform: ((PsiMethod..PsiMethod?)) -> Iterable<PsiMethod>): List<PsiMethod> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiMethod..com.intellij.psi.PsiMethod?)
    <R> -> PsiMethod

'methodWrappers' @ [96:65] ==> private final fun methodWrappers(method: PsiMethod): List<PsiMethod> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[SimpleFunctionDescriptorImpl]

'it' @ [96:80] ==> value-parameter it: (PsiMethod..PsiMethod?) defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.calcMethods.<anonymous>[ValueParameterDescriptorImpl]

'_methods' @ [98:36] ==> private final val _methods: List<PsiMethod> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[PropertyDescriptorImpl]

'method' @ [101:26] ==> value-parameter method: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodWrappers[ValueParameterDescriptorImpl]

'name' @ [101:33] ==> public final var PsiMethod.name: String[MyPropertyDescriptor]

'javaGetterNameToKotlinGetterName' @ [103:9] ==> private val javaGetterNameToKotlinGetterName: Map<String, String> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses in file platformWrappers.kt[PropertyDescriptorImpl]

'get' @ [103:42] ==> public abstract operator fun get(key: String): String? defined in kotlin.collections.Map[DeserializedSimpleFunctionDescriptor]

'methodName' @ [103:46] ==> val methodName: String defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodWrappers[LocalVariableDescriptor]

'let' @ [103:59] ==> @InlineOnly public inline fun <T, R> String.let(block: (String) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String
    <R> -> Nothing

'method' @ [104:38] ==> value-parameter method: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodWrappers[ValueParameterDescriptorImpl]

'finalBridge' @ [104:45] ==> private final fun PsiMethod.finalBridge(): KtLightMethodWrapper defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[SimpleFunctionDescriptorImpl]

'method' @ [105:40] ==> value-parameter method: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodWrappers[ValueParameterDescriptorImpl]

'wrap' @ [105:47] ==> private final fun PsiMethod.wrap(makeFinal: Boolean = ..., hasImplementation: Boolean = ..., name: String = ..., substituteObjectWith: PsiType? = ..., signature: MethodSignature? = ...): KtLightMethodWrapper defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[SimpleFunctionDescriptorImpl]

'kotlinName' @ [105:59] ==> value-parameter kotlinName: String defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodWrappers.<anonymous>[ValueParameterDescriptorImpl]

'listOf' @ [106:20] ==> public fun <T> listOf(vararg elements: KtLightMethodWrapper): List<KtLightMethodWrapper> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtLightMethodWrapper

'finalBridgeForJava' @ [106:27] ==> val finalBridgeForJava: KtLightMethodWrapper defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodWrappers.<anonymous>[LocalVariableDescriptor]

'abstractKotlinGetter' @ [106:47] ==> val abstractKotlinGetter: KtLightMethodWrapper defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodWrappers.<anonymous>[LocalVariableDescriptor]

'!' @ [109:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'method' @ [109:14] ==> value-parameter method: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodWrappers[ValueParameterDescriptorImpl]

'isInKotlinInterface' @ [109:21] ==> private final fun PsiMethod.isInKotlinInterface(): Boolean defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[SimpleFunctionDescriptorImpl]

'listOf' @ [111:20] ==> public fun <T> listOf(element: KtLightMethodWrapper): List<KtLightMethodWrapper> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtLightMethodWrapper

'method' @ [111:27] ==> value-parameter method: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodWrappers[ValueParameterDescriptorImpl]

'openBridge' @ [111:34] ==> private final fun PsiMethod.openBridge(): KtLightMethodWrapper defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[SimpleFunctionDescriptorImpl]

'methodsWithSpecializedSignature' @ [114:16] ==> private final fun methodsWithSpecializedSignature(method: PsiMethod): List<PsiMethod> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[SimpleFunctionDescriptorImpl]

'method' @ [114:48] ==> value-parameter method: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodWrappers[ValueParameterDescriptorImpl]

'method' @ [118:26] ==> value-parameter method: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodsWithSpecializedSignature[ValueParameterDescriptorImpl]

'name' @ [118:33] ==> public final var PsiMethod.name: String[MyPropertyDescriptor]

'methodName' @ [120:13] ==> val methodName: String defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodsWithSpecializedSignature[LocalVariableDescriptor]

'membersWithSpecializedSignature' @ [120:28] ==> private val membersWithSpecializedSignature: Set<String> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses in file platformWrappers.kt[PropertyDescriptorImpl]

'emptyList' @ [120:68] ==> public fun <T> emptyList(): List<PsiMethod> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiMethod

'javaBaseClass' @ [122:13] ==> private final val javaBaseClass: PsiClass defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[PropertyDescriptorImpl]

'qualifiedName' @ [122:27] ==> public final val PsiClass.qualifiedName: String?[MyPropertyDescriptor]

'JAVA_UTIL_MAP' @ [122:61] ==> @NonNls public const final val JAVA_UTIL_MAP: String defined in com.intellij.psi.CommonClassNames[JavaPropertyDescriptor]

'javaUtilMapMethodWithSpecialSignature' @ [123:52] ==> private final fun javaUtilMapMethodWithSpecialSignature(method: PsiMethod): KtLightMethodWrapper? defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[SimpleFunctionDescriptorImpl]

'method' @ [123:90] ==> value-parameter method: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodsWithSpecializedSignature[ValueParameterDescriptorImpl]

'emptyList' @ [123:108] ==> public fun <T> emptyList(): List<PsiMethod> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiMethod

'method' @ [124:41] ==> value-parameter method: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodsWithSpecializedSignature[ValueParameterDescriptorImpl]

'finalBridge' @ [124:48] ==> private final fun PsiMethod.finalBridge(): KtLightMethodWrapper defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[SimpleFunctionDescriptorImpl]

'listOf' @ [125:20] ==> public fun <T> listOf(vararg elements: KtLightMethodWrapper): List<KtLightMethodWrapper> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtLightMethodWrapper

'finalBridgeWithObject' @ [125:27] ==> val finalBridgeWithObject: KtLightMethodWrapper defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodsWithSpecializedSignature[LocalVariableDescriptor]

'abstractKotlinVariantWithGeneric' @ [125:50] ==> val abstractKotlinVariantWithGeneric: KtLightMethodWrapper defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodsWithSpecializedSignature[LocalVariableDescriptor]

'methodName' @ [128:13] ==> val methodName: String defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodsWithSpecializedSignature[LocalVariableDescriptor]

'BuiltinMethodsWithSpecialGenericSignature' @ [128:27] ==> public object BuiltinMethodsWithSpecialGenericSignature defined in org.jetbrains.kotlin.load.java[FakeCallableDescriptorForObject]

'ERASED_COLLECTION_PARAMETER_NAMES' @ [128:69] ==> public final val ERASED_COLLECTION_PARAMETER_NAMES: List<String> defined in org.jetbrains.kotlin.load.java.BuiltinMethodsWithSpecialGenericSignature[DeserializedPropertyDescriptor]

'emptyList' @ [129:20] ==> public fun <T> emptyList(): List<PsiMethod> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiMethod

'methodName' @ [132:13] ==> val methodName: String defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodsWithSpecializedSignature[LocalVariableDescriptor]

'method' @ [132:39] ==> value-parameter method: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodsWithSpecializedSignature[ValueParameterDescriptorImpl]

'parameterList' @ [132:46] ==> public final val PsiMethod.parameterList: PsiParameterList[MyPropertyDescriptor]

'parameters' @ [132:60] ==> public final val PsiParameterList.parameters: (Array<(PsiParameter..PsiParameter?)>..Array<out (PsiParameter..PsiParameter?)>)[MyPropertyDescriptor]

'singleOrNull' @ [132:71] ==> public fun <T> Array<out (PsiParameter..PsiParameter?)>.singleOrNull(): PsiParameter? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiParameter..com.intellij.psi.PsiParameter?)

'type' @ [132:87] ==> public final val PsiParameter.type: PsiType[MyPropertyDescriptor]

'INT' @ [132:103] ==> public final val INT: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'listOf' @ [134:20] ==> public fun <T> listOf(vararg elements: PsiMethod): List<PsiMethod> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiMethod

'method' @ [134:27] ==> value-parameter method: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodsWithSpecializedSignature[ValueParameterDescriptorImpl]

'finalBridge' @ [134:34] ==> private final fun PsiMethod.finalBridge(): KtLightMethodWrapper defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[SimpleFunctionDescriptorImpl]

'createRemoveAt' @ [134:49] ==> private final fun createRemoveAt(baseMethod: PsiMethod): PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[SimpleFunctionDescriptorImpl]

'method' @ [134:64] ==> value-parameter method: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodsWithSpecializedSignature[ValueParameterDescriptorImpl]

'method' @ [138:37] ==> value-parameter method: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodsWithSpecializedSignature[ValueParameterDescriptorImpl]

'finalBridge' @ [138:44] ==> private final fun PsiMethod.finalBridge(): KtLightMethodWrapper defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[SimpleFunctionDescriptorImpl]

'method' @ [139:48] ==> value-parameter method: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodsWithSpecializedSignature[ValueParameterDescriptorImpl]

'wrap' @ [139:55] ==> private final fun PsiMethod.wrap(makeFinal: Boolean = ..., hasImplementation: Boolean = ..., name: String = ..., substituteObjectWith: PsiType? = ..., signature: MethodSignature? = ...): KtLightMethodWrapper defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[SimpleFunctionDescriptorImpl]

'singleTypeParameterAsType' @ [139:83] ==> private final fun singleTypeParameterAsType(): PsiImmediateClassType defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[SimpleFunctionDescriptorImpl]

'listOf' @ [140:16] ==> public fun <T> listOf(vararg elements: KtLightMethodWrapper): List<KtLightMethodWrapper> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtLightMethodWrapper

'finalBridgeWithObject' @ [140:23] ==> val finalBridgeWithObject: KtLightMethodWrapper defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodsWithSpecializedSignature[LocalVariableDescriptor]

'abstractKotlinVariantWithGeneric' @ [140:46] ==> val abstractKotlinVariantWithGeneric: KtLightMethodWrapper defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.methodsWithSpecializedSignature[LocalVariableDescriptor]

'typeParameters' @ [143:47] ==> public final val KtLightMutabilityPlatformWrapper.typeParameters: Array<PsiTypeParameter>[MyPropertyDescriptor]

'single' @ [143:62] ==> public fun <T> Array<out PsiTypeParameter>.single(): PsiTypeParameter defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiTypeParameter

'asType' @ [143:71] ==> private fun PsiTypeParameter.asType(): PsiImmediateClassType defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses in file platformWrappers.kt[SimpleFunctionDescriptorImpl]

'baseMethod' @ [146:16] ==> value-parameter baseMethod: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.createRemoveAt[ValueParameterDescriptorImpl]

'wrap' @ [146:27] ==> private final fun PsiMethod.wrap(makeFinal: Boolean = ..., hasImplementation: Boolean = ..., name: String = ..., substituteObjectWith: PsiType? = ..., signature: MethodSignature? = ...): KtLightMethodWrapper defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[SimpleFunctionDescriptorImpl]

'MethodSignature' @ [148:29] ==> public constructor MethodSignature(parameterTypes: List<PsiType>, returnType: PsiType) defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.MethodSignature[ClassConstructorDescriptorImpl]

'listOf' @ [149:42] ==> public fun <T> listOf(element: (PsiPrimitiveType..PsiPrimitiveType?)): List<(PsiPrimitiveType..PsiPrimitiveType?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiPrimitiveType..com.intellij.psi.PsiPrimitiveType?)

'INT' @ [149:57] ==> public final val INT: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'singleTypeParameterAsType' @ [150:38] ==> private final fun singleTypeParameterAsType(): PsiImmediateClassType defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[SimpleFunctionDescriptorImpl]

'wrap' @ [155:43] ==> private final fun PsiMethod.wrap(makeFinal: Boolean = ..., hasImplementation: Boolean = ..., name: String = ..., substituteObjectWith: PsiType? = ..., signature: MethodSignature? = ...): KtLightMethodWrapper defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[SimpleFunctionDescriptorImpl]

'wrap' @ [156:42] ==> private final fun PsiMethod.wrap(makeFinal: Boolean = ..., hasImplementation: Boolean = ..., name: String = ..., substituteObjectWith: PsiType? = ..., signature: MethodSignature? = ...): KtLightMethodWrapper defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[SimpleFunctionDescriptorImpl]

'this' @ [161:28] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.wrap[ReceiverParameterDescriptorImpl]

'name' @ [161:33] ==> public final var PsiMethod.name: String[MyPropertyDescriptor]

'KtLightMethodWrapper' @ [164:9] ==> public constructor KtLightMethodWrapper(containingClass: KtAbstractContainerWrapper, baseMethod: PsiMethod, name: String, isFinal: Boolean, hasImplementation: Boolean, substituteObjectWith: PsiType?, providedSignature: MethodSignature?) defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[ClassConstructorDescriptorImpl]

'this@KtLightMutabilityPlatformWrapper' @ [165:13] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[LazyClassReceiverParameterDescriptor]

'this@wrap' @ [165:52] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.wrap[ReceiverParameterDescriptorImpl]

'makeFinal' @ [166:23] ==> value-parameter makeFinal: Boolean = ... defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.wrap[ValueParameterDescriptorImpl]

'name' @ [167:20] ==> value-parameter name: String = ... defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.wrap[ValueParameterDescriptorImpl]

'substituteObjectWith' @ [168:36] ==> value-parameter substituteObjectWith: PsiType? = ... defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.wrap[ValueParameterDescriptorImpl]

'signature' @ [169:33] ==> value-parameter signature: MethodSignature? = ... defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.wrap[ValueParameterDescriptorImpl]

'hasImplementation' @ [170:33] ==> value-parameter hasImplementation: Boolean = ... defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.wrap[ValueParameterDescriptorImpl]

'typeParameters' @ [174:17] ==> public final val KtLightMutabilityPlatformWrapper.typeParameters: Array<PsiTypeParameter>[MyPropertyDescriptor]

'asType' @ [174:35] ==> private fun PsiTypeParameter.asType(): PsiImmediateClassType defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses in file platformWrappers.kt[SimpleFunctionDescriptorImpl]

'typeParameters' @ [175:17] ==> public final val KtLightMutabilityPlatformWrapper.typeParameters: Array<PsiTypeParameter>[MyPropertyDescriptor]

'asType' @ [175:35] ==> private fun PsiTypeParameter.asType(): PsiImmediateClassType defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses in file platformWrappers.kt[SimpleFunctionDescriptorImpl]

'when (method.name) {
            "get" -> MethodSignature(
                    parameterTypes = listOf(k),
                    returnType = v
            )
            "getOrDefault" -> MethodSignature(
                    parameterTypes = listOf(k, v),
                    returnType = v
            )
            "containsKey" -> MethodSignature(
                    parameterTypes = listOf(k),
                    returnType = PsiType.BOOLEAN
            )
            "containsValue" -> MethodSignature(
                    parameterTypes = listOf(v),
                    returnType = PsiType.BOOLEAN
            )
            "remove" ->
                when (method.parameterList.parametersCount) {
                    1 -> MethodSignature(
                            parameterTypes = listOf(k),
                            returnType = v
                    )
                    2 -> MethodSignature(
                            parameterTypes = listOf(k, v),
                            returnType = PsiType.BOOLEAN
                    )
                    else -> null
                }
            else -> null
        }' @ [177:25] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: MethodSignature?, entry1: MethodSignature?, entry2: MethodSignature?, entry3: MethodSignature?, entry4: MethodSignature?, entry5: MethodSignature?): MethodSignature?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> MethodSignature?

'method' @ [177:31] ==> value-parameter method: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.javaUtilMapMethodWithSpecialSignature[ValueParameterDescriptorImpl]

'name' @ [177:38] ==> public final var PsiMethod.name: String[MyPropertyDescriptor]

'MethodSignature' @ [178:22] ==> public constructor MethodSignature(parameterTypes: List<PsiType>, returnType: PsiType) defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.MethodSignature[ClassConstructorDescriptorImpl]

'listOf' @ [179:38] ==> public fun <T> listOf(element: PsiImmediateClassType): List<PsiImmediateClassType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiImmediateClassType

'k' @ [179:45] ==> val k: PsiImmediateClassType defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.javaUtilMapMethodWithSpecialSignature[LocalVariableDescriptor]

'v' @ [180:34] ==> val v: PsiImmediateClassType defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.javaUtilMapMethodWithSpecialSignature[LocalVariableDescriptor]

'MethodSignature' @ [182:31] ==> public constructor MethodSignature(parameterTypes: List<PsiType>, returnType: PsiType) defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.MethodSignature[ClassConstructorDescriptorImpl]

'listOf' @ [183:38] ==> public fun <T> listOf(vararg elements: PsiImmediateClassType): List<PsiImmediateClassType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiImmediateClassType

'k' @ [183:45] ==> val k: PsiImmediateClassType defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.javaUtilMapMethodWithSpecialSignature[LocalVariableDescriptor]

'v' @ [183:48] ==> val v: PsiImmediateClassType defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.javaUtilMapMethodWithSpecialSignature[LocalVariableDescriptor]

'v' @ [184:34] ==> val v: PsiImmediateClassType defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.javaUtilMapMethodWithSpecialSignature[LocalVariableDescriptor]

'MethodSignature' @ [186:30] ==> public constructor MethodSignature(parameterTypes: List<PsiType>, returnType: PsiType) defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.MethodSignature[ClassConstructorDescriptorImpl]

'listOf' @ [187:38] ==> public fun <T> listOf(element: PsiImmediateClassType): List<PsiImmediateClassType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiImmediateClassType

'k' @ [187:45] ==> val k: PsiImmediateClassType defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.javaUtilMapMethodWithSpecialSignature[LocalVariableDescriptor]

'BOOLEAN' @ [188:42] ==> public final val BOOLEAN: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'MethodSignature' @ [190:32] ==> public constructor MethodSignature(parameterTypes: List<PsiType>, returnType: PsiType) defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.MethodSignature[ClassConstructorDescriptorImpl]

'listOf' @ [191:38] ==> public fun <T> listOf(element: PsiImmediateClassType): List<PsiImmediateClassType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiImmediateClassType

'v' @ [191:45] ==> val v: PsiImmediateClassType defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.javaUtilMapMethodWithSpecialSignature[LocalVariableDescriptor]

'BOOLEAN' @ [192:42] ==> public final val BOOLEAN: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'when (method.parameterList.parametersCount) {
                    1 -> MethodSignature(
                            parameterTypes = listOf(k),
                            returnType = v
                    )
                    2 -> MethodSignature(
                            parameterTypes = listOf(k, v),
                            returnType = PsiType.BOOLEAN
                    )
                    else -> null
                }' @ [195:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: MethodSignature?, entry1: MethodSignature?, entry2: MethodSignature?): MethodSignature?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> MethodSignature?

'method' @ [195:23] ==> value-parameter method: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.javaUtilMapMethodWithSpecialSignature[ValueParameterDescriptorImpl]

'parameterList' @ [195:30] ==> public final val PsiMethod.parameterList: PsiParameterList[MyPropertyDescriptor]

'parametersCount' @ [195:44] ==> public final val PsiParameterList.parametersCount: Int[MyPropertyDescriptor]

'MethodSignature' @ [196:26] ==> public constructor MethodSignature(parameterTypes: List<PsiType>, returnType: PsiType) defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.MethodSignature[ClassConstructorDescriptorImpl]

'listOf' @ [197:46] ==> public fun <T> listOf(element: PsiImmediateClassType): List<PsiImmediateClassType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiImmediateClassType

'k' @ [197:53] ==> val k: PsiImmediateClassType defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.javaUtilMapMethodWithSpecialSignature[LocalVariableDescriptor]

'v' @ [198:42] ==> val v: PsiImmediateClassType defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.javaUtilMapMethodWithSpecialSignature[LocalVariableDescriptor]

'MethodSignature' @ [200:26] ==> public constructor MethodSignature(parameterTypes: List<PsiType>, returnType: PsiType) defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.MethodSignature[ClassConstructorDescriptorImpl]

'listOf' @ [201:46] ==> public fun <T> listOf(vararg elements: PsiImmediateClassType): List<PsiImmediateClassType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiImmediateClassType

'k' @ [201:53] ==> val k: PsiImmediateClassType defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.javaUtilMapMethodWithSpecialSignature[LocalVariableDescriptor]

'v' @ [201:56] ==> val v: PsiImmediateClassType defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.javaUtilMapMethodWithSpecialSignature[LocalVariableDescriptor]

'BOOLEAN' @ [202:50] ==> public final val BOOLEAN: (PsiPrimitiveType..PsiPrimitiveType?) defined in com.intellij.psi.PsiType[JavaPropertyDescriptor]

'method' @ [209:16] ==> value-parameter method: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.javaUtilMapMethodWithSpecialSignature[ValueParameterDescriptorImpl]

'wrap' @ [209:23] ==> private final fun PsiMethod.wrap(makeFinal: Boolean = ..., hasImplementation: Boolean = ..., name: String = ..., substituteObjectWith: PsiType? = ..., signature: MethodSignature? = ...): KtLightMethodWrapper defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[SimpleFunctionDescriptorImpl]

'signature' @ [209:40] ==> val signature: MethodSignature defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.javaUtilMapMethodWithSpecialSignature[LocalVariableDescriptor]

'javaBaseClass' @ [213:13] ==> private final val javaBaseClass: PsiClass defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[PropertyDescriptorImpl]

'qualifiedName' @ [213:27] ==> public final val PsiClass.qualifiedName: String?[MyPropertyDescriptor]

'JAVA_UTIL_MAP_ENTRY' @ [213:61] ==> @NonNls public const final val JAVA_UTIL_MAP_ENTRY: String defined in com.intellij.psi.CommonClassNames[JavaPropertyDescriptor]

'when (name) {
                "getValue", "getKey" -> return true
            }' @ [214:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Nothing

'name' @ [214:19] ==> public final var PsiMethod.name: String[MyPropertyDescriptor]

'DefaultBuiltIns' @ [219:31] ==> public companion object defined in org.jetbrains.kotlin.builtins.DefaultBuiltIns[FakeCallableDescriptorForObject]

'Instance' @ [219:47] ==> @JvmStatic public final val Instance: DefaultBuiltIns defined in org.jetbrains.kotlin.builtins.DefaultBuiltIns.Companion[DeserializedPropertyDescriptor]

'getBuiltInClassByFqName' @ [219:56] ==> @NotNull public open fun getBuiltInClassByFqName(@NotNull p0: FqName): ClassDescriptor defined in org.jetbrains.kotlin.builtins.DefaultBuiltIns[JavaMethodDescriptor]

'kotlinInterfaceFqName' @ [219:80] ==> private final val kotlinInterfaceFqName: FqName defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[PropertyDescriptorImpl]

'kotlinInterface' @ [220:21] ==> val kotlinInterface: ClassDescriptor defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.isInKotlinInterface[LocalVariableDescriptor]

'unsubstitutedMemberScope' @ [220:37] ==> public final val ClassDescriptor.unsubstitutedMemberScope: MemberScope[MyPropertyDescriptor]

'identifier' @ [222:31] ==> @NotNull public open fun identifier(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'name' @ [222:42] ==> public final var PsiMethod.name: String[MyPropertyDescriptor]

'scope' @ [223:16] ==> val scope: MemberScope defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.isInKotlinInterface[LocalVariableDescriptor]

'getContributedFunctions' @ [223:22] ==> public abstract fun getContributedFunctions(name: Name, location: LookupLocation): Collection<SimpleFunctionDescriptor> defined in org.jetbrains.kotlin.resolve.scopes.MemberScope[DeserializedSimpleFunctionDescriptor]

'methodName' @ [223:46] ==> val methodName: Name defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.isInKotlinInterface[LocalVariableDescriptor]

'FROM_IDE' @ [223:75] ==> enum entry FROM_IDE defined in org.jetbrains.kotlin.incremental.components.NoLookupLocation[FakeCallableDescriptorForObject]

'isNotEmpty' @ [223:85] ==> @InlineOnly public inline fun <T> Collection<SimpleFunctionDescriptor>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SimpleFunctionDescriptor

'scope' @ [224:19] ==> val scope: MemberScope defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.isInKotlinInterface[LocalVariableDescriptor]

'getContributedVariables' @ [224:25] ==> public abstract fun getContributedVariables(name: Name, location: LookupLocation): Collection<PropertyDescriptor> defined in org.jetbrains.kotlin.resolve.scopes.MemberScope[DeserializedSimpleFunctionDescriptor]

'methodName' @ [224:49] ==> val methodName: Name defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper.isInKotlinInterface[LocalVariableDescriptor]

'FROM_IDE' @ [224:78] ==> enum entry FROM_IDE defined in org.jetbrains.kotlin.incremental.components.NoLookupLocation[FakeCallableDescriptorForObject]

'isNotEmpty' @ [224:88] ==> @InlineOnly public inline fun <T> Collection<PropertyDescriptor>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PropertyDescriptor

'javaBaseClass' @ [227:40] ==> private final val javaBaseClass: PsiClass defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMutabilityPlatformWrapper[PropertyDescriptorImpl]

'containingFile' @ [227:54] ==> public final val PsiClass.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'KtLightElementBase' @ [240:16] ==> public constructor KtLightElementBase(parent: PsiElement) defined in org.jetbrains.kotlin.asJava.elements.KtLightElementBase[DeserializedClassConstructorDescriptor]

'containingClass' @ [240:35] ==> value-parameter containingClass: KtAbstractContainerWrapper defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper.<init>[ValueParameterDescriptorImpl]

'!' @ [243:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'hasImplementation' @ [243:14] ==> private final val hasImplementation: Boolean defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'isFinal' @ [243:35] ==> private final val isFinal: Boolean defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'error' @ [244:13] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'containingClass' @ [249:27] ==> private final val containingClass: KtAbstractContainerWrapper defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'substitutor' @ [249:43] ==> internal final val substitutor: (PsiSubstitutor..PsiSubstitutor?) defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[PropertyDescriptorImpl]

'substitute' @ [249:55] ==> public abstract fun substitute(@Nullable p0: PsiType?): (PsiType..PsiType?) defined in com.intellij.psi.PsiSubstitutor[JavaMethodDescriptor]

'psiType' @ [249:66] ==> value-parameter psiType: PsiType defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper.substituteType[ValueParameterDescriptorImpl]

'if (TypeUtils.isJavaLangObject(substituted) && substituteObjectWith != null) {
            substituteObjectWith
        }
        else {
            substituted
        }' @ [250:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: PsiType, elseBranch: PsiType): PsiType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> PsiType

'isJavaLangObject' @ [250:30] ==> @Contract public open fun isJavaLangObject(@Nullable p0: PsiType?): Boolean defined in com.siyeh.ig.psiutils.TypeUtils[JavaMethodDescriptor]

'substituted' @ [250:47] ==> val substituted: (PsiType..PsiType?) defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper.substituteType[LocalVariableDescriptor]

'substituteObjectWith' @ [250:63] ==> private final val substituteObjectWith: PsiType? defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'substituteObjectWith' @ [251:13] ==> private final val substituteObjectWith: PsiType? defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'substituted' @ [254:13] ==> val substituted: (PsiType..PsiType?) defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper.substituteType[LocalVariableDescriptor]

'baseMethod' @ [258:38] ==> private final val baseMethod: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'presentation' @ [258:49] ==> public final val PsiMethod.presentation: ItemPresentation?[MyPropertyDescriptor]

'when (name) {
                PsiModifier.DEFAULT -> hasImplementation
                PsiModifier.ABSTRACT -> !hasImplementation
                PsiModifier.FINAL -> isFinal
                else -> baseMethod.hasModifierProperty(name)
            }' @ [263:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean, entry2: Boolean, entry3: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'name' @ [263:19] ==> value-parameter name: String defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper.hasModifierProperty[ValueParameterDescriptorImpl]

'DEFAULT' @ [264:29] ==> public const final val DEFAULT: String defined in com.intellij.psi.PsiModifier[JavaPropertyDescriptor]

'hasImplementation' @ [264:40] ==> private final val hasImplementation: Boolean defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'ABSTRACT' @ [265:29] ==> public const final val ABSTRACT: String defined in com.intellij.psi.PsiModifier[JavaPropertyDescriptor]

'!' @ [265:41] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'hasImplementation' @ [265:42] ==> private final val hasImplementation: Boolean defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'FINAL' @ [266:29] ==> public const final val FINAL: String defined in com.intellij.psi.PsiModifier[JavaPropertyDescriptor]

'isFinal' @ [266:38] ==> private final val isFinal: Boolean defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'baseMethod' @ [267:25] ==> private final val baseMethod: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'hasModifierProperty' @ [267:36] ==> public abstract fun hasModifierProperty(@PsiModifier.ModifierConstant @NonNls @NotNull p0: String): Boolean defined in com.intellij.psi.PsiMethod[JavaMethodDescriptor]

'name' @ [267:56] ==> value-parameter name: String defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper.hasModifierProperty[ValueParameterDescriptorImpl]

'LightParameterListBuilder' @ [271:16] ==> public constructor LightParameterListBuilder(p0: (PsiManager..PsiManager?), p1: (Language..Language?)) defined in com.intellij.psi.impl.light.LightParameterListBuilder[JavaClassConstructorDescriptor]

'manager' @ [271:42] ==> public final val KtLightMethodWrapper.manager: (PsiManager..PsiManager?)[MyPropertyDescriptor]

'INSTANCE' @ [271:66] ==> @NotNull public final val INSTANCE: KotlinLanguage defined in org.jetbrains.kotlin.idea.KotlinLanguage[JavaPropertyDescriptor]

'apply' @ [271:76] ==> @InlineOnly public inline fun <T> LightParameterListBuilder.apply(block: LightParameterListBuilder.() -> Unit): LightParameterListBuilder defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> LightParameterListBuilder

'baseMethod' @ [272:13] ==> private final val baseMethod: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'parameterList' @ [272:24] ==> public final val PsiMethod.parameterList: PsiParameterList[MyPropertyDescriptor]

'parameters' @ [272:38] ==> public final val PsiParameterList.parameters: (Array<(PsiParameter..PsiParameter?)>..Array<out (PsiParameter..PsiParameter?)>)[MyPropertyDescriptor]

'forEachIndexed' @ [272:49] ==> public inline fun <T> Array<out (PsiParameter..PsiParameter?)>.forEachIndexed(action: (index: Int, (PsiParameter..PsiParameter?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiParameter..com.intellij.psi.PsiParameter?)

'providedSignature' @ [273:28] ==> private final val providedSignature: MethodSignature? defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'parameterTypes' @ [273:47] ==> public final val parameterTypes: List<PsiType> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.MethodSignature[PropertyDescriptorImpl]

'get' @ [273:63] ==> public abstract operator fun get(index: Int): PsiType defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'index' @ [273:67] ==> value-parameter index: Int defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper.getParameterList.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'substituteType' @ [273:77] ==> private final fun substituteType(psiType: PsiType): PsiType defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[SimpleFunctionDescriptorImpl]

'paramFromJava' @ [273:92] ==> value-parameter paramFromJava: (PsiParameter..PsiParameter?) defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper.getParameterList.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [273:106] ==> public final val PsiParameter.type: PsiType[MyPropertyDescriptor]

'addParameter' @ [274:17] ==> public open fun addParameter(p0: (PsiParameter..PsiParameter?)): Unit defined in com.intellij.psi.impl.light.LightParameterListBuilder[JavaMethodDescriptor]

'LightParameter' @ [275:25] ==> public constructor LightParameter(@NotNull p0: String, @NotNull p1: PsiType, @NotNull p2: PsiElement, @NotNull p3: Language, p4: Boolean) defined in com.intellij.psi.impl.light.LightParameter[JavaClassConstructorDescriptor]

'paramFromJava' @ [275:40] ==> value-parameter paramFromJava: (PsiParameter..PsiParameter?) defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper.getParameterList.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [275:54] ==> public final val PsiParameter.name: String?[MyPropertyDescriptor]

'index' @ [275:65] ==> value-parameter index: Int defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper.getParameterList.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [275:73] ==> val type: PsiType defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper.getParameterList.<anonymous>.<anonymous>[LocalVariableDescriptor]

'this@KtLightMethodWrapper' @ [276:40] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[LazyClassReceiverParameterDescriptor]

'INSTANCE' @ [276:82] ==> @NotNull public final val INSTANCE: KotlinLanguage defined in org.jetbrains.kotlin.idea.KotlinLanguage[JavaPropertyDescriptor]

'paramFromJava' @ [276:92] ==> value-parameter paramFromJava: (PsiParameter..PsiParameter?) defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper.getParameterList.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'isVarArgs' @ [276:106] ==> public final val PsiParameter.isVarArgs: Boolean[MyPropertyDescriptor]

'name' @ [282:30] ==> private final val name: String defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'providedSignature' @ [283:36] ==> private final val providedSignature: MethodSignature? defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'returnType' @ [283:55] ==> public final val returnType: PsiType defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.MethodSignature[PropertyDescriptorImpl]

'baseMethod' @ [283:69] ==> private final val baseMethod: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'returnType' @ [283:80] ==> public final val PsiMethod.returnType: PsiType?[MyPropertyDescriptor]

'let' @ [283:92] ==> @InlineOnly public inline fun <T, R> PsiType.let(block: (PsiType) -> PsiType): PsiType defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiType
    <R> -> PsiType

'substituteType' @ [283:98] ==> private final fun substituteType(psiType: PsiType): PsiType defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[SimpleFunctionDescriptorImpl]

'it' @ [283:113] ==> value-parameter it: PsiType defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper.getReturnType.<anonymous>[ValueParameterDescriptorImpl]

'baseMethod' @ [285:40] ==> private final val baseMethod: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'typeParameters' @ [285:51] ==> public final val PsiMethod.typeParameters: (Array<(PsiTypeParameter..PsiTypeParameter?)>..Array<out (PsiTypeParameter..PsiTypeParameter?)>)[MyPropertyDescriptor]

'baseMethod' @ [286:43] ==> private final val baseMethod: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'typeParameterList' @ [286:54] ==> public final val PsiMethod.typeParameterList: PsiTypeParameterList?[MyPropertyDescriptor]

'findSuperMethods' @ [288:82] ==> @NotNull public open fun findSuperMethods(@NotNull p0: PsiMethod, p1: Boolean): (Array<(PsiMethod..PsiMethod?)>..Array<out (PsiMethod..PsiMethod?)>) defined in com.intellij.psi.impl.PsiSuperMethodImplUtil[JavaMethodDescriptor]

'this' @ [288:99] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[LazyClassReceiverParameterDescriptor]

'checkAccess' @ [288:105] ==> value-parameter checkAccess: Boolean defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper.findSuperMethods[ValueParameterDescriptorImpl]

'findSuperMethods' @ [289:83] ==> @NotNull public open fun findSuperMethods(@NotNull p0: PsiMethod, p1: (PsiClass..PsiClass?)): (Array<(PsiMethod..PsiMethod?)>..Array<out (PsiMethod..PsiMethod?)>) defined in com.intellij.psi.impl.PsiSuperMethodImplUtil[JavaMethodDescriptor]

'this' @ [289:100] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[LazyClassReceiverParameterDescriptor]

'parentClass' @ [289:106] ==> value-parameter parentClass: PsiClass defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper.findSuperMethods[ValueParameterDescriptorImpl]

'findSuperMethods' @ [290:62] ==> @NotNull public open fun findSuperMethods(@NotNull p0: PsiMethod): (Array<(PsiMethod..PsiMethod?)>..Array<out (PsiMethod..PsiMethod?)>) defined in com.intellij.psi.impl.PsiSuperMethodImplUtil[JavaMethodDescriptor]

'this' @ [290:79] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[LazyClassReceiverParameterDescriptor]

'findSuperMethodSignaturesIncludingStatic' @ [291:106] ==> @NotNull public open fun findSuperMethodSignaturesIncludingStatic(@NotNull p0: PsiMethod, p1: Boolean): (MutableList<(MethodSignatureBackedByPsiMethod..MethodSignatureBackedByPsiMethod?)>..List<(MethodSignatureBackedByPsiMethod..MethodSignatureBackedByPsiMethod?)>) defined in com.intellij.psi.impl.PsiSuperMethodImplUtil[JavaMethodDescriptor]

'this' @ [291:147] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[LazyClassReceiverParameterDescriptor]

'checkAccess' @ [291:153] ==> value-parameter checkAccess: Boolean defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper.findSuperMethodSignaturesIncludingStatic[ValueParameterDescriptorImpl]

'Suppress' @ [292:5] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'findDeepestSuperMethod' @ [292:108] ==> @Nullable public open fun findDeepestSuperMethod(@NotNull p0: PsiMethod): PsiMethod? defined in com.intellij.psi.impl.PsiSuperMethodImplUtil[JavaMethodDescriptor]

'this' @ [292:131] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[LazyClassReceiverParameterDescriptor]

'findDeepestSuperMethods' @ [293:69] ==> @NotNull public open fun findDeepestSuperMethods(@NotNull p0: PsiMethod): (Array<(PsiMethod..PsiMethod?)>..Array<out (PsiMethod..PsiMethod?)>) defined in com.intellij.psi.impl.PsiSuperMethodImplUtil[JavaMethodDescriptor]

'this' @ [293:93] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[LazyClassReceiverParameterDescriptor]

'getHierarchicalMethodSignature' @ [294:76] ==> @NotNull public open fun getHierarchicalMethodSignature(@NotNull p0: PsiMethod): HierarchicalMethodSignature defined in com.intellij.psi.impl.PsiSuperMethodImplUtil[JavaMethodDescriptor]

'this' @ [294:107] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[LazyClassReceiverParameterDescriptor]

'create' @ [295:95] ==> @NotNull public open fun create(@NotNull p0: PsiMethod, @NotNull p1: PsiSubstitutor): MethodSignatureBackedByPsiMethod defined in com.intellij.psi.util.MethodSignatureBackedByPsiMethod[JavaMethodDescriptor]

'this' @ [295:102] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[LazyClassReceiverParameterDescriptor]

'substitutor' @ [295:108] ==> value-parameter substitutor: PsiSubstitutor defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper.getSignature[ValueParameterDescriptorImpl]

'containingClass' @ [297:41] ==> private final val containingClass: KtAbstractContainerWrapper defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'baseMethod' @ [298:36] ==> private final val baseMethod: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'throwsList' @ [298:47] ==> public final val PsiMethod.throwsList: PsiReferenceList[MyPropertyDescriptor]

'baseMethod' @ [299:40] ==> private final val baseMethod: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'hasTypeParameters' @ [299:51] ==> public abstract fun hasTypeParameters(): Boolean defined in com.intellij.psi.PsiMethod[JavaMethodDescriptor]

'baseMethod' @ [300:32] ==> private final val baseMethod: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'isVarArgs' @ [300:43] ==> public final val PsiMethod.isVarArgs: Boolean[MyPropertyDescriptor]

'getValue' @ [302:31] ==> @InlineOnly public operator inline fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> T

'LightIdentifier' @ [302:41] ==> public constructor LightIdentifier(p0: (PsiManager..PsiManager?), p1: (String..String?)) defined in com.intellij.psi.impl.light.LightIdentifier[JavaClassConstructorDescriptor]

'manager' @ [302:57] ==> public final val KtLightMethodWrapper.manager: (PsiManager..PsiManager?)[MyPropertyDescriptor]

'name' @ [302:66] ==> private final val name: String defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'identifier' @ [303:40] ==> private final val identifier: LightIdentifier defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'baseMethod' @ [304:36] ==> private final val baseMethod: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'docComment' @ [304:47] ==> public final val PsiMethod.docComment: PsiDocComment?[MyPropertyDescriptor]

'baseMethod' @ [305:38] ==> private final val baseMethod: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'modifierList' @ [305:49] ==> public final val PsiMethod.modifierList: PsiModifierList[MyPropertyDescriptor]

'baseMethod' @ [307:35] ==> private final val baseMethod: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'isDeprecated' @ [307:46] ==> public final val PsiMethod.isDeprecated: Boolean[MyPropertyDescriptor]

'cannotModify' @ [308:42] ==> public fun LightElement.cannotModify(): Nothing defined in org.jetbrains.kotlin.asJava.classes[DeserializedSimpleFunctionDescriptor]

'javaClass' @ [311:18] ==> public val <T : Any> KtLightMethodWrapper.javaClass: Class<KtLightMethodWrapper> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> KtLightMethodWrapper

'name' @ [311:29] ==> private final val name: String defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper[PropertyDescriptorImpl]

'parameterList' @ [311:35] ==> public final val KtLightMethodWrapper.parameterList: PsiParameterList[MyPropertyDescriptor]

'parameters' @ [311:49] ==> public final val PsiParameterList.parameters: (Array<(PsiParameter..PsiParameter?)>..Array<out (PsiParameter..PsiParameter?)>)[MyPropertyDescriptor]

'map' @ [311:60] ==> public inline fun <T, R> Array<out (PsiParameter..PsiParameter?)>.map(transform: ((PsiParameter..PsiParameter?)) -> PsiType): List<PsiType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiParameter..com.intellij.psi.PsiParameter?)
    <R> -> PsiType

'it' @ [311:66] ==> value-parameter it: (PsiParameter..PsiParameter?) defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtLightMethodWrapper.toString.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [311:69] ==> public final val PsiParameter.type: PsiType[MyPropertyDescriptor]

'joinToString' @ [311:76] ==> public fun <T> Iterable<PsiType>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((PsiType) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiType

'LightElement' @ [317:7] ==> protected/*protected and package*/ constructor LightElement(@NotNull p0: PsiManager, @NotNull p1: Language) defined in com.intellij.psi.impl.light.LightElement[JavaClassConstructorDescriptor]

'superInterface' @ [317:20] ==> value-parameter superInterface: PsiClass defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper.<init>[ValueParameterDescriptorImpl]

'manager' @ [317:35] ==> public final val PsiClass.manager: (PsiManager..PsiManager?)[MyPropertyDescriptor]

'INSTANCE' @ [317:59] ==> @NotNull public final val INSTANCE: KotlinLanguage defined in org.jetbrains.kotlin.idea.KotlinLanguage[JavaPropertyDescriptor]

'ClassInnerStuffCache' @ [319:31] ==> public constructor ClassInnerStuffCache(@NotNull p0: PsiExtensibleClass) defined in com.intellij.psi.impl.source.ClassInnerStuffCache[JavaClassConstructorDescriptor]

'this' @ [319:52] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[LazyClassReceiverParameterDescriptor]

'superInterface' @ [322:15] ==> private final val superInterface: PsiClass defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[PropertyDescriptorImpl]

'typeParameters' @ [322:30] ==> public final val PsiClass.typeParameters: (Array<(PsiTypeParameter..PsiTypeParameter?)>..Array<out (PsiTypeParameter..PsiTypeParameter?)>)[MyPropertyDescriptor]

'mapIndexed' @ [323:14] ==> public inline fun <T, R> Array<out (PsiTypeParameter..PsiTypeParameter?)>.mapIndexed(transform: (index: Int, (PsiTypeParameter..PsiTypeParameter?)) -> Pair<(PsiTypeParameter..PsiTypeParameter?), LightTypeParameterBuilder>): List<Pair<(PsiTypeParameter..PsiTypeParameter?), LightTypeParameterBuilder>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiTypeParameter..com.intellij.psi.PsiTypeParameter?)
    <R> -> Pair<(com.intellij.psi.PsiTypeParameter..com.intellij.psi.PsiTypeParameter?), LightTypeParameterBuilder>

'supersParameter' @ [324:17] ==> value-parameter supersParameter: (PsiTypeParameter..PsiTypeParameter?) defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper.superClassTypeParametersToMyTypeParameters.<anonymous>[ValueParameterDescriptorImpl]

'LightTypeParameterBuilder' @ [324:36] ==> public constructor LightTypeParameterBuilder(@NotNull p0: String, p1: (PsiTypeParameterListOwner..PsiTypeParameterListOwner?), p2: Int) defined in com.intellij.psi.impl.light.LightTypeParameterBuilder[JavaClassConstructorDescriptor]

'supersParameter' @ [324:62] ==> value-parameter supersParameter: (PsiTypeParameter..PsiTypeParameter?) defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper.superClassTypeParametersToMyTypeParameters.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [324:78] ==> public final val PsiTypeParameter.name: String?[MyPropertyDescriptor]

'index' @ [324:89] ==> value-parameter index: Int defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper.superClassTypeParametersToMyTypeParameters.<anonymous>[ValueParameterDescriptorImpl]

'this' @ [324:97] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[LazyClassReceiverParameterDescriptor]

'index' @ [324:103] ==> value-parameter index: Int defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper.superClassTypeParametersToMyTypeParameters.<anonymous>[ValueParameterDescriptorImpl]

'toMap' @ [326:14] ==> public fun <K, V> Iterable<Pair<PsiTypeParameter, LightTypeParameterBuilder>>.toMap(): Map<PsiTypeParameter, LightTypeParameterBuilder> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> PsiTypeParameter
    <V> -> LightTypeParameterBuilder

'createSubstitutor' @ [328:32] ==> public open fun createSubstitutor(@Nullable p0: (MutableMap<(PsiTypeParameter..PsiTypeParameter?), (PsiType..PsiType?)>?..Map<(PsiTypeParameter..PsiTypeParameter?), (PsiType..PsiType?)>?)): (PsiSubstitutor..PsiSubstitutor?) defined in com.intellij.psi.impl.PsiSubstitutorImpl[JavaMethodDescriptor]

'superClassTypeParametersToMyTypeParameters' @ [328:50] ==> private final val superClassTypeParametersToMyTypeParameters: Map<PsiTypeParameter, PsiTypeParameter> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[PropertyDescriptorImpl]

'mapValues' @ [328:93] ==> public inline fun <K, V, R> Map<out (PsiTypeParameter..PsiTypeParameter?), PsiTypeParameter>.mapValues(transform: (Map.Entry<(PsiTypeParameter..PsiTypeParameter?), PsiTypeParameter>) -> PsiImmediateClassType): Map<(PsiTypeParameter..PsiTypeParameter?), PsiImmediateClassType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (com.intellij.psi.PsiTypeParameter..com.intellij.psi.PsiTypeParameter?)
    <V> -> PsiTypeParameter
    <R> -> PsiImmediateClassType

'it' @ [329:9] ==> value-parameter it: Map.Entry<PsiTypeParameter, PsiTypeParameter> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper.substitutor.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [329:12] ==> public abstract val value: PsiTypeParameter defined in kotlin.collections.Map.Entry[DeserializedPropertyDescriptor]

'asType' @ [329:18] ==> private fun PsiTypeParameter.asType(): PsiImmediateClassType defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses in file platformWrappers.kt[SimpleFunctionDescriptorImpl]

'arrayOf' @ [332:32] ==> public inline fun <reified @PureReifiable T> arrayOf(vararg elements: PsiClass): Array<PsiClass> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified @PureReifiable T> -> PsiClass

'superInterface' @ [332:40] ==> private final val superInterface: PsiClass defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[PropertyDescriptorImpl]

'fqName' @ [334:39] ==> internal final val fqName: FqName defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[PropertyDescriptorImpl]

'asString' @ [334:46] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'javaClass' @ [336:33] ==> public val <T : Any> KtAbstractContainerWrapper.javaClass: Class<KtAbstractContainerWrapper> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> KtAbstractContainerWrapper

'name' @ [336:44] ==> public final var KtAbstractContainerWrapper.name: String[MyPropertyDescriptor]

'name' @ [338:54] ==> value-parameter name: String defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper.hasModifierProperty[ValueParameterDescriptorImpl]

'PUBLIC' @ [338:74] ==> public const final val PUBLIC: String defined in com.intellij.psi.PsiModifier[JavaPropertyDescriptor]

'name' @ [338:84] ==> value-parameter name: String defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper.hasModifierProperty[ValueParameterDescriptorImpl]

'ABSTRACT' @ [338:104] ==> public const final val ABSTRACT: String defined in com.intellij.psi.PsiModifier[JavaPropertyDescriptor]

'getValue' @ [340:39] ==> @InlineOnly public operator inline fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> T

'LightTypeParameterListBuilder' @ [341:9] ==> public constructor LightTypeParameterListBuilder(p0: (PsiManager..PsiManager?), p1: (Language..Language?)) defined in com.intellij.psi.impl.light.LightTypeParameterListBuilder[JavaClassConstructorDescriptor]

'manager' @ [341:39] ==> public final val KtAbstractContainerWrapper.manager: (PsiManager..PsiManager?)[MyPropertyDescriptor]

'INSTANCE' @ [341:63] ==> @NotNull public final val INSTANCE: KotlinLanguage defined in org.jetbrains.kotlin.idea.KotlinLanguage[JavaPropertyDescriptor]

'apply' @ [341:73] ==> @InlineOnly public inline fun <T> LightTypeParameterListBuilder.apply(block: LightTypeParameterListBuilder.() -> Unit): LightTypeParameterListBuilder defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> LightTypeParameterListBuilder

'superClassTypeParametersToMyTypeParameters' @ [342:13] ==> private final val superClassTypeParametersToMyTypeParameters: Map<PsiTypeParameter, PsiTypeParameter> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[PropertyDescriptorImpl]

'values' @ [342:56] ==> public abstract val values: Collection<PsiTypeParameter> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'forEach' @ [342:63] ==> @HidesMembers public inline fun <T> Iterable<PsiTypeParameter>.forEach(action: (PsiTypeParameter) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiTypeParameter

'addParameter' @ [342:73] ==> public open fun addParameter(p0: (PsiTypeParameter..PsiTypeParameter?)): Unit defined in com.intellij.psi.impl.light.LightTypeParameterListBuilder[JavaMethodDescriptor]

'it' @ [342:86] ==> value-parameter it: PsiTypeParameter defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper._typeParameterList.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'_typeParameterList' @ [346:43] ==> private final val _typeParameterList: LightTypeParameterListBuilder defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[PropertyDescriptorImpl]

'getValue' @ [348:31] ==> @InlineOnly public operator inline fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> T

'LightIdentifier' @ [348:41] ==> public constructor LightIdentifier(p0: (PsiManager..PsiManager?), p1: (String..String?)) defined in com.intellij.psi.impl.light.LightIdentifier[JavaClassConstructorDescriptor]

'manager' @ [348:57] ==> public final val KtAbstractContainerWrapper.manager: (PsiManager..PsiManager?)[MyPropertyDescriptor]

'name' @ [348:66] ==> public final var KtAbstractContainerWrapper.name: String[MyPropertyDescriptor]

'identifier' @ [349:40] ==> private final val identifier: LightIdentifier defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[PropertyDescriptorImpl]

'fqName' @ [351:30] ==> internal final val fqName: FqName defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[PropertyDescriptorImpl]

'shortName' @ [351:37] ==> @NotNull public open fun shortName(): Name defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'asString' @ [351:49] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'getValue' @ [353:36] ==> @InlineOnly public operator inline fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> T

'LightReferenceListBuilder' @ [354:9] ==> public constructor LightReferenceListBuilder(p0: (PsiManager..PsiManager?), p1: (PsiReferenceList.Role..PsiReferenceList.Role?)) defined in com.intellij.psi.impl.light.LightReferenceListBuilder[JavaClassConstructorDescriptor]

'manager' @ [354:35] ==> public final val KtAbstractContainerWrapper.manager: (PsiManager..PsiManager?)[MyPropertyDescriptor]

'IMPLEMENTS_LIST' @ [354:66] ==> enum entry IMPLEMENTS_LIST defined in com.intellij.psi.PsiReferenceList.Role[FakeCallableDescriptorForObject]

'apply' @ [354:83] ==> @InlineOnly public inline fun <T> LightReferenceListBuilder.apply(block: LightReferenceListBuilder.() -> Unit): LightReferenceListBuilder defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> LightReferenceListBuilder

'addReference' @ [355:13] ==> public open fun addReference(p0: (PsiClass..PsiClass?)): Unit defined in com.intellij.psi.impl.light.LightReferenceListBuilder[JavaMethodDescriptor]

'superInterface' @ [355:26] ==> private final val superInterface: PsiClass defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[PropertyDescriptorImpl]

'_implementsList' @ [359:40] ==> private final val _implementsList: LightReferenceListBuilder defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[PropertyDescriptorImpl]

'arrayOf' @ [361:36] ==> public inline fun <reified @PureReifiable T> arrayOf(vararg elements: PsiImmediateClassType): Array<PsiImmediateClassType> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified @PureReifiable T> -> PsiImmediateClassType

'PsiImmediateClassType' @ [361:44] ==> public constructor PsiImmediateClassType(@NotNull p0: PsiClass, @NotNull p1: PsiSubstitutor) defined in com.intellij.psi.impl.source.PsiImmediateClassType[JavaClassConstructorDescriptor]

'superInterface' @ [361:66] ==> private final val superInterface: PsiClass defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[PropertyDescriptorImpl]

'substitutor' @ [361:82] ==> internal final val substitutor: (PsiSubstitutor..PsiSubstitutor?) defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[PropertyDescriptorImpl]

'memberCache' @ [363:33] ==> private final val memberCache: ClassInnerStuffCache defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[PropertyDescriptorImpl]

'methods' @ [363:45] ==> public final val ClassInnerStuffCache.methods: (Array<(PsiMethod..PsiMethod?)>..Array<out (PsiMethod..PsiMethod?)>)[MyPropertyDescriptor]

'superClassTypeParametersToMyTypeParameters' @ [365:40] ==> private final val superClassTypeParametersToMyTypeParameters: Map<PsiTypeParameter, PsiTypeParameter> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[PropertyDescriptorImpl]

'values' @ [365:83] ==> public abstract val values: Collection<PsiTypeParameter> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'toTypedArray' @ [365:90] ==> public inline fun <reified T> Collection<PsiTypeParameter>.toTypedArray(): Array<PsiTypeParameter> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T> -> PsiTypeParameter

'arrayOf' @ [367:36] ==> public inline fun <reified @PureReifiable T> arrayOf(vararg elements: PsiClass): Array<PsiClass> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified @PureReifiable T> -> PsiClass

'superInterface' @ [367:44] ==> private final val superInterface: PsiClass defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[PropertyDescriptorImpl]

'EMPTY_ARRAY' @ [369:58] ==> public final val EMPTY_ARRAY: (Array<(PsiClassInitializer..PsiClassInitializer?)>..Array<out (PsiClassInitializer..PsiClassInitializer?)>?) defined in com.intellij.psi.PsiClassInitializer[JavaPropertyDescriptor]

'EMPTY_ARRAY' @ [373:41] ==> public final val EMPTY_ARRAY: (Array<(PsiField..PsiField?)>..Array<out (PsiField..PsiField?)>?) defined in com.intellij.psi.PsiField[JavaPropertyDescriptor]

'isInheritor' @ [376:93] ==> public open fun isInheritor(@NotNull p0: PsiClass, @NotNull p1: PsiClass, p2: Boolean): Boolean defined in com.intellij.psi.impl.InheritanceImplUtil[JavaMethodDescriptor]

'this' @ [376:105] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[LazyClassReceiverParameterDescriptor]

'baseClass' @ [376:111] ==> value-parameter baseClass: PsiClass defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper.isInheritor[ValueParameterDescriptorImpl]

'checkDeep' @ [376:122] ==> value-parameter checkDeep: Boolean defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper.isInheritor[ValueParameterDescriptorImpl]

'emptyList' @ [377:41] ==> public fun <T> emptyList(): List<PsiClass> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiClass

'EMPTY_ARRAY' @ [380:55] ==> public final val EMPTY_ARRAY: (Array<(PsiClassType..PsiClassType?)>..Array<out (PsiClassType..PsiClassType?)>?) defined in com.intellij.psi.PsiClassType[JavaPropertyDescriptor]

'isInheritorDeep' @ [381:103] ==> public open fun isInheritorDeep(@NotNull p0: PsiClass, @NotNull p1: PsiClass, @Nullable p2: PsiClass?): Boolean defined in com.intellij.psi.impl.InheritanceImplUtil[JavaMethodDescriptor]

'this' @ [381:119] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[LazyClassReceiverParameterDescriptor]

'baseClass' @ [381:125] ==> value-parameter baseClass: PsiClass defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper.isInheritorDeep[ValueParameterDescriptorImpl]

'classToByPass' @ [381:136] ==> value-parameter classToByPass: PsiClass? defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper.isInheritorDeep[ValueParameterDescriptorImpl]

'findMethodsAndTheirSubstitutorsByName' @ [384:32] ==> @NotNull public open fun findMethodsAndTheirSubstitutorsByName(@NotNull p0: PsiClass, p1: (String..String?), p2: Boolean): (MutableList<(Pair<(PsiMethod..PsiMethod?), (PsiSubstitutor..PsiSubstitutor?)>..Pair<(PsiMethod..PsiMethod?), (PsiSubstitutor..PsiSubstitutor?)>?)>..List<(Pair<(PsiMethod..PsiMethod?), (PsiSubstitutor..PsiSubstitutor?)>..Pair<(PsiMethod..PsiMethod?), (PsiSubstitutor..PsiSubstitutor?)>?)>) defined in com.intellij.psi.impl.PsiClassImplUtil[JavaMethodDescriptor]

'this' @ [384:70] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[LazyClassReceiverParameterDescriptor]

'name' @ [384:76] ==> value-parameter name: String? defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper.findMethodsAndTheirSubstitutorsByName[ValueParameterDescriptorImpl]

'checkBases' @ [384:82] ==> value-parameter checkBases: Boolean defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper.findMethodsAndTheirSubstitutorsByName[ValueParameterDescriptorImpl]

'EMPTY_ARRAY' @ [386:47] ==> @NotNull public final val EMPTY_ARRAY: (Array<(PsiClass..PsiClass?)>..Array<out (PsiClass..PsiClass?)>) defined in com.intellij.psi.PsiClass[JavaPropertyDescriptor]

'findMethodBySignature' @ [388:32] ==> @Nullable public open fun findMethodBySignature(@NotNull p0: PsiClass, @NotNull p1: PsiMethod, p2: Boolean): PsiMethod? defined in com.intellij.psi.impl.PsiClassImplUtil[JavaMethodDescriptor]

'this' @ [388:54] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[LazyClassReceiverParameterDescriptor]

'patternMethod' @ [388:60] ==> value-parameter patternMethod: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper.findMethodBySignature[ValueParameterDescriptorImpl]

'checkBases' @ [388:75] ==> value-parameter checkBases: Boolean defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper.findMethodBySignature[ValueParameterDescriptorImpl]

'getAllFields' @ [391:52] ==> @NotNull public open fun getAllFields(@NotNull p0: PsiClass): (Array<(PsiField..PsiField?)>..Array<out (PsiField..PsiField?)>) defined in com.intellij.psi.impl.PsiClassImplUtil[JavaMethodDescriptor]

'this' @ [391:65] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[LazyClassReceiverParameterDescriptor]

'getAllInnerClasses' @ [392:58] ==> @NotNull public open fun getAllInnerClasses(@NotNull p0: PsiClass): (Array<(PsiClass..PsiClass?)>..Array<out (PsiClass..PsiClass?)>) defined in com.intellij.psi.impl.PsiClassImplUtil[JavaMethodDescriptor]

'this' @ [392:77] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[LazyClassReceiverParameterDescriptor]

'memberCache' @ [393:74] ==> private final val memberCache: ClassInnerStuffCache defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[PropertyDescriptorImpl]

'findMethodsByName' @ [393:86] ==> @NotNull public open fun findMethodsByName(p0: (String..String?), p1: Boolean): (Array<(PsiMethod..PsiMethod?)>..Array<out (PsiMethod..PsiMethod?)>) defined in com.intellij.psi.impl.source.ClassInnerStuffCache[JavaMethodDescriptor]

'name' @ [393:104] ==> value-parameter name: String? defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper.findMethodsByName[ValueParameterDescriptorImpl]

'checkBases' @ [393:110] ==> value-parameter checkBases: Boolean defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper.findMethodsByName[ValueParameterDescriptorImpl]

'getAllMethods' @ [394:53] ==> @NotNull public open fun getAllMethods(@NotNull p0: PsiClass): (Array<(PsiMethod..PsiMethod?)>..Array<out (PsiMethod..PsiMethod?)>) defined in com.intellij.psi.impl.PsiClassImplUtil[JavaMethodDescriptor]

'this' @ [394:67] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[LazyClassReceiverParameterDescriptor]

'emptyList' @ [395:35] ==> public fun <T> emptyList(): List<PsiField> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiField

'getAllWithSubstitutorsByMap' @ [397:30] ==> @NotNull public open fun <T : (PsiMember..PsiMember?)> getAllWithSubstitutorsByMap(@NotNull p0: PsiClass, @NotNull p1: PsiClassImplUtil.MemberType): (MutableList<(Pair<(PsiMethod..PsiMethod?), (PsiSubstitutor..PsiSubstitutor?)>..Pair<(PsiMethod..PsiMethod?), (PsiSubstitutor..PsiSubstitutor?)>?)>..List<(Pair<(PsiMethod..PsiMethod?), (PsiSubstitutor..PsiSubstitutor?)>..Pair<(PsiMethod..PsiMethod?), (PsiSubstitutor..PsiSubstitutor?)>?)>) defined in com.intellij.psi.impl.PsiClassImplUtil[JavaMethodDescriptor]
Inferred types:
    <T : (PsiMember..PsiMember?)> -> PsiMethod

'this' @ [397:69] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[LazyClassReceiverParameterDescriptor]

'METHOD' @ [397:103] ==> enum entry METHOD defined in com.intellij.psi.impl.PsiClassImplUtil.MemberType[FakeCallableDescriptorForObject]

'getVisibleSignatures' @ [402:66] ==> @NotNull public open fun getVisibleSignatures(@NotNull p0: PsiClass): (MutableCollection<(HierarchicalMethodSignature..HierarchicalMethodSignature?)>..Collection<(HierarchicalMethodSignature..HierarchicalMethodSignature?)>) defined in com.intellij.psi.impl.PsiSuperMethodImplUtil[JavaMethodDescriptor]

'this' @ [402:87] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[LazyClassReceiverParameterDescriptor]

'getValue' @ [406:34] ==> @InlineOnly public operator inline fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> T

'LightModifierList' @ [406:44] ==> public constructor LightModifierList(p0: (PsiManager..PsiManager?), p1: (Language..Language?), vararg p2: (String..String?)) defined in com.intellij.psi.impl.light.LightModifierList[JavaClassConstructorDescriptor]

'manager' @ [406:62] ==> public final val KtAbstractContainerWrapper.manager: (PsiManager..PsiManager?)[MyPropertyDescriptor]

'INSTANCE' @ [406:86] ==> @NotNull public final val INSTANCE: KotlinLanguage defined in org.jetbrains.kotlin.idea.KotlinLanguage[JavaPropertyDescriptor]

'PUBLIC' @ [406:108] ==> public const final val PUBLIC: String defined in com.intellij.psi.PsiModifier[JavaPropertyDescriptor]

'_modifierList' @ [407:38] ==> private final val _modifierList: LightModifierList defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[PropertyDescriptorImpl]

'superInterface' @ [408:31] ==> private final val superInterface: PsiClass defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[PropertyDescriptorImpl]

'scope' @ [408:46] ==> public final val PsiClass.scope: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'superTypes' @ [409:45] ==> public final val KtAbstractContainerWrapper.superTypes: Array<PsiImmediateClassType>[MyPropertyDescriptor]

'EMPTY_ARRAY' @ [410:48] ==> public final val EMPTY_ARRAY: (Array<(PsiMethod..PsiMethod?)>..Array<out (PsiMethod..PsiMethod?)>?) defined in com.intellij.psi.PsiMethod[JavaPropertyDescriptor]

'cannotModify' @ [412:42] ==> public fun LightElement.cannotModify(): Nothing defined in org.jetbrains.kotlin.asJava.classes[DeserializedSimpleFunctionDescriptor]

'findMethodsBySignature' @ [414:32] ==> @NotNull public open fun findMethodsBySignature(@NotNull p0: PsiClass, @NotNull p1: PsiMethod, p2: Boolean): (Array<(PsiMethod..PsiMethod?)>..Array<out (PsiMethod..PsiMethod?)>) defined in com.intellij.psi.impl.PsiClassImplUtil[JavaMethodDescriptor]

'this' @ [414:55] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper[LazyClassReceiverParameterDescriptor]

'patternMethod' @ [414:61] ==> value-parameter patternMethod: PsiMethod defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper.findMethodsBySignature[ValueParameterDescriptorImpl]

'checkBases' @ [414:76] ==> value-parameter checkBases: Boolean defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.KtAbstractContainerWrapper.findMethodsBySignature[ValueParameterDescriptorImpl]

'PsiImmediateClassType' @ [417:41] ==> public constructor PsiImmediateClassType(@NotNull p0: PsiClass, @NotNull p1: PsiSubstitutor) defined in com.intellij.psi.impl.source.PsiImmediateClassType[JavaClassConstructorDescriptor]

'this' @ [417:63] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.lightClasses.asType[ReceiverParameterDescriptorImpl]

'EMPTY' @ [417:84] ==> @NotNull public final val EMPTY: PsiSubstitutor defined in com.intellij.psi.PsiSubstitutor[JavaPropertyDescriptor]

