'resolveElementCache' @ [34:23] ==> private final val resolveElementCache: ResolveElementCache defined in org.jetbrains.kotlin.idea.project.IdeaLocalDescriptorResolver[PropertyDescriptorImpl]

'resolveToElements' @ [34:43] ==> public final fun resolveToElements(elements: Collection<KtElement>, bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.project.ResolveElementCache[SimpleFunctionDescriptorImpl]

'listOf' @ [34:61] ==> public fun <T> listOf(element: KtDeclaration): List<KtDeclaration> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtDeclaration

'declaration' @ [34:68] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.idea.project.IdeaLocalDescriptorResolver.resolveLocalDeclaration[ValueParameterDescriptorImpl]

'FULL' @ [34:98] ==> enum entry FULL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'context' @ [35:16] ==> val context: BindingContext defined in org.jetbrains.kotlin.idea.project.IdeaLocalDescriptorResolver.resolveLocalDeclaration[LocalVariableDescriptor]

'get' @ [35:24] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(p0: (ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>?), p1: (PsiElement..PsiElement?)): DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.descriptors.DeclarationDescriptor..org.jetbrains.kotlin.descriptors.DeclarationDescriptor?)

'DECLARATION_TO_DESCRIPTOR' @ [35:43] ==> public final val DECLARATION_TO_DESCRIPTOR: (ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'declaration' @ [35:70] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.idea.project.IdeaLocalDescriptorResolver.resolveLocalDeclaration[ValueParameterDescriptorImpl]

'absentDescriptorHandler' @ [36:19] ==> private final val absentDescriptorHandler: AbsentDescriptorHandler defined in org.jetbrains.kotlin.idea.project.IdeaLocalDescriptorResolver[PropertyDescriptorImpl]

'diagnoseDescriptorNotFound' @ [36:43] ==> public abstract fun diagnoseDescriptorNotFound(declaration: KtDeclaration): DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.lazy.AbsentDescriptorHandler[DeserializedSimpleFunctionDescriptor]

'declaration' @ [36:70] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.idea.project.IdeaLocalDescriptorResolver.resolveLocalDeclaration[ValueParameterDescriptorImpl]

'NoDescriptorForDeclarationException' @ [44:15] ==> @JvmOverloads public constructor NoDescriptorForDeclarationException(declaration: KtDeclaration, additionalDetails: String? = ...) defined in org.jetbrains.kotlin.resolve.lazy.NoDescriptorForDeclarationException[DeserializedClassConstructorDescriptor]

'declaration' @ [45:17] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.idea.project.IdeaAbsentDescriptorHandler.diagnoseDescriptorNotFound[ValueParameterDescriptorImpl]

'declarationProviderFactory' @ [46:18] ==> private final val declarationProviderFactory: DeclarationProviderFactory defined in org.jetbrains.kotlin.idea.project.IdeaAbsentDescriptorHandler[PropertyDescriptorImpl]

'debugToString' @ [46:84] ==> public final fun debugToString(): String defined in org.jetbrains.kotlin.idea.stubindex.resolve.PluginDeclarationProviderFactory[SimpleFunctionDescriptorImpl]

