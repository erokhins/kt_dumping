'this' @ [36:50] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[ReceiverParameterDescriptorImpl]

'getModuleInfo' @ [36:55] ==> private fun PsiElement.getModuleInfo(onFailure: (String) -> IdeaModuleInfo?): IdeaModuleInfo? defined in org.jetbrains.kotlin.idea.caches.resolve[SimpleFunctionDescriptorImpl]

'LOG' @ [37:5] ==> internal val LOG: Logger defined in org.jetbrains.kotlin.idea.caches.resolve in file KotlinCacheServiceImpl.kt[PropertyDescriptorImpl]

'error' @ [37:9] ==> public open fun error(@NonNls p0: (String..String?)): Unit defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'reason' @ [37:69] ==> value-parameter reason: String defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo.<anonymous>[ValueParameterDescriptorImpl]

'NotUnderContentRootModuleInfo' @ [38:5] ==> internal object NotUnderContentRootModuleInfo : IdeaModuleInfo defined in org.jetbrains.kotlin.idea.caches.resolve in file IdeaModuleInfos.kt[FakeCallableDescriptorForObject]

'NotUnderContentRootModuleInfo' @ [39:6] ==> internal object NotUnderContentRootModuleInfo : IdeaModuleInfo defined in org.jetbrains.kotlin.idea.caches.resolve in file IdeaModuleInfos.kt[FakeCallableDescriptorForObject]

'this' @ [41:59] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.getNullableModuleInfo[ReceiverParameterDescriptorImpl]

'getModuleInfo' @ [41:64] ==> private fun PsiElement.getModuleInfo(onFailure: (String) -> IdeaModuleInfo?): IdeaModuleInfo? defined in org.jetbrains.kotlin.idea.caches.resolve[SimpleFunctionDescriptorImpl]

'LOG' @ [42:5] ==> internal val LOG: Logger defined in org.jetbrains.kotlin.idea.caches.resolve in file KotlinCacheServiceImpl.kt[PropertyDescriptorImpl]

'warn' @ [42:9] ==> public open fun warn(@NonNls p0: (String..String?)): Unit defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'reason' @ [42:68] ==> value-parameter reason: String defined in org.jetbrains.kotlin.idea.caches.resolve.getNullableModuleInfo.<anonymous>[ValueParameterDescriptorImpl]

'containingFile' @ [47:6] ==> public final val PsiElement.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'moduleInfo' @ [47:22] ==> public var PsiFile.moduleInfo: ModuleInfo? defined in org.jetbrains.kotlin.psi[DeserializedPropertyDescriptor]

'let' @ [47:54] ==> @InlineOnly public inline fun <T, R> IdeaModuleInfo.let(block: (IdeaModuleInfo) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> IdeaModuleInfo
    <R> -> Nothing

'it' @ [47:67] ==> value-parameter it: IdeaModuleInfo defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo.<anonymous>[ValueParameterDescriptorImpl]

'this' @ [49:9] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[ReceiverParameterDescriptorImpl]

'this' @ [49:46] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[ReceiverParameterDescriptorImpl]

'getModuleInfoForLightElement' @ [49:51] ==> private fun KtLightElement<*, *>.getModuleInfoForLightElement(onFailure: (String) -> IdeaModuleInfo?): IdeaModuleInfo? defined in org.jetbrains.kotlin.idea.caches.resolve[SimpleFunctionDescriptorImpl]

'onFailure' @ [49:80] ==> value-parameter onFailure: (String) -> IdeaModuleInfo? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[ValueParameterDescriptorImpl]

'this' @ [51:30] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[ReceiverParameterDescriptorImpl]

'containingFile' @ [51:51] ==> public final val KtElement.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'containingJetFile' @ [52:19] ==> val containingJetFile: KtFile? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[LocalVariableDescriptor]

'analysisContext' @ [52:38] ==> public var KtFile.analysisContext: PsiElement? defined in org.jetbrains.kotlin.psi[DeserializedPropertyDescriptor]

'context' @ [53:9] ==> val context: PsiElement? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[LocalVariableDescriptor]

'context' @ [53:33] ==> val context: PsiElement? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[LocalVariableDescriptor]

'getModuleInfo' @ [53:41] ==> public fun PsiElement.getModuleInfo(): IdeaModuleInfo defined in org.jetbrains.kotlin.idea.caches.resolve in file getModuleInfo.kt[SimpleFunctionDescriptorImpl]

'containingJetFile' @ [55:24] ==> val containingJetFile: KtFile? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[LocalVariableDescriptor]

'doNotAnalyze' @ [55:43] ==> public var KtFile.doNotAnalyze: String? defined in org.jetbrains.kotlin.psi[DeserializedPropertyDescriptor]

'doNotAnalyze' @ [56:9] ==> val doNotAnalyze: String? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[LocalVariableDescriptor]

'invoke' @ [57:16] ==> public abstract operator fun invoke(p1: String): IdeaModuleInfo? defined in kotlin.Function1[FunctionInvokeDescriptor]

'text' @ [58:47] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'containingJetFile' @ [58:62] ==> val containingJetFile: KtFile? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[LocalVariableDescriptor]

'name' @ [58:80] ==> public final var KtFile.name: String[MyPropertyDescriptor]

'doNotAnalyze' @ [58:88] ==> val doNotAnalyze: String? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[LocalVariableDescriptor]

'containingJetFile' @ [62:30] ==> val containingJetFile: KtFile? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[LocalVariableDescriptor]

'moduleInfo' @ [62:49] ==> public var PsiFile.moduleInfo: ModuleInfo? defined in org.jetbrains.kotlin.psi[DeserializedPropertyDescriptor]

'containingJetFile' @ [62:64] ==> val containingJetFile: KtFile? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[LocalVariableDescriptor]

'originalFile' @ [62:83] ==> public final var KtFile.originalFile: PsiFile[MyPropertyDescriptor]

'moduleInfo' @ [62:109] ==> public var PsiFile.moduleInfo: ModuleInfo? defined in org.jetbrains.kotlin.psi[DeserializedPropertyDescriptor]

'explicitModuleInfo' @ [63:9] ==> val explicitModuleInfo: ModuleInfo? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[LocalVariableDescriptor]

'explicitModuleInfo' @ [63:54] ==> val explicitModuleInfo: ModuleInfo? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[LocalVariableDescriptor]

'containingJetFile' @ [65:9] ==> val containingJetFile: KtFile? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[LocalVariableDescriptor]

'containingJetFile' @ [66:16] ==> val containingJetFile: KtFile? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[LocalVariableDescriptor]

'getContext' @ [66:34] ==> public open fun getContext(): PsiElement? defined in org.jetbrains.kotlin.psi.KtFile[JavaMethodDescriptor]

'getModuleInfo' @ [66:48] ==> public fun PsiElement.getModuleInfo(): IdeaModuleInfo defined in org.jetbrains.kotlin.idea.caches.resolve in file getModuleInfo.kt[SimpleFunctionDescriptorImpl]

'invoke' @ [67:19] ==> public abstract operator fun invoke(p1: String): IdeaModuleInfo? defined in kotlin.Function1[FunctionInvokeDescriptor]

'containingJetFile' @ [67:64] ==> val containingJetFile: KtFile? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[LocalVariableDescriptor]

'java' @ [67:89] ==> public val <T> KClass<out KtFile>.java: Class<out KtFile> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtFile

'containingJetFile' @ [67:129] ==> val containingJetFile: KtFile? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[LocalVariableDescriptor]

'getText' @ [67:147] ==> public open fun getText(): (String..String?) defined in org.jetbrains.kotlin.psi.KtFile[JavaMethodDescriptor]

'containingFile' @ [70:26] ==> public final val PsiElement.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'invoke' @ [70:51] ==> public abstract operator fun invoke(p1: String): IdeaModuleInfo? defined in kotlin.Function1[FunctionInvokeDescriptor]

'this' @ [70:90] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[ReceiverParameterDescriptorImpl]

'java' @ [70:102] ==> public val <T> KClass<out PsiElement>.java: Class<out PsiElement> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> PsiElement

'text' @ [70:141] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'containingFile' @ [72:23] ==> val containingFile: PsiFile defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[LocalVariableDescriptor]

'originalFile' @ [72:38] ==> public final val PsiFile.originalFile: PsiFile[MyPropertyDescriptor]

'virtualFile' @ [72:51] ==> public final val PsiFile.virtualFile: (VirtualFile..VirtualFile?)[MyPropertyDescriptor]

'invoke' @ [73:23] ==> public abstract operator fun invoke(p1: String): IdeaModuleInfo? defined in kotlin.Function1[FunctionInvokeDescriptor]

'this' @ [73:62] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[ReceiverParameterDescriptorImpl]

'java' @ [73:74] ==> public val <T> KClass<out PsiElement>.java: Class<out PsiElement> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> PsiElement

'containingFile' @ [73:102] ==> val containingFile: PsiFile defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[LocalVariableDescriptor]

'containingFile' @ [73:127] ==> val containingFile: PsiFile defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[LocalVariableDescriptor]

'java' @ [73:149] ==> public val <T> KClass<out PsiFile>.java: Class<out PsiFile> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> PsiFile

'text' @ [73:164] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'getModuleInfoByVirtualFile' @ [75:12] ==> private fun getModuleInfoByVirtualFile(project: Project, virtualFile: VirtualFile, treatAsLibrarySource: Boolean): IdeaModuleInfo? defined in org.jetbrains.kotlin.idea.caches.resolve in file getModuleInfo.kt[SimpleFunctionDescriptorImpl]

'project' @ [76:13] ==> public final val PsiElement.project: Project[MyPropertyDescriptor]

'virtualFile' @ [77:13] ==> val virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[LocalVariableDescriptor]

'?:' @ [78:36] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: Boolean?, right: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> Boolean

'containingFile' @ [78:37] ==> val containingFile: PsiFile defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfo[LocalVariableDescriptor]

'isCompiled' @ [78:65] ==> public final val KtFile.isCompiled: Boolean[MyPropertyDescriptor]

'getModuleInfoByVirtualFile' @ [84:22] ==> private fun getModuleInfoByVirtualFile(project: Project, virtualFile: VirtualFile, treatAsLibrarySource: Boolean): IdeaModuleInfo? defined in org.jetbrains.kotlin.idea.caches.resolve in file getModuleInfo.kt[SimpleFunctionDescriptorImpl]

'project' @ [84:49] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[ValueParameterDescriptorImpl]

'virtualFile' @ [84:58] ==> value-parameter virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[ValueParameterDescriptorImpl]

'getInstance' @ [87:53] ==> public open fun getInstance(p0: (Project..Project?)): (ProjectFileIndex..ProjectFileIndex?) defined in com.intellij.openapi.roots.ProjectFileIndex.SERVICE[JavaMethodDescriptor]

'project' @ [87:65] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[ValueParameterDescriptorImpl]

'projectFileIndex' @ [89:18] ==> val projectFileIndex: (ProjectFileIndex..ProjectFileIndex?) defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[LocalVariableDescriptor]

'getModuleForFile' @ [89:35] ==> @Nullable public abstract fun getModuleForFile(@NotNull p0: VirtualFile): Module? defined in com.intellij.openapi.roots.ProjectFileIndex[JavaMethodDescriptor]

'virtualFile' @ [89:52] ==> value-parameter virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[ValueParameterDescriptorImpl]

'module' @ [90:9] ==> val module: Module? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[LocalVariableDescriptor]

'module' @ [91:13] ==> val module: Module? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[LocalVariableDescriptor]

'isDisposed' @ [91:20] ==> public final val Module.isDisposed: Boolean[MyPropertyDescriptor]

'treatAsLibrarySource' @ [94:17] ==> value-parameter treatAsLibrarySource: Boolean defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[ValueParameterDescriptorImpl]

'LOG' @ [95:17] ==> internal val LOG: Logger defined in org.jetbrains.kotlin.idea.caches.resolve in file KotlinCacheServiceImpl.kt[PropertyDescriptorImpl]

'warn' @ [95:21] ==> public open fun warn(@NonNls p0: (String..String?)): Unit defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'virtualFile' @ [95:49] ==> value-parameter virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[ValueParameterDescriptorImpl]

'canonicalPath' @ [95:61] ==> public final val VirtualFile.canonicalPath: String?[MyPropertyDescriptor]

'module' @ [95:94] ==> val module: Module? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[LocalVariableDescriptor]

'getInstance' @ [99:49] ==> public open fun getInstance(@NotNull p0: Module): (ModuleRootManager..ModuleRootManager?) defined in com.intellij.openapi.roots.ModuleRootManager[JavaMethodDescriptor]

'module' @ [99:61] ==> val module: Module? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[LocalVariableDescriptor]

'fileIndex' @ [99:69] ==> public final val ModuleRootManager.fileIndex: ModuleFileIndex[MyPropertyDescriptor]

'if (moduleFileIndex.isInTestSourceContent(virtualFile)) {
            warnIfDecompiled()
            return module.testSourceInfo()
        }
        else if (moduleFileIndex.isInSourceContentWithoutInjected(virtualFile)) {
            warnIfDecompiled()
            return module.productionSourceInfo()
        }' @ [100:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'moduleFileIndex' @ [100:13] ==> val moduleFileIndex: ModuleFileIndex defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[LocalVariableDescriptor]

'isInTestSourceContent' @ [100:29] ==> public abstract fun isInTestSourceContent(@NotNull p0: VirtualFile): Boolean defined in com.intellij.openapi.roots.ModuleFileIndex[JavaMethodDescriptor]

'virtualFile' @ [100:51] ==> value-parameter virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[ValueParameterDescriptorImpl]

'warnIfDecompiled' @ [101:13] ==> local final fun warnIfDecompiled(): Unit defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[SimpleFunctionDescriptorImpl]

'module' @ [102:20] ==> val module: Module? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[LocalVariableDescriptor]

'testSourceInfo' @ [102:27] ==> public fun Module.testSourceInfo(): ModuleTestSourceInfo defined in org.jetbrains.kotlin.idea.caches.resolve in file IdeaModuleInfos.kt[SimpleFunctionDescriptorImpl]

'moduleFileIndex' @ [104:18] ==> val moduleFileIndex: ModuleFileIndex defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[LocalVariableDescriptor]

'isInSourceContentWithoutInjected' @ [104:34] ==> public fun FileIndex.isInSourceContentWithoutInjected(file: VirtualFile): Boolean defined in org.jetbrains.kotlin.idea.util in file ProjectRootsUtil.kt[SimpleFunctionDescriptorImpl]

'virtualFile' @ [104:67] ==> value-parameter virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[ValueParameterDescriptorImpl]

'warnIfDecompiled' @ [105:13] ==> local final fun warnIfDecompiled(): Unit defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[SimpleFunctionDescriptorImpl]

'module' @ [106:20] ==> val module: Module? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[LocalVariableDescriptor]

'productionSourceInfo' @ [106:27] ==> public fun Module.productionSourceInfo(): ModuleProductionSourceInfo defined in org.jetbrains.kotlin.idea.caches.resolve in file IdeaModuleInfos.kt[SimpleFunctionDescriptorImpl]

'projectFileIndex' @ [110:5] ==> val projectFileIndex: (ProjectFileIndex..ProjectFileIndex?) defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[LocalVariableDescriptor]

'getOrderEntriesForFile' @ [110:22] ==> @NotNull public abstract fun getOrderEntriesForFile(@NotNull p0: VirtualFile): (MutableList<(OrderEntry..OrderEntry?)>..List<(OrderEntry..OrderEntry?)>) defined in com.intellij.openapi.roots.ProjectFileIndex[JavaMethodDescriptor]

'virtualFile' @ [110:45] ==> value-parameter virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[ValueParameterDescriptorImpl]

'process' @ [111:14] ==> private inline fun List<OrderEntry>.process(project: Project, virtualFile: VirtualFile, treatAsLibrarySource: Boolean = ..., body: (IdeaModuleInfo) -> Unit): Unit defined in org.jetbrains.kotlin.idea.caches.resolve[SimpleFunctionDescriptorImpl]

'project' @ [111:22] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[ValueParameterDescriptorImpl]

'virtualFile' @ [111:31] ==> value-parameter virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[ValueParameterDescriptorImpl]

'treatAsLibrarySource' @ [111:44] ==> value-parameter treatAsLibrarySource: Boolean defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[ValueParameterDescriptorImpl]

'correspondingModuleInfo' @ [112:24] ==> value-parameter correspondingModuleInfo: IdeaModuleInfo defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile.<anonymous>[ValueParameterDescriptorImpl]

'getScriptDefinition' @ [115:28] ==> public fun getScriptDefinition(file: VirtualFile, project: Project): KotlinScriptDefinition? defined in org.jetbrains.kotlin.script[DeserializedSimpleFunctionDescriptor]

'virtualFile' @ [115:48] ==> value-parameter virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[ValueParameterDescriptorImpl]

'project' @ [115:61] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[ValueParameterDescriptorImpl]

'scriptDefinition' @ [116:9] ==> val scriptDefinition: KotlinScriptDefinition? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[LocalVariableDescriptor]

'ScriptModuleInfo' @ [117:16] ==> public constructor ScriptModuleInfo(project: Project, scriptFile: VirtualFile, scriptDefinition: KotlinScriptDefinition) defined in org.jetbrains.kotlin.idea.caches.resolve.ScriptModuleInfo[ClassConstructorDescriptorImpl]

'project' @ [117:33] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[ValueParameterDescriptorImpl]

'virtualFile' @ [117:42] ==> value-parameter virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[ValueParameterDescriptorImpl]

'scriptDefinition' @ [117:55] ==> val scriptDefinition: KotlinScriptDefinition? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[LocalVariableDescriptor]

'virtualFile' @ [120:20] ==> value-parameter virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[ValueParameterDescriptorImpl]

'isKotlinBinary' @ [120:32] ==> public fun VirtualFile.isKotlinBinary(): Boolean defined in org.jetbrains.kotlin.idea.util in file ProjectRootsUtil.kt[SimpleFunctionDescriptorImpl]

'ScriptDependenciesManager' @ [121:38] ==> public companion object defined in org.jetbrains.kotlin.idea.core.script.ScriptDependenciesManager[FakeCallableDescriptorForObject]

'getInstance' @ [121:64] ==> @JvmStatic public final fun getInstance(project: Project): ScriptDependenciesManager defined in org.jetbrains.kotlin.idea.core.script.ScriptDependenciesManager.Companion[SimpleFunctionDescriptorImpl]

'project' @ [121:76] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[ValueParameterDescriptorImpl]

'isBinary' @ [122:9] ==> val isBinary: Boolean defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[LocalVariableDescriptor]

'virtualFile' @ [122:21] ==> value-parameter virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[ValueParameterDescriptorImpl]

'scriptConfigurationManager' @ [122:36] ==> val scriptConfigurationManager: ScriptDependenciesManager defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[LocalVariableDescriptor]

'getAllScriptsClasspathScope' @ [122:63] ==> public final fun getAllScriptsClasspathScope(): NonClasspathDirectoriesScope defined in org.jetbrains.kotlin.idea.core.script.ScriptDependenciesManager[SimpleFunctionDescriptorImpl]

'if (treatAsLibrarySource) {
            ScriptDependenciesSourceModuleInfo(project)
        }
        else {
            ScriptDependenciesModuleInfo(project, null)
        }' @ [123:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: IdeaModuleInfo?, elseBranch: IdeaModuleInfo?): IdeaModuleInfo?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> IdeaModuleInfo?

'treatAsLibrarySource' @ [123:20] ==> value-parameter treatAsLibrarySource: Boolean defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[ValueParameterDescriptorImpl]

'ScriptDependenciesSourceModuleInfo' @ [124:13] ==> public constructor ScriptDependenciesSourceModuleInfo(project: Project) defined in org.jetbrains.kotlin.idea.caches.resolve.ScriptDependenciesSourceModuleInfo[ClassConstructorDescriptorImpl]

'project' @ [124:48] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[ValueParameterDescriptorImpl]

'ScriptDependenciesModuleInfo' @ [127:13] ==> public constructor ScriptDependenciesModuleInfo(project: Project, scriptModuleInfo: ScriptModuleInfo?) defined in org.jetbrains.kotlin.idea.caches.resolve.ScriptDependenciesModuleInfo[ClassConstructorDescriptorImpl]

'project' @ [127:42] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[ValueParameterDescriptorImpl]

'!' @ [130:9] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isBinary' @ [130:10] ==> val isBinary: Boolean defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[LocalVariableDescriptor]

'virtualFile' @ [130:22] ==> value-parameter virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[ValueParameterDescriptorImpl]

'scriptConfigurationManager' @ [130:37] ==> val scriptConfigurationManager: ScriptDependenciesManager defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[LocalVariableDescriptor]

'getAllLibrarySourcesScope' @ [130:64] ==> public final fun getAllLibrarySourcesScope(): NonClasspathDirectoriesScope defined in org.jetbrains.kotlin.idea.core.script.ScriptDependenciesManager[SimpleFunctionDescriptorImpl]

'ScriptDependenciesSourceModuleInfo' @ [131:16] ==> public constructor ScriptDependenciesSourceModuleInfo(project: Project) defined in org.jetbrains.kotlin.idea.caches.resolve.ScriptDependenciesSourceModuleInfo[ClassConstructorDescriptorImpl]

'project' @ [131:51] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoByVirtualFile[ValueParameterDescriptorImpl]

'this' @ [138:27] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoForLightElement[ReceiverParameterDescriptorImpl]

'getParentOfType' @ [138:32] ==> public inline fun <reified T : PsiElement> PsiElement.getParentOfType(strict: Boolean): KtLightClassForDecompiledDeclaration? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtLightClassForDecompiledDeclaration

'decompiledClass' @ [139:9] ==> val decompiledClass: KtLightClassForDecompiledDeclaration? defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoForLightElement[LocalVariableDescriptor]

'getModuleInfoByVirtualFile' @ [140:16] ==> private fun getModuleInfoByVirtualFile(project: Project, virtualFile: VirtualFile, treatAsLibrarySource: Boolean): IdeaModuleInfo? defined in org.jetbrains.kotlin.idea.caches.resolve in file getModuleInfo.kt[SimpleFunctionDescriptorImpl]

'project' @ [141:17] ==> public final val <out T : KtElement, out D : PsiElement> KtLightElement<KtElement, PsiElement>.project: Project[MyPropertyDescriptor]
Inferred types:
    <out T : KtElement> -> KtElement
    <out D : PsiElement> -> PsiElement

'containingFile' @ [142:17] ==> public final val <out T : KtElement, out D : PsiElement> KtLightElement<KtElement, PsiElement>.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]
Inferred types:
    <out T : KtElement> -> KtElement
    <out D : PsiElement> -> PsiElement

'virtualFile' @ [142:32] ==> public final val PsiFile.virtualFile: (VirtualFile..VirtualFile?)[MyPropertyDescriptor]

'sure' @ [142:44] ==> public inline fun <T : Any> VirtualFile?.sure(message: () -> String): VirtualFile defined in org.jetbrains.kotlin.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> VirtualFile

'kotlinOrigin' @ [146:19] ==> public abstract val kotlinOrigin: KtElement? defined in org.jetbrains.kotlin.asJava.elements.KtLightElement[DeserializedPropertyDescriptor]

'when (this) {
        is FakeLightClassForFileOfPackage -> this.getContainingFile()!!
        is KtLightClassForFacade -> this.files.first()
        else -> return onFailure("Light element without origin is referenced by resolve:\n$this\n${this.clsDelegate.text}")
    }' @ [146:35] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: PsiFile, entry1: PsiFile, entry2: PsiFile): PsiFile[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> PsiFile

'this' @ [146:41] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoForLightElement[ReceiverParameterDescriptorImpl]

'this' @ [147:46] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoForLightElement[ReceiverParameterDescriptorImpl]

'getContainingFile' @ [147:51] ==> @Contract public abstract fun getContainingFile(): (PsiFile..PsiFile?) defined in org.jetbrains.kotlin.asJava.elements.KtLightElement[JavaMethodDescriptor]

'this' @ [148:37] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoForLightElement[ReceiverParameterDescriptorImpl]

'files' @ [148:42] ==> public final val files: Collection<KtFile> defined in org.jetbrains.kotlin.asJava.classes.KtLightClassForFacade[DeserializedPropertyDescriptor]

'first' @ [148:48] ==> public fun <T> Iterable<KtFile>.first(): KtFile defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtFile

'invoke' @ [149:24] ==> public abstract operator fun invoke(p1: String): IdeaModuleInfo? defined in kotlin.Function1[FunctionInvokeDescriptor]

'this' @ [149:92] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoForLightElement[ReceiverParameterDescriptorImpl]

'this' @ [149:100] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoForLightElement[ReceiverParameterDescriptorImpl]

'clsDelegate' @ [149:105] ==> public abstract val clsDelegate: PsiElement defined in org.jetbrains.kotlin.asJava.elements.KtLightElement[DeserializedPropertyDescriptor]

'text' @ [149:117] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'element' @ [151:12] ==> val element: NavigatablePsiElement defined in org.jetbrains.kotlin.idea.caches.resolve.getModuleInfoForLightElement[LocalVariableDescriptor]

'getModuleInfo' @ [151:20] ==> public fun PsiElement.getModuleInfo(): IdeaModuleInfo defined in org.jetbrains.kotlin.idea.caches.resolve in file getModuleInfo.kt[SimpleFunctionDescriptorImpl]

'collectModuleInfosByType' @ [154:81] ==> private inline fun <reified T : IdeaModuleInfo> collectModuleInfosByType(project: Project, virtualFile: VirtualFile): Collection<BinaryModuleInfo> defined in org.jetbrains.kotlin.idea.caches.resolve[SimpleFunctionDescriptorImpl]
Inferred types:
    <reified T : IdeaModuleInfo> -> BinaryModuleInfo

'project' @ [154:124] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.caches.resolve.getBinaryLibrariesModuleInfos[ValueParameterDescriptorImpl]

'virtualFile' @ [154:133] ==> value-parameter virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.caches.resolve.getBinaryLibrariesModuleInfos[ValueParameterDescriptorImpl]

'collectModuleInfosByType' @ [155:80] ==> private inline fun <reified T : IdeaModuleInfo> collectModuleInfosByType(project: Project, virtualFile: VirtualFile): Collection<LibrarySourceInfo> defined in org.jetbrains.kotlin.idea.caches.resolve[SimpleFunctionDescriptorImpl]
Inferred types:
    <reified T : IdeaModuleInfo> -> LibrarySourceInfo

'project' @ [155:124] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.caches.resolve.getLibrarySourcesModuleInfos[ValueParameterDescriptorImpl]

'virtualFile' @ [155:133] ==> value-parameter virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.caches.resolve.getLibrarySourcesModuleInfos[ValueParameterDescriptorImpl]

'getInstance' @ [158:49] ==> public open fun getInstance(p0: (Project..Project?)): (ProjectFileIndex..ProjectFileIndex?) defined in com.intellij.openapi.roots.ProjectFileIndex.SERVICE[JavaMethodDescriptor]

'project' @ [158:61] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.caches.resolve.collectModuleInfosByType[ValueParameterDescriptorImpl]

'getOrderEntriesForFile' @ [158:70] ==> @NotNull public abstract fun getOrderEntriesForFile(@NotNull p0: VirtualFile): (MutableList<(OrderEntry..OrderEntry?)>..List<(OrderEntry..OrderEntry?)>) defined in com.intellij.openapi.roots.ProjectFileIndex[JavaMethodDescriptor]

'virtualFile' @ [158:93] ==> value-parameter virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.caches.resolve.collectModuleInfosByType[ValueParameterDescriptorImpl]

'linkedSetOf' @ [160:18] ==> @SinceKotlin @InlineOnly public inline fun <T> linkedSetOf(): LinkedHashSet<T?> /* = LinkedHashSet<T?> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> T?

'orderEntries' @ [161:5] ==> val orderEntries: (MutableList<(OrderEntry..OrderEntry?)>..List<(OrderEntry..OrderEntry?)>) defined in org.jetbrains.kotlin.idea.caches.resolve.collectModuleInfosByType[LocalVariableDescriptor]

'process' @ [161:18] ==> private inline fun List<OrderEntry>.process(project: Project, virtualFile: VirtualFile, treatAsLibrarySource: Boolean = ..., body: (IdeaModuleInfo) -> Unit): Unit defined in org.jetbrains.kotlin.idea.caches.resolve[SimpleFunctionDescriptorImpl]

'project' @ [161:26] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.caches.resolve.collectModuleInfosByType[ValueParameterDescriptorImpl]

'virtualFile' @ [161:35] ==> value-parameter virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.caches.resolve.collectModuleInfosByType[ValueParameterDescriptorImpl]

'result' @ [162:9] ==> val result: LinkedHashSet<T?> /* = LinkedHashSet<T?> */ defined in org.jetbrains.kotlin.idea.caches.resolve.collectModuleInfosByType[LocalVariableDescriptor]

'add' @ [162:16] ==> public open fun add(element: T?): Boolean defined in java.util.LinkedHashSet[JavaMethodDescriptor]

'it' @ [162:20] ==> value-parameter it: IdeaModuleInfo defined in org.jetbrains.kotlin.idea.caches.resolve.collectModuleInfosByType.<anonymous>[ValueParameterDescriptorImpl]

'result' @ [166:5] ==> val result: LinkedHashSet<T?> /* = LinkedHashSet<T?> */ defined in org.jetbrains.kotlin.idea.caches.resolve.collectModuleInfosByType[LocalVariableDescriptor]

'add' @ [166:12] ==> public open fun add(element: T?): Boolean defined in java.util.LinkedHashSet[JavaMethodDescriptor]

'getModuleInfoByVirtualFile' @ [166:16] ==> public fun getModuleInfoByVirtualFile(project: Project, virtualFile: VirtualFile): IdeaModuleInfo? defined in org.jetbrains.kotlin.idea.caches.resolve in file getModuleInfo.kt[SimpleFunctionDescriptorImpl]

'project' @ [166:43] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.caches.resolve.collectModuleInfosByType[ValueParameterDescriptorImpl]

'virtualFile' @ [166:52] ==> value-parameter virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.caches.resolve.collectModuleInfosByType[ValueParameterDescriptorImpl]

'result' @ [168:12] ==> val result: LinkedHashSet<T?> /* = LinkedHashSet<T?> */ defined in org.jetbrains.kotlin.idea.caches.resolve.collectModuleInfosByType[LocalVariableDescriptor]

'filterNotNull' @ [168:19] ==> public fun <T : Any> Iterable<T?>.filterNotNull(): List<T> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> T

'this' @ [177:33] ==> <this> defined in org.jetbrains.kotlin.idea.caches.resolve.process[ReceiverParameterDescriptorImpl]

'!' @ [178:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'orderEntry' @ [178:14] ==> val orderEntry: OrderEntry defined in org.jetbrains.kotlin.idea.caches.resolve.process[LocalVariableDescriptor]

'isValid' @ [178:25] ==> public final val OrderEntry.isValid: Boolean[MyPropertyDescriptor]

'when (orderEntry) {
            is LibraryOrderEntry -> {
                val library = orderEntry.library ?: continue@entries
                if (ProjectRootsUtil.isLibraryClassFile(project, virtualFile) && !treatAsLibrarySource) {
                    body(LibraryInfo(project, library))
                }
                else if (ProjectRootsUtil.isLibraryFile(project, virtualFile) || treatAsLibrarySource) {
                    body(LibrarySourceInfo(project, library))
                }
            }
            is JdkOrderEntry -> {
                val sdk = orderEntry.jdk ?: continue@entries
                body(SdkInfo(project, sdk))
            }
        }' @ [180:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'orderEntry' @ [180:15] ==> val orderEntry: OrderEntry defined in org.jetbrains.kotlin.idea.caches.resolve.process[LocalVariableDescriptor]

'orderEntry' @ [182:31] ==> val orderEntry: OrderEntry defined in org.jetbrains.kotlin.idea.caches.resolve.process[LocalVariableDescriptor]

'library' @ [182:42] ==> public final val LibraryOrderEntry.library: Library?[MyPropertyDescriptor]

'if (ProjectRootsUtil.isLibraryClassFile(project, virtualFile) && !treatAsLibrarySource) {
                    body(LibraryInfo(project, library))
                }
                else if (ProjectRootsUtil.isLibraryFile(project, virtualFile) || treatAsLibrarySource) {
                    body(LibrarySourceInfo(project, library))
                }' @ [183:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'ProjectRootsUtil' @ [183:21] ==> public object ProjectRootsUtil defined in org.jetbrains.kotlin.idea.util in file ProjectRootsUtil.kt[FakeCallableDescriptorForObject]

'isLibraryClassFile' @ [183:38] ==> @JvmStatic public final fun isLibraryClassFile(project: Project, file: VirtualFile): Boolean defined in org.jetbrains.kotlin.idea.util.ProjectRootsUtil[SimpleFunctionDescriptorImpl]

'project' @ [183:57] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.caches.resolve.process[ValueParameterDescriptorImpl]

'virtualFile' @ [183:66] ==> value-parameter virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.caches.resolve.process[ValueParameterDescriptorImpl]

'!' @ [183:82] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'treatAsLibrarySource' @ [183:83] ==> value-parameter treatAsLibrarySource: Boolean = ... defined in org.jetbrains.kotlin.idea.caches.resolve.process[ValueParameterDescriptorImpl]

'invoke' @ [184:21] ==> public abstract operator fun invoke(p1: IdeaModuleInfo): Unit defined in kotlin.Function1[FunctionInvokeDescriptor]

'LibraryInfo' @ [184:26] ==> public constructor LibraryInfo(project: Project, library: Library) defined in org.jetbrains.kotlin.idea.caches.resolve.LibraryInfo[ClassConstructorDescriptorImpl]

'project' @ [184:38] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.caches.resolve.process[ValueParameterDescriptorImpl]

'library' @ [184:47] ==> val library: Library defined in org.jetbrains.kotlin.idea.caches.resolve.process[LocalVariableDescriptor]

'ProjectRootsUtil' @ [186:26] ==> public object ProjectRootsUtil defined in org.jetbrains.kotlin.idea.util in file ProjectRootsUtil.kt[FakeCallableDescriptorForObject]

'isLibraryFile' @ [186:43] ==> @JvmStatic public final fun isLibraryFile(project: Project, file: VirtualFile): Boolean defined in org.jetbrains.kotlin.idea.util.ProjectRootsUtil[SimpleFunctionDescriptorImpl]

'project' @ [186:57] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.caches.resolve.process[ValueParameterDescriptorImpl]

'virtualFile' @ [186:66] ==> value-parameter virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.caches.resolve.process[ValueParameterDescriptorImpl]

'treatAsLibrarySource' @ [186:82] ==> value-parameter treatAsLibrarySource: Boolean = ... defined in org.jetbrains.kotlin.idea.caches.resolve.process[ValueParameterDescriptorImpl]

'invoke' @ [187:21] ==> public abstract operator fun invoke(p1: IdeaModuleInfo): Unit defined in kotlin.Function1[FunctionInvokeDescriptor]

'LibrarySourceInfo' @ [187:26] ==> public constructor LibrarySourceInfo(project: Project, library: Library) defined in org.jetbrains.kotlin.idea.caches.resolve.LibrarySourceInfo[ClassConstructorDescriptorImpl]

'project' @ [187:44] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.caches.resolve.process[ValueParameterDescriptorImpl]

'library' @ [187:53] ==> val library: Library defined in org.jetbrains.kotlin.idea.caches.resolve.process[LocalVariableDescriptor]

'orderEntry' @ [191:27] ==> val orderEntry: OrderEntry defined in org.jetbrains.kotlin.idea.caches.resolve.process[LocalVariableDescriptor]

'jdk' @ [191:38] ==> public final val JdkOrderEntry.jdk: (Sdk..Sdk?)[MyPropertyDescriptor]

'invoke' @ [192:17] ==> public abstract operator fun invoke(p1: IdeaModuleInfo): Unit defined in kotlin.Function1[FunctionInvokeDescriptor]

'SdkInfo' @ [192:22] ==> public constructor SdkInfo(project: Project, sdk: Sdk) defined in org.jetbrains.kotlin.idea.caches.resolve.SdkInfo[ClassConstructorDescriptorImpl]

'project' @ [192:30] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.caches.resolve.process[ValueParameterDescriptorImpl]

'sdk' @ [192:39] ==> val sdk: Sdk defined in org.jetbrains.kotlin.idea.caches.resolve.process[LocalVariableDescriptor]

