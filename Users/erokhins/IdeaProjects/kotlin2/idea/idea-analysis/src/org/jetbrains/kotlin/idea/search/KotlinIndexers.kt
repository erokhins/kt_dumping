'builder' @ [40:10] ==> public open fun <E : (Any..Any?)> builder(): (ImmutableSet.Builder<(KtToken..KtToken?)>..ImmutableSet.Builder<(KtToken..KtToken?)>?) defined in com.google.common.collect.ImmutableSet[JavaMethodDescriptor]
Inferred types:
    <E : (Any..Any?)> -> KtToken

'addAll' @ [41:10] ==> @CanIgnoreReturnValue public open fun addAll(p0: (MutableIterable<(KtToken..KtToken?)>..Iterable<(KtToken..KtToken?)>?)): (ImmutableSet.Builder<(KtToken..KtToken?)>..ImmutableSet.Builder<(KtToken..KtToken?)>?) defined in com.google.common.collect.ImmutableSet.Builder[JavaMethodDescriptor]

'UNARY_OPERATION_NAMES' @ [41:37] ==> public final val UNARY_OPERATION_NAMES: (ImmutableBiMap<(KtSingleValueToken..KtSingleValueToken?), (Name..Name?)>..ImmutableBiMap<(KtSingleValueToken..KtSingleValueToken?), (Name..Name?)>?) defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaPropertyDescriptor]

'keys' @ [41:59] ==> public open val keys: ImmutableSet<(KtSingleValueToken..KtSingleValueToken?)> defined in com.google.common.collect.ImmutableBiMap[JavaPropertyDescriptor]

'addAll' @ [42:10] ==> @CanIgnoreReturnValue public open fun addAll(p0: (MutableIterable<(KtToken..KtToken?)>..Iterable<(KtToken..KtToken?)>?)): (ImmutableSet.Builder<(KtToken..KtToken?)>..ImmutableSet.Builder<(KtToken..KtToken?)>?) defined in com.google.common.collect.ImmutableSet.Builder[JavaMethodDescriptor]

'BINARY_OPERATION_NAMES' @ [42:37] ==> public final val BINARY_OPERATION_NAMES: (ImmutableBiMap<(KtSingleValueToken..KtSingleValueToken?), (Name..Name?)>..ImmutableBiMap<(KtSingleValueToken..KtSingleValueToken?), (Name..Name?)>?) defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaPropertyDescriptor]

'keys' @ [42:60] ==> public open val keys: ImmutableSet<(KtSingleValueToken..KtSingleValueToken?)> defined in com.google.common.collect.ImmutableBiMap[JavaPropertyDescriptor]

'addAll' @ [43:10] ==> @CanIgnoreReturnValue public open fun addAll(p0: (MutableIterable<(KtToken..KtToken?)>..Iterable<(KtToken..KtToken?)>?)): (ImmutableSet.Builder<(KtToken..KtToken?)>..ImmutableSet.Builder<(KtToken..KtToken?)>?) defined in com.google.common.collect.ImmutableSet.Builder[JavaMethodDescriptor]

'ASSIGNMENT_OPERATIONS' @ [43:37] ==> public final val ASSIGNMENT_OPERATIONS: (ImmutableBiMap<(KtSingleValueToken..KtSingleValueToken?), (Name..Name?)>..ImmutableBiMap<(KtSingleValueToken..KtSingleValueToken?), (Name..Name?)>?) defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaPropertyDescriptor]

'keys' @ [43:59] ==> public open val keys: ImmutableSet<(KtSingleValueToken..KtSingleValueToken?)> defined in com.google.common.collect.ImmutableBiMap[JavaPropertyDescriptor]

'addAll' @ [44:10] ==> @CanIgnoreReturnValue public open fun addAll(p0: (MutableIterable<(KtToken..KtToken?)>..Iterable<(KtToken..KtToken?)>?)): (ImmutableSet.Builder<(KtToken..KtToken?)>..ImmutableSet.Builder<(KtToken..KtToken?)>?) defined in com.google.common.collect.ImmutableSet.Builder[JavaMethodDescriptor]

'COMPARISON_OPERATIONS' @ [44:37] ==> public final val COMPARISON_OPERATIONS: (ImmutableSet<(KtSingleValueToken..KtSingleValueToken?)>..ImmutableSet<(KtSingleValueToken..KtSingleValueToken?)>?) defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaPropertyDescriptor]

'addAll' @ [45:10] ==> @CanIgnoreReturnValue public open fun addAll(p0: (MutableIterable<(KtToken..KtToken?)>..Iterable<(KtToken..KtToken?)>?)): (ImmutableSet.Builder<(KtToken..KtToken?)>..ImmutableSet.Builder<(KtToken..KtToken?)>?) defined in com.google.common.collect.ImmutableSet.Builder[JavaMethodDescriptor]

'EQUALS_OPERATIONS' @ [45:37] ==> public final val EQUALS_OPERATIONS: (ImmutableSet<(KtSingleValueToken..KtSingleValueToken?)>..ImmutableSet<(KtSingleValueToken..KtSingleValueToken?)>?) defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaPropertyDescriptor]

'addAll' @ [46:10] ==> @CanIgnoreReturnValue public open fun addAll(p0: (MutableIterable<(KtToken..KtToken?)>..Iterable<(KtToken..KtToken?)>?)): (ImmutableSet.Builder<(KtToken..KtToken?)>..ImmutableSet.Builder<(KtToken..KtToken?)>?) defined in com.google.common.collect.ImmutableSet.Builder[JavaMethodDescriptor]

'IN_OPERATIONS' @ [46:37] ==> public final val IN_OPERATIONS: (ImmutableSet<(KtSingleValueToken..KtSingleValueToken?)>..ImmutableSet<(KtSingleValueToken..KtSingleValueToken?)>?) defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaPropertyDescriptor]

'add' @ [47:10] ==> @CanIgnoreReturnValue public open fun add(p0: (KtToken..KtToken?)): (ImmutableSet.Builder<(KtToken..KtToken?)>..ImmutableSet.Builder<(KtToken..KtToken?)>?) defined in com.google.common.collect.ImmutableSet.Builder[JavaMethodDescriptor]

'LBRACKET' @ [47:23] ==> public final val LBRACKET: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'add' @ [48:10] ==> @CanIgnoreReturnValue public open fun add(p0: (KtToken..KtToken?)): (ImmutableSet.Builder<(KtToken..KtToken?)>..ImmutableSet.Builder<(KtToken..KtToken?)>?) defined in com.google.common.collect.ImmutableSet.Builder[JavaMethodDescriptor]

'BY_KEYWORD' @ [48:23] ==> public final val BY_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'build' @ [49:10] ==> public open fun build(): (ImmutableSet<(KtToken..KtToken?)>..ImmutableSet<(KtToken..KtToken?)>?) defined in com.google.common.collect.ImmutableSet.Builder[JavaMethodDescriptor]

'BaseFilterLexer' @ [51:78] ==> protected/*protected and package*/ constructor BaseFilterLexer(p0: (Lexer..Lexer?), p1: (OccurrenceConsumer..OccurrenceConsumer?)) defined in com.intellij.psi.impl.cache.impl.BaseFilterLexer[JavaClassConstructorDescriptor]

'KotlinLexer' @ [51:94] ==> public constructor KotlinLexer() defined in org.jetbrains.kotlin.lexer.KotlinLexer[JavaClassConstructorDescriptor]

'occurrenceConsumer' @ [51:109] ==> value-parameter occurrenceConsumer: OccurrenceConsumer defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer.<init>[ValueParameterDescriptorImpl]

'orSet' @ [52:39] ==> @NotNull public open fun orSet(@NotNull vararg p0: (TokenSet..TokenSet?)): TokenSet defined in com.intellij.psi.tree.TokenSet[JavaMethodDescriptor]

'create' @ [53:22] ==> @NotNull public open fun create(@NotNull vararg p0: (IElementType..IElementType?)): TokenSet defined in com.intellij.psi.tree.TokenSet[JavaMethodDescriptor]

'ALL_SEARCHABLE_OPERATIONS' @ [53:30] ==> private val ALL_SEARCHABLE_OPERATIONS: ImmutableSet<KtToken> defined in org.jetbrains.kotlin.idea.search in file KotlinIndexers.kt[PropertyDescriptorImpl]

'toTypedArray' @ [53:56] ==> public inline fun <reified T> Collection<(KtToken..KtToken?)>.toTypedArray(): Array<(KtToken..KtToken?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T> -> (org.jetbrains.kotlin.lexer.KtToken..org.jetbrains.kotlin.lexer.KtToken?)

'create' @ [54:22] ==> @NotNull public open fun create(@NotNull vararg p0: (IElementType..IElementType?)): TokenSet defined in com.intellij.psi.tree.TokenSet[JavaMethodDescriptor]

'IDENTIFIER' @ [54:38] ==> public final val IDENTIFIER: (KtToken..KtToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'orSet' @ [57:42] ==> @NotNull public open fun orSet(@NotNull vararg p0: (TokenSet..TokenSet?)): TokenSet defined in com.intellij.psi.tree.TokenSet[JavaMethodDescriptor]

'COMMENTS' @ [57:57] ==> public final val COMMENTS: (TokenSet..TokenSet?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'create' @ [57:76] ==> @NotNull public open fun create(@NotNull vararg p0: (IElementType..IElementType?)): TokenSet defined in com.intellij.psi.tree.TokenSet[JavaMethodDescriptor]

'KDOC' @ [57:94] ==> public final val KDOC: (ILazyParseableElementType..ILazyParseableElementType?) defined in org.jetbrains.kotlin.kdoc.lexer.KDocTokens[JavaPropertyDescriptor]

'ArrayDeque' @ [60:30] ==> public constructor ArrayDeque<E : (Any..Any?)>(p0: Int) defined in java.util.ArrayDeque[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> IElementType

'MAX_PREV_TOKENS' @ [60:55] ==> private final val MAX_PREV_TOKENS: Int defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[PropertyDescriptorImpl]

'-' @ [61:34] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'-' @ [62:32] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'myDelegate' @ [65:25] ==> protected/*protected and package*/ final val myDelegate: (Lexer..Lexer?) defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[JavaPropertyDescriptor]

'tokenType' @ [65:36] ==> public final val Lexer.tokenType: IElementType?[MyPropertyDescriptor]

'when (tokenType) {
            KtTokens.EQ -> {
                if (prevTokens.peekFirst() == KtTokens.IDENTIFIER) {
                    val prevPrev = prevTokens.elementAtOrNull(1)
                    if (prevPrev == KtTokens.COMMA || prevPrev == KtTokens.LPAR) {
                        occurrenceConsumer.addOccurrence(bufferSequence, null, prevTokenStart, prevTokenEnd, KOTLIN_NAMED_ARGUMENT_SEARCH_CONTEXT.toInt())
                    }
                }
            }

            KtTokens.LPAR -> {
                if (isMultiDeclarationPosition()) {
                    addOccurrenceInToken(UsageSearchContext.IN_CODE.toInt())
                }
            }

            KtTokens.IDENTIFIER -> {
                 if (myDelegate.tokenText.startsWith("`")) {
                     scanWordsInToken(UsageSearchContext.IN_CODE.toInt(), false, false)
                 }
                 else {
                     addOccurrenceInToken(UsageSearchContext.IN_CODE.toInt())
                     if (myDelegate.tokenText == "TODO" ) {
                         // Heuristics to reduce mismatches between indexer and searcher. The searcher returns only occurrences of TO_DO
                         // as the callee of a call expression, but we can't tell calls and other usages apart based on limited lexer context,
                         // so we just exclude occurrences in declaration names (and even that doesn't work precisely because it doesn't handle
                         // declarations with type parameters)
                         val prevToken = prevTokens.peekFirst()
                         if (prevToken != KtTokens.FUN_KEYWORD && prevToken != KtTokens.VAR_KEYWORD && prevToken != KtTokens.VAL_KEYWORD && prevToken != KtTokens.CLASS_KEYWORD) {
                             advanceTodoItemCountsInToken()
                         }
                     }
                 }
            }

            in codeTokens -> addOccurrenceInToken(UsageSearchContext.IN_CODE.toInt())

            in KtTokens.STRINGS -> scanWordsInToken(UsageSearchContext.IN_STRINGS + UsageSearchContext.IN_FOREIGN_LANGUAGES, false, true)

            in commentTokens -> {
                scanWordsInToken(UsageSearchContext.IN_COMMENTS.toInt(), false, false)
                advanceTodoItemCountsInToken()
            }
        }' @ [67:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit, entry3: Unit, entry4: Unit, entry5: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'tokenType' @ [67:15] ==> val tokenType: IElementType? defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer.advance[LocalVariableDescriptor]

'EQ' @ [68:22] ==> public final val EQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'prevTokens' @ [69:21] ==> private final val prevTokens: ArrayDeque<IElementType> defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[PropertyDescriptorImpl]

'peekFirst' @ [69:32] ==> public open fun peekFirst(): (IElementType..IElementType?) defined in java.util.ArrayDeque[JavaMethodDescriptor]

'IDENTIFIER' @ [69:56] ==> public final val IDENTIFIER: (KtToken..KtToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'prevTokens' @ [70:36] ==> private final val prevTokens: ArrayDeque<IElementType> defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[PropertyDescriptorImpl]

'elementAtOrNull' @ [70:47] ==> public fun <T> Iterable<(IElementType..IElementType?)>.elementAtOrNull(index: Int): IElementType? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.tree.IElementType..com.intellij.psi.tree.IElementType?)

'prevPrev' @ [71:25] ==> val prevPrev: IElementType? defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer.advance[LocalVariableDescriptor]

'COMMA' @ [71:46] ==> public final val COMMA: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'prevPrev' @ [71:55] ==> val prevPrev: IElementType? defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer.advance[LocalVariableDescriptor]

'LPAR' @ [71:76] ==> public final val LPAR: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'occurrenceConsumer' @ [72:25] ==> private final val occurrenceConsumer: OccurrenceConsumer defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[PropertyDescriptorImpl]

'addOccurrence' @ [72:44] ==> public open fun addOccurrence(p0: (CharSequence..CharSequence?), p1: (CharArray..CharArray?), p2: Int, p3: Int, p4: Int): Unit defined in com.intellij.psi.impl.cache.impl.OccurrenceConsumer[JavaMethodDescriptor]

'bufferSequence' @ [72:58] ==> public final val KotlinFilterLexer.bufferSequence: CharSequence[MyPropertyDescriptor]

'prevTokenStart' @ [72:80] ==> private final var prevTokenStart: Int defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[PropertyDescriptorImpl]

'prevTokenEnd' @ [72:96] ==> private final var prevTokenEnd: Int defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[PropertyDescriptorImpl]

'KOTLIN_NAMED_ARGUMENT_SEARCH_CONTEXT' @ [72:110] ==> public val KOTLIN_NAMED_ARGUMENT_SEARCH_CONTEXT: Short defined in org.jetbrains.kotlin.idea.search in file KotlinIndexers.kt[PropertyDescriptorImpl]

'toInt' @ [72:147] ==> public open fun toInt(): Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor]

'LPAR' @ [77:22] ==> public final val LPAR: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'isMultiDeclarationPosition' @ [78:21] ==> private final fun isMultiDeclarationPosition(): Boolean defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[SimpleFunctionDescriptorImpl]

'addOccurrenceInToken' @ [79:21] ==> protected/*protected and package*/ final fun addOccurrenceInToken(p0: Int): Unit defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[JavaMethodDescriptor]

'IN_CODE' @ [79:61] ==> public const final val IN_CODE: Short defined in com.intellij.psi.search.UsageSearchContext[JavaPropertyDescriptor]

'toInt' @ [79:69] ==> public open fun toInt(): Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor]

'IDENTIFIER' @ [83:22] ==> public final val IDENTIFIER: (KtToken..KtToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'if (myDelegate.tokenText.startsWith("`")) {
                     scanWordsInToken(UsageSearchContext.IN_CODE.toInt(), false, false)
                 }
                 else {
                     addOccurrenceInToken(UsageSearchContext.IN_CODE.toInt())
                     if (myDelegate.tokenText == "TODO" ) {
                         // Heuristics to reduce mismatches between indexer and searcher. The searcher returns only occurrences of TO_DO
                         // as the callee of a call expression, but we can't tell calls and other usages apart based on limited lexer context,
                         // so we just exclude occurrences in declaration names (and even that doesn't work precisely because it doesn't handle
                         // declarations with type parameters)
                         val prevToken = prevTokens.peekFirst()
                         if (prevToken != KtTokens.FUN_KEYWORD && prevToken != KtTokens.VAR_KEYWORD && prevToken != KtTokens.VAL_KEYWORD && prevToken != KtTokens.CLASS_KEYWORD) {
                             advanceTodoItemCountsInToken()
                         }
                     }
                 }' @ [84:18] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'myDelegate' @ [84:22] ==> protected/*protected and package*/ final val myDelegate: (Lexer..Lexer?) defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[JavaPropertyDescriptor]

'tokenText' @ [84:33] ==> public final val Lexer.tokenText: String[MyPropertyDescriptor]

'startsWith' @ [84:43] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'scanWordsInToken' @ [85:22] ==> protected/*protected and package*/ final fun scanWordsInToken(p0: Int, p1: Boolean, p2: Boolean): Unit defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[JavaMethodDescriptor]

'IN_CODE' @ [85:58] ==> public const final val IN_CODE: Short defined in com.intellij.psi.search.UsageSearchContext[JavaPropertyDescriptor]

'toInt' @ [85:66] ==> public open fun toInt(): Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor]

'addOccurrenceInToken' @ [88:22] ==> protected/*protected and package*/ final fun addOccurrenceInToken(p0: Int): Unit defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[JavaMethodDescriptor]

'IN_CODE' @ [88:62] ==> public const final val IN_CODE: Short defined in com.intellij.psi.search.UsageSearchContext[JavaPropertyDescriptor]

'toInt' @ [88:70] ==> public open fun toInt(): Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor]

'myDelegate' @ [89:26] ==> protected/*protected and package*/ final val myDelegate: (Lexer..Lexer?) defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[JavaPropertyDescriptor]

'tokenText' @ [89:37] ==> public final val Lexer.tokenText: String[MyPropertyDescriptor]

'prevTokens' @ [94:42] ==> private final val prevTokens: ArrayDeque<IElementType> defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[PropertyDescriptorImpl]

'peekFirst' @ [94:53] ==> public open fun peekFirst(): (IElementType..IElementType?) defined in java.util.ArrayDeque[JavaMethodDescriptor]

'prevToken' @ [95:30] ==> val prevToken: (IElementType..IElementType?) defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer.advance[LocalVariableDescriptor]

'FUN_KEYWORD' @ [95:52] ==> public final val FUN_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'prevToken' @ [95:67] ==> val prevToken: (IElementType..IElementType?) defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer.advance[LocalVariableDescriptor]

'VAR_KEYWORD' @ [95:89] ==> public final val VAR_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'prevToken' @ [95:104] ==> val prevToken: (IElementType..IElementType?) defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer.advance[LocalVariableDescriptor]

'VAL_KEYWORD' @ [95:126] ==> public final val VAL_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'prevToken' @ [95:141] ==> val prevToken: (IElementType..IElementType?) defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer.advance[LocalVariableDescriptor]

'CLASS_KEYWORD' @ [95:163] ==> public final val CLASS_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'advanceTodoItemCountsInToken' @ [96:30] ==> protected/*protected and package*/ final fun advanceTodoItemCountsInToken(): Unit defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[JavaMethodDescriptor]

'in' @ [102:13] ==> public open operator fun contains(@Nullable p0: IElementType?): Boolean defined in com.intellij.psi.tree.TokenSet[JavaMethodDescriptor]

'codeTokens' @ [102:16] ==> private final val codeTokens: TokenSet defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[PropertyDescriptorImpl]

'addOccurrenceInToken' @ [102:30] ==> protected/*protected and package*/ final fun addOccurrenceInToken(p0: Int): Unit defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[JavaMethodDescriptor]

'IN_CODE' @ [102:70] ==> public const final val IN_CODE: Short defined in com.intellij.psi.search.UsageSearchContext[JavaPropertyDescriptor]

'toInt' @ [102:78] ==> public open fun toInt(): Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor]

'in' @ [104:13] ==> public open operator fun contains(@Nullable p0: IElementType?): Boolean defined in com.intellij.psi.tree.TokenSet[JavaMethodDescriptor]

'STRINGS' @ [104:25] ==> public final val STRINGS: (TokenSet..TokenSet?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'scanWordsInToken' @ [104:36] ==> protected/*protected and package*/ final fun scanWordsInToken(p0: Int, p1: Boolean, p2: Boolean): Unit defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[JavaMethodDescriptor]

'+' @ [104:53] ==> public final operator fun plus(other: Short): Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor]

'IN_STRINGS' @ [104:72] ==> public const final val IN_STRINGS: Short defined in com.intellij.psi.search.UsageSearchContext[JavaPropertyDescriptor]

'IN_FOREIGN_LANGUAGES' @ [104:104] ==> public const final val IN_FOREIGN_LANGUAGES: Short defined in com.intellij.psi.search.UsageSearchContext[JavaPropertyDescriptor]

'in' @ [106:13] ==> public open operator fun contains(@Nullable p0: IElementType?): Boolean defined in com.intellij.psi.tree.TokenSet[JavaMethodDescriptor]

'commentTokens' @ [106:16] ==> private final val commentTokens: TokenSet defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[PropertyDescriptorImpl]

'scanWordsInToken' @ [107:17] ==> protected/*protected and package*/ final fun scanWordsInToken(p0: Int, p1: Boolean, p2: Boolean): Unit defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[JavaMethodDescriptor]

'IN_COMMENTS' @ [107:53] ==> public const final val IN_COMMENTS: Short defined in com.intellij.psi.search.UsageSearchContext[JavaPropertyDescriptor]

'toInt' @ [107:65] ==> public open fun toInt(): Int defined in kotlin.Short[DeserializedSimpleFunctionDescriptor]

'advanceTodoItemCountsInToken' @ [108:17] ==> protected/*protected and package*/ final fun advanceTodoItemCountsInToken(): Unit defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[JavaMethodDescriptor]

'tokenType' @ [112:13] ==> val tokenType: IElementType? defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer.advance[LocalVariableDescriptor]

'WHITE_SPACE' @ [112:36] ==> public final val WHITE_SPACE: (IElementType..IElementType?) defined in com.intellij.psi.TokenType[JavaPropertyDescriptor]

'tokenType' @ [112:51] ==> val tokenType: IElementType? defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer.advance[LocalVariableDescriptor]

'commentTokens' @ [112:65] ==> private final val commentTokens: TokenSet defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[PropertyDescriptorImpl]

'prevTokens' @ [113:17] ==> private final val prevTokens: ArrayDeque<IElementType> defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[PropertyDescriptorImpl]

'size' @ [113:28] ==> public open val size: Int defined in java.util.ArrayDeque[JavaPropertyDescriptor]

'MAX_PREV_TOKENS' @ [113:36] ==> private final val MAX_PREV_TOKENS: Int defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[PropertyDescriptorImpl]

'prevTokens' @ [114:17] ==> private final val prevTokens: ArrayDeque<IElementType> defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[PropertyDescriptorImpl]

'removeLast' @ [114:28] ==> public open fun removeLast(): (IElementType..IElementType?) defined in java.util.ArrayDeque[JavaMethodDescriptor]

'prevTokens' @ [116:13] ==> private final val prevTokens: ArrayDeque<IElementType> defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[PropertyDescriptorImpl]

'addFirst' @ [116:24] ==> public open fun addFirst(p0: (IElementType..IElementType?)): Unit defined in java.util.ArrayDeque[JavaMethodDescriptor]

'tokenType' @ [116:33] ==> val tokenType: IElementType? defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer.advance[LocalVariableDescriptor]

'prevTokenStart' @ [117:13] ==> private final var prevTokenStart: Int defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[PropertyDescriptorImpl]

'tokenStart' @ [117:30] ==> public final val KotlinFilterLexer.tokenStart: Int[MyPropertyDescriptor]

'prevTokenEnd' @ [118:13] ==> private final var prevTokenEnd: Int defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[PropertyDescriptorImpl]

'tokenEnd' @ [118:28] ==> public final val KotlinFilterLexer.tokenEnd: Int[MyPropertyDescriptor]

'myDelegate' @ [121:9] ==> protected/*protected and package*/ final val myDelegate: (Lexer..Lexer?) defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[JavaPropertyDescriptor]

'advance' @ [121:20] ==> public abstract fun advance(): Unit defined in com.intellij.lexer.Lexer[JavaMethodDescriptor]

'prevTokens' @ [125:21] ==> private final val prevTokens: ArrayDeque<IElementType> defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[PropertyDescriptorImpl]

'peekFirst' @ [125:32] ==> public open fun peekFirst(): (IElementType..IElementType?) defined in java.util.ArrayDeque[JavaMethodDescriptor]

'first' @ [126:13] ==> val first: (IElementType..IElementType?) defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer.isMultiDeclarationPosition[LocalVariableDescriptor]

'VAL_KEYWORD' @ [126:31] ==> public final val VAL_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'first' @ [126:46] ==> val first: (IElementType..IElementType?) defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer.isMultiDeclarationPosition[LocalVariableDescriptor]

'VAR_KEYWORD' @ [126:64] ==> public final val VAR_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'first' @ [127:16] ==> val first: (IElementType..IElementType?) defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer.isMultiDeclarationPosition[LocalVariableDescriptor]

'LPAR' @ [127:34] ==> public final val LPAR: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'prevTokens' @ [127:42] ==> private final val prevTokens: ArrayDeque<IElementType> defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[PropertyDescriptorImpl]

'elementAtOrNull' @ [127:53] ==> public fun <T> Iterable<(IElementType..IElementType?)>.elementAtOrNull(index: Int): IElementType? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.tree.IElementType..com.intellij.psi.tree.IElementType?)

'FOR_KEYWORD' @ [127:84] ==> public final val FOR_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'LexerBasedIdIndexer' @ [131:24] ==> public constructor LexerBasedIdIndexer() defined in com.intellij.psi.impl.cache.impl.id.LexerBasedIdIndexer[JavaClassConstructorDescriptor]

'KotlinFilterLexer' @ [132:69] ==> public constructor KotlinFilterLexer(occurrenceConsumer: OccurrenceConsumer) defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[ClassConstructorDescriptorImpl]

'consumer' @ [132:87] ==> value-parameter consumer: OccurrenceConsumer defined in org.jetbrains.kotlin.idea.search.KotlinIdIndexer.createLexer[ValueParameterDescriptorImpl]

'LexerBasedTodoIndexer' @ [137:26] ==> public constructor LexerBasedTodoIndexer() defined in com.intellij.psi.impl.cache.impl.todo.LexerBasedTodoIndexer[JavaClassConstructorDescriptor]

'KotlinFilterLexer' @ [140:62] ==> public constructor KotlinFilterLexer(occurrenceConsumer: OccurrenceConsumer) defined in org.jetbrains.kotlin.idea.search.KotlinFilterLexer[ClassConstructorDescriptorImpl]

'consumer' @ [140:80] ==> value-parameter consumer: OccurrenceConsumer defined in org.jetbrains.kotlin.idea.search.KotlinTodoIndexer.createLexer[ValueParameterDescriptorImpl]

