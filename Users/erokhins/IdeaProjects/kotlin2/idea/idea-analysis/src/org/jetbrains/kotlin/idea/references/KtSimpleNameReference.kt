'KtSimpleReference<KtSimpleNameExpression>' @ [54:67] ==> public constructor KtSimpleReference<T : KtReferenceExpression>(expression: KtSimpleNameExpression) defined in org.jetbrains.kotlin.idea.references.KtSimpleReference[ClassConstructorDescriptorImpl]
Inferred types:
    <T : KtReferenceExpression> -> KtSimpleNameExpression

'expression' @ [54:109] ==> value-parameter expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.<init>[ValueParameterDescriptorImpl]

'SmartList' @ [56:16] ==> public constructor SmartList<E : (Any..Any?)>() defined in com.intellij.util.SmartList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> DeclarationDescriptor

'apply' @ [56:51] ==> @InlineOnly public inline fun <T> SmartList<DeclarationDescriptor>.apply(block: SmartList<DeclarationDescriptor>.() -> Unit): SmartList<DeclarationDescriptor> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SmartList<DeclarationDescriptor>

'super' @ [58:32] ==> <this> defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[LazyClassReceiverParameterDescriptor]

'getTargetDescriptors' @ [58:38] ==> protected open fun getTargetDescriptors(context: BindingContext): Collection<DeclarationDescriptor> defined in org.jetbrains.kotlin.idea.references.KtSimpleReference[SimpleFunctionDescriptorImpl]

'context' @ [58:59] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getTargetDescriptors[ValueParameterDescriptorImpl]

'size' @ [59:34] ==> public open val size: Int defined in com.intellij.util.SmartList[JavaPropertyDescriptor]

'descriptor' @ [61:21] ==> val descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getTargetDescriptors.<anonymous>[LocalVariableDescriptor]

'add' @ [62:21] ==> public open fun add(element: (DeclarationDescriptor..DeclarationDescriptor?)): Boolean defined in com.intellij.util.SmartList[JavaMethodDescriptor]

'descriptor' @ [62:25] ==> val descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getTargetDescriptors.<anonymous>[LocalVariableDescriptor]

'expression' @ [66:39] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[PropertyDescriptorImpl]

'readWriteAccess' @ [66:50] ==> public fun KtExpression.readWriteAccess(useResolveForReadWrite: Boolean): ReferenceAccess defined in org.jetbrains.kotlin.idea.references in file referenceUtil.kt[SimpleFunctionDescriptorImpl]

'descriptor' @ [67:17] ==> val descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getTargetDescriptors.<anonymous>[LocalVariableDescriptor]

'getter' @ [67:28] ==> public open val getter: PropertyGetterDescriptorImpl? defined in org.jetbrains.kotlin.load.java.descriptors.JavaPropertyDescriptor[JavaPropertyDescriptor]

'let' @ [67:36] ==> @InlineOnly public inline fun <T, R> PropertyGetterDescriptorImpl.let(block: (PropertyGetterDescriptorImpl) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PropertyGetterDescriptorImpl
    <R> -> Unit

'readWriteAccess' @ [68:25] ==> val readWriteAccess: ReferenceAccess defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getTargetDescriptors.<anonymous>[LocalVariableDescriptor]

'isRead' @ [68:41] ==> public final val isRead: Boolean defined in org.jetbrains.kotlin.idea.references.ReferenceAccess[PropertyDescriptorImpl]

'add' @ [68:49] ==> public open fun add(element: (DeclarationDescriptor..DeclarationDescriptor?)): Boolean defined in com.intellij.util.SmartList[JavaMethodDescriptor]

'it' @ [68:53] ==> value-parameter it: PropertyGetterDescriptorImpl defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getTargetDescriptors.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'descriptor' @ [70:17] ==> val descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getTargetDescriptors.<anonymous>[LocalVariableDescriptor]

'setter' @ [70:28] ==> public open val setter: PropertySetterDescriptor? defined in org.jetbrains.kotlin.load.java.descriptors.JavaPropertyDescriptor[JavaPropertyDescriptor]

'let' @ [70:36] ==> @InlineOnly public inline fun <T, R> PropertySetterDescriptor.let(block: (PropertySetterDescriptor) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PropertySetterDescriptor
    <R> -> Unit

'readWriteAccess' @ [71:25] ==> val readWriteAccess: ReferenceAccess defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getTargetDescriptors.<anonymous>[LocalVariableDescriptor]

'isWrite' @ [71:41] ==> public final val isWrite: Boolean defined in org.jetbrains.kotlin.idea.references.ReferenceAccess[PropertyDescriptorImpl]

'add' @ [71:50] ==> public open fun add(element: (DeclarationDescriptor..DeclarationDescriptor?)): Boolean defined in com.intellij.util.SmartList[JavaMethodDescriptor]

'it' @ [71:54] ==> value-parameter it: PropertySetterDescriptor defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getTargetDescriptors.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'size' @ [74:21] ==> public open val size: Int defined in com.intellij.util.SmartList[JavaPropertyDescriptor]

'sizeBefore' @ [74:29] ==> val sizeBefore: Int defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getTargetDescriptors.<anonymous>[LocalVariableDescriptor]

'add' @ [75:21] ==> public open fun add(element: (DeclarationDescriptor..DeclarationDescriptor?)): Boolean defined in com.intellij.util.SmartList[JavaMethodDescriptor]

'descriptor' @ [75:25] ==> val descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getTargetDescriptors.<anonymous>[LocalVariableDescriptor]

'element' @ [82:13] ==> value-parameter element: PsiElement? defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.isReferenceTo[ValueParameterDescriptorImpl]

'!' @ [83:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'canBeReferenceTo' @ [83:18] ==> public fun PsiReference.canBeReferenceTo(candidateTarget: PsiElement): Boolean defined in org.jetbrains.kotlin.idea.references in file referenceUtil.kt[SimpleFunctionDescriptorImpl]

'element' @ [83:35] ==> value-parameter element: PsiElement? defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.isReferenceTo[ValueParameterDescriptorImpl]

'iterator' @ [85:31] ==> public final operator fun iterator(): Iterator<(SimpleNameReferenceExtension..SimpleNameReferenceExtension?)> defined in kotlin.Array[DeserializedSimpleFunctionDescriptor]

'getArea' @ [85:42] ==> @NotNull public open fun getArea(@Nullable p0: AreaInstance?): ExtensionsArea defined in com.intellij.openapi.extensions.Extensions[JavaMethodDescriptor]

'element' @ [85:50] ==> value-parameter element: PsiElement? defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.isReferenceTo[ValueParameterDescriptorImpl]

'project' @ [85:58] ==> public final val PsiElement.project: Project[MyPropertyDescriptor]

'getExtensionPoint' @ [85:67] ==> @NotNull public abstract fun <T : (Any..Any?)> getExtensionPoint(@NotNull p0: ExtensionPointName<(SimpleNameReferenceExtension..SimpleNameReferenceExtension?)>): ExtensionPoint<(SimpleNameReferenceExtension..SimpleNameReferenceExtension?)> defined in com.intellij.openapi.extensions.ExtensionsArea[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> SimpleNameReferenceExtension

'SimpleNameReferenceExtension' @ [85:85] ==> public companion object defined in org.jetbrains.kotlin.plugin.references.SimpleNameReferenceExtension[FakeCallableDescriptorForObject]

'EP_NAME' @ [85:114] ==> public final val EP_NAME: ExtensionPointName<SimpleNameReferenceExtension> defined in org.jetbrains.kotlin.plugin.references.SimpleNameReferenceExtension.Companion[PropertyDescriptorImpl]

'extensions' @ [85:123] ==> public final val <T : (Any..Any?)> ExtensionPoint<(SimpleNameReferenceExtension..SimpleNameReferenceExtension?)>.extensions: (Array<(SimpleNameReferenceExtension..SimpleNameReferenceExtension?)>..Array<out (SimpleNameReferenceExtension..SimpleNameReferenceExtension?)>)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> (org.jetbrains.kotlin.plugin.references.SimpleNameReferenceExtension..org.jetbrains.kotlin.plugin.references.SimpleNameReferenceExtension?)

'extension' @ [86:21] ==> val extension: (SimpleNameReferenceExtension..SimpleNameReferenceExtension?) defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.isReferenceTo[LocalVariableDescriptor]

'isReferenceTo' @ [86:31] ==> public abstract fun isReferenceTo(reference: KtSimpleNameReference, element: PsiElement): Boolean defined in org.jetbrains.kotlin.plugin.references.SimpleNameReferenceExtension[SimpleFunctionDescriptorImpl]

'this' @ [86:45] ==> <this> defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[LazyClassReceiverParameterDescriptor]

'element' @ [86:51] ==> value-parameter element: PsiElement? defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.isReferenceTo[ValueParameterDescriptorImpl]

'super' @ [90:16] ==> <this> defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[LazyClassReceiverParameterDescriptor]

'isReferenceTo' @ [90:22] ==> public open fun isReferenceTo(element: PsiElement?): Boolean defined in org.jetbrains.kotlin.idea.references.KtSimpleReference[SimpleFunctionDescriptorImpl]

'element' @ [90:36] ==> value-parameter element: PsiElement? defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.isReferenceTo[ValueParameterDescriptorImpl]

'element' @ [94:23] ==> public final val KtSimpleNameReference.element: (KtSimpleNameExpression..KtSimpleNameExpression?)[MyPropertyDescriptor]

'getReferencedNameElement' @ [94:31] ==> public abstract fun getReferencedNameElement(): PsiElement defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[DeserializedSimpleFunctionDescriptor]

'getElement' @ [95:27] ==> public open fun getElement(): (KtSimpleNameExpression..KtSimpleNameExpression?) defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[JavaMethodDescriptor]

'startOffset' @ [95:40] ==> public val PsiElement.startOffset: Int defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'element' @ [96:16] ==> val element: PsiElement defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getRangeInElement[LocalVariableDescriptor]

'textRange' @ [96:24] ==> public final val PsiElement.textRange: (TextRange..TextRange?)[MyPropertyDescriptor]

'shiftRight' @ [96:34] ==> @NotNull public open fun shiftRight(p0: Int): TextRange defined in com.intellij.openapi.util.TextRange[JavaMethodDescriptor]

'-' @ [96:45] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'startOffset' @ [96:46] ==> val startOffset: Int defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getRangeInElement[LocalVariableDescriptor]

'expression' @ [100:13] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[PropertyDescriptorImpl]

'getParentOfTypeAndBranch' @ [100:24] ==> public inline fun <reified T : PsiElement> PsiElement.getParentOfTypeAndBranch(strict: Boolean = ..., noinline branch: KtWhenConditionInRange.() -> PsiElement?): KtWhenConditionInRange? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtWhenConditionInRange

'operationReference' @ [100:89] ==> public final val KtWhenConditionInRange.operationReference: KtOperationReferenceExpression[MyPropertyDescriptor]

'expression' @ [102:27] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[PropertyDescriptorImpl]

'getReferencedNameElementType' @ [102:38] ==> public abstract fun getReferencedNameElementType(): IElementType defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[DeserializedSimpleFunctionDescriptor]

'elementType' @ [103:13] ==> val elementType: IElementType defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.canRename[LocalVariableDescriptor]

'PLUSPLUS' @ [103:37] ==> public final val PLUSPLUS: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'elementType' @ [103:49] ==> val elementType: IElementType defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.canRename[LocalVariableDescriptor]

'MINUSMINUS' @ [103:73] ==> public final val MINUSMINUS: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'!' @ [109:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'canRename' @ [109:14] ==> public open fun canRename(): Boolean defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[SimpleFunctionDescriptorImpl]

'IncorrectOperationException' @ [109:33] ==> public constructor IncorrectOperationException() defined in com.intellij.util.IncorrectOperationException[JavaClassConstructorDescriptor]

'newElementName' @ [110:13] ==> value-parameter newElementName: String? defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.handleElementRename[ValueParameterDescriptorImpl]

'expression' @ [110:44] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[PropertyDescriptorImpl]

'expression' @ [113:30] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[PropertyDescriptorImpl]

'text' @ [113:41] ==> public final val KtSimpleNameExpression.text: (String..String?)[MyPropertyDescriptor]

'expressionText' @ [114:13] ==> val expressionText: (String..String?) defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.handleElementRename[LocalVariableDescriptor]

'isValidIdentifier' @ [114:44] ==> public open fun isValidIdentifier(@NotNull p0: String): Boolean defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'expressionText' @ [114:62] ==> val expressionText: (String..String?) defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.handleElementRename[LocalVariableDescriptor]

'DataClassDescriptorResolver' @ [115:17] ==> public object DataClassDescriptorResolver defined in org.jetbrains.kotlin.resolve[FakeCallableDescriptorForObject]

'isComponentLike' @ [115:45] ==> public final fun isComponentLike(name: Name): Boolean defined in org.jetbrains.kotlin.resolve.DataClassDescriptorResolver[DeserializedSimpleFunctionDescriptor]

'identifier' @ [115:66] ==> @NotNull public open fun identifier(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'expressionText' @ [115:77] ==> val expressionText: (String..String?) defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.handleElementRename[LocalVariableDescriptor]

'resolve' @ [115:97] ==> @Nullable public open fun resolve(): PsiElement? defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[JavaMethodDescriptor]

'expression' @ [116:24] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[PropertyDescriptorImpl]

'KtPsiFactory' @ [120:26] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'expression' @ [120:39] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[PropertyDescriptorImpl]

'?:' @ [121:23] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: PsiElement?, right: PsiElement): PsiElement[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> PsiElement

'getArea' @ [121:34] ==> @NotNull public open fun getArea(@Nullable p0: AreaInstance?): ExtensionsArea defined in com.intellij.openapi.extensions.Extensions[JavaMethodDescriptor]

'expression' @ [121:42] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[PropertyDescriptorImpl]

'project' @ [121:53] ==> public final val KtSimpleNameExpression.project: Project[MyPropertyDescriptor]

'getExtensionPoint' @ [121:62] ==> @NotNull public abstract fun <T : (Any..Any?)> getExtensionPoint(@NotNull p0: ExtensionPointName<(SimpleNameReferenceExtension..SimpleNameReferenceExtension?)>): ExtensionPoint<(SimpleNameReferenceExtension..SimpleNameReferenceExtension?)> defined in com.intellij.openapi.extensions.ExtensionsArea[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> SimpleNameReferenceExtension

'SimpleNameReferenceExtension' @ [121:80] ==> public companion object defined in org.jetbrains.kotlin.plugin.references.SimpleNameReferenceExtension[FakeCallableDescriptorForObject]

'EP_NAME' @ [121:109] ==> public final val EP_NAME: ExtensionPointName<SimpleNameReferenceExtension> defined in org.jetbrains.kotlin.plugin.references.SimpleNameReferenceExtension.Companion[PropertyDescriptorImpl]

'extensions' @ [121:118] ==> public final val <T : (Any..Any?)> ExtensionPoint<(SimpleNameReferenceExtension..SimpleNameReferenceExtension?)>.extensions: (Array<(SimpleNameReferenceExtension..SimpleNameReferenceExtension?)>..Array<out (SimpleNameReferenceExtension..SimpleNameReferenceExtension?)>)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> (org.jetbrains.kotlin.plugin.references.SimpleNameReferenceExtension..org.jetbrains.kotlin.plugin.references.SimpleNameReferenceExtension?)

'asSequence' @ [122:26] ==> public fun <T> Array<out (SimpleNameReferenceExtension..SimpleNameReferenceExtension?)>.asSequence(): Sequence<(SimpleNameReferenceExtension..SimpleNameReferenceExtension?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.plugin.references.SimpleNameReferenceExtension..org.jetbrains.kotlin.plugin.references.SimpleNameReferenceExtension?)

'map' @ [123:26] ==> public fun <T, R> Sequence<(SimpleNameReferenceExtension..SimpleNameReferenceExtension?)>.map(transform: ((SimpleNameReferenceExtension..SimpleNameReferenceExtension?)) -> PsiElement?): Sequence<PsiElement?> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.plugin.references.SimpleNameReferenceExtension..org.jetbrains.kotlin.plugin.references.SimpleNameReferenceExtension?)
    <R> -> PsiElement?

'it' @ [123:32] ==> value-parameter it: (SimpleNameReferenceExtension..SimpleNameReferenceExtension?) defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.handleElementRename.<anonymous>[ValueParameterDescriptorImpl]

'handleElementRename' @ [123:35] ==> public abstract fun handleElementRename(reference: KtSimpleNameReference, psiFactory: KtPsiFactory, newElementName: String): PsiElement? defined in org.jetbrains.kotlin.plugin.references.SimpleNameReferenceExtension[SimpleFunctionDescriptorImpl]

'this' @ [123:55] ==> <this> defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[LazyClassReceiverParameterDescriptor]

'psiFactory' @ [123:61] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.handleElementRename[LocalVariableDescriptor]

'newElementName' @ [123:73] ==> value-parameter newElementName: String? defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.handleElementRename[ValueParameterDescriptorImpl]

'firstOrNull' @ [124:26] ==> public inline fun <T> Sequence<PsiElement?>.firstOrNull(predicate: (PsiElement?) -> Boolean): PsiElement? defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement?

'it' @ [124:40] ==> value-parameter it: PsiElement? defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.handleElementRename.<anonymous>[ValueParameterDescriptorImpl]

'psiFactory' @ [124:56] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.handleElementRename[LocalVariableDescriptor]

'createNameIdentifier' @ [124:67] ==> public final fun createNameIdentifier(name: String): PsiElement defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'newElementName' @ [124:88] ==> value-parameter newElementName: String? defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.handleElementRename[ValueParameterDescriptorImpl]

'quoteIfNeeded' @ [124:103] ==> public fun String.quoteIfNeeded(): String defined in org.jetbrains.kotlin.idea.core in file Utils.kt[SimpleFunctionDescriptorImpl]

'expression' @ [126:27] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[PropertyDescriptorImpl]

'getReferencedNameElement' @ [126:38] ==> public abstract fun getReferencedNameElement(): PsiElement defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[DeserializedSimpleFunctionDescriptor]

'nameElement' @ [128:27] ==> val nameElement: PsiElement defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.handleElementRename[LocalVariableDescriptor]

'node' @ [128:39] ==> public final val PsiElement.node: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'elementType' @ [128:44] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'elementType' @ [129:13] ==> val elementType: IElementType defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.handleElementRename[LocalVariableDescriptor]

'!=' @ [129:39] ==> public open fun equals(other: Any?): Boolean defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'getNameForOperationSymbol' @ [129:59] ==> @Nullable public open fun getNameForOperationSymbol(@NotNull p0: KtToken): Name? defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaMethodDescriptor]

'elementType' @ [129:85] ==> val elementType: IElementType defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.handleElementRename[LocalVariableDescriptor]

'expression' @ [130:32] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[PropertyDescriptorImpl]

'parent' @ [130:43] ==> public final val KtSimpleNameExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'opExpression' @ [131:17] ==> val opExpression: KtOperationExpression? defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.handleElementRename[LocalVariableDescriptor]

'component1' @ [132:22] ==> public final operator fun component1(): KtExpression defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [132:37] ==> public final operator fun component2(): KtSimpleNameExpression defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'OperatorToFunctionIntention' @ [132:55] ==> public companion object defined in org.jetbrains.kotlin.idea.intentions.OperatorToFunctionIntention[FakeCallableDescriptorForObject]

'convert' @ [132:83] ==> public final fun convert(element: KtExpression): Pair<KtExpression, KtSimpleNameExpression> defined in org.jetbrains.kotlin.idea.intentions.OperatorToFunctionIntention.Companion[SimpleFunctionDescriptorImpl]

'opExpression' @ [132:91] ==> val opExpression: KtOperationExpression? defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.handleElementRename[LocalVariableDescriptor]

'newNameElement' @ [133:17] ==> val newNameElement: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.handleElementRename[LocalVariableDescriptor]

'replace' @ [133:32] ==> public abstract fun replace(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[JavaMethodDescriptor]

'element' @ [133:40] ==> val element: PsiElement defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.handleElementRename[LocalVariableDescriptor]

'newExpression' @ [134:24] ==> val newExpression: KtExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.handleElementRename[LocalVariableDescriptor]

'nameElement' @ [138:9] ==> val nameElement: PsiElement defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.handleElementRename[LocalVariableDescriptor]

'replace' @ [138:21] ==> public abstract fun replace(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'element' @ [138:29] ==> val element: PsiElement defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.handleElementRename[LocalVariableDescriptor]

'expression' @ [139:16] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[PropertyDescriptorImpl]

'bindToElement' @ [150:13] ==> public final fun bindToElement(element: PsiElement, shorteningMode: KtSimpleNameReference.ShorteningMode): PsiElement defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[SimpleFunctionDescriptorImpl]

'element' @ [150:27] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.bindToElement[ValueParameterDescriptorImpl]

'DELAYED_SHORTENING' @ [150:51] ==> enum entry DELAYED_SHORTENING defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.ShorteningMode[FakeCallableDescriptorForObject]

'element' @ [153:13] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.bindToElement[ValueParameterDescriptorImpl]

'getKotlinFqName' @ [153:21] ==> public fun PsiElement.getKotlinFqName(): FqName? defined in org.jetbrains.kotlin.idea.refactoring.fqName in file fqNameUtil.kt[SimpleFunctionDescriptorImpl]

'let' @ [153:40] ==> @InlineOnly public inline fun <T, R> FqName.let(block: (FqName) -> PsiElement): PsiElement defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FqName
    <R> -> PsiElement

'bindToFqName' @ [153:56] ==> public final fun bindToFqName(fqName: FqName, shorteningMode: KtSimpleNameReference.ShorteningMode = ...): PsiElement defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[SimpleFunctionDescriptorImpl]

'fqName' @ [153:69] ==> value-parameter fqName: FqName defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.bindToElement.<anonymous>[ValueParameterDescriptorImpl]

'shorteningMode' @ [153:77] ==> value-parameter shorteningMode: KtSimpleNameReference.ShorteningMode defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.bindToElement[ValueParameterDescriptorImpl]

'expression' @ [153:98] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[PropertyDescriptorImpl]

'DELAYED_SHORTENING' @ [155:86] ==> enum entry DELAYED_SHORTENING defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.ShorteningMode[FakeCallableDescriptorForObject]

'expression' @ [156:26] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[PropertyDescriptorImpl]

'fqName' @ [157:13] ==> value-parameter fqName: FqName defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.bindToFqName[ValueParameterDescriptorImpl]

'isRoot' @ [157:20] ==> public final val FqName.isRoot: Boolean[MyPropertyDescriptor]

'expression' @ [157:35] ==> val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.bindToFqName[LocalVariableDescriptor]

'expression' @ [160:13] ==> val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.bindToFqName[LocalVariableDescriptor]

'expression' @ [160:62] ==> val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.bindToFqName[LocalVariableDescriptor]

'expression' @ [161:13] ==> val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.bindToFqName[LocalVariableDescriptor]

'parent' @ [161:24] ==> public final val KtNameReferenceExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'expression' @ [161:54] ==> val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.bindToFqName[LocalVariableDescriptor]

'parent' @ [161:65] ==> public final val KtNameReferenceExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'expression' @ [161:101] ==> val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.bindToFqName[LocalVariableDescriptor]

'expression' @ [163:29] ==> val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.bindToFqName[LocalVariableDescriptor]

'changeQualifiedName' @ [163:40] ==> private final fun KtNameReferenceExpression.changeQualifiedName(fqName: FqName): KtNameReferenceExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[SimpleFunctionDescriptorImpl]

'fqName' @ [163:60] ==> value-parameter fqName: FqName defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.bindToFqName[ValueParameterDescriptorImpl]

'quoteIfNeeded' @ [163:67] ==> public fun FqName.quoteIfNeeded(): FqName defined in org.jetbrains.kotlin.idea.core[SimpleFunctionDescriptorImpl]

'newExpression' @ [164:35] ==> val newExpression: KtNameReferenceExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.bindToFqName[LocalVariableDescriptor]

'getQualifiedElementOrCallableRef' @ [164:49] ==> public fun KtSimpleNameExpression.getQualifiedElementOrCallableRef(): KtElement defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'shorteningMode' @ [166:13] ==> value-parameter shorteningMode: KtSimpleNameReference.ShorteningMode = ... defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.bindToFqName[ValueParameterDescriptorImpl]

'NO_SHORTENING' @ [166:46] ==> enum entry NO_SHORTENING defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.ShorteningMode[FakeCallableDescriptorForObject]

'newExpression' @ [166:68] ==> val newExpression: KtNameReferenceExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.bindToFqName[LocalVariableDescriptor]

'==' @ [169:17] ==> public open fun equals(other: Any?): Boolean defined in org.jetbrains.kotlin.psi.KtElementImplStub[DeserializedSimpleFunctionDescriptor]

'getParentOfType' @ [169:29] ==> @SafeVarargs @Nullable @Contract public open fun <T : (PsiElement..PsiElement?)> getParentOfType(@Nullable p0: PsiElement?, @NotNull vararg p1: (Class<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>?)>?)>..Class<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>?)>?)>?)): KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>?)>? defined in com.intellij.psi.util.PsiTreeUtil[JavaMethodDescriptor]
Inferred types:
    <T : (PsiElement..PsiElement?)> -> KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out (org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out (org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>..org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>?)>..com.intellij.psi.stubs.StubElement<out (org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>..org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>?)>?)>..org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out (org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>..org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>?)>..com.intellij.psi.stubs.StubElement<out (org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>..org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>?)>?)>?)>..com.intellij.psi.stubs.StubElement<out (org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out (org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>..org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>?)>..com.intellij.psi.stubs.StubElement<out (org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>..org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>?)>?)>..org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out (org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>..org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>?)>..com.intellij.psi.stubs.StubElement<out (org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>..org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>?)>?)>?)>?)>

'expression' @ [169:45] ==> val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.bindToFqName[LocalVariableDescriptor]

'java' @ [169:82] ==> public val <T> KClass<KtImportDirective>.java: Class<KtImportDirective> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtImportDirective

'java' @ [169:114] ==> public val <T> KClass<KtPackageDirective>.java: Class<KtPackageDirective> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtPackageDirective

'needToShorten' @ [170:13] ==> val needToShorten: Boolean defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.bindToFqName[LocalVariableDescriptor]

'when (shorteningMode) {
                ShorteningMode.FORCED_SHORTENING -> ShortenReferences.DEFAULT.process(newQualifiedElement)
                else -> newQualifiedElement.addToShorteningWaitSet()
            }' @ [171:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Any, entry1: Any): Any[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Any

'shorteningMode' @ [171:19] ==> value-parameter shorteningMode: KtSimpleNameReference.ShorteningMode = ... defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.bindToFqName[ValueParameterDescriptorImpl]

'FORCED_SHORTENING' @ [172:32] ==> enum entry FORCED_SHORTENING defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.ShorteningMode[FakeCallableDescriptorForObject]

'ShortenReferences' @ [172:53] ==> public companion object defined in org.jetbrains.kotlin.idea.core.ShortenReferences[FakeCallableDescriptorForObject]

'DEFAULT' @ [172:71] ==> @JvmField public final val DEFAULT: ShortenReferences defined in org.jetbrains.kotlin.idea.core.ShortenReferences.Companion[PropertyDescriptorImpl]

'process' @ [172:79] ==> @JvmOverloads public final fun process(element: KtElement, elementFilter: (PsiElement) -> ShortenReferences.FilterResult = ...): KtElement defined in org.jetbrains.kotlin.idea.core.ShortenReferences[SimpleFunctionDescriptorImpl]

'newQualifiedElement' @ [172:87] ==> val newQualifiedElement: KtElement defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.bindToFqName[LocalVariableDescriptor]

'newQualifiedElement' @ [173:25] ==> val newQualifiedElement: KtElement defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.bindToFqName[LocalVariableDescriptor]

'addToShorteningWaitSet' @ [173:45] ==> public fun KtElement.addToShorteningWaitSet(options: ShortenReferences.Options = ...): Unit defined in org.jetbrains.kotlin.idea.codeInsight.shorten in file delayedRequestsWaitingSet.kt[SimpleFunctionDescriptorImpl]

'newExpression' @ [177:16] ==> val newExpression: KtNameReferenceExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.bindToFqName[LocalVariableDescriptor]

'assert' @ [186:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'!' @ [186:16] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'fqName' @ [186:17] ==> value-parameter fqName: FqName defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[ValueParameterDescriptorImpl]

'isRoot' @ [186:24] ==> public final val FqName.isRoot: Boolean[MyPropertyDescriptor]

'this' @ [186:71] ==> <this> defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[ReceiverParameterDescriptorImpl]

'fqName' @ [188:25] ==> value-parameter fqName: FqName defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[ValueParameterDescriptorImpl]

'shortName' @ [188:32] ==> @NotNull public open fun shortName(): Name defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'asString' @ [188:44] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'KtPsiFactory' @ [189:26] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'this' @ [189:39] ==> <this> defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[ReceiverParameterDescriptorImpl]

'parent' @ [190:22] ==> public final val KtNameReferenceExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'when {
            parent is KtCallElement -> {
                val callCopy = parent.copied()
                callCopy.calleeExpression!!.replace(psiFactory.createSimpleName(shortName)).parent!!.text
            }
            parent is KtCallableReferenceExpression && parent.callableReference == this -> {
                parentDelimiter = ""
                val callableRefCopy = parent.copied()
                callableRefCopy.callableReference.replace(psiFactory.createSimpleName(shortName)).parent!!.text
            }
            else -> shortName
        }' @ [192:26] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: (String..String?), entry1: (String..String?), entry2: (String..String?)): (String..String?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> (kotlin.String..kotlin.String?)

'parent' @ [193:13] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'parent' @ [194:32] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'copied' @ [194:39] ==> @Suppress public fun <T : PsiElement> KtCallElement.copied(): KtCallElement defined in org.jetbrains.kotlin.idea.core[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : PsiElement> -> KtCallElement

'callCopy' @ [195:17] ==> val callCopy: KtCallElement defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'calleeExpression' @ [195:26] ==> public final val KtCallElement.calleeExpression: KtExpression?[MyPropertyDescriptor]

'replace' @ [195:45] ==> public abstract fun replace(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtExpression[JavaMethodDescriptor]

'psiFactory' @ [195:53] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'createSimpleName' @ [195:64] ==> public final fun createSimpleName(name: String): KtSimpleNameExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'shortName' @ [195:81] ==> val shortName: String defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'parent' @ [195:93] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'text' @ [195:102] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'parent' @ [197:13] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'parent' @ [197:56] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'callableReference' @ [197:63] ==> public final val KtCallableReferenceExpression.callableReference: KtSimpleNameExpression[MyPropertyDescriptor]

'this' @ [197:84] ==> <this> defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[ReceiverParameterDescriptorImpl]

'parentDelimiter' @ [198:17] ==> var parentDelimiter: String defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'parent' @ [199:39] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'copied' @ [199:46] ==> @Suppress public fun <T : PsiElement> KtCallableReferenceExpression.copied(): KtCallableReferenceExpression defined in org.jetbrains.kotlin.idea.core[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : PsiElement> -> KtCallableReferenceExpression

'callableRefCopy' @ [200:17] ==> val callableRefCopy: KtCallableReferenceExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'callableReference' @ [200:33] ==> public final val KtCallableReferenceExpression.callableReference: KtSimpleNameExpression[MyPropertyDescriptor]

'replace' @ [200:51] ==> public abstract fun replace(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[JavaMethodDescriptor]

'psiFactory' @ [200:59] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'createSimpleName' @ [200:70] ==> public final fun createSimpleName(name: String): KtSimpleNameExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'shortName' @ [200:87] ==> val shortName: String defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'parent' @ [200:99] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'text' @ [200:108] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'shortName' @ [202:21] ==> val shortName: String defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'if (!fqName.isOneSegmentFQN()) "${fqName.parent().asString()}$parentDelimiter$fqNameBase" else fqNameBase' @ [205:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (String..String?), elseBranch: (String..String?)): (String..String?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (kotlin.String..kotlin.String?)

'!' @ [205:24] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'fqName' @ [205:25] ==> value-parameter fqName: FqName defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[ValueParameterDescriptorImpl]

'isOneSegmentFQN' @ [205:32] ==> public fun FqName.isOneSegmentFQN(): Boolean defined in org.jetbrains.kotlin.name[DeserializedSimpleFunctionDescriptor]

'fqName' @ [205:54] ==> value-parameter fqName: FqName defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[ValueParameterDescriptorImpl]

'parent' @ [205:61] ==> @NotNull public open fun parent(): FqName defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'asString' @ [205:70] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'parentDelimiter' @ [205:82] ==> var parentDelimiter: String defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'fqNameBase' @ [205:98] ==> val fqNameBase: (String..String?) defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'fqNameBase' @ [205:115] ==> val fqNameBase: (String..String?) defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'getQualifiedElementOrCallableRef' @ [207:32] ==> public fun KtSimpleNameExpression.getQualifiedElementOrCallableRef(): KtElement defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'when (elementToReplace) {
            is KtUserType -> {
                val typeText = "$text${elementToReplace.typeArgumentList?.text ?: ""}"
                elementToReplace.replace(psiFactory.createType(typeText).typeElement!!)
            }
            else -> KtPsiUtil.safeDeparenthesize(elementToReplace.replaced(psiFactory.createExpression(text)))
        }' @ [209:26] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: (PsiElement..PsiElement?), entry1: (PsiElement..PsiElement?)): (PsiElement..PsiElement?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> (com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)

'elementToReplace' @ [209:32] ==> val elementToReplace: KtElement defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'text' @ [211:34] ==> val text: (String..String?) defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'elementToReplace' @ [211:40] ==> val elementToReplace: KtElement defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'typeArgumentList' @ [211:57] ==> public final val KtUserType.typeArgumentList: KtTypeArgumentList?[MyPropertyDescriptor]

'text' @ [211:75] ==> public final val KtTypeArgumentList.text: (String..String?)[MyPropertyDescriptor]

'elementToReplace' @ [212:17] ==> val elementToReplace: KtElement defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'replace' @ [212:34] ==> public abstract fun replace(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtElement[JavaMethodDescriptor]

'psiFactory' @ [212:42] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'createType' @ [212:53] ==> public final fun createType(type: String): KtTypeReference defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'typeText' @ [212:64] ==> val typeText: String defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'typeElement' @ [212:74] ==> public final val typeElement: KtTypeElement? defined in org.jetbrains.kotlin.psi.KtTypeReference[DeserializedPropertyDescriptor]

'safeDeparenthesize' @ [214:31] ==> @NotNull public open fun safeDeparenthesize(@NotNull p0: KtExpression): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'elementToReplace' @ [214:50] ==> val elementToReplace: KtElement defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'replaced' @ [214:67] ==> @Suppress public inline fun <reified T : PsiElement> PsiElement.replaced(newElement: KtExpression): KtExpression defined in org.jetbrains.kotlin.idea.core[SimpleFunctionDescriptorImpl]
Inferred types:
    <reified T : PsiElement> -> KtExpression

'psiFactory' @ [214:76] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'createExpression' @ [214:87] ==> public final fun createExpression(text: String): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'text' @ [214:104] ==> val text: (String..String?) defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'?:' @ [217:24] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtElement?, right: KtElement?): KtElement?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtElement?

'newElement' @ [217:25] ==> val newElement: KtElement defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'callableReference' @ [217:72] ==> public final val KtCallableReferenceExpression.callableReference: KtSimpleNameExpression[MyPropertyDescriptor]

'newElement' @ [218:27] ==> val newElement: KtElement defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'getQualifiedElementSelector' @ [218:38] ==> public fun KtElement.getQualifiedElementSelector(): KtElement? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'error' @ [219:27] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'newElement' @ [219:51] ==> val newElement: KtElement defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'selector' @ [220:16] ==> val selector: KtElement defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.changeQualifiedName[LocalVariableDescriptor]

'expression' @ [223:47] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[PropertyDescriptorImpl]

'text' @ [223:58] ==> public final val KtSimpleNameExpression.text: (String..String?)[MyPropertyDescriptor]

'element' @ [227:27] ==> public final val KtSimpleNameReference.element: (KtSimpleNameExpression..KtSimpleNameExpression?)[MyPropertyDescriptor]

'element' @ [229:17] ==> val element: (KtSimpleNameExpression..KtSimpleNameExpression?) defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.<get-resolvesByNames>[LocalVariableDescriptor]

'element' @ [230:33] ==> val element: (KtSimpleNameExpression..KtSimpleNameExpression?) defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.<get-resolvesByNames>[LocalVariableDescriptor]

'operationSignTokenType' @ [230:41] ==> public final val operationSignTokenType: KtSingleValueToken? defined in org.jetbrains.kotlin.psi.KtOperationReferenceExpression[DeserializedPropertyDescriptor]

'tokenType' @ [231:21] ==> val tokenType: KtSingleValueToken? defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.<get-resolvesByNames>[LocalVariableDescriptor]

'?:' @ [232:32] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: Name?, right: Name): Name[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> Name

'getNameForOperationSymbol' @ [232:52] ==> @Nullable public open fun getNameForOperationSymbol(@NotNull p0: KtToken, p1: Boolean, p2: Boolean): Name? defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaMethodDescriptor]

'tokenType' @ [233:29] ==> val tokenType: KtSingleValueToken? defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.<get-resolvesByNames>[LocalVariableDescriptor]

'element' @ [233:40] ==> val element: (KtSimpleNameExpression..KtSimpleNameExpression?) defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.<get-resolvesByNames>[LocalVariableDescriptor]

'parent' @ [233:48] ==> public final val KtOperationReferenceExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'element' @ [233:77] ==> val element: (KtSimpleNameExpression..KtSimpleNameExpression?) defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.<get-resolvesByNames>[LocalVariableDescriptor]

'parent' @ [233:85] ==> public final val KtOperationReferenceExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'emptyList' @ [234:33] ==> public fun <T> emptyList(): List<Name> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Name

'OperatorConventions.ASSIGNMENT_OPERATION_COUNTERPARTS[tokenType]' @ [235:39] ==> public abstract fun get(@Nullable key: KtSingleValueToken?): KtSingleValueToken? defined in com.google.common.collect.ImmutableBiMap[JavaMethodDescriptor]

'ASSIGNMENT_OPERATION_COUNTERPARTS' @ [235:59] ==> public final val ASSIGNMENT_OPERATION_COUNTERPARTS: (ImmutableBiMap<(KtSingleValueToken..KtSingleValueToken?), (KtSingleValueToken..KtSingleValueToken?)>..ImmutableBiMap<(KtSingleValueToken..KtSingleValueToken?), (KtSingleValueToken..KtSingleValueToken?)>?) defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaPropertyDescriptor]

'tokenType' @ [235:93] ==> val tokenType: KtSingleValueToken? defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.<get-resolvesByNames>[LocalVariableDescriptor]

'if (counterpart != null) {
                        val counterpartName = OperatorConventions.getNameForOperationSymbol(counterpart, false, true)!!
                        listOf(name, counterpartName)
                    }
                    else {
                        listOf(name)
                    }' @ [236:28] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Collection<Name>, elseBranch: Collection<Name>): Collection<Name>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Collection<Name>

'counterpart' @ [236:32] ==> val counterpart: KtSingleValueToken? defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.<get-resolvesByNames>[LocalVariableDescriptor]

'!!' @ [237:47] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: Name?): Name[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> Name

'getNameForOperationSymbol' @ [237:67] ==> @Nullable public open fun getNameForOperationSymbol(@NotNull p0: KtToken, p1: Boolean, p2: Boolean): Name? defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaMethodDescriptor]

'counterpart' @ [237:93] ==> val counterpart: KtSingleValueToken? defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.<get-resolvesByNames>[LocalVariableDescriptor]

'listOf' @ [238:25] ==> public fun <T> listOf(vararg elements: Name): List<Name> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Name

'name' @ [238:32] ==> val name: Name defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.<get-resolvesByNames>[LocalVariableDescriptor]

'counterpartName' @ [238:38] ==> val counterpartName: Name defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.<get-resolvesByNames>[LocalVariableDescriptor]

'listOf' @ [241:25] ==> public fun <T> listOf(element: Name): List<Name> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Name

'name' @ [241:32] ==> val name: Name defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.<get-resolvesByNames>[LocalVariableDescriptor]

'listOf' @ [246:20] ==> public fun <T> listOf(element: Name): List<Name> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Name

'element' @ [246:27] ==> val element: (KtSimpleNameExpression..KtSimpleNameExpression?) defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.<get-resolvesByNames>[LocalVariableDescriptor]

'getReferencedNameAsName' @ [246:35] ==> public abstract fun getReferencedNameAsName(): Name defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[DeserializedSimpleFunctionDescriptor]

'if (this is ImportedFromObjectCallableDescriptor<*>) callableFromObject else this' @ [250:46] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: DeclarationDescriptor, elseBranch: DeclarationDescriptor): DeclarationDescriptor[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> DeclarationDescriptor

'this' @ [250:50] ==> <this> defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getImportAlias.unwrap[ReceiverParameterDescriptorImpl]

'callableFromObject' @ [250:99] ==> public final val callableFromObject: CallableMemberDescriptor defined in org.jetbrains.kotlin.resolve.ImportedFromObjectCallableDescriptor[DeserializedPropertyDescriptor]

'this' @ [250:123] ==> <this> defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getImportAlias.unwrap[ReceiverParameterDescriptorImpl]

'element' @ [252:23] ==> public final val KtSimpleNameReference.element: (KtSimpleNameExpression..KtSimpleNameExpression?)[MyPropertyDescriptor]

'element' @ [253:20] ==> val element: (KtSimpleNameExpression..KtSimpleNameExpression?) defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getImportAlias[LocalVariableDescriptor]

'getReferencedName' @ [253:28] ==> public abstract fun getReferencedName(): String defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[DeserializedSimpleFunctionDescriptor]

'element' @ [254:20] ==> val element: (KtSimpleNameExpression..KtSimpleNameExpression?) defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getImportAlias[LocalVariableDescriptor]

'containingKtFile' @ [254:28] ==> public final val KtSimpleNameExpression.containingKtFile: KtFile[MyPropertyDescriptor]

'file' @ [255:31] ==> val file: KtFile defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getImportAlias[LocalVariableDescriptor]

'findImportByAlias' @ [255:36] ==> @Nullable public open fun findImportByAlias(@NotNull p0: String): KtImportDirective? defined in org.jetbrains.kotlin.psi.KtFile[JavaMethodDescriptor]

'name' @ [255:54] ==> val name: String defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getImportAlias[LocalVariableDescriptor]

'importDirective' @ [256:22] ==> val importDirective: KtImportDirective defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getImportAlias[LocalVariableDescriptor]

'importedFqName' @ [256:38] ==> public final val KtImportDirective.importedFqName: FqName?[MyPropertyDescriptor]

'file' @ [257:35] ==> val file: KtFile defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getImportAlias[LocalVariableDescriptor]

'resolveImportReference' @ [257:40] ==> public fun KtFile.resolveImportReference(fqName: FqName): Collection<DeclarationDescriptor> defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'fqName' @ [257:63] ==> val fqName: FqName defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getImportAlias[LocalVariableDescriptor]

'map' @ [257:71] ==> public inline fun <T, R> Iterable<DeclarationDescriptor>.map(transform: (DeclarationDescriptor) -> DeclarationDescriptor): List<DeclarationDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DeclarationDescriptor
    <R> -> DeclarationDescriptor

'it' @ [257:77] ==> value-parameter it: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getImportAlias.<anonymous>[ValueParameterDescriptorImpl]

'unwrap' @ [257:80] ==> local final fun DeclarationDescriptor.unwrap(): DeclarationDescriptor defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getImportAlias[SimpleFunctionDescriptorImpl]

'getTargetDescriptors' @ [258:13] ==> protected open fun getTargetDescriptors(context: BindingContext): Collection<DeclarationDescriptor> defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[SimpleFunctionDescriptorImpl]

'element' @ [258:34] ==> val element: (KtSimpleNameExpression..KtSimpleNameExpression?) defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getImportAlias[LocalVariableDescriptor]

'analyze' @ [258:42] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'PARTIAL' @ [258:66] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'any' @ [258:76] ==> public inline fun <T> Iterable<DeclarationDescriptor>.any(predicate: (DeclarationDescriptor) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DeclarationDescriptor

'it' @ [258:82] ==> value-parameter it: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getImportAlias.<anonymous>[ValueParameterDescriptorImpl]

'unwrap' @ [258:85] ==> local final fun DeclarationDescriptor.unwrap(): DeclarationDescriptor defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getImportAlias[SimpleFunctionDescriptorImpl]

'getImportableDescriptor' @ [258:94] ==> public fun DeclarationDescriptor.getImportableDescriptor(): DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedSimpleFunctionDescriptor]

'importedDescriptors' @ [258:123] ==> val importedDescriptors: List<DeclarationDescriptor> defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getImportAlias[LocalVariableDescriptor]

'importDirective' @ [259:20] ==> val importDirective: KtImportDirective defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference.getImportAlias[LocalVariableDescriptor]

'alias' @ [259:36] ==> public final val KtImportDirective.alias: KtImportAlias?[MyPropertyDescriptor]

