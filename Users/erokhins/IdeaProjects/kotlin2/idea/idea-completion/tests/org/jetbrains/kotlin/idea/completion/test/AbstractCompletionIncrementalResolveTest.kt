'KotlinLightCodeInsightFixtureTestCase' @ [31:59] ==> public constructor KotlinLightCodeInsightFixtureTestCase() defined in org.jetbrains.kotlin.idea.test.KotlinLightCodeInsightFixtureTestCase[ClassConstructorDescriptorImpl]

'INSTANCE' @ [37:89] ==> @NotNull public final val INSTANCE: KotlinWithJdkAndRuntimeLightProjectDescriptor defined in org.jetbrains.kotlin.idea.test.KotlinWithJdkAndRuntimeLightProjectDescriptor[JavaPropertyDescriptor]

'CompletionBindingContextProvider' @ [40:9] ==> public companion object defined in org.jetbrains.kotlin.idea.completion.CompletionBindingContextProvider[FakeCallableDescriptorForObject]

'ENABLED' @ [40:42] ==> public final var ENABLED: Boolean defined in org.jetbrains.kotlin.idea.completion.CompletionBindingContextProvider.Companion[DeserializedPropertyDescriptor]

'File' @ [42:24] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'testPath' @ [42:29] ==> value-parameter testPath: String defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[ValueParameterDescriptorImpl]

'loadFile' @ [43:43] ==> @NotNull public open fun loadFile(@NotNull p0: File, p1: Boolean): String defined in com.intellij.openapi.util.io.FileUtil[JavaMethodDescriptor]

'file' @ [43:52] ==> val file: File defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'contains' @ [43:64] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'myFixture' @ [44:13] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest[JavaPropertyDescriptor]

'configureByFile' @ [44:23] ==> public abstract fun configureByFile(@NotNull p0: String): (PsiFile..PsiFile?) defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'testPath' @ [44:39] ==> value-parameter testPath: String defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[ValueParameterDescriptorImpl]

'myFixture' @ [46:28] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest[JavaPropertyDescriptor]

'editor' @ [46:38] ==> public final val JavaCodeInsightTestFixture.editor: (Editor..Editor?)[MyPropertyDescriptor]

'document' @ [46:45] ==> public final val Editor.document: Document[MyPropertyDescriptor]

'document' @ [47:38] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'text' @ [47:47] ==> public final val Document.text: String[MyPropertyDescriptor]

'indexOf' @ [47:52] ==> public fun CharSequence.indexOf(string: String, startIndex: Int = ..., ignoreCase: Boolean = ...): Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'BEFORE_MARKER' @ [47:60] ==> private final val BEFORE_MARKER: String defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest[PropertyDescriptorImpl]

'assertTrue' @ [48:13] ==> public open fun assertTrue(p0: (String..String?), p1: Boolean): Unit defined in org.jetbrains.kotlin.idea.test.KotlinLightCodeInsightFixtureTestCaseBase[JavaMethodDescriptor]

'BEFORE_MARKER' @ [48:28] ==> private final val BEFORE_MARKER: String defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest[PropertyDescriptorImpl]

'testPath' @ [48:66] ==> value-parameter testPath: String defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[ValueParameterDescriptorImpl]

'beforeMarkerOffset' @ [48:79] ==> val beforeMarkerOffset: Int defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'document' @ [50:38] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'text' @ [50:47] ==> public final val Document.text: String[MyPropertyDescriptor]

'indexOf' @ [50:52] ==> public fun CharSequence.indexOf(string: String, startIndex: Int = ..., ignoreCase: Boolean = ...): Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'CHANGE_MARKER' @ [50:60] ==> private final val CHANGE_MARKER: String defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest[PropertyDescriptorImpl]

'assertTrue' @ [51:13] ==> public open fun assertTrue(p0: (String..String?), p1: Boolean): Unit defined in org.jetbrains.kotlin.idea.test.KotlinLightCodeInsightFixtureTestCaseBase[JavaMethodDescriptor]

'CHANGE_MARKER' @ [51:28] ==> private final val CHANGE_MARKER: String defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest[PropertyDescriptorImpl]

'testPath' @ [51:66] ==> value-parameter testPath: String defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[ValueParameterDescriptorImpl]

'changeMarkerOffset' @ [51:79] ==> val changeMarkerOffset: Int defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'findArrayWithPrefixes' @ [53:52] ==> @NotNull public open fun findArrayWithPrefixes(@NotNull p0: String, @NotNull vararg p1: (String..String?)): (Array<(String..String?)>..Array<out (String..String?)>) defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'document' @ [53:74] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'text' @ [53:83] ==> public final val Document.text: String[MyPropertyDescriptor]

'TYPE_DIRECTIVE_PREFIX' @ [53:89] ==> private final val TYPE_DIRECTIVE_PREFIX: String defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest[PropertyDescriptorImpl]

'singleOrNull' @ [53:112] ==> public fun <T> Array<out (String..String?)>.singleOrNull(): String? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.String..kotlin.String?)

'let' @ [54:23] ==> @InlineOnly public inline fun <T, R> String.let(block: (String) -> String): String defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String
    <R> -> String

'unquoteString' @ [54:40] ==> @NotNull @Contract public open fun unquoteString(@NotNull p0: String): String defined in com.intellij.openapi.util.text.StringUtil[JavaMethodDescriptor]

'it' @ [54:54] ==> value-parameter it: String defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest.<anonymous>[ValueParameterDescriptorImpl]

'getPrefixedInt' @ [55:56] ==> @Nullable public open fun getPrefixedInt(p0: (String..String?), p1: (String..String?)): Int? defined in org.jetbrains.kotlin.test.InTextDirectivesUtils[JavaMethodDescriptor]

'document' @ [55:71] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'text' @ [55:80] ==> public final val Document.text: String[MyPropertyDescriptor]

'BACKSPACES_DIRECTIVE_PREFIX' @ [55:86] ==> private final val BACKSPACES_DIRECTIVE_PREFIX: String defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest[PropertyDescriptorImpl]

'assertTrue' @ [56:13] ==> public open fun assertTrue(p0: (String..String?), p1: Boolean): Unit defined in org.jetbrains.kotlin.idea.test.KotlinLightCodeInsightFixtureTestCaseBase[JavaMethodDescriptor]

'TYPE_DIRECTIVE_PREFIX' @ [56:44] ==> private final val TYPE_DIRECTIVE_PREFIX: String defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest[PropertyDescriptorImpl]

'BACKSPACES_DIRECTIVE_PREFIX' @ [56:75] ==> private final val BACKSPACES_DIRECTIVE_PREFIX: String defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest[PropertyDescriptorImpl]

'textToType' @ [57:24] ==> val textToType: String? defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'backspaceCount' @ [57:46] ==> val backspaceCount: Int? defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'document' @ [59:32] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'createRangeMarker' @ [59:41] ==> @NotNull public open fun createRangeMarker(p0: Int, p1: Int): RangeMarker defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'beforeMarkerOffset' @ [59:59] ==> val beforeMarkerOffset: Int defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'beforeMarkerOffset' @ [59:79] ==> val beforeMarkerOffset: Int defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'BEFORE_MARKER' @ [59:100] ==> private final val BEFORE_MARKER: String defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest[PropertyDescriptorImpl]

'length' @ [59:114] ==> public open val length: Int defined in kotlin.String[DeserializedPropertyDescriptor]

'document' @ [60:32] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'createRangeMarker' @ [60:41] ==> @NotNull public open fun createRangeMarker(p0: Int, p1: Int): RangeMarker defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'changeMarkerOffset' @ [60:59] ==> val changeMarkerOffset: Int defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'changeMarkerOffset' @ [60:79] ==> val changeMarkerOffset: Int defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'CHANGE_MARKER' @ [60:100] ==> private final val CHANGE_MARKER: String defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest[PropertyDescriptorImpl]

'length' @ [60:114] ==> public open val length: Int defined in kotlin.String[DeserializedPropertyDescriptor]

'changeMarker' @ [61:13] ==> val changeMarker: RangeMarker defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'isGreedyToRight' @ [61:26] ==> public final var RangeMarker.isGreedyToRight: Boolean[MyPropertyDescriptor]

'project' @ [63:13] ==> public final val AbstractCompletionIncrementalResolveTest.project: Project[MyPropertyDescriptor]

'executeWriteCommand' @ [63:21] ==> public fun Project.executeWriteCommand(name: String, command: () -> Unit): Unit defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]

'document' @ [64:17] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'deleteString' @ [64:26] ==> public abstract fun deleteString(p0: Int, p1: Int): Unit defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'beforeMarker' @ [64:39] ==> val beforeMarker: RangeMarker defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'startOffset' @ [64:52] ==> public final val RangeMarker.startOffset: Int[MyPropertyDescriptor]

'beforeMarker' @ [64:65] ==> val beforeMarker: RangeMarker defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'endOffset' @ [64:78] ==> public final val RangeMarker.endOffset: Int[MyPropertyDescriptor]

'document' @ [65:17] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'deleteString' @ [65:26] ==> public abstract fun deleteString(p0: Int, p1: Int): Unit defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'changeMarker' @ [65:39] ==> val changeMarker: RangeMarker defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'startOffset' @ [65:52] ==> public final val RangeMarker.startOffset: Int[MyPropertyDescriptor]

'changeMarker' @ [65:65] ==> val changeMarker: RangeMarker defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'endOffset' @ [65:78] ==> public final val RangeMarker.endOffset: Int[MyPropertyDescriptor]

'if (hasCaretMarker)
                document.createRangeMarker(editor.caretModel.offset, editor.caretModel.offset)
            else
                null' @ [68:31] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: RangeMarker?, elseBranch: RangeMarker?): RangeMarker?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> RangeMarker?

'hasCaretMarker' @ [68:35] ==> val hasCaretMarker: Boolean defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'document' @ [69:17] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'createRangeMarker' @ [69:26] ==> @NotNull public open fun createRangeMarker(p0: Int, p1: Int): RangeMarker defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'editor' @ [69:44] ==> public final val AbstractCompletionIncrementalResolveTest.editor: Editor[MyPropertyDescriptor]

'caretModel' @ [69:51] ==> public final val Editor.caretModel: CaretModel[MyPropertyDescriptor]

'offset' @ [69:62] ==> public final val CaretModel.offset: Int[MyPropertyDescriptor]

'editor' @ [69:70] ==> public final val AbstractCompletionIncrementalResolveTest.editor: Editor[MyPropertyDescriptor]

'caretModel' @ [69:77] ==> public final val Editor.caretModel: CaretModel[MyPropertyDescriptor]

'offset' @ [69:88] ==> public final val CaretModel.offset: Int[MyPropertyDescriptor]

'editor' @ [72:13] ==> public final val AbstractCompletionIncrementalResolveTest.editor: Editor[MyPropertyDescriptor]

'caretModel' @ [72:20] ==> public final val Editor.caretModel: CaretModel[MyPropertyDescriptor]

'moveToOffset' @ [72:31] ==> public abstract fun moveToOffset(p0: Int): Unit defined in com.intellij.openapi.editor.CaretModel[JavaMethodDescriptor]

'beforeMarker' @ [72:44] ==> val beforeMarker: RangeMarker defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'startOffset' @ [72:57] ==> public final val RangeMarker.startOffset: Int[MyPropertyDescriptor]

'StringBuilder' @ [74:27] ==> public final fun <init>(): StringBuilder /* = StringBuilder */ defined in kotlin.text.StringBuilder[TypeAliasConstructorDescriptorImpl]

'CompletionBindingContextProvider' @ [75:13] ==> public companion object defined in org.jetbrains.kotlin.idea.completion.CompletionBindingContextProvider[FakeCallableDescriptorForObject]

'getInstance' @ [75:46] ==> public final fun getInstance(project: Project): CompletionBindingContextProvider defined in org.jetbrains.kotlin.idea.completion.CompletionBindingContextProvider.Companion[DeserializedSimpleFunctionDescriptor]

'project' @ [75:58] ==> public final val AbstractCompletionIncrementalResolveTest.project: Project[MyPropertyDescriptor]

'TEST_LOG' @ [75:67] ==> internal final var TEST_LOG: StringBuilder? /* = StringBuilder? */ defined in org.jetbrains.kotlin.idea.completion.CompletionBindingContextProvider[DeserializedPropertyDescriptor]

'testLog' @ [75:78] ==> val testLog: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'myFixture' @ [77:13] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest[JavaPropertyDescriptor]

'complete' @ [77:23] ==> public abstract fun complete(@NotNull p0: CompletionType): (Array<(LookupElement..LookupElement?)>..Array<out (LookupElement..LookupElement?)>?) defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'BASIC' @ [77:47] ==> enum entry BASIC defined in com.intellij.codeInsight.completion.CompletionType[FakeCallableDescriptorForObject]

'project' @ [79:13] ==> public final val AbstractCompletionIncrementalResolveTest.project: Project[MyPropertyDescriptor]

'executeWriteCommand' @ [79:21] ==> public fun Project.executeWriteCommand(name: String, command: () -> Unit): Unit defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]

'backspaceCount' @ [80:21] ==> val backspaceCount: Int? defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'document' @ [81:21] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'deleteString' @ [81:30] ==> public abstract fun deleteString(p0: Int, p1: Int): Unit defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'changeMarker' @ [81:43] ==> val changeMarker: RangeMarker defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'startOffset' @ [81:56] ==> public final val RangeMarker.startOffset: Int[MyPropertyDescriptor]

'backspaceCount' @ [81:70] ==> val backspaceCount: Int? defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'changeMarker' @ [81:86] ==> val changeMarker: RangeMarker defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'startOffset' @ [81:99] ==> public final val RangeMarker.startOffset: Int[MyPropertyDescriptor]

'textToType' @ [83:21] ==> val textToType: String? defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'document' @ [84:21] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'insertString' @ [84:30] ==> public abstract fun insertString(p0: Int, @NotNull p1: CharSequence): Unit defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'changeMarker' @ [84:43] ==> val changeMarker: RangeMarker defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'startOffset' @ [84:56] ==> public final val RangeMarker.startOffset: Int[MyPropertyDescriptor]

'textToType' @ [84:69] ==> val textToType: String? defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'if (caretMarker != null) {
                editor.caretModel.moveToOffset(caretMarker.startOffset)
            }
            else {
                editor.caretModel.moveToOffset(changeMarker.endOffset)
            }' @ [88:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'caretMarker' @ [88:17] ==> val caretMarker: RangeMarker? defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'editor' @ [89:17] ==> public final val AbstractCompletionIncrementalResolveTest.editor: Editor[MyPropertyDescriptor]

'caretModel' @ [89:24] ==> public final val Editor.caretModel: CaretModel[MyPropertyDescriptor]

'moveToOffset' @ [89:35] ==> public abstract fun moveToOffset(p0: Int): Unit defined in com.intellij.openapi.editor.CaretModel[JavaMethodDescriptor]

'caretMarker' @ [89:48] ==> val caretMarker: RangeMarker? defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'startOffset' @ [89:60] ==> public final val RangeMarker.startOffset: Int[MyPropertyDescriptor]

'editor' @ [92:17] ==> public final val AbstractCompletionIncrementalResolveTest.editor: Editor[MyPropertyDescriptor]

'caretModel' @ [92:24] ==> public final val Editor.caretModel: CaretModel[MyPropertyDescriptor]

'moveToOffset' @ [92:35] ==> public abstract fun moveToOffset(p0: Int): Unit defined in com.intellij.openapi.editor.CaretModel[JavaMethodDescriptor]

'changeMarker' @ [92:48] ==> val changeMarker: RangeMarker defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'endOffset' @ [92:61] ==> public final val RangeMarker.endOffset: Int[MyPropertyDescriptor]

'testCompletion' @ [95:13] ==> public fun testCompletion(fileText: String, platform: TargetPlatform?, complete: (CompletionType, Int) -> Array<LookupElement>?, defaultCompletionType: CompletionType = ..., defaultInvocationCount: Int = ..., additionalValidDirectives: Collection<String> = ...): Unit defined in org.jetbrains.kotlin.idea.completion.test[SimpleFunctionDescriptorImpl]

'loadFile' @ [95:37] ==> @NotNull public open fun loadFile(@NotNull p0: File, p1: Boolean): String defined in com.intellij.openapi.util.io.FileUtil[JavaMethodDescriptor]

'file' @ [95:46] ==> val file: File defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'JvmPlatform' @ [96:28] ==> public object JvmPlatform : TargetPlatform defined in org.jetbrains.kotlin.resolve.jvm.platform[FakeCallableDescriptorForObject]

'myFixture' @ [97:55] ==> protected/*protected and package*/ final var myFixture: (JavaCodeInsightTestFixture..JavaCodeInsightTestFixture?) defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest[JavaPropertyDescriptor]

'complete' @ [97:65] ==> public abstract fun complete(@NotNull p0: CompletionType, p1: Int): (Array<(LookupElement..LookupElement?)>..Array<out (LookupElement..LookupElement?)>?) defined in com.intellij.testFramework.fixtures.JavaCodeInsightTestFixture[JavaMethodDescriptor]

'completionType' @ [97:74] ==> value-parameter completionType: CompletionType defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest.<anonymous>[ValueParameterDescriptorImpl]

'count' @ [97:90] ==> value-parameter count: Int defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest.<anonymous>[ValueParameterDescriptorImpl]

'listOf' @ [98:56] ==> public fun <T> listOf(vararg elements: String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'TYPE_DIRECTIVE_PREFIX' @ [98:63] ==> private final val TYPE_DIRECTIVE_PREFIX: String defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest[PropertyDescriptorImpl]

'BACKSPACES_DIRECTIVE_PREFIX' @ [98:86] ==> private final val BACKSPACES_DIRECTIVE_PREFIX: String defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest[PropertyDescriptorImpl]

'assertEqualsToFile' @ [100:29] ==> public open fun assertEqualsToFile(@NotNull p0: File, @NotNull p1: String): Unit defined in org.jetbrains.kotlin.test.KotlinTestUtils[JavaMethodDescriptor]

'File' @ [100:48] ==> public constructor File(p0: (String..String?), p1: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'file' @ [100:53] ==> val file: File defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'parent' @ [100:58] ==> public final val File.parent: (String..String?)[MyPropertyDescriptor]

'file' @ [100:66] ==> val file: File defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'nameWithoutExtension' @ [100:71] ==> public val File.nameWithoutExtension: String defined in kotlin.io[DeserializedPropertyDescriptor]

'testLog' @ [100:103] ==> val testLog: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.idea.completion.test.AbstractCompletionIncrementalResolveTest.doTest[LocalVariableDescriptor]

'toString' @ [100:111] ==> public open fun toString(): String defined in java.lang.StringBuilder[JavaMethodDescriptor]

'CompletionBindingContextProvider' @ [102:13] ==> public companion object defined in org.jetbrains.kotlin.idea.completion.CompletionBindingContextProvider[FakeCallableDescriptorForObject]

'ENABLED' @ [102:46] ==> public final var ENABLED: Boolean defined in org.jetbrains.kotlin.idea.completion.CompletionBindingContextProvider.Companion[DeserializedPropertyDescriptor]

