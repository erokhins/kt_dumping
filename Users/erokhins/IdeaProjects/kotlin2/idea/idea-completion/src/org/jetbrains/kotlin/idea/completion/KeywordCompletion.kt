'KEYWORDS' @ [50:33] ==> public final val KEYWORDS: (TokenSet..TokenSet?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'types' @ [50:42] ==> public final val TokenSet.types: (Array<(IElementType..IElementType?)>..Array<out (IElementType..IElementType?)>)[MyPropertyDescriptor]

'SOFT_KEYWORDS' @ [50:50] ==> public final val SOFT_KEYWORDS: (TokenSet..TokenSet?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'types' @ [50:64] ==> public final val TokenSet.types: (Array<(IElementType..IElementType?)>..Array<out (IElementType..IElementType?)>)[MyPropertyDescriptor]

'map' @ [51:14] ==> public inline fun <T, R> Array<out (IElementType..IElementType?)>.map(transform: ((IElementType..IElementType?)) -> KtKeywordToken): List<KtKeywordToken> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.tree.IElementType..com.intellij.psi.tree.IElementType?)
    <R> -> KtKeywordToken

'it' @ [51:20] ==> value-parameter it: (IElementType..IElementType?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.ALL_KEYWORDS.<anonymous>[ValueParameterDescriptorImpl]

'create' @ [53:54] ==> @NotNull public open fun create(@NotNull vararg p0: (IElementType..IElementType?)): TokenSet defined in com.intellij.psi.tree.TokenSet[JavaMethodDescriptor]

'OVERRIDE_KEYWORD' @ [53:61] ==> public final val OVERRIDE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'mapOf' @ [55:37] ==> public fun <K, V> mapOf(vararg pairs: Pair<KtKeywordToken, KtKeywordToken>): Map<KtKeywordToken, KtKeywordToken> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> KtKeywordToken
    <V> -> KtKeywordToken

'COMPANION_KEYWORD' @ [56:13] ==> public final val COMPANION_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'OBJECT_KEYWORD' @ [56:34] ==> public final val OBJECT_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'ENUM_KEYWORD' @ [57:13] ==> public final val ENUM_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'CLASS_KEYWORD' @ [57:29] ==> public final val CLASS_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'ANNOTATION_KEYWORD' @ [58:13] ==> public final val ANNOTATION_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'CLASS_KEYWORD' @ [58:35] ==> public final val CLASS_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'SEALED_KEYWORD' @ [59:13] ==> public final val SEALED_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'CLASS_KEYWORD' @ [59:31] ==> public final val CLASS_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'LATEINIT_KEYWORD' @ [60:13] ==> public final val LATEINIT_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'VAR_KEYWORD' @ [60:33] ==> public final val VAR_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'mapOf' @ [63:38] ==> public fun <K, V> mapOf(vararg pairs: Pair<KtKeywordToken, String>): Map<KtKeywordToken, String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> KtKeywordToken
    <V> -> String

'IF_KEYWORD' @ [64:13] ==> public final val IF_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'WHILE_KEYWORD' @ [65:13] ==> public final val WHILE_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'FOR_KEYWORD' @ [66:13] ==> public final val FOR_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'TRY_KEYWORD' @ [67:13] ==> public final val TRY_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'CATCH_KEYWORD' @ [68:13] ==> public final val CATCH_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'FINALLY_KEYWORD' @ [69:13] ==> public final val FINALLY_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'DO_KEYWORD' @ [70:13] ==> public final val DO_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'INIT_KEYWORD' @ [71:13] ==> public final val INIT_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'CONSTRUCTOR_KEYWORD' @ [72:13] ==> public final val CONSTRUCTOR_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'COMPANION_KEYWORD' @ [73:13] ==> public final val COMPANION_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'listOf' @ [76:34] ==> public fun <T> listOf(vararg elements: (KtKeywordToken..KtKeywordToken?)): List<(KtKeywordToken..KtKeywordToken?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.lexer.KtKeywordToken..org.jetbrains.kotlin.lexer.KtKeywordToken?)

'THIS_KEYWORD' @ [76:41] ==> public final val THIS_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'SUPER_KEYWORD' @ [77:41] ==> public final val SUPER_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'NULL_KEYWORD' @ [78:41] ==> public final val NULL_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'TRUE_KEYWORD' @ [79:41] ==> public final val TRUE_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'FALSE_KEYWORD' @ [80:41] ==> public final val FALSE_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'BREAK_KEYWORD' @ [81:41] ==> public final val BREAK_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'CONTINUE_KEYWORD' @ [82:41] ==> public final val CONTINUE_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'ELSE_KEYWORD' @ [83:41] ==> public final val ELSE_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'WHEN_KEYWORD' @ [84:41] ==> public final val WHEN_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'FILE_KEYWORD' @ [85:41] ==> public final val FILE_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'DYNAMIC_KEYWORD' @ [86:41] ==> public final val DYNAMIC_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'GET_KEYWORD' @ [87:41] ==> public final val GET_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'SET_KEYWORD' @ [88:41] ==> public final val SET_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'map' @ [88:54] ==> public inline fun <T, R> Iterable<(KtKeywordToken..KtKeywordToken?)>.map(transform: ((KtKeywordToken..KtKeywordToken?)) -> String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.lexer.KtKeywordToken..org.jetbrains.kotlin.lexer.KtKeywordToken?)
    <R> -> String

'it' @ [88:60] ==> value-parameter it: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.NO_SPACE_AFTER.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [88:63] ==> public final val KtKeywordToken.value: String[MyPropertyDescriptor]

'!' @ [91:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'GENERAL_FILTER' @ [91:14] ==> private final val GENERAL_FILTER: NotFilter defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[PropertyDescriptorImpl]

'isAcceptable' @ [91:29] ==> public open fun isAcceptable(p0: (Any..Any?), p1: PsiElement?): Boolean defined in com.intellij.psi.filters.NotFilter[JavaMethodDescriptor]

'position' @ [91:42] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[ValueParameterDescriptorImpl]

'position' @ [91:52] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[ValueParameterDescriptorImpl]

'buildFilter' @ [93:28] ==> private final fun buildFilter(position: PsiElement): (KtKeywordToken) -> Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[SimpleFunctionDescriptorImpl]

'position' @ [93:40] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[ValueParameterDescriptorImpl]

'ALL_KEYWORDS' @ [94:30] ==> private final val ALL_KEYWORDS: List<KtKeywordToken> defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[PropertyDescriptorImpl]

'keywordToken' @ [95:27] ==> val keywordToken: KtKeywordToken defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'value' @ [95:40] ==> public final val KtKeywordToken.value: String[MyPropertyDescriptor]

'COMPOUND_KEYWORDS' @ [97:31] ==> private final val COMPOUND_KEYWORDS: Map<KtKeywordToken, KtKeywordToken> defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[PropertyDescriptorImpl]

'keywordToken' @ [97:49] ==> val keywordToken: KtKeywordToken defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'nextKeyword' @ [99:17] ==> val nextKeyword: KtKeywordToken? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'this' @ [100:44] ==> <this> defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete.isSpace[ReceiverParameterDescriptorImpl]

'!in' @ [100:69] ==> public operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'getText' @ [100:78] ==> @NonNls @Contract public abstract fun getText(): (String..String?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'position' @ [102:28] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[ValueParameterDescriptorImpl]

'nextLeaf' @ [102:37] ==> public fun PsiElement.nextLeaf(filter: (PsiElement) -> Boolean): PsiElement? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'!' @ [102:48] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'it' @ [102:50] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete.<anonymous>[ValueParameterDescriptorImpl]

'isSpace' @ [102:53] ==> local final fun PsiElement.isSpace(): Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[SimpleFunctionDescriptorImpl]

'it' @ [102:66] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete.<anonymous>[ValueParameterDescriptorImpl]

'text' @ [102:69] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'text' @ [102:85] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'next' @ [103:21] ==> var next: String? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'next' @ [103:37] ==> var next: String? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'startsWith' @ [103:42] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'next' @ [104:21] ==> var next: String? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'next' @ [104:28] ==> var next: String? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'substring' @ [104:33] ==> @InlineOnly public inline fun String.substring(startIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'if (next != nextKeyword.value)
                    keyword += " " + nextKeyword.value
                else
                    applicableAsCompound = true' @ [106:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'next' @ [106:21] ==> var next: String? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'nextKeyword' @ [106:29] ==> val nextKeyword: KtKeywordToken? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'value' @ [106:41] ==> public final val KtKeywordToken.value: String[MyPropertyDescriptor]

'keyword' @ [107:21] ==> var keyword: String defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'+' @ [107:32] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'nextKeyword' @ [107:38] ==> val nextKeyword: KtKeywordToken? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'value' @ [107:50] ==> public final val KtKeywordToken.value: String[MyPropertyDescriptor]

'applicableAsCompound' @ [109:21] ==> var applicableAsCompound: Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'keywordToken' @ [112:17] ==> val keywordToken: KtKeywordToken defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'DYNAMIC_KEYWORD' @ [112:33] ==> public final val DYNAMIC_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'isJvmModule' @ [112:52] ==> value-parameter isJvmModule: Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[ValueParameterDescriptorImpl]

'!' @ [115:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'keyword' @ [115:18] ==> var keyword: String defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'startsWith' @ [115:26] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'prefix' @ [115:37] ==> value-parameter prefix: String defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[ValueParameterDescriptorImpl]

'keywordToken' @ [115:48] ==> val keywordToken: KtKeywordToken defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'KEYWORDS_TO_IGNORE_PREFIX' @ [115:65] ==> private final val KEYWORDS_TO_IGNORE_PREFIX: TokenSet defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[PropertyDescriptorImpl]

'!' @ [117:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'invoke' @ [117:18] ==> public abstract operator fun invoke(p1: KtKeywordToken): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'keywordToken' @ [117:31] ==> val keywordToken: KtKeywordToken defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'KEYWORD_CONSTRUCTS' @ [119:33] ==> private final val KEYWORD_CONSTRUCTS: Map<KtKeywordToken, String> defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[PropertyDescriptorImpl]

'keywordToken' @ [119:52] ==> val keywordToken: KtKeywordToken defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'if (constructText != null && !applicableAsCompound) {
                val element = createKeywordConstructLookupElement(position.project, keyword, constructText)
                consumer(element)
            }
            else {
                var element = LookupElementBuilder.create(KeywordLookupObject(), keyword).bold()

                val isUseSiteAnnotationTarget = position.prevLeaf()?.node?.elementType == KtTokens.AT

                val insertHandler = when {
                    isUseSiteAnnotationTarget -> UseSiteAnnotationTargetInsertHandler

                    keyword in NO_SPACE_AFTER -> null

                    else -> SpaceAfterInsertHandler
                }

                element = element.withInsertHandler(insertHandler)

                if (isUseSiteAnnotationTarget) {
                    element = element.withPresentableText(keyword + ":")
                }

                consumer(element)
            }' @ [120:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'constructText' @ [120:17] ==> val constructText: String? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'!' @ [120:42] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'applicableAsCompound' @ [120:43] ==> var applicableAsCompound: Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'createKeywordConstructLookupElement' @ [121:31] ==> public fun createKeywordConstructLookupElement(project: Project, keyword: String, fileTextToReformat: String, trimSpacesAroundCaret: Boolean = ...): LookupElement defined in org.jetbrains.kotlin.idea.completion.handlers in file handlerUtils.kt[SimpleFunctionDescriptorImpl]

'position' @ [121:67] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[ValueParameterDescriptorImpl]

'project' @ [121:76] ==> public final val PsiElement.project: Project[MyPropertyDescriptor]

'keyword' @ [121:85] ==> var keyword: String defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'constructText' @ [121:94] ==> val constructText: String? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'invoke' @ [122:17] ==> public abstract operator fun invoke(p1: LookupElement): Unit defined in kotlin.Function1[FunctionInvokeDescriptor]

'element' @ [122:26] ==> val element: LookupElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'create' @ [125:52] ==> public open fun create(@NotNull p0: Any, @NotNull p1: String): (LookupElementBuilder..LookupElementBuilder?) defined in com.intellij.codeInsight.lookup.LookupElementBuilder[JavaMethodDescriptor]

'KeywordLookupObject' @ [125:59] ==> public constructor KeywordLookupObject() defined in org.jetbrains.kotlin.idea.completion.KeywordLookupObject[ClassConstructorDescriptorImpl]

'keyword' @ [125:82] ==> var keyword: String defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'bold' @ [125:91] ==> @Contract public open fun bold(): (LookupElementBuilder..LookupElementBuilder?) defined in com.intellij.codeInsight.lookup.LookupElementBuilder[JavaMethodDescriptor]

'position' @ [127:49] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[ValueParameterDescriptorImpl]

'prevLeaf' @ [127:58] ==> public fun PsiElement.prevLeaf(skipEmptyElements: Boolean = ...): PsiElement? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'node' @ [127:70] ==> public final val PsiElement.node: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'elementType' @ [127:76] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'AT' @ [127:100] ==> public final val AT: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'when {
                    isUseSiteAnnotationTarget -> UseSiteAnnotationTargetInsertHandler

                    keyword in NO_SPACE_AFTER -> null

                    else -> SpaceAfterInsertHandler
                }' @ [129:37] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: InsertHandler<LookupElement>?, entry1: InsertHandler<LookupElement>?, entry2: InsertHandler<LookupElement>?): InsertHandler<LookupElement>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> InsertHandler<LookupElement>?

'isUseSiteAnnotationTarget' @ [130:21] ==> val isUseSiteAnnotationTarget: Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'UseSiteAnnotationTargetInsertHandler' @ [130:50] ==> private object UseSiteAnnotationTargetInsertHandler : InsertHandler<LookupElement> defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[FakeCallableDescriptorForObject]

'keyword' @ [132:21] ==> var keyword: String defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'NO_SPACE_AFTER' @ [132:32] ==> private final val NO_SPACE_AFTER: List<String> defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[PropertyDescriptorImpl]

'SpaceAfterInsertHandler' @ [134:29] ==> private object SpaceAfterInsertHandler : InsertHandler<LookupElement> defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[FakeCallableDescriptorForObject]

'element' @ [137:17] ==> var element: (LookupElementBuilder..LookupElementBuilder?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'element' @ [137:27] ==> var element: (LookupElementBuilder..LookupElementBuilder?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'withInsertHandler' @ [137:35] ==> @Contract public open fun withInsertHandler(@Nullable p0: InsertHandler<(LookupElement..LookupElement?)>?): (LookupElementBuilder..LookupElementBuilder?) defined in com.intellij.codeInsight.lookup.LookupElementBuilder[JavaMethodDescriptor]

'insertHandler' @ [137:53] ==> val insertHandler: InsertHandler<LookupElement>? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'isUseSiteAnnotationTarget' @ [139:21] ==> val isUseSiteAnnotationTarget: Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'element' @ [140:21] ==> var element: (LookupElementBuilder..LookupElementBuilder?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'element' @ [140:31] ==> var element: (LookupElementBuilder..LookupElementBuilder?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'withPresentableText' @ [140:39] ==> @Contract public open fun withPresentableText(@NotNull p0: String): (LookupElementBuilder..LookupElementBuilder?) defined in com.intellij.codeInsight.lookup.LookupElementBuilder[JavaMethodDescriptor]

'keyword' @ [140:59] ==> var keyword: String defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'invoke' @ [143:17] ==> public abstract operator fun invoke(p1: LookupElement): Unit defined in kotlin.Function1[FunctionInvokeDescriptor]

'element' @ [143:26] ==> var element: (LookupElementBuilder..LookupElementBuilder?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.complete[LocalVariableDescriptor]

'WithTailInsertHandler' @ [150:13] ==> public constructor WithTailInsertHandler(tailText: String, spaceBefore: Boolean, spaceAfter: Boolean, overwriteText: Boolean = ...) defined in org.jetbrains.kotlin.idea.completion.handlers.WithTailInsertHandler[ClassConstructorDescriptorImpl]

'postHandleInsert' @ [150:81] ==> public final fun postHandleInsert(context: InsertionContext, item: LookupElement): Unit defined in org.jetbrains.kotlin.idea.completion.handlers.WithTailInsertHandler[SimpleFunctionDescriptorImpl]

'context' @ [150:98] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.UseSiteAnnotationTargetInsertHandler.handleInsert[ValueParameterDescriptorImpl]

'item' @ [150:107] ==> value-parameter item: LookupElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.UseSiteAnnotationTargetInsertHandler.handleInsert[ValueParameterDescriptorImpl]

'WithTailInsertHandler' @ [156:13] ==> public companion object defined in org.jetbrains.kotlin.idea.completion.handlers.WithTailInsertHandler[FakeCallableDescriptorForObject]

'SPACE' @ [156:35] ==> public final val SPACE: WithTailInsertHandler defined in org.jetbrains.kotlin.idea.completion.handlers.WithTailInsertHandler.Companion[PropertyDescriptorImpl]

'postHandleInsert' @ [156:41] ==> public final fun postHandleInsert(context: InsertionContext, item: LookupElement): Unit defined in org.jetbrains.kotlin.idea.completion.handlers.WithTailInsertHandler[SimpleFunctionDescriptorImpl]

'context' @ [156:58] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.SpaceAfterInsertHandler.handleInsert[ValueParameterDescriptorImpl]

'item' @ [156:67] ==> value-parameter item: LookupElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.SpaceAfterInsertHandler.handleInsert[ValueParameterDescriptorImpl]

'NotFilter' @ [160:34] ==> public constructor NotFilter(p0: (ElementFilter..ElementFilter?)) defined in com.intellij.psi.filters.NotFilter[JavaClassConstructorDescriptor]

'OrFilter' @ [160:44] ==> public constructor OrFilter(vararg p0: (ElementFilter..ElementFilter?)) defined in com.intellij.psi.filters.OrFilter[JavaClassConstructorDescriptor]

'CommentFilter' @ [161:13] ==> public constructor CommentFilter() defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.CommentFilter[ClassConstructorDescriptorImpl]

'ParentFilter' @ [162:13] ==> public constructor ParentFilter(filter: ElementFilter) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.ParentFilter[ClassConstructorDescriptorImpl]

'ClassFilter' @ [162:26] ==> public constructor ClassFilter(p0: raw (Class<(Any..Any?)>..Class<*>?)) defined in com.intellij.psi.filters.ClassFilter[JavaClassConstructorDescriptor]

'KtLiteralStringTemplateEntry' @ [162:38] ==> public constructor KtLiteralStringTemplateEntry(@NotNull p0: ASTNode) defined in org.jetbrains.kotlin.psi.KtLiteralStringTemplateEntry[JavaClassConstructorDescriptor]

'java' @ [162:74] ==> public val <T> KClass<KtLiteralStringTemplateEntry>.java: Class<KtLiteralStringTemplateEntry> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtLiteralStringTemplateEntry

'ParentFilter' @ [163:13] ==> public constructor ParentFilter(filter: ElementFilter) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.ParentFilter[ClassConstructorDescriptorImpl]

'ClassFilter' @ [163:26] ==> public constructor ClassFilter(p0: raw (Class<(Any..Any?)>..Class<*>?)) defined in com.intellij.psi.filters.ClassFilter[JavaClassConstructorDescriptor]

'KtConstantExpression' @ [163:38] ==> public constructor KtConstantExpression(@NotNull p0: ASTNode) defined in org.jetbrains.kotlin.psi.KtConstantExpression[JavaClassConstructorDescriptor]

'java' @ [163:66] ==> public val <T> KClass<KtConstantExpression>.java: Class<KtConstantExpression> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtConstantExpression

'FileFilter' @ [164:13] ==> public constructor FileFilter(filter: ElementFilter) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.FileFilter[ClassConstructorDescriptorImpl]

'ClassFilter' @ [164:24] ==> public constructor ClassFilter(p0: raw (Class<(Any..Any?)>..Class<*>?)) defined in com.intellij.psi.filters.ClassFilter[JavaClassConstructorDescriptor]

'KtTypeCodeFragment' @ [164:36] ==> public constructor KtTypeCodeFragment(project: Project, name: String, text: CharSequence, context: PsiElement?) defined in org.jetbrains.kotlin.psi.KtTypeCodeFragment[DeserializedClassConstructorDescriptor]

'java' @ [164:62] ==> public val <T> KClass<KtTypeCodeFragment>.java: Class<KtTypeCodeFragment> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtTypeCodeFragment

'LeftNeighbour' @ [165:13] ==> public constructor LeftNeighbour(p0: (ElementFilter..ElementFilter?)) defined in com.intellij.psi.filters.position.LeftNeighbour[JavaClassConstructorDescriptor]

'TextFilter' @ [165:27] ==> public constructor TextFilter(@NonNls p0: (String..String?)) defined in com.intellij.psi.filters.TextFilter[JavaClassConstructorDescriptor]

'LeftNeighbour' @ [166:13] ==> public constructor LeftNeighbour(p0: (ElementFilter..ElementFilter?)) defined in com.intellij.psi.filters.position.LeftNeighbour[JavaClassConstructorDescriptor]

'TextFilter' @ [166:27] ==> public constructor TextFilter(@NonNls p0: (String..String?)) defined in com.intellij.psi.filters.TextFilter[JavaClassConstructorDescriptor]

'element' @ [171:20] ==> value-parameter element: Any? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.CommentFilter.isAcceptable[ValueParameterDescriptorImpl]

'isInComment' @ [171:56] ==> public open fun isInComment(p0: (PsiElement..PsiElement?)): Boolean defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'element' @ [171:68] ==> value-parameter element: Any? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.CommentFilter.isAcceptable[ValueParameterDescriptorImpl]

'PositionElementFilter' @ [177:58] ==> public constructor PositionElementFilter() defined in com.intellij.psi.filters.position.PositionElementFilter[JavaClassConstructorDescriptor]

'setFilter' @ [179:13] ==> public open fun setFilter(p0: (ElementFilter..ElementFilter?)): Unit defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.ParentFilter[JavaMethodDescriptor]

'filter' @ [179:23] ==> value-parameter filter: ElementFilter defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.ParentFilter.<init>[ValueParameterDescriptorImpl]

'element' @ [183:27] ==> value-parameter element: Any? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.ParentFilter.isAcceptable[ValueParameterDescriptorImpl]

'parent' @ [183:52] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [184:20] ==> val parent: PsiElement? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.ParentFilter.isAcceptable[LocalVariableDescriptor]

'filter' @ [184:39] ==> public final var KeywordCompletion.ParentFilter.filter: (ElementFilter..ElementFilter?)[MyPropertyDescriptor]

'isAcceptable' @ [184:47] ==> public abstract fun isAcceptable(p0: (Any..Any?), @Nullable p1: PsiElement?): Boolean defined in com.intellij.psi.filters.ElementFilter[JavaMethodDescriptor]

'parent' @ [184:60] ==> val parent: PsiElement? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.ParentFilter.isAcceptable[LocalVariableDescriptor]

'context' @ [184:68] ==> value-parameter context: PsiElement? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.ParentFilter.isAcceptable[ValueParameterDescriptorImpl]

'PositionElementFilter' @ [188:56] ==> public constructor PositionElementFilter() defined in com.intellij.psi.filters.position.PositionElementFilter[JavaClassConstructorDescriptor]

'setFilter' @ [190:13] ==> public open fun setFilter(p0: (ElementFilter..ElementFilter?)): Unit defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.FileFilter[JavaMethodDescriptor]

'filter' @ [190:23] ==> value-parameter filter: ElementFilter defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.FileFilter.<init>[ValueParameterDescriptorImpl]

'element' @ [194:25] ==> value-parameter element: Any? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.FileFilter.isAcceptable[ValueParameterDescriptorImpl]

'containingFile' @ [194:50] ==> public final val PsiElement.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'file' @ [195:20] ==> val file: PsiFile? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.FileFilter.isAcceptable[LocalVariableDescriptor]

'filter' @ [195:37] ==> public final var KeywordCompletion.FileFilter.filter: (ElementFilter..ElementFilter?)[MyPropertyDescriptor]

'isAcceptable' @ [195:45] ==> public abstract fun isAcceptable(p0: (Any..Any?), @Nullable p1: PsiElement?): Boolean defined in com.intellij.psi.filters.ElementFilter[JavaMethodDescriptor]

'file' @ [195:58] ==> val file: PsiFile? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.FileFilter.isAcceptable[LocalVariableDescriptor]

'context' @ [195:64] ==> value-parameter context: PsiElement? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.FileFilter.isAcceptable[ValueParameterDescriptorImpl]

'position' @ [200:22] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[ValueParameterDescriptorImpl]

'parent' @ [200:31] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'position' @ [201:26] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[ValueParameterDescriptorImpl]

'parent' @ [202:16] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'when (parent) {
                is KtBlockExpression -> {
                    var prefixText = "fun foo() { "
                    if (prevParent is KtExpression) {
                        // check that we are right after a try-expression without finally-block or after if-expression without else
                        val prevLeaf = prevParent.prevLeaf { it !is PsiWhiteSpace && it !is PsiComment && it !is PsiErrorElement }
                        if (prevLeaf != null) {
                            val isAfterThen = prevLeaf.goUpWhileIsLastChild().any { it.node.elementType == KtNodeTypes.THEN }

                            var isAfterTry = false
                            var isAfterCatch = false
                            if (prevLeaf.node.elementType == KtTokens.RBRACE) {
                                val blockParent = (prevLeaf.parent as? KtBlockExpression)?.parent
                                when (blockParent) {
                                    is KtTryExpression -> isAfterTry = true
                                    is KtCatchClause -> { isAfterTry = true; isAfterCatch = true }
                                }
                            }

                            if (isAfterThen) {
                                if (isAfterTry) {
                                    prefixText += "if (a)\n"
                                }
                                else {
                                    prefixText += "if (a) {}\n"
                                }
                            }
                            if (isAfterTry) {
                                prefixText += "try {}\n"
                            }
                            if (isAfterCatch) {
                                prefixText += "catch (e: E) {}\n"
                            }
                        }

                        return buildFilterWithContext(prefixText, prevParent, position)
                    }
                    else {
                        val lastExpression = prevParent
                                .siblings(forward = false, withItself = false)
                                .firstIsInstanceOrNull<KtExpression>()
                        if (lastExpression != null) {
                            val contextAfterExpression = lastExpression
                                    .siblings(forward = true, withItself = false)
                                    .takeWhile { it != prevParent }
                                    .joinToString { it.text }
                            return buildFilterWithContext(prefixText + "x" + contextAfterExpression, prevParent, position)
                        }
                    }
                }

                is KtDeclarationWithInitializer -> {
                    val initializer = parent.initializer
                    if (prevParent == initializer) {
                        return buildFilterWithContext("val v = ", initializer, position)
                    }
                }

                is KtParameter -> {
                    val default = parent.defaultValue
                    if (prevParent == default) {
                        return buildFilterWithContext("val v = ", default, position)
                    }
                }

                is KtDeclaration -> {
                    val scope = parent.parent
                    when (scope) {
                        is KtClassOrObject -> {
                            return if (parent is KtPrimaryConstructor) {
                                buildFilterWithReducedContext("class X ", parent, position)
                            }
                            else {
                                buildFilterWithReducedContext("class X { ", parent, position)
                            }
                        }

                        is KtFile -> return buildFilterWithReducedContext("", parent, position)
                    }
                }
            }' @ [203:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit, entry3: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'parent' @ [203:19] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'if (prevParent is KtExpression) {
                        // check that we are right after a try-expression without finally-block or after if-expression without else
                        val prevLeaf = prevParent.prevLeaf { it !is PsiWhiteSpace && it !is PsiComment && it !is PsiErrorElement }
                        if (prevLeaf != null) {
                            val isAfterThen = prevLeaf.goUpWhileIsLastChild().any { it.node.elementType == KtNodeTypes.THEN }

                            var isAfterTry = false
                            var isAfterCatch = false
                            if (prevLeaf.node.elementType == KtTokens.RBRACE) {
                                val blockParent = (prevLeaf.parent as? KtBlockExpression)?.parent
                                when (blockParent) {
                                    is KtTryExpression -> isAfterTry = true
                                    is KtCatchClause -> { isAfterTry = true; isAfterCatch = true }
                                }
                            }

                            if (isAfterThen) {
                                if (isAfterTry) {
                                    prefixText += "if (a)\n"
                                }
                                else {
                                    prefixText += "if (a) {}\n"
                                }
                            }
                            if (isAfterTry) {
                                prefixText += "try {}\n"
                            }
                            if (isAfterCatch) {
                                prefixText += "catch (e: E) {}\n"
                            }
                        }

                        return buildFilterWithContext(prefixText, prevParent, position)
                    }
                    else {
                        val lastExpression = prevParent
                                .siblings(forward = false, withItself = false)
                                .firstIsInstanceOrNull<KtExpression>()
                        if (lastExpression != null) {
                            val contextAfterExpression = lastExpression
                                    .siblings(forward = true, withItself = false)
                                    .takeWhile { it != prevParent }
                                    .joinToString { it.text }
                            return buildFilterWithContext(prefixText + "x" + contextAfterExpression, prevParent, position)
                        }
                    }' @ [206:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'prevParent' @ [206:25] ==> var prevParent: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'prevParent' @ [208:40] ==> var prevParent: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'prevLeaf' @ [208:51] ==> public fun PsiElement.prevLeaf(filter: (PsiElement) -> Boolean): PsiElement? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'it' @ [208:62] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [208:86] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [208:107] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter.<anonymous>[ValueParameterDescriptorImpl]

'prevLeaf' @ [209:29] ==> val prevLeaf: PsiElement? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'prevLeaf' @ [210:47] ==> val prevLeaf: PsiElement? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'goUpWhileIsLastChild' @ [210:56] ==> private final fun PsiElement.goUpWhileIsLastChild(): Sequence<PsiElement> defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[SimpleFunctionDescriptorImpl]

'any' @ [210:79] ==> public inline fun <T> Sequence<PsiElement>.any(predicate: (PsiElement) -> Boolean): Boolean defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'it' @ [210:85] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter.<anonymous>[ValueParameterDescriptorImpl]

'node' @ [210:88] ==> public final val PsiElement.node: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'elementType' @ [210:93] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'THEN' @ [210:120] ==> public final val THEN: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'prevLeaf' @ [214:33] ==> val prevLeaf: PsiElement? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'node' @ [214:42] ==> public final val PsiElement.node: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'elementType' @ [214:47] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'RBRACE' @ [214:71] ==> public final val RBRACE: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'prevLeaf' @ [215:52] ==> val prevLeaf: PsiElement? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'parent' @ [215:61] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [215:92] ==> public final val KtBlockExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'when (blockParent) {
                                    is KtTryExpression -> isAfterTry = true
                                    is KtCatchClause -> { isAfterTry = true; isAfterCatch = true }
                                }' @ [216:33] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'blockParent' @ [216:39] ==> val blockParent: PsiElement? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'isAfterTry' @ [217:59] ==> var isAfterTry: Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'isAfterTry' @ [218:59] ==> var isAfterTry: Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'isAfterCatch' @ [218:78] ==> var isAfterCatch: Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'isAfterThen' @ [222:33] ==> val isAfterThen: Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'if (isAfterTry) {
                                    prefixText += "if (a)\n"
                                }
                                else {
                                    prefixText += "if (a) {}\n"
                                }' @ [223:33] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'isAfterTry' @ [223:37] ==> var isAfterTry: Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'prefixText' @ [224:37] ==> var prefixText: String defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'prefixText' @ [227:37] ==> var prefixText: String defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'isAfterTry' @ [230:33] ==> var isAfterTry: Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'prefixText' @ [231:33] ==> var prefixText: String defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'isAfterCatch' @ [233:33] ==> var isAfterCatch: Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'prefixText' @ [234:33] ==> var prefixText: String defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'buildFilterWithContext' @ [238:32] ==> private final fun buildFilterWithContext(prefixText: String, contextElement: PsiElement, position: PsiElement): (KtKeywordToken) -> Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[SimpleFunctionDescriptorImpl]

'prefixText' @ [238:55] ==> var prefixText: String defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'prevParent' @ [238:67] ==> var prevParent: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'position' @ [238:79] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[ValueParameterDescriptorImpl]

'prevParent' @ [241:46] ==> var prevParent: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'siblings' @ [242:34] ==> public fun PsiElement.siblings(forward: Boolean = ..., withItself: Boolean = ...): Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'firstIsInstanceOrNull' @ [243:34] ==> public inline fun <reified T : Any> Sequence<*>.firstIsInstanceOrNull(): KtExpression? defined in org.jetbrains.kotlin.utils.addToStdlib[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : Any> -> KtExpression

'lastExpression' @ [244:29] ==> val lastExpression: KtExpression? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'lastExpression' @ [245:58] ==> val lastExpression: KtExpression? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'siblings' @ [246:38] ==> public fun PsiElement.siblings(forward: Boolean = ..., withItself: Boolean = ...): Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'takeWhile' @ [247:38] ==> public fun <T> Sequence<PsiElement>.takeWhile(predicate: (PsiElement) -> Boolean): Sequence<PsiElement> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'it' @ [247:50] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter.<anonymous>[ValueParameterDescriptorImpl]

'prevParent' @ [247:56] ==> var prevParent: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'joinToString' @ [248:38] ==> public fun <T> Sequence<PsiElement>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((PsiElement) -> CharSequence)? = ...): String defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'it' @ [248:53] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter.<anonymous>[ValueParameterDescriptorImpl]

'text' @ [248:56] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'buildFilterWithContext' @ [249:36] ==> private final fun buildFilterWithContext(prefixText: String, contextElement: PsiElement, position: PsiElement): (KtKeywordToken) -> Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[SimpleFunctionDescriptorImpl]

'prefixText' @ [249:59] ==> var prefixText: String defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'contextAfterExpression' @ [249:78] ==> val contextAfterExpression: String defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'prevParent' @ [249:102] ==> var prevParent: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'position' @ [249:114] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[ValueParameterDescriptorImpl]

'parent' @ [255:39] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'initializer' @ [255:46] ==> public final val KtDeclarationWithInitializer.initializer: KtExpression?[MyPropertyDescriptor]

'prevParent' @ [256:25] ==> var prevParent: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'initializer' @ [256:39] ==> val initializer: KtExpression? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'buildFilterWithContext' @ [257:32] ==> private final fun buildFilterWithContext(prefixText: String, contextElement: PsiElement, position: PsiElement): (KtKeywordToken) -> Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[SimpleFunctionDescriptorImpl]

'initializer' @ [257:67] ==> val initializer: KtExpression? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'position' @ [257:80] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[ValueParameterDescriptorImpl]

'parent' @ [262:35] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'defaultValue' @ [262:42] ==> public final val KtParameter.defaultValue: KtExpression?[MyPropertyDescriptor]

'prevParent' @ [263:25] ==> var prevParent: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'default' @ [263:39] ==> val default: KtExpression? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'buildFilterWithContext' @ [264:32] ==> private final fun buildFilterWithContext(prefixText: String, contextElement: PsiElement, position: PsiElement): (KtKeywordToken) -> Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[SimpleFunctionDescriptorImpl]

'default' @ [264:67] ==> val default: KtExpression? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'position' @ [264:76] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[ValueParameterDescriptorImpl]

'parent' @ [269:33] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'parent' @ [269:40] ==> public final val KtDeclaration.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'when (scope) {
                        is KtClassOrObject -> {
                            return if (parent is KtPrimaryConstructor) {
                                buildFilterWithReducedContext("class X ", parent, position)
                            }
                            else {
                                buildFilterWithReducedContext("class X { ", parent, position)
                            }
                        }

                        is KtFile -> return buildFilterWithReducedContext("", parent, position)
                    }' @ [270:21] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Nothing, entry1: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Nothing

'scope' @ [270:27] ==> val scope: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'if (parent is KtPrimaryConstructor) {
                                buildFilterWithReducedContext("class X ", parent, position)
                            }
                            else {
                                buildFilterWithReducedContext("class X { ", parent, position)
                            }' @ [272:36] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (KtKeywordToken) -> Boolean, elseBranch: (KtKeywordToken) -> Boolean): (KtKeywordToken) -> Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Function1<KtKeywordToken, Boolean>

'parent' @ [272:40] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'buildFilterWithReducedContext' @ [273:33] ==> private final fun buildFilterWithReducedContext(prefixText: String, contextElement: PsiElement?, position: PsiElement): (KtKeywordToken) -> Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[SimpleFunctionDescriptorImpl]

'parent' @ [273:75] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'position' @ [273:83] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[ValueParameterDescriptorImpl]

'buildFilterWithReducedContext' @ [276:33] ==> private final fun buildFilterWithReducedContext(prefixText: String, contextElement: PsiElement?, position: PsiElement): (KtKeywordToken) -> Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[SimpleFunctionDescriptorImpl]

'parent' @ [276:77] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'position' @ [276:85] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[ValueParameterDescriptorImpl]

'buildFilterWithReducedContext' @ [280:45] ==> private final fun buildFilterWithReducedContext(prefixText: String, contextElement: PsiElement?, position: PsiElement): (KtKeywordToken) -> Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[SimpleFunctionDescriptorImpl]

'parent' @ [280:79] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'position' @ [280:87] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[ValueParameterDescriptorImpl]

'prevParent' @ [286:13] ==> var prevParent: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'parent' @ [286:26] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'parent' @ [287:13] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'parent' @ [287:22] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[LocalVariableDescriptor]

'parent' @ [287:29] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'buildFilterWithReducedContext' @ [290:16] ==> private final fun buildFilterWithReducedContext(prefixText: String, contextElement: PsiElement?, position: PsiElement): (KtKeywordToken) -> Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[SimpleFunctionDescriptorImpl]

'position' @ [290:56] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilter[ValueParameterDescriptorImpl]

'when (keyword) {
        SUSPEND_KEYWORD -> sequenceOf("suspend () -> Unit>", "suspend X")
        else -> {
            if (prefixText.endsWith("@"))
                sequenceOf(keyword.value + ":X Y.Z")
            else
                sequenceOf(keyword.value + " X")
        }
    }' @ [293:109] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Sequence<String>, entry1: Sequence<String>): Sequence<String>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Sequence<String>

'keyword' @ [293:115] ==> value-parameter keyword: KtKeywordToken defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.computeKeywordApplications[ValueParameterDescriptorImpl]

'SUSPEND_KEYWORD' @ [294:9] ==> public final val SUSPEND_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'sequenceOf' @ [294:28] ==> public fun <T> sequenceOf(vararg elements: String): Sequence<String> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'if (prefixText.endsWith("@"))
                sequenceOf(keyword.value + ":X Y.Z")
            else
                sequenceOf(keyword.value + " X")' @ [296:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Sequence<String>, elseBranch: Sequence<String>): Sequence<String>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Sequence<String>

'prefixText' @ [296:17] ==> value-parameter prefixText: String defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.computeKeywordApplications[ValueParameterDescriptorImpl]

'endsWith' @ [296:28] ==> public fun String.endsWith(suffix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'sequenceOf' @ [297:17] ==> public fun <T> sequenceOf(vararg elements: String): Sequence<String> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'keyword' @ [297:28] ==> value-parameter keyword: KtKeywordToken defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.computeKeywordApplications[ValueParameterDescriptorImpl]

'value' @ [297:36] ==> public final val KtKeywordToken.value: String[MyPropertyDescriptor]

'sequenceOf' @ [299:17] ==> public fun <T> sequenceOf(vararg elements: String): Sequence<String> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'keyword' @ [299:28] ==> value-parameter keyword: KtKeywordToken defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.computeKeywordApplications[ValueParameterDescriptorImpl]

'value' @ [299:36] ==> public final val KtKeywordToken.value: String[MyPropertyDescriptor]

'position' @ [306:22] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterWithContext[ValueParameterDescriptorImpl]

'getStartOffsetInAncestor' @ [306:31] ==> private final fun PsiElement.getStartOffsetInAncestor(ancestor: PsiElement): Int defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[SimpleFunctionDescriptorImpl]

'contextElement' @ [306:56] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterWithContext[ValueParameterDescriptorImpl]

'contextElement' @ [307:32] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterWithContext[ValueParameterDescriptorImpl]

'text' @ [307:47] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'substring' @ [307:54] ==> @InlineOnly public inline fun String.substring(startIndex: Int, endIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'offset' @ [307:67] ==> val offset: Int defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterWithContext[LocalVariableDescriptor]

'buildFilterByText' @ [308:16] ==> private final fun buildFilterByText(prefixText: String, position: PsiElement): (KtKeywordToken) -> Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[SimpleFunctionDescriptorImpl]

'prefixText' @ [308:34] ==> value-parameter prefixText: String defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterWithContext[ValueParameterDescriptorImpl]

'truncatedContext' @ [308:47] ==> val truncatedContext: String defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterWithContext[LocalVariableDescriptor]

'position' @ [308:65] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterWithContext[ValueParameterDescriptorImpl]

'StringBuilder' @ [314:23] ==> public final fun <init>(): StringBuilder /* = StringBuilder */ defined in kotlin.text.StringBuilder[TypeAliasConstructorDescriptorImpl]

'buildReducedContextBefore' @ [315:9] ==> private final fun buildReducedContextBefore(builder: StringBuilder /* = StringBuilder */, position: PsiElement, scope: PsiElement?): Unit defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[SimpleFunctionDescriptorImpl]

'builder' @ [315:35] ==> val builder: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterWithReducedContext[LocalVariableDescriptor]

'position' @ [315:44] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterWithReducedContext[ValueParameterDescriptorImpl]

'contextElement' @ [315:54] ==> value-parameter contextElement: PsiElement? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterWithReducedContext[ValueParameterDescriptorImpl]

'buildFilterByText' @ [316:16] ==> private final fun buildFilterByText(prefixText: String, position: PsiElement): (KtKeywordToken) -> Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[SimpleFunctionDescriptorImpl]

'prefixText' @ [316:34] ==> value-parameter prefixText: String defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterWithReducedContext[ValueParameterDescriptorImpl]

'builder' @ [316:47] ==> val builder: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterWithReducedContext[LocalVariableDescriptor]

'toString' @ [316:55] ==> public open fun toString(): String defined in java.lang.StringBuilder[JavaMethodDescriptor]

'position' @ [316:67] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterWithReducedContext[ValueParameterDescriptorImpl]

'computeKeywordApplications' @ [321:16] ==> private final fun computeKeywordApplications(prefixText: String, keyword: KtKeywordToken): Sequence<String> defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[SimpleFunctionDescriptorImpl]

'prefixText' @ [321:43] ==> value-parameter prefixText: String defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilesWithKeywordApplication[ValueParameterDescriptorImpl]

'keywordTokenType' @ [321:55] ==> value-parameter keywordTokenType: KtKeywordToken defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilesWithKeywordApplication[ValueParameterDescriptorImpl]

'map' @ [322:18] ==> public fun <T, R> Sequence<String>.map(transform: (String) -> KtFile): Sequence<KtFile> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String
    <R> -> KtFile

'psiFactory' @ [322:39] ==> value-parameter psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilesWithKeywordApplication[ValueParameterDescriptorImpl]

'createFile' @ [322:50] ==> public final fun createFile(text: String): KtFile defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'prefixText' @ [322:61] ==> value-parameter prefixText: String defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilesWithKeywordApplication[ValueParameterDescriptorImpl]

'application' @ [322:74] ==> value-parameter application: String defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilesWithKeywordApplication.<anonymous>[ValueParameterDescriptorImpl]

'KtPsiFactory' @ [327:26] ==> @JvmOverloads public constructor KtPsiFactory(project: Project, markGenerated: Boolean = ...) defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedClassConstructorDescriptor]

'position' @ [327:39] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText[ValueParameterDescriptorImpl]

'project' @ [327:48] ==> public final val PsiElement.project: Project[MyPropertyDescriptor]

'file' @ [329:29] ==> value-parameter file: KtFile defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[ValueParameterDescriptorImpl]

'findElementAt' @ [329:34] ==> public open fun findElementAt(p0: Int): PsiElement? defined in org.jetbrains.kotlin.psi.KtFile[JavaMethodDescriptor]

'prefixText' @ [329:48] ==> value-parameter prefixText: String defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText[ValueParameterDescriptorImpl]

'length' @ [329:59] ==> public open val length: Int defined in kotlin.String[DeserializedPropertyDescriptor]

'when {
                !elementAt.node!!.elementType.matchesKeyword(keywordTokenType) -> return false

                elementAt.getNonStrictParentOfType<PsiErrorElement>() != null -> return false

                isErrorElementBefore(elementAt) -> return false

                !isSupportedAtLanguageLevel(keywordTokenType, position) -> return false

                keywordTokenType !is KtModifierKeywordToken -> return true

                else -> {
                    if (elementAt.parent !is KtModifierList) return true
                    val container = elementAt.parent.parent
                    val possibleTargets = when (container) {
                        is KtParameter -> {
                            if (container.ownerFunction is KtPrimaryConstructor)
                                listOf(VALUE_PARAMETER, MEMBER_PROPERTY)
                            else
                                listOf(VALUE_PARAMETER)
                        }

                        is KtTypeParameter -> listOf(TYPE_PARAMETER)

                        is KtEnumEntry -> listOf(ENUM_ENTRY)

                        is KtClassBody -> listOf(CLASS_ONLY, INTERFACE, OBJECT, ENUM_CLASS, ANNOTATION_CLASS, MEMBER_FUNCTION, MEMBER_PROPERTY, FUNCTION, PROPERTY)

                        is KtFile -> listOf(CLASS_ONLY, INTERFACE, OBJECT, ENUM_CLASS, ANNOTATION_CLASS, TOP_LEVEL_FUNCTION, TOP_LEVEL_PROPERTY, FUNCTION, PROPERTY)

                        else -> null
                    }
                    val modifierTargets = ModifierCheckerCore.possibleTargetMap[keywordTokenType]
                    if (modifierTargets != null && possibleTargets != null && possibleTargets.none { it in modifierTargets }) return false

                    val ownerDeclaration = container?.getParentOfType<KtDeclaration>(strict = true)
                    val parentTarget = when (ownerDeclaration) {
                        null -> KotlinTarget.FILE

                        is KtClass -> {
                            when {
                                ownerDeclaration.isInterface() -> KotlinTarget.INTERFACE
                                ownerDeclaration.isEnum() -> KotlinTarget.ENUM_CLASS
                                ownerDeclaration.isAnnotation() -> KotlinTarget.ANNOTATION_CLASS
                                else -> KotlinTarget.CLASS_ONLY
                            }
                        }

                        is KtObjectDeclaration -> if (ownerDeclaration.isObjectLiteral()) KotlinTarget.OBJECT_LITERAL else KotlinTarget.OBJECT

                        else -> return true
                    }

                    val modifierParents = ModifierCheckerCore.possibleParentTargetMap[keywordTokenType]
                    if (modifierParents != null && parentTarget !in modifierParents) return false

                    val deprecatedParents = ModifierCheckerCore.deprecatedParentTargetMap[keywordTokenType]
                    if (deprecatedParents != null && parentTarget in deprecatedParents) return false

                    return true
                }
            }' @ [331:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Nothing, entry1: Nothing, entry2: Nothing, entry3: Nothing, entry4: Nothing, entry5: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Nothing

'!' @ [332:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'elementAt' @ [332:18] ==> val elementAt: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[LocalVariableDescriptor]

'node' @ [332:28] ==> public final val PsiElement.node: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'elementType' @ [332:35] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'matchesKeyword' @ [332:47] ==> private final fun IElementType.matchesKeyword(keywordType: KtKeywordToken): Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[SimpleFunctionDescriptorImpl]

'keywordTokenType' @ [332:62] ==> value-parameter keywordTokenType: KtKeywordToken defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[ValueParameterDescriptorImpl]

'elementAt' @ [334:17] ==> val elementAt: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[LocalVariableDescriptor]

'getNonStrictParentOfType' @ [334:27] ==> public inline fun <reified T : PsiElement> PsiElement.getNonStrictParentOfType(): PsiErrorElement? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> PsiErrorElement

'isErrorElementBefore' @ [336:17] ==> private final fun isErrorElementBefore(token: PsiElement): Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[SimpleFunctionDescriptorImpl]

'elementAt' @ [336:38] ==> val elementAt: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[LocalVariableDescriptor]

'!' @ [338:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isSupportedAtLanguageLevel' @ [338:18] ==> private final fun isSupportedAtLanguageLevel(keyword: KtKeywordToken, position: PsiElement): Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[SimpleFunctionDescriptorImpl]

'keywordTokenType' @ [338:45] ==> value-parameter keywordTokenType: KtKeywordToken defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[ValueParameterDescriptorImpl]

'position' @ [338:63] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText[ValueParameterDescriptorImpl]

'keywordTokenType' @ [340:17] ==> value-parameter keywordTokenType: KtKeywordToken defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[ValueParameterDescriptorImpl]

'elementAt' @ [343:25] ==> val elementAt: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[LocalVariableDescriptor]

'parent' @ [343:35] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'elementAt' @ [344:37] ==> val elementAt: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[LocalVariableDescriptor]

'parent' @ [344:47] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [344:54] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'when (container) {
                        is KtParameter -> {
                            if (container.ownerFunction is KtPrimaryConstructor)
                                listOf(VALUE_PARAMETER, MEMBER_PROPERTY)
                            else
                                listOf(VALUE_PARAMETER)
                        }

                        is KtTypeParameter -> listOf(TYPE_PARAMETER)

                        is KtEnumEntry -> listOf(ENUM_ENTRY)

                        is KtClassBody -> listOf(CLASS_ONLY, INTERFACE, OBJECT, ENUM_CLASS, ANNOTATION_CLASS, MEMBER_FUNCTION, MEMBER_PROPERTY, FUNCTION, PROPERTY)

                        is KtFile -> listOf(CLASS_ONLY, INTERFACE, OBJECT, ENUM_CLASS, ANNOTATION_CLASS, TOP_LEVEL_FUNCTION, TOP_LEVEL_PROPERTY, FUNCTION, PROPERTY)

                        else -> null
                    }' @ [345:43] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: List<KotlinTarget>?, entry1: List<KotlinTarget>?, entry2: List<KotlinTarget>?, entry3: List<KotlinTarget>?, entry4: List<KotlinTarget>?, entry5: List<KotlinTarget>?): List<KotlinTarget>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> List<KotlinTarget>?

'container' @ [345:49] ==> val container: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[LocalVariableDescriptor]

'if (container.ownerFunction is KtPrimaryConstructor)
                                listOf(VALUE_PARAMETER, MEMBER_PROPERTY)
                            else
                                listOf(VALUE_PARAMETER)' @ [347:29] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<KotlinTarget>, elseBranch: List<KotlinTarget>): List<KotlinTarget>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<KotlinTarget>

'container' @ [347:33] ==> val container: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[LocalVariableDescriptor]

'ownerFunction' @ [347:43] ==> public final val KtParameter.ownerFunction: KtDeclarationWithBody?[MyPropertyDescriptor]

'listOf' @ [348:33] ==> public fun <T> listOf(vararg elements: KotlinTarget): List<KotlinTarget> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'VALUE_PARAMETER' @ [348:40] ==> enum entry VALUE_PARAMETER defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'MEMBER_PROPERTY' @ [348:57] ==> enum entry MEMBER_PROPERTY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'listOf' @ [350:33] ==> public fun <T> listOf(element: KotlinTarget): List<KotlinTarget> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'VALUE_PARAMETER' @ [350:40] ==> enum entry VALUE_PARAMETER defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'listOf' @ [353:47] ==> public fun <T> listOf(element: KotlinTarget): List<KotlinTarget> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'TYPE_PARAMETER' @ [353:54] ==> enum entry TYPE_PARAMETER defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'listOf' @ [355:43] ==> public fun <T> listOf(element: KotlinTarget): List<KotlinTarget> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'ENUM_ENTRY' @ [355:50] ==> enum entry ENUM_ENTRY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'listOf' @ [357:43] ==> public fun <T> listOf(vararg elements: KotlinTarget): List<KotlinTarget> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'CLASS_ONLY' @ [357:50] ==> enum entry CLASS_ONLY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'INTERFACE' @ [357:62] ==> enum entry INTERFACE defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'OBJECT' @ [357:73] ==> enum entry OBJECT defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ENUM_CLASS' @ [357:81] ==> enum entry ENUM_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ANNOTATION_CLASS' @ [357:93] ==> enum entry ANNOTATION_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'MEMBER_FUNCTION' @ [357:111] ==> enum entry MEMBER_FUNCTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'MEMBER_PROPERTY' @ [357:128] ==> enum entry MEMBER_PROPERTY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'FUNCTION' @ [357:145] ==> enum entry FUNCTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'PROPERTY' @ [357:155] ==> enum entry PROPERTY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'listOf' @ [359:38] ==> public fun <T> listOf(vararg elements: KotlinTarget): List<KotlinTarget> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'CLASS_ONLY' @ [359:45] ==> enum entry CLASS_ONLY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'INTERFACE' @ [359:57] ==> enum entry INTERFACE defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'OBJECT' @ [359:68] ==> enum entry OBJECT defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ENUM_CLASS' @ [359:76] ==> enum entry ENUM_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ANNOTATION_CLASS' @ [359:88] ==> enum entry ANNOTATION_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'TOP_LEVEL_FUNCTION' @ [359:106] ==> enum entry TOP_LEVEL_FUNCTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'TOP_LEVEL_PROPERTY' @ [359:126] ==> enum entry TOP_LEVEL_PROPERTY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'FUNCTION' @ [359:146] ==> enum entry FUNCTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'PROPERTY' @ [359:156] ==> enum entry PROPERTY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ModifierCheckerCore' @ [363:43] ==> public object ModifierCheckerCore defined in org.jetbrains.kotlin.resolve[FakeCallableDescriptorForObject]

'possibleTargetMap' @ [363:63] ==> public final val possibleTargetMap: Map<KtModifierKeywordToken, Set<KotlinTarget>> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[DeserializedPropertyDescriptor]

'keywordTokenType' @ [363:81] ==> value-parameter keywordTokenType: KtKeywordToken defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[ValueParameterDescriptorImpl]

'modifierTargets' @ [364:25] ==> val modifierTargets: Set<KotlinTarget>? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[LocalVariableDescriptor]

'possibleTargets' @ [364:52] ==> val possibleTargets: List<KotlinTarget>? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[LocalVariableDescriptor]

'possibleTargets' @ [364:79] ==> val possibleTargets: List<KotlinTarget>? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[LocalVariableDescriptor]

'none' @ [364:95] ==> public inline fun <T> Iterable<KotlinTarget>.none(predicate: (KotlinTarget) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'it' @ [364:102] ==> value-parameter it: KotlinTarget defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied.<anonymous>[ValueParameterDescriptorImpl]

'modifierTargets' @ [364:108] ==> val modifierTargets: Set<KotlinTarget>? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[LocalVariableDescriptor]

'container' @ [366:44] ==> val container: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[LocalVariableDescriptor]

'getParentOfType' @ [366:55] ==> public inline fun <reified T : PsiElement> PsiElement.getParentOfType(strict: Boolean): KtDeclaration? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtDeclaration

'when (ownerDeclaration) {
                        null -> KotlinTarget.FILE

                        is KtClass -> {
                            when {
                                ownerDeclaration.isInterface() -> KotlinTarget.INTERFACE
                                ownerDeclaration.isEnum() -> KotlinTarget.ENUM_CLASS
                                ownerDeclaration.isAnnotation() -> KotlinTarget.ANNOTATION_CLASS
                                else -> KotlinTarget.CLASS_ONLY
                            }
                        }

                        is KtObjectDeclaration -> if (ownerDeclaration.isObjectLiteral()) KotlinTarget.OBJECT_LITERAL else KotlinTarget.OBJECT

                        else -> return true
                    }' @ [367:40] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KotlinTarget, entry1: KotlinTarget, entry2: KotlinTarget, entry3: KotlinTarget): KotlinTarget[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KotlinTarget

'ownerDeclaration' @ [367:46] ==> val ownerDeclaration: KtDeclaration? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[LocalVariableDescriptor]

'FILE' @ [368:46] ==> enum entry FILE defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'when {
                                ownerDeclaration.isInterface() -> KotlinTarget.INTERFACE
                                ownerDeclaration.isEnum() -> KotlinTarget.ENUM_CLASS
                                ownerDeclaration.isAnnotation() -> KotlinTarget.ANNOTATION_CLASS
                                else -> KotlinTarget.CLASS_ONLY
                            }' @ [371:29] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KotlinTarget, entry1: KotlinTarget, entry2: KotlinTarget, entry3: KotlinTarget): KotlinTarget[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KotlinTarget

'ownerDeclaration' @ [372:33] ==> val ownerDeclaration: KtDeclaration? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[LocalVariableDescriptor]

'isInterface' @ [372:50] ==> public final fun isInterface(): Boolean defined in org.jetbrains.kotlin.psi.KtClass[DeserializedSimpleFunctionDescriptor]

'INTERFACE' @ [372:80] ==> enum entry INTERFACE defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ownerDeclaration' @ [373:33] ==> val ownerDeclaration: KtDeclaration? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[LocalVariableDescriptor]

'isEnum' @ [373:50] ==> public final fun isEnum(): Boolean defined in org.jetbrains.kotlin.psi.KtClass[DeserializedSimpleFunctionDescriptor]

'ENUM_CLASS' @ [373:75] ==> enum entry ENUM_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ownerDeclaration' @ [374:33] ==> val ownerDeclaration: KtDeclaration? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[LocalVariableDescriptor]

'isAnnotation' @ [374:50] ==> public final fun isAnnotation(): Boolean defined in org.jetbrains.kotlin.psi.KtClass[DeserializedSimpleFunctionDescriptor]

'ANNOTATION_CLASS' @ [374:81] ==> enum entry ANNOTATION_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'CLASS_ONLY' @ [375:54] ==> enum entry CLASS_ONLY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'if (ownerDeclaration.isObjectLiteral()) KotlinTarget.OBJECT_LITERAL else KotlinTarget.OBJECT' @ [379:51] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinTarget, elseBranch: KotlinTarget): KotlinTarget[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinTarget

'ownerDeclaration' @ [379:55] ==> val ownerDeclaration: KtDeclaration? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[LocalVariableDescriptor]

'isObjectLiteral' @ [379:72] ==> public final fun isObjectLiteral(): Boolean defined in org.jetbrains.kotlin.psi.KtObjectDeclaration[DeserializedSimpleFunctionDescriptor]

'OBJECT_LITERAL' @ [379:104] ==> enum entry OBJECT_LITERAL defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'OBJECT' @ [379:137] ==> enum entry OBJECT defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ModifierCheckerCore' @ [384:43] ==> public object ModifierCheckerCore defined in org.jetbrains.kotlin.resolve[FakeCallableDescriptorForObject]

'possibleParentTargetMap' @ [384:63] ==> public final val possibleParentTargetMap: Map<KtModifierKeywordToken, Set<KotlinTarget>> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[DeserializedPropertyDescriptor]

'keywordTokenType' @ [384:87] ==> value-parameter keywordTokenType: KtKeywordToken defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[ValueParameterDescriptorImpl]

'modifierParents' @ [385:25] ==> val modifierParents: Set<KotlinTarget>? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[LocalVariableDescriptor]

'parentTarget' @ [385:52] ==> val parentTarget: KotlinTarget defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[LocalVariableDescriptor]

'modifierParents' @ [385:69] ==> val modifierParents: Set<KotlinTarget>? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[LocalVariableDescriptor]

'ModifierCheckerCore' @ [387:45] ==> public object ModifierCheckerCore defined in org.jetbrains.kotlin.resolve[FakeCallableDescriptorForObject]

'deprecatedParentTargetMap' @ [387:65] ==> public final val deprecatedParentTargetMap: Map<KtModifierKeywordToken, Set<KotlinTarget>> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[DeserializedPropertyDescriptor]

'keywordTokenType' @ [387:91] ==> value-parameter keywordTokenType: KtKeywordToken defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[ValueParameterDescriptorImpl]

'deprecatedParents' @ [388:25] ==> val deprecatedParents: Set<KotlinTarget>? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[LocalVariableDescriptor]

'parentTarget' @ [388:54] ==> val parentTarget: KotlinTarget defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[LocalVariableDescriptor]

'deprecatedParents' @ [388:70] ==> val deprecatedParents: Set<KotlinTarget>? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.isKeywordCorrectlyApplied[LocalVariableDescriptor]

'buildFilesWithKeywordApplication' @ [396:25] ==> private final fun buildFilesWithKeywordApplication(keywordTokenType: KtKeywordToken, prefixText: String, psiFactory: KtPsiFactory): Sequence<KtFile> defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[SimpleFunctionDescriptorImpl]

'keywordTokenType' @ [396:58] ==> value-parameter keywordTokenType: KtKeywordToken defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.<no name provided>[ValueParameterDescriptorImpl]

'prefixText' @ [396:76] ==> value-parameter prefixText: String defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText[ValueParameterDescriptorImpl]

'psiFactory' @ [396:88] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText[LocalVariableDescriptor]

'files' @ [397:20] ==> val files: Sequence<KtFile> defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.<no name provided>[LocalVariableDescriptor]

'any' @ [397:26] ==> public inline fun <T> Sequence<KtFile>.any(predicate: (KtFile) -> Boolean): Boolean defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtFile

'isKeywordCorrectlyApplied' @ [397:40] ==> local final fun isKeywordCorrectlyApplied(keywordTokenType: KtKeywordToken, file: KtFile): Boolean defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText[SimpleFunctionDescriptorImpl]

'keywordTokenType' @ [397:66] ==> value-parameter keywordTokenType: KtKeywordToken defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.<no name provided>[ValueParameterDescriptorImpl]

'file' @ [397:84] ==> value-parameter file: KtFile defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildFilterByText.<no name provided>.<anonymous>[ValueParameterDescriptorImpl]

'token' @ [402:22] ==> value-parameter token: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.isErrorElementBefore[ValueParameterDescriptorImpl]

'prevLeafs' @ [402:28] ==> public val PsiElement.prevLeafs: Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'leaf' @ [403:17] ==> val leaf: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.isErrorElementBefore[LocalVariableDescriptor]

'leaf' @ [403:42] ==> val leaf: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.isErrorElementBefore[LocalVariableDescriptor]

'leaf' @ [404:17] ==> val leaf: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.isErrorElementBefore[LocalVariableDescriptor]

'parentsWithSelf' @ [404:22] ==> public val PsiElement.parentsWithSelf: Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'any' @ [404:38] ==> public inline fun <T> Sequence<PsiElement>.any(predicate: (PsiElement) -> Boolean): Boolean defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'it' @ [404:44] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.isErrorElementBefore.<anonymous>[ValueParameterDescriptorImpl]

'leaf' @ [405:17] ==> val leaf: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.isErrorElementBefore[LocalVariableDescriptor]

'textLength' @ [405:22] ==> public final val PsiElement.textLength: Int[MyPropertyDescriptor]

'when(this) {
            keywordType -> true
            NOT_IN -> keywordType == IN_KEYWORD
            NOT_IS -> keywordType == IS_KEYWORD
            else -> false
        }' @ [411:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean, entry2: Boolean, entry3: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'this' @ [411:21] ==> <this> defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.matchesKeyword[ReceiverParameterDescriptorImpl]

'keywordType' @ [412:13] ==> value-parameter keywordType: KtKeywordToken defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.matchesKeyword[ValueParameterDescriptorImpl]

'NOT_IN' @ [413:13] ==> public final val NOT_IN: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'keywordType' @ [413:23] ==> value-parameter keywordType: KtKeywordToken defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.matchesKeyword[ValueParameterDescriptorImpl]

'IN_KEYWORD' @ [413:38] ==> public final val IN_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'NOT_IS' @ [414:13] ==> public final val NOT_IS: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'keywordType' @ [414:23] ==> value-parameter keywordType: KtKeywordToken defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.matchesKeyword[ValueParameterDescriptorImpl]

'IS_KEYWORD' @ [414:38] ==> public final val IS_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'?:' @ [420:39] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: LanguageVersionSettings?, right: LanguageVersionSettings): LanguageVersionSettings[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> LanguageVersionSettings

'findModuleForPsiElement' @ [420:54] ==> @Nullable public open fun findModuleForPsiElement(@NotNull p0: PsiElement): Module? defined in com.intellij.openapi.module.ModuleUtilCore[JavaMethodDescriptor]

'position' @ [420:78] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.isSupportedAtLanguageLevel[ValueParameterDescriptorImpl]

'languageVersionSettings' @ [420:89] ==> public val Module.languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.idea.project[DeserializedPropertyDescriptor]

'DEFAULT' @ [421:70] ==> @field:JvmField public final val DEFAULT: LanguageVersionSettingsImpl defined in org.jetbrains.kotlin.config.LanguageVersionSettingsImpl.Companion[DeserializedPropertyDescriptor]

'when (keyword) {
            KtTokens.TYPE_ALIAS_KEYWORD -> LanguageFeature.TypeAliases
            KtTokens.HEADER_KEYWORD, KtTokens.IMPL_KEYWORD -> LanguageFeature.MultiPlatformProjects
            KtTokens.SUSPEND_KEYWORD -> LanguageFeature.Coroutines
            else -> return true
        }' @ [422:23] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: LanguageFeature, entry1: LanguageFeature, entry2: LanguageFeature, entry3: LanguageFeature): LanguageFeature[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> LanguageFeature

'keyword' @ [422:29] ==> value-parameter keyword: KtKeywordToken defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.isSupportedAtLanguageLevel[ValueParameterDescriptorImpl]

'TYPE_ALIAS_KEYWORD' @ [423:22] ==> public final val TYPE_ALIAS_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'TypeAliases' @ [423:60] ==> enum entry TypeAliases defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'HEADER_KEYWORD' @ [424:22] ==> public final val HEADER_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'IMPL_KEYWORD' @ [424:47] ==> public final val IMPL_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'MultiPlatformProjects' @ [424:79] ==> enum entry MultiPlatformProjects defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'SUSPEND_KEYWORD' @ [425:22] ==> public final val SUSPEND_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'Coroutines' @ [425:57] ==> enum entry Coroutines defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'languageVersionSettings' @ [428:16] ==> val languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.isSupportedAtLanguageLevel[LocalVariableDescriptor]

'supportsFeature' @ [428:40] ==> public open fun supportsFeature(feature: LanguageFeature): Boolean defined in org.jetbrains.kotlin.config.LanguageVersionSettings[DeserializedSimpleFunctionDescriptor]

'feature' @ [428:56] ==> val feature: LanguageFeature defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.isSupportedAtLanguageLevel[LocalVariableDescriptor]

'position' @ [433:13] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildReducedContextBefore[ValueParameterDescriptorImpl]

'scope' @ [433:25] ==> value-parameter scope: PsiElement? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildReducedContextBefore[ValueParameterDescriptorImpl]

'position' @ [434:22] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildReducedContextBefore[ValueParameterDescriptorImpl]

'parent' @ [434:31] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'buildReducedContextBefore' @ [436:9] ==> private final fun buildReducedContextBefore(builder: StringBuilder /* = StringBuilder */, position: PsiElement, scope: PsiElement?): Unit defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[SimpleFunctionDescriptorImpl]

'builder' @ [436:35] ==> value-parameter builder: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildReducedContextBefore[ValueParameterDescriptorImpl]

'parent' @ [436:44] ==> val parent: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildReducedContextBefore[LocalVariableDescriptor]

'scope' @ [436:52] ==> value-parameter scope: PsiElement? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildReducedContextBefore[ValueParameterDescriptorImpl]

'position' @ [438:31] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildReducedContextBefore[ValueParameterDescriptorImpl]

'siblings' @ [438:40] ==> public fun PsiElement.siblings(forward: Boolean = ..., withItself: Boolean = ...): Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'firstOrNull' @ [438:86] ==> public inline fun <T> Sequence<PsiElement>.firstOrNull(predicate: (PsiElement) -> Boolean): PsiElement? defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'it' @ [438:100] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildReducedContextBefore.<anonymous>[ValueParameterDescriptorImpl]

'parent' @ [440:21] ==> val parent: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildReducedContextBefore[LocalVariableDescriptor]

'firstChild' @ [440:28] ==> public final val PsiElement.firstChild: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'child' @ [441:16] ==> var child: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildReducedContextBefore[LocalVariableDescriptor]

'position' @ [441:25] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildReducedContextBefore[ValueParameterDescriptorImpl]

'if (child is KtDeclaration) {
                if (child == prevDeclaration) {
                    builder.appendReducedText(child)
                }
            }
            else {
                builder.append(child!!.text)
            }' @ [442:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (Any..Any?), elseBranch: (Any..Any?)): (Any..Any?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (kotlin.Any..kotlin.Any?)

'child' @ [442:17] ==> var child: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildReducedContextBefore[LocalVariableDescriptor]

'child' @ [443:21] ==> var child: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildReducedContextBefore[LocalVariableDescriptor]

'prevDeclaration' @ [443:30] ==> val prevDeclaration: PsiElement? defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildReducedContextBefore[LocalVariableDescriptor]

'builder' @ [444:21] ==> value-parameter builder: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildReducedContextBefore[ValueParameterDescriptorImpl]

'appendReducedText' @ [444:29] ==> private final fun StringBuilder /* = StringBuilder */.appendReducedText(element: PsiElement): Unit defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[SimpleFunctionDescriptorImpl]

'child' @ [444:47] ==> var child: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildReducedContextBefore[LocalVariableDescriptor]

'builder' @ [448:17] ==> value-parameter builder: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildReducedContextBefore[ValueParameterDescriptorImpl]

'append' @ [448:25] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'child' @ [448:32] ==> var child: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildReducedContextBefore[LocalVariableDescriptor]

'text' @ [448:40] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'child' @ [451:13] ==> var child: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildReducedContextBefore[LocalVariableDescriptor]

'child' @ [451:21] ==> var child: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.buildReducedContextBefore[LocalVariableDescriptor]

'nextSibling' @ [451:27] ==> public final val PsiElement.nextSibling: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'element' @ [456:21] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.appendReducedText[ValueParameterDescriptorImpl]

'firstChild' @ [456:29] ==> public final val PsiElement.firstChild: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'if (child == null) {
            append(element.text!!)
        }
        else {
            while (child != null) {
                when (child) {
                    is KtBlockExpression, is KtClassBody -> append("{}")
                    else -> appendReducedText(child)
                }

                child = child.nextSibling
            }
        }' @ [457:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (Any..Any?), elseBranch: (Any..Any?)): (Any..Any?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (kotlin.Any..kotlin.Any?)

'child' @ [457:13] ==> var child: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.appendReducedText[LocalVariableDescriptor]

'append' @ [458:13] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'element' @ [458:20] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.appendReducedText[ValueParameterDescriptorImpl]

'text' @ [458:28] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'child' @ [461:20] ==> var child: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.appendReducedText[LocalVariableDescriptor]

'when (child) {
                    is KtBlockExpression, is KtClassBody -> append("{}")
                    else -> appendReducedText(child)
                }' @ [462:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: (Any..Any?), entry1: (Any..Any?)): (Any..Any?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> (kotlin.Any..kotlin.Any?)

'child' @ [462:23] ==> var child: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.appendReducedText[LocalVariableDescriptor]

'append' @ [463:61] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'appendReducedText' @ [464:29] ==> private final fun StringBuilder /* = StringBuilder */.appendReducedText(element: PsiElement): Unit defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[SimpleFunctionDescriptorImpl]

'child' @ [464:47] ==> var child: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.appendReducedText[LocalVariableDescriptor]

'child' @ [467:17] ==> var child: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.appendReducedText[LocalVariableDescriptor]

'child' @ [467:25] ==> var child: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.appendReducedText[LocalVariableDescriptor]

'nextSibling' @ [467:31] ==> public final val PsiElement.nextSibling: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'ancestor' @ [473:13] ==> value-parameter ancestor: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.getStartOffsetInAncestor[ValueParameterDescriptorImpl]

'this' @ [473:25] ==> <this> defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.getStartOffsetInAncestor[ReceiverParameterDescriptorImpl]

'parent' @ [474:16] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'getStartOffsetInAncestor' @ [474:25] ==> private final fun PsiElement.getStartOffsetInAncestor(ancestor: PsiElement): Int defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion[SimpleFunctionDescriptorImpl]

'ancestor' @ [474:50] ==> value-parameter ancestor: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.getStartOffsetInAncestor[ValueParameterDescriptorImpl]

'startOffsetInParent' @ [474:62] ==> public final val PsiElement.startOffsetInParent: Int[MyPropertyDescriptor]

'generateSequence' @ [478:16] ==> @LowPriorityInOverloadResolution public fun <T : Any> generateSequence(seed: PsiElement?, nextFunction: (PsiElement) -> PsiElement?): Sequence<PsiElement> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> PsiElement

'this' @ [478:33] ==> <this> defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.goUpWhileIsLastChild[ReceiverParameterDescriptorImpl]

'if (it is PsiFile)
                null
            else if (it != it.parent.lastChild)
                null
            else
                it.parent' @ [479:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: PsiElement?, elseBranch: PsiElement?): PsiElement?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> PsiElement?

'it' @ [479:17] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.goUpWhileIsLastChild.<anonymous>[ValueParameterDescriptorImpl]

'if (it != it.parent.lastChild)
                null
            else
                it.parent' @ [481:18] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: PsiElement?, elseBranch: PsiElement?): PsiElement?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> PsiElement?

'it' @ [481:22] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.goUpWhileIsLastChild.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [481:28] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.goUpWhileIsLastChild.<anonymous>[ValueParameterDescriptorImpl]

'parent' @ [481:31] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'lastChild' @ [481:38] ==> public final val PsiElement.lastChild: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'it' @ [484:17] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.completion.KeywordCompletion.goUpWhileIsLastChild.<anonymous>[ValueParameterDescriptorImpl]

'parent' @ [484:20] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

