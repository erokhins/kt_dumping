'KotlinCallableInsertHandler' @ [39:67] ==> public constructor KotlinCallableInsertHandler(callType: CallType<*>) defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinCallableInsertHandler[ClassConstructorDescriptorImpl]

'callType' @ [39:95] ==> value-parameter callType: CallType<*> defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.<init>[ValueParameterDescriptorImpl]

'KotlinFunctionInsertHandler' @ [48:9] ==> private constructor KotlinFunctionInsertHandler(callType: CallType<*>) defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler[ClassConstructorDescriptorImpl]

'callType' @ [48:37] ==> value-parameter callType: CallType<*> defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.<init>[ValueParameterDescriptorImpl]

'lambdaInfo' @ [50:17] ==> public final val lambdaInfo: GenerateLambdaInfo? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[PropertyDescriptorImpl]

'assert' @ [51:17] ==> @InlineOnly public inline fun assert(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'argumentText' @ [51:24] ==> public final val argumentText: String defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[PropertyDescriptorImpl]

'this' @ [57:41] ==> <this> defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[LazyClassReceiverParameterDescriptor]

'callType' @ [57:46] ==> public final val callType: CallType<*> defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[PropertyDescriptorImpl]

'this' @ [58:47] ==> <this> defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[LazyClassReceiverParameterDescriptor]

'inputTypeArguments' @ [58:52] ==> public final val inputTypeArguments: Boolean defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[PropertyDescriptorImpl]

'this' @ [59:48] ==> <this> defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[LazyClassReceiverParameterDescriptor]

'inputValueArguments' @ [59:53] ==> public final val inputValueArguments: Boolean defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[PropertyDescriptorImpl]

'this' @ [60:40] ==> <this> defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[LazyClassReceiverParameterDescriptor]

'argumentText' @ [60:45] ==> public final val argumentText: String defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[PropertyDescriptorImpl]

'this' @ [61:51] ==> <this> defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[LazyClassReceiverParameterDescriptor]

'lambdaInfo' @ [61:56] ==> public final val lambdaInfo: GenerateLambdaInfo? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[PropertyDescriptorImpl]

'this' @ [62:42] ==> <this> defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[LazyClassReceiverParameterDescriptor]

'argumentsOnly' @ [62:47] ==> public final val argumentsOnly: Boolean defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[PropertyDescriptorImpl]

'Normal' @ [63:13] ==> public constructor Normal(callType: CallType<*>, inputTypeArguments: Boolean, inputValueArguments: Boolean, argumentText: String = ..., lambdaInfo: GenerateLambdaInfo? = ..., argumentsOnly: Boolean = ...) defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[ClassConstructorDescriptorImpl]

'callType' @ [63:20] ==> value-parameter callType: CallType<*> = ... defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.copy[ValueParameterDescriptorImpl]

'inputTypeArguments' @ [63:30] ==> value-parameter inputTypeArguments: Boolean = ... defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.copy[ValueParameterDescriptorImpl]

'inputValueArguments' @ [63:50] ==> value-parameter inputValueArguments: Boolean = ... defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.copy[ValueParameterDescriptorImpl]

'argumentText' @ [63:71] ==> value-parameter argumentText: String = ... defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.copy[ValueParameterDescriptorImpl]

'lambdaInfo' @ [63:85] ==> value-parameter lambdaInfo: GenerateLambdaInfo? = ... defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.copy[ValueParameterDescriptorImpl]

'argumentsOnly' @ [63:97] ==> value-parameter argumentsOnly: Boolean = ... defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.copy[ValueParameterDescriptorImpl]

'getInstance' @ [66:57] ==> public open fun getInstance(@NotNull p0: Project): (PsiDocumentManager..PsiDocumentManager?) defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'context' @ [66:69] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.handleInsert[ValueParameterDescriptorImpl]

'project' @ [66:77] ==> public final val InsertionContext.project: (Project..Project?)[MyPropertyDescriptor]

'context' @ [67:28] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.handleInsert[ValueParameterDescriptorImpl]

'document' @ [67:36] ==> public final val InsertionContext.document: Document[MyPropertyDescriptor]

'!' @ [69:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'argumentsOnly' @ [69:18] ==> public final val argumentsOnly: Boolean defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[PropertyDescriptorImpl]

'surroundWithBracesIfInStringTemplate' @ [70:17] ==> public fun surroundWithBracesIfInStringTemplate(context: InsertionContext): Boolean defined in org.jetbrains.kotlin.idea.completion.handlers in file handlerUtils.kt[SimpleFunctionDescriptorImpl]

'context' @ [70:54] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.handleInsert[ValueParameterDescriptorImpl]

'super' @ [72:17] ==> <this> defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[LazyClassReceiverParameterDescriptor]

'handleInsert' @ [72:23] ==> public open fun handleInsert(context: InsertionContext, item: LookupElement): Unit defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler[SimpleFunctionDescriptorImpl]

'context' @ [72:36] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.handleInsert[ValueParameterDescriptorImpl]

'item' @ [72:45] ==> value-parameter item: LookupElement defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.handleInsert[ValueParameterDescriptorImpl]

'psiDocumentManager' @ [75:13] ==> val psiDocumentManager: (PsiDocumentManager..PsiDocumentManager?) defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.handleInsert[LocalVariableDescriptor]

'commitAllDocuments' @ [75:32] ==> public abstract fun commitAllDocuments(): Unit defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'psiDocumentManager' @ [76:13] ==> val psiDocumentManager: (PsiDocumentManager..PsiDocumentManager?) defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.handleInsert[LocalVariableDescriptor]

'doPostponedOperationsAndUnblockDocument' @ [76:32] ==> public abstract fun doPostponedOperationsAndUnblockDocument(@NotNull p0: Document): Unit defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'document' @ [76:72] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.handleInsert[LocalVariableDescriptor]

'context' @ [78:31] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.handleInsert[ValueParameterDescriptorImpl]

'startOffset' @ [78:39] ==> public final val InsertionContext.startOffset: Int[MyPropertyDescriptor]

'context' @ [79:27] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.handleInsert[ValueParameterDescriptorImpl]

'file' @ [79:35] ==> public final val InsertionContext.file: PsiFile[MyPropertyDescriptor]

'findElementAt' @ [79:40] ==> @Nullable @Contract public abstract fun findElementAt(p0: Int): PsiElement? defined in com.intellij.psi.PsiFile[JavaMethodDescriptor]

'startOffset' @ [79:54] ==> val startOffset: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.handleInsert[LocalVariableDescriptor]

'addArguments' @ [81:13] ==> private final fun addArguments(context: InsertionContext, offsetElement: PsiElement): Unit defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[SimpleFunctionDescriptorImpl]

'context' @ [81:26] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.handleInsert[ValueParameterDescriptorImpl]

'element' @ [81:35] ==> val element: PsiElement defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.handleInsert[LocalVariableDescriptor]

'context' @ [85:34] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[ValueParameterDescriptorImpl]

'completionChar' @ [85:42] ==> public final val InsertionContext.completionChar: Char[MyPropertyDescriptor]

'completionChar' @ [86:17] ==> val completionChar: Char defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'context' @ [87:17] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[ValueParameterDescriptorImpl]

'setAddCompletionChar' @ [87:25] ==> public open fun setAddCompletionChar(p0: Boolean): Unit defined in com.intellij.codeInsight.completion.InsertionContext[JavaMethodDescriptor]

'context' @ [90:26] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[ValueParameterDescriptorImpl]

'tailOffset' @ [90:34] ==> public final var InsertionContext.tailOffset: Int[MyPropertyDescriptor]

'context' @ [91:28] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[ValueParameterDescriptorImpl]

'document' @ [91:36] ==> public final val InsertionContext.document: Document[MyPropertyDescriptor]

'context' @ [92:26] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[ValueParameterDescriptorImpl]

'editor' @ [92:34] ==> public final val InsertionContext.editor: Editor[MyPropertyDescriptor]

'context' @ [93:27] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[ValueParameterDescriptorImpl]

'project' @ [93:35] ==> public final val InsertionContext.project: (Project..Project?)[MyPropertyDescriptor]

'document' @ [94:25] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'charsSequence' @ [94:34] ==> public final val Document.charsSequence: CharSequence[MyPropertyDescriptor]

'lambdaInfo' @ [96:32] ==> public final val lambdaInfo: GenerateLambdaInfo? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[PropertyDescriptorImpl]

'completionChar' @ [96:54] ==> val completionChar: Char defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'!' @ [96:79] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'completionChar' @ [96:81] ==> val completionChar: Char defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'chars' @ [96:107] ==> val chars: CharSequence defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'isCharAt' @ [96:113] ==> public fun CharSequence.isCharAt(offset: Int, c: Char): Boolean defined in org.jetbrains.kotlin.idea.completion.handlers in file handlerUtils.kt[SimpleFunctionDescriptorImpl]

'offset' @ [96:122] ==> var offset: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'if (insertLambda) '{' else '('' @ [98:34] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Char, elseBranch: Char): Char[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Char

'insertLambda' @ [98:38] ==> val insertLambda: Boolean defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'if (insertLambda) '}' else ')'' @ [99:34] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Char, elseBranch: Char): Char[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Char

'insertLambda' @ [99:38] ==> val insertLambda: Boolean defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'inputTypeArguments' @ [101:39] ==> public final val inputTypeArguments: Boolean defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[PropertyDescriptorImpl]

'completionChar' @ [101:62] ==> val completionChar: Char defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'completionChar' @ [101:88] ==> val completionChar: Char defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'completionChar' @ [101:114] ==> val completionChar: Char defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'REPLACE_SELECT_CHAR' @ [101:139] ==> public const final val REPLACE_SELECT_CHAR: Char defined in com.intellij.codeInsight.lookup.Lookup[JavaPropertyDescriptor]

'completionChar' @ [103:17] ==> val completionChar: Char defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'REPLACE_SELECT_CHAR' @ [103:42] ==> public const final val REPLACE_SELECT_CHAR: Char defined in com.intellij.codeInsight.lookup.Lookup[JavaPropertyDescriptor]

'chars' @ [104:31] ==> val chars: CharSequence defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'skipSpaces' @ [104:37] ==> public fun CharSequence.skipSpaces(index: Int): Int defined in org.jetbrains.kotlin.idea.completion.handlers in file handlerUtils.kt[SimpleFunctionDescriptorImpl]

'offset' @ [104:48] ==> var offset: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'offset1' @ [105:21] ==> val offset1: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'chars' @ [105:31] ==> val chars: CharSequence defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'length' @ [105:37] ==> public abstract val length: Int defined in kotlin.CharSequence[DeserializedPropertyDescriptor]

'chars' @ [106:25] ==> val chars: CharSequence defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'offset1' @ [106:31] ==> val offset1: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'getInstance' @ [107:44] ==> public open fun getInstance(@NotNull p0: Project): (PsiDocumentManager..PsiDocumentManager?) defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'project' @ [107:56] ==> val project: (Project..Project?) defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'commitDocument' @ [107:65] ==> public abstract fun commitDocument(@NotNull p0: Document): Unit defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'document' @ [107:80] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'context' @ [108:37] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[ValueParameterDescriptorImpl]

'file' @ [108:45] ==> public final val InsertionContext.file: PsiFile[MyPropertyDescriptor]

'findElementAt' @ [108:50] ==> @Nullable @Contract public abstract fun findElementAt(p0: Int): PsiElement? defined in com.intellij.psi.PsiFile[JavaMethodDescriptor]

'offset1' @ [108:64] ==> val offset1: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'token' @ [109:29] ==> val token: PsiElement defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'node' @ [109:35] ==> public final val PsiElement.node: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'elementType' @ [109:40] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'LT' @ [109:64] ==> public final val LT: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'token' @ [110:42] ==> val token: PsiElement defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'parent' @ [110:48] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [111:33] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'parent' @ [111:65] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'getText' @ [111:72] ==> @NonNls @Contract public abstract fun getText(): (String..String?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'indexOf' @ [111:82] ==> public fun CharSequence.indexOf(char: Char, startIndex: Int = ..., ignoreCase: Boolean = ...): Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'offset' @ [112:33] ==> var offset: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'parent' @ [112:42] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'endOffset' @ [112:49] ==> public val PsiElement.endOffset: Int defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'insertTypeArguments' @ [113:33] ==> var insertTypeArguments: Boolean defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'insertLambda' @ [120:17] ==> val insertLambda: Boolean defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'lambdaInfo' @ [120:33] ==> public final val lambdaInfo: GenerateLambdaInfo? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[PropertyDescriptorImpl]

'explicitParameters' @ [120:46] ==> public final val explicitParameters: Boolean defined in org.jetbrains.kotlin.idea.completion.handlers.GenerateLambdaInfo[PropertyDescriptorImpl]

'insertTypeArguments' @ [121:17] ==> var insertTypeArguments: Boolean defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'insertTypeArguments' @ [124:17] ==> var insertTypeArguments: Boolean defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'document' @ [125:17] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'insertString' @ [125:26] ==> public abstract fun insertString(p0: Int, @NotNull p1: CharSequence): Unit defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'offset' @ [125:39] ==> var offset: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'editor' @ [126:17] ==> val editor: Editor defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'caretModel' @ [126:24] ==> public final val Editor.caretModel: CaretModel[MyPropertyDescriptor]

'moveToOffset' @ [126:35] ==> public abstract fun moveToOffset(p0: Int): Unit defined in com.intellij.openapi.editor.CaretModel[JavaMethodDescriptor]

'offset' @ [126:48] ==> var offset: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'offset' @ [127:17] ==> var offset: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'chars' @ [130:40] ==> val chars: CharSequence defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'indexOfSkippingSpace' @ [130:46] ==> public fun CharSequence.indexOfSkippingSpace(c: Char, startIndex: Int): Int? defined in org.jetbrains.kotlin.idea.completion.handlers in file handlerUtils.kt[SimpleFunctionDescriptorImpl]

'openingBracket' @ [130:67] ==> val openingBracket: Char defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'offset' @ [130:83] ==> var offset: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'openingBracketOffset' @ [131:38] ==> var openingBracketOffset: Int? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'let' @ [131:60] ==> @InlineOnly public inline fun <T, R> Int.let(block: (Int) -> Int?): Int? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Int
    <R> -> Int?

'chars' @ [131:66] ==> val chars: CharSequence defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'indexOfSkippingSpace' @ [131:72] ==> public fun CharSequence.indexOfSkippingSpace(c: Char, startIndex: Int): Int? defined in org.jetbrains.kotlin.idea.completion.handlers in file handlerUtils.kt[SimpleFunctionDescriptorImpl]

'closingBracket' @ [131:93] ==> val closingBracket: Char defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'it' @ [131:109] ==> value-parameter it: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments.<anonymous>[ValueParameterDescriptorImpl]

'insertLambda' @ [134:17] ==> val insertLambda: Boolean defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'lambdaInfo' @ [134:33] ==> public final val lambdaInfo: GenerateLambdaInfo? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[PropertyDescriptorImpl]

'explicitParameters' @ [134:46] ==> public final val explicitParameters: Boolean defined in org.jetbrains.kotlin.idea.completion.handlers.GenerateLambdaInfo[PropertyDescriptorImpl]

'closeBracketOffset' @ [134:68] ==> var closeBracketOffset: Int? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'openingBracketOffset' @ [135:17] ==> var openingBracketOffset: Int? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'openingBracketOffset' @ [138:17] ==> var openingBracketOffset: Int? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'if (insertLambda) {
                    if (completionChar == ' ' || completionChar == '{') {
                        context.setAddCompletionChar(false)
                    }

                    if (isInsertSpacesInOneLineFunctionEnabled(project)) {
                        document.insertString(offset, " {  }")
                        inBracketsShift = 1
                    }
                    else {
                        document.insertString(offset, " {}")
                    }
                }
                else {
                    document.insertString(offset, "()")
                }' @ [139:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'insertLambda' @ [139:21] ==> val insertLambda: Boolean defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'completionChar' @ [140:25] ==> val completionChar: Char defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'completionChar' @ [140:50] ==> val completionChar: Char defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'context' @ [141:25] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[ValueParameterDescriptorImpl]

'setAddCompletionChar' @ [141:33] ==> public open fun setAddCompletionChar(p0: Boolean): Unit defined in com.intellij.codeInsight.completion.InsertionContext[JavaMethodDescriptor]

'if (isInsertSpacesInOneLineFunctionEnabled(project)) {
                        document.insertString(offset, " {  }")
                        inBracketsShift = 1
                    }
                    else {
                        document.insertString(offset, " {}")
                    }' @ [144:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'isInsertSpacesInOneLineFunctionEnabled' @ [144:25] ==> private final fun isInsertSpacesInOneLineFunctionEnabled(project: Project): Boolean defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[SimpleFunctionDescriptorImpl]

'project' @ [144:64] ==> val project: (Project..Project?) defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'document' @ [145:25] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'insertString' @ [145:34] ==> public abstract fun insertString(p0: Int, @NotNull p1: CharSequence): Unit defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'offset' @ [145:47] ==> var offset: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'inBracketsShift' @ [146:25] ==> var inBracketsShift: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'document' @ [149:25] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'insertString' @ [149:34] ==> public abstract fun insertString(p0: Int, @NotNull p1: CharSequence): Unit defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'offset' @ [149:47] ==> var offset: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'document' @ [153:21] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'insertString' @ [153:30] ==> public abstract fun insertString(p0: Int, @NotNull p1: CharSequence): Unit defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'offset' @ [153:43] ==> var offset: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'getInstance' @ [155:36] ==> public open fun getInstance(@NotNull p0: Project): (PsiDocumentManager..PsiDocumentManager?) defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'project' @ [155:48] ==> val project: (Project..Project?) defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'commitDocument' @ [155:57] ==> public abstract fun commitDocument(@NotNull p0: Document): Unit defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'document' @ [155:72] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'openingBracketOffset' @ [157:17] ==> var openingBracketOffset: Int? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'chars' @ [157:40] ==> val chars: CharSequence defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'indexOfSkippingSpace' @ [157:46] ==> public fun CharSequence.indexOfSkippingSpace(c: Char, startIndex: Int): Int? defined in org.jetbrains.kotlin.idea.completion.handlers in file handlerUtils.kt[SimpleFunctionDescriptorImpl]

'openingBracket' @ [157:67] ==> val openingBracket: Char defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'offset' @ [157:83] ==> var offset: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'closeBracketOffset' @ [158:17] ==> var closeBracketOffset: Int? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'chars' @ [158:38] ==> val chars: CharSequence defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'indexOfSkippingSpace' @ [158:44] ==> public fun CharSequence.indexOfSkippingSpace(c: Char, startIndex: Int): Int? defined in org.jetbrains.kotlin.idea.completion.handlers in file handlerUtils.kt[SimpleFunctionDescriptorImpl]

'closingBracket' @ [158:65] ==> val closingBracket: Char defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'openingBracketOffset' @ [158:81] ==> var openingBracketOffset: Int? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'insertLambda' @ [161:17] ==> val insertLambda: Boolean defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'lambdaInfo' @ [161:33] ==> public final val lambdaInfo: GenerateLambdaInfo? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[PropertyDescriptorImpl]

'explicitParameters' @ [161:46] ==> public final val explicitParameters: Boolean defined in org.jetbrains.kotlin.idea.completion.handlers.GenerateLambdaInfo[PropertyDescriptorImpl]

'TextRange' @ [162:40] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'openingBracketOffset' @ [162:50] ==> var openingBracketOffset: Int? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'closeBracketOffset' @ [162:72] ==> var closeBracketOffset: Int? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'LambdaSignatureTemplates' @ [163:46] ==> public object LambdaSignatureTemplates defined in org.jetbrains.kotlin.idea.completion in file LambdaSignatureTemplates.kt[FakeCallableDescriptorForObject]

'explicitParameterTypesRequired' @ [163:71] ==> public final fun explicitParameterTypesRequired(file: KtFile, placeholderRange: TextRange, lambdaType: KotlinType): Boolean defined in org.jetbrains.kotlin.idea.completion.LambdaSignatureTemplates[SimpleFunctionDescriptorImpl]

'context' @ [163:102] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[ValueParameterDescriptorImpl]

'file' @ [163:110] ==> public final val InsertionContext.file: PsiFile[MyPropertyDescriptor]

'placeholderRange' @ [163:126] ==> val placeholderRange: TextRange defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'lambdaInfo' @ [163:144] ==> public final val lambdaInfo: GenerateLambdaInfo? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[PropertyDescriptorImpl]

'lambdaType' @ [163:155] ==> public final val lambdaType: KotlinType defined in org.jetbrains.kotlin.idea.completion.handlers.GenerateLambdaInfo[PropertyDescriptorImpl]

'LambdaSignatureTemplates' @ [164:17] ==> public object LambdaSignatureTemplates defined in org.jetbrains.kotlin.idea.completion in file LambdaSignatureTemplates.kt[FakeCallableDescriptorForObject]

'insertTemplate' @ [164:42] ==> public final fun insertTemplate(context: InsertionContext, placeholderRange: TextRange, lambdaType: KotlinType, explicitParameterTypes: Boolean, signatureOnly: Boolean): Unit defined in org.jetbrains.kotlin.idea.completion.LambdaSignatureTemplates[SimpleFunctionDescriptorImpl]

'context' @ [164:57] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[ValueParameterDescriptorImpl]

'placeholderRange' @ [164:66] ==> val placeholderRange: TextRange defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'lambdaInfo' @ [164:84] ==> public final val lambdaInfo: GenerateLambdaInfo? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[PropertyDescriptorImpl]

'lambdaType' @ [164:95] ==> public final val lambdaType: KotlinType defined in org.jetbrains.kotlin.idea.completion.handlers.GenerateLambdaInfo[PropertyDescriptorImpl]

'explicitParameterTypes' @ [164:107] ==> val explicitParameterTypes: Boolean defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'document' @ [168:13] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'insertString' @ [168:22] ==> public abstract fun insertString(p0: Int, @NotNull p1: CharSequence): Unit defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'openingBracketOffset' @ [168:35] ==> var openingBracketOffset: Int? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'argumentText' @ [168:61] ==> public final val argumentText: String defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[PropertyDescriptorImpl]

'closeBracketOffset' @ [169:17] ==> var closeBracketOffset: Int? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'closeBracketOffset' @ [170:17] ==> var closeBracketOffset: Int? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'argumentText' @ [170:39] ==> public final val argumentText: String defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[PropertyDescriptorImpl]

'length' @ [170:52] ==> public open val length: Int defined in kotlin.String[DeserializedPropertyDescriptor]

'!' @ [173:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'insertTypeArguments' @ [173:18] ==> var insertTypeArguments: Boolean defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'if (shouldPlaceCaretInBrackets(completionChar) || closeBracketOffset == null) {
                    editor.caretModel.moveToOffset(openingBracketOffset + 1 + inBracketsShift)
                    if (!insertLambda) {
                        AutoPopupController.getInstance(project)?.autoPopupParameterInfo(editor, offsetElement)
                    }
                }
                else {
                    editor.caretModel.moveToOffset(closeBracketOffset + 1)
                }' @ [174:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'shouldPlaceCaretInBrackets' @ [174:21] ==> private final fun shouldPlaceCaretInBrackets(completionChar: Char): Boolean defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[SimpleFunctionDescriptorImpl]

'completionChar' @ [174:48] ==> val completionChar: Char defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'closeBracketOffset' @ [174:67] ==> var closeBracketOffset: Int? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'editor' @ [175:21] ==> val editor: Editor defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'caretModel' @ [175:28] ==> public final val Editor.caretModel: CaretModel[MyPropertyDescriptor]

'moveToOffset' @ [175:39] ==> public abstract fun moveToOffset(p0: Int): Unit defined in com.intellij.openapi.editor.CaretModel[JavaMethodDescriptor]

'openingBracketOffset' @ [175:52] ==> var openingBracketOffset: Int? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'inBracketsShift' @ [175:79] ==> var inBracketsShift: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'!' @ [176:25] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'insertLambda' @ [176:26] ==> val insertLambda: Boolean defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'getInstance' @ [177:45] ==> public open fun getInstance(p0: (Project..Project?)): (AutoPopupController..AutoPopupController?) defined in com.intellij.codeInsight.AutoPopupController[JavaMethodDescriptor]

'project' @ [177:57] ==> val project: (Project..Project?) defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'autoPopupParameterInfo' @ [177:67] ==> public open fun autoPopupParameterInfo(@NotNull p0: Editor, @Nullable p1: PsiElement?): Unit defined in com.intellij.codeInsight.AutoPopupController[JavaMethodDescriptor]

'editor' @ [177:90] ==> val editor: Editor defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'offsetElement' @ [177:98] ==> value-parameter offsetElement: PsiElement defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[ValueParameterDescriptorImpl]

'editor' @ [181:21] ==> val editor: Editor defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'caretModel' @ [181:28] ==> public final val Editor.caretModel: CaretModel[MyPropertyDescriptor]

'moveToOffset' @ [181:39] ==> public abstract fun moveToOffset(p0: Int): Unit defined in com.intellij.openapi.editor.CaretModel[JavaMethodDescriptor]

'closeBracketOffset' @ [181:52] ==> var closeBracketOffset: Int? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.addArguments[LocalVariableDescriptor]

'completionChar' @ [187:17] ==> value-parameter completionChar: Char defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.shouldPlaceCaretInBrackets[ValueParameterDescriptorImpl]

'completionChar' @ [187:42] ==> value-parameter completionChar: Char defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.shouldPlaceCaretInBrackets[ValueParameterDescriptorImpl]

'completionChar' @ [187:67] ==> value-parameter completionChar: Char defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.shouldPlaceCaretInBrackets[ValueParameterDescriptorImpl]

'completionChar' @ [188:17] ==> value-parameter completionChar: Char defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.shouldPlaceCaretInBrackets[ValueParameterDescriptorImpl]

'inputValueArguments' @ [189:20] ==> public final val inputValueArguments: Boolean defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[PropertyDescriptorImpl]

'lambdaInfo' @ [189:43] ==> public final val lambdaInfo: GenerateLambdaInfo? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal[PropertyDescriptorImpl]

'!!' @ [193:19] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: KotlinCodeStyleSettings?): KotlinCodeStyleSettings[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> KotlinCodeStyleSettings

'getSettings' @ [193:44] ==> @NotNull public open fun getSettings(@Nullable p0: Project?): CodeStyleSettings defined in com.intellij.psi.codeStyle.CodeStyleSettingsManager[JavaMethodDescriptor]

'project' @ [193:56] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Normal.isInsertSpacesInOneLineFunctionEnabled[ValueParameterDescriptorImpl]

'getCustomSettings' @ [193:65] ==> public open fun <T : (CustomCodeStyleSettings..CustomCodeStyleSettings?)> getCustomSettings(@NotNull p0: Class<(KotlinCodeStyleSettings..KotlinCodeStyleSettings?)>): (KotlinCodeStyleSettings..KotlinCodeStyleSettings?) defined in com.intellij.psi.codeStyle.CodeStyleSettings[JavaMethodDescriptor]
Inferred types:
    <T : (CustomCodeStyleSettings..CustomCodeStyleSettings?)> -> (org.jetbrains.kotlin.idea.core.formatter.KotlinCodeStyleSettings..org.jetbrains.kotlin.idea.core.formatter.KotlinCodeStyleSettings?)

'KotlinCodeStyleSettings' @ [193:83] ==> public constructor KotlinCodeStyleSettings(p0: (CodeStyleSettings..CodeStyleSettings?)) defined in org.jetbrains.kotlin.idea.core.formatter.KotlinCodeStyleSettings[JavaClassConstructorDescriptor]

'java' @ [193:114] ==> public val <T> KClass<KotlinCodeStyleSettings>.java: Class<KotlinCodeStyleSettings> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KotlinCodeStyleSettings

'INSERT_WHITESPACES_IN_SIMPLE_ONE_LINE_METHOD' @ [193:122] ==> public final var INSERT_WHITESPACES_IN_SIMPLE_ONE_LINE_METHOD: Boolean defined in org.jetbrains.kotlin.idea.core.formatter.KotlinCodeStyleSettings[JavaPropertyDescriptor]

'KotlinFunctionInsertHandler' @ [196:20] ==> private constructor KotlinFunctionInsertHandler(callType: CallType<*>) defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler[ClassConstructorDescriptorImpl]

'INFIX' @ [196:57] ==> public object INFIX : CallType<KtExpression> defined in org.jetbrains.kotlin.idea.util.CallType[FakeCallableDescriptorForObject]

'super' @ [198:13] ==> <this> defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Infix[LazyClassReceiverParameterDescriptor]

'handleInsert' @ [198:19] ==> public open fun handleInsert(context: InsertionContext, item: LookupElement): Unit defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler[SimpleFunctionDescriptorImpl]

'context' @ [198:32] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Infix.handleInsert[ValueParameterDescriptorImpl]

'item' @ [198:41] ==> value-parameter item: LookupElement defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Infix.handleInsert[ValueParameterDescriptorImpl]

'context' @ [200:17] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Infix.handleInsert[ValueParameterDescriptorImpl]

'completionChar' @ [200:25] ==> public final val InsertionContext.completionChar: Char[MyPropertyDescriptor]

'context' @ [201:17] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Infix.handleInsert[ValueParameterDescriptorImpl]

'setAddCompletionChar' @ [201:25] ==> public open fun setAddCompletionChar(p0: Boolean): Unit defined in com.intellij.codeInsight.completion.InsertionContext[JavaMethodDescriptor]

'context' @ [204:30] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Infix.handleInsert[ValueParameterDescriptorImpl]

'tailOffset' @ [204:38] ==> public final var InsertionContext.tailOffset: Int[MyPropertyDescriptor]

'context' @ [205:13] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Infix.handleInsert[ValueParameterDescriptorImpl]

'document' @ [205:21] ==> public final val InsertionContext.document: Document[MyPropertyDescriptor]

'insertString' @ [205:30] ==> public abstract fun insertString(p0: Int, @NotNull p1: CharSequence): Unit defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'tailOffset' @ [205:43] ==> val tailOffset: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Infix.handleInsert[LocalVariableDescriptor]

'context' @ [206:13] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Infix.handleInsert[ValueParameterDescriptorImpl]

'editor' @ [206:21] ==> public final val InsertionContext.editor: Editor[MyPropertyDescriptor]

'caretModel' @ [206:28] ==> public final val Editor.caretModel: CaretModel[MyPropertyDescriptor]

'moveToOffset' @ [206:39] ==> public abstract fun moveToOffset(p0: Int): Unit defined in com.intellij.openapi.editor.CaretModel[JavaMethodDescriptor]

'tailOffset' @ [206:52] ==> val tailOffset: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.Infix.handleInsert[LocalVariableDescriptor]

'KotlinFunctionInsertHandler' @ [210:45] ==> private constructor KotlinFunctionInsertHandler(callType: CallType<*>) defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler[ClassConstructorDescriptorImpl]

'callType' @ [210:73] ==> value-parameter callType: CallType<*> defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.OnlyName.<init>[ValueParameterDescriptorImpl]

'super' @ [213:9] ==> <this> defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler[LazyClassReceiverParameterDescriptor]

'handleInsert' @ [213:15] ==> public open fun handleInsert(context: InsertionContext, item: LookupElement): Unit defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinCallableInsertHandler[SimpleFunctionDescriptorImpl]

'context' @ [213:28] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.handleInsert[ValueParameterDescriptorImpl]

'item' @ [213:37] ==> value-parameter item: LookupElement defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.handleInsert[ValueParameterDescriptorImpl]

'getInstance' @ [215:53] ==> public open fun getInstance(@NotNull p0: Project): (PsiDocumentManager..PsiDocumentManager?) defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'context' @ [215:65] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.handleInsert[ValueParameterDescriptorImpl]

'project' @ [215:73] ==> public final val InsertionContext.project: (Project..Project?)[MyPropertyDescriptor]

'psiDocumentManager' @ [216:9] ==> val psiDocumentManager: (PsiDocumentManager..PsiDocumentManager?) defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.handleInsert[LocalVariableDescriptor]

'commitAllDocuments' @ [216:28] ==> public abstract fun commitAllDocuments(): Unit defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'psiDocumentManager' @ [217:9] ==> val psiDocumentManager: (PsiDocumentManager..PsiDocumentManager?) defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.handleInsert[LocalVariableDescriptor]

'doPostponedOperationsAndUnblockDocument' @ [217:28] ==> public abstract fun doPostponedOperationsAndUnblockDocument(@NotNull p0: Document): Unit defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'context' @ [217:68] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinFunctionInsertHandler.handleInsert[ValueParameterDescriptorImpl]

'document' @ [217:76] ==> public final val InsertionContext.document: Document[MyPropertyDescriptor]

