'BaseDeclarationInsertHandler' @ [39:40] ==> public constructor BaseDeclarationInsertHandler() defined in org.jetbrains.kotlin.idea.completion.handlers.BaseDeclarationInsertHandler[ClassConstructorDescriptorImpl]

'surroundWithBracesIfInStringTemplate' @ [41:9] ==> public fun surroundWithBracesIfInStringTemplate(context: InsertionContext): Boolean defined in org.jetbrains.kotlin.idea.completion.handlers in file handlerUtils.kt[SimpleFunctionDescriptorImpl]

'context' @ [41:46] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[ValueParameterDescriptorImpl]

'super' @ [43:9] ==> <this> defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler[LazyClassReceiverParameterDescriptor]

'handleInsert' @ [43:15] ==> public open fun handleInsert(context: InsertionContext, item: LookupElement): Unit defined in org.jetbrains.kotlin.idea.completion.handlers.BaseDeclarationInsertHandler[SimpleFunctionDescriptorImpl]

'context' @ [43:28] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[ValueParameterDescriptorImpl]

'item' @ [43:37] ==> value-parameter item: LookupElement defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[ValueParameterDescriptorImpl]

'context' @ [45:20] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[ValueParameterDescriptorImpl]

'file' @ [45:28] ==> public final val InsertionContext.file: PsiFile[MyPropertyDescriptor]

'file' @ [46:13] ==> val file: PsiFile defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'!' @ [47:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'context' @ [47:18] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[ValueParameterDescriptorImpl]

'isAfterDot' @ [47:26] ==> public fun InsertionContext.isAfterDot(): Boolean defined in org.jetbrains.kotlin.idea.completion in file CompletionUtils.kt[SimpleFunctionDescriptorImpl]

'getInstance' @ [48:61] ==> public open fun getInstance(@NotNull p0: Project): (PsiDocumentManager..PsiDocumentManager?) defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'context' @ [48:73] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[ValueParameterDescriptorImpl]

'project' @ [48:81] ==> public final val InsertionContext.project: (Project..Project?)[MyPropertyDescriptor]

'psiDocumentManager' @ [49:17] ==> val psiDocumentManager: (PsiDocumentManager..PsiDocumentManager?) defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'commitAllDocuments' @ [49:36] ==> public abstract fun commitAllDocuments(): Unit defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'context' @ [51:35] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[ValueParameterDescriptorImpl]

'startOffset' @ [51:43] ==> public final val InsertionContext.startOffset: Int[MyPropertyDescriptor]

'context' @ [52:32] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[ValueParameterDescriptorImpl]

'document' @ [52:40] ==> public final val InsertionContext.document: Document[MyPropertyDescriptor]

'item' @ [54:36] ==> value-parameter item: LookupElement defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[ValueParameterDescriptorImpl]

'`object`' @ [54:41] ==> public final val LookupElement.`object`: Any[MyPropertyDescriptor]

'lookupObject' @ [55:21] ==> val lookupObject: DeclarationLookupObject defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'descriptor' @ [55:34] ==> public abstract val descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.core.completion.DeclarationLookupObject[DeserializedPropertyDescriptor]

'isArtificialImportAliasedDescriptor' @ [55:46] ==> public val DeclarationDescriptor.isArtificialImportAliasedDescriptor: Boolean defined in org.jetbrains.kotlin.idea.completion in file CompletionUtils.kt[PropertyDescriptorImpl]

'qualifiedName' @ [57:37] ==> private final fun qualifiedName(lookupObject: DeclarationLookupObject): String defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler[SimpleFunctionDescriptorImpl]

'lookupObject' @ [57:51] ==> val lookupObject: DeclarationLookupObject defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'file' @ [60:29] ==> val file: PsiFile defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'findElementAt' @ [60:34] ==> @Nullable @Contract public abstract fun findElementAt(p0: Int): PsiElement? defined in com.intellij.psi.PsiFile[JavaMethodDescriptor]

'startOffset' @ [60:48] ==> val startOffset: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'token' @ [61:31] ==> val token: PsiElement defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'parent' @ [61:37] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'nameRef' @ [62:21] ==> val nameRef: KtNameReferenceExpression? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'nameRef' @ [63:42] ==> val nameRef: KtNameReferenceExpression? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'analyze' @ [63:50] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'PARTIAL' @ [63:74] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'bindingContext' @ [64:34] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'SHORT_REFERENCE_TO_COMPANION_OBJECT' @ [64:64] ==> public final val SHORT_REFERENCE_TO_COMPANION_OBJECT: (WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (ClassifierDescriptorWithTypeParameters..ClassifierDescriptorWithTypeParameters?)>..WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (ClassifierDescriptorWithTypeParameters..ClassifierDescriptorWithTypeParameters?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'nameRef' @ [64:101] ==> val nameRef: KtNameReferenceExpression? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'bindingContext' @ [65:37] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'REFERENCE_TARGET' @ [65:67] ==> public final val REFERENCE_TARGET: (WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'nameRef' @ [65:85] ==> val nameRef: KtNameReferenceExpression? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'target' @ [66:25] ==> val target: ClassifierDescriptorWithTypeParameters? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'IdeDescriptorRenderers' @ [66:43] ==> public object IdeDescriptorRenderers defined in org.jetbrains.kotlin.idea.util[FakeCallableDescriptorForObject]

'SOURCE_CODE' @ [66:66] ==> @field:JvmField public final val SOURCE_CODE: DescriptorRenderer defined in org.jetbrains.kotlin.idea.util.IdeDescriptorRenderers[DeserializedPropertyDescriptor]

'renderClassifierName' @ [66:78] ==> public abstract fun renderClassifierName(klass: ClassifierDescriptor): String defined in org.jetbrains.kotlin.renderer.DescriptorRenderer[DeserializedSimpleFunctionDescriptor]

'target' @ [66:99] ==> val target: ClassifierDescriptorWithTypeParameters? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'qualifiedName' @ [66:110] ==> val qualifiedName: String defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'if (nameRef != null) {
                    val isAnnotation = CallTypeAndReceiver.detect(nameRef) is CallTypeAndReceiver.ANNOTATION
                    // we insert space so that any preceding spaces inserted by formatter on reference shortening are deleted
                    // (but not for annotations where spaces are not allowed after @)
                    if (isAnnotation) "" else " "
                }
                else {
                    "$;val v:"  // if we have no reference in the current context we have a more complicated prefix to get one
                }' @ [69:34] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'nameRef' @ [69:38] ==> val nameRef: KtNameReferenceExpression? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'CallTypeAndReceiver' @ [70:40] ==> public companion object defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver[FakeCallableDescriptorForObject]

'detect' @ [70:60] ==> public final fun detect(expression: KtSimpleNameExpression): CallTypeAndReceiver<*, *> defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion[DeserializedSimpleFunctionDescriptor]

'nameRef' @ [70:67] ==> val nameRef: KtNameReferenceExpression? defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'if (isAnnotation) "" else " "' @ [73:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'isAnnotation' @ [73:25] ==> val isAnnotation: Boolean defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'document' @ [79:17] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'replaceString' @ [79:26] ==> public abstract fun replaceString(p0: Int, p1: Int, @NotNull p2: CharSequence): Unit defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'startOffset' @ [79:40] ==> val startOffset: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'context' @ [79:53] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[ValueParameterDescriptorImpl]

'tailOffset' @ [79:61] ==> public final var InsertionContext.tailOffset: Int[MyPropertyDescriptor]

'tempPrefix' @ [79:73] ==> val tempPrefix: String defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'qualifiedName' @ [79:86] ==> val qualifiedName: String defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'tempSuffix' @ [79:102] ==> val tempSuffix: String defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'psiDocumentManager' @ [81:17] ==> val psiDocumentManager: (PsiDocumentManager..PsiDocumentManager?) defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'commitAllDocuments' @ [81:36] ==> public abstract fun commitAllDocuments(): Unit defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'startOffset' @ [83:38] ==> val startOffset: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'tempPrefix' @ [83:52] ==> val tempPrefix: String defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'length' @ [83:63] ==> public open val length: Int defined in kotlin.String[DeserializedPropertyDescriptor]

'classNameStart' @ [84:36] ==> val classNameStart: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'qualifiedName' @ [84:53] ==> val qualifiedName: String defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'length' @ [84:67] ==> public open val length: Int defined in kotlin.String[DeserializedPropertyDescriptor]

'document' @ [85:35] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'createRangeMarker' @ [85:44] ==> @NotNull public open fun createRangeMarker(p0: Int, p1: Int): RangeMarker defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'classNameStart' @ [85:62] ==> val classNameStart: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'classNameEnd' @ [85:78] ==> val classNameEnd: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'document' @ [86:40] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'createRangeMarker' @ [86:49] ==> @NotNull public open fun createRangeMarker(p0: Int, p1: Int): RangeMarker defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'startOffset' @ [86:67] ==> val startOffset: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'classNameEnd' @ [86:80] ==> val classNameEnd: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'tempSuffix' @ [86:95] ==> val tempSuffix: String defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'length' @ [86:106] ==> public open val length: Int defined in kotlin.String[DeserializedPropertyDescriptor]

'ShortenReferences' @ [88:17] ==> public companion object defined in org.jetbrains.kotlin.idea.core.ShortenReferences[FakeCallableDescriptorForObject]

'DEFAULT' @ [88:35] ==> @field:JvmField public final val DEFAULT: ShortenReferences defined in org.jetbrains.kotlin.idea.core.ShortenReferences.Companion[DeserializedPropertyDescriptor]

'process' @ [88:43] ==> public final fun process(file: KtFile, startOffset: Int, endOffset: Int): Unit defined in org.jetbrains.kotlin.idea.core.ShortenReferences[DeserializedSimpleFunctionDescriptor]

'file' @ [88:51] ==> val file: PsiFile defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'classNameStart' @ [88:57] ==> val classNameStart: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'classNameEnd' @ [88:73] ==> val classNameEnd: Int defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'psiDocumentManager' @ [89:17] ==> val psiDocumentManager: (PsiDocumentManager..PsiDocumentManager?) defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'doPostponedOperationsAndUnblockDocument' @ [89:36] ==> public abstract fun doPostponedOperationsAndUnblockDocument(@NotNull p0: Document): Unit defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'document' @ [89:76] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'rangeMarker' @ [91:21] ==> val rangeMarker: RangeMarker defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'isValid' @ [91:33] ==> public final val RangeMarker.isValid: Boolean[MyPropertyDescriptor]

'wholeRangeMarker' @ [91:44] ==> val wholeRangeMarker: RangeMarker defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'isValid' @ [91:61] ==> public final val RangeMarker.isValid: Boolean[MyPropertyDescriptor]

'document' @ [92:21] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'deleteString' @ [92:30] ==> public abstract fun deleteString(p0: Int, p1: Int): Unit defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'wholeRangeMarker' @ [92:43] ==> val wholeRangeMarker: RangeMarker defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'startOffset' @ [92:60] ==> public final val RangeMarker.startOffset: Int[MyPropertyDescriptor]

'rangeMarker' @ [92:73] ==> val rangeMarker: RangeMarker defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'startOffset' @ [92:85] ==> public final val RangeMarker.startOffset: Int[MyPropertyDescriptor]

'document' @ [93:21] ==> val document: Document defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'deleteString' @ [93:30] ==> public abstract fun deleteString(p0: Int, p1: Int): Unit defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'rangeMarker' @ [93:43] ==> val rangeMarker: RangeMarker defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'endOffset' @ [93:55] ==> public final val RangeMarker.endOffset: Int[MyPropertyDescriptor]

'wholeRangeMarker' @ [93:66] ==> val wholeRangeMarker: RangeMarker defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.handleInsert[LocalVariableDescriptor]

'endOffset' @ [93:83] ==> public final val RangeMarker.endOffset: Int[MyPropertyDescriptor]

'if (lookupObject.descriptor != null) {
            IdeDescriptorRenderers.SOURCE_CODE.renderClassifierName(lookupObject.descriptor as ClassifierDescriptor)
        }
        else {
            val qualifiedName = (lookupObject.psiElement as PsiClass).qualifiedName!!
            if (FqNameUnsafe.isValid(qualifiedName)) FqNameUnsafe(qualifiedName).render() else qualifiedName
        }' @ [100:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'lookupObject' @ [100:20] ==> value-parameter lookupObject: DeclarationLookupObject defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.qualifiedName[ValueParameterDescriptorImpl]

'descriptor' @ [100:33] ==> public abstract val descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.core.completion.DeclarationLookupObject[DeserializedPropertyDescriptor]

'SOURCE_CODE' @ [101:36] ==> @field:JvmField public final val SOURCE_CODE: DescriptorRenderer defined in org.jetbrains.kotlin.idea.util.IdeDescriptorRenderers[DeserializedPropertyDescriptor]

'renderClassifierName' @ [101:48] ==> public abstract fun renderClassifierName(klass: ClassifierDescriptor): String defined in org.jetbrains.kotlin.renderer.DescriptorRenderer[DeserializedSimpleFunctionDescriptor]

'lookupObject' @ [101:69] ==> value-parameter lookupObject: DeclarationLookupObject defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.qualifiedName[ValueParameterDescriptorImpl]

'descriptor' @ [101:82] ==> public abstract val descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.core.completion.DeclarationLookupObject[DeserializedPropertyDescriptor]

'!!' @ [104:33] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: String?): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> String

'lookupObject' @ [104:34] ==> value-parameter lookupObject: DeclarationLookupObject defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.qualifiedName[ValueParameterDescriptorImpl]

'psiElement' @ [104:47] ==> public abstract val psiElement: PsiElement? defined in org.jetbrains.kotlin.idea.core.completion.DeclarationLookupObject[DeserializedPropertyDescriptor]

'qualifiedName' @ [104:71] ==> public final val PsiClass.qualifiedName: String?[MyPropertyDescriptor]

'if (FqNameUnsafe.isValid(qualifiedName)) FqNameUnsafe(qualifiedName).render() else qualifiedName' @ [105:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'isValid' @ [105:30] ==> public open fun isValid(@Nullable p0: String?): Boolean defined in org.jetbrains.kotlin.name.FqNameUnsafe[JavaMethodDescriptor]

'qualifiedName' @ [105:38] ==> val qualifiedName: String defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.qualifiedName[LocalVariableDescriptor]

'FqNameUnsafe' @ [105:54] ==> public constructor FqNameUnsafe(@NotNull p0: String) defined in org.jetbrains.kotlin.name.FqNameUnsafe[JavaClassConstructorDescriptor]

'qualifiedName' @ [105:67] ==> val qualifiedName: String defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.qualifiedName[LocalVariableDescriptor]

'render' @ [105:82] ==> public fun FqNameUnsafe.render(): String defined in org.jetbrains.kotlin.renderer[DeserializedSimpleFunctionDescriptor]

'qualifiedName' @ [105:96] ==> val qualifiedName: String defined in org.jetbrains.kotlin.idea.completion.handlers.KotlinClassifierInsertHandler.qualifiedName[LocalVariableDescriptor]

