'nameExpression' @ [39:28] ==> value-parameter nameExpression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.isOnlyNamedArgumentExpected[ValueParameterDescriptorImpl]

'parent' @ [39:43] ==> public final val KtSimpleNameExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'thisArgument' @ [40:13] ==> val thisArgument: KtValueArgument defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.isOnlyNamedArgumentExpected[LocalVariableDescriptor]

'isNamed' @ [40:26] ==> public open fun isNamed(): Boolean defined in org.jetbrains.kotlin.psi.KtValueArgument[JavaMethodDescriptor]

'thisArgument' @ [42:27] ==> val thisArgument: KtValueArgument defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.isOnlyNamedArgumentExpected[LocalVariableDescriptor]

'getStrictParentOfType' @ [42:40] ==> public inline fun <reified T : PsiElement> PsiElement.getStrictParentOfType(): KtCallElement? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtCallElement

'callElement' @ [44:16] ==> val callElement: KtCallElement defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.isOnlyNamedArgumentExpected[LocalVariableDescriptor]

'valueArguments' @ [44:28] ==> public final val KtCallElement.valueArguments: (MutableList<out (ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>)[MyPropertyDescriptor]

'takeWhile' @ [45:18] ==> public inline fun <T> Iterable<(ValueArgument..ValueArgument?)>.takeWhile(predicate: ((ValueArgument..ValueArgument?)) -> Boolean): List<(ValueArgument..ValueArgument?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)

'it' @ [45:30] ==> value-parameter it: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.isOnlyNamedArgumentExpected.<anonymous>[ValueParameterDescriptorImpl]

'thisArgument' @ [45:36] ==> val thisArgument: KtValueArgument defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.isOnlyNamedArgumentExpected[LocalVariableDescriptor]

'any' @ [46:18] ==> public inline fun <T> Iterable<(ValueArgument..ValueArgument?)>.any(predicate: ((ValueArgument..ValueArgument?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)

'it' @ [46:24] ==> value-parameter it: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.isOnlyNamedArgumentExpected.<anonymous>[ValueParameterDescriptorImpl]

'isNamed' @ [46:27] ==> public abstract fun isNamed(): Boolean defined in org.jetbrains.kotlin.psi.ValueArgument[DeserializedSimpleFunctionDescriptor]

'callType' @ [50:13] ==> value-parameter callType: CallType<*> defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.complete[ValueParameterDescriptorImpl]

'DEFAULT' @ [50:34] ==> public object DEFAULT : CallType<Nothing?> defined in org.jetbrains.kotlin.idea.util.CallType[FakeCallableDescriptorForObject]

'HashMap' @ [52:35] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> Name
    <V : (Any..Any?)> -> MutableSet<KotlinType>

'expectedInfos' @ [53:30] ==> value-parameter expectedInfos: Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.complete[ValueParameterDescriptorImpl]

'expectedInfo' @ [54:32] ==> val expectedInfo: ExpectedInfo defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.complete[LocalVariableDescriptor]

'additionalData' @ [54:45] ==> public final val additionalData: ExpectedInfo.AdditionalData? defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[DeserializedPropertyDescriptor]

'argumentData' @ [55:31] ==> val argumentData: ArgumentPositionData.Positional defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.complete[LocalVariableDescriptor]

'namedArgumentCandidates' @ [55:44] ==> public final val namedArgumentCandidates: Collection<ParameterDescriptor> defined in org.jetbrains.kotlin.idea.core.ArgumentPositionData.Positional[DeserializedPropertyDescriptor]

'nameToParameterType' @ [56:17] ==> val nameToParameterType: HashMap<Name, MutableSet<KotlinType>> defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.complete[LocalVariableDescriptor]

'getOrPut' @ [56:37] ==> public inline fun <K, V> MutableMap<Name, MutableSet<KotlinType>>.getOrPut(key: Name, defaultValue: () -> MutableSet<KotlinType>): MutableSet<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Name
    <V> -> MutableSet<KotlinType>

'parameter' @ [56:46] ==> val parameter: ParameterDescriptor defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.complete[LocalVariableDescriptor]

'name' @ [56:56] ==> public final val ParameterDescriptor.name: Name[MyPropertyDescriptor]

'HashSet' @ [56:64] ==> public constructor HashSet<E : (Any..Any?)>() defined in java.util.HashSet[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> KotlinType

'add' @ [56:76] ==> public abstract fun add(element: KotlinType): Boolean defined in kotlin.collections.MutableSet[DeserializedSimpleFunctionDescriptor]

'parameter' @ [56:80] ==> val parameter: ParameterDescriptor defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.complete[LocalVariableDescriptor]

'type' @ [56:90] ==> public final val ParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'component1' @ [60:15] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<Name, MutableSet<KotlinType>>.component1(): Name defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Name
    <V> -> MutableSet<KotlinType>

'component2' @ [60:21] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<Name, MutableSet<KotlinType>>.component2(): MutableSet<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Name
    <V> -> MutableSet<KotlinType>

'nameToParameterType' @ [60:31] ==> val nameToParameterType: HashMap<Name, MutableSet<KotlinType>> defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.complete[LocalVariableDescriptor]

'types' @ [61:28] ==> val types: MutableSet<KotlinType> defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.complete[LocalVariableDescriptor]

'singleOrNull' @ [61:34] ==> public fun <T> Iterable<KotlinType>.singleOrNull(): KotlinType? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'let' @ [61:50] ==> @InlineOnly public inline fun <T, R> KotlinType.let(block: (KotlinType) -> String): String defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType
    <R> -> String

'BasicLookupElementFactory' @ [61:56] ==> public companion object defined in org.jetbrains.kotlin.idea.completion.BasicLookupElementFactory[FakeCallableDescriptorForObject]

'SHORT_NAMES_RENDERER' @ [61:82] ==> public final val SHORT_NAMES_RENDERER: DescriptorRenderer defined in org.jetbrains.kotlin.idea.completion.BasicLookupElementFactory.Companion[PropertyDescriptorImpl]

'renderType' @ [61:103] ==> public abstract fun renderType(type: KotlinType): String defined in org.jetbrains.kotlin.renderer.DescriptorRenderer[DeserializedSimpleFunctionDescriptor]

'it' @ [61:114] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.complete.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [62:30] ==> val name: Name defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.complete[LocalVariableDescriptor]

'asString' @ [62:35] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'create' @ [63:54] ==> @NotNull public open fun create(@NotNull p0: String): LookupElementBuilder defined in com.intellij.codeInsight.lookup.LookupElementBuilder[JavaMethodDescriptor]

'nameString' @ [63:63] ==> val nameString: String defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.complete[LocalVariableDescriptor]

'withPresentableText' @ [64:22] ==> @Contract public open fun withPresentableText(@NotNull p0: String): (LookupElementBuilder..LookupElementBuilder?) defined in com.intellij.codeInsight.lookup.LookupElementBuilder[JavaMethodDescriptor]

'nameString' @ [64:44] ==> val nameString: String defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.complete[LocalVariableDescriptor]

'withTailText' @ [65:22] ==> @Contract public open fun withTailText(@Nullable p0: String?): (LookupElementBuilder..LookupElementBuilder?) defined in com.intellij.codeInsight.lookup.LookupElementBuilder[JavaMethodDescriptor]

'typeText' @ [65:38] ==> val typeText: String defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.complete[LocalVariableDescriptor]

'withIcon' @ [66:22] ==> @Contract public open fun withIcon(@Nullable p0: Icon?): (LookupElementBuilder..LookupElementBuilder?) defined in com.intellij.codeInsight.lookup.LookupElementBuilder[JavaMethodDescriptor]

'PARAMETER' @ [66:43] ==> public final val PARAMETER: (Icon..Icon?) defined in org.jetbrains.kotlin.idea.KotlinIcons[JavaPropertyDescriptor]

'withInsertHandler' @ [67:22] ==> @Contract public open fun withInsertHandler(@Nullable p0: InsertHandler<(LookupElement..LookupElement?)>?): (LookupElementBuilder..LookupElementBuilder?) defined in com.intellij.codeInsight.lookup.LookupElementBuilder[JavaMethodDescriptor]

'NamedArgumentInsertHandler' @ [67:40] ==> public constructor NamedArgumentInsertHandler(parameterName: Name) defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.NamedArgumentInsertHandler[ClassConstructorDescriptorImpl]

'name' @ [67:67] ==> val name: Name defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.complete[LocalVariableDescriptor]

'lookupElement' @ [68:13] ==> val lookupElement: (LookupElementBuilder..LookupElementBuilder?) defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.complete[LocalVariableDescriptor]

'putUserData' @ [68:27] ==> public open fun <T : (Any..Any?)> putUserData(@NotNull p0: Key<(Unit..Unit?)>, @Nullable p1: Unit?): Unit defined in com.intellij.codeInsight.lookup.LookupElementBuilder[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Unit

'SmartCompletionInBasicWeigher' @ [68:39] ==> public companion object defined in org.jetbrains.kotlin.idea.completion.SmartCompletionInBasicWeigher[FakeCallableDescriptorForObject]

'NAMED_ARGUMENT_KEY' @ [68:69] ==> public final val NAMED_ARGUMENT_KEY: Key<Unit> defined in org.jetbrains.kotlin.idea.completion.SmartCompletionInBasicWeigher.Companion[PropertyDescriptorImpl]

'Unit' @ [68:89] ==> public object Unit defined in kotlin[FakeCallableDescriptorForObject]

'collector' @ [69:13] ==> value-parameter collector: LookupElementsCollector defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.complete[ValueParameterDescriptorImpl]

'addElement' @ [69:23] ==> public final fun addElement(element: LookupElement, notImported: Boolean = ...): Unit defined in org.jetbrains.kotlin.idea.completion.LookupElementsCollector[SimpleFunctionDescriptorImpl]

'lookupElement' @ [69:34] ==> val lookupElement: (LookupElementBuilder..LookupElementBuilder?) defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.complete[LocalVariableDescriptor]

'context' @ [75:26] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.NamedArgumentInsertHandler.handleInsert[ValueParameterDescriptorImpl]

'editor' @ [75:34] ==> public final val InsertionContext.editor: Editor[MyPropertyDescriptor]

'parameterName' @ [76:24] ==> private final val parameterName: Name defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.NamedArgumentInsertHandler[PropertyDescriptorImpl]

'render' @ [76:38] ==> public fun Name.render(): String defined in org.jetbrains.kotlin.renderer[DeserializedSimpleFunctionDescriptor]

'editor' @ [77:13] ==> val editor: Editor defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.NamedArgumentInsertHandler.handleInsert[LocalVariableDescriptor]

'document' @ [77:20] ==> public final val Editor.document: Document[MyPropertyDescriptor]

'replaceString' @ [77:29] ==> public abstract fun replaceString(p0: Int, p1: Int, @NotNull p2: CharSequence): Unit defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'context' @ [77:43] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.NamedArgumentInsertHandler.handleInsert[ValueParameterDescriptorImpl]

'startOffset' @ [77:51] ==> public final val InsertionContext.startOffset: Int[MyPropertyDescriptor]

'context' @ [77:64] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.NamedArgumentInsertHandler.handleInsert[ValueParameterDescriptorImpl]

'tailOffset' @ [77:72] ==> public final var InsertionContext.tailOffset: Int[MyPropertyDescriptor]

'text' @ [77:84] ==> val text: String defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.NamedArgumentInsertHandler.handleInsert[LocalVariableDescriptor]

'editor' @ [78:13] ==> val editor: Editor defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.NamedArgumentInsertHandler.handleInsert[LocalVariableDescriptor]

'caretModel' @ [78:20] ==> public final val Editor.caretModel: CaretModel[MyPropertyDescriptor]

'moveToOffset' @ [78:31] ==> public abstract fun moveToOffset(p0: Int): Unit defined in com.intellij.openapi.editor.CaretModel[JavaMethodDescriptor]

'context' @ [78:44] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.NamedArgumentInsertHandler.handleInsert[ValueParameterDescriptorImpl]

'startOffset' @ [78:52] ==> public final val InsertionContext.startOffset: Int[MyPropertyDescriptor]

'text' @ [78:66] ==> val text: String defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.NamedArgumentInsertHandler.handleInsert[LocalVariableDescriptor]

'length' @ [78:71] ==> public open val length: Int defined in kotlin.String[DeserializedPropertyDescriptor]

'WithTailInsertHandler' @ [80:13] ==> public companion object defined in org.jetbrains.kotlin.idea.completion.handlers.WithTailInsertHandler[FakeCallableDescriptorForObject]

'EQ' @ [80:35] ==> public final val EQ: WithTailInsertHandler defined in org.jetbrains.kotlin.idea.completion.handlers.WithTailInsertHandler.Companion[PropertyDescriptorImpl]

'postHandleInsert' @ [80:38] ==> public final fun postHandleInsert(context: InsertionContext, item: LookupElement): Unit defined in org.jetbrains.kotlin.idea.completion.handlers.WithTailInsertHandler[SimpleFunctionDescriptorImpl]

'context' @ [80:55] ==> value-parameter context: InsertionContext defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.NamedArgumentInsertHandler.handleInsert[ValueParameterDescriptorImpl]

'item' @ [80:64] ==> value-parameter item: LookupElement defined in org.jetbrains.kotlin.idea.completion.NamedArgumentCompletion.NamedArgumentInsertHandler.handleInsert[ValueParameterDescriptorImpl]

