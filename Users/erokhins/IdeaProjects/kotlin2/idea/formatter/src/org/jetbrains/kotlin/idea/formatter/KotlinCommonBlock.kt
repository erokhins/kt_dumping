'create' @ [36:44] ==> @NotNull public open fun create(@NotNull vararg p0: (IElementType..IElementType?)): TokenSet defined in com.intellij.psi.tree.TokenSet[JavaMethodDescriptor]

'DOT' @ [36:51] ==> public final val DOT: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'SAFE_ACCESS' @ [36:56] ==> public final val SAFE_ACCESS: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'create' @ [39:43] ==> @NotNull public open fun create(@NotNull vararg p0: (IElementType..IElementType?)): TokenSet defined in com.intellij.psi.tree.TokenSet[JavaMethodDescriptor]

'BINARY_EXPRESSION' @ [39:62] ==> public final val BINARY_EXPRESSION: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'BINARY_WITH_TYPE' @ [39:93] ==> public final val BINARY_WITH_TYPE: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'IS_EXPRESSION' @ [39:123] ==> public final val IS_EXPRESSION: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'create' @ [40:37] ==> @NotNull public open fun create(@NotNull vararg p0: (IElementType..IElementType?)): TokenSet defined in com.intellij.psi.tree.TokenSet[JavaMethodDescriptor]

'KDOC' @ [40:55] ==> public final val KDOC: (ILazyParseableElementType..ILazyParseableElementType?) defined in org.jetbrains.kotlin.kdoc.lexer.KDocTokens[JavaPropertyDescriptor]

'KDOC_SECTION' @ [40:78] ==> public final val KDOC_SECTION: (KDocElementType..KDocElementType?) defined in org.jetbrains.kotlin.kdoc.parser.KDocElementTypes[JavaPropertyDescriptor]

'KDOC_TAG' @ [40:109] ==> public final val KDOC_TAG: (KDocElementType..KDocElementType?) defined in org.jetbrains.kotlin.kdoc.parser.KDocElementTypes[JavaPropertyDescriptor]

'create' @ [42:36] ==> @NotNull public open fun create(@NotNull vararg p0: (IElementType..IElementType?)): TokenSet defined in com.intellij.psi.tree.TokenSet[JavaMethodDescriptor]

'BLOCK' @ [42:55] ==> public final val BLOCK: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'CLASS_BODY' @ [42:74] ==> public final val CLASS_BODY: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'FUNCTION_LITERAL' @ [42:98] ==> public final val FUNCTION_LITERAL: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'create' @ [44:52] ==> @NotNull public open fun create(@NotNull vararg p0: (IElementType..IElementType?)): TokenSet defined in com.intellij.psi.tree.TokenSet[JavaMethodDescriptor]

'MUL' @ [44:59] ==> public final val MUL: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'DIV' @ [44:64] ==> public final val DIV: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'PERC' @ [44:69] ==> public final val PERC: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'PLUS' @ [44:75] ==> public final val PLUS: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'MINUS' @ [44:81] ==> public final val MINUS: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'ELVIS' @ [44:88] ==> public final val ELVIS: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'LT' @ [44:95] ==> public final val LT: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'GT' @ [44:99] ==> public final val GT: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'LTEQ' @ [44:103] ==> public final val LTEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'GTEQ' @ [44:109] ==> public final val GTEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'ANDAND' @ [44:115] ==> public final val ANDAND: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'OROR' @ [44:123] ==> public final val OROR: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'create' @ [45:36] ==> @NotNull public open fun create(@NotNull vararg p0: (IElementType..IElementType?)): TokenSet defined in com.intellij.psi.tree.TokenSet[JavaMethodDescriptor]

'ANNOTATION_ENTRY' @ [45:55] ==> public final val ANNOTATION_ENTRY: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'ANNOTATION' @ [45:85] ==> public final val ANNOTATION: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'getCustomSettings' @ [48:13] ==> public open fun <T : (CustomCodeStyleSettings..CustomCodeStyleSettings?)> getCustomSettings(@NotNull p0: Class<(KotlinCodeStyleSettings..KotlinCodeStyleSettings?)>): (KotlinCodeStyleSettings..KotlinCodeStyleSettings?) defined in com.intellij.psi.codeStyle.CodeStyleSettings[JavaMethodDescriptor]
Inferred types:
    <T : (CustomCodeStyleSettings..CustomCodeStyleSettings?)> -> (org.jetbrains.kotlin.idea.core.formatter.KotlinCodeStyleSettings..org.jetbrains.kotlin.idea.core.formatter.KotlinCodeStyleSettings?)

'KotlinCodeStyleSettings' @ [48:31] ==> public constructor KotlinCodeStyleSettings(container: (CodeStyleSettings..CodeStyleSettings?)) defined in org.jetbrains.kotlin.idea.core.formatter.KotlinCodeStyleSettings[JavaClassConstructorDescriptor]

'java' @ [48:62] ==> public val <T> KClass<KotlinCodeStyleSettings>.java: Class<KotlinCodeStyleSettings> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KotlinCodeStyleSettings

'Volatile' @ [55:13] ==> public constructor Volatile() defined in kotlin.jvm.Volatile[DeserializedClassConstructorDescriptor]

'node' @ [80:29] ==> private final val node: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'firstChildNode' @ [80:34] ==> public final val ASTNode.firstChildNode: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'mySubBlocks' @ [83:13] ==> @Volatile private final var mySubBlocks: List<Block>? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'mySubBlocks' @ [84:20] ==> @Volatile private final var mySubBlocks: List<Block>? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'buildSubBlocks' @ [87:29] ==> private final fun buildSubBlocks(): ArrayList<Block> defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[SimpleFunctionDescriptorImpl]

'node' @ [89:13] ==> private final val node: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'elementType' @ [89:18] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'DOT_QUALIFIED_EXPRESSION' @ [89:46] ==> public final val DOT_QUALIFIED_EXPRESSION: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'node' @ [89:74] ==> private final val node: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'elementType' @ [89:79] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'SAFE_ACCESS_EXPRESSION' @ [89:107] ==> public final val SAFE_ACCESS_EXPRESSION: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'findNodeBlockIndex' @ [90:39] ==> private fun findNodeBlockIndex(blocks: List<Block>, tokenSet: TokenSet): Int defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[SimpleFunctionDescriptorImpl]

'nodeSubBlocks' @ [90:58] ==> var nodeSubBlocks: ArrayList<Block> defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildChildren[LocalVariableDescriptor]

'QUALIFIED_OPERATION' @ [90:73] ==> private val QUALIFIED_OPERATION: TokenSet defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[PropertyDescriptorImpl]

'operationBlockIndex' @ [91:17] ==> val operationBlockIndex: Int defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildChildren[LocalVariableDescriptor]

'-' @ [91:40] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'nodeSubBlocks' @ [95:38] ==> var nodeSubBlocks: ArrayList<Block> defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildChildren[LocalVariableDescriptor]

'operationBlockIndex' @ [95:52] ==> val operationBlockIndex: Int defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildChildren[LocalVariableDescriptor]

'if (settings.kotlinSettings.CONTINUATION_INDENT_FOR_CHAINED_CALLS)
                    Indent.getContinuationWithoutFirstIndent()
                else
                    Indent.getNormalIndent()' @ [96:30] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (Indent..Indent?), elseBranch: (Indent..Indent?)): (Indent..Indent?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (com.intellij.formatting.Indent..com.intellij.formatting.Indent?)

'settings' @ [96:34] ==> private final val settings: CodeStyleSettings defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'kotlinSettings' @ [96:43] ==> public val CodeStyleSettings.kotlinSettings: (KotlinCodeStyleSettings..KotlinCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[PropertyDescriptorImpl]

'CONTINUATION_INDENT_FOR_CHAINED_CALLS' @ [96:58] ==> public final var CONTINUATION_INDENT_FOR_CHAINED_CALLS: Boolean defined in org.jetbrains.kotlin.idea.core.formatter.KotlinCodeStyleSettings[JavaPropertyDescriptor]

'getContinuationWithoutFirstIndent' @ [97:28] ==> public open fun getContinuationWithoutFirstIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'getNormalIndent' @ [99:28] ==> public open fun getNormalIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'SyntheticKotlinBlock' @ [100:47] ==> public constructor SyntheticKotlinBlock(node: ASTNode, subBlocks: MutableList<Block>, alignment: Alignment?, indent: Indent?, wrap: Wrap?, spacingBuilder: KotlinSpacingBuilder, createSyntheticSpacingNodeBlock: (ASTNode) -> ASTBlock) defined in org.jetbrains.kotlin.idea.formatter.SyntheticKotlinBlock[ClassConstructorDescriptorImpl]

'operationBlock' @ [101:26] ==> val operationBlock: Block defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildChildren[LocalVariableDescriptor]

'node' @ [101:54] ==> public final val ASTBlock.node: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'nodeSubBlocks' @ [102:25] ==> var nodeSubBlocks: ArrayList<Block> defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildChildren[LocalVariableDescriptor]

'subList' @ [102:39] ==> public open fun subList(fromIndex: Int, toIndex: Int): MutableList<Block> defined in java.util.ArrayList[JavaMethodDescriptor]

'operationBlockIndex' @ [102:47] ==> val operationBlockIndex: Int defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildChildren[LocalVariableDescriptor]

'nodeSubBlocks' @ [102:68] ==> var nodeSubBlocks: ArrayList<Block> defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildChildren[LocalVariableDescriptor]

'size' @ [102:82] ==> public open val size: Int defined in java.util.ArrayList[JavaPropertyDescriptor]

'indent' @ [103:31] ==> val indent: (Indent..Indent?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildChildren[LocalVariableDescriptor]

'spacingBuilder' @ [103:45] ==> private final val spacingBuilder: KotlinSpacingBuilder defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'createSyntheticSpacingNodeBlock' @ [103:63] ==> protected abstract fun createSyntheticSpacingNodeBlock(node: ASTNode): ASTBlock defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[SimpleFunctionDescriptorImpl]

'it' @ [103:95] ==> value-parameter it: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildChildren.<anonymous>[ValueParameterDescriptorImpl]

'nodeSubBlocks' @ [105:17] ==> var nodeSubBlocks: ArrayList<Block> defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildChildren[LocalVariableDescriptor]

'ArrayList' @ [105:33] ==> public constructor ArrayList<E : (Any..Any?)>(p0: (MutableCollection<out (Block..Block?)>..Collection<(Block..Block?)>?)) defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> Block

'nodeSubBlocks' @ [105:50] ==> var nodeSubBlocks: ArrayList<Block> defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildChildren[LocalVariableDescriptor]

'subList' @ [105:64] ==> public open fun subList(fromIndex: Int, toIndex: Int): MutableList<Block> defined in java.util.ArrayList[JavaMethodDescriptor]

'operationBlockIndex' @ [105:75] ==> val operationBlockIndex: Int defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildChildren[LocalVariableDescriptor]

'nodeSubBlocks' @ [106:17] ==> var nodeSubBlocks: ArrayList<Block> defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildChildren[LocalVariableDescriptor]

'add' @ [106:31] ==> public open fun add(element: Block): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'operationSyntheticBlock' @ [106:35] ==> val operationSyntheticBlock: SyntheticKotlinBlock defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildChildren[LocalVariableDescriptor]

'mySubBlocks' @ [110:9] ==> @Volatile private final var mySubBlocks: List<Block>? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'nodeSubBlocks' @ [110:23] ==> var nodeSubBlocks: ArrayList<Block> defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildChildren[LocalVariableDescriptor]

'nodeSubBlocks' @ [112:16] ==> var nodeSubBlocks: ArrayList<Block> defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildChildren[LocalVariableDescriptor]

'child' @ [116:27] ==> value-parameter child: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[ValueParameterDescriptorImpl]

'treeParent' @ [116:33] ==> public final val ASTNode.treeParent: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'child' @ [117:25] ==> value-parameter child: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[ValueParameterDescriptorImpl]

'elementType' @ [117:31] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'childParent' @ [119:13] ==> val childParent: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[LocalVariableDescriptor]

'treeParent' @ [119:26] ==> public final val ASTNode.treeParent: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'childParent' @ [120:17] ==> val childParent: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[LocalVariableDescriptor]

'elementType' @ [120:29] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'BLOCK' @ [120:57] ==> public final val BLOCK: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'childParent' @ [120:66] ==> val childParent: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[LocalVariableDescriptor]

'treeParent' @ [120:78] ==> public final val ASTNode.treeParent: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'elementType' @ [120:89] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'SCRIPT' @ [120:117] ==> public final val SCRIPT: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'getNoneIndent' @ [121:31] ==> public open fun getNoneIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'childParent' @ [126:13] ==> val childParent: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[LocalVariableDescriptor]

'childParent' @ [126:36] ==> val childParent: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[LocalVariableDescriptor]

'psi' @ [126:48] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'getPrevWithoutWhitespace' @ [127:24] ==> private fun getPrevWithoutWhitespace(pNode: ASTNode?): ASTNode? defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[SimpleFunctionDescriptorImpl]

'child' @ [127:49] ==> value-parameter child: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[ValueParameterDescriptorImpl]

'prev' @ [128:17] ==> val prev: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[LocalVariableDescriptor]

'COMMENTS' @ [128:33] ==> public final val COMMENTS: (TokenSet..TokenSet?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'contains' @ [128:42] ==> public open operator fun contains(@Nullable p0: IElementType?): Boolean defined in com.intellij.psi.tree.TokenSet[JavaMethodDescriptor]

'prev' @ [128:51] ==> val prev: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[LocalVariableDescriptor]

'elementType' @ [128:56] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'getPrevWithoutWhitespaceAndComments' @ [128:72] ==> private fun getPrevWithoutWhitespaceAndComments(pNode: ASTNode?): ASTNode? defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[SimpleFunctionDescriptorImpl]

'prev' @ [128:108] ==> val prev: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[LocalVariableDescriptor]

'getNoneIndent' @ [129:31] ==> public open fun getNoneIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'INDENT_RULES' @ [133:26] ==> private val INDENT_RULES: Array<NodeIndentStrategy> defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[PropertyDescriptorImpl]

'strategy' @ [134:26] ==> val strategy: NodeIndentStrategy defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[LocalVariableDescriptor]

'getIndent' @ [134:35] ==> public abstract fun getIndent(node: ASTNode, settings: CodeStyleSettings): Indent? defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy[SimpleFunctionDescriptorImpl]

'child' @ [134:45] ==> value-parameter child: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[ValueParameterDescriptorImpl]

'settings' @ [134:52] ==> private final val settings: CodeStyleSettings defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'indent' @ [135:17] ==> val indent: Indent? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[LocalVariableDescriptor]

'indent' @ [136:24] ==> val indent: Indent? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[LocalVariableDescriptor]

'childParent' @ [141:13] ==> val childParent: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[LocalVariableDescriptor]

'childParent' @ [142:30] ==> val childParent: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[LocalVariableDescriptor]

'elementType' @ [142:42] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'parentType' @ [144:17] ==> val parentType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[LocalVariableDescriptor]

'VALUE_PARAMETER_LIST' @ [144:44] ==> public final val VALUE_PARAMETER_LIST: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'parentType' @ [144:68] ==> val parentType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[LocalVariableDescriptor]

'VALUE_ARGUMENT_LIST' @ [144:95] ==> public final val VALUE_ARGUMENT_LIST: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'getPrevWithoutWhitespace' @ [145:28] ==> private fun getPrevWithoutWhitespace(pNode: ASTNode?): ASTNode? defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[SimpleFunctionDescriptorImpl]

'child' @ [145:53] ==> value-parameter child: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[ValueParameterDescriptorImpl]

'childType' @ [146:21] ==> val childType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[LocalVariableDescriptor]

'RPAR' @ [146:35] ==> public final val RPAR: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'prev' @ [146:44] ==> val prev: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[LocalVariableDescriptor]

'prev' @ [146:60] ==> val prev: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[LocalVariableDescriptor]

'elementType' @ [146:65] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'ERROR_ELEMENT' @ [146:91] ==> public final val ERROR_ELEMENT: (IElementType..IElementType?) defined in com.intellij.psi.TokenType[JavaPropertyDescriptor]

'getNoneIndent' @ [147:35] ==> public open fun getNoneIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'getContinuationWithoutFirstIndent' @ [150:31] ==> public open fun getContinuationWithoutFirstIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'parentType' @ [153:17] ==> val parentType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[LocalVariableDescriptor]

'TYPE_PARAMETER_LIST' @ [153:44] ==> public final val TYPE_PARAMETER_LIST: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'parentType' @ [153:67] ==> val parentType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.createChildIndent[LocalVariableDescriptor]

'TYPE_ARGUMENT_LIST' @ [153:94] ==> public final val TYPE_ARGUMENT_LIST: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'getContinuationWithoutFirstIndent' @ [154:31] ==> public open fun getContinuationWithoutFirstIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'getNoneIndent' @ [158:23] ==> public open fun getNoneIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'node' @ [162:20] ==> private final val node: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'elementType' @ [162:25] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'node' @ [164:13] ==> private final val node: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'elementType' @ [164:18] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'BLOCK' @ [164:45] ==> public final val BLOCK: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'node' @ [164:54] ==> private final val node: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'treeParent' @ [164:59] ==> public final val ASTNode.treeParent: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'elementType' @ [164:70] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'SCRIPT' @ [164:97] ==> public final val SCRIPT: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'ChildAttributes' @ [165:20] ==> public constructor ChildAttributes(@Nullable p0: Indent?, @Nullable p1: Alignment?) defined in com.intellij.formatting.ChildAttributes[JavaClassConstructorDescriptor]

'getNoneIndent' @ [165:43] ==> public open fun getNoneIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'type' @ [168:13] ==> val type: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[LocalVariableDescriptor]

'IF' @ [168:33] ==> public final val IF: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'mySubBlocks' @ [169:29] ==> @Volatile private final var mySubBlocks: List<Block>? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'getOrNull' @ [169:42] ==> public fun <T> List<Block>.getOrNull(index: Int): Block? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Block

'newChildIndex' @ [169:52] ==> value-parameter newChildIndex: Int defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[ValueParameterDescriptorImpl]

'elseBlock' @ [170:17] ==> val elseBlock: Block? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[LocalVariableDescriptor]

'elseBlock' @ [170:42] ==> val elseBlock: Block? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[LocalVariableDescriptor]

'node' @ [170:52] ==> public final val ASTBlock.node: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'elementType' @ [170:57] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'ELSE_KEYWORD' @ [170:81] ==> public final val ELSE_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'DELEGATE_TO_NEXT_CHILD' @ [171:40] ==> public final val DELEGATE_TO_NEXT_CHILD: (ChildAttributes..ChildAttributes?) defined in com.intellij.formatting.ChildAttributes[JavaPropertyDescriptor]

'when (type) {
            in CODE_BLOCKS, KtNodeTypes.WHEN, KtNodeTypes.IF, KtNodeTypes.FOR, KtNodeTypes.WHILE, KtNodeTypes.DO_WHILE -> ChildAttributes(Indent.getNormalIndent(), null)

            KtNodeTypes.TRY -> ChildAttributes(Indent.getNoneIndent(), null)

            KtNodeTypes.DOT_QUALIFIED_EXPRESSION, KtNodeTypes.SAFE_ACCESS_EXPRESSION -> ChildAttributes(Indent.getContinuationWithoutFirstIndent(), null)

            KtNodeTypes.VALUE_PARAMETER_LIST, KtNodeTypes.VALUE_ARGUMENT_LIST -> {
                val subBlocks = getSubBlocks()
                if (newChildIndex != 1 && newChildIndex != 0 && newChildIndex < subBlocks.size) {
                    val block = subBlocks[newChildIndex]
                    ChildAttributes(block.indent, block.alignment)
                }
                else {
                    val indent = if (type == KtNodeTypes.VALUE_PARAMETER_LIST && !settings.kotlinSettings.CONTINUATION_INDENT_IN_PARAMETER_LISTS)
                        Indent.getNormalIndent()
                    else
                        Indent.getContinuationIndent()
                    ChildAttributes(indent, null)
                }
            }

            DOC_COMMENT -> ChildAttributes(Indent.getSpaceIndent(KDOC_COMMENT_INDENT), null)

            KtNodeTypes.PARENTHESIZED -> getSuperChildAttributes(newChildIndex)

            else -> {
                val blocks = getSubBlocks()
                if (newChildIndex != 0) {
                    val isIncomplete = if (newChildIndex < blocks.size) blocks[newChildIndex - 1].isIncomplete else isIncompleteInSuper()
                    if (isIncomplete) {
                        return getSuperChildAttributes(newChildIndex)
                    }
                }

                if (blocks.size > newChildIndex) {
                    val block = blocks[newChildIndex]
                    return ChildAttributes(block.indent, block.alignment)
                }

                ChildAttributes(Indent.getNoneIndent(), null)
            }
        }' @ [175:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: ChildAttributes, entry1: ChildAttributes, entry2: ChildAttributes, entry3: ChildAttributes, entry4: ChildAttributes, entry5: ChildAttributes, entry6: ChildAttributes): ChildAttributes[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> ChildAttributes

'type' @ [175:22] ==> val type: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[LocalVariableDescriptor]

'in' @ [176:13] ==> public open operator fun contains(@Nullable p0: IElementType?): Boolean defined in com.intellij.psi.tree.TokenSet[JavaMethodDescriptor]

'CODE_BLOCKS' @ [176:16] ==> private val CODE_BLOCKS: TokenSet defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[PropertyDescriptorImpl]

'WHEN' @ [176:41] ==> public final val WHEN: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'IF' @ [176:59] ==> public final val IF: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'FOR' @ [176:75] ==> public final val FOR: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'WHILE' @ [176:92] ==> public final val WHILE: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'DO_WHILE' @ [176:111] ==> public final val DO_WHILE: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'ChildAttributes' @ [176:123] ==> public constructor ChildAttributes(@Nullable p0: Indent?, @Nullable p1: Alignment?) defined in com.intellij.formatting.ChildAttributes[JavaClassConstructorDescriptor]

'getNormalIndent' @ [176:146] ==> public open fun getNormalIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'TRY' @ [178:25] ==> public final val TRY: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'ChildAttributes' @ [178:32] ==> public constructor ChildAttributes(@Nullable p0: Indent?, @Nullable p1: Alignment?) defined in com.intellij.formatting.ChildAttributes[JavaClassConstructorDescriptor]

'getNoneIndent' @ [178:55] ==> public open fun getNoneIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'DOT_QUALIFIED_EXPRESSION' @ [180:25] ==> public final val DOT_QUALIFIED_EXPRESSION: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'SAFE_ACCESS_EXPRESSION' @ [180:63] ==> public final val SAFE_ACCESS_EXPRESSION: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'ChildAttributes' @ [180:89] ==> public constructor ChildAttributes(@Nullable p0: Indent?, @Nullable p1: Alignment?) defined in com.intellij.formatting.ChildAttributes[JavaClassConstructorDescriptor]

'getContinuationWithoutFirstIndent' @ [180:112] ==> public open fun getContinuationWithoutFirstIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'VALUE_PARAMETER_LIST' @ [182:25] ==> public final val VALUE_PARAMETER_LIST: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'VALUE_ARGUMENT_LIST' @ [182:59] ==> public final val VALUE_ARGUMENT_LIST: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'getSubBlocks' @ [183:33] ==> protected abstract fun getSubBlocks(): List<Block> defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[SimpleFunctionDescriptorImpl]

'if (newChildIndex != 1 && newChildIndex != 0 && newChildIndex < subBlocks.size) {
                    val block = subBlocks[newChildIndex]
                    ChildAttributes(block.indent, block.alignment)
                }
                else {
                    val indent = if (type == KtNodeTypes.VALUE_PARAMETER_LIST && !settings.kotlinSettings.CONTINUATION_INDENT_IN_PARAMETER_LISTS)
                        Indent.getNormalIndent()
                    else
                        Indent.getContinuationIndent()
                    ChildAttributes(indent, null)
                }' @ [184:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: ChildAttributes, elseBranch: ChildAttributes): ChildAttributes[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> ChildAttributes

'newChildIndex' @ [184:21] ==> value-parameter newChildIndex: Int defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[ValueParameterDescriptorImpl]

'newChildIndex' @ [184:43] ==> value-parameter newChildIndex: Int defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[ValueParameterDescriptorImpl]

'newChildIndex' @ [184:65] ==> value-parameter newChildIndex: Int defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[ValueParameterDescriptorImpl]

'subBlocks' @ [184:81] ==> val subBlocks: List<Block> defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[LocalVariableDescriptor]

'size' @ [184:91] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'subBlocks' @ [185:33] ==> val subBlocks: List<Block> defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[LocalVariableDescriptor]

'newChildIndex' @ [185:43] ==> value-parameter newChildIndex: Int defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[ValueParameterDescriptorImpl]

'ChildAttributes' @ [186:21] ==> public constructor ChildAttributes(@Nullable p0: Indent?, @Nullable p1: Alignment?) defined in com.intellij.formatting.ChildAttributes[JavaClassConstructorDescriptor]

'block' @ [186:37] ==> val block: Block defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[LocalVariableDescriptor]

'indent' @ [186:43] ==> public final val Block.indent: Indent?[MyPropertyDescriptor]

'block' @ [186:51] ==> val block: Block defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[LocalVariableDescriptor]

'alignment' @ [186:57] ==> public final val Block.alignment: Alignment?[MyPropertyDescriptor]

'if (type == KtNodeTypes.VALUE_PARAMETER_LIST && !settings.kotlinSettings.CONTINUATION_INDENT_IN_PARAMETER_LISTS)
                        Indent.getNormalIndent()
                    else
                        Indent.getContinuationIndent()' @ [189:34] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (Indent..Indent?), elseBranch: (Indent..Indent?)): (Indent..Indent?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (com.intellij.formatting.Indent..com.intellij.formatting.Indent?)

'type' @ [189:38] ==> val type: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[LocalVariableDescriptor]

'VALUE_PARAMETER_LIST' @ [189:58] ==> public final val VALUE_PARAMETER_LIST: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'!' @ [189:82] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'settings' @ [189:83] ==> private final val settings: CodeStyleSettings defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'kotlinSettings' @ [189:92] ==> public val CodeStyleSettings.kotlinSettings: (KotlinCodeStyleSettings..KotlinCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[PropertyDescriptorImpl]

'CONTINUATION_INDENT_IN_PARAMETER_LISTS' @ [189:107] ==> public final var CONTINUATION_INDENT_IN_PARAMETER_LISTS: Boolean defined in org.jetbrains.kotlin.idea.core.formatter.KotlinCodeStyleSettings[JavaPropertyDescriptor]

'getNormalIndent' @ [190:32] ==> public open fun getNormalIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'getContinuationIndent' @ [192:32] ==> public open fun getContinuationIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'ChildAttributes' @ [193:21] ==> public constructor ChildAttributes(@Nullable p0: Indent?, @Nullable p1: Alignment?) defined in com.intellij.formatting.ChildAttributes[JavaClassConstructorDescriptor]

'indent' @ [193:37] ==> val indent: (Indent..Indent?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[LocalVariableDescriptor]

'DOC_COMMENT' @ [197:13] ==> public final val DOC_COMMENT: (IElementType..IElementType?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'ChildAttributes' @ [197:28] ==> public constructor ChildAttributes(@Nullable p0: Indent?, @Nullable p1: Alignment?) defined in com.intellij.formatting.ChildAttributes[JavaClassConstructorDescriptor]

'getSpaceIndent' @ [197:51] ==> public open fun getSpaceIndent(p0: Int): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'KDOC_COMMENT_INDENT' @ [197:66] ==> private val KDOC_COMMENT_INDENT: Int defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[PropertyDescriptorImpl]

'PARENTHESIZED' @ [199:25] ==> public final val PARENTHESIZED: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'getSuperChildAttributes' @ [199:42] ==> protected abstract fun getSuperChildAttributes(newChildIndex: Int): ChildAttributes defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[SimpleFunctionDescriptorImpl]

'newChildIndex' @ [199:66] ==> value-parameter newChildIndex: Int defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[ValueParameterDescriptorImpl]

'getSubBlocks' @ [202:30] ==> protected abstract fun getSubBlocks(): List<Block> defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[SimpleFunctionDescriptorImpl]

'newChildIndex' @ [203:21] ==> value-parameter newChildIndex: Int defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[ValueParameterDescriptorImpl]

'if (newChildIndex < blocks.size) blocks[newChildIndex - 1].isIncomplete else isIncompleteInSuper()' @ [204:40] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Boolean, elseBranch: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Boolean

'newChildIndex' @ [204:44] ==> value-parameter newChildIndex: Int defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[ValueParameterDescriptorImpl]

'blocks' @ [204:60] ==> val blocks: List<Block> defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[LocalVariableDescriptor]

'size' @ [204:67] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'blocks' @ [204:73] ==> val blocks: List<Block> defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[LocalVariableDescriptor]

'newChildIndex' @ [204:80] ==> value-parameter newChildIndex: Int defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[ValueParameterDescriptorImpl]

'isIncomplete' @ [204:99] ==> public final val Block.isIncomplete: Boolean[MyPropertyDescriptor]

'isIncompleteInSuper' @ [204:117] ==> protected abstract fun isIncompleteInSuper(): Boolean defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[SimpleFunctionDescriptorImpl]

'isIncomplete' @ [205:25] ==> val isIncomplete: Boolean defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[LocalVariableDescriptor]

'getSuperChildAttributes' @ [206:32] ==> protected abstract fun getSuperChildAttributes(newChildIndex: Int): ChildAttributes defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[SimpleFunctionDescriptorImpl]

'newChildIndex' @ [206:56] ==> value-parameter newChildIndex: Int defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[ValueParameterDescriptorImpl]

'blocks' @ [210:21] ==> val blocks: List<Block> defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[LocalVariableDescriptor]

'size' @ [210:28] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'newChildIndex' @ [210:35] ==> value-parameter newChildIndex: Int defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[ValueParameterDescriptorImpl]

'blocks' @ [211:33] ==> val blocks: List<Block> defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[LocalVariableDescriptor]

'newChildIndex' @ [211:40] ==> value-parameter newChildIndex: Int defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[ValueParameterDescriptorImpl]

'ChildAttributes' @ [212:28] ==> public constructor ChildAttributes(@Nullable p0: Indent?, @Nullable p1: Alignment?) defined in com.intellij.formatting.ChildAttributes[JavaClassConstructorDescriptor]

'block' @ [212:44] ==> val block: Block defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[LocalVariableDescriptor]

'indent' @ [212:50] ==> public final val Block.indent: Indent?[MyPropertyDescriptor]

'block' @ [212:58] ==> val block: Block defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildAttributes[LocalVariableDescriptor]

'alignment' @ [212:64] ==> public final val Block.alignment: Alignment?[MyPropertyDescriptor]

'ChildAttributes' @ [215:17] ==> public constructor ChildAttributes(@Nullable p0: Indent?, @Nullable p1: Alignment?) defined in com.intellij.formatting.ChildAttributes[JavaClassConstructorDescriptor]

'getNoneIndent' @ [215:40] ==> public open fun getNoneIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'settings' @ [221:33] ==> private final val settings: CodeStyleSettings defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'getCommonSettings' @ [221:42] ==> public open fun getCommonSettings(p0: (Language..Language?)): (CommonCodeStyleSettings..CommonCodeStyleSettings?) defined in com.intellij.psi.codeStyle.CodeStyleSettings[JavaMethodDescriptor]

'INSTANCE' @ [221:75] ==> @NotNull public final val INSTANCE: KotlinLanguage defined in org.jetbrains.kotlin.idea.KotlinLanguage[JavaPropertyDescriptor]

'settings' @ [222:30] ==> private final val settings: CodeStyleSettings defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'kotlinSettings' @ [222:39] ==> public val CodeStyleSettings.kotlinSettings: (KotlinCodeStyleSettings..KotlinCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[PropertyDescriptorImpl]

'node' @ [223:26] ==> private final val node: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'elementType' @ [223:31] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'when {
            parentType === KtNodeTypes.VALUE_PARAMETER_LIST ->
                getAlignmentForChildInParenthesis(
                        jetCommonSettings.ALIGN_MULTILINE_PARAMETERS, KtNodeTypes.VALUE_PARAMETER, COMMA,
                        jetCommonSettings.ALIGN_MULTILINE_METHOD_BRACKETS, LPAR, RPAR)

            parentType === KtNodeTypes.VALUE_ARGUMENT_LIST ->
                getAlignmentForChildInParenthesis(
                        jetCommonSettings.ALIGN_MULTILINE_PARAMETERS_IN_CALLS, KtNodeTypes.VALUE_ARGUMENT, COMMA,
                        jetCommonSettings.ALIGN_MULTILINE_METHOD_BRACKETS, LPAR, RPAR)

            parentType === KtNodeTypes.WHEN ->
                getAlignmentForCaseBranch(kotlinSettings.ALIGN_IN_COLUMNS_CASE_BRANCH)

            parentType === KtNodeTypes.WHEN_ENTRY ->
                alignmentStrategy

            parentType in BINARY_EXPRESSIONS && getOperationType(node) in ALIGN_FOR_BINARY_OPERATIONS ->
                createAlignmentStrategy(jetCommonSettings.ALIGN_MULTILINE_BINARY_OPERATION, getAlignment())

            parentType === KtNodeTypes.SUPER_TYPE_LIST || parentType === KtNodeTypes.INITIALIZER_LIST ->
                createAlignmentStrategy(jetCommonSettings.ALIGN_MULTILINE_EXTENDS_LIST, getAlignment())

            parentType === KtNodeTypes.PARENTHESIZED ->
                object : CommonAlignmentStrategy() {
                    private var bracketsAlignment: Alignment? = if (jetCommonSettings.ALIGN_MULTILINE_BINARY_OPERATION) Alignment.createAlignment() else null

                    override fun getAlignment(node: ASTNode): Alignment? {
                        val childNodeType = node.elementType
                        val prev = getPrevWithoutWhitespace(node)

                        if (prev != null && prev.elementType === TokenType.ERROR_ELEMENT || childNodeType === TokenType.ERROR_ELEMENT) {
                            return bracketsAlignment
                        }

                        if (childNodeType === LPAR || childNodeType === RPAR) {
                            return bracketsAlignment
                        }

                        return null
                    }
                }

            parentType == KtNodeTypes.TYPE_CONSTRAINT_LIST ->
                createAlignmentStrategy(true, getAlignment())

            else ->
                getNullAlignmentStrategy()
        }' @ [224:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: CommonAlignmentStrategy, entry1: CommonAlignmentStrategy, entry2: CommonAlignmentStrategy, entry3: CommonAlignmentStrategy, entry4: CommonAlignmentStrategy, entry5: CommonAlignmentStrategy, entry6: CommonAlignmentStrategy, entry7: CommonAlignmentStrategy, entry8: CommonAlignmentStrategy): CommonAlignmentStrategy[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> CommonAlignmentStrategy

'parentType' @ [225:13] ==> val parentType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy[LocalVariableDescriptor]

'VALUE_PARAMETER_LIST' @ [225:40] ==> public final val VALUE_PARAMETER_LIST: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'getAlignmentForChildInParenthesis' @ [226:17] ==> private fun getAlignmentForChildInParenthesis(shouldAlignChild: Boolean, parameter: IElementType, delimiter: IElementType, shouldAlignParenthesis: Boolean, openBracket: IElementType, closeBracket: IElementType): CommonAlignmentStrategy defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[SimpleFunctionDescriptorImpl]

'jetCommonSettings' @ [227:25] ==> val jetCommonSettings: (CommonCodeStyleSettings..CommonCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy[LocalVariableDescriptor]

'ALIGN_MULTILINE_PARAMETERS' @ [227:43] ==> public final var ALIGN_MULTILINE_PARAMETERS: Boolean defined in com.intellij.psi.codeStyle.CommonCodeStyleSettings[JavaPropertyDescriptor]

'VALUE_PARAMETER' @ [227:83] ==> public final val VALUE_PARAMETER: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'COMMA' @ [227:100] ==> public final val COMMA: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'jetCommonSettings' @ [228:25] ==> val jetCommonSettings: (CommonCodeStyleSettings..CommonCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy[LocalVariableDescriptor]

'ALIGN_MULTILINE_METHOD_BRACKETS' @ [228:43] ==> public final var ALIGN_MULTILINE_METHOD_BRACKETS: Boolean defined in com.intellij.psi.codeStyle.CommonCodeStyleSettings[JavaPropertyDescriptor]

'LPAR' @ [228:76] ==> public final val LPAR: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'RPAR' @ [228:82] ==> public final val RPAR: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'parentType' @ [230:13] ==> val parentType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy[LocalVariableDescriptor]

'VALUE_ARGUMENT_LIST' @ [230:40] ==> public final val VALUE_ARGUMENT_LIST: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'getAlignmentForChildInParenthesis' @ [231:17] ==> private fun getAlignmentForChildInParenthesis(shouldAlignChild: Boolean, parameter: IElementType, delimiter: IElementType, shouldAlignParenthesis: Boolean, openBracket: IElementType, closeBracket: IElementType): CommonAlignmentStrategy defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[SimpleFunctionDescriptorImpl]

'jetCommonSettings' @ [232:25] ==> val jetCommonSettings: (CommonCodeStyleSettings..CommonCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy[LocalVariableDescriptor]

'ALIGN_MULTILINE_PARAMETERS_IN_CALLS' @ [232:43] ==> public final var ALIGN_MULTILINE_PARAMETERS_IN_CALLS: Boolean defined in com.intellij.psi.codeStyle.CommonCodeStyleSettings[JavaPropertyDescriptor]

'VALUE_ARGUMENT' @ [232:92] ==> public final val VALUE_ARGUMENT: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'COMMA' @ [232:108] ==> public final val COMMA: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'jetCommonSettings' @ [233:25] ==> val jetCommonSettings: (CommonCodeStyleSettings..CommonCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy[LocalVariableDescriptor]

'ALIGN_MULTILINE_METHOD_BRACKETS' @ [233:43] ==> public final var ALIGN_MULTILINE_METHOD_BRACKETS: Boolean defined in com.intellij.psi.codeStyle.CommonCodeStyleSettings[JavaPropertyDescriptor]

'LPAR' @ [233:76] ==> public final val LPAR: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'RPAR' @ [233:82] ==> public final val RPAR: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'parentType' @ [235:13] ==> val parentType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy[LocalVariableDescriptor]

'WHEN' @ [235:40] ==> public final val WHEN: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'getAlignmentForCaseBranch' @ [236:17] ==> protected abstract fun getAlignmentForCaseBranch(shouldAlignInColumns: Boolean): CommonAlignmentStrategy defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[SimpleFunctionDescriptorImpl]

'kotlinSettings' @ [236:43] ==> val kotlinSettings: (KotlinCodeStyleSettings..KotlinCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy[LocalVariableDescriptor]

'ALIGN_IN_COLUMNS_CASE_BRANCH' @ [236:58] ==> public final var ALIGN_IN_COLUMNS_CASE_BRANCH: Boolean defined in org.jetbrains.kotlin.idea.core.formatter.KotlinCodeStyleSettings[JavaPropertyDescriptor]

'parentType' @ [238:13] ==> val parentType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy[LocalVariableDescriptor]

'WHEN_ENTRY' @ [238:40] ==> public final val WHEN_ENTRY: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'alignmentStrategy' @ [239:17] ==> private final val alignmentStrategy: CommonAlignmentStrategy defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'parentType' @ [241:13] ==> val parentType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy[LocalVariableDescriptor]

'BINARY_EXPRESSIONS' @ [241:27] ==> private val BINARY_EXPRESSIONS: TokenSet defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[PropertyDescriptorImpl]

'getOperationType' @ [241:49] ==> private fun getOperationType(node: ASTNode): IElementType? defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[SimpleFunctionDescriptorImpl]

'node' @ [241:66] ==> private final val node: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'ALIGN_FOR_BINARY_OPERATIONS' @ [241:75] ==> private val ALIGN_FOR_BINARY_OPERATIONS: TokenSet defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[PropertyDescriptorImpl]

'createAlignmentStrategy' @ [242:17] ==> protected abstract fun createAlignmentStrategy(alignOption: Boolean, defaultAlignment: Alignment?): CommonAlignmentStrategy defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[SimpleFunctionDescriptorImpl]

'jetCommonSettings' @ [242:41] ==> val jetCommonSettings: (CommonCodeStyleSettings..CommonCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy[LocalVariableDescriptor]

'ALIGN_MULTILINE_BINARY_OPERATION' @ [242:59] ==> public final var ALIGN_MULTILINE_BINARY_OPERATION: Boolean defined in com.intellij.psi.codeStyle.CommonCodeStyleSettings[JavaPropertyDescriptor]

'getAlignment' @ [242:93] ==> protected abstract fun getAlignment(): Alignment? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[SimpleFunctionDescriptorImpl]

'parentType' @ [244:13] ==> val parentType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy[LocalVariableDescriptor]

'SUPER_TYPE_LIST' @ [244:40] ==> public final val SUPER_TYPE_LIST: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'parentType' @ [244:59] ==> val parentType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy[LocalVariableDescriptor]

'INITIALIZER_LIST' @ [244:86] ==> public final val INITIALIZER_LIST: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'createAlignmentStrategy' @ [245:17] ==> protected abstract fun createAlignmentStrategy(alignOption: Boolean, defaultAlignment: Alignment?): CommonAlignmentStrategy defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[SimpleFunctionDescriptorImpl]

'jetCommonSettings' @ [245:41] ==> val jetCommonSettings: (CommonCodeStyleSettings..CommonCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy[LocalVariableDescriptor]

'ALIGN_MULTILINE_EXTENDS_LIST' @ [245:59] ==> public final var ALIGN_MULTILINE_EXTENDS_LIST: Boolean defined in com.intellij.psi.codeStyle.CommonCodeStyleSettings[JavaPropertyDescriptor]

'getAlignment' @ [245:89] ==> protected abstract fun getAlignment(): Alignment? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[SimpleFunctionDescriptorImpl]

'parentType' @ [247:13] ==> val parentType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy[LocalVariableDescriptor]

'PARENTHESIZED' @ [247:40] ==> public final val PARENTHESIZED: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'CommonAlignmentStrategy' @ [248:26] ==> public constructor CommonAlignmentStrategy() defined in org.jetbrains.kotlin.idea.formatter.CommonAlignmentStrategy[ClassConstructorDescriptorImpl]

'if (jetCommonSettings.ALIGN_MULTILINE_BINARY_OPERATION) Alignment.createAlignment() else null' @ [249:65] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Alignment?, elseBranch: Alignment?): Alignment?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Alignment?

'jetCommonSettings' @ [249:69] ==> val jetCommonSettings: (CommonCodeStyleSettings..CommonCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy[LocalVariableDescriptor]

'ALIGN_MULTILINE_BINARY_OPERATION' @ [249:87] ==> public final var ALIGN_MULTILINE_BINARY_OPERATION: Boolean defined in com.intellij.psi.codeStyle.CommonCodeStyleSettings[JavaPropertyDescriptor]

'createAlignment' @ [249:131] ==> public open fun createAlignment(): (Alignment..Alignment?) defined in com.intellij.formatting.Alignment[JavaMethodDescriptor]

'node' @ [252:45] ==> value-parameter node: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy.<no name provided>.getAlignment[ValueParameterDescriptorImpl]

'elementType' @ [252:50] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'getPrevWithoutWhitespace' @ [253:36] ==> private fun getPrevWithoutWhitespace(pNode: ASTNode?): ASTNode? defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[SimpleFunctionDescriptorImpl]

'node' @ [253:61] ==> value-parameter node: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy.<no name provided>.getAlignment[ValueParameterDescriptorImpl]

'prev' @ [255:29] ==> val prev: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy.<no name provided>.getAlignment[LocalVariableDescriptor]

'prev' @ [255:45] ==> val prev: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy.<no name provided>.getAlignment[LocalVariableDescriptor]

'elementType' @ [255:50] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'ERROR_ELEMENT' @ [255:76] ==> public final val ERROR_ELEMENT: (IElementType..IElementType?) defined in com.intellij.psi.TokenType[JavaPropertyDescriptor]

'childNodeType' @ [255:93] ==> val childNodeType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy.<no name provided>.getAlignment[LocalVariableDescriptor]

'ERROR_ELEMENT' @ [255:121] ==> public final val ERROR_ELEMENT: (IElementType..IElementType?) defined in com.intellij.psi.TokenType[JavaPropertyDescriptor]

'bracketsAlignment' @ [256:36] ==> private final var bracketsAlignment: Alignment? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy.<no name provided>[PropertyDescriptorImpl]

'childNodeType' @ [259:29] ==> val childNodeType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy.<no name provided>.getAlignment[LocalVariableDescriptor]

'LPAR' @ [259:47] ==> public final val LPAR: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'childNodeType' @ [259:55] ==> val childNodeType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy.<no name provided>.getAlignment[LocalVariableDescriptor]

'RPAR' @ [259:73] ==> public final val RPAR: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'bracketsAlignment' @ [260:36] ==> private final var bracketsAlignment: Alignment? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy.<no name provided>[PropertyDescriptorImpl]

'parentType' @ [267:13] ==> val parentType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getChildrenAlignmentStrategy[LocalVariableDescriptor]

'TYPE_CONSTRAINT_LIST' @ [267:39] ==> public final val TYPE_CONSTRAINT_LIST: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'createAlignmentStrategy' @ [268:17] ==> protected abstract fun createAlignmentStrategy(alignOption: Boolean, defaultAlignment: Alignment?): CommonAlignmentStrategy defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[SimpleFunctionDescriptorImpl]

'getAlignment' @ [268:47] ==> protected abstract fun getAlignment(): Alignment? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[SimpleFunctionDescriptorImpl]

'getNullAlignmentStrategy' @ [271:17] ==> protected abstract fun getNullAlignmentStrategy(): CommonAlignmentStrategy defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[SimpleFunctionDescriptorImpl]

'wrappingStrategy' @ [277:25] ==> value-parameter wrappingStrategy: WrappingStrategy defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlock[ValueParameterDescriptorImpl]

'getWrap' @ [277:42] ==> public abstract fun getWrap(childElement: ASTNode): Wrap? defined in org.jetbrains.kotlin.idea.formatter.WrappingStrategy[SimpleFunctionDescriptorImpl]

'child' @ [277:50] ==> value-parameter child: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlock[ValueParameterDescriptorImpl]

'child' @ [280:13] ==> value-parameter child: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlock[ValueParameterDescriptorImpl]

'elementType' @ [280:19] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'OPERATION_REFERENCE' @ [280:47] ==> public final val OPERATION_REFERENCE: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'child' @ [281:33] ==> value-parameter child: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlock[ValueParameterDescriptorImpl]

'firstChildNode' @ [281:39] ==> public final val ASTNode.firstChildNode: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'operationNode' @ [282:17] ==> val operationNode: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlock[LocalVariableDescriptor]

'createBlock' @ [283:24] ==> protected abstract fun createBlock(node: ASTNode, alignmentStrategy: CommonAlignmentStrategy, indent: Indent?, wrap: Wrap?, settings: CodeStyleSettings, spacingBuilder: KotlinSpacingBuilder): Block defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[SimpleFunctionDescriptorImpl]

'operationNode' @ [284:25] ==> val operationNode: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlock[LocalVariableDescriptor]

'alignmentStrategy' @ [285:25] ==> value-parameter alignmentStrategy: CommonAlignmentStrategy defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlock[ValueParameterDescriptorImpl]

'createChildIndent' @ [286:25] ==> public final fun createChildIndent(child: ASTNode): Indent? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[SimpleFunctionDescriptorImpl]

'child' @ [286:43] ==> value-parameter child: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlock[ValueParameterDescriptorImpl]

'childWrap' @ [287:25] ==> val childWrap: Wrap? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlock[LocalVariableDescriptor]

'settings' @ [288:25] ==> private final val settings: CodeStyleSettings defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'spacingBuilder' @ [289:25] ==> private final val spacingBuilder: KotlinSpacingBuilder defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'createBlock' @ [293:16] ==> protected abstract fun createBlock(node: ASTNode, alignmentStrategy: CommonAlignmentStrategy, indent: Indent?, wrap: Wrap?, settings: CodeStyleSettings, spacingBuilder: KotlinSpacingBuilder): Block defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[SimpleFunctionDescriptorImpl]

'child' @ [293:28] ==> value-parameter child: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlock[ValueParameterDescriptorImpl]

'alignmentStrategy' @ [293:35] ==> value-parameter alignmentStrategy: CommonAlignmentStrategy defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlock[ValueParameterDescriptorImpl]

'createChildIndent' @ [293:54] ==> public final fun createChildIndent(child: ASTNode): Indent? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[SimpleFunctionDescriptorImpl]

'child' @ [293:72] ==> value-parameter child: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlock[ValueParameterDescriptorImpl]

'childWrap' @ [293:80] ==> val childWrap: Wrap? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlock[LocalVariableDescriptor]

'settings' @ [293:91] ==> private final val settings: CodeStyleSettings defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'spacingBuilder' @ [293:101] ==> private final val spacingBuilder: KotlinSpacingBuilder defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'ArrayList' @ [297:22] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> Block

'getChildrenAlignmentStrategy' @ [299:41] ==> private final fun getChildrenAlignmentStrategy(): CommonAlignmentStrategy defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[SimpleFunctionDescriptorImpl]

'getWrappingStrategy' @ [300:32] ==> private final fun getWrappingStrategy(): WrappingStrategy defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[SimpleFunctionDescriptorImpl]

'node' @ [302:31] ==> private final val node: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'firstChildNode' @ [302:36] ==> public final val ASTNode.firstChildNode: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'child' @ [303:16] ==> var child: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlocks[LocalVariableDescriptor]

'child' @ [304:29] ==> var child: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlocks[LocalVariableDescriptor]

'elementType' @ [304:35] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'child' @ [306:17] ==> var child: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlocks[LocalVariableDescriptor]

'textRange' @ [306:23] ==> public final val ASTNode.textRange: (TextRange..TextRange?)[MyPropertyDescriptor]

'length' @ [306:33] ==> public final val TextRange.length: Int[MyPropertyDescriptor]

'child' @ [307:17] ==> var child: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlocks[LocalVariableDescriptor]

'child' @ [307:25] ==> var child: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlocks[LocalVariableDescriptor]

'treeNext' @ [307:31] ==> public final val ASTNode.treeNext: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'childType' @ [311:17] ==> val childType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlocks[LocalVariableDescriptor]

'WHITE_SPACE' @ [311:41] ==> public final val WHITE_SPACE: (IElementType..IElementType?) defined in com.intellij.psi.TokenType[JavaPropertyDescriptor]

'child' @ [312:17] ==> var child: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlocks[LocalVariableDescriptor]

'child' @ [312:25] ==> var child: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlocks[LocalVariableDescriptor]

'treeNext' @ [312:31] ==> public final val ASTNode.treeNext: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'blocks' @ [316:13] ==> val blocks: ArrayList<Block> defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlocks[LocalVariableDescriptor]

'add' @ [316:20] ==> public open fun add(element: Block): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'buildSubBlock' @ [316:24] ==> private final fun buildSubBlock(child: ASTNode, alignmentStrategy: CommonAlignmentStrategy, wrappingStrategy: WrappingStrategy): Block defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[SimpleFunctionDescriptorImpl]

'child' @ [316:38] ==> var child: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlocks[LocalVariableDescriptor]

'childrenAlignmentStrategy' @ [316:45] ==> val childrenAlignmentStrategy: CommonAlignmentStrategy defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlocks[LocalVariableDescriptor]

'wrappingStrategy' @ [316:72] ==> val wrappingStrategy: WrappingStrategy defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlocks[LocalVariableDescriptor]

'child' @ [317:13] ==> var child: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlocks[LocalVariableDescriptor]

'child' @ [317:21] ==> var child: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlocks[LocalVariableDescriptor]

'treeNext' @ [317:27] ==> public final val ASTNode.treeNext: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'blocks' @ [320:16] ==> val blocks: ArrayList<Block> defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.buildSubBlocks[LocalVariableDescriptor]

'settings' @ [324:30] ==> private final val settings: CodeStyleSettings defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'getCommonSettings' @ [324:39] ==> public open fun getCommonSettings(p0: (Language..Language?)): (CommonCodeStyleSettings..CommonCodeStyleSettings?) defined in com.intellij.psi.codeStyle.CodeStyleSettings[JavaMethodDescriptor]

'INSTANCE' @ [324:72] ==> @NotNull public final val INSTANCE: KotlinLanguage defined in org.jetbrains.kotlin.idea.KotlinLanguage[JavaPropertyDescriptor]

'node' @ [325:27] ==> private final val node: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'elementType' @ [325:32] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'node' @ [326:23] ==> private final val node: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'psi' @ [326:28] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'when {
            elementType === KtNodeTypes.VALUE_ARGUMENT_LIST ->
                return getWrappingStrategyForItemList(commonSettings.CALL_PARAMETERS_WRAP, KtNodeTypes.VALUE_ARGUMENT)

            elementType === KtNodeTypes.VALUE_PARAMETER_LIST -> {
                val parentElementType = node.treeParent.elementType
                if (parentElementType === KtNodeTypes.FUN ||
                    parentElementType === KtNodeTypes.PRIMARY_CONSTRUCTOR ||
                    parentElementType === KtNodeTypes.SECONDARY_CONSTRUCTOR) {
                    val wrap = Wrap.createWrap(commonSettings.METHOD_PARAMETERS_WRAP, false)
                    return object : WrappingStrategy {
                        override fun getWrap(childElement: ASTNode): Wrap? {
                            return if (childElement.elementType === KtNodeTypes.VALUE_PARAMETER && !childElement.startsWithAnnotation())
                                wrap
                            else
                                null
                        }
                    }
                }
            }

            elementType === KtNodeTypes.SUPER_TYPE_LIST -> {
                val wrap = Wrap.createWrap(commonSettings.EXTENDS_LIST_WRAP, false)
                return object : WrappingStrategy {
                    override fun getWrap(childElement: ASTNode): Wrap? =
                        if (childElement.psi is KtSuperTypeListEntry) wrap else null
                }
            }

            elementType === KtNodeTypes.CLASS_BODY ->
                return getWrappingStrategyForItemList(commonSettings.ENUM_CONSTANTS_WRAP, KtNodeTypes.ENUM_ENTRY)

            elementType === KtNodeTypes.MODIFIER_LIST -> {
                val parent = node.treeParent.psi
                when (parent) {
                    is KtParameter ->
                        return getWrappingStrategyForItemList(commonSettings.PARAMETER_ANNOTATION_WRAP,
                                                              ANNOTATIONS,
                                                              !node.treeParent.isFirstParameter())
                    is KtClassOrObject ->
                        return getWrappingStrategyForItemList(commonSettings.CLASS_ANNOTATION_WRAP,
                                                              ANNOTATIONS)

                    is KtNamedFunction ->
                        return getWrappingStrategyForItemList(commonSettings.METHOD_ANNOTATION_WRAP,
                                                              ANNOTATIONS)

                    is KtProperty ->
                        return getWrappingStrategyForItemList(if (parent.isLocal)
                                                                  commonSettings.VARIABLE_ANNOTATION_WRAP
                                                              else
                                                                  commonSettings.FIELD_ANNOTATION_WRAP,
                                                              ANNOTATIONS)
                }
            }

            elementType === KtNodeTypes.VALUE_PARAMETER ->
                return wrapAfterAnnotation(commonSettings.PARAMETER_ANNOTATION_WRAP)

            nodePsi is KtClassOrObject ->
                return wrapAfterAnnotation(commonSettings.CLASS_ANNOTATION_WRAP)

            nodePsi is KtNamedFunction ->
                return wrapAfterAnnotation(commonSettings.METHOD_ANNOTATION_WRAP)

            nodePsi is KtProperty ->
                return wrapAfterAnnotation(if (nodePsi.isLocal)
                                               commonSettings.VARIABLE_ANNOTATION_WRAP
                                           else
                                               commonSettings.FIELD_ANNOTATION_WRAP)
        }' @ [328:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit, entry3: Unit, entry4: Unit, entry5: Unit, entry6: Unit, entry7: Unit, entry8: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'elementType' @ [329:13] ==> val elementType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'VALUE_ARGUMENT_LIST' @ [329:41] ==> public final val VALUE_ARGUMENT_LIST: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'getWrappingStrategyForItemList' @ [330:24] ==> private fun getWrappingStrategyForItemList(wrapType: Int, itemType: IElementType, wrapFirstElement: Boolean = ...): WrappingStrategy defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[SimpleFunctionDescriptorImpl]

'commonSettings' @ [330:55] ==> val commonSettings: (CommonCodeStyleSettings..CommonCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'CALL_PARAMETERS_WRAP' @ [330:70] ==> public final var CALL_PARAMETERS_WRAP: Int defined in com.intellij.psi.codeStyle.CommonCodeStyleSettings[JavaPropertyDescriptor]

'VALUE_ARGUMENT' @ [330:104] ==> public final val VALUE_ARGUMENT: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'elementType' @ [332:13] ==> val elementType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'VALUE_PARAMETER_LIST' @ [332:41] ==> public final val VALUE_PARAMETER_LIST: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'node' @ [333:41] ==> private final val node: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'treeParent' @ [333:46] ==> public final val ASTNode.treeParent: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'elementType' @ [333:57] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'parentElementType' @ [334:21] ==> val parentElementType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'FUN' @ [334:55] ==> public final val FUN: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'parentElementType' @ [335:21] ==> val parentElementType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'PRIMARY_CONSTRUCTOR' @ [335:55] ==> public final val PRIMARY_CONSTRUCTOR: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'parentElementType' @ [336:21] ==> val parentElementType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'SECONDARY_CONSTRUCTOR' @ [336:55] ==> public final val SECONDARY_CONSTRUCTOR: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'createWrap' @ [337:37] ==> public open fun createWrap(p0: Int, p1: Boolean): (Wrap..Wrap?) defined in com.intellij.formatting.Wrap[JavaMethodDescriptor]

'commonSettings' @ [337:48] ==> val commonSettings: (CommonCodeStyleSettings..CommonCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'METHOD_PARAMETERS_WRAP' @ [337:63] ==> public final var METHOD_PARAMETERS_WRAP: Int defined in com.intellij.psi.codeStyle.CommonCodeStyleSettings[JavaPropertyDescriptor]

'if (childElement.elementType === KtNodeTypes.VALUE_PARAMETER && !childElement.startsWithAnnotation())
                                wrap
                            else
                                null' @ [340:36] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Wrap?, elseBranch: Wrap?): Wrap?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Wrap?

'childElement' @ [340:40] ==> value-parameter childElement: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy.<no name provided>.getWrap[ValueParameterDescriptorImpl]

'elementType' @ [340:53] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'VALUE_PARAMETER' @ [340:81] ==> public final val VALUE_PARAMETER: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'!' @ [340:100] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'childElement' @ [340:101] ==> value-parameter childElement: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy.<no name provided>.getWrap[ValueParameterDescriptorImpl]

'startsWithAnnotation' @ [340:114] ==> private fun ASTNode.startsWithAnnotation(): Boolean defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[SimpleFunctionDescriptorImpl]

'wrap' @ [341:33] ==> val wrap: (Wrap..Wrap?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'elementType' @ [349:13] ==> val elementType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'SUPER_TYPE_LIST' @ [349:41] ==> public final val SUPER_TYPE_LIST: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'createWrap' @ [350:33] ==> public open fun createWrap(p0: Int, p1: Boolean): (Wrap..Wrap?) defined in com.intellij.formatting.Wrap[JavaMethodDescriptor]

'commonSettings' @ [350:44] ==> val commonSettings: (CommonCodeStyleSettings..CommonCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'EXTENDS_LIST_WRAP' @ [350:59] ==> public final var EXTENDS_LIST_WRAP: Int defined in com.intellij.psi.codeStyle.CommonCodeStyleSettings[JavaPropertyDescriptor]

'if (childElement.psi is KtSuperTypeListEntry) wrap else null' @ [353:25] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Wrap?, elseBranch: Wrap?): Wrap?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Wrap?

'childElement' @ [353:29] ==> value-parameter childElement: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy.<no name provided>.getWrap[ValueParameterDescriptorImpl]

'psi' @ [353:42] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'wrap' @ [353:71] ==> val wrap: (Wrap..Wrap?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'elementType' @ [357:13] ==> val elementType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'CLASS_BODY' @ [357:41] ==> public final val CLASS_BODY: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'getWrappingStrategyForItemList' @ [358:24] ==> private fun getWrappingStrategyForItemList(wrapType: Int, itemType: IElementType, wrapFirstElement: Boolean = ...): WrappingStrategy defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[SimpleFunctionDescriptorImpl]

'commonSettings' @ [358:55] ==> val commonSettings: (CommonCodeStyleSettings..CommonCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'ENUM_CONSTANTS_WRAP' @ [358:70] ==> public final var ENUM_CONSTANTS_WRAP: Int defined in com.intellij.psi.codeStyle.CommonCodeStyleSettings[JavaPropertyDescriptor]

'ENUM_ENTRY' @ [358:103] ==> public final val ENUM_ENTRY: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'elementType' @ [360:13] ==> val elementType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'MODIFIER_LIST' @ [360:41] ==> public final val MODIFIER_LIST: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'node' @ [361:30] ==> private final val node: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'treeParent' @ [361:35] ==> public final val ASTNode.treeParent: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'psi' @ [361:46] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'when (parent) {
                    is KtParameter ->
                        return getWrappingStrategyForItemList(commonSettings.PARAMETER_ANNOTATION_WRAP,
                                                              ANNOTATIONS,
                                                              !node.treeParent.isFirstParameter())
                    is KtClassOrObject ->
                        return getWrappingStrategyForItemList(commonSettings.CLASS_ANNOTATION_WRAP,
                                                              ANNOTATIONS)

                    is KtNamedFunction ->
                        return getWrappingStrategyForItemList(commonSettings.METHOD_ANNOTATION_WRAP,
                                                              ANNOTATIONS)

                    is KtProperty ->
                        return getWrappingStrategyForItemList(if (parent.isLocal)
                                                                  commonSettings.VARIABLE_ANNOTATION_WRAP
                                                              else
                                                                  commonSettings.FIELD_ANNOTATION_WRAP,
                                                              ANNOTATIONS)
                }' @ [362:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Nothing, entry1: Nothing, entry2: Nothing, entry3: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Nothing

'parent' @ [362:23] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'getWrappingStrategyForItemList' @ [364:32] ==> private fun getWrappingStrategyForItemList(wrapType: Int, itemTypes: TokenSet, wrapFirstElement: Boolean = ...): WrappingStrategy defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[SimpleFunctionDescriptorImpl]

'commonSettings' @ [364:63] ==> val commonSettings: (CommonCodeStyleSettings..CommonCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'PARAMETER_ANNOTATION_WRAP' @ [364:78] ==> public final var PARAMETER_ANNOTATION_WRAP: Int defined in com.intellij.psi.codeStyle.CommonCodeStyleSettings[JavaPropertyDescriptor]

'ANNOTATIONS' @ [365:63] ==> private val ANNOTATIONS: TokenSet defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[PropertyDescriptorImpl]

'!' @ [366:63] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'node' @ [366:64] ==> private final val node: ASTNode defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock[PropertyDescriptorImpl]

'treeParent' @ [366:69] ==> public final val ASTNode.treeParent: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'isFirstParameter' @ [366:80] ==> private fun ASTNode.isFirstParameter(): Boolean defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[SimpleFunctionDescriptorImpl]

'getWrappingStrategyForItemList' @ [368:32] ==> private fun getWrappingStrategyForItemList(wrapType: Int, itemTypes: TokenSet, wrapFirstElement: Boolean = ...): WrappingStrategy defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[SimpleFunctionDescriptorImpl]

'commonSettings' @ [368:63] ==> val commonSettings: (CommonCodeStyleSettings..CommonCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'CLASS_ANNOTATION_WRAP' @ [368:78] ==> public final var CLASS_ANNOTATION_WRAP: Int defined in com.intellij.psi.codeStyle.CommonCodeStyleSettings[JavaPropertyDescriptor]

'ANNOTATIONS' @ [369:63] ==> private val ANNOTATIONS: TokenSet defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[PropertyDescriptorImpl]

'getWrappingStrategyForItemList' @ [372:32] ==> private fun getWrappingStrategyForItemList(wrapType: Int, itemTypes: TokenSet, wrapFirstElement: Boolean = ...): WrappingStrategy defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[SimpleFunctionDescriptorImpl]

'commonSettings' @ [372:63] ==> val commonSettings: (CommonCodeStyleSettings..CommonCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'METHOD_ANNOTATION_WRAP' @ [372:78] ==> public final var METHOD_ANNOTATION_WRAP: Int defined in com.intellij.psi.codeStyle.CommonCodeStyleSettings[JavaPropertyDescriptor]

'ANNOTATIONS' @ [373:63] ==> private val ANNOTATIONS: TokenSet defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[PropertyDescriptorImpl]

'getWrappingStrategyForItemList' @ [376:32] ==> private fun getWrappingStrategyForItemList(wrapType: Int, itemTypes: TokenSet, wrapFirstElement: Boolean = ...): WrappingStrategy defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[SimpleFunctionDescriptorImpl]

'if (parent.isLocal)
                                                                  commonSettings.VARIABLE_ANNOTATION_WRAP
                                                              else
                                                                  commonSettings.FIELD_ANNOTATION_WRAP' @ [376:63] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Int, elseBranch: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Int

'parent' @ [376:67] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'isLocal' @ [376:74] ==> public final val KtProperty.isLocal: Boolean[MyPropertyDescriptor]

'commonSettings' @ [377:67] ==> val commonSettings: (CommonCodeStyleSettings..CommonCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'VARIABLE_ANNOTATION_WRAP' @ [377:82] ==> public final var VARIABLE_ANNOTATION_WRAP: Int defined in com.intellij.psi.codeStyle.CommonCodeStyleSettings[JavaPropertyDescriptor]

'commonSettings' @ [379:67] ==> val commonSettings: (CommonCodeStyleSettings..CommonCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'FIELD_ANNOTATION_WRAP' @ [379:82] ==> public final var FIELD_ANNOTATION_WRAP: Int defined in com.intellij.psi.codeStyle.CommonCodeStyleSettings[JavaPropertyDescriptor]

'ANNOTATIONS' @ [380:63] ==> private val ANNOTATIONS: TokenSet defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[PropertyDescriptorImpl]

'elementType' @ [384:13] ==> val elementType: IElementType defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'VALUE_PARAMETER' @ [384:41] ==> public final val VALUE_PARAMETER: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'wrapAfterAnnotation' @ [385:24] ==> private fun wrapAfterAnnotation(wrapType: Int): WrappingStrategy defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[SimpleFunctionDescriptorImpl]

'commonSettings' @ [385:44] ==> val commonSettings: (CommonCodeStyleSettings..CommonCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'PARAMETER_ANNOTATION_WRAP' @ [385:59] ==> public final var PARAMETER_ANNOTATION_WRAP: Int defined in com.intellij.psi.codeStyle.CommonCodeStyleSettings[JavaPropertyDescriptor]

'nodePsi' @ [387:13] ==> val nodePsi: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'wrapAfterAnnotation' @ [388:24] ==> private fun wrapAfterAnnotation(wrapType: Int): WrappingStrategy defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[SimpleFunctionDescriptorImpl]

'commonSettings' @ [388:44] ==> val commonSettings: (CommonCodeStyleSettings..CommonCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'CLASS_ANNOTATION_WRAP' @ [388:59] ==> public final var CLASS_ANNOTATION_WRAP: Int defined in com.intellij.psi.codeStyle.CommonCodeStyleSettings[JavaPropertyDescriptor]

'nodePsi' @ [390:13] ==> val nodePsi: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'wrapAfterAnnotation' @ [391:24] ==> private fun wrapAfterAnnotation(wrapType: Int): WrappingStrategy defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[SimpleFunctionDescriptorImpl]

'commonSettings' @ [391:44] ==> val commonSettings: (CommonCodeStyleSettings..CommonCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'METHOD_ANNOTATION_WRAP' @ [391:59] ==> public final var METHOD_ANNOTATION_WRAP: Int defined in com.intellij.psi.codeStyle.CommonCodeStyleSettings[JavaPropertyDescriptor]

'nodePsi' @ [393:13] ==> val nodePsi: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'wrapAfterAnnotation' @ [394:24] ==> private fun wrapAfterAnnotation(wrapType: Int): WrappingStrategy defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[SimpleFunctionDescriptorImpl]

'if (nodePsi.isLocal)
                                               commonSettings.VARIABLE_ANNOTATION_WRAP
                                           else
                                               commonSettings.FIELD_ANNOTATION_WRAP' @ [394:44] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Int, elseBranch: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Int

'nodePsi' @ [394:48] ==> val nodePsi: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'isLocal' @ [394:56] ==> public final val KtProperty.isLocal: Boolean[MyPropertyDescriptor]

'commonSettings' @ [395:48] ==> val commonSettings: (CommonCodeStyleSettings..CommonCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'VARIABLE_ANNOTATION_WRAP' @ [395:63] ==> public final var VARIABLE_ANNOTATION_WRAP: Int defined in com.intellij.psi.codeStyle.CommonCodeStyleSettings[JavaPropertyDescriptor]

'commonSettings' @ [397:48] ==> val commonSettings: (CommonCodeStyleSettings..CommonCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter.KotlinCommonBlock.getWrappingStrategy[LocalVariableDescriptor]

'FIELD_ANNOTATION_WRAP' @ [397:63] ==> public final var FIELD_ANNOTATION_WRAP: Int defined in com.intellij.psi.codeStyle.CommonCodeStyleSettings[JavaPropertyDescriptor]

'NoWrapping' @ [400:33] ==> public object NoWrapping : WrappingStrategy defined in org.jetbrains.kotlin.idea.formatter.WrappingStrategy[FakeCallableDescriptorForObject]

'firstChildNode' @ [404:46] ==> public final val ASTNode.firstChildNode: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'firstChildNode' @ [404:62] ==> public final val ASTNode.firstChildNode: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'elementType' @ [404:78] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'ANNOTATION_ENTRY' @ [404:105] ==> public final val ANNOTATION_ENTRY: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'treePrev' @ [406:51] ==> public final val ASTNode.treePrev: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'elementType' @ [406:61] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'LPAR' @ [406:85] ==> public final val LPAR: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'childElement' @ [411:17] ==> value-parameter childElement: ASTNode defined in org.jetbrains.kotlin.idea.formatter.wrapAfterAnnotation.<no name provided>.getWrap[ValueParameterDescriptorImpl]

'elementType' @ [411:30] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'COMMENTS' @ [411:54] ==> public final val COMMENTS: (TokenSet..TokenSet?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'childElement' @ [412:28] ==> value-parameter childElement: ASTNode defined in org.jetbrains.kotlin.idea.formatter.wrapAfterAnnotation.<no name provided>.getWrap[ValueParameterDescriptorImpl]

'treePrev' @ [412:41] ==> public final val ASTNode.treePrev: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'prevLeaf' @ [413:20] ==> var prevLeaf: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.idea.formatter.wrapAfterAnnotation.<no name provided>.getWrap[LocalVariableDescriptor]

'elementType' @ [413:30] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'WHITE_SPACE' @ [413:55] ==> public final val WHITE_SPACE: (IElementType..IElementType?) defined in com.intellij.psi.TokenType[JavaPropertyDescriptor]

'prevLeaf' @ [414:17] ==> var prevLeaf: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.idea.formatter.wrapAfterAnnotation.<no name provided>.getWrap[LocalVariableDescriptor]

'prevLeaf' @ [414:28] ==> var prevLeaf: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.idea.formatter.wrapAfterAnnotation.<no name provided>.getWrap[LocalVariableDescriptor]

'treePrev' @ [414:37] ==> public final val ASTNode.treePrev: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'prevLeaf' @ [416:17] ==> var prevLeaf: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.idea.formatter.wrapAfterAnnotation.<no name provided>.getWrap[LocalVariableDescriptor]

'elementType' @ [416:27] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'MODIFIER_LIST' @ [416:54] ==> public final val MODIFIER_LIST: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'prevLeaf' @ [417:21] ==> var prevLeaf: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.idea.formatter.wrapAfterAnnotation.<no name provided>.getWrap[LocalVariableDescriptor]

'lastChildNode' @ [417:31] ==> public final val ASTNode.lastChildNode: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'elementType' @ [417:46] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'ANNOTATIONS' @ [417:61] ==> private val ANNOTATIONS: TokenSet defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[PropertyDescriptorImpl]

'createWrap' @ [418:33] ==> public open fun createWrap(p0: Int, p1: Boolean): (Wrap..Wrap?) defined in com.intellij.formatting.Wrap[JavaMethodDescriptor]

'wrapType' @ [418:44] ==> value-parameter wrapType: Int defined in org.jetbrains.kotlin.idea.formatter.wrapAfterAnnotation[ValueParameterDescriptorImpl]

'arrayOf' @ [426:28] ==> public inline fun <reified @PureReifiable T> arrayOf(vararg elements: NodeIndentStrategy): Array<NodeIndentStrategy> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified @PureReifiable T> -> NodeIndentStrategy

'strategy' @ [427:9] ==> public final fun strategy(debugInfo: String?): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.Companion[FunctionImportedFromObject]

'within' @ [428:18] ==> public final fun within(parentType: IElementType, vararg orParentTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'BLOCK' @ [428:37] ==> public final val BLOCK: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'CLASS_BODY' @ [428:56] ==> public final val CLASS_BODY: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'FUNCTION_LITERAL' @ [428:80] ==> public final val FUNCTION_LITERAL: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'forType' @ [429:18] ==> public final fun forType(elementType: IElementType, vararg otherTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'RBRACE' @ [429:26] ==> public final val RBRACE: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'LBRACE' @ [429:34] ==> public final val LBRACE: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'set' @ [430:18] ==> public final fun set(indent: Indent): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'getNoneIndent' @ [430:29] ==> public open fun getNoneIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'strategy' @ [432:9] ==> public final fun strategy(debugInfo: String?): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.Companion[FunctionImportedFromObject]

'within' @ [433:18] ==> public final fun within(parentType: IElementType, vararg orParentTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'BLOCK' @ [433:37] ==> public final val BLOCK: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'CLASS_BODY' @ [433:56] ==> public final val CLASS_BODY: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'FUNCTION_LITERAL' @ [433:80] ==> public final val FUNCTION_LITERAL: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'notForType' @ [434:18] ==> public final fun notForType(elementType: IElementType, vararg otherTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'RBRACE' @ [434:29] ==> public final val RBRACE: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'LBRACE' @ [434:37] ==> public final val LBRACE: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'BLOCK' @ [434:57] ==> public final val BLOCK: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'set' @ [435:18] ==> public final fun set(indent: Indent): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'getNormalIndent' @ [435:29] ==> public open fun getNormalIndent(p0: Boolean): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'strategy' @ [437:9] ==> public final fun strategy(debugInfo: String?): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.Companion[FunctionImportedFromObject]

'within' @ [438:18] ==> public final fun within(parentType: IElementType, vararg orParentTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'PROPERTY' @ [438:37] ==> public final val PROPERTY: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'forType' @ [438:47] ==> public final fun forType(elementType: IElementType, vararg otherTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'PROPERTY_ACCESSOR' @ [438:67] ==> public final val PROPERTY_ACCESSOR: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'set' @ [439:18] ==> public final fun set(indent: Indent): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'getNormalIndent' @ [439:29] ==> public open fun getNormalIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'strategy' @ [441:9] ==> public final fun strategy(debugInfo: String?): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.Companion[FunctionImportedFromObject]

'within' @ [442:18] ==> public final fun within(parentType: IElementType, vararg orParentTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'BODY' @ [442:37] ==> public final val BODY: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'notForType' @ [442:43] ==> public final fun notForType(elementType: IElementType, vararg otherTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'BLOCK' @ [442:66] ==> public final val BLOCK: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'set' @ [443:18] ==> public final fun set(indent: Indent): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'getNormalIndent' @ [443:29] ==> public open fun getNormalIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'strategy' @ [445:9] ==> public final fun strategy(debugInfo: String?): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.Companion[FunctionImportedFromObject]

'forType' @ [446:18] ==> public final fun forType(elementType: IElementType, vararg otherTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'WHEN_ENTRY' @ [446:38] ==> public final val WHEN_ENTRY: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'set' @ [447:18] ==> public final fun set(indent: Indent): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'getNormalIndent' @ [447:29] ==> public open fun getNormalIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'strategy' @ [449:9] ==> public final fun strategy(debugInfo: String?): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.Companion[FunctionImportedFromObject]

'within' @ [450:18] ==> public final fun within(parentType: IElementType, vararg orParentTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'THEN' @ [450:37] ==> public final val THEN: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'ELSE' @ [450:55] ==> public final val ELSE: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'notForType' @ [450:61] ==> public final fun notForType(elementType: IElementType, vararg otherTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'BLOCK' @ [450:84] ==> public final val BLOCK: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'set' @ [451:18] ==> public final fun set(indent: Indent): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'getNormalIndent' @ [451:29] ==> public open fun getNormalIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'strategy' @ [453:9] ==> public final fun strategy(debugInfo: String?): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.Companion[FunctionImportedFromObject]

'within' @ [454:18] ==> public final fun within(parentType: IElementType, vararg orParentTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'FUN' @ [454:37] ==> public final val FUN: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'forElement' @ [455:18] ==> public final fun forElement(callback: (ASTNode) -> Boolean): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'it' @ [456:21] ==> value-parameter it: ASTNode defined in org.jetbrains.kotlin.idea.formatter.INDENT_RULES.<anonymous>[ValueParameterDescriptorImpl]

'psi' @ [456:24] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'it' @ [456:47] ==> value-parameter it: ASTNode defined in org.jetbrains.kotlin.idea.formatter.INDENT_RULES.<anonymous>[ValueParameterDescriptorImpl]

'psi' @ [456:50] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'set' @ [458:18] ==> public final fun set(indentCallback: (CodeStyleSettings) -> Indent): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'if (settings.kotlinSettings.CONTINUATION_INDENT_FOR_EXPRESSION_BODIES)
                        Indent.getContinuationIndent()
                    else
                        Indent.getNormalIndent()' @ [459:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Indent, elseBranch: Indent): Indent[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Indent

'settings' @ [459:25] ==> value-parameter settings: CodeStyleSettings defined in org.jetbrains.kotlin.idea.formatter.INDENT_RULES.<anonymous>[ValueParameterDescriptorImpl]

'kotlinSettings' @ [459:34] ==> public val CodeStyleSettings.kotlinSettings: (KotlinCodeStyleSettings..KotlinCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[PropertyDescriptorImpl]

'CONTINUATION_INDENT_FOR_EXPRESSION_BODIES' @ [459:49] ==> public final var CONTINUATION_INDENT_FOR_EXPRESSION_BODIES: Boolean defined in org.jetbrains.kotlin.idea.core.formatter.KotlinCodeStyleSettings[JavaPropertyDescriptor]

'getContinuationIndent' @ [460:32] ==> public open fun getContinuationIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'getNormalIndent' @ [462:32] ==> public open fun getNormalIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'strategy' @ [465:9] ==> public final fun strategy(debugInfo: String?): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.Companion[FunctionImportedFromObject]

'within' @ [466:18] ==> public final fun within(parentType: IElementType, vararg orParentTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'PROPERTY_ACCESSOR' @ [466:37] ==> public final val PROPERTY_ACCESSOR: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'forElement' @ [467:18] ==> public final fun forElement(callback: (ASTNode) -> Boolean): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'it' @ [468:21] ==> value-parameter it: ASTNode defined in org.jetbrains.kotlin.idea.formatter.INDENT_RULES.<anonymous>[ValueParameterDescriptorImpl]

'psi' @ [468:24] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'it' @ [468:47] ==> value-parameter it: ASTNode defined in org.jetbrains.kotlin.idea.formatter.INDENT_RULES.<anonymous>[ValueParameterDescriptorImpl]

'psi' @ [468:50] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'set' @ [470:18] ==> public final fun set(indent: Indent): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'getNormalIndent' @ [470:29] ==> public open fun getNormalIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'strategy' @ [472:9] ==> public final fun strategy(debugInfo: String?): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.Companion[FunctionImportedFromObject]

'within' @ [473:18] ==> public final fun within(parentType: IElementType, vararg orParentTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'PROPERTY' @ [473:37] ==> public final val PROPERTY: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'FUN' @ [473:59] ==> public final val FUN: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'DESTRUCTURING_DECLARATION' @ [473:76] ==> public final val DESTRUCTURING_DECLARATION: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'SECONDARY_CONSTRUCTOR' @ [473:115] ==> public final val SECONDARY_CONSTRUCTOR: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'notForType' @ [474:18] ==> public final fun notForType(elementType: IElementType, vararg otherTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'BLOCK' @ [474:41] ==> public final val BLOCK: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'FUN_KEYWORD' @ [474:48] ==> public final val FUN_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'VAL_KEYWORD' @ [474:61] ==> public final val VAL_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'VAR_KEYWORD' @ [474:74] ==> public final val VAR_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'CONSTRUCTOR_KEYWORD' @ [474:87] ==> public final val CONSTRUCTOR_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'set' @ [475:18] ==> public final fun set(indent: Indent): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'getContinuationWithoutFirstIndent' @ [475:29] ==> public open fun getContinuationWithoutFirstIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'strategy' @ [477:9] ==> public final fun strategy(debugInfo: String?): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.Companion[FunctionImportedFromObject]

'within' @ [478:18] ==> public final fun within(parentType: IElementType, vararg orParentTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'DOT_QUALIFIED_EXPRESSION' @ [478:37] ==> public final val DOT_QUALIFIED_EXPRESSION: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'SAFE_ACCESS_EXPRESSION' @ [478:75] ==> public final val SAFE_ACCESS_EXPRESSION: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'notForType' @ [479:18] ==> public final fun notForType(elementType: IElementType, vararg otherTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'DOT' @ [479:38] ==> public final val DOT: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'SAFE_ACCESS' @ [479:52] ==> public final val SAFE_ACCESS: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'forElement' @ [480:18] ==> public final fun forElement(callback: (ASTNode) -> Boolean): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'it' @ [480:31] ==> value-parameter it: ASTNode defined in org.jetbrains.kotlin.idea.formatter.INDENT_RULES.<anonymous>[ValueParameterDescriptorImpl]

'treeParent' @ [480:34] ==> public final val ASTNode.treeParent: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'firstChildNode' @ [480:45] ==> public final val ASTNode.firstChildNode: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'it' @ [480:63] ==> value-parameter it: ASTNode defined in org.jetbrains.kotlin.idea.formatter.INDENT_RULES.<anonymous>[ValueParameterDescriptorImpl]

'set' @ [481:18] ==> public final fun set(indentCallback: (CodeStyleSettings) -> Indent): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'if (settings.kotlinSettings.CONTINUATION_INDENT_FOR_CHAINED_CALLS)
                        Indent.getContinuationWithoutFirstIndent()
                    else
                        Indent.getNormalIndent()' @ [482:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Indent, elseBranch: Indent): Indent[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Indent

'settings' @ [482:25] ==> value-parameter settings: CodeStyleSettings defined in org.jetbrains.kotlin.idea.formatter.INDENT_RULES.<anonymous>[ValueParameterDescriptorImpl]

'kotlinSettings' @ [482:34] ==> public val CodeStyleSettings.kotlinSettings: (KotlinCodeStyleSettings..KotlinCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[PropertyDescriptorImpl]

'CONTINUATION_INDENT_FOR_CHAINED_CALLS' @ [482:49] ==> public final var CONTINUATION_INDENT_FOR_CHAINED_CALLS: Boolean defined in org.jetbrains.kotlin.idea.core.formatter.KotlinCodeStyleSettings[JavaPropertyDescriptor]

'getContinuationWithoutFirstIndent' @ [483:32] ==> public open fun getContinuationWithoutFirstIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'getNormalIndent' @ [485:32] ==> public open fun getNormalIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'strategy' @ [488:9] ==> public final fun strategy(debugInfo: String?): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.Companion[FunctionImportedFromObject]

'within' @ [489:18] ==> public final fun within(parentType: IElementType, vararg orParentTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'CLASS' @ [489:37] ==> public final val CLASS: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'OBJECT_DECLARATION' @ [489:56] ==> public final val OBJECT_DECLARATION: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'forType' @ [490:18] ==> public final fun forType(elementType: IElementType, vararg otherTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'COLON' @ [490:35] ==> public final val COLON: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'set' @ [491:18] ==> public final fun set(indent: Indent): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'getNormalIndent' @ [491:29] ==> public open fun getNormalIndent(p0: Boolean): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'strategy' @ [493:9] ==> public final fun strategy(debugInfo: String?): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.Companion[FunctionImportedFromObject]

'within' @ [494:18] ==> public final fun within(parentType: IElementType, vararg orParentTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'SUPER_TYPE_LIST' @ [494:37] ==> public final val SUPER_TYPE_LIST: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'INITIALIZER_LIST' @ [494:66] ==> public final val INITIALIZER_LIST: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'set' @ [495:18] ==> public final fun set(indent: Indent): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'getContinuationIndent' @ [495:29] ==> public open fun getContinuationIndent(p0: Boolean): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'strategy' @ [497:9] ==> public final fun strategy(debugInfo: String?): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.Companion[FunctionImportedFromObject]

'within' @ [498:18] ==> public final fun within(parentType: IElementType, vararg orParentTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'INDICES' @ [498:37] ==> public final val INDICES: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'set' @ [499:18] ==> public final fun set(indent: Indent): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'getContinuationIndent' @ [499:29] ==> public open fun getContinuationIndent(p0: Boolean): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'strategy' @ [501:9] ==> public final fun strategy(debugInfo: String?): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.Companion[FunctionImportedFromObject]

'within' @ [502:18] ==> public final fun within(parents: TokenSet): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'BINARY_EXPRESSIONS' @ [502:25] ==> private val BINARY_EXPRESSIONS: TokenSet defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[PropertyDescriptorImpl]

'set' @ [503:18] ==> public final fun set(indent: Indent): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'getContinuationWithoutFirstIndent' @ [503:29] ==> public open fun getContinuationWithoutFirstIndent(p0: Boolean): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'strategy' @ [505:9] ==> public final fun strategy(debugInfo: String?): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.Companion[FunctionImportedFromObject]

'within' @ [506:18] ==> public final fun within(parentType: IElementType, vararg orParentTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'PARENTHESIZED' @ [506:37] ==> public final val PARENTHESIZED: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'set' @ [507:18] ==> public final fun set(indent: Indent): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'getContinuationWithoutFirstIndent' @ [507:29] ==> public open fun getContinuationWithoutFirstIndent(p0: Boolean): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'strategy' @ [509:9] ==> public final fun strategy(debugInfo: String?): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.Companion[FunctionImportedFromObject]

'forType' @ [510:18] ==> public final fun forType(elementType: IElementType, vararg otherTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'LPAR' @ [510:26] ==> public final val LPAR: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'RPAR' @ [510:32] ==> public final val RPAR: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'within' @ [511:18] ==> public final fun within(parentType: IElementType, vararg orParentTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'IF' @ [511:37] ==> public final val IF: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'WHEN_ENTRY' @ [511:53] ==> public final val WHEN_ENTRY: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'WHILE' @ [511:77] ==> public final val WHILE: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'DO_WHILE' @ [511:96] ==> public final val DO_WHILE: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'set' @ [512:18] ==> public final fun set(indent: Indent): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'getContinuationWithoutFirstIndent' @ [512:29] ==> public open fun getContinuationWithoutFirstIndent(p0: Boolean): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'strategy' @ [514:9] ==> public final fun strategy(debugInfo: String?): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.Companion[FunctionImportedFromObject]

'within' @ [515:18] ==> public final fun within(parents: TokenSet): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'KDOC_CONTENT' @ [515:25] ==> private val KDOC_CONTENT: TokenSet defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[PropertyDescriptorImpl]

'forType' @ [516:18] ==> public final fun forType(elementType: IElementType, vararg otherTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'LEADING_ASTERISK' @ [516:37] ==> public final val LEADING_ASTERISK: (KDocToken..KDocToken?) defined in org.jetbrains.kotlin.kdoc.lexer.KDocTokens[JavaPropertyDescriptor]

'END' @ [516:66] ==> public final val END: (KDocToken..KDocToken?) defined in org.jetbrains.kotlin.kdoc.lexer.KDocTokens[JavaPropertyDescriptor]

'set' @ [517:18] ==> public final fun set(indent: Indent): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'getSpaceIndent' @ [517:29] ==> public open fun getSpaceIndent(p0: Int): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'KDOC_COMMENT_INDENT' @ [517:44] ==> private val KDOC_COMMENT_INDENT: Int defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[PropertyDescriptorImpl]

'strategy' @ [519:9] ==> public final fun strategy(debugInfo: String?): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.Companion[FunctionImportedFromObject]

'within' @ [520:18] ==> public final fun within(parentType: IElementType, vararg orParentTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'WHEN_ENTRY' @ [520:37] ==> public final val WHEN_ENTRY: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'notForType' @ [521:18] ==> public final fun notForType(elementType: IElementType, vararg otherTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'BLOCK' @ [521:41] ==> public final val BLOCK: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'WHEN_CONDITION_EXPRESSION' @ [521:60] ==> public final val WHEN_CONDITION_EXPRESSION: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'WHEN_CONDITION_IN_RANGE' @ [521:99] ==> public final val WHEN_CONDITION_IN_RANGE: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'WHEN_CONDITION_IS_PATTERN' @ [521:136] ==> public final val WHEN_CONDITION_IS_PATTERN: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'ELSE_KEYWORD' @ [521:163] ==> public final val ELSE_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'ARROW' @ [521:177] ==> public final val ARROW: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'set' @ [522:18] ==> public final fun set(indent: Indent): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'getNormalIndent' @ [522:29] ==> public open fun getNormalIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'strategy' @ [524:9] ==> public final fun strategy(debugInfo: String?): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.Companion[FunctionImportedFromObject]

'within' @ [525:18] ==> public final fun within(parentType: IElementType, vararg orParentTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'VALUE_PARAMETER_LIST' @ [525:37] ==> public final val VALUE_PARAMETER_LIST: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'forElement' @ [526:18] ==> public final fun forElement(callback: (ASTNode) -> Boolean): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'it' @ [526:31] ==> value-parameter it: ASTNode defined in org.jetbrains.kotlin.idea.formatter.INDENT_RULES.<anonymous>[ValueParameterDescriptorImpl]

'elementType' @ [526:34] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'VALUE_PARAMETER' @ [526:61] ==> public final val VALUE_PARAMETER: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'it' @ [526:80] ==> value-parameter it: ASTNode defined in org.jetbrains.kotlin.idea.formatter.INDENT_RULES.<anonymous>[ValueParameterDescriptorImpl]

'psi' @ [526:83] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'prevSibling' @ [526:87] ==> public final val PsiElement.prevSibling: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'set' @ [527:18] ==> public final fun set(indentCallback: (CodeStyleSettings) -> Indent): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'if (settings.kotlinSettings.CONTINUATION_INDENT_IN_PARAMETER_LISTS)
                        Indent.getContinuationIndent()
                    else
                        Indent.getNormalIndent()' @ [528:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Indent, elseBranch: Indent): Indent[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Indent

'settings' @ [528:25] ==> value-parameter settings: CodeStyleSettings defined in org.jetbrains.kotlin.idea.formatter.INDENT_RULES.<anonymous>[ValueParameterDescriptorImpl]

'kotlinSettings' @ [528:34] ==> public val CodeStyleSettings.kotlinSettings: (KotlinCodeStyleSettings..KotlinCodeStyleSettings?) defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[PropertyDescriptorImpl]

'CONTINUATION_INDENT_IN_PARAMETER_LISTS' @ [528:49] ==> public final var CONTINUATION_INDENT_IN_PARAMETER_LISTS: Boolean defined in org.jetbrains.kotlin.idea.core.formatter.KotlinCodeStyleSettings[JavaPropertyDescriptor]

'getContinuationIndent' @ [529:32] ==> public open fun getContinuationIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'getNormalIndent' @ [531:32] ==> public open fun getNormalIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'strategy' @ [534:9] ==> public final fun strategy(debugInfo: String?): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.Companion[FunctionImportedFromObject]

'within' @ [535:18] ==> public final fun within(parentType: IElementType, vararg orParentTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'CLASS' @ [535:37] ==> public final val CLASS: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'FUN' @ [535:56] ==> public final val FUN: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'PROPERTY' @ [535:73] ==> public final val PROPERTY: (IElementType..IElementType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'forType' @ [536:18] ==> public final fun forType(elementType: IElementType, vararg otherTypes: IElementType): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'WHERE_KEYWORD' @ [536:35] ==> public final val WHERE_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'set' @ [537:18] ==> public final fun set(indent: Indent): NodeIndentStrategy.PositionStrategy defined in org.jetbrains.kotlin.idea.formatter.NodeIndentStrategy.PositionStrategy[SimpleFunctionDescriptorImpl]

'getContinuationIndent' @ [537:29] ==> public open fun getContinuationIndent(): (Indent..Indent?) defined in com.intellij.formatting.Indent[JavaMethodDescriptor]

'node' @ [540:62] ==> value-parameter node: ASTNode defined in org.jetbrains.kotlin.idea.formatter.getOperationType[ValueParameterDescriptorImpl]

'findChildByType' @ [540:67] ==> @Nullable public abstract fun findChildByType(p0: (IElementType..IElementType?)): ASTNode? defined in com.intellij.lang.ASTNode[JavaMethodDescriptor]

'OPERATION_REFERENCE' @ [540:95] ==> public final val OPERATION_REFERENCE: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'firstChildNode' @ [540:117] ==> public final val ASTNode.firstChildNode: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'elementType' @ [540:133] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'if (shouldAlignChild) Alignment.createAlignment() else null' @ [545:30] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Alignment?, elseBranch: Alignment?): Alignment?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Alignment?

'shouldAlignChild' @ [545:34] ==> value-parameter shouldAlignChild: Boolean defined in org.jetbrains.kotlin.idea.formatter.getAlignmentForChildInParenthesis[ValueParameterDescriptorImpl]

'createAlignment' @ [545:62] ==> public open fun createAlignment(): (Alignment..Alignment?) defined in com.intellij.formatting.Alignment[JavaMethodDescriptor]

'if (shouldAlignParenthesis) Alignment.createAlignment() else null' @ [546:29] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Alignment?, elseBranch: Alignment?): Alignment?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Alignment?

'shouldAlignParenthesis' @ [546:33] ==> value-parameter shouldAlignParenthesis: Boolean defined in org.jetbrains.kotlin.idea.formatter.getAlignmentForChildInParenthesis[ValueParameterDescriptorImpl]

'createAlignment' @ [546:67] ==> public open fun createAlignment(): (Alignment..Alignment?) defined in com.intellij.formatting.Alignment[JavaMethodDescriptor]

'CommonAlignmentStrategy' @ [548:21] ==> public constructor CommonAlignmentStrategy() defined in org.jetbrains.kotlin.idea.formatter.CommonAlignmentStrategy[ClassConstructorDescriptorImpl]

'node' @ [550:33] ==> value-parameter node: ASTNode defined in org.jetbrains.kotlin.idea.formatter.getAlignmentForChildInParenthesis.<no name provided>.getAlignment[ValueParameterDescriptorImpl]

'elementType' @ [550:38] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'getPrevWithoutWhitespace' @ [552:24] ==> private fun getPrevWithoutWhitespace(pNode: ASTNode?): ASTNode? defined in org.jetbrains.kotlin.idea.formatter in file KotlinCommonBlock.kt[SimpleFunctionDescriptorImpl]

'node' @ [552:49] ==> value-parameter node: ASTNode defined in org.jetbrains.kotlin.idea.formatter.getAlignmentForChildInParenthesis.<no name provided>.getAlignment[ValueParameterDescriptorImpl]

'prev' @ [553:17] ==> val prev: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.getAlignmentForChildInParenthesis.<no name provided>.getAlignment[LocalVariableDescriptor]

'prev' @ [553:33] ==> val prev: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.getAlignmentForChildInParenthesis.<no name provided>.getAlignment[LocalVariableDescriptor]

'elementType' @ [553:38] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'ERROR_ELEMENT' @ [553:64] ==> public final val ERROR_ELEMENT: (IElementType..IElementType?) defined in com.intellij.psi.TokenType[JavaPropertyDescriptor]

'childNodeType' @ [553:81] ==> val childNodeType: IElementType defined in org.jetbrains.kotlin.idea.formatter.getAlignmentForChildInParenthesis.<no name provided>.getAlignment[LocalVariableDescriptor]

'ERROR_ELEMENT' @ [553:109] ==> public final val ERROR_ELEMENT: (IElementType..IElementType?) defined in com.intellij.psi.TokenType[JavaPropertyDescriptor]

'parameterAlignment' @ [555:24] ==> val parameterAlignment: Alignment? defined in org.jetbrains.kotlin.idea.formatter.getAlignmentForChildInParenthesis[LocalVariableDescriptor]

'childNodeType' @ [558:17] ==> val childNodeType: IElementType defined in org.jetbrains.kotlin.idea.formatter.getAlignmentForChildInParenthesis.<no name provided>.getAlignment[LocalVariableDescriptor]

'openBracket' @ [558:35] ==> value-parameter openBracket: IElementType defined in org.jetbrains.kotlin.idea.formatter.getAlignmentForChildInParenthesis[ValueParameterDescriptorImpl]

'childNodeType' @ [558:50] ==> val childNodeType: IElementType defined in org.jetbrains.kotlin.idea.formatter.getAlignmentForChildInParenthesis.<no name provided>.getAlignment[LocalVariableDescriptor]

'closeBracket' @ [558:68] ==> value-parameter closeBracket: IElementType defined in org.jetbrains.kotlin.idea.formatter.getAlignmentForChildInParenthesis[ValueParameterDescriptorImpl]

'bracketsAlignment' @ [559:24] ==> val bracketsAlignment: Alignment? defined in org.jetbrains.kotlin.idea.formatter.getAlignmentForChildInParenthesis[LocalVariableDescriptor]

'childNodeType' @ [562:17] ==> val childNodeType: IElementType defined in org.jetbrains.kotlin.idea.formatter.getAlignmentForChildInParenthesis.<no name provided>.getAlignment[LocalVariableDescriptor]

'parameter' @ [562:35] ==> value-parameter parameter: IElementType defined in org.jetbrains.kotlin.idea.formatter.getAlignmentForChildInParenthesis[ValueParameterDescriptorImpl]

'childNodeType' @ [562:48] ==> val childNodeType: IElementType defined in org.jetbrains.kotlin.idea.formatter.getAlignmentForChildInParenthesis.<no name provided>.getAlignment[LocalVariableDescriptor]

'delimiter' @ [562:66] ==> value-parameter delimiter: IElementType defined in org.jetbrains.kotlin.idea.formatter.getAlignmentForChildInParenthesis[ValueParameterDescriptorImpl]

'parameterAlignment' @ [563:24] ==> val parameterAlignment: Alignment? defined in org.jetbrains.kotlin.idea.formatter.getAlignmentForChildInParenthesis[LocalVariableDescriptor]

'pNode' @ [572:16] ==> value-parameter pNode: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.getPrevWithoutWhitespace[ValueParameterDescriptorImpl]

'node' @ [573:5] ==> var node: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.getPrevWithoutWhitespace[LocalVariableDescriptor]

'node' @ [573:12] ==> var node: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.getPrevWithoutWhitespace[LocalVariableDescriptor]

'treePrev' @ [573:19] ==> public final val ASTNode.treePrev: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'node' @ [574:12] ==> var node: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.getPrevWithoutWhitespace[LocalVariableDescriptor]

'node' @ [574:28] ==> var node: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.getPrevWithoutWhitespace[LocalVariableDescriptor]

'elementType' @ [574:33] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'WHITE_SPACE' @ [574:59] ==> public final val WHITE_SPACE: (IElementType..IElementType?) defined in com.intellij.psi.TokenType[JavaPropertyDescriptor]

'node' @ [575:9] ==> var node: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.getPrevWithoutWhitespace[LocalVariableDescriptor]

'node' @ [575:16] ==> var node: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.getPrevWithoutWhitespace[LocalVariableDescriptor]

'treePrev' @ [575:21] ==> public final val ASTNode.treePrev: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'node' @ [578:12] ==> var node: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.getPrevWithoutWhitespace[LocalVariableDescriptor]

'pNode' @ [582:16] ==> value-parameter pNode: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.getPrevWithoutWhitespaceAndComments[ValueParameterDescriptorImpl]

'node' @ [583:5] ==> var node: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.getPrevWithoutWhitespaceAndComments[LocalVariableDescriptor]

'node' @ [583:12] ==> var node: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.getPrevWithoutWhitespaceAndComments[LocalVariableDescriptor]

'treePrev' @ [583:19] ==> public final val ASTNode.treePrev: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'node' @ [584:12] ==> var node: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.getPrevWithoutWhitespaceAndComments[LocalVariableDescriptor]

'node' @ [584:29] ==> var node: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.getPrevWithoutWhitespaceAndComments[LocalVariableDescriptor]

'elementType' @ [584:34] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'WHITE_SPACE' @ [584:60] ==> public final val WHITE_SPACE: (IElementType..IElementType?) defined in com.intellij.psi.TokenType[JavaPropertyDescriptor]

'COMMENTS' @ [584:75] ==> public final val COMMENTS: (TokenSet..TokenSet?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'contains' @ [584:84] ==> public open operator fun contains(@Nullable p0: IElementType?): Boolean defined in com.intellij.psi.tree.TokenSet[JavaMethodDescriptor]

'node' @ [584:93] ==> var node: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.getPrevWithoutWhitespaceAndComments[LocalVariableDescriptor]

'elementType' @ [584:98] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'node' @ [585:9] ==> var node: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.getPrevWithoutWhitespaceAndComments[LocalVariableDescriptor]

'node' @ [585:16] ==> var node: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.getPrevWithoutWhitespaceAndComments[LocalVariableDescriptor]

'treePrev' @ [585:21] ==> public final val ASTNode.treePrev: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'node' @ [588:12] ==> var node: ASTNode? defined in org.jetbrains.kotlin.idea.formatter.getPrevWithoutWhitespaceAndComments[LocalVariableDescriptor]

'createWrap' @ [592:25] ==> public open fun createWrap(p0: Int, p1: Boolean): (Wrap..Wrap?) defined in com.intellij.formatting.Wrap[JavaMethodDescriptor]

'wrapType' @ [592:36] ==> value-parameter wrapType: Int defined in org.jetbrains.kotlin.idea.formatter.getWrappingStrategyForItemList[ValueParameterDescriptorImpl]

'wrapFirstElement' @ [592:46] ==> value-parameter wrapFirstElement: Boolean = ... defined in org.jetbrains.kotlin.idea.formatter.getWrappingStrategyForItemList[ValueParameterDescriptorImpl]

'if (childElement.elementType === itemType) itemWrap else null' @ [595:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Wrap?, elseBranch: Wrap?): Wrap?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Wrap?

'childElement' @ [595:24] ==> value-parameter childElement: ASTNode defined in org.jetbrains.kotlin.idea.formatter.getWrappingStrategyForItemList.<no name provided>.getWrap[ValueParameterDescriptorImpl]

'elementType' @ [595:37] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'itemType' @ [595:53] ==> value-parameter itemType: IElementType defined in org.jetbrains.kotlin.idea.formatter.getWrappingStrategyForItemList[ValueParameterDescriptorImpl]

'itemWrap' @ [595:63] ==> val itemWrap: (Wrap..Wrap?) defined in org.jetbrains.kotlin.idea.formatter.getWrappingStrategyForItemList[LocalVariableDescriptor]

'createWrap' @ [601:25] ==> public open fun createWrap(p0: Int, p1: Boolean): (Wrap..Wrap?) defined in com.intellij.formatting.Wrap[JavaMethodDescriptor]

'wrapType' @ [601:36] ==> value-parameter wrapType: Int defined in org.jetbrains.kotlin.idea.formatter.getWrappingStrategyForItemList[ValueParameterDescriptorImpl]

'wrapFirstElement' @ [601:46] ==> value-parameter wrapFirstElement: Boolean = ... defined in org.jetbrains.kotlin.idea.formatter.getWrappingStrategyForItemList[ValueParameterDescriptorImpl]

'if (childElement.elementType in itemTypes) itemWrap else null' @ [604:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Wrap?, elseBranch: Wrap?): Wrap?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Wrap?

'childElement' @ [604:24] ==> value-parameter childElement: ASTNode defined in org.jetbrains.kotlin.idea.formatter.getWrappingStrategyForItemList.<no name provided>.getWrap[ValueParameterDescriptorImpl]

'elementType' @ [604:37] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'itemTypes' @ [604:52] ==> value-parameter itemTypes: TokenSet defined in org.jetbrains.kotlin.idea.formatter.getWrappingStrategyForItemList[ValueParameterDescriptorImpl]

'itemWrap' @ [604:63] ==> val itemWrap: (Wrap..Wrap?) defined in org.jetbrains.kotlin.idea.formatter.getWrappingStrategyForItemList[LocalVariableDescriptor]

'blocks' @ [610:12] ==> value-parameter blocks: List<Block> defined in org.jetbrains.kotlin.idea.formatter.findNodeBlockIndex[ValueParameterDescriptorImpl]

'indexOfFirst' @ [610:19] ==> public inline fun <T> List<Block>.indexOfFirst(predicate: (Block) -> Boolean): Int defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Block

'block' @ [611:13] ==> value-parameter block: Block defined in org.jetbrains.kotlin.idea.formatter.findNodeBlockIndex.<anonymous>[ValueParameterDescriptorImpl]

'block' @ [613:20] ==> value-parameter block: Block defined in org.jetbrains.kotlin.idea.formatter.findNodeBlockIndex.<anonymous>[ValueParameterDescriptorImpl]

'node' @ [613:26] ==> public final val ASTBlock.node: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'node' @ [614:9] ==> val node: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.idea.formatter.findNodeBlockIndex.<anonymous>[LocalVariableDescriptor]

'node' @ [614:25] ==> val node: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.idea.formatter.findNodeBlockIndex.<anonymous>[LocalVariableDescriptor]

'elementType' @ [614:30] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'tokenSet' @ [614:45] ==> value-parameter tokenSet: TokenSet defined in org.jetbrains.kotlin.idea.formatter.findNodeBlockIndex[ValueParameterDescriptorImpl]

