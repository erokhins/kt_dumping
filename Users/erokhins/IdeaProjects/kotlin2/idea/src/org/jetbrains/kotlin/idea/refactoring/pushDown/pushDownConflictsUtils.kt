'usages' @ [47:25] ==> value-parameter usages: Array<out UsageInfo> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.analyzePushDownConflicts[ValueParameterDescriptorImpl]

'mapNotNull' @ [47:32] ==> public inline fun <T, R : Any> Array<out UsageInfo>.mapNotNull(transform: (UsageInfo) -> PsiElement?): List<PsiElement> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> UsageInfo
    <R : Any> -> PsiElement

'it' @ [47:45] ==> value-parameter it: UsageInfo defined in org.jetbrains.kotlin.idea.refactoring.pushDown.analyzePushDownConflicts.<anonymous>[ValueParameterDescriptorImpl]

'element' @ [47:48] ==> public final val UsageInfo.element: PsiElement?[MyPropertyDescriptor]

'unwrapped' @ [47:57] ==> public val PsiElement.unwrapped: PsiElement? defined in org.jetbrains.kotlin.asJava[DeserializedPropertyDescriptor]

'MultiMap' @ [49:21] ==> public constructor MultiMap<K : (Any..Any?), V : (Any..Any?)>() defined in com.intellij.util.containers.MultiMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> PsiElement
    <V : (Any..Any?)> -> String

'ArrayList' @ [51:25] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> KtNamedDeclaration

'ArrayList' @ [52:33] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> KtNamedDeclaration

'context' @ [53:18] ==> value-parameter context: KotlinPushDownContext defined in org.jetbrains.kotlin.idea.refactoring.pushDown.analyzePushDownConflicts[ValueParameterDescriptorImpl]

'membersToMove' @ [53:26] ==> public final val membersToMove: List<KotlinMemberInfo> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.KotlinPushDownContext[PropertyDescriptorImpl]

'info' @ [54:22] ==> val info: KotlinMemberInfo defined in org.jetbrains.kotlin.idea.refactoring.pushDown.analyzePushDownConflicts[LocalVariableDescriptor]

'member' @ [54:27] ==> public final val KotlinMemberInfo.member: (KtNamedDeclaration..KtNamedDeclaration?)[MyPropertyDescriptor]

'!' @ [55:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'info' @ [55:14] ==> val info: KotlinMemberInfo defined in org.jetbrains.kotlin.idea.refactoring.pushDown.analyzePushDownConflicts[LocalVariableDescriptor]

'isChecked' @ [55:19] ==> public final var KotlinMemberInfo.isChecked: Boolean[MyPropertyDescriptor]

'member' @ [55:34] ==> val member: (KtNamedDeclaration..KtNamedDeclaration?) defined in org.jetbrains.kotlin.idea.refactoring.pushDown.analyzePushDownConflicts[LocalVariableDescriptor]

'member' @ [55:63] ==> val member: (KtNamedDeclaration..KtNamedDeclaration?) defined in org.jetbrains.kotlin.idea.refactoring.pushDown.analyzePushDownConflicts[LocalVariableDescriptor]

'info' @ [55:95] ==> val info: KotlinMemberInfo defined in org.jetbrains.kotlin.idea.refactoring.pushDown.analyzePushDownConflicts[LocalVariableDescriptor]

'overrides' @ [55:100] ==> public final val KotlinMemberInfo.overrides: (Boolean..Boolean?)[MyPropertyDescriptor]

'membersToPush' @ [57:9] ==> val membersToPush: ArrayList<KtNamedDeclaration> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.analyzePushDownConflicts[LocalVariableDescriptor]

'member' @ [57:26] ==> val member: (KtNamedDeclaration..KtNamedDeclaration?) defined in org.jetbrains.kotlin.idea.refactoring.pushDown.analyzePushDownConflicts[LocalVariableDescriptor]

'member' @ [58:14] ==> val member: (KtNamedDeclaration..KtNamedDeclaration?) defined in org.jetbrains.kotlin.idea.refactoring.pushDown.analyzePushDownConflicts[LocalVariableDescriptor]

'member' @ [58:43] ==> val member: (KtNamedDeclaration..KtNamedDeclaration?) defined in org.jetbrains.kotlin.idea.refactoring.pushDown.analyzePushDownConflicts[LocalVariableDescriptor]

'info' @ [59:16] ==> val info: KotlinMemberInfo defined in org.jetbrains.kotlin.idea.refactoring.pushDown.analyzePushDownConflicts[LocalVariableDescriptor]

'isToAbstract' @ [59:21] ==> public final var KotlinMemberInfo.isToAbstract: Boolean[MyPropertyDescriptor]

'!=' @ [60:16] ==> public final fun equals(other: Any?): Boolean defined in org.jetbrains.kotlin.descriptors.Modality[DeserializedSimpleFunctionDescriptor]

'context' @ [60:17] ==> value-parameter context: KotlinPushDownContext defined in org.jetbrains.kotlin.idea.refactoring.pushDown.analyzePushDownConflicts[ValueParameterDescriptorImpl]

'memberDescriptors' @ [60:25] ==> public final val memberDescriptors: Map<(KtNamedDeclaration..KtNamedDeclaration?), DeclarationDescriptor> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.KotlinPushDownContext[PropertyDescriptorImpl]

'member' @ [60:43] ==> val member: (KtNamedDeclaration..KtNamedDeclaration?) defined in org.jetbrains.kotlin.idea.refactoring.pushDown.analyzePushDownConflicts[LocalVariableDescriptor]

'modality' @ [60:80] ==> public final val CallableMemberDescriptor.modality: Modality[MyPropertyDescriptor]

'ABSTRACT' @ [60:101] ==> enum entry ABSTRACT defined in org.jetbrains.kotlin.descriptors.Modality[FakeCallableDescriptorForObject]

'membersToKeepAbstract' @ [61:13] ==> val membersToKeepAbstract: ArrayList<KtNamedDeclaration> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.analyzePushDownConflicts[LocalVariableDescriptor]

'member' @ [61:38] ==> val member: (KtNamedDeclaration..KtNamedDeclaration?) defined in org.jetbrains.kotlin.idea.refactoring.pushDown.analyzePushDownConflicts[LocalVariableDescriptor]

'targetClasses' @ [65:25] ==> val targetClasses: List<PsiElement> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.analyzePushDownConflicts[LocalVariableDescriptor]

'checkConflicts' @ [66:9] ==> private fun checkConflicts(conflicts: MultiMap<PsiElement, String>, context: KotlinPushDownContext, targetClass: PsiElement, membersToKeepAbstract: List<KtNamedDeclaration>, membersToPush: ArrayList<KtNamedDeclaration>): Unit defined in org.jetbrains.kotlin.idea.refactoring.pushDown in file pushDownConflictsUtils.kt[SimpleFunctionDescriptorImpl]

'conflicts' @ [66:24] ==> val conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.analyzePushDownConflicts[LocalVariableDescriptor]

'context' @ [66:35] ==> value-parameter context: KotlinPushDownContext defined in org.jetbrains.kotlin.idea.refactoring.pushDown.analyzePushDownConflicts[ValueParameterDescriptorImpl]

'targetClass' @ [66:44] ==> val targetClass: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.pushDown.analyzePushDownConflicts[LocalVariableDescriptor]

'membersToKeepAbstract' @ [66:57] ==> val membersToKeepAbstract: ArrayList<KtNamedDeclaration> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.analyzePushDownConflicts[LocalVariableDescriptor]

'membersToPush' @ [66:80] ==> val membersToPush: ArrayList<KtNamedDeclaration> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.analyzePushDownConflicts[LocalVariableDescriptor]

'conflicts' @ [69:12] ==> val conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.analyzePushDownConflicts[LocalVariableDescriptor]

'targetClass' @ [79:9] ==> value-parameter targetClass: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'conflicts' @ [80:9] ==> value-parameter conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'putValue' @ [80:19] ==> public open fun putValue(@Nullable p0: PsiElement?, p1: (String..String?)): Unit defined in com.intellij.util.containers.MultiMap[JavaMethodDescriptor]

'targetClass' @ [81:17] ==> value-parameter targetClass: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'getDescription' @ [82:49] ==> public open fun getDescription(@NotNull p0: PsiElement, p1: Boolean): (String..String?) defined in com.intellij.refactoring.util.RefactoringUIUtil[JavaMethodDescriptor]

'targetClass' @ [82:64] ==> value-parameter targetClass: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'context' @ [87:33] ==> value-parameter context: KotlinPushDownContext defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'resolutionFacade' @ [87:41] ==> public final val resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.refactoring.pushDown.KotlinPushDownContext[PropertyDescriptorImpl]

'resolveToDescriptor' @ [87:58] ==> public abstract fun resolveToDescriptor(declaration: KtDeclaration, bodyResolveMode: BodyResolveMode = ...): DeclarationDescriptor defined in org.jetbrains.kotlin.idea.resolve.ResolutionFacade[DeserializedSimpleFunctionDescriptor]

'targetClass' @ [87:78] ==> value-parameter targetClass: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'getTypeSubstitutor' @ [88:23] ==> public fun getTypeSubstitutor(baseType: KotlinType, derivedType: KotlinType): TypeSubstitutor? defined in org.jetbrains.kotlin.types.substitutions[DeserializedSimpleFunctionDescriptor]

'context' @ [88:42] ==> value-parameter context: KotlinPushDownContext defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'sourceClassDescriptor' @ [88:50] ==> public final val sourceClassDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.KotlinPushDownContext[PropertyDescriptorImpl]

'defaultType' @ [88:72] ==> public final val ClassDescriptor.defaultType: SimpleType[MyPropertyDescriptor]

'targetClassDescriptor' @ [88:85] ==> val targetClassDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[LocalVariableDescriptor]

'defaultType' @ [88:107] ==> public final val ClassDescriptor.defaultType: SimpleType[MyPropertyDescriptor]

'EMPTY' @ [89:42] ==> public final val EMPTY: (TypeSubstitutor..TypeSubstitutor?) defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaPropertyDescriptor]

'!' @ [91:9] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'context' @ [91:10] ==> value-parameter context: KotlinPushDownContext defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'sourceClass' @ [91:18] ==> public final val sourceClass: KtClass defined in org.jetbrains.kotlin.idea.refactoring.pushDown.KotlinPushDownContext[PropertyDescriptorImpl]

'isInterface' @ [91:30] ==> public final fun isInterface(): Boolean defined in org.jetbrains.kotlin.psi.KtClass[DeserializedSimpleFunctionDescriptor]

'targetClass' @ [91:47] ==> value-parameter targetClass: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'targetClass' @ [91:73] ==> value-parameter targetClass: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'isInterface' @ [91:85] ==> public final fun isInterface(): Boolean defined in org.jetbrains.kotlin.psi.KtClass[DeserializedSimpleFunctionDescriptor]

'+' @ [92:23] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'targetClassDescriptor' @ [92:26] ==> val targetClassDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[LocalVariableDescriptor]

'renderForConflicts' @ [92:48] ==> public fun DeclarationDescriptor.renderForConflicts(): String defined in org.jetbrains.kotlin.idea.refactoring.pullUp in file pullUpConflictsUtils.kt[SimpleFunctionDescriptorImpl]

'context' @ [93:40] ==> value-parameter context: KotlinPushDownContext defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'sourceClassDescriptor' @ [93:48] ==> public final val sourceClassDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.KotlinPushDownContext[PropertyDescriptorImpl]

'renderForConflicts' @ [93:70] ==> public fun DeclarationDescriptor.renderForConflicts(): String defined in org.jetbrains.kotlin.idea.refactoring.pullUp in file pullUpConflictsUtils.kt[SimpleFunctionDescriptorImpl]

'conflicts' @ [95:9] ==> value-parameter conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'putValue' @ [95:19] ==> public open fun putValue(@Nullable p0: PsiElement?, p1: (String..String?)): Unit defined in com.intellij.util.containers.MultiMap[JavaMethodDescriptor]

'targetClass' @ [95:28] ==> value-parameter targetClass: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'message' @ [95:41] ==> val message: String defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[LocalVariableDescriptor]

'capitalize' @ [95:49] ==> public fun String.capitalize(): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'membersToPush' @ [98:20] ==> value-parameter membersToPush: ArrayList<KtNamedDeclaration> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'checkMemberClashing' @ [99:9] ==> private fun checkMemberClashing(conflicts: MultiMap<PsiElement, String>, context: KotlinPushDownContext, member: KtNamedDeclaration, membersToKeepAbstract: List<KtNamedDeclaration>, substitutor: TypeSubstitutor, targetClass: KtClassOrObject, targetClassDescriptor: ClassDescriptor): Unit defined in org.jetbrains.kotlin.idea.refactoring.pushDown in file pushDownConflictsUtils.kt[SimpleFunctionDescriptorImpl]

'conflicts' @ [99:29] ==> value-parameter conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'context' @ [99:40] ==> value-parameter context: KotlinPushDownContext defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'member' @ [99:49] ==> val member: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[LocalVariableDescriptor]

'membersToKeepAbstract' @ [99:57] ==> value-parameter membersToKeepAbstract: List<KtNamedDeclaration> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'substitutor' @ [99:80] ==> val substitutor: (TypeSubstitutor..TypeSubstitutor?) defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[LocalVariableDescriptor]

'targetClass' @ [99:93] ==> value-parameter targetClass: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'targetClassDescriptor' @ [99:106] ==> val targetClassDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[LocalVariableDescriptor]

'checkSuperCalls' @ [100:9] ==> private fun checkSuperCalls(conflicts: MultiMap<PsiElement, String>, context: KotlinPushDownContext, member: KtNamedDeclaration, membersToPush: ArrayList<KtNamedDeclaration>): Unit defined in org.jetbrains.kotlin.idea.refactoring.pushDown in file pushDownConflictsUtils.kt[SimpleFunctionDescriptorImpl]

'conflicts' @ [100:25] ==> value-parameter conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'context' @ [100:36] ==> value-parameter context: KotlinPushDownContext defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'member' @ [100:45] ==> val member: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[LocalVariableDescriptor]

'membersToPush' @ [100:53] ==> value-parameter membersToPush: ArrayList<KtNamedDeclaration> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'checkExternalUsages' @ [101:9] ==> internal fun checkExternalUsages(conflicts: MultiMap<PsiElement, String>, member: PsiElement, targetClassDescriptor: ClassDescriptor, resolutionFacade: ResolutionFacade): Unit defined in org.jetbrains.kotlin.idea.refactoring.pushDown in file pushDownConflictsUtils.kt[SimpleFunctionDescriptorImpl]

'conflicts' @ [101:29] ==> value-parameter conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'member' @ [101:40] ==> val member: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[LocalVariableDescriptor]

'targetClassDescriptor' @ [101:48] ==> val targetClassDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[LocalVariableDescriptor]

'context' @ [101:71] ==> value-parameter context: KotlinPushDownContext defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'resolutionFacade' @ [101:79] ==> public final val resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.refactoring.pushDown.KotlinPushDownContext[PropertyDescriptorImpl]

'checkVisibility' @ [102:9] ==> private fun checkVisibility(conflicts: MultiMap<PsiElement, String>, context: KotlinPushDownContext, member: KtNamedDeclaration, targetClassDescriptor: ClassDescriptor): Unit defined in org.jetbrains.kotlin.idea.refactoring.pushDown in file pushDownConflictsUtils.kt[SimpleFunctionDescriptorImpl]

'conflicts' @ [102:25] ==> value-parameter conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'context' @ [102:36] ==> value-parameter context: KotlinPushDownContext defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[ValueParameterDescriptorImpl]

'member' @ [102:45] ==> val member: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[LocalVariableDescriptor]

'targetClassDescriptor' @ [102:53] ==> val targetClassDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkConflicts[LocalVariableDescriptor]

'when (member) {
        is KtNamedFunction, is KtProperty -> {
            val memberDescriptor = context.memberDescriptors[member] as CallableMemberDescriptor
            val clashingDescriptor = targetClassDescriptor.findCallableMemberBySignature(memberDescriptor.substitute(substitutor) as CallableMemberDescriptor)
            val clashingDeclaration = clashingDescriptor?.source?.getPsi() as? KtNamedDeclaration
            if (clashingDescriptor != null && clashingDeclaration != null) {
                if (memberDescriptor.modality != Modality.ABSTRACT && member !in membersToKeepAbstract) {
                    val message = "${targetClassDescriptor.renderForConflicts()} already contains ${clashingDescriptor.renderForConflicts()}"
                    conflicts.putValue(clashingDeclaration, CommonRefactoringUtil.capitalize(message))
                }
                if (!clashingDeclaration.hasModifier(KtTokens.OVERRIDE_KEYWORD)) {
                    val message = "${clashingDescriptor.renderForConflicts()} in ${targetClassDescriptor.renderForConflicts()} " +
                                  "will override corresponding member of ${context.sourceClassDescriptor.renderForConflicts()} " +
                                  "after refactoring"
                    conflicts.putValue(clashingDeclaration, CommonRefactoringUtil.capitalize(message))
                }
            }
        }

        is KtClassOrObject -> {
            targetClass.declarations
                    .filterIsInstance<KtClassOrObject>()
                    .firstOrNull() { it.name == member.name }
                    ?.let {
                        val message = "${targetClassDescriptor.renderForConflicts()} " +
                                      "already contains nested class named ${CommonRefactoringUtil.htmlEmphasize(member.name ?: "")}"
                        conflicts.putValue(it, message.capitalize())
                    }
        }
    }' @ [114:5] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit?, entry1: Unit?): Unit?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit?

'member' @ [114:11] ==> value-parameter member: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[ValueParameterDescriptorImpl]

'context' @ [116:36] ==> value-parameter context: KotlinPushDownContext defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[ValueParameterDescriptorImpl]

'memberDescriptors' @ [116:44] ==> public final val memberDescriptors: Map<(KtNamedDeclaration..KtNamedDeclaration?), DeclarationDescriptor> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.KotlinPushDownContext[PropertyDescriptorImpl]

'member' @ [116:62] ==> value-parameter member: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[ValueParameterDescriptorImpl]

'targetClassDescriptor' @ [117:38] ==> value-parameter targetClassDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[ValueParameterDescriptorImpl]

'findCallableMemberBySignature' @ [117:60] ==> public fun ClassDescriptor.findCallableMemberBySignature(signature: CallableMemberDescriptor, allowOverridabilityConflicts: Boolean = ...): CallableMemberDescriptor? defined in org.jetbrains.kotlin.util[DeserializedSimpleFunctionDescriptor]

'memberDescriptor' @ [117:90] ==> val memberDescriptor: CallableMemberDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[LocalVariableDescriptor]

'substitute' @ [117:107] ==> public abstract fun substitute(substitutor: TypeSubstitutor): (CallableDescriptor..CallableDescriptor?) defined in org.jetbrains.kotlin.descriptors.CallableMemberDescriptor[DeserializedSimpleFunctionDescriptor]

'substitutor' @ [117:118] ==> value-parameter substitutor: TypeSubstitutor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[ValueParameterDescriptorImpl]

'clashingDescriptor' @ [118:39] ==> val clashingDescriptor: CallableMemberDescriptor? defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[LocalVariableDescriptor]

'source' @ [118:59] ==> public final val CallableMemberDescriptor.source: SourceElement[MyPropertyDescriptor]

'getPsi' @ [118:67] ==> public fun SourceElement.getPsi(): PsiElement? defined in org.jetbrains.kotlin.resolve.source[DeserializedSimpleFunctionDescriptor]

'clashingDescriptor' @ [119:17] ==> val clashingDescriptor: CallableMemberDescriptor? defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[LocalVariableDescriptor]

'clashingDeclaration' @ [119:47] ==> val clashingDeclaration: KtNamedDeclaration? defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[LocalVariableDescriptor]

'memberDescriptor' @ [120:21] ==> val memberDescriptor: CallableMemberDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[LocalVariableDescriptor]

'modality' @ [120:38] ==> public final val CallableMemberDescriptor.modality: Modality[MyPropertyDescriptor]

'ABSTRACT' @ [120:59] ==> enum entry ABSTRACT defined in org.jetbrains.kotlin.descriptors.Modality[FakeCallableDescriptorForObject]

'member' @ [120:71] ==> value-parameter member: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[ValueParameterDescriptorImpl]

'membersToKeepAbstract' @ [120:82] ==> value-parameter membersToKeepAbstract: List<KtNamedDeclaration> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[ValueParameterDescriptorImpl]

'targetClassDescriptor' @ [121:38] ==> value-parameter targetClassDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[ValueParameterDescriptorImpl]

'renderForConflicts' @ [121:60] ==> public fun DeclarationDescriptor.renderForConflicts(): String defined in org.jetbrains.kotlin.idea.refactoring.pullUp in file pullUpConflictsUtils.kt[SimpleFunctionDescriptorImpl]

'clashingDescriptor' @ [121:101] ==> val clashingDescriptor: CallableMemberDescriptor? defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[LocalVariableDescriptor]

'renderForConflicts' @ [121:120] ==> public fun DeclarationDescriptor.renderForConflicts(): String defined in org.jetbrains.kotlin.idea.refactoring.pullUp in file pullUpConflictsUtils.kt[SimpleFunctionDescriptorImpl]

'conflicts' @ [122:21] ==> value-parameter conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[ValueParameterDescriptorImpl]

'putValue' @ [122:31] ==> public open fun putValue(@Nullable p0: PsiElement?, p1: (String..String?)): Unit defined in com.intellij.util.containers.MultiMap[JavaMethodDescriptor]

'clashingDeclaration' @ [122:40] ==> val clashingDeclaration: KtNamedDeclaration? defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[LocalVariableDescriptor]

'capitalize' @ [122:83] ==> public open fun capitalize(@NotNull p0: String): (String..String?) defined in com.intellij.refactoring.util.CommonRefactoringUtil[JavaMethodDescriptor]

'message' @ [122:94] ==> val message: String defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[LocalVariableDescriptor]

'!' @ [124:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'clashingDeclaration' @ [124:22] ==> val clashingDeclaration: KtNamedDeclaration? defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[LocalVariableDescriptor]

'hasModifier' @ [124:42] ==> public abstract fun hasModifier(@NotNull p0: KtModifierKeywordToken): Boolean defined in org.jetbrains.kotlin.psi.KtNamedDeclaration[JavaMethodDescriptor]

'OVERRIDE_KEYWORD' @ [124:63] ==> public final val OVERRIDE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'+' @ [125:35] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'clashingDescriptor' @ [125:38] ==> val clashingDescriptor: CallableMemberDescriptor? defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[LocalVariableDescriptor]

'renderForConflicts' @ [125:57] ==> public fun DeclarationDescriptor.renderForConflicts(): String defined in org.jetbrains.kotlin.idea.refactoring.pullUp in file pullUpConflictsUtils.kt[SimpleFunctionDescriptorImpl]

'targetClassDescriptor' @ [125:84] ==> value-parameter targetClassDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[ValueParameterDescriptorImpl]

'renderForConflicts' @ [125:106] ==> public fun DeclarationDescriptor.renderForConflicts(): String defined in org.jetbrains.kotlin.idea.refactoring.pullUp in file pullUpConflictsUtils.kt[SimpleFunctionDescriptorImpl]

'context' @ [126:76] ==> value-parameter context: KotlinPushDownContext defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[ValueParameterDescriptorImpl]

'sourceClassDescriptor' @ [126:84] ==> public final val sourceClassDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.KotlinPushDownContext[PropertyDescriptorImpl]

'renderForConflicts' @ [126:106] ==> public fun DeclarationDescriptor.renderForConflicts(): String defined in org.jetbrains.kotlin.idea.refactoring.pullUp in file pullUpConflictsUtils.kt[SimpleFunctionDescriptorImpl]

'conflicts' @ [128:21] ==> value-parameter conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[ValueParameterDescriptorImpl]

'putValue' @ [128:31] ==> public open fun putValue(@Nullable p0: PsiElement?, p1: (String..String?)): Unit defined in com.intellij.util.containers.MultiMap[JavaMethodDescriptor]

'clashingDeclaration' @ [128:40] ==> val clashingDeclaration: KtNamedDeclaration? defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[LocalVariableDescriptor]

'capitalize' @ [128:83] ==> public open fun capitalize(@NotNull p0: String): (String..String?) defined in com.intellij.refactoring.util.CommonRefactoringUtil[JavaMethodDescriptor]

'message' @ [128:94] ==> val message: String defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[LocalVariableDescriptor]

'targetClass' @ [134:13] ==> value-parameter targetClass: KtClassOrObject defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[ValueParameterDescriptorImpl]

'declarations' @ [134:25] ==> public final val KtClassOrObject.declarations: List<KtDeclaration>[MyPropertyDescriptor]

'filterIsInstance' @ [135:22] ==> public inline fun <reified R> Iterable<*>.filterIsInstance(): List<KtClassOrObject> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified R> -> KtClassOrObject

'firstOrNull' @ [136:22] ==> public inline fun <T> Iterable<KtClassOrObject>.firstOrNull(predicate: (KtClassOrObject) -> Boolean): KtClassOrObject? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtClassOrObject

'it' @ [136:38] ==> value-parameter it: KtClassOrObject defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [136:41] ==> public final val KtClassOrObject.name: String?[MyPropertyDescriptor]

'member' @ [136:49] ==> value-parameter member: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[ValueParameterDescriptorImpl]

'name' @ [136:56] ==> public final val KtClassOrObject.name: String?[MyPropertyDescriptor]

'let' @ [137:23] ==> @InlineOnly public inline fun <T, R> KtClassOrObject.let(block: (KtClassOrObject) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtClassOrObject
    <R> -> Unit

'+' @ [138:39] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'targetClassDescriptor' @ [138:42] ==> value-parameter targetClassDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[ValueParameterDescriptorImpl]

'renderForConflicts' @ [138:64] ==> public fun DeclarationDescriptor.renderForConflicts(): String defined in org.jetbrains.kotlin.idea.refactoring.pullUp in file pullUpConflictsUtils.kt[SimpleFunctionDescriptorImpl]

'htmlEmphasize' @ [139:100] ==> public open fun htmlEmphasize(@NotNull p0: String): (String..String?) defined in com.intellij.refactoring.util.CommonRefactoringUtil[JavaMethodDescriptor]

'member' @ [139:114] ==> value-parameter member: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[ValueParameterDescriptorImpl]

'name' @ [139:121] ==> public final val KtClassOrObject.name: String?[MyPropertyDescriptor]

'conflicts' @ [140:25] ==> value-parameter conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing[ValueParameterDescriptorImpl]

'putValue' @ [140:35] ==> public open fun putValue(@Nullable p0: PsiElement?, p1: (String..String?)): Unit defined in com.intellij.util.containers.MultiMap[JavaMethodDescriptor]

'it' @ [140:44] ==> value-parameter it: KtClassOrObject defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing.<anonymous>[ValueParameterDescriptorImpl]

'message' @ [140:48] ==> val message: String defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkMemberClashing.<anonymous>[LocalVariableDescriptor]

'capitalize' @ [140:56] ==> public fun String.capitalize(): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'member' @ [152:5] ==> value-parameter member: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkSuperCalls[ValueParameterDescriptorImpl]

'accept' @ [152:12] ==> public abstract fun accept(@NotNull p0: PsiElementVisitor): Unit defined in org.jetbrains.kotlin.psi.KtNamedDeclaration[JavaMethodDescriptor]

'KtTreeVisitorVoid' @ [153:22] ==> public constructor KtTreeVisitorVoid() defined in org.jetbrains.kotlin.psi.KtTreeVisitorVoid[JavaClassConstructorDescriptor]

'expression' @ [155:47] ==> value-parameter expression: KtSuperExpression defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkSuperCalls.<no name provided>.visitSuperExpression[ValueParameterDescriptorImpl]

'getQualifiedExpressionForReceiver' @ [155:58] ==> public fun KtExpression.getQualifiedExpressionForReceiver(): KtQualifiedExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'qualifiedExpression' @ [156:35] ==> val qualifiedExpression: KtQualifiedExpression defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkSuperCalls.<no name provided>.visitSuperExpression[LocalVariableDescriptor]

'selectorExpression' @ [156:55] ==> public open val selectorExpression: KtExpression? defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[DeserializedPropertyDescriptor]

'getCalleeExpressionIfAny' @ [156:74] ==> public fun KtElement?.getCalleeExpressionIfAny(): KtExpression? defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'refExpr' @ [157:40] ==> val refExpr: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkSuperCalls.<no name provided>.visitSuperExpression[LocalVariableDescriptor]

'mainReference' @ [157:48] ==> public val KtSimpleNameExpression.mainReference: KtSimpleNameReference defined in org.jetbrains.kotlin.idea.references[DeserializedPropertyDescriptor]

'resolveToDescriptors' @ [157:62] ==> public open fun resolveToDescriptors(bindingContext: BindingContext): Collection<DeclarationDescriptor> defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[DeserializedSimpleFunctionDescriptor]

'context' @ [157:83] ==> value-parameter context: KotlinPushDownContext defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkSuperCalls[ValueParameterDescriptorImpl]

'sourceClassContext' @ [157:91] ==> public final val sourceClassContext: BindingContext defined in org.jetbrains.kotlin.idea.refactoring.pushDown.KotlinPushDownContext[PropertyDescriptorImpl]

'descriptor' @ [158:48] ==> val descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkSuperCalls.<no name provided>.visitSuperExpression[LocalVariableDescriptor]

'memberDescriptor' @ [159:47] ==> val memberDescriptor: CallableMemberDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkSuperCalls.<no name provided>.visitSuperExpression[LocalVariableDescriptor]

'containingDeclaration' @ [159:64] ==> public final val CallableMemberDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'!' @ [160:29] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isSubclass' @ [160:46] ==> public open fun isSubclass(@NotNull p0: ClassDescriptor, @NotNull p1: ClassDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'context' @ [160:57] ==> value-parameter context: KotlinPushDownContext defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkSuperCalls[ValueParameterDescriptorImpl]

'sourceClassDescriptor' @ [160:65] ==> public final val sourceClassDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.KotlinPushDownContext[PropertyDescriptorImpl]

'containingClass' @ [160:88] ==> val containingClass: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkSuperCalls.<no name provided>.visitSuperExpression[LocalVariableDescriptor]

'context' @ [161:46] ==> value-parameter context: KotlinPushDownContext defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkSuperCalls[ValueParameterDescriptorImpl]

'sourceClassDescriptor' @ [161:54] ==> public final val sourceClassDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.KotlinPushDownContext[PropertyDescriptorImpl]

'findCallableMemberBySignature' @ [161:76] ==> public fun ClassDescriptor.findCallableMemberBySignature(signature: CallableMemberDescriptor, allowOverridabilityConflicts: Boolean = ...): CallableMemberDescriptor? defined in org.jetbrains.kotlin.util[DeserializedSimpleFunctionDescriptor]

'memberDescriptor' @ [161:106] ==> val memberDescriptor: CallableMemberDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkSuperCalls.<no name provided>.visitSuperExpression[LocalVariableDescriptor]

'source' @ [161:125] ==> public final val CallableMemberDescriptor.source: SourceElement[MyPropertyDescriptor]

'getPsi' @ [161:133] ==> public fun SourceElement.getPsi(): PsiElement? defined in org.jetbrains.kotlin.resolve.source[DeserializedSimpleFunctionDescriptor]

'memberInSource' @ [163:29] ==> val memberInSource: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkSuperCalls.<no name provided>.visitSuperExpression[LocalVariableDescriptor]

'membersToPush' @ [163:48] ==> value-parameter membersToPush: ArrayList<KtNamedDeclaration> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkSuperCalls[ValueParameterDescriptorImpl]

'conflicts' @ [164:29] ==> value-parameter conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkSuperCalls[ValueParameterDescriptorImpl]

'putValue' @ [164:39] ==> public open fun putValue(@Nullable p0: PsiElement?, p1: (String..String?)): Unit defined in com.intellij.util.containers.MultiMap[JavaMethodDescriptor]

'qualifiedExpression' @ [164:48] ==> val qualifiedExpression: KtQualifiedExpression defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkSuperCalls.<no name provided>.visitSuperExpression[LocalVariableDescriptor]

'qualifiedExpression' @ [165:88] ==> val qualifiedExpression: KtQualifiedExpression defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkSuperCalls.<no name provided>.visitSuperExpression[LocalVariableDescriptor]

'text' @ [165:108] ==> public final val KtQualifiedExpression.text: (String..String?)[MyPropertyDescriptor]

'iterator' @ [179:17] ==> public abstract fun iterator(): MutableIterator<(PsiReference..PsiReference?)> defined in com.intellij.util.Query[DeserializedSimpleFunctionDescriptor]

'search' @ [179:34] ==> @NotNull public open fun search(@NotNull p0: PsiElement, @NotNull p1: SearchScope, p2: Boolean): Query<(PsiReference..PsiReference?)> defined in com.intellij.psi.search.searches.ReferencesSearch[JavaMethodDescriptor]

'member' @ [179:41] ==> value-parameter member: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkExternalUsages[ValueParameterDescriptorImpl]

'member' @ [179:49] ==> value-parameter member: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkExternalUsages[ValueParameterDescriptorImpl]

'resolveScope' @ [179:56] ==> public final val PsiElement.resolveScope: GlobalSearchScope[MyPropertyDescriptor]

'ref' @ [180:26] ==> val ref: (PsiReference..PsiReference?) defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkExternalUsages[LocalVariableDescriptor]

'element' @ [180:30] ==> public final val PsiReference.element: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'calleeExpr' @ [181:28] ==> val calleeExpr: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkExternalUsages[LocalVariableDescriptor]

'getResolvedCall' @ [181:39] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'resolutionFacade' @ [181:55] ==> value-parameter resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkExternalUsages[ValueParameterDescriptorImpl]

'analyze' @ [181:72] ==> public abstract fun analyze(element: KtElement, bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.resolve.ResolutionFacade[DeserializedSimpleFunctionDescriptor]

'calleeExpr' @ [181:80] ==> val calleeExpr: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkExternalUsages[LocalVariableDescriptor]

'resolvedCall' @ [182:27] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkExternalUsages[LocalVariableDescriptor]

'call' @ [182:40] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out CallableDescriptor)

'callElement' @ [182:45] ==> public final val Call.callElement: KtElement[MyPropertyDescriptor]

'resolvedCall' @ [183:32] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkExternalUsages[LocalVariableDescriptor]

'dispatchReceiver' @ [183:45] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.dispatchReceiver: ReceiverValue?[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out CallableDescriptor)

'dispatchReceiver' @ [184:13] ==> val dispatchReceiver: ReceiverValue? defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkExternalUsages[LocalVariableDescriptor]

'dispatchReceiver' @ [184:41] ==> val dispatchReceiver: ReceiverValue? defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkExternalUsages[LocalVariableDescriptor]

'dispatchReceiver' @ [185:39] ==> val dispatchReceiver: ReceiverValue? defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkExternalUsages[LocalVariableDescriptor]

'type' @ [185:56] ==> public final val ReceiverValue.type: KotlinType[MyPropertyDescriptor]

'constructor' @ [185:61] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'declarationDescriptor' @ [185:73] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'!' @ [186:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isSubclass' @ [186:30] ==> public open fun isSubclass(@NotNull p0: ClassDescriptor, @NotNull p1: ClassDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'receiverClassDescriptor' @ [186:41] ==> val receiverClassDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkExternalUsages[LocalVariableDescriptor]

'targetClassDescriptor' @ [186:66] ==> value-parameter targetClassDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkExternalUsages[ValueParameterDescriptorImpl]

'conflicts' @ [187:13] ==> value-parameter conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkExternalUsages[ValueParameterDescriptorImpl]

'putValue' @ [187:23] ==> public open fun putValue(@Nullable p0: PsiElement?, p1: (String..String?)): Unit defined in com.intellij.util.containers.MultiMap[JavaMethodDescriptor]

'callElement' @ [187:32] ==> val callElement: KtElement defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkExternalUsages[LocalVariableDescriptor]

'callElement' @ [187:85] ==> val callElement: KtElement defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkExternalUsages[LocalVariableDescriptor]

'text' @ [187:97] ==> public final val KtElement.text: (String..String?)[MyPropertyDescriptor]

'?:' @ [199:22] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: PsiElement?, right: PsiElement): PsiElement[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> PsiElement

'targetDescriptor' @ [199:23] ==> value-parameter targetDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkVisibility.reportConflictIfAny[ValueParameterDescriptorImpl]

'source' @ [199:78] ==> public final val DeclarationDescriptorWithSource.source: SourceElement[MyPropertyDescriptor]

'getPsi' @ [199:86] ==> public fun SourceElement.getPsi(): PsiElement? defined in org.jetbrains.kotlin.resolve.source[DeserializedSimpleFunctionDescriptor]

'targetDescriptor' @ [200:13] ==> value-parameter targetDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkVisibility.reportConflictIfAny[ValueParameterDescriptorImpl]

'!' @ [201:16] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isVisibleIgnoringReceiver' @ [201:30] ==> public open fun isVisibleIgnoringReceiver(@NotNull p0: DeclarationDescriptorWithVisibility, @NotNull p1: DeclarationDescriptor): Boolean defined in org.jetbrains.kotlin.descriptors.Visibilities[JavaMethodDescriptor]

'targetDescriptor' @ [201:56] ==> value-parameter targetDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkVisibility.reportConflictIfAny[ValueParameterDescriptorImpl]

'targetClassDescriptor' @ [201:74] ==> value-parameter targetClassDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkVisibility[ValueParameterDescriptorImpl]

'+' @ [202:27] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'context' @ [202:30] ==> value-parameter context: KotlinPushDownContext defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkVisibility[ValueParameterDescriptorImpl]

'memberDescriptors' @ [202:38] ==> public final val memberDescriptors: Map<(KtNamedDeclaration..KtNamedDeclaration?), DeclarationDescriptor> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.KotlinPushDownContext[PropertyDescriptorImpl]

'member' @ [202:56] ==> value-parameter member: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkVisibility[ValueParameterDescriptorImpl]

'renderForConflicts' @ [202:66] ==> public fun DeclarationDescriptor.renderForConflicts(): String defined in org.jetbrains.kotlin.idea.refactoring.pullUp in file pullUpConflictsUtils.kt[SimpleFunctionDescriptorImpl]

'targetDescriptor' @ [203:35] ==> value-parameter targetDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkVisibility.reportConflictIfAny[ValueParameterDescriptorImpl]

'renderForConflicts' @ [203:52] ==> public fun DeclarationDescriptor.renderForConflicts(): String defined in org.jetbrains.kotlin.idea.refactoring.pullUp in file pullUpConflictsUtils.kt[SimpleFunctionDescriptorImpl]

'targetClassDescriptor' @ [204:63] ==> value-parameter targetClassDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkVisibility[ValueParameterDescriptorImpl]

'renderForConflicts' @ [204:85] ==> public fun DeclarationDescriptor.renderForConflicts(): String defined in org.jetbrains.kotlin.idea.refactoring.pullUp in file pullUpConflictsUtils.kt[SimpleFunctionDescriptorImpl]

'conflicts' @ [205:13] ==> value-parameter conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkVisibility[ValueParameterDescriptorImpl]

'putValue' @ [205:23] ==> public open fun putValue(@Nullable p0: PsiElement?, p1: (String..String?)): Unit defined in com.intellij.util.containers.MultiMap[JavaMethodDescriptor]

'target' @ [205:32] ==> val target: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkVisibility.reportConflictIfAny[LocalVariableDescriptor]

'message' @ [205:40] ==> val message: String defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkVisibility.reportConflictIfAny[LocalVariableDescriptor]

'capitalize' @ [205:48] ==> public fun String.capitalize(): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'member' @ [209:5] ==> value-parameter member: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkVisibility[ValueParameterDescriptorImpl]

'accept' @ [209:12] ==> public abstract fun accept(@NotNull p0: PsiElementVisitor): Unit defined in org.jetbrains.kotlin.psi.KtNamedDeclaration[JavaMethodDescriptor]

'KtTreeVisitorVoid' @ [210:22] ==> public constructor KtTreeVisitorVoid() defined in org.jetbrains.kotlin.psi.KtTreeVisitorVoid[JavaClassConstructorDescriptor]

'super' @ [212:21] ==> <this> defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkVisibility.<no name provided>[LazyClassReceiverParameterDescriptor]

'visitReferenceExpression' @ [212:27] ==> public open fun visitReferenceExpression(@NotNull p0: KtReferenceExpression): Unit defined in org.jetbrains.kotlin.psi.KtTreeVisitorVoid[JavaMethodDescriptor]

'expression' @ [212:52] ==> value-parameter expression: KtReferenceExpression defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkVisibility.<no name provided>.visitReferenceExpression[ValueParameterDescriptorImpl]

'expression' @ [214:21] ==> value-parameter expression: KtReferenceExpression defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkVisibility.<no name provided>.visitReferenceExpression[ValueParameterDescriptorImpl]

'references' @ [214:32] ==> public final val KtReferenceExpression.references: (Array<(PsiReference..PsiReference?)>..Array<out (PsiReference..PsiReference?)>)[MyPropertyDescriptor]

'flatMap' @ [215:30] ==> public inline fun <T, R> Array<out (PsiReference..PsiReference?)>.flatMap(transform: ((PsiReference..PsiReference?)) -> Iterable<DeclarationDescriptor>): List<DeclarationDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiReference..com.intellij.psi.PsiReference?)
    <R> -> DeclarationDescriptor

'?:' @ [215:40] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: Collection<DeclarationDescriptor>?, right: Collection<DeclarationDescriptor>): Collection<DeclarationDescriptor>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> Collection<DeclarationDescriptor>

'it' @ [215:41] ==> value-parameter it: (PsiReference..PsiReference?) defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkVisibility.<no name provided>.visitReferenceExpression.<anonymous>[ValueParameterDescriptorImpl]

'resolveToDescriptors' @ [215:62] ==> public abstract fun resolveToDescriptors(bindingContext: BindingContext): Collection<DeclarationDescriptor> defined in org.jetbrains.kotlin.idea.references.KtReference[DeserializedSimpleFunctionDescriptor]

'context' @ [215:83] ==> value-parameter context: KotlinPushDownContext defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkVisibility[ValueParameterDescriptorImpl]

'sourceClassContext' @ [215:91] ==> public final val sourceClassContext: BindingContext defined in org.jetbrains.kotlin.idea.refactoring.pushDown.KotlinPushDownContext[PropertyDescriptorImpl]

'emptyList' @ [215:114] ==> public fun <T> emptyList(): List<DeclarationDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DeclarationDescriptor

'forEach' @ [216:30] ==> @HidesMembers public inline fun <T> Iterable<DeclarationDescriptor>.forEach(action: (DeclarationDescriptor) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DeclarationDescriptor

'reportConflictIfAny' @ [216:40] ==> local final fun reportConflictIfAny(targetDescriptor: DeclarationDescriptor): Unit defined in org.jetbrains.kotlin.idea.refactoring.pushDown.checkVisibility[SimpleFunctionDescriptorImpl]

