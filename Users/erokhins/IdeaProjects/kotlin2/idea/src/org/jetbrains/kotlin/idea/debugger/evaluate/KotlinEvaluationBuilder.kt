'getInstance' @ [90:27] ==> @NotNull public open fun getInstance(@NotNull @NonNls p0: String): Logger defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'codeFragment' @ [97:13] ==> value-parameter codeFragment: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluationBuilder.build[ValueParameterDescriptorImpl]

'position' @ [97:48] ==> value-parameter position: SourcePosition? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluationBuilder.build[ValueParameterDescriptorImpl]

'!!' @ [98:20] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: EvaluatorBuilder?): EvaluatorBuilder[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> EvaluatorBuilder

'getInstance' @ [98:41] ==> public open fun getInstance(): (EvaluatorBuilder..EvaluatorBuilder?) defined in com.intellij.debugger.engine.evaluation.expression.EvaluatorBuilderImpl[JavaMethodDescriptor]

'build' @ [98:57] ==> public abstract fun build(p0: (PsiElement..PsiElement?), p1: (SourcePosition..SourcePosition?)): (ExpressionEvaluator..ExpressionEvaluator?) defined in com.intellij.debugger.engine.evaluation.expression.EvaluatorBuilder[JavaMethodDescriptor]

'codeFragment' @ [98:63] ==> value-parameter codeFragment: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluationBuilder.build[ValueParameterDescriptorImpl]

'position' @ [98:77] ==> value-parameter position: SourcePosition? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluationBuilder.build[ValueParameterDescriptorImpl]

'position' @ [101:13] ==> value-parameter position: SourcePosition? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluationBuilder.build[ValueParameterDescriptorImpl]

'line' @ [101:22] ==> public final val SourcePosition.line: Int[MyPropertyDescriptor]

'createEvaluateException' @ [102:41] ==> public open fun createEvaluateException(p0: (String..String?)): (EvaluateException..EvaluateException?) defined in com.intellij.debugger.engine.evaluation.EvaluateExceptionUtil[JavaMethodDescriptor]

'position' @ [102:106] ==> value-parameter position: SourcePosition? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluationBuilder.build[ValueParameterDescriptorImpl]

'position' @ [105:20] ==> value-parameter position: SourcePosition? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluationBuilder.build[ValueParameterDescriptorImpl]

'file' @ [105:29] ==> public final val SourcePosition.file: PsiFile[MyPropertyDescriptor]

'file' @ [106:13] ==> val file: PsiFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluationBuilder.build[LocalVariableDescriptor]

'getInstance' @ [107:47] ==> public open fun getInstance(@NotNull p0: Project): (PsiDocumentManager..PsiDocumentManager?) defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'file' @ [107:59] ==> val file: PsiFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluationBuilder.build[LocalVariableDescriptor]

'project' @ [107:64] ==> public final val KtFile.project: Project[MyPropertyDescriptor]

'getDocument' @ [107:73] ==> @Nullable public abstract fun getDocument(@NotNull p0: PsiFile): Document? defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'file' @ [107:85] ==> val file: PsiFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluationBuilder.build[LocalVariableDescriptor]

'document' @ [108:17] ==> val document: Document? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluationBuilder.build[LocalVariableDescriptor]

'document' @ [108:37] ==> val document: Document? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluationBuilder.build[LocalVariableDescriptor]

'lineCount' @ [108:46] ==> public final val Document.lineCount: Int[MyPropertyDescriptor]

'position' @ [108:58] ==> value-parameter position: SourcePosition? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluationBuilder.build[ValueParameterDescriptorImpl]

'line' @ [108:67] ==> public final val SourcePosition.line: Int[MyPropertyDescriptor]

'createEvaluateException' @ [109:45] ==> public open fun createEvaluateException(p0: (String..String?)): (EvaluateException..EvaluateException?) defined in com.intellij.debugger.engine.evaluation.EvaluateExceptionUtil[JavaMethodDescriptor]

'+' @ [110:25] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'codeFragment' @ [115:13] ==> value-parameter codeFragment: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluationBuilder.build[ValueParameterDescriptorImpl]

'context' @ [115:26] ==> public final val KtCodeFragment.context: PsiElement?[MyPropertyDescriptor]

'arrayOf' @ [116:31] ==> public inline fun <reified @PureReifiable T> arrayOf(vararg elements: Attachment?): Array<Attachment?> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified @PureReifiable T> -> Attachment?

'attachmentByPsiFile' @ [116:39] ==> public fun attachmentByPsiFile(file: PsiFile?): Attachment? defined in org.jetbrains.kotlin.idea.util.attachment in file attachmentUtils.kt[SimpleFunctionDescriptorImpl]

'position' @ [116:59] ==> value-parameter position: SourcePosition? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluationBuilder.build[ValueParameterDescriptorImpl]

'file' @ [116:68] ==> public final val SourcePosition.file: PsiFile[MyPropertyDescriptor]

'attachmentByPsiFile' @ [117:39] ==> public fun attachmentByPsiFile(file: PsiFile?): Attachment? defined in org.jetbrains.kotlin.idea.util.attachment in file attachmentUtils.kt[SimpleFunctionDescriptorImpl]

'codeFragment' @ [117:59] ==> value-parameter codeFragment: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluationBuilder.build[ValueParameterDescriptorImpl]

'Attachment' @ [118:39] ==> public constructor Attachment(@NotNull p0: String, @NotNull p1: String) defined in com.intellij.openapi.diagnostic.Attachment[JavaClassConstructorDescriptor]

'position' @ [118:78] ==> value-parameter position: SourcePosition? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluationBuilder.build[ValueParameterDescriptorImpl]

'line' @ [118:87] ==> public final val SourcePosition.line: Int[MyPropertyDescriptor]

'LOG' @ [120:13] ==> internal val LOG: Logger defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'error' @ [120:17] ==> public open fun error(@NonNls p0: (String..String?), @NotNull vararg p1: (Attachment..Attachment?)): Unit defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'codeFragment' @ [120:45] ==> value-parameter codeFragment: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluationBuilder.build[ValueParameterDescriptorImpl]

'java' @ [120:65] ==> public val <T> KClass<out PsiElement>.java: Class<out PsiElement> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> PsiElement

'codeFragment' @ [120:86] ==> value-parameter codeFragment: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluationBuilder.build[ValueParameterDescriptorImpl]

'context' @ [120:99] ==> public final val KtCodeFragment.context: PsiElement?[MyPropertyDescriptor]

'javaClass' @ [120:108] ==> public val <T : Any> PsiElement.javaClass: Class<PsiElement> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> PsiElement

'mergeAttachments' @ [120:121] ==> public fun mergeAttachments(vararg attachments: Attachment?): Attachment defined in org.jetbrains.kotlin.idea.util.attachment[SimpleFunctionDescriptorImpl]

'attachments' @ [120:139] ==> val attachments: Array<Attachment?> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluationBuilder.build[LocalVariableDescriptor]

'createEvaluateException' @ [121:41] ==> public open fun createEvaluateException(p0: (String..String?)): (EvaluateException..EvaluateException?) defined in com.intellij.debugger.engine.evaluation.EvaluateExceptionUtil[JavaMethodDescriptor]

'ExpressionEvaluatorImpl' @ [124:16] ==> public constructor ExpressionEvaluatorImpl(p0: (Evaluator..Evaluator?)) defined in com.intellij.debugger.engine.evaluation.expression.ExpressionEvaluatorImpl[JavaClassConstructorDescriptor]

'KotlinEvaluator' @ [124:40] ==> public constructor KotlinEvaluator(codeFragment: KtCodeFragment, sourcePosition: SourcePosition) defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator[ClassConstructorDescriptorImpl]

'codeFragment' @ [124:56] ==> value-parameter codeFragment: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluationBuilder.build[ValueParameterDescriptorImpl]

'position' @ [124:70] ==> value-parameter position: SourcePosition? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluationBuilder.build[ValueParameterDescriptorImpl]

'codeFragment' @ [130:13] ==> public final val codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator[PropertyDescriptorImpl]

'text' @ [130:26] ==> public final val KtCodeFragment.text: (String..String?)[MyPropertyDescriptor]

'isEmpty' @ [130:31] ==> @InlineOnly public inline fun CharSequence.isEmpty(): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'context' @ [131:20] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[ValueParameterDescriptorImpl]

'debugProcess' @ [131:28] ==> public final val EvaluationContextImpl.debugProcess: DebugProcessImpl[MyPropertyDescriptor]

'virtualMachineProxy' @ [131:41] ==> public final val DebugProcessImpl.virtualMachineProxy: VirtualMachineProxyImpl[MyPropertyDescriptor]

'mirrorOfVoid' @ [131:61] ==> public open fun mirrorOfVoid(): (VoidValue..VoidValue?) defined in com.intellij.debugger.jdi.VirtualMachineProxyImpl[JavaMethodDescriptor]

'KotlinDebuggerCaches' @ [136:32] ==> public companion object defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinDebuggerCaches[FakeCallableDescriptorForObject]

'getOrCreateCompiledData' @ [136:53] ==> public final fun getOrCreateCompiledData(codeFragment: KtCodeFragment, sourcePosition: SourcePosition, evaluationContext: EvaluationContextImpl, create: (KtCodeFragment, SourcePosition) -> KotlinDebuggerCaches.CompiledDataDescriptor): KotlinDebuggerCaches.CompiledDataDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinDebuggerCaches.Companion[SimpleFunctionDescriptorImpl]

'codeFragment' @ [136:77] ==> public final val codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator[PropertyDescriptorImpl]

'sourcePosition' @ [136:91] ==> public final val sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator[PropertyDescriptorImpl]

'context' @ [136:107] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[ValueParameterDescriptorImpl]

'isCompiledDataFromCache' @ [138:17] ==> var isCompiledDataFromCache: Boolean defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'extractAndCompile' @ [139:17] ==> private final fun extractAndCompile(codeFragment: KtCodeFragment, sourcePosition: SourcePosition, context: EvaluationContextImpl): KotlinDebuggerCaches.CompiledDataDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'fragment' @ [139:35] ==> value-parameter fragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate.<anonymous>[ValueParameterDescriptorImpl]

'position' @ [139:45] ==> value-parameter position: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate.<anonymous>[ValueParameterDescriptorImpl]

'context' @ [139:55] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[ValueParameterDescriptorImpl]

'loadClassesSafely' @ [142:38] ==> public fun loadClassesSafely(evaluationContext: EvaluationContextImpl, classes: Collection<ClassToLoad>): ClassLoaderHandler? defined in org.jetbrains.kotlin.idea.debugger.evaluate.compilingEvaluator[SimpleFunctionDescriptorImpl]

'context' @ [142:56] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[ValueParameterDescriptorImpl]

'compiledData' @ [142:65] ==> val compiledData: KotlinDebuggerCaches.CompiledDataDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'classes' @ [142:78] ==> public final val classes: List<ClassToLoad> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinDebuggerCaches.CompiledDataDescriptor[PropertyDescriptorImpl]

'if (classLoaderHandler != null) {
                try {
                    evaluateWithCompilation(context, compiledData) ?: runEval4j(context, compiledData)
                } finally {
                    classLoaderHandler.dispose()
                }
            }
            else {
                runEval4j(context, compiledData)
            }' @ [144:26] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any, elseBranch: Any): Any[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any

'classLoaderHandler' @ [144:30] ==> val classLoaderHandler: ClassLoaderHandler? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'evaluateWithCompilation' @ [146:21] ==> private final fun evaluateWithCompilation(context: EvaluationContextImpl, compiledData: KotlinDebuggerCaches.CompiledDataDescriptor): Any? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'context' @ [146:45] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[ValueParameterDescriptorImpl]

'compiledData' @ [146:54] ==> val compiledData: KotlinDebuggerCaches.CompiledDataDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'runEval4j' @ [146:71] ==> private final fun runEval4j(context: EvaluationContextImpl, compiledData: KotlinDebuggerCaches.CompiledDataDescriptor): InterpreterResult defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'context' @ [146:81] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[ValueParameterDescriptorImpl]

'compiledData' @ [146:90] ==> val compiledData: KotlinDebuggerCaches.CompiledDataDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'classLoaderHandler' @ [148:21] ==> val classLoaderHandler: ClassLoaderHandler? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'dispose' @ [148:40] ==> public open fun dispose(): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.classLoading.ClassLoaderHandler[SimpleFunctionDescriptorImpl]

'runEval4j' @ [152:17] ==> private final fun runEval4j(context: EvaluationContextImpl, compiledData: KotlinDebuggerCaches.CompiledDataDescriptor): InterpreterResult defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'context' @ [152:27] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[ValueParameterDescriptorImpl]

'compiledData' @ [152:36] ==> val compiledData: KotlinDebuggerCaches.CompiledDataDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'isCompiledDataFromCache' @ [156:17] ==> var isCompiledDataFromCache: Boolean defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'result' @ [156:44] ==> val result: Any defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'result' @ [156:73] ==> val result: Any defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'kind' @ [156:80] ==> public final val kind: ExceptionThrown.ExceptionKind defined in org.jetbrains.eval4j.ExceptionThrown[DeserializedPropertyDescriptor]

'BROKEN_CODE' @ [156:118] ==> enum entry BROKEN_CODE defined in org.jetbrains.eval4j.ExceptionThrown.ExceptionKind[FakeCallableDescriptorForObject]

'loadClasses' @ [158:42] ==> public fun loadClasses(evaluationContext: EvaluationContextImpl, classes: Collection<ClassToLoad>): ClassLoaderHandler? defined in org.jetbrains.kotlin.idea.debugger.evaluate.compilingEvaluator[SimpleFunctionDescriptorImpl]

'context' @ [158:54] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[ValueParameterDescriptorImpl]

'compiledData' @ [158:63] ==> val compiledData: KotlinDebuggerCaches.CompiledDataDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'classes' @ [158:76] ==> public final val classes: List<ClassToLoad> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinDebuggerCaches.CompiledDataDescriptor[PropertyDescriptorImpl]

'drop' @ [158:84] ==> public fun <T> Iterable<ClassToLoad>.drop(n: Int): List<ClassToLoad> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ClassToLoad

'runEval4j' @ [161:28] ==> private final fun runEval4j(context: EvaluationContextImpl, compiledData: KotlinDebuggerCaches.CompiledDataDescriptor): InterpreterResult defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'context' @ [161:38] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[ValueParameterDescriptorImpl]

'extractAndCompile' @ [161:47] ==> private final fun extractAndCompile(codeFragment: KtCodeFragment, sourcePosition: SourcePosition, context: EvaluationContextImpl): KotlinDebuggerCaches.CompiledDataDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'codeFragment' @ [161:65] ==> public final val codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator[PropertyDescriptorImpl]

'sourcePosition' @ [161:79] ==> public final val sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator[PropertyDescriptorImpl]

'context' @ [161:95] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[ValueParameterDescriptorImpl]

'toJdiValue' @ [161:105] ==> private final fun InterpreterResult.toJdiValue(context: EvaluationContextImpl): Value? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'context' @ [161:116] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[ValueParameterDescriptorImpl]

'classLoaderHandler' @ [163:21] ==> val classLoaderHandler: ClassLoaderHandler? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'dispose' @ [163:41] ==> public open fun dispose(): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.classLoading.ClassLoaderHandler[SimpleFunctionDescriptorImpl]

'if (result is InterpreterResult) {
                result.toJdiValue(context)
            } else {
                result
            }' @ [167:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any?, elseBranch: Any?): Any?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any?

'result' @ [167:24] ==> val result: Any defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'result' @ [168:17] ==> val result: Any defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'toJdiValue' @ [168:24] ==> private final fun InterpreterResult.toJdiValue(context: EvaluationContextImpl): Value? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'context' @ [168:35] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[ValueParameterDescriptorImpl]

'result' @ [170:17] ==> val result: Any defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'e' @ [174:19] ==> val e: EvaluateException defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'LOG' @ [177:13] ==> internal val LOG: Logger defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'debug' @ [177:17] ==> public abstract fun debug(@Nullable p0: Throwable?): Unit defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'e' @ [177:23] ==> val e: ProcessCanceledException defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'exception' @ [178:13] ==> private final fun exception(e: Throwable): Nothing defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'e' @ [178:23] ==> val e: ProcessCanceledException defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'isSpecialException' @ [181:38] ==> private final fun isSpecialException(th: Throwable): Boolean defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator[SimpleFunctionDescriptorImpl]

'e' @ [181:57] ==> val e: Exception /* = Exception */ defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'isSpecialException' @ [182:17] ==> val isSpecialException: Boolean defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'exception' @ [183:17] ==> private final fun exception(e: Throwable): Nothing defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'e' @ [183:27] ==> val e: Exception /* = Exception */ defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'runReadAction' @ [186:24] ==> public fun <T> runReadAction(action: () -> String): String defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'codeFragment' @ [186:40] ==> public final val codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator[PropertyDescriptorImpl]

'context' @ [186:53] ==> public final val KtCodeFragment.context: PsiElement?[MyPropertyDescriptor]

'text' @ [186:62] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'arrayOf' @ [187:31] ==> public inline fun <reified @PureReifiable T> arrayOf(vararg elements: Attachment?): Array<Attachment?> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified @PureReifiable T> -> Attachment?

'attachmentByPsiFile' @ [187:39] ==> public fun attachmentByPsiFile(file: PsiFile?): Attachment? defined in org.jetbrains.kotlin.idea.util.attachment in file attachmentUtils.kt[SimpleFunctionDescriptorImpl]

'sourcePosition' @ [187:59] ==> public final val sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator[PropertyDescriptorImpl]

'file' @ [187:74] ==> public final val SourcePosition.file: PsiFile[MyPropertyDescriptor]

'attachmentByPsiFile' @ [188:39] ==> public fun attachmentByPsiFile(file: PsiFile?): Attachment? defined in org.jetbrains.kotlin.idea.util.attachment in file attachmentUtils.kt[SimpleFunctionDescriptorImpl]

'codeFragment' @ [188:59] ==> public final val codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator[PropertyDescriptorImpl]

'Attachment' @ [189:39] ==> public constructor Attachment(@NotNull p0: String, @NotNull p1: String) defined in com.intellij.openapi.diagnostic.Attachment[JavaClassConstructorDescriptor]

'sourcePosition' @ [189:78] ==> public final val sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator[PropertyDescriptorImpl]

'line' @ [189:93] ==> public final val SourcePosition.line: Int[MyPropertyDescriptor]

'Attachment' @ [190:39] ==> public constructor Attachment(@NotNull p0: String, @NotNull p1: String) defined in com.intellij.openapi.diagnostic.Attachment[JavaClassConstructorDescriptor]

'text' @ [190:66] ==> val text: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'LOG' @ [192:13] ==> internal val LOG: Logger defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'error' @ [192:17] ==> public open fun error(p0: (Any..Any?)): Unit defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'createEvent' @ [192:36] ==> public open fun createEvent(p0: (String..String?), p1: (String..String?), vararg p2: (Attachment..Attachment?)): (IdeaLoggingEvent..IdeaLoggingEvent?) defined in com.intellij.diagnostic.LogMessageEx[JavaMethodDescriptor]

'getThrowableText' @ [194:35] ==> @NotNull public open fun getThrowableText(@NotNull p0: Throwable): String defined in com.intellij.util.ExceptionUtil[JavaMethodDescriptor]

'e' @ [194:52] ==> val e: Exception /* = Exception */ defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'mergeAttachments' @ [195:21] ==> public fun mergeAttachments(vararg attachments: Attachment?): Attachment defined in org.jetbrains.kotlin.idea.util.attachment[SimpleFunctionDescriptorImpl]

'attachments' @ [195:39] ==> val attachments: Array<Attachment?> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'if (e.message != null) ": ${e.message}" else ""' @ [197:25] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'e' @ [197:29] ==> val e: Exception /* = Exception */ defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'message' @ [197:31] ==> public open val message: String? defined in java.lang.Exception[DeserializedPropertyDescriptor]

'e' @ [197:53] ==> val e: Exception /* = Exception */ defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'message' @ [197:55] ==> public open val message: String? defined in java.lang.Exception[DeserializedPropertyDescriptor]

'exception' @ [198:13] ==> private final fun exception(msg: String): Nothing defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'cause' @ [198:79] ==> val cause: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.evaluate[LocalVariableDescriptor]

'when (th) {
            is ClassNotPreparedException,
            is InternalException,
            is AbsentInformationException,
            is ClassNotLoadedException,
            is IncompatibleThreadStateException,
            is InconsistentDebugInfoException,
            is ObjectCollectedException,
            is VMDisconnectedException -> true
            else -> false
        }' @ [203:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'th' @ [203:22] ==> value-parameter th: Throwable defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.isSpecialException[ValueParameterDescriptorImpl]

'codeFragment' @ [222:13] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile[ValueParameterDescriptorImpl]

'checkForErrors' @ [222:26] ==> private final fun KtFile.checkForErrors(analyzeInlineFunctions: Boolean = ..., contextFile: KtFile? = ...): KotlinEvaluator.Companion.ExtendedAnalysisResult defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'getFunctionForExtractedFragment' @ [224:36] ==> public fun getFunctionForExtractedFragment(codeFragment: KtCodeFragment, breakpointFile: PsiFile, breakpointLine: Int): ExtractionResult? defined in org.jetbrains.kotlin.idea.debugger.evaluate in file extractFunctionForDebuggerUtil.kt[SimpleFunctionDescriptorImpl]

'codeFragment' @ [224:68] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile[ValueParameterDescriptorImpl]

'sourcePosition' @ [224:82] ==> value-parameter sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile[ValueParameterDescriptorImpl]

'file' @ [224:97] ==> public final val SourcePosition.file: PsiFile[MyPropertyDescriptor]

'sourcePosition' @ [224:103] ==> value-parameter sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile[ValueParameterDescriptorImpl]

'line' @ [224:118] ==> public final val SourcePosition.line: Int[MyPropertyDescriptor]

'IllegalStateException' @ [225:45] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'codeFragment' @ [225:117] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile[ValueParameterDescriptorImpl]

'text' @ [225:130] ==> public final val KtCodeFragment.text: (String..String?)[MyPropertyDescriptor]

'extractionResult' @ [226:40] ==> val extractionResult: ExtractionResult defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile[LocalVariableDescriptor]

'getParametersForDebugger' @ [226:57] ==> private final fun ExtractionResult.getParametersForDebugger(fragment: KtCodeFragment): KotlinDebuggerCaches.ParametersDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'codeFragment' @ [226:82] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile[ValueParameterDescriptorImpl]

'extractionResult' @ [227:37] ==> val extractionResult: ExtractionResult defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile[LocalVariableDescriptor]

'declaration' @ [227:54] ==> public final val declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionResult[PropertyDescriptorImpl]

'LOG' @ [229:17] ==> internal val LOG: Logger defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'isDebugEnabled' @ [229:21] ==> public final val Logger.isDebugEnabled: Boolean[MyPropertyDescriptor]

'LOG' @ [230:17] ==> internal val LOG: Logger defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'debug' @ [230:21] ==> public abstract fun debug(@NonNls p0: (String..String?)): Unit defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'+' @ [230:27] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'runReadAction' @ [230:53] ==> public fun <T> runReadAction(action: () -> (String..String?)): (String..String?) defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.String..kotlin.String?)

'extractedFunction' @ [230:69] ==> val extractedFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile[LocalVariableDescriptor]

'text' @ [230:87] ==> public final val KtNamedFunction.text: (String..String?)[MyPropertyDescriptor]

'createClassFileFactory' @ [233:36] ==> private final fun createClassFileFactory(codeFragment: KtCodeFragment, extractedFunction: KtNamedFunction, context: EvaluationContextImpl, parameters: KotlinDebuggerCaches.ParametersDescriptor): ClassFileFactory defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'codeFragment' @ [233:59] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile[ValueParameterDescriptorImpl]

'extractedFunction' @ [233:73] ==> val extractedFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile[LocalVariableDescriptor]

'context' @ [233:92] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile[ValueParameterDescriptorImpl]

'parametersDescriptor' @ [233:101] ==> val parametersDescriptor: KotlinDebuggerCaches.ParametersDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile[LocalVariableDescriptor]

'classFileFactory' @ [235:31] ==> val classFileFactory: ClassFileFactory defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile[LocalVariableDescriptor]

'asList' @ [235:48] ==> @NotNull public open fun asList(): List<OutputFile> defined in org.jetbrains.kotlin.codegen.ClassFileFactory[JavaMethodDescriptor]

'filterClassFiles' @ [235:57] ==> public fun List<OutputFile>.filterClassFiles(): Iterable<OutputFile> defined in org.jetbrains.kotlin.codegen[DeserializedSimpleFunctionDescriptor]

'sortedBy' @ [236:22] ==> public inline fun <T, R : Comparable<Int>> Iterable<OutputFile>.sortedBy(crossinline selector: (OutputFile) -> Int?): List<OutputFile> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> OutputFile
    <R : Comparable<R>> -> Int

'it' @ [236:33] ==> value-parameter it: OutputFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile.<anonymous>[ValueParameterDescriptorImpl]

'relativePath' @ [236:36] ==> public abstract val relativePath: String defined in org.jetbrains.kotlin.backend.common.output.OutputFile[DeserializedPropertyDescriptor]

'length' @ [236:49] ==> public open val length: Int defined in kotlin.String[DeserializedPropertyDescriptor]

'outputFiles' @ [238:26] ==> val outputFiles: List<OutputFile> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile[LocalVariableDescriptor]

'LOG' @ [239:21] ==> internal val LOG: Logger defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'isDebugEnabled' @ [239:25] ==> public final val Logger.isDebugEnabled: Boolean[MyPropertyDescriptor]

'LOG' @ [240:21] ==> internal val LOG: Logger defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'debug' @ [240:25] ==> public abstract fun debug(@NonNls p0: (String..String?)): Unit defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'file' @ [240:57] ==> val file: OutputFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile[LocalVariableDescriptor]

'relativePath' @ [240:62] ==> public abstract val relativePath: String defined in org.jetbrains.kotlin.backend.common.output.OutputFile[DeserializedPropertyDescriptor]

'DEBUG_MODE' @ [242:21] ==> private val DEBUG_MODE: Boolean defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'println' @ [243:21] ==> @InlineOnly public inline fun println(message: Any?): Unit defined in kotlin.io[DeserializedSimpleFunctionDescriptor]

'file' @ [243:29] ==> val file: OutputFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile[LocalVariableDescriptor]

'asText' @ [243:34] ==> public abstract fun asText(): String defined in org.jetbrains.kotlin.backend.common.output.OutputFile[DeserializedSimpleFunctionDescriptor]

'outputFiles' @ [247:35] ==> val outputFiles: List<OutputFile> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile[LocalVariableDescriptor]

'map' @ [247:47] ==> public inline fun <T, R> Iterable<OutputFile>.map(transform: (OutputFile) -> ClassToLoad): List<ClassToLoad> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> OutputFile
    <R> -> ClassToLoad

'ClassToLoad' @ [247:53] ==> public constructor ClassToLoad(className: String, relativeFileName: String, bytes: ByteArray) defined in org.jetbrains.kotlin.idea.debugger.evaluate.classLoading.ClassToLoad[ClassConstructorDescriptorImpl]

'getClassName' @ [247:65] ==> private final fun getClassName(fileName: String): String defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'it' @ [247:78] ==> value-parameter it: OutputFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile.<anonymous>[ValueParameterDescriptorImpl]

'relativePath' @ [247:81] ==> public abstract val relativePath: String defined in org.jetbrains.kotlin.backend.common.output.OutputFile[DeserializedPropertyDescriptor]

'it' @ [247:96] ==> value-parameter it: OutputFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile.<anonymous>[ValueParameterDescriptorImpl]

'relativePath' @ [247:99] ==> public abstract val relativePath: String defined in org.jetbrains.kotlin.backend.common.output.OutputFile[DeserializedPropertyDescriptor]

'it' @ [247:113] ==> value-parameter it: OutputFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile.<anonymous>[ValueParameterDescriptorImpl]

'asByteArray' @ [247:116] ==> public abstract fun asByteArray(): ByteArray defined in org.jetbrains.kotlin.backend.common.output.OutputFile[DeserializedSimpleFunctionDescriptor]

'CompiledDataDescriptor' @ [249:20] ==> public constructor CompiledDataDescriptor(classes: List<ClassToLoad>, sourcePosition: SourcePosition, parameters: KotlinDebuggerCaches.ParametersDescriptor) defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinDebuggerCaches.CompiledDataDescriptor[ClassConstructorDescriptorImpl]

'additionalFiles' @ [250:21] ==> val additionalFiles: List<ClassToLoad> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile[LocalVariableDescriptor]

'sourcePosition' @ [251:21] ==> value-parameter sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile[ValueParameterDescriptorImpl]

'parametersDescriptor' @ [252:21] ==> val parametersDescriptor: KotlinDebuggerCaches.ParametersDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.extractAndCompile[LocalVariableDescriptor]

'fileName' @ [256:20] ==> value-parameter fileName: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getClassName[ValueParameterDescriptorImpl]

'substringBeforeLast' @ [256:29] ==> public fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'replace' @ [256:59] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'classes' @ [260:21] ==> public final val classes: List<ClassToLoad> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinDebuggerCaches.CompiledDataDescriptor[PropertyDescriptorImpl]

'firstOrNull' @ [260:29] ==> public fun <T> List<ClassToLoad>.firstOrNull(): ClassToLoad? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ClassToLoad

'error' @ [260:46] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'+' @ [261:21] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'sourcePosition' @ [261:52] ==> public final val sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinDebuggerCaches.CompiledDataDescriptor[PropertyDescriptorImpl]

'elementAt' @ [261:67] ==> public final val SourcePosition.elementAt: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'getParentOfType' @ [261:77] ==> public inline fun <reified T : PsiElement> PsiElement.getParentOfType(strict: Boolean): KtDeclaration? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtDeclaration

'context' @ [264:22] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[ValueParameterDescriptorImpl]

'debugProcess' @ [264:30] ==> public final val EvaluationContextImpl.debugProcess: DebugProcessImpl[MyPropertyDescriptor]

'virtualMachineProxy' @ [264:43] ==> public final val DebugProcessImpl.virtualMachineProxy: VirtualMachineProxyImpl[MyPropertyDescriptor]

'virtualMachine' @ [264:63] ==> public final val VirtualMachineProxyImpl.virtualMachine: VirtualMachine[MyPropertyDescriptor]

'context' @ [265:31] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[ValueParameterDescriptorImpl]

'classLoader' @ [265:39] ==> public final var EvaluationContextImpl.classLoader: ClassLoaderReference?[MyPropertyDescriptor]

'compiledData' @ [266:37] ==> value-parameter compiledData: KotlinDebuggerCaches.CompiledDataDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[ValueParameterDescriptorImpl]

'mainClass' @ [266:50] ==> private final val KotlinDebuggerCaches.CompiledDataDescriptor.mainClass: ClassToLoad defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[PropertyDescriptorImpl]

'bytes' @ [266:60] ==> public final val bytes: ByteArray defined in org.jetbrains.kotlin.idea.debugger.evaluate.classLoading.ClassToLoad[PropertyDescriptorImpl]

'ClassNode' @ [269:40] ==> public constructor ClassNode() defined in org.jetbrains.org.objectweb.asm.tree.ClassNode[JavaClassConstructorDescriptor]

'apply' @ [269:52] ==> @InlineOnly public inline fun <T> ClassNode.apply(block: ClassNode.() -> Unit): ClassNode defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ClassNode

'ClassReader' @ [269:60] ==> public constructor ClassReader(p0: (ByteArray..ByteArray?)) defined in org.jetbrains.org.objectweb.asm.ClassReader[JavaClassConstructorDescriptor]

'mainClassBytecode' @ [269:72] ==> val mainClassBytecode: ByteArray defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'accept' @ [269:91] ==> public open fun accept(p0: (ClassVisitor..ClassVisitor?), p1: Int): Unit defined in org.jetbrains.org.objectweb.asm.ClassReader[JavaMethodDescriptor]

'this' @ [269:98] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation.<anonymous>[ReceiverParameterDescriptorImpl]

'SKIP_CODE' @ [269:116] ==> public const final val SKIP_CODE: Int defined in org.jetbrains.org.objectweb.asm.ClassReader[JavaPropertyDescriptor]

'mainClassAsmNode' @ [270:40] ==> val mainClassAsmNode: ClassNode defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'name' @ [270:57] ==> public final var name: (String..String?) defined in org.jetbrains.org.objectweb.asm.tree.ClassNode[JavaPropertyDescriptor]

'replace' @ [270:62] ==> public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'assert' @ [271:17] ==> @InlineOnly public inline fun assert(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'mainClassAsmNode' @ [271:24] ==> val mainClassAsmNode: ClassNode defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'methods' @ [271:41] ==> public final var methods: (MutableList<(MethodNode..MethodNode?)>..List<(MethodNode..MethodNode?)>?) defined in org.jetbrains.org.objectweb.asm.tree.ClassNode[JavaPropertyDescriptor]

'size' @ [271:49] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'mainClassAsmNode' @ [273:38] ==> val mainClassAsmNode: ClassNode defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'methods' @ [273:55] ==> public final var methods: (MutableList<(MethodNode..MethodNode?)>..List<(MethodNode..MethodNode?)>?) defined in org.jetbrains.org.objectweb.asm.tree.ClassNode[JavaPropertyDescriptor]

'assert' @ [274:17] ==> @InlineOnly public inline fun assert(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'methodToInvoke' @ [274:24] ==> val methodToInvoke: (MethodNode..MethodNode?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'parameters' @ [274:39] ==> public final var parameters: (MutableList<(ParameterNode..ParameterNode?)>..List<(ParameterNode..ParameterNode?)>?) defined in org.jetbrains.org.objectweb.asm.tree.MethodNode[JavaPropertyDescriptor]

'methodToInvoke' @ [274:61] ==> val methodToInvoke: (MethodNode..MethodNode?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'parameters' @ [274:76] ==> public final var parameters: (MutableList<(ParameterNode..ParameterNode?)>..List<(ParameterNode..ParameterNode?)>?) defined in org.jetbrains.org.objectweb.asm.tree.MethodNode[JavaPropertyDescriptor]

'isEmpty' @ [274:87] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'context' @ [276:33] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[ValueParameterDescriptorImpl]

'debugProcess' @ [276:41] ==> public final val EvaluationContextImpl.debugProcess: DebugProcessImpl[MyPropertyDescriptor]

'findClass' @ [276:54] ==> public open fun findClass(p0: (EvaluationContext..EvaluationContext?), p1: (String..String?), p2: (ClassLoaderReference..ClassLoaderReference?)): (ReferenceType..ReferenceType?) defined in com.intellij.debugger.engine.DebugProcessImpl[JavaMethodDescriptor]

'context' @ [276:64] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[ValueParameterDescriptorImpl]

'mainClassJdiName' @ [276:73] ==> val mainClassJdiName: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'classLoader' @ [276:91] ==> val classLoader: ClassLoaderReference defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'context' @ [278:30] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[ValueParameterDescriptorImpl]

'suspendContext' @ [278:38] ==> public final val EvaluationContextImpl.suspendContext: SuspendContextImpl[MyPropertyDescriptor]

'thread' @ [278:53] ==> public final val SuspendContextImpl.thread: ThreadReferenceProxyImpl?[MyPropertyDescriptor]

'threadReference' @ [278:61] ==> public final val ThreadReferenceProxyImpl.threadReference: (ThreadReference..ThreadReference?)[MyPropertyDescriptor]

'context' @ [279:36] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[ValueParameterDescriptorImpl]

'suspendContext' @ [279:44] ==> public final val EvaluationContextImpl.suspendContext: SuspendContextImpl[MyPropertyDescriptor]

'getInvokePolicy' @ [279:59] ==> internal fun SuspendContext.getInvokePolicy(): Int defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[SimpleFunctionDescriptorImpl]

'JDIEval' @ [280:28] ==> public constructor JDIEval(vm: VirtualMachine, defaultClassLoader: ClassLoaderReference?, thread: ThreadReference, invokePolicy: Int) defined in org.jetbrains.eval4j.jdi.JDIEval[DeserializedClassConstructorDescriptor]

'vm' @ [280:36] ==> val vm: VirtualMachine defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'classLoader' @ [280:40] ==> val classLoader: ClassLoaderReference defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'thread' @ [280:53] ==> val thread: ThreadReference defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'invokePolicy' @ [280:61] ==> val invokePolicy: Int defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'vm' @ [282:24] ==> val vm: VirtualMachine defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'executeWithBreakpointsDisabled' @ [282:27] ==> private final inline fun <T> VirtualMachine.executeWithBreakpointsDisabled(block: () -> (Value..Value?)): (Value..Value?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> (com.sun.jdi.Value..com.sun.jdi.Value?)

'eval' @ [284:21] ==> val eval: JDIEval defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'loadClass' @ [284:26] ==> public final fun loadClass(classType: Type, classLoader: ClassLoaderReference?): Value defined in org.jetbrains.eval4j.jdi.JDIEval[DeserializedSimpleFunctionDescriptor]

'getObjectType' @ [284:41] ==> public open fun getObjectType(p0: (String..String?)): (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaMethodDescriptor]

'mainClassAsmNode' @ [284:55] ==> val mainClassAsmNode: ClassNode defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'name' @ [284:72] ==> public final var name: (String..String?) defined in org.jetbrains.org.objectweb.asm.tree.ClassNode[JavaPropertyDescriptor]

'classLoader' @ [284:79] ==> val classLoader: ClassLoaderReference defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'getArgumentTypes' @ [286:46] ==> public open fun getArgumentTypes(p0: (String..String?)): (Array<(Type..Type?)>..Array<out (Type..Type?)>?) defined in org.jetbrains.org.objectweb.asm.Type[JavaMethodDescriptor]

'methodToInvoke' @ [286:63] ==> val methodToInvoke: (MethodNode..MethodNode?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'desc' @ [286:78] ==> public final var desc: (String..String?) defined in org.jetbrains.org.objectweb.asm.tree.MethodNode[JavaPropertyDescriptor]

'context' @ [287:32] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[ValueParameterDescriptorImpl]

'getArgumentsForEval4j' @ [287:40] ==> private final fun EvaluationContextImpl.getArgumentsForEval4j(parameters: KotlinDebuggerCaches.ParametersDescriptor, parameterTypes: Array<Type>): List<Value> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'compiledData' @ [287:62] ==> value-parameter compiledData: KotlinDebuggerCaches.CompiledDataDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[ValueParameterDescriptorImpl]

'parameters' @ [287:75] ==> public final val parameters: KotlinDebuggerCaches.ParametersDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinDebuggerCaches.CompiledDataDescriptor[PropertyDescriptorImpl]

'argumentTypes' @ [287:87] ==> val argumentTypes: (Array<(Type..Type?)>..Array<out (Type..Type?)>?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation.<anonymous>[LocalVariableDescriptor]

'zip' @ [288:30] ==> public infix fun <T, R> Iterable<Value>.zip(other: Array<out (Type..Type?)>): List<Pair<Value, (Type..Type?)>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Value
    <R> -> (org.jetbrains.org.objectweb.asm.Type..org.jetbrains.org.objectweb.asm.Type?)

'argumentTypes' @ [288:34] ==> val argumentTypes: (Array<(Type..Type?)>..Array<out (Type..Type?)>?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation.<anonymous>[LocalVariableDescriptor]

'map' @ [289:30] ==> public inline fun <T, R> Iterable<Pair<Value, (Type..Type?)>>.map(transform: (Pair<Value, (Type..Type?)>) -> Value?): List<Value?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<Value, (org.jetbrains.org.objectweb.asm.Type..org.jetbrains.org.objectweb.asm.Type?)>
    <R> -> Value?

'component1' @ [289:37] ==> public final operator fun component1(): Value defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [289:44] ==> public final operator fun component2(): (Type..Type?) defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'eval' @ [291:33] ==> val eval: JDIEval defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'loadClass' @ [291:38] ==> public final fun loadClass(classType: Type, classLoader: ClassLoaderReference?): Value defined in org.jetbrains.eval4j.jdi.JDIEval[DeserializedSimpleFunctionDescriptor]

'type' @ [291:48] ==> val type: (Type..Type?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation.<anonymous>.<anonymous>[LocalVariableDescriptor]

'classLoader' @ [291:54] ==> val classLoader: ClassLoaderReference defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'boxOrUnboxArgumentIfNeeded' @ [292:33] ==> private final fun boxOrUnboxArgumentIfNeeded(eval: JDIEval, argumentValue: Value, parameterType: Type): Value defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'eval' @ [292:60] ==> val eval: JDIEval defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'value' @ [292:66] ==> val value: Value defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation.<anonymous>.<anonymous>[LocalVariableDescriptor]

'type' @ [292:73] ==> val type: (Type..Type?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation.<anonymous>.<anonymous>[LocalVariableDescriptor]

'asJdiValue' @ [292:79] ==> public fun Value.asJdiValue(vm: VirtualMachine, expectedType: Type): Value? defined in org.jetbrains.eval4j.jdi[DeserializedSimpleFunctionDescriptor]

'vm' @ [292:90] ==> val vm: VirtualMachine defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'type' @ [292:94] ==> val type: (Type..Type?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation.<anonymous>.<anonymous>[LocalVariableDescriptor]

'mainClass' @ [296:21] ==> val mainClass: ClassType defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'invokeMethod' @ [296:31] ==> public abstract fun invokeMethod(p0: (ThreadReference..ThreadReference?), p1: (Method..Method?), p2: (MutableList<out (Value..Value?)>..List<(Value..Value?)>?), p3: Int): (Value..Value?) defined in com.sun.jdi.ClassType[JavaMethodDescriptor]

'thread' @ [296:44] ==> val thread: ThreadReference defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'mainClass' @ [296:52] ==> val mainClass: ClassType defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'methods' @ [296:62] ==> public abstract fun methods(): (MutableList<(Method..Method?)>..List<(Method..Method?)>?) defined in com.sun.jdi.ClassType[JavaMethodDescriptor]

'single' @ [296:72] ==> public fun <T> List<(Method..Method?)>.single(): (Method..Method?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Method..com.sun.jdi.Method?)

'args' @ [296:82] ==> val args: List<Value?> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation.<anonymous>[LocalVariableDescriptor]

'invokePolicy' @ [296:88] ==> val invokePolicy: Int defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'LOG' @ [299:17] ==> internal val LOG: Logger defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'debug' @ [299:21] ==> public abstract fun debug(@NonNls p0: (String..String?), @Nullable p1: Throwable?): Unit defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'e' @ [299:77] ==> val e: Throwable defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.evaluateWithCompilation[LocalVariableDescriptor]

'context' @ [305:34] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j[ValueParameterDescriptorImpl]

'debugProcess' @ [305:42] ==> public final val EvaluationContextImpl.debugProcess: DebugProcessImpl[MyPropertyDescriptor]

'virtualMachineProxy' @ [305:55] ==> public final val DebugProcessImpl.virtualMachineProxy: VirtualMachineProxyImpl[MyPropertyDescriptor]

'virtualMachine' @ [305:75] ==> public final val VirtualMachineProxyImpl.virtualMachine: VirtualMachine[MyPropertyDescriptor]

'compiledData' @ [309:37] ==> value-parameter compiledData: KotlinDebuggerCaches.CompiledDataDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j[ValueParameterDescriptorImpl]

'mainClass' @ [309:50] ==> private final val KotlinDebuggerCaches.CompiledDataDescriptor.mainClass: ClassToLoad defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[PropertyDescriptorImpl]

'bytes' @ [309:60] ==> public final val bytes: ByteArray defined in org.jetbrains.kotlin.idea.debugger.evaluate.classLoading.ClassToLoad[PropertyDescriptorImpl]

'ClassReader' @ [311:13] ==> public constructor ClassReader(p0: (ByteArray..ByteArray?)) defined in org.jetbrains.org.objectweb.asm.ClassReader[JavaClassConstructorDescriptor]

'mainClassBytecode' @ [311:25] ==> val mainClassBytecode: ByteArray defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j[LocalVariableDescriptor]

'accept' @ [311:44] ==> public open fun accept(p0: (ClassVisitor..ClassVisitor?), p1: Int): Unit defined in org.jetbrains.org.objectweb.asm.ClassReader[JavaMethodDescriptor]

'ClassVisitor' @ [311:60] ==> public constructor ClassVisitor(p0: Int) defined in org.jetbrains.org.objectweb.asm.ClassVisitor[JavaClassConstructorDescriptor]

'ASM5' @ [311:73] ==> public const final val ASM5: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'name' @ [313:25] ==> value-parameter name: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j.<no name provided>.visitMethod[ValueParameterDescriptorImpl]

'GENERATED_FUNCTION_NAME' @ [313:33] ==> internal val GENERATED_FUNCTION_NAME: String defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'getArgumentTypes' @ [314:50] ==> public open fun getArgumentTypes(p0: (String..String?)): (Array<(Type..Type?)>..Array<out (Type..Type?)>?) defined in org.jetbrains.org.objectweb.asm.Type[JavaMethodDescriptor]

'desc' @ [314:67] ==> value-parameter desc: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j.<no name provided>.visitMethod[ValueParameterDescriptorImpl]

'context' @ [315:36] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j[ValueParameterDescriptorImpl]

'getArgumentsForEval4j' @ [315:44] ==> private final fun EvaluationContextImpl.getArgumentsForEval4j(parameters: KotlinDebuggerCaches.ParametersDescriptor, parameterTypes: Array<Type>): List<Value> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'compiledData' @ [315:66] ==> value-parameter compiledData: KotlinDebuggerCaches.CompiledDataDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j[ValueParameterDescriptorImpl]

'parameters' @ [315:79] ==> public final val parameters: KotlinDebuggerCaches.ParametersDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinDebuggerCaches.CompiledDataDescriptor[PropertyDescriptorImpl]

'argumentTypes' @ [315:91] ==> val argumentTypes: (Array<(Type..Type?)>..Array<out (Type..Type?)>?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j.<no name provided>.visitMethod[LocalVariableDescriptor]

'MethodNode' @ [317:41] ==> public constructor MethodNode(p0: Int, p1: Int, p2: (String..String?), p3: (String..String?), p4: (String..String?), p5: (Array<(String..String?)>..Array<out (String..String?)>?)) defined in org.jetbrains.org.objectweb.asm.tree.MethodNode[JavaClassConstructorDescriptor]

'ASM5' @ [317:60] ==> public const final val ASM5: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'access' @ [317:66] ==> value-parameter access: Int defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j.<no name provided>.visitMethod[ValueParameterDescriptorImpl]

'name' @ [317:74] ==> value-parameter name: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j.<no name provided>.visitMethod[ValueParameterDescriptorImpl]

'desc' @ [317:80] ==> value-parameter desc: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j.<no name provided>.visitMethod[ValueParameterDescriptorImpl]

'signature' @ [317:86] ==> value-parameter signature: String? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j.<no name provided>.visitMethod[ValueParameterDescriptorImpl]

'exceptions' @ [317:97] ==> value-parameter exceptions: Array<out String>? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j.<no name provided>.visitMethod[ValueParameterDescriptorImpl]

'virtualMachine' @ [319:33] ==> val virtualMachine: VirtualMachine defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j[LocalVariableDescriptor]

'executeWithBreakpointsDisabled' @ [319:48] ==> private final inline fun <T> VirtualMachine.executeWithBreakpointsDisabled(block: () -> Unit): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> Unit

'JDIEval' @ [320:48] ==> public constructor JDIEval(vm: VirtualMachine, defaultClassLoader: ClassLoaderReference?, thread: ThreadReference, invokePolicy: Int) defined in org.jetbrains.eval4j.jdi.JDIEval[DeserializedClassConstructorDescriptor]

'virtualMachine' @ [320:56] ==> val virtualMachine: VirtualMachine defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j[LocalVariableDescriptor]

'context' @ [321:56] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j[ValueParameterDescriptorImpl]

'classLoader' @ [321:64] ==> public final var EvaluationContextImpl.classLoader: ClassLoaderReference?[MyPropertyDescriptor]

'context' @ [322:56] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j[ValueParameterDescriptorImpl]

'suspendContext' @ [322:64] ==> public final val EvaluationContextImpl.suspendContext: SuspendContextImpl[MyPropertyDescriptor]

'thread' @ [322:79] ==> public final val SuspendContextImpl.thread: ThreadReferenceProxyImpl?[MyPropertyDescriptor]

'threadReference' @ [322:87] ==> public final val ThreadReferenceProxyImpl.threadReference: (ThreadReference..ThreadReference?)[MyPropertyDescriptor]

'context' @ [323:56] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j[ValueParameterDescriptorImpl]

'suspendContext' @ [323:64] ==> public final val EvaluationContextImpl.suspendContext: SuspendContextImpl[MyPropertyDescriptor]

'getInvokePolicy' @ [323:79] ==> internal fun SuspendContext.getInvokePolicy(): Int defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[SimpleFunctionDescriptorImpl]

'resultValue' @ [325:37] ==> var resultValue: InterpreterResult? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j[LocalVariableDescriptor]

'interpreterLoop' @ [325:51] ==> public fun interpreterLoop(m: MethodNode, initialState: Frame<Value>, eval: Eval, handler: InterpretationEventHandler = ...): InterpreterResult defined in org.jetbrains.eval4j[DeserializedSimpleFunctionDescriptor]

'this' @ [326:45] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j.<no name provided>.visitMethod.<no name provided>[LazyClassReceiverParameterDescriptor]

'makeInitialFrame' @ [327:45] ==> public fun makeInitialFrame(methodNode: MethodNode, arguments: List<Value>): Frame<Value> defined in org.jetbrains.eval4j.jdi[DeserializedSimpleFunctionDescriptor]

'this' @ [327:62] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j.<no name provided>.visitMethod.<no name provided>[LazyClassReceiverParameterDescriptor]

'args' @ [327:68] ==> val args: List<Value> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j.<no name provided>.visitMethod[LocalVariableDescriptor]

'zip' @ [327:73] ==> public infix fun <T, R> Iterable<Value>.zip(other: Array<out (Type..Type?)>): List<Pair<Value, (Type..Type?)>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Value
    <R> -> (org.jetbrains.org.objectweb.asm.Type..org.jetbrains.org.objectweb.asm.Type?)

'argumentTypes' @ [327:77] ==> val argumentTypes: (Array<(Type..Type?)>..Array<out (Type..Type?)>?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j.<no name provided>.visitMethod[LocalVariableDescriptor]

'map' @ [327:92] ==> public inline fun <T, R> Iterable<Pair<Value, (Type..Type?)>>.map(transform: (Pair<Value, (Type..Type?)>) -> Value): List<Value> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<Value, (org.jetbrains.org.objectweb.asm.Type..org.jetbrains.org.objectweb.asm.Type?)>
    <R> -> Value

'boxOrUnboxArgumentIfNeeded' @ [327:98] ==> private final fun boxOrUnboxArgumentIfNeeded(eval: JDIEval, argumentValue: Value, parameterType: Type): Value defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'eval' @ [327:125] ==> val eval: JDIEval defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j.<no name provided>.visitMethod.<no name provided>.visitEnd.<anonymous>[LocalVariableDescriptor]

'it' @ [327:131] ==> value-parameter it: Pair<Value, (Type..Type?)> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j.<no name provided>.visitMethod.<no name provided>.visitEnd.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'first' @ [327:134] ==> public final val first: Value defined in kotlin.Pair[DeserializedPropertyDescriptor]

'it' @ [327:141] ==> value-parameter it: Pair<Value, (Type..Type?)> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j.<no name provided>.visitMethod.<no name provided>.visitEnd.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'second' @ [327:144] ==> public final val second: (Type..Type?) defined in kotlin.Pair[DeserializedPropertyDescriptor]

'eval' @ [328:45] ==> val eval: JDIEval defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j.<no name provided>.visitMethod.<no name provided>.visitEnd.<anonymous>[LocalVariableDescriptor]

'super' @ [335:28] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j.<no name provided>[LazyClassReceiverParameterDescriptor]

'visitMethod' @ [335:34] ==> public open fun visitMethod(p0: Int, p1: (String..String?), p2: (String..String?), p3: (String..String?), p4: (Array<(String..String?)>..Array<out (String..String?)>?)): (MethodVisitor..MethodVisitor?) defined in org.jetbrains.org.objectweb.asm.ClassVisitor[JavaMethodDescriptor]

'access' @ [335:46] ==> value-parameter access: Int defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j.<no name provided>.visitMethod[ValueParameterDescriptorImpl]

'name' @ [335:54] ==> value-parameter name: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j.<no name provided>.visitMethod[ValueParameterDescriptorImpl]

'desc' @ [335:60] ==> value-parameter desc: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j.<no name provided>.visitMethod[ValueParameterDescriptorImpl]

'signature' @ [335:66] ==> value-parameter signature: String? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j.<no name provided>.visitMethod[ValueParameterDescriptorImpl]

'exceptions' @ [335:77] ==> value-parameter exceptions: Array<out String>? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j.<no name provided>.visitMethod[ValueParameterDescriptorImpl]

'resultValue' @ [339:20] ==> var resultValue: InterpreterResult? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.runEval4j[LocalVariableDescriptor]

'IllegalStateException' @ [339:41] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'+' @ [339:63] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'GENERATED_FUNCTION_NAME' @ [339:108] ==> internal val GENERATED_FUNCTION_NAME: String defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'eventRequestManager' @ [343:31] ==> public abstract fun eventRequestManager(): (EventRequestManager..EventRequestManager?) defined in com.sun.jdi.VirtualMachine[JavaMethodDescriptor]

'breakpointRequests' @ [343:53] ==> public abstract fun breakpointRequests(): (MutableList<(BreakpointRequest..BreakpointRequest?)>..List<(BreakpointRequest..BreakpointRequest?)>?) defined in com.sun.jdi.request.EventRequestManager[JavaMethodDescriptor]

'eventRequestManager' @ [343:76] ==> public abstract fun eventRequestManager(): (EventRequestManager..EventRequestManager?) defined in com.sun.jdi.VirtualMachine[JavaMethodDescriptor]

'classPrepareRequests' @ [343:98] ==> public abstract fun classPrepareRequests(): (MutableList<(ClassPrepareRequest..ClassPrepareRequest?)>..List<(ClassPrepareRequest..ClassPrepareRequest?)>?) defined in com.sun.jdi.request.EventRequestManager[JavaMethodDescriptor]

'allRequests' @ [346:17] ==> val allRequests: List<(EventRequest..EventRequest?)> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.executeWithBreakpointsDisabled[LocalVariableDescriptor]

'forEach' @ [346:29] ==> @HidesMembers public inline fun <T> Iterable<(EventRequest..EventRequest?)>.forEach(action: ((EventRequest..EventRequest?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.request.EventRequest..com.sun.jdi.request.EventRequest?)

'it' @ [346:39] ==> value-parameter it: (EventRequest..EventRequest?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.executeWithBreakpointsDisabled.<anonymous>[ValueParameterDescriptorImpl]

'disable' @ [346:42] ==> public abstract fun disable(): Unit defined in com.sun.jdi.request.EventRequest[JavaMethodDescriptor]

'invoke' @ [347:24] ==> public abstract operator fun invoke(): T defined in kotlin.Function0[FunctionInvokeDescriptor]

'allRequests' @ [349:17] ==> val allRequests: List<(EventRequest..EventRequest?)> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.executeWithBreakpointsDisabled[LocalVariableDescriptor]

'forEach' @ [349:29] ==> @HidesMembers public inline fun <T> Iterable<(EventRequest..EventRequest?)>.forEach(action: ((EventRequest..EventRequest?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.request.EventRequest..com.sun.jdi.request.EventRequest?)

'it' @ [349:39] ==> value-parameter it: (EventRequest..EventRequest?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.executeWithBreakpointsDisabled.<anonymous>[ValueParameterDescriptorImpl]

'enable' @ [349:42] ==> public abstract fun enable(): Unit defined in com.sun.jdi.request.EventRequest[JavaMethodDescriptor]

'argumentValue' @ [354:32] ==> value-parameter argumentValue: Value defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.boxOrUnboxArgumentIfNeeded[ValueParameterDescriptorImpl]

'asmType' @ [354:46] ==> public abstract val asmType: Type defined in org.jetbrains.eval4j.Value[DeserializedPropertyDescriptor]

'isPrimitive' @ [356:25] ==> public open fun isPrimitive(p0: (Type..Type?)): Boolean defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaMethodDescriptor]

'parameterType' @ [356:37] ==> value-parameter parameterType: Type defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.boxOrUnboxArgumentIfNeeded[ValueParameterDescriptorImpl]

'!' @ [356:55] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isPrimitive' @ [356:64] ==> public open fun isPrimitive(p0: (Type..Type?)): Boolean defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaMethodDescriptor]

'argumentType' @ [356:76] ==> val argumentType: Type defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.boxOrUnboxArgumentIfNeeded[LocalVariableDescriptor]

'unboxType' @ [358:47] ==> @NotNull public open fun unboxType(@NotNull p0: Type): Type defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaMethodDescriptor]

'argumentType' @ [358:57] ==> val argumentType: Type defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.boxOrUnboxArgumentIfNeeded[LocalVariableDescriptor]

'parameterType' @ [359:25] ==> value-parameter parameterType: Type defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.boxOrUnboxArgumentIfNeeded[ValueParameterDescriptorImpl]

'unboxedType' @ [359:42] ==> val unboxedType: Type defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.boxOrUnboxArgumentIfNeeded[LocalVariableDescriptor]

'eval' @ [360:32] ==> value-parameter eval: JDIEval defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.boxOrUnboxArgumentIfNeeded[ValueParameterDescriptorImpl]

'unboxType' @ [360:37] ==> public final fun unboxType(boxedValue: Value, type: Type): Value defined in org.jetbrains.eval4j.jdi.JDIEval[DeserializedSimpleFunctionDescriptor]

'argumentValue' @ [360:47] ==> value-parameter argumentValue: Value defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.boxOrUnboxArgumentIfNeeded[ValueParameterDescriptorImpl]

'parameterType' @ [360:62] ==> value-parameter parameterType: Type defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.boxOrUnboxArgumentIfNeeded[ValueParameterDescriptorImpl]

'!' @ [367:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isPrimitive' @ [367:26] ==> public open fun isPrimitive(p0: (Type..Type?)): Boolean defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaMethodDescriptor]

'parameterType' @ [367:38] ==> value-parameter parameterType: Type defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.boxOrUnboxArgumentIfNeeded[ValueParameterDescriptorImpl]

'isPrimitive' @ [367:64] ==> public open fun isPrimitive(p0: (Type..Type?)): Boolean defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaMethodDescriptor]

'argumentType' @ [367:76] ==> val argumentType: Type defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.boxOrUnboxArgumentIfNeeded[LocalVariableDescriptor]

'parameterType' @ [368:21] ==> value-parameter parameterType: Type defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.boxOrUnboxArgumentIfNeeded[ValueParameterDescriptorImpl]

'FrameVisitor' @ [368:38] ==> public companion object defined in org.jetbrains.kotlin.idea.debugger.evaluate.FrameVisitor[FakeCallableDescriptorForObject]

'OBJECT_TYPE' @ [368:51] ==> public final val OBJECT_TYPE: (Type..Type?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.FrameVisitor.Companion[PropertyDescriptorImpl]

'parameterType' @ [368:66] ==> value-parameter parameterType: Type defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.boxOrUnboxArgumentIfNeeded[ValueParameterDescriptorImpl]

'boxType' @ [368:91] ==> @NotNull public open fun boxType(@NotNull p0: Type): Type defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaMethodDescriptor]

'argumentType' @ [368:99] ==> val argumentType: Type defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.boxOrUnboxArgumentIfNeeded[LocalVariableDescriptor]

'eval' @ [369:28] ==> value-parameter eval: JDIEval defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.boxOrUnboxArgumentIfNeeded[ValueParameterDescriptorImpl]

'boxType' @ [369:33] ==> public final fun boxType(value: Value): Value defined in org.jetbrains.eval4j.jdi.JDIEval[DeserializedSimpleFunctionDescriptor]

'argumentValue' @ [369:41] ==> value-parameter argumentValue: Value defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.boxOrUnboxArgumentIfNeeded[ValueParameterDescriptorImpl]

'argumentValue' @ [373:20] ==> value-parameter argumentValue: Value defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.boxOrUnboxArgumentIfNeeded[ValueParameterDescriptorImpl]

'when (this) {
                is ValueReturned -> result
                is ExceptionThrown -> {
                    when {
                        this.kind == ExceptionThrown.ExceptionKind.FROM_EVALUATED_CODE ->
                            exception(InvocationException(this.exception.value as ObjectReference))
                        this.kind == ExceptionThrown.ExceptionKind.BROKEN_CODE ->
                            throw exception.value as Throwable
                        else ->
                            exception(exception.toString())
                    }
                }
                is AbnormalTermination -> exception(message)
                else -> throw IllegalStateException("Unknown result value produced by eval4j")
            }' @ [377:28] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Value, entry1: Value, entry2: Value, entry3: Value): Value[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Value

'this' @ [377:34] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.toJdiValue[ReceiverParameterDescriptorImpl]

'result' @ [378:37] ==> public final val result: Value defined in org.jetbrains.eval4j.ValueReturned[DeserializedPropertyDescriptor]

'when {
                        this.kind == ExceptionThrown.ExceptionKind.FROM_EVALUATED_CODE ->
                            exception(InvocationException(this.exception.value as ObjectReference))
                        this.kind == ExceptionThrown.ExceptionKind.BROKEN_CODE ->
                            throw exception.value as Throwable
                        else ->
                            exception(exception.toString())
                    }' @ [380:21] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Value, entry1: Value, entry2: Value): Value[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Value

'this' @ [381:25] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.toJdiValue[ReceiverParameterDescriptorImpl]

'kind' @ [381:30] ==> public final val kind: ExceptionThrown.ExceptionKind defined in org.jetbrains.eval4j.ExceptionThrown[DeserializedPropertyDescriptor]

'FROM_EVALUATED_CODE' @ [381:68] ==> enum entry FROM_EVALUATED_CODE defined in org.jetbrains.eval4j.ExceptionThrown.ExceptionKind[FakeCallableDescriptorForObject]

'exception' @ [382:29] ==> private final fun exception(e: Throwable): Nothing defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'InvocationException' @ [382:39] ==> public constructor InvocationException(p0: (ObjectReference..ObjectReference?)) defined in com.sun.jdi.InvocationException[JavaClassConstructorDescriptor]

'this' @ [382:59] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.toJdiValue[ReceiverParameterDescriptorImpl]

'exception' @ [382:64] ==> public final val exception: ObjectValue defined in org.jetbrains.eval4j.ExceptionThrown[DeserializedPropertyDescriptor]

'value' @ [382:74] ==> public open val value: Any? defined in org.jetbrains.eval4j.ObjectValue[DeserializedPropertyDescriptor]

'this' @ [383:25] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.toJdiValue[ReceiverParameterDescriptorImpl]

'kind' @ [383:30] ==> public final val kind: ExceptionThrown.ExceptionKind defined in org.jetbrains.eval4j.ExceptionThrown[DeserializedPropertyDescriptor]

'BROKEN_CODE' @ [383:68] ==> enum entry BROKEN_CODE defined in org.jetbrains.eval4j.ExceptionThrown.ExceptionKind[FakeCallableDescriptorForObject]

'exception' @ [384:35] ==> public final val exception: ObjectValue defined in org.jetbrains.eval4j.ExceptionThrown[DeserializedPropertyDescriptor]

'value' @ [384:45] ==> public open val value: Any? defined in org.jetbrains.eval4j.ObjectValue[DeserializedPropertyDescriptor]

'exception' @ [386:29] ==> private final fun exception(msg: String): Nothing defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'exception' @ [386:39] ==> public final val exception: ObjectValue defined in org.jetbrains.eval4j.ExceptionThrown[DeserializedPropertyDescriptor]

'toString' @ [386:49] ==> public open fun toString(): String defined in org.jetbrains.eval4j.ObjectValue[DeserializedSimpleFunctionDescriptor]

'exception' @ [389:43] ==> private final fun exception(msg: String): Nothing defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'message' @ [389:53] ==> public final val message: String defined in org.jetbrains.eval4j.AbnormalTermination[DeserializedPropertyDescriptor]

'IllegalStateException' @ [390:31] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'context' @ [393:22] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.toJdiValue[ValueParameterDescriptorImpl]

'debugProcess' @ [393:30] ==> public final val EvaluationContextImpl.debugProcess: DebugProcessImpl[MyPropertyDescriptor]

'virtualMachineProxy' @ [393:43] ==> public final val DebugProcessImpl.virtualMachineProxy: VirtualMachineProxyImpl[MyPropertyDescriptor]

'virtualMachine' @ [393:63] ==> public final val VirtualMachineProxyImpl.virtualMachine: VirtualMachine[MyPropertyDescriptor]

'FrameVisitor' @ [394:29] ==> public constructor FrameVisitor(context: EvaluationContextImpl) defined in org.jetbrains.kotlin.idea.debugger.evaluate.FrameVisitor[ClassConstructorDescriptorImpl]

'context' @ [394:42] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.toJdiValue[ValueParameterDescriptorImpl]

'getValueIfSharedVar' @ [394:51] ==> public final fun getValueIfSharedVar(value: Value, expectedType: Type?, checkType: Boolean): Value? defined in org.jetbrains.kotlin.idea.debugger.evaluate.FrameVisitor[SimpleFunctionDescriptorImpl]

'jdiValue' @ [394:71] ==> val jdiValue: Value defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.toJdiValue[LocalVariableDescriptor]

'jdiValue' @ [394:81] ==> val jdiValue: Value defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.toJdiValue[LocalVariableDescriptor]

'asmType' @ [394:90] ==> public abstract val asmType: Type defined in org.jetbrains.eval4j.Value[DeserializedPropertyDescriptor]

'sharedVar' @ [395:20] ==> val sharedVar: Value? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.toJdiValue[LocalVariableDescriptor]

'asJdiValue' @ [395:31] ==> public fun Value.asJdiValue(vm: VirtualMachine, expectedType: Type): Value? defined in org.jetbrains.eval4j.jdi[DeserializedSimpleFunctionDescriptor]

'vm' @ [395:42] ==> val vm: VirtualMachine defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.toJdiValue[LocalVariableDescriptor]

'sharedVar' @ [395:46] ==> val sharedVar: Value? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.toJdiValue[LocalVariableDescriptor]

'asmType' @ [395:56] ==> public abstract val asmType: Type defined in org.jetbrains.eval4j.Value[DeserializedPropertyDescriptor]

'jdiValue' @ [395:68] ==> val jdiValue: Value defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.toJdiValue[LocalVariableDescriptor]

'asJdiValue' @ [395:77] ==> public fun Value.asJdiValue(vm: VirtualMachine, expectedType: Type): Value? defined in org.jetbrains.eval4j.jdi[DeserializedSimpleFunctionDescriptor]

'vm' @ [395:88] ==> val vm: VirtualMachine defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.toJdiValue[LocalVariableDescriptor]

'jdiValue' @ [395:92] ==> val jdiValue: Value defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.toJdiValue[LocalVariableDescriptor]

'asmType' @ [395:101] ==> public abstract val asmType: Type defined in org.jetbrains.eval4j.Value[DeserializedPropertyDescriptor]

'runReadAction' @ [399:20] ==> public fun <T> runReadAction(action: () -> KotlinDebuggerCaches.ParametersDescriptor): KotlinDebuggerCaches.ParametersDescriptor defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ParametersDescriptor

'HashMap' @ [400:39] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> String
    <V : (Any..Any?)> -> Value

'fragment' @ [402:42] ==> value-parameter fragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getParametersForDebugger[ValueParameterDescriptorImpl]

'context' @ [402:51] ==> public final val KtCodeFragment.context: PsiElement?[MyPropertyDescriptor]

'containingFile' @ [402:60] ==> public final val PsiElement.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'contextElementFile' @ [403:21] ==> val contextElementFile: PsiFile? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getParametersForDebugger.<anonymous>[LocalVariableDescriptor]

'contextElementFile' @ [404:21] ==> val contextElementFile: PsiFile? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getParametersForDebugger.<anonymous>[LocalVariableDescriptor]

'accept' @ [404:40] ==> public abstract fun accept(@NotNull p0: PsiElementVisitor): Unit defined in com.intellij.psi.PsiFile[JavaMethodDescriptor]

'KtTreeVisitorVoid' @ [404:56] ==> public constructor KtTreeVisitorVoid() defined in org.jetbrains.kotlin.psi.KtTreeVisitorVoid[JavaClassConstructorDescriptor]

'property' @ [406:41] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getParametersForDebugger.<anonymous>.<no name provided>.visitProperty[ValueParameterDescriptorImpl]

'getUserData' @ [406:50] ==> public open fun <T : (Any..Any?)> getUserData(@NotNull p0: Key<(Value..Value?)>): Value? defined in org.jetbrains.kotlin.psi.KtProperty[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Value

'KotlinCodeFragmentFactory' @ [406:62] ==> public companion object defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinCodeFragmentFactory[FakeCallableDescriptorForObject]

'LABEL_VARIABLE_VALUE_KEY' @ [406:88] ==> public final val LABEL_VARIABLE_VALUE_KEY: Key<Value> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinCodeFragmentFactory.Companion[PropertyDescriptorImpl]

'value' @ [407:33] ==> val value: Value? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getParametersForDebugger.<anonymous>.<no name provided>.visitProperty[LocalVariableDescriptor]

'valuesForLabels' @ [408:33] ==> val valuesForLabels: HashMap<String, Value> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getParametersForDebugger.<anonymous>[LocalVariableDescriptor]

'put' @ [408:49] ==> public open fun put(key: String, value: Value): Value? defined in java.util.HashMap[JavaMethodDescriptor]

'property' @ [408:53] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getParametersForDebugger.<anonymous>.<no name provided>.visitProperty[ValueParameterDescriptorImpl]

'name' @ [408:62] ==> public final val KtProperty.name: String?[MyPropertyDescriptor]

'quoteIfNeeded' @ [408:68] ==> public fun String.quoteIfNeeded(): String defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]

'value' @ [408:87] ==> val value: Value? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getParametersForDebugger.<anonymous>.<no name provided>.visitProperty[LocalVariableDescriptor]

'asValue' @ [408:93] ==> public fun Value?.asValue(): Value defined in org.jetbrains.eval4j.jdi[DeserializedSimpleFunctionDescriptor]

'ParametersDescriptor' @ [414:34] ==> public constructor ParametersDescriptor() defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinDebuggerCaches.ParametersDescriptor[ClassConstructorDescriptorImpl]

'config' @ [415:32] ==> public final val config: ExtractionGeneratorConfiguration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionResult[PropertyDescriptorImpl]

'descriptor' @ [415:39] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'receiverParameter' @ [415:50] ==> public final val receiverParameter: Parameter? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'receiver' @ [416:21] ==> val receiver: Parameter? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getParametersForDebugger.<anonymous>[LocalVariableDescriptor]

'parameters' @ [417:21] ==> val parameters: KotlinDebuggerCaches.ParametersDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getParametersForDebugger.<anonymous>[LocalVariableDescriptor]

'add' @ [417:32] ==> public final fun add(name: String, jetType: KotlinType, value: Value? = ...): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinDebuggerCaches.ParametersDescriptor[SimpleFunctionDescriptorImpl]

'THIS_NAME' @ [417:36] ==> internal val THIS_NAME: String defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'receiver' @ [417:47] ==> val receiver: Parameter? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getParametersForDebugger.<anonymous>[LocalVariableDescriptor]

'getParameterType' @ [417:56] ==> public abstract fun getParameterType(allowSpecialClassNames: Boolean): KotlinType defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.Parameter[SimpleFunctionDescriptorImpl]

'config' @ [420:31] ==> public final val config: ExtractionGeneratorConfiguration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionResult[PropertyDescriptorImpl]

'descriptor' @ [420:38] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'parameters' @ [420:49] ==> public final val parameters: List<Parameter> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'when {
                        param.argumentText.contains("@") -> param.argumentText.substringBefore("@")
                        param.argumentText.startsWith("::") -> param.argumentText.substring(2)
                        else -> param.argumentText
                    }' @ [421:37] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: String, entry1: String, entry2: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> String

'param' @ [422:25] ==> val param: Parameter defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getParametersForDebugger.<anonymous>[LocalVariableDescriptor]

'argumentText' @ [422:31] ==> public abstract val argumentText: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.Parameter[PropertyDescriptorImpl]

'contains' @ [422:44] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'param' @ [422:61] ==> val param: Parameter defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getParametersForDebugger.<anonymous>[LocalVariableDescriptor]

'argumentText' @ [422:67] ==> public abstract val argumentText: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.Parameter[PropertyDescriptorImpl]

'substringBefore' @ [422:80] ==> public fun String.substringBefore(delimiter: String, missingDelimiterValue: String = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'param' @ [423:25] ==> val param: Parameter defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getParametersForDebugger.<anonymous>[LocalVariableDescriptor]

'argumentText' @ [423:31] ==> public abstract val argumentText: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.Parameter[PropertyDescriptorImpl]

'startsWith' @ [423:44] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'param' @ [423:64] ==> val param: Parameter defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getParametersForDebugger.<anonymous>[LocalVariableDescriptor]

'argumentText' @ [423:70] ==> public abstract val argumentText: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.Parameter[PropertyDescriptorImpl]

'substring' @ [423:83] ==> @InlineOnly public inline fun String.substring(startIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'param' @ [424:33] ==> val param: Parameter defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getParametersForDebugger.<anonymous>[LocalVariableDescriptor]

'argumentText' @ [424:39] ==> public abstract val argumentText: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.Parameter[PropertyDescriptorImpl]

'parameters' @ [426:21] ==> val parameters: KotlinDebuggerCaches.ParametersDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getParametersForDebugger.<anonymous>[LocalVariableDescriptor]

'add' @ [426:32] ==> public final fun add(name: String, jetType: KotlinType, value: Value? = ...): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinDebuggerCaches.ParametersDescriptor[SimpleFunctionDescriptorImpl]

'paramName' @ [426:36] ==> val paramName: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getParametersForDebugger.<anonymous>[LocalVariableDescriptor]

'param' @ [426:47] ==> val param: Parameter defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getParametersForDebugger.<anonymous>[LocalVariableDescriptor]

'getParameterType' @ [426:53] ==> public abstract fun getParameterType(allowSpecialClassNames: Boolean): KotlinType defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.Parameter[SimpleFunctionDescriptorImpl]

'valuesForLabels' @ [426:77] ==> val valuesForLabels: HashMap<String, Value> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getParametersForDebugger.<anonymous>[LocalVariableDescriptor]

'paramName' @ [426:93] ==> val paramName: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getParametersForDebugger.<anonymous>[LocalVariableDescriptor]

'parameters' @ [428:17] ==> val parameters: KotlinDebuggerCaches.ParametersDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getParametersForDebugger.<anonymous>[LocalVariableDescriptor]

'FrameVisitor' @ [433:32] ==> public constructor FrameVisitor(context: EvaluationContextImpl) defined in org.jetbrains.kotlin.idea.debugger.evaluate.FrameVisitor[ClassConstructorDescriptorImpl]

'this' @ [433:45] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getArgumentsForEval4j[ReceiverParameterDescriptorImpl]

'parameters' @ [434:20] ==> value-parameter parameters: KotlinDebuggerCaches.ParametersDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getArgumentsForEval4j[ValueParameterDescriptorImpl]

'zip' @ [434:31] ==> public infix fun <T, R> Iterable<KotlinDebuggerCaches.Parameter>.zip(other: Array<out Type>): List<Pair<KotlinDebuggerCaches.Parameter, Type>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Parameter
    <R> -> Type

'parameterTypes' @ [434:35] ==> value-parameter parameterTypes: Array<Type> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getArgumentsForEval4j[ValueParameterDescriptorImpl]

'map' @ [434:51] ==> public inline fun <T, R> Iterable<Pair<KotlinDebuggerCaches.Parameter, Type>>.map(transform: (Pair<KotlinDebuggerCaches.Parameter, Type>) -> Value): List<Value> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<Parameter, Type>
    <R> -> Value

'if (it.first.value != null) {
                    it.first.value!!
                }
                else {
                    frameVisitor.findValue(it.first.callText, it.second, checkType = false, failIfNotFound = true)!!
                }' @ [435:30] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Value, elseBranch: Value): Value[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Value

'it' @ [435:34] ==> value-parameter it: Pair<KotlinDebuggerCaches.Parameter, Type> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getArgumentsForEval4j.<anonymous>[ValueParameterDescriptorImpl]

'first' @ [435:37] ==> public final val first: KotlinDebuggerCaches.Parameter defined in kotlin.Pair[DeserializedPropertyDescriptor]

'value' @ [435:43] ==> public final val value: Value? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinDebuggerCaches.Parameter[PropertyDescriptorImpl]

'it' @ [436:21] ==> value-parameter it: Pair<KotlinDebuggerCaches.Parameter, Type> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getArgumentsForEval4j.<anonymous>[ValueParameterDescriptorImpl]

'first' @ [436:24] ==> public final val first: KotlinDebuggerCaches.Parameter defined in kotlin.Pair[DeserializedPropertyDescriptor]

'value' @ [436:30] ==> public final val value: Value? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinDebuggerCaches.Parameter[PropertyDescriptorImpl]

'frameVisitor' @ [439:21] ==> val frameVisitor: FrameVisitor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getArgumentsForEval4j[LocalVariableDescriptor]

'findValue' @ [439:34] ==> public final fun findValue(name: String, asmType: Type?, checkType: Boolean, failIfNotFound: Boolean): Value? defined in org.jetbrains.kotlin.idea.debugger.evaluate.FrameVisitor[SimpleFunctionDescriptorImpl]

'it' @ [439:44] ==> value-parameter it: Pair<KotlinDebuggerCaches.Parameter, Type> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getArgumentsForEval4j.<anonymous>[ValueParameterDescriptorImpl]

'first' @ [439:47] ==> public final val first: KotlinDebuggerCaches.Parameter defined in kotlin.Pair[DeserializedPropertyDescriptor]

'callText' @ [439:53] ==> public final val callText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinDebuggerCaches.Parameter[PropertyDescriptorImpl]

'it' @ [439:63] ==> value-parameter it: Pair<KotlinDebuggerCaches.Parameter, Type> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getArgumentsForEval4j.<anonymous>[ValueParameterDescriptorImpl]

'second' @ [439:66] ==> public final val second: Type defined in kotlin.Pair[DeserializedPropertyDescriptor]

'LOG' @ [441:21] ==> internal val LOG: Logger defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'isDebugEnabled' @ [441:25] ==> public final val Logger.isDebugEnabled: Boolean[MyPropertyDescriptor]

'LOG' @ [442:21] ==> internal val LOG: Logger defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'debug' @ [442:25] ==> public abstract fun debug(@NonNls p0: (String..String?)): Unit defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'it' @ [442:63] ==> value-parameter it: Pair<KotlinDebuggerCaches.Parameter, Type> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getArgumentsForEval4j.<anonymous>[ValueParameterDescriptorImpl]

'first' @ [442:66] ==> public final val first: KotlinDebuggerCaches.Parameter defined in kotlin.Pair[DeserializedPropertyDescriptor]

'callText' @ [442:72] ==> public final val callText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinDebuggerCaches.Parameter[PropertyDescriptorImpl]

'it' @ [442:92] ==> value-parameter it: Pair<KotlinDebuggerCaches.Parameter, Type> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getArgumentsForEval4j.<anonymous>[ValueParameterDescriptorImpl]

'second' @ [442:95] ==> public final val second: Type defined in kotlin.Pair[DeserializedPropertyDescriptor]

'result' @ [442:113] ==> val result: Value defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getArgumentsForEval4j.<anonymous>[LocalVariableDescriptor]

'result' @ [444:17] ==> val result: Value defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.getArgumentsForEval4j.<anonymous>[LocalVariableDescriptor]

'runReadAction' @ [454:20] ==> public fun <T> runReadAction(action: () -> ClassFileFactory): ClassFileFactory defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ClassFileFactory

'createFileForDebugger' @ [455:39] ==> private fun createFileForDebugger(codeFragment: KtCodeFragment, extractedFunction: KtNamedFunction): KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[SimpleFunctionDescriptorImpl]

'codeFragment' @ [455:61] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory[ValueParameterDescriptorImpl]

'extractedFunction' @ [455:75] ==> value-parameter extractedFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory[ValueParameterDescriptorImpl]

'LOG' @ [456:21] ==> internal val LOG: Logger defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'isDebugEnabled' @ [456:25] ==> public final val Logger.isDebugEnabled: Boolean[MyPropertyDescriptor]

'LOG' @ [457:21] ==> internal val LOG: Logger defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'debug' @ [457:25] ==> public abstract fun debug(@NonNls p0: (String..String?)): Unit defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'runReadAction' @ [457:52] ==> public fun <T> runReadAction(action: () -> (String..String?)): (String..String?) defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.String..kotlin.String?)

'fileForDebugger' @ [457:68] ==> val fileForDebugger: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory.<anonymous>[LocalVariableDescriptor]

'text' @ [457:84] ==> public final val KtFile.text: (String..String?)[MyPropertyDescriptor]

'component1' @ [460:22] ==> public final operator fun component1(): BindingContext defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.ExtendedAnalysisResult[SimpleFunctionDescriptorImpl]

'component2' @ [460:38] ==> public final operator fun component2(): ModuleDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.ExtendedAnalysisResult[SimpleFunctionDescriptorImpl]

'component3' @ [460:56] ==> public final operator fun component3(): List<KtFile> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.ExtendedAnalysisResult[SimpleFunctionDescriptorImpl]

'fileForDebugger' @ [460:65] ==> val fileForDebugger: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory.<anonymous>[LocalVariableDescriptor]

'checkForErrors' @ [460:81] ==> private final fun KtFile.checkForErrors(analyzeInlineFunctions: Boolean = ..., contextFile: KtFile? = ...): KotlinEvaluator.Companion.ExtendedAnalysisResult defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'codeFragment' @ [460:102] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory[ValueParameterDescriptorImpl]

'getContextContainingFile' @ [460:115] ==> public final fun getContextContainingFile(): KtFile? defined in org.jetbrains.kotlin.psi.KtCodeFragment[DeserializedSimpleFunctionDescriptor]

'GenerationState.GenerateClassFilter' @ [462:52] ==> public constructor GenerateClassFilter() defined in org.jetbrains.kotlin.codegen.state.GenerationState.GenerateClassFilter[DeserializedClassConstructorDescriptor]

'ktFile' @ [463:78] ==> value-parameter ktFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory.<anonymous>.<no name provided>.shouldGeneratePackagePart[ValueParameterDescriptorImpl]

'fileForDebugger' @ [463:88] ==> val fileForDebugger: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory.<anonymous>[LocalVariableDescriptor]

'processingClassOrObject' @ [465:98] ==> value-parameter processingClassOrObject: KtClassOrObject defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory.<anonymous>.<no name provided>.shouldGenerateClass[ValueParameterDescriptorImpl]

'containingKtFile' @ [465:122] ==> public final val KtClassOrObject.containingKtFile: KtFile[MyPropertyDescriptor]

'fileForDebugger' @ [465:142] ==> val fileForDebugger: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory.<anonymous>[LocalVariableDescriptor]

'GenerationState' @ [469:29] ==> @JvmOverloads public constructor GenerationState(project: Project, builderFactory: ClassBuilderFactory, module: ModuleDescriptor, bindingContext: BindingContext, files: List<KtFile>, configuration: CompilerConfiguration, generateDeclaredClassFilter: GenerationState.GenerateClassFilter = ..., codegenFactory: CodegenFactory = ..., targetId: TargetId? = ..., moduleName: String? = ..., outDirectory: File? = ..., onIndependentPartCompilationEnd: GenerationStateEventCallback = ..., wantsDiagnostics: Boolean = ...) defined in org.jetbrains.kotlin.codegen.state.GenerationState[DeserializedClassConstructorDescriptor]

'fileForDebugger' @ [470:25] ==> val fileForDebugger: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory.<anonymous>[LocalVariableDescriptor]

'project' @ [470:41] ==> public final val KtFile.project: Project[MyPropertyDescriptor]

'if (!DEBUG_MODE) ClassBuilderFactories.binaries(false) else ClassBuilderFactories.TEST' @ [471:25] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: ClassBuilderFactory, elseBranch: ClassBuilderFactory): ClassBuilderFactory[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> ClassBuilderFactory

'!' @ [471:29] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'DEBUG_MODE' @ [471:30] ==> private val DEBUG_MODE: Boolean defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'binaries' @ [471:64] ==> @NotNull public open fun binaries(p0: Boolean): ClassBuilderFactory defined in org.jetbrains.kotlin.codegen.ClassBuilderFactories[JavaMethodDescriptor]

'TEST' @ [471:107] ==> public final var TEST: (ClassBuilderFactory..ClassBuilderFactory?) defined in org.jetbrains.kotlin.codegen.ClassBuilderFactories[JavaPropertyDescriptor]

'moduleDescriptor' @ [472:25] ==> val moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory.<anonymous>[LocalVariableDescriptor]

'bindingContext' @ [473:25] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory.<anonymous>[LocalVariableDescriptor]

'files' @ [474:25] ==> val files: List<KtFile> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory.<anonymous>[LocalVariableDescriptor]

'EMPTY' @ [475:47] ==> public final var EMPTY: (CompilerConfiguration..CompilerConfiguration?) defined in org.jetbrains.kotlin.config.CompilerConfiguration[JavaPropertyDescriptor]

'generateClassFilter' @ [476:25] ==> val generateClassFilter: <no name provided> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory.<anonymous>[LocalVariableDescriptor]

'FrameVisitor' @ [479:36] ==> public constructor FrameVisitor(context: EvaluationContextImpl) defined in org.jetbrains.kotlin.idea.debugger.evaluate.FrameVisitor[ClassConstructorDescriptorImpl]

'context' @ [479:49] ==> value-parameter context: EvaluationContextImpl defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory[ValueParameterDescriptorImpl]

'extractedFunction' @ [481:17] ==> value-parameter extractedFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory[ValueParameterDescriptorImpl]

'receiverTypeReference' @ [481:35] ==> public final val KtNamedFunction.receiverTypeReference: KtTypeReference?[MyPropertyDescriptor]

'let' @ [481:58] ==> @InlineOnly public inline fun <T, R> KtTypeReference.let(block: (KtTypeReference) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtTypeReference
    <R> -> Unit

'state' @ [482:21] ==> val state: GenerationState defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory.<anonymous>[LocalVariableDescriptor]

'bindingTrace' @ [482:27] ==> public final val bindingTrace: BindingTrace defined in org.jetbrains.kotlin.codegen.state.GenerationState[DeserializedPropertyDescriptor]

'recordAnonymousType' @ [482:40] ==> private final fun BindingTrace.recordAnonymousType(typeReference: KtTypeReference, localVariableName: String, visitor: FrameVisitor): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'it' @ [482:60] ==> value-parameter it: KtTypeReference defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'THIS_NAME' @ [482:64] ==> internal val THIS_NAME: String defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'frameVisitor' @ [482:75] ==> val frameVisitor: FrameVisitor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory.<anonymous>[LocalVariableDescriptor]

'extractedFunction' @ [485:39] ==> value-parameter extractedFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory[ValueParameterDescriptorImpl]

'valueParameters' @ [485:57] ==> public final val KtNamedFunction.valueParameters: (MutableList<(KtParameter..KtParameter?)>..List<(KtParameter..KtParameter?)>)[MyPropertyDescriptor]

'parameters' @ [487:31] ==> value-parameter parameters: KotlinDebuggerCaches.ParametersDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory[ValueParameterDescriptorImpl]

'valueParameters' @ [488:42] ==> val valueParameters: (MutableList<(KtParameter..KtParameter?)>..List<(KtParameter..KtParameter?)>) defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory.<anonymous>[LocalVariableDescriptor]

'paramIndex' @ [488:58] ==> var paramIndex: Int defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory.<anonymous>[LocalVariableDescriptor]

'valueParameter' @ [490:36] ==> val valueParameter: (KtParameter..KtParameter?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory.<anonymous>[LocalVariableDescriptor]

'typeReference' @ [490:51] ==> public final var KtParameter.typeReference: KtTypeReference?[MyPropertyDescriptor]

'paramRef' @ [491:25] ==> val paramRef: KtTypeReference? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory.<anonymous>[LocalVariableDescriptor]

'LOG' @ [492:25] ==> internal val LOG: Logger defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'error' @ [492:29] ==> public open fun error(@NonNls p0: (String..String?), @NotNull vararg p1: (Attachment..Attachment?)): Unit defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'Attachment' @ [493:35] ==> public constructor Attachment(@NotNull p0: String, @NotNull p1: String) defined in com.intellij.openapi.diagnostic.Attachment[JavaClassConstructorDescriptor]

'codeFragment' @ [493:66] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory[ValueParameterDescriptorImpl]

'text' @ [493:79] ==> public final val KtCodeFragment.text: (String..String?)[MyPropertyDescriptor]

'Attachment' @ [494:35] ==> public constructor Attachment(@NotNull p0: String, @NotNull p1: String) defined in com.intellij.openapi.diagnostic.Attachment[JavaClassConstructorDescriptor]

'extractedFunction' @ [494:71] ==> value-parameter extractedFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory[ValueParameterDescriptorImpl]

'text' @ [494:89] ==> public final val KtNamedFunction.text: (String..String?)[MyPropertyDescriptor]

'exception' @ [496:25] ==> private final fun exception(msg: String): Nothing defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'state' @ [499:21] ==> val state: GenerationState defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory.<anonymous>[LocalVariableDescriptor]

'bindingTrace' @ [499:27] ==> public final val bindingTrace: BindingTrace defined in org.jetbrains.kotlin.codegen.state.GenerationState[DeserializedPropertyDescriptor]

'recordAnonymousType' @ [499:40] ==> private final fun BindingTrace.recordAnonymousType(typeReference: KtTypeReference, localVariableName: String, visitor: FrameVisitor): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'paramRef' @ [499:60] ==> val paramRef: KtTypeReference? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory.<anonymous>[LocalVariableDescriptor]

'param' @ [499:70] ==> val param: KotlinDebuggerCaches.Parameter defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory.<anonymous>[LocalVariableDescriptor]

'callText' @ [499:76] ==> public final val callText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinDebuggerCaches.Parameter[PropertyDescriptorImpl]

'frameVisitor' @ [499:86] ==> val frameVisitor: FrameVisitor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory.<anonymous>[LocalVariableDescriptor]

'compileCorrectFiles' @ [502:37] ==> public open fun compileCorrectFiles(@NotNull p0: GenerationState, @NotNull p1: CompilationErrorHandler): Unit defined in org.jetbrains.kotlin.codegen.KotlinCodegenFacade[JavaMethodDescriptor]

'state' @ [502:57] ==> val state: GenerationState defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory.<anonymous>[LocalVariableDescriptor]

'THROW_EXCEPTION' @ [502:88] ==> public final val THROW_EXCEPTION: (CompilationErrorHandler..CompilationErrorHandler?) defined in org.jetbrains.kotlin.codegen.CompilationErrorHandler[JavaPropertyDescriptor]

'state' @ [504:17] ==> val state: GenerationState defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.createClassFileFactory.<anonymous>[LocalVariableDescriptor]

'factory' @ [504:23] ==> public final val factory: ClassFileFactory defined in org.jetbrains.kotlin.codegen.state.GenerationState[DeserializedPropertyDescriptor]

'typeReference' @ [509:38] ==> value-parameter typeReference: KtTypeReference defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.recordAnonymousType[ValueParameterDescriptorImpl]

'debugTypeInfo' @ [509:52] ==> public var KtTypeReference.debugTypeInfo: KotlinType? defined in org.jetbrains.kotlin.psi.codeFragmentUtil[DeserializedPropertyDescriptor]

'paramAnonymousType' @ [510:17] ==> val paramAnonymousType: KotlinType? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.recordAnonymousType[LocalVariableDescriptor]

'paramAnonymousType' @ [511:45] ==> val paramAnonymousType: KotlinType? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.recordAnonymousType[LocalVariableDescriptor]

'constructor' @ [511:64] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'declarationDescriptor' @ [511:76] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'declarationDescriptor' @ [512:21] ==> val declarationDescriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.recordAnonymousType[LocalVariableDescriptor]

'visitor' @ [513:41] ==> value-parameter visitor: FrameVisitor defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.recordAnonymousType[ValueParameterDescriptorImpl]

'findValue' @ [513:49] ==> public final fun findValue(name: String, asmType: Type?, checkType: Boolean, failIfNotFound: Boolean): Value? defined in org.jetbrains.kotlin.idea.debugger.evaluate.FrameVisitor[SimpleFunctionDescriptorImpl]

'localVariableName' @ [513:59] ==> value-parameter localVariableName: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.recordAnonymousType[ValueParameterDescriptorImpl]

'exception' @ [514:44] ==> private final fun exception(msg: String): Nothing defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'paramAnonymousType' @ [514:143] ==> val paramAnonymousType: KotlinType? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.recordAnonymousType[LocalVariableDescriptor]

'record' @ [515:21] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(p0: (WritableSlice<(ClassDescriptor..ClassDescriptor?), (Type..Type?)>..WritableSlice<(ClassDescriptor..ClassDescriptor?), (Type..Type?)>?), p1: (ClassDescriptor..ClassDescriptor?), p2: (Type..Type?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> ClassDescriptor
    <V : (Any..Any?)> -> Type

'ASM_TYPE' @ [515:43] ==> public final val ASM_TYPE: (WritableSlice<(ClassDescriptor..ClassDescriptor?), (Type..Type?)>..WritableSlice<(ClassDescriptor..ClassDescriptor?), (Type..Type?)>?) defined in org.jetbrains.kotlin.codegen.binding.CodegenBinding[JavaPropertyDescriptor]

'declarationDescriptor' @ [515:53] ==> val declarationDescriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.recordAnonymousType[LocalVariableDescriptor]

'localVariable' @ [515:76] ==> val localVariable: Value defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.recordAnonymousType[LocalVariableDescriptor]

'asmType' @ [515:90] ==> public abstract val asmType: Type defined in org.jetbrains.eval4j.Value[DeserializedPropertyDescriptor]

'LOG' @ [516:25] ==> internal val LOG: Logger defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'isDebugEnabled' @ [516:29] ==> public final val Logger.isDebugEnabled: Boolean[MyPropertyDescriptor]

'LOG' @ [517:25] ==> internal val LOG: Logger defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'debug' @ [517:29] ==> public abstract fun debug(@NonNls p0: (String..String?)): Unit defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'localVariable' @ [517:47] ==> val localVariable: Value defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.recordAnonymousType[LocalVariableDescriptor]

'asmType' @ [517:61] ==> public abstract val asmType: Type defined in org.jetbrains.eval4j.Value[DeserializedPropertyDescriptor]

'className' @ [517:69] ==> public final val Type.className: (String..String?)[MyPropertyDescriptor]

'declarationDescriptor' @ [517:99] ==> val declarationDescriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.recordAnonymousType[LocalVariableDescriptor]

'name' @ [517:121] ==> public final val ClassDescriptor.name: Name[MyPropertyDescriptor]

'createEvaluateException' @ [523:83] ==> public open fun createEvaluateException(p0: (String..String?)): (EvaluateException..EvaluateException?) defined in com.intellij.debugger.engine.evaluation.EvaluateExceptionUtil[JavaMethodDescriptor]

'msg' @ [523:107] ==> value-parameter msg: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.exception[ValueParameterDescriptorImpl]

'createEvaluateException' @ [525:84] ==> public open fun createEvaluateException(p0: (Throwable..Throwable?)): (EvaluateException..EvaluateException?) defined in com.intellij.debugger.engine.evaluation.EvaluateExceptionUtil[JavaMethodDescriptor]

'e' @ [525:108] ==> value-parameter e: Throwable defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.exception[ValueParameterDescriptorImpl]

'runInReadActionWithWriteActionPriorityWithPCE' @ [529:20] ==> public fun <T : Any> runInReadActionWithWriteActionPriorityWithPCE(f: () -> KotlinEvaluator.Companion.ExtendedAnalysisResult): KotlinEvaluator.Companion.ExtendedAnalysisResult defined in org.jetbrains.kotlin.idea[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> ExtendedAnalysisResult

'checkForSyntacticErrors' @ [531:36] ==> public open fun checkForSyntacticErrors(@NotNull p0: PsiElement): Unit defined in org.jetbrains.kotlin.resolve.AnalyzingUtils[JavaMethodDescriptor]

'this' @ [531:60] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors[ReceiverParameterDescriptorImpl]

'createEvaluateException' @ [534:49] ==> public open fun createEvaluateException(p0: (String..String?)): (EvaluateException..EvaluateException?) defined in com.intellij.debugger.engine.evaluation.EvaluateExceptionUtil[JavaMethodDescriptor]

'e' @ [534:73] ==> val e: IllegalArgumentException /* = IllegalArgumentException */ defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors.<anonymous>[LocalVariableDescriptor]

'message' @ [534:75] ==> public open val message: String? defined in java.lang.IllegalArgumentException[DeserializedPropertyDescriptor]

'if (contextFile == null) listOf(this) else listOf(this, contextFile)' @ [537:38] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<KtFile>, elseBranch: List<KtFile>): List<KtFile>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<KtFile>

'contextFile' @ [537:42] ==> value-parameter contextFile: KtFile? = ... defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors[ValueParameterDescriptorImpl]

'listOf' @ [537:63] ==> public fun <T> listOf(element: KtFile): List<KtFile> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtFile

'this' @ [537:70] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors[ReceiverParameterDescriptorImpl]

'listOf' @ [537:81] ==> public fun <T> listOf(vararg elements: KtFile): List<KtFile> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtFile

'this' @ [537:88] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors[ReceiverParameterDescriptorImpl]

'contextFile' @ [537:94] ==> value-parameter contextFile: KtFile? = ... defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors[ValueParameterDescriptorImpl]

'KotlinCacheService' @ [538:40] ==> public companion object defined in org.jetbrains.kotlin.caches.resolve.KotlinCacheService[FakeCallableDescriptorForObject]

'getInstance' @ [538:59] ==> public final fun getInstance(project: Project): KotlinCacheService defined in org.jetbrains.kotlin.caches.resolve.KotlinCacheService.Companion[DeserializedSimpleFunctionDescriptor]

'project' @ [538:71] ==> public final val KtFile.project: Project[MyPropertyDescriptor]

'getResolutionFacade' @ [538:80] ==> public abstract fun getResolutionFacade(elements: List<KtElement>): ResolutionFacade defined in org.jetbrains.kotlin.caches.resolve.KotlinCacheService[DeserializedSimpleFunctionDescriptor]

'filesToAnalyze' @ [538:100] ==> val filesToAnalyze: List<KtFile> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors.<anonymous>[LocalVariableDescriptor]

'resolutionFacade' @ [539:38] ==> val resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors.<anonymous>[LocalVariableDescriptor]

'analyzeFullyAndGetResult' @ [539:55] ==> public abstract fun analyzeFullyAndGetResult(elements: Collection<KtElement>): AnalysisResult defined in org.jetbrains.kotlin.idea.resolve.ResolutionFacade[DeserializedSimpleFunctionDescriptor]

'filesToAnalyze' @ [539:80] ==> val filesToAnalyze: List<KtFile> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors.<anonymous>[LocalVariableDescriptor]

'analysisResult' @ [541:21] ==> val analysisResult: AnalysisResult defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors.<anonymous>[LocalVariableDescriptor]

'isError' @ [541:36] ==> public final fun isError(): Boolean defined in org.jetbrains.kotlin.analyzer.AnalysisResult[DeserializedSimpleFunctionDescriptor]

'exception' @ [542:21] ==> private final fun exception(e: Throwable): Nothing defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'analysisResult' @ [542:31] ==> val analysisResult: AnalysisResult defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors.<anonymous>[LocalVariableDescriptor]

'error' @ [542:46] ==> public final val error: Throwable defined in org.jetbrains.kotlin.analyzer.AnalysisResult[DeserializedPropertyDescriptor]

'analysisResult' @ [545:38] ==> val analysisResult: AnalysisResult defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors.<anonymous>[LocalVariableDescriptor]

'bindingContext' @ [545:53] ==> public final val bindingContext: BindingContext defined in org.jetbrains.kotlin.analyzer.AnalysisResult[DeserializedPropertyDescriptor]

'bindingContext' @ [546:17] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors.<anonymous>[LocalVariableDescriptor]

'diagnostics' @ [546:32] ==> public final val BindingContext.diagnostics: Diagnostics[MyPropertyDescriptor]

'firstOrNull' @ [546:44] ==> public inline fun <T> Iterable<Diagnostic>.firstOrNull(predicate: (Diagnostic) -> Boolean): Diagnostic? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Diagnostic

'it' @ [546:58] ==> value-parameter it: Diagnostic defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'severity' @ [546:61] ==> public final val Diagnostic.severity: Severity[MyPropertyDescriptor]

'ERROR' @ [546:82] ==> enum entry ERROR defined in org.jetbrains.kotlin.diagnostics.Severity[FakeCallableDescriptorForObject]

'let' @ [546:91] ==> @InlineOnly public inline fun <T, R> Diagnostic.let(block: (Diagnostic) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Diagnostic
    <R> -> Unit

'it' @ [547:25] ==> value-parameter it: Diagnostic defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'psiElement' @ [547:28] ==> public final val Diagnostic.psiElement: PsiElement[MyPropertyDescriptor]

'containingFile' @ [547:39] ==> public final val PsiElement.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'this' @ [547:57] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors[ReceiverParameterDescriptorImpl]

'exception' @ [548:25] ==> private final fun exception(msg: String): Nothing defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion[SimpleFunctionDescriptorImpl]

'render' @ [548:56] ==> @NotNull public open fun render(@NotNull p0: Diagnostic): String defined in org.jetbrains.kotlin.diagnostics.rendering.DefaultErrorMessages[JavaMethodDescriptor]

'it' @ [548:63] ==> value-parameter it: Diagnostic defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'if (analyzeInlineFunctions) {
                    val (newBindingContext, files) = DebuggerUtils.analyzeInlinedFunctions(resolutionFacade, this, false)
                    ExtendedAnalysisResult(newBindingContext, analysisResult.moduleDescriptor, files)
                }
                else {
                    ExtendedAnalysisResult(bindingContext, analysisResult.moduleDescriptor, Collections.singletonList(this))
                }' @ [552:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinEvaluator.Companion.ExtendedAnalysisResult, elseBranch: KotlinEvaluator.Companion.ExtendedAnalysisResult): KotlinEvaluator.Companion.ExtendedAnalysisResult[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> ExtendedAnalysisResult

'analyzeInlineFunctions' @ [552:21] ==> value-parameter analyzeInlineFunctions: Boolean = ... defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors[ValueParameterDescriptorImpl]

'component1' @ [553:26] ==> public final operator fun component1(): BindingContext defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [553:45] ==> public final operator fun component2(): List<KtFile> defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'DebuggerUtils' @ [553:54] ==> public object DebuggerUtils defined in org.jetbrains.kotlin.idea.debugger in file DebuggerUtils.kt[FakeCallableDescriptorForObject]

'analyzeInlinedFunctions' @ [553:68] ==> public final fun analyzeInlinedFunctions(resolutionFacadeForFile: ResolutionFacade, file: KtFile, analyzeOnlyReifiedInlineFunctions: Boolean, bindingContext: BindingContext? = ...): Pair<BindingContext, List<KtFile>> defined in org.jetbrains.kotlin.idea.debugger.DebuggerUtils[SimpleFunctionDescriptorImpl]

'resolutionFacade' @ [553:92] ==> val resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors.<anonymous>[LocalVariableDescriptor]

'this' @ [553:110] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors[ReceiverParameterDescriptorImpl]

'ExtendedAnalysisResult' @ [554:21] ==> public constructor ExtendedAnalysisResult(bindingContext: BindingContext, moduleDescriptor: ModuleDescriptor, files: List<KtFile>) defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.ExtendedAnalysisResult[ClassConstructorDescriptorImpl]

'newBindingContext' @ [554:44] ==> val newBindingContext: BindingContext defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors.<anonymous>[LocalVariableDescriptor]

'analysisResult' @ [554:63] ==> val analysisResult: AnalysisResult defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors.<anonymous>[LocalVariableDescriptor]

'moduleDescriptor' @ [554:78] ==> public final val moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.analyzer.AnalysisResult[DeserializedPropertyDescriptor]

'files' @ [554:96] ==> val files: List<KtFile> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors.<anonymous>[LocalVariableDescriptor]

'ExtendedAnalysisResult' @ [557:21] ==> public constructor ExtendedAnalysisResult(bindingContext: BindingContext, moduleDescriptor: ModuleDescriptor, files: List<KtFile>) defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.ExtendedAnalysisResult[ClassConstructorDescriptorImpl]

'bindingContext' @ [557:44] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors.<anonymous>[LocalVariableDescriptor]

'analysisResult' @ [557:60] ==> val analysisResult: AnalysisResult defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors.<anonymous>[LocalVariableDescriptor]

'moduleDescriptor' @ [557:75] ==> public final val moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.analyzer.AnalysisResult[DeserializedPropertyDescriptor]

'singletonList' @ [557:105] ==> public open fun <T : (Any..Any?)> singletonList(p0: (KtFile..KtFile?)): (MutableList<(KtFile..KtFile?)>..List<(KtFile..KtFile?)>?) defined in java.util.Collections[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> KtFile

'this' @ [557:119] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinEvaluator.Companion.checkForErrors[ReceiverParameterDescriptorImpl]

'codeFragment' @ [577:33] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[ValueParameterDescriptorImpl]

'getContextContainingFile' @ [577:46] ==> public final fun getContextContainingFile(): KtFile? defined in org.jetbrains.kotlin.psi.KtCodeFragment[DeserializedSimpleFunctionDescriptor]

'containingContextFile' @ [578:34] ==> val containingContextFile: KtFile? defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[LocalVariableDescriptor]

'importList' @ [578:57] ==> public final val KtFile.importList: KtImportList?[MyPropertyDescriptor]

'let' @ [578:69] ==> @InlineOnly public inline fun <T, R> KtImportList.let(block: (KtImportList) -> String): String defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtImportList
    <R> -> String

'it' @ [578:75] ==> value-parameter it: KtImportList defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger.<anonymous>[ValueParameterDescriptorImpl]

'text' @ [578:78] ==> public final val KtImportList.text: (String..String?)[MyPropertyDescriptor]

'template' @ [580:20] ==> private val template: String defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'replace' @ [580:29] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'importsFromContextFile' @ [582:13] ==> val importsFromContextFile: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[LocalVariableDescriptor]

'codeFragment' @ [582:38] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[ValueParameterDescriptorImpl]

'importsToString' @ [582:51] ==> public open fun importsToString(): String defined in org.jetbrains.kotlin.psi.KtCodeFragment[DeserializedSimpleFunctionDescriptor]

'split' @ [582:69] ==> public fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = ..., limit: Int = ...): List<String> defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'KtCodeFragment' @ [582:75] ==> public companion object defined in org.jetbrains.kotlin.psi.KtCodeFragment[FakeCallableDescriptorForObject]

'IMPORT_SEPARATOR' @ [582:90] ==> public final val IMPORT_SEPARATOR: String defined in org.jetbrains.kotlin.psi.KtCodeFragment.Companion[DeserializedPropertyDescriptor]

'joinToString' @ [582:108] ==> public fun <T> Iterable<String>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((String) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'containingContextFile' @ [585:34] ==> val containingContextFile: KtFile? defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[LocalVariableDescriptor]

'packageFqName' @ [585:57] ==> public final val KtFile.packageFqName: FqName[MyPropertyDescriptor]

'let' @ [585:72] ==> @InlineOnly public inline fun <T, R> FqName.let(block: (FqName) -> String): String defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FqName
    <R> -> String

'if (!it.isRoot) "package ${it.quoteSegmentsIfNeeded()}" else ""' @ [586:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'!' @ [586:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'it' @ [586:14] ==> value-parameter it: FqName defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger.<anonymous>[ValueParameterDescriptorImpl]

'isRoot' @ [586:17] ==> public final val FqName.isRoot: Boolean[MyPropertyDescriptor]

'it' @ [586:36] ==> value-parameter it: FqName defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger.<anonymous>[ValueParameterDescriptorImpl]

'quoteSegmentsIfNeeded' @ [586:39] ==> public fun FqName.quoteSegmentsIfNeeded(): String defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]

'fileText' @ [588:5] ==> var fileText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[LocalVariableDescriptor]

'fileText' @ [588:16] ==> var fileText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[LocalVariableDescriptor]

'replace' @ [588:25] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'packageFromContextFile' @ [588:46] ==> val packageFromContextFile: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[LocalVariableDescriptor]

'extractedFunction' @ [590:33] ==> value-parameter extractedFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[ValueParameterDescriptorImpl]

'text' @ [590:51] ==> public final val KtNamedFunction.text: (String..String?)[MyPropertyDescriptor]

'assert' @ [591:5] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'extractedFunctionText' @ [591:12] ==> val extractedFunctionText: (String..String?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[LocalVariableDescriptor]

'fileText' @ [592:5] ==> var fileText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[LocalVariableDescriptor]

'fileText' @ [592:16] ==> var fileText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[LocalVariableDescriptor]

'replace' @ [592:25] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'extractedFunction' @ [592:47] ==> value-parameter extractedFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[ValueParameterDescriptorImpl]

'text' @ [592:65] ==> public final val KtNamedFunction.text: (String..String?)[MyPropertyDescriptor]

'codeFragment' @ [594:19] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[ValueParameterDescriptorImpl]

'createKtFile' @ [594:32] ==> private fun PsiElement.createKtFile(fileName: String, fileText: String): KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[SimpleFunctionDescriptorImpl]

'fileText' @ [594:61] ==> var fileText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[LocalVariableDescriptor]

'jetFile' @ [595:5] ==> val jetFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[LocalVariableDescriptor]

'suppressDiagnosticsInDebugMode' @ [595:13] ==> public var KtFile.suppressDiagnosticsInDebugMode: Boolean defined in org.jetbrains.kotlin.psi.codeFragmentUtil[DeserializedPropertyDescriptor]

'jetFile' @ [597:16] ==> val jetFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[LocalVariableDescriptor]

'declarations' @ [597:24] ==> public final val KtFile.declarations: List<(KtDeclaration..KtDeclaration?)>[MyPropertyDescriptor]

'list' @ [598:20] ==> val list: List<(KtDeclaration..KtDeclaration?)> defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[LocalVariableDescriptor]

'function' @ [600:5] ==> val function: KtNamedFunction defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[LocalVariableDescriptor]

'receiverTypeReference' @ [600:14] ==> public final val KtNamedFunction.receiverTypeReference: KtTypeReference?[MyPropertyDescriptor]

'debugTypeInfo' @ [600:37] ==> public var KtTypeReference.debugTypeInfo: KotlinType? defined in org.jetbrains.kotlin.psi.codeFragmentUtil[DeserializedPropertyDescriptor]

'extractedFunction' @ [600:53] ==> value-parameter extractedFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[ValueParameterDescriptorImpl]

'receiverTypeReference' @ [600:71] ==> public final val KtNamedFunction.receiverTypeReference: KtTypeReference?[MyPropertyDescriptor]

'debugTypeInfo' @ [600:94] ==> public var KtTypeReference.debugTypeInfo: KotlinType? defined in org.jetbrains.kotlin.psi.codeFragmentUtil[DeserializedPropertyDescriptor]

'component1' @ [602:11] ==> public final operator fun component1(): (KtParameter..KtParameter?) defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [602:21] ==> public final operator fun component2(): (KtParameter..KtParameter?) defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'function' @ [602:34] ==> val function: KtNamedFunction defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[LocalVariableDescriptor]

'valueParameters' @ [602:43] ==> public final val KtNamedFunction.valueParameters: (MutableList<(KtParameter..KtParameter?)>..List<(KtParameter..KtParameter?)>)[MyPropertyDescriptor]

'zip' @ [602:59] ==> public infix fun <T, R> Iterable<(KtParameter..KtParameter?)>.zip(other: Iterable<(KtParameter..KtParameter?)>): List<Pair<(KtParameter..KtParameter?), (KtParameter..KtParameter?)>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtParameter..org.jetbrains.kotlin.psi.KtParameter?)
    <R> -> (org.jetbrains.kotlin.psi.KtParameter..org.jetbrains.kotlin.psi.KtParameter?)

'extractedFunction' @ [602:63] ==> value-parameter extractedFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[ValueParameterDescriptorImpl]

'valueParameters' @ [602:81] ==> public final val KtNamedFunction.valueParameters: (MutableList<(KtParameter..KtParameter?)>..List<(KtParameter..KtParameter?)>)[MyPropertyDescriptor]

'newParam' @ [603:9] ==> val newParam: (KtParameter..KtParameter?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[LocalVariableDescriptor]

'typeReference' @ [603:18] ==> public final var KtParameter.typeReference: KtTypeReference?[MyPropertyDescriptor]

'debugTypeInfo' @ [603:33] ==> public var KtTypeReference.debugTypeInfo: KotlinType? defined in org.jetbrains.kotlin.psi.codeFragmentUtil[DeserializedPropertyDescriptor]

'oldParam' @ [603:49] ==> val oldParam: (KtParameter..KtParameter?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[LocalVariableDescriptor]

'typeReference' @ [603:58] ==> public final var KtParameter.typeReference: KtTypeReference?[MyPropertyDescriptor]

'debugTypeInfo' @ [603:73] ==> public var KtTypeReference.debugTypeInfo: KotlinType? defined in org.jetbrains.kotlin.psi.codeFragmentUtil[DeserializedPropertyDescriptor]

'function' @ [606:5] ==> val function: KtNamedFunction defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[LocalVariableDescriptor]

'typeReference' @ [606:14] ==> public final var KtNamedFunction.typeReference: KtTypeReference?[MyPropertyDescriptor]

'debugTypeInfo' @ [606:29] ==> public var KtTypeReference.debugTypeInfo: KotlinType? defined in org.jetbrains.kotlin.psi.codeFragmentUtil[DeserializedPropertyDescriptor]

'extractedFunction' @ [606:45] ==> value-parameter extractedFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[ValueParameterDescriptorImpl]

'typeReference' @ [606:63] ==> public final var KtNamedFunction.typeReference: KtTypeReference?[MyPropertyDescriptor]

'debugTypeInfo' @ [606:78] ==> public var KtTypeReference.debugTypeInfo: KotlinType? defined in org.jetbrains.kotlin.psi.codeFragmentUtil[DeserializedPropertyDescriptor]

'jetFile' @ [608:12] ==> val jetFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.createFileForDebugger[LocalVariableDescriptor]

'LightVirtualFile' @ [613:23] ==> public constructor LightVirtualFile(@NotNull p0: String, p1: (Language..Language?), @NotNull p2: CharSequence) defined in com.intellij.testFramework.LightVirtualFile[JavaClassConstructorDescriptor]

'fileName' @ [613:40] ==> value-parameter fileName: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.createKtFile[ValueParameterDescriptorImpl]

'INSTANCE' @ [613:65] ==> @NotNull public final val INSTANCE: KotlinLanguage defined in org.jetbrains.kotlin.idea.KotlinLanguage[JavaPropertyDescriptor]

'fileText' @ [613:75] ==> value-parameter fileText: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.createKtFile[ValueParameterDescriptorImpl]

'virtualFile' @ [614:5] ==> val virtualFile: LightVirtualFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.createKtFile[LocalVariableDescriptor]

'charset' @ [614:17] ==> public final var LightVirtualFile.charset: Charset[MyPropertyDescriptor]

'UTF8_CHARSET' @ [614:42] ==> public final val UTF8_CHARSET: (Charset..Charset?) defined in com.intellij.openapi.vfs.CharsetToolkit[JavaPropertyDescriptor]

'getInstance' @ [615:35] ==> public open fun getInstance(p0: (Project..Project?)): (PsiFileFactory..PsiFileFactory?) defined in com.intellij.psi.PsiFileFactory[JavaMethodDescriptor]

'project' @ [615:47] ==> public final val PsiElement.project: Project[MyPropertyDescriptor]

'trySetupPsiForFile' @ [616:14] ==> @Nullable public open fun trySetupPsiForFile(@NotNull p0: LightVirtualFile, @NotNull p1: Language, p2: Boolean, p3: Boolean): PsiFile? defined in com.intellij.psi.impl.PsiFileFactoryImpl[JavaMethodDescriptor]

'virtualFile' @ [616:33] ==> val virtualFile: LightVirtualFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.createKtFile[LocalVariableDescriptor]

'INSTANCE' @ [616:61] ==> @NotNull public final val INSTANCE: KotlinLanguage defined in org.jetbrains.kotlin.idea.KotlinLanguage[JavaPropertyDescriptor]

'jetFile' @ [617:5] ==> val jetFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.createKtFile[LocalVariableDescriptor]

'analysisContext' @ [617:13] ==> public var KtFile.analysisContext: PsiElement? defined in org.jetbrains.kotlin.psi[DeserializedPropertyDescriptor]

'this' @ [617:31] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.createKtFile[ReceiverParameterDescriptorImpl]

'jetFile' @ [618:12] ==> val jetFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.createKtFile[LocalVariableDescriptor]

'if (suspendPolicy == EventRequest.SUSPEND_EVENT_THREAD) ObjectReference.INVOKE_SINGLE_THREADED else 0' @ [622:12] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Int, elseBranch: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Int

'suspendPolicy' @ [622:16] ==> public final val SuspendContext.suspendPolicy: Int[MyPropertyDescriptor]

'SUSPEND_EVENT_THREAD' @ [622:46] ==> public const final val SUSPEND_EVENT_THREAD: Int defined in com.sun.jdi.request.EventRequest[JavaPropertyDescriptor]

'INVOKE_SINGLE_THREADED' @ [622:84] ==> public const final val INVOKE_SINGLE_THREADED: Int defined in com.sun.jdi.ObjectReference[JavaPropertyDescriptor]

'isPrimitive' @ [626:17] ==> public open fun isPrimitive(p0: (Type..Type?)): Boolean defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaMethodDescriptor]

'this' @ [626:29] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.getClassDescriptor[ReceiverParameterDescriptorImpl]

'byInternalName' @ [628:32] ==> @NotNull public open fun byInternalName(@NotNull p0: String): JvmClassName defined in org.jetbrains.kotlin.resolve.jvm.JvmClassName[JavaMethodDescriptor]

'internalName' @ [628:47] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'fqNameForClassNameWithoutDollars' @ [628:61] ==> public final val JvmClassName.fqNameForClassNameWithoutDollars: FqName[MyPropertyDescriptor]

'JavaToKotlinClassMap' @ [631:5] ==> public object JavaToKotlinClassMap : PlatformToKotlinClassMap defined in org.jetbrains.kotlin.platform[FakeCallableDescriptorForObject]

'mapJavaToKotlin' @ [631:26] ==> public final fun mapJavaToKotlin(fqName: FqName): ClassId? defined in org.jetbrains.kotlin.platform.JavaToKotlinClassMap[DeserializedSimpleFunctionDescriptor]

'jvmName' @ [631:42] ==> val jvmName: FqName defined in org.jetbrains.kotlin.idea.debugger.evaluate.getClassDescriptor[LocalVariableDescriptor]

'let' @ [631:52] ==> @InlineOnly public inline fun <T, R> ClassId.let(block: (ClassId) -> ClassDescriptor?): ClassDescriptor? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ClassId
    <R> -> ClassDescriptor?

'DefaultBuiltIns' @ [632:13] ==> public companion object defined in org.jetbrains.kotlin.builtins.DefaultBuiltIns[FakeCallableDescriptorForObject]

'Instance' @ [632:29] ==> @JvmStatic public final val Instance: DefaultBuiltIns defined in org.jetbrains.kotlin.builtins.DefaultBuiltIns.Companion[DeserializedPropertyDescriptor]

'builtInsModule' @ [632:38] ==> public final var DefaultBuiltIns.builtInsModule: ModuleDescriptorImpl[MyPropertyDescriptor]

'let' @ [633:8] ==> @InlineOnly public inline fun <T, R> ClassDescriptor.let(block: (ClassDescriptor) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ClassDescriptor
    <R> -> Nothing

'it' @ [633:21] ==> value-parameter it: ClassDescriptor defined in org.jetbrains.kotlin.idea.debugger.evaluate.getClassDescriptor.<anonymous>[ValueParameterDescriptorImpl]

'runReadAction' @ [635:12] ==> public fun <T> runReadAction(action: () -> ClassDescriptor?): ClassDescriptor? defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ClassDescriptor?

'getInstance' @ [636:37] ==> public open fun getInstance(p0: (Project..Project?)): (JavaPsiFacade..JavaPsiFacade?) defined in com.intellij.psi.JavaPsiFacade[JavaMethodDescriptor]

'scope' @ [636:49] ==> value-parameter scope: GlobalSearchScope defined in org.jetbrains.kotlin.idea.debugger.evaluate.getClassDescriptor[ValueParameterDescriptorImpl]

'project' @ [636:55] ==> public final val GlobalSearchScope.project: Project?[MyPropertyDescriptor]

'findClasses' @ [636:64] ==> @NotNull public abstract fun findClasses(@NonNls @NotNull p0: String, @NotNull p1: GlobalSearchScope): (Array<(PsiClass..PsiClass?)>..Array<out (PsiClass..PsiClass?)>) defined in com.intellij.psi.JavaPsiFacade[JavaMethodDescriptor]

'jvmName' @ [636:76] ==> val jvmName: FqName defined in org.jetbrains.kotlin.idea.debugger.evaluate.getClassDescriptor[LocalVariableDescriptor]

'asString' @ [636:84] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'scope' @ [636:96] ==> value-parameter scope: GlobalSearchScope defined in org.jetbrains.kotlin.idea.debugger.evaluate.getClassDescriptor[ValueParameterDescriptorImpl]

'if (classes.isEmpty()) null
        else {
            classes.first().getJavaClassDescriptor()
        }' @ [637:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: ClassDescriptor?, elseBranch: ClassDescriptor?): ClassDescriptor?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> ClassDescriptor?

'classes' @ [637:13] ==> val classes: (Array<(PsiClass..PsiClass?)>..Array<out (PsiClass..PsiClass?)>) defined in org.jetbrains.kotlin.idea.debugger.evaluate.getClassDescriptor.<anonymous>[LocalVariableDescriptor]

'isEmpty' @ [637:21] ==> @InlineOnly public inline fun <T> Array<out (PsiClass..PsiClass?)>.isEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiClass..com.intellij.psi.PsiClass?)

'classes' @ [639:13] ==> val classes: (Array<(PsiClass..PsiClass?)>..Array<out (PsiClass..PsiClass?)>) defined in org.jetbrains.kotlin.idea.debugger.evaluate.getClassDescriptor.<anonymous>[LocalVariableDescriptor]

'first' @ [639:21] ==> public fun <T> Array<out (PsiClass..PsiClass?)>.first(): (PsiClass..PsiClass?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiClass..com.intellij.psi.PsiClass?)

'getJavaClassDescriptor' @ [639:29] ==> @JvmOverloads public fun PsiClass.getJavaClassDescriptor(resolutionFacade: ResolutionFacade? = ...): ClassDescriptor? defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

