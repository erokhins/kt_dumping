'SelfTargetingRangeIntention<KtDotQualifiedExpression>' @ [36:34] ==> public constructor SelfTargetingRangeIntention<TElement : PsiElement>(elementType: Class<KtDotQualifiedExpression>, text: String, familyName: String = ...) defined in org.jetbrains.kotlin.idea.intentions.SelfTargetingRangeIntention[DeserializedClassConstructorDescriptor]
Inferred types:
    <TElement : PsiElement> -> KtDotQualifiedExpression

'KtDotQualifiedExpression' @ [36:88] ==> public companion object defined in org.jetbrains.kotlin.psi.KtDotQualifiedExpression[FakeCallableDescriptorForObject]

'java' @ [36:120] ==> public val <T> KClass<KtDotQualifiedExpression>.java: Class<KtDotQualifiedExpression> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtDotQualifiedExpression

'element' @ [38:13] ==> value-parameter element: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applicabilityRange[ValueParameterDescriptorImpl]

'calleeName' @ [38:21] ==> public val KtQualifiedExpression.calleeName: String? defined in org.jetbrains.kotlin.idea.intentions in file Utils.kt[PropertyDescriptorImpl]

'OperatorNameConventions' @ [38:35] ==> public object OperatorNameConventions defined in org.jetbrains.kotlin.util[FakeCallableDescriptorForObject]

'CONTAINS' @ [38:59] ==> @field:JvmField public final val CONTAINS: Name defined in org.jetbrains.kotlin.util.OperatorNameConventions[DeserializedPropertyDescriptor]

'asString' @ [38:68] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'element' @ [40:28] ==> value-parameter element: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applicabilityRange[ValueParameterDescriptorImpl]

'toResolvedCall' @ [40:36] ==> public fun KtQualifiedExpression.toResolvedCall(bodyResolveMode: BodyResolveMode): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.idea.intentions[SimpleFunctionDescriptorImpl]

'PARTIAL' @ [40:67] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'!' @ [41:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'resolvedCall' @ [41:14] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applicabilityRange[LocalVariableDescriptor]

'isReallySuccess' @ [41:27] ==> public fun ResolvedCall<*>.isReallySuccess(): Boolean defined in org.jetbrains.kotlin.resolve.calls.model[DeserializedSimpleFunctionDescriptor]

'resolvedCall' @ [42:24] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applicabilityRange[LocalVariableDescriptor]

'call' @ [42:37] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'valueArguments' @ [42:42] ==> public final val Call.valueArguments: List<(ValueArgument..ValueArgument?)>[MyPropertyDescriptor]

'singleOrNull' @ [42:57] ==> public fun <T> List<(ValueArgument..ValueArgument?)>.singleOrNull(): ValueArgument? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)

'!=' @ [43:13] ==> public open fun equals(other: Any?): Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'resolvedCall' @ [43:14] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applicabilityRange[LocalVariableDescriptor]

'getArgumentMapping' @ [43:27] ==> @NotNull public abstract fun getArgumentMapping(@NotNull p0: ValueArgument): ArgumentMapping defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCall[JavaMethodDescriptor]

'argument' @ [43:46] ==> val argument: ValueArgument defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applicabilityRange[LocalVariableDescriptor]

'valueParameter' @ [43:74] ==> public abstract val valueParameter: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.model.ArgumentMatch[DeserializedPropertyDescriptor]

'index' @ [43:89] ==> public abstract val index: Int defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'resolvedCall' @ [45:22] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applicabilityRange[LocalVariableDescriptor]

'resultingDescriptor' @ [45:35] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.resultingDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'target' @ [46:26] ==> val target: CallableDescriptor defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applicabilityRange[LocalVariableDescriptor]

'returnType' @ [46:33] ==> public final val CallableDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'!' @ [47:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'target' @ [47:14] ==> val target: CallableDescriptor defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applicabilityRange[LocalVariableDescriptor]

'builtIns' @ [47:21] ==> public val DeclarationDescriptor.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'isBooleanOrSubtype' @ [47:30] ==> public open fun isBooleanOrSubtype(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'returnType' @ [47:49] ==> val returnType: KotlinType defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applicabilityRange[LocalVariableDescriptor]

'!' @ [49:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'element' @ [49:14] ==> value-parameter element: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applicabilityRange[ValueParameterDescriptorImpl]

'isReceiverExpressionWithValue' @ [49:22] ==> public fun KtQualifiedExpression.isReceiverExpressionWithValue(): Boolean defined in org.jetbrains.kotlin.idea.intentions in file Utils.kt[SimpleFunctionDescriptorImpl]

'getFunctionDescriptor' @ [51:34] ==> private final fun getFunctionDescriptor(element: KtDotQualifiedExpression): FunctionDescriptor? defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention[SimpleFunctionDescriptorImpl]

'element' @ [51:56] ==> value-parameter element: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applicabilityRange[ValueParameterDescriptorImpl]

'!' @ [53:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'functionDescriptor' @ [53:14] ==> val functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applicabilityRange[LocalVariableDescriptor]

'isOperatorOrCompatible' @ [53:33] ==> private final val FunctionDescriptor.isOperatorOrCompatible: Boolean defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention[PropertyDescriptorImpl]

'element' @ [55:16] ==> value-parameter element: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applicabilityRange[ValueParameterDescriptorImpl]

'callExpression' @ [55:24] ==> public val KtQualifiedExpression.callExpression: KtCallExpression? defined in org.jetbrains.kotlin.idea.intentions in file Utils.kt[PropertyDescriptorImpl]

'calleeExpression' @ [55:41] ==> public final val KtCallExpression.calleeExpression: KtExpression?[MyPropertyDescriptor]

'textRange' @ [55:60] ==> public final val KtExpression.textRange: (TextRange..TextRange?)[MyPropertyDescriptor]

'this' @ [60:17] ==> <this> defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.isOperatorOrCompatible[ReceiverParameterDescriptorImpl]

'OperatorChecks' @ [61:24] ==> public object OperatorChecks : AbstractModifierChecks defined in org.jetbrains.kotlin.util[FakeCallableDescriptorForObject]

'check' @ [61:39] ==> public final fun check(functionDescriptor: FunctionDescriptor): CheckResult defined in org.jetbrains.kotlin.util.OperatorChecks[DeserializedSimpleFunctionDescriptor]

'this' @ [61:45] ==> <this> defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.isOperatorOrCompatible[ReceiverParameterDescriptorImpl]

'isSuccess' @ [61:51] ==> public final val isSuccess: Boolean defined in org.jetbrains.kotlin.util.CheckResult[DeserializedPropertyDescriptor]

'isOperator' @ [63:20] ==> public final val FunctionDescriptor.isOperator: Boolean[MyPropertyDescriptor]

'element' @ [67:24] ==> value-parameter element: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applyTo[ValueParameterDescriptorImpl]

'callExpression' @ [67:32] ==> public val KtQualifiedExpression.callExpression: KtCallExpression? defined in org.jetbrains.kotlin.idea.intentions in file Utils.kt[PropertyDescriptorImpl]

'valueArguments' @ [67:49] ==> public final val KtCallExpression.valueArguments: (MutableList<(KtValueArgument..KtValueArgument?)>..List<(KtValueArgument..KtValueArgument?)>)[MyPropertyDescriptor]

'single' @ [67:64] ==> public fun <T> List<(KtValueArgument..KtValueArgument?)>.single(): (KtValueArgument..KtValueArgument?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtValueArgument..org.jetbrains.kotlin.psi.KtValueArgument?)

'getArgumentExpression' @ [67:73] ==> @IfNotParsed @Nullable public open fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.KtValueArgument[JavaMethodDescriptor]

'element' @ [68:24] ==> value-parameter element: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applyTo[ValueParameterDescriptorImpl]

'receiverExpression' @ [68:32] ==> public open val receiverExpression: KtExpression defined in org.jetbrains.kotlin.psi.KtDotQualifiedExpression[DeserializedPropertyDescriptor]

'KtPsiFactory' @ [70:26] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'element' @ [70:39] ==> value-parameter element: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applyTo[ValueParameterDescriptorImpl]

'element' @ [72:32] ==> value-parameter element: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applyTo[ValueParameterDescriptorImpl]

'parent' @ [72:40] ==> public final val KtDotQualifiedExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'if (prefixExpression != null && prefixExpression.operationToken == KtTokens.EXCL) {
            prefixExpression.replace(psiFactory.createExpressionByPattern("$0 !in $1", argument, receiver))
        }
        else {
            element.replace(psiFactory.createExpressionByPattern("$0 in $1", argument, receiver))
        }' @ [73:26] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: PsiElement, elseBranch: PsiElement): PsiElement[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> PsiElement

'prefixExpression' @ [73:30] ==> val prefixExpression: KtPrefixExpression? defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applyTo[LocalVariableDescriptor]

'prefixExpression' @ [73:58] ==> val prefixExpression: KtPrefixExpression? defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applyTo[LocalVariableDescriptor]

'operationToken' @ [73:75] ==> public final val KtPrefixExpression.operationToken: (IElementType..IElementType?)[MyPropertyDescriptor]

'EXCL' @ [73:102] ==> public final val EXCL: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'prefixExpression' @ [74:13] ==> val prefixExpression: KtPrefixExpression? defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applyTo[LocalVariableDescriptor]

'replace' @ [74:30] ==> public open fun replace(newElement: PsiElement): PsiElement defined in org.jetbrains.kotlin.psi.KtPrefixExpression[DeserializedSimpleFunctionDescriptor]

'psiFactory' @ [74:38] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applyTo[LocalVariableDescriptor]

'createExpressionByPattern' @ [74:49] ==> public fun KtPsiFactory.createExpressionByPattern(pattern: String, vararg args: Any, reformat: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'argument' @ [74:88] ==> val argument: KtExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applyTo[LocalVariableDescriptor]

'receiver' @ [74:98] ==> val receiver: KtExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applyTo[LocalVariableDescriptor]

'element' @ [77:13] ==> value-parameter element: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applyTo[ValueParameterDescriptorImpl]

'replace' @ [77:21] ==> @NotNull public open fun replace(@NotNull p0: PsiElement): PsiElement defined in org.jetbrains.kotlin.psi.KtDotQualifiedExpression[JavaMethodDescriptor]

'psiFactory' @ [77:29] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applyTo[LocalVariableDescriptor]

'createExpressionByPattern' @ [77:40] ==> public fun KtPsiFactory.createExpressionByPattern(pattern: String, vararg args: Any, reformat: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'argument' @ [77:78] ==> val argument: KtExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applyTo[LocalVariableDescriptor]

'receiver' @ [77:88] ==> val receiver: KtExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applyTo[LocalVariableDescriptor]

'argument' @ [81:13] ==> val argument: KtExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applyTo[LocalVariableDescriptor]

'skipSiblingsBackwardByPredicate' @ [82:45] ==> @Nullable public final fun skipSiblingsBackwardByPredicate(@Nullable p0: PsiElement?, p1: (((PsiElement..PsiElement?)) -> Boolean..(((PsiElement..PsiElement?)) -> Boolean)?)): PsiElement? defined in org.jetbrains.kotlin.psi.KtPsiUtil[SamAdapterFunctionDescriptor]

'expression' @ [82:77] ==> val expression: PsiElement defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applyTo[LocalVariableDescriptor]

'it' @ [83:17] ==> value-parameter it: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applyTo.<anonymous>[ValueParameterDescriptorImpl]

'node' @ [83:22] ==> public final val PsiElement.node: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'elementType' @ [83:27] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'WHITE_SPACE_OR_COMMENT_BIT_SET' @ [83:51] ==> public final val WHITE_SPACE_OR_COMMENT_BIT_SET: (TokenSet..TokenSet?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'previousElement' @ [85:17] ==> val previousElement: PsiElement? defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applyTo[LocalVariableDescriptor]

'previousElement' @ [85:44] ==> val previousElement: PsiElement? defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applyTo[LocalVariableDescriptor]

'previousElement' @ [86:17] ==> val previousElement: PsiElement? defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applyTo[LocalVariableDescriptor]

'parent' @ [86:33] ==> public final val KtExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'addAfter' @ [86:40] ==> public abstract fun addAfter(@NotNull p0: PsiElement, @Nullable p1: PsiElement?): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'psiFactory' @ [86:49] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applyTo[LocalVariableDescriptor]

'createSemicolon' @ [86:60] ==> public final fun createSemicolon(): PsiElement defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'previousElement' @ [86:79] ==> val previousElement: PsiElement? defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.applyTo[LocalVariableDescriptor]

'element' @ [92:30] ==> value-parameter element: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.getFunctionDescriptor[ValueParameterDescriptorImpl]

'analyze' @ [92:38] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'PARTIAL' @ [92:62] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'element' @ [93:28] ==> value-parameter element: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.getFunctionDescriptor[ValueParameterDescriptorImpl]

'getResolvedCall' @ [93:36] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [93:52] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.getFunctionDescriptor[LocalVariableDescriptor]

'resolvedCall' @ [94:16] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceContainsIntention.getFunctionDescriptor[LocalVariableDescriptor]

'resultingDescriptor' @ [94:29] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.resultingDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

