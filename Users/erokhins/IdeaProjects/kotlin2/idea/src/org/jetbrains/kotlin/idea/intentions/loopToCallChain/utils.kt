'KtPsiFactory' @ [48:22] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'expression' @ [48:35] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[ValueParameterDescriptorImpl]

'psiFactory' @ [50:28] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[LocalVariableDescriptor]

'createExpressionByPattern' @ [50:39] ==> public fun KtPsiFactory.createExpressionByPattern(pattern: String, vararg args: Any, reformat: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'inputVariable' @ [50:81] ==> value-parameter inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[ValueParameterDescriptorImpl]

'nameAsSafeName' @ [50:95] ==> public final val KtCallableDeclaration.nameAsSafeName: Name[MyPropertyDescriptor]

'expression' @ [50:111] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[ValueParameterDescriptorImpl]

'expression' @ [52:26] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[ValueParameterDescriptorImpl]

'anyDescendantOfType' @ [52:37] ==> public inline fun <reified T : PsiElement> PsiElement.anyDescendantOfType(noinline predicate: (KtNameReferenceExpression) -> Boolean = ...): Boolean defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtNameReferenceExpression

'it' @ [53:9] ==> value-parameter it: KtNameReferenceExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda.<anonymous>[ValueParameterDescriptorImpl]

'getQualifiedExpressionForSelector' @ [53:12] ==> public fun KtElement.getQualifiedExpressionForSelector(): KtQualifiedExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'it' @ [53:59] ==> value-parameter it: KtNameReferenceExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda.<anonymous>[ValueParameterDescriptorImpl]

'getReferencedName' @ [53:62] ==> public open fun getReferencedName(): String defined in org.jetbrains.kotlin.psi.KtNameReferenceExpression[DeserializedSimpleFunctionDescriptor]

'isItUsedInside' @ [56:9] ==> val isItUsedInside: Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[LocalVariableDescriptor]

'lambdaExpression' @ [56:32] ==> val lambdaExpression: KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[LocalVariableDescriptor]

'lambdaExpression' @ [58:18] ==> val lambdaExpression: KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[LocalVariableDescriptor]

'findParameterUsages' @ [58:35] ==> private fun KtLambdaExpression.findParameterUsages(lambdaParam: KtParameter, context: KtExpression): Collection<KtNameReferenceExpression> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain[SimpleFunctionDescriptorImpl]

'lambdaExpression' @ [58:55] ==> val lambdaExpression: KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[LocalVariableDescriptor]

'valueParameters' @ [58:72] ==> public final val KtLambdaExpression.valueParameters: (MutableList<(KtParameter..KtParameter?)>..List<(KtParameter..KtParameter?)>)[MyPropertyDescriptor]

'single' @ [58:88] ==> public fun <T> List<(KtParameter..KtParameter?)>.single(): (KtParameter..KtParameter?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtParameter..org.jetbrains.kotlin.psi.KtParameter?)

'inputVariable' @ [58:98] ==> value-parameter inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[ValueParameterDescriptorImpl]

'psiFactory' @ [60:18] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[LocalVariableDescriptor]

'createSimpleName' @ [60:29] ==> public final fun createSimpleName(name: String): KtSimpleNameExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'usages' @ [61:19] ==> val usages: Collection<KtNameReferenceExpression> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[LocalVariableDescriptor]

'usage' @ [62:24] ==> val usage: KtNameReferenceExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[LocalVariableDescriptor]

'replaced' @ [62:30] ==> public inline fun <reified T : PsiElement> PsiElement.replaced(newElement: KtSimpleNameExpression): KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtSimpleNameExpression

'itExpr' @ [62:39] ==> val itExpr: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[LocalVariableDescriptor]

'usage' @ [65:10] ==> val usage: KtNameReferenceExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[LocalVariableDescriptor]

'node' @ [65:16] ==> public final var KtNameReferenceExpression.node: ASTNode[MyPropertyDescriptor]

'copyCopyableDataTo' @ [65:44] ==> public open fun copyCopyableDataTo(@NotNull p0: UserDataHolderBase): Unit defined in com.intellij.openapi.util.UserDataHolderBase[JavaMethodDescriptor]

'replaced' @ [65:63] ==> val replaced: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[LocalVariableDescriptor]

'node' @ [65:72] ==> public final val KtSimpleNameExpression.node: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'psiFactory' @ [68:12] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[LocalVariableDescriptor]

'createExpressionByPattern' @ [68:23] ==> public fun KtPsiFactory.createExpressionByPattern(pattern: String, vararg args: Any, reformat: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'lambdaExpression' @ [68:59] ==> val lambdaExpression: KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[LocalVariableDescriptor]

'bodyExpression' @ [68:76] ==> public final val KtLambdaExpression.bodyExpression: KtBlockExpression?[MyPropertyDescriptor]

'indexVariable' @ [72:9] ==> value-parameter indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[ValueParameterDescriptorImpl]

'generateLambda' @ [73:16] ==> public fun generateLambda(inputVariable: KtCallableDeclaration, expression: KtExpression): KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file utils.kt[SimpleFunctionDescriptorImpl]

'inputVariable' @ [73:31] ==> value-parameter inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[ValueParameterDescriptorImpl]

'expression' @ [73:46] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[ValueParameterDescriptorImpl]

'generateLambda' @ [76:28] ==> public fun generateLambda(expression: KtExpression, vararg inputVariables: KtCallableDeclaration): KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain[SimpleFunctionDescriptorImpl]

'expression' @ [76:43] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[ValueParameterDescriptorImpl]

'arrayOf' @ [76:56] ==> public inline fun <reified @PureReifiable T> arrayOf(vararg elements: KtCallableDeclaration): Array<KtCallableDeclaration> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified @PureReifiable T> -> KtCallableDeclaration

'indexVariable' @ [76:64] ==> value-parameter indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[ValueParameterDescriptorImpl]

'inputVariable' @ [76:79] ==> value-parameter inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[ValueParameterDescriptorImpl]

'lambdaExpression' @ [79:25] ==> val lambdaExpression: KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[LocalVariableDescriptor]

'findDescendantOfType' @ [79:42] ==> public inline fun <reified T : PsiElement> PsiElement.findDescendantOfType(noinline predicate: (KtUnaryExpression) -> Boolean = ...): KtUnaryExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtUnaryExpression

'unaryExpression' @ [80:23] ==> value-parameter unaryExpression: KtUnaryExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda.<anonymous>[ValueParameterDescriptorImpl]

'isPlusPlusOf' @ [80:39] ==> public fun KtExpression.isPlusPlusOf(): KtExpression? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file commonUtils.kt[SimpleFunctionDescriptorImpl]

'if (operand != null && operand.getReferencedName() == indexVariable.name) {
            val bindingContext = lambdaExpression.analyzeInContext(inputVariable)
            val parameter = lambdaExpression.valueParameters[0]
            val parameterDescriptor = bindingContext[BindingContext.DECLARATION_TO_DESCRIPTOR, parameter]
            operand.mainReference.resolveToDescriptors(bindingContext).singleOrNull() == parameterDescriptor
        }
        else {
            false
        }' @ [81:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Boolean, elseBranch: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Boolean

'operand' @ [81:13] ==> val operand: KtNameReferenceExpression? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda.<anonymous>[LocalVariableDescriptor]

'operand' @ [81:32] ==> val operand: KtNameReferenceExpression? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda.<anonymous>[LocalVariableDescriptor]

'getReferencedName' @ [81:40] ==> public open fun getReferencedName(): String defined in org.jetbrains.kotlin.psi.KtNameReferenceExpression[DeserializedSimpleFunctionDescriptor]

'indexVariable' @ [81:63] ==> value-parameter indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[ValueParameterDescriptorImpl]

'name' @ [81:77] ==> public final val KtCallableDeclaration.name: String?[MyPropertyDescriptor]

'lambdaExpression' @ [82:34] ==> val lambdaExpression: KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[LocalVariableDescriptor]

'analyzeInContext' @ [82:51] ==> private fun KtLambdaExpression.analyzeInContext(context: KtExpression): BindingContext defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file utils.kt[SimpleFunctionDescriptorImpl]

'inputVariable' @ [82:68] ==> value-parameter inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[ValueParameterDescriptorImpl]

'lambdaExpression' @ [83:29] ==> val lambdaExpression: KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[LocalVariableDescriptor]

'valueParameters' @ [83:46] ==> public final val KtLambdaExpression.valueParameters: (MutableList<(KtParameter..KtParameter?)>..List<(KtParameter..KtParameter?)>)[MyPropertyDescriptor]

'bindingContext' @ [84:39] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda.<anonymous>[LocalVariableDescriptor]

'DECLARATION_TO_DESCRIPTOR' @ [84:69] ==> public final val DECLARATION_TO_DESCRIPTOR: (ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'parameter' @ [84:96] ==> val parameter: (KtParameter..KtParameter?) defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda.<anonymous>[LocalVariableDescriptor]

'operand' @ [85:13] ==> val operand: KtNameReferenceExpression? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda.<anonymous>[LocalVariableDescriptor]

'mainReference' @ [85:21] ==> public val KtSimpleNameExpression.mainReference: KtSimpleNameReference defined in org.jetbrains.kotlin.idea.references[DeserializedPropertyDescriptor]

'resolveToDescriptors' @ [85:35] ==> public open fun resolveToDescriptors(bindingContext: BindingContext): Collection<DeclarationDescriptor> defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [85:56] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda.<anonymous>[LocalVariableDescriptor]

'singleOrNull' @ [85:72] ==> public fun <T> Iterable<DeclarationDescriptor>.singleOrNull(): DeclarationDescriptor? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DeclarationDescriptor

'parameterDescriptor' @ [85:90] ==> val parameterDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda.<anonymous>[LocalVariableDescriptor]

'indexPlusPlus' @ [91:9] ==> val indexPlusPlus: KtUnaryExpression? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[LocalVariableDescriptor]

'removePlusPlus' @ [92:9] ==> public fun removePlusPlus(indexPlusPlus: KtUnaryExpression): Unit defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file utils.kt[SimpleFunctionDescriptorImpl]

'indexPlusPlus' @ [92:24] ==> val indexPlusPlus: KtUnaryExpression? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[LocalVariableDescriptor]

'lambdaExpression' @ [95:12] ==> val lambdaExpression: KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[LocalVariableDescriptor]

'indexPlusPlus' @ [99:19] ==> value-parameter indexPlusPlus: KtUnaryExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.removePlusPlus[ValueParameterDescriptorImpl]

'baseExpression' @ [99:33] ==> public final val KtUnaryExpression.baseExpression: KtExpression?[MyPropertyDescriptor]

'if (indexPlusPlus is KtPostfixExpression) // index++
        operand
    else // ++index
        KtPsiFactory(operand).createExpressionByPattern("$0 + 1", operand)' @ [100:23] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtExpression, elseBranch: KtExpression): KtExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtExpression

'indexPlusPlus' @ [100:27] ==> value-parameter indexPlusPlus: KtUnaryExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.removePlusPlus[ValueParameterDescriptorImpl]

'operand' @ [101:9] ==> val operand: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.removePlusPlus[LocalVariableDescriptor]

'KtPsiFactory' @ [103:9] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'operand' @ [103:22] ==> val operand: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.removePlusPlus[LocalVariableDescriptor]

'createExpressionByPattern' @ [103:31] ==> public fun KtPsiFactory.createExpressionByPattern(pattern: String, vararg args: Any, reformat: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'operand' @ [103:67] ==> val operand: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.removePlusPlus[LocalVariableDescriptor]

'indexPlusPlus' @ [104:5] ==> value-parameter indexPlusPlus: KtUnaryExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.removePlusPlus[ValueParameterDescriptorImpl]

'replace' @ [104:19] ==> public open fun replace(newElement: PsiElement): PsiElement defined in org.jetbrains.kotlin.psi.KtUnaryExpression[DeserializedSimpleFunctionDescriptor]

'replacement' @ [104:27] ==> val replacement: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.removePlusPlus[LocalVariableDescriptor]

'KtPsiFactory' @ [108:12] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'expression' @ [108:25] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[ValueParameterDescriptorImpl]

'buildExpression' @ [108:37] ==> public fun KtPsiFactory.buildExpression(build: BuilderByPattern<KtExpression>.() -> Unit): KtExpression defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'appendFixedText' @ [109:9] ==> public final fun appendFixedText(text: String): BuilderByPattern<KtExpression> defined in org.jetbrains.kotlin.psi.BuilderByPattern[DeserializedSimpleFunctionDescriptor]

'component1' @ [111:15] ==> public final operator fun component1(): Int defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'component2' @ [111:22] ==> public final operator fun component2(): KtCallableDeclaration defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'inputVariables' @ [111:35] ==> value-parameter vararg inputVariables: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[ValueParameterDescriptorImpl]

'withIndex' @ [111:50] ==> public fun <T> Array<out KtCallableDeclaration>.withIndex(): Iterable<IndexedValue<KtCallableDeclaration>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtCallableDeclaration

'index' @ [112:17] ==> val index: Int defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda.<anonymous>[LocalVariableDescriptor]

'appendFixedText' @ [113:17] ==> public final fun appendFixedText(text: String): BuilderByPattern<KtExpression> defined in org.jetbrains.kotlin.psi.BuilderByPattern[DeserializedSimpleFunctionDescriptor]

'appendName' @ [115:13] ==> public final fun appendName(name: Name): BuilderByPattern<KtExpression> defined in org.jetbrains.kotlin.psi.BuilderByPattern[DeserializedSimpleFunctionDescriptor]

'variable' @ [115:24] ==> val variable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda.<anonymous>[LocalVariableDescriptor]

'nameAsSafeName' @ [115:33] ==> public final val KtCallableDeclaration.nameAsSafeName: Name[MyPropertyDescriptor]

'appendFixedText' @ [118:9] ==> public final fun appendFixedText(text: String): BuilderByPattern<KtExpression> defined in org.jetbrains.kotlin.psi.BuilderByPattern[DeserializedSimpleFunctionDescriptor]

'appendExpression' @ [120:9] ==> public final fun appendExpression(expression: KtExpression?): BuilderByPattern<KtExpression> defined in org.jetbrains.kotlin.psi.BuilderByPattern[DeserializedSimpleFunctionDescriptor]

'expression' @ [120:26] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.generateLambda[ValueParameterDescriptorImpl]

'appendFixedText' @ [122:9] ==> public final fun appendFixedText(text: String): BuilderByPattern<KtExpression> defined in org.jetbrains.kotlin.psi.BuilderByPattern[DeserializedSimpleFunctionDescriptor]

'analyzeInContext' @ [127:26] ==> private fun KtLambdaExpression.analyzeInContext(context: KtExpression): BindingContext defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file utils.kt[SimpleFunctionDescriptorImpl]

'context' @ [127:43] ==> value-parameter context: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.findParameterUsages[ValueParameterDescriptorImpl]

'bindingContext' @ [128:33] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.findParameterUsages[LocalVariableDescriptor]

'DECLARATION_TO_DESCRIPTOR' @ [128:63] ==> public final val DECLARATION_TO_DESCRIPTOR: (ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'lambdaParam' @ [128:90] ==> value-parameter lambdaParam: KtParameter defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.findParameterUsages[ValueParameterDescriptorImpl]

'collectDescendantsOfType' @ [129:12] ==> public inline fun <reified T : PsiElement> PsiElement.collectDescendantsOfType(noinline predicate: (KtNameReferenceExpression) -> Boolean = ...): List<KtNameReferenceExpression> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtNameReferenceExpression

'it' @ [130:9] ==> value-parameter it: KtNameReferenceExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.findParameterUsages.<anonymous>[ValueParameterDescriptorImpl]

'mainReference' @ [130:12] ==> public val KtSimpleNameExpression.mainReference: KtSimpleNameReference defined in org.jetbrains.kotlin.idea.references[DeserializedPropertyDescriptor]

'resolveToDescriptors' @ [130:26] ==> public open fun resolveToDescriptors(bindingContext: BindingContext): Collection<DeclarationDescriptor> defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [130:47] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.findParameterUsages[LocalVariableDescriptor]

'singleOrNull' @ [130:63] ==> public fun <T> Iterable<DeclarationDescriptor>.singleOrNull(): DeclarationDescriptor? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DeclarationDescriptor

'lambdaParamDescriptor' @ [130:81] ==> val lambdaParamDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.findParameterUsages[LocalVariableDescriptor]

'context' @ [135:27] ==> value-parameter context: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.analyzeInContext[ValueParameterDescriptorImpl]

'getResolutionScope' @ [135:35] ==> public fun PsiElement.getResolutionScope(bindingContext: BindingContext, resolutionFacade: ResolutionFacade): LexicalScope defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'context' @ [135:54] ==> value-parameter context: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.analyzeInContext[ValueParameterDescriptorImpl]

'analyze' @ [135:62] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'FULL' @ [135:86] ==> enum entry FULL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'context' @ [135:93] ==> value-parameter context: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.analyzeInContext[ValueParameterDescriptorImpl]

'getResolutionFacade' @ [135:101] ==> public fun KtElement.getResolutionFacade(): ResolutionFacade defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'analyzeInContext' @ [136:12] ==> @JvmOverloads public fun KtExpression.analyzeInContext(scope: LexicalScope, contextExpression: KtExpression = ..., trace: BindingTrace = ..., dataFlowInfo: DataFlowInfo = ..., expectedType: KotlinType = ..., isStatement: Boolean = ..., contextDependency: ContextDependency = ..., expressionTypingServices: ExpressionTypingServices = ...): BindingContext defined in org.jetbrains.kotlin.idea.analysis[DeserializedSimpleFunctionDescriptor]

'resolutionScope' @ [136:29] ==> val resolutionScope: LexicalScope defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.analyzeInContext[LocalVariableDescriptor]

'context' @ [136:66] ==> value-parameter context: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.analyzeInContext[ValueParameterDescriptorImpl]

'this' @ [149:9] ==> <this> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.findVariableInitializationBeforeLoop[ReceiverParameterDescriptorImpl]

'getQualifiedExpressionForSelector' @ [150:9] ==> public fun KtElement.getQualifiedExpressionForSelector(): KtQualifiedExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'this' @ [151:20] ==> <this> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.findVariableInitializationBeforeLoop[ReceiverParameterDescriptorImpl]

'mainReference' @ [151:25] ==> public val KtSimpleNameExpression.mainReference: KtSimpleNameReference defined in org.jetbrains.kotlin.idea.references[DeserializedPropertyDescriptor]

'resolve' @ [151:39] ==> @Nullable public open fun resolve(): PsiElement? defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[JavaMethodDescriptor]

'checkNoOtherUsagesInLoop' @ [154:9] ==> value-parameter checkNoOtherUsagesInLoop: Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.findVariableInitializationBeforeLoop[ValueParameterDescriptorImpl]

'variable' @ [154:37] ==> val variable: KtProperty defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.findVariableInitializationBeforeLoop[LocalVariableDescriptor]

'countUsages' @ [154:46] ==> public fun KtCallableDeclaration.countUsages(inElement: KtElement): Int defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file commonUtils.kt[SimpleFunctionDescriptorImpl]

'loop' @ [154:58] ==> value-parameter loop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.findVariableInitializationBeforeLoop[ValueParameterDescriptorImpl]

'loop' @ [156:21] ==> value-parameter loop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.findVariableInitializationBeforeLoop[ValueParameterDescriptorImpl]

'unwrapIfLabeled' @ [156:26] ==> public fun KtExpression.unwrapIfLabeled(): KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file commonUtils.kt[SimpleFunctionDescriptorImpl]

'unwrapped' @ [157:9] ==> val unwrapped: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.findVariableInitializationBeforeLoop[LocalVariableDescriptor]

'parent' @ [157:19] ==> public final val KtExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'unwrapped' @ [158:26] ==> val unwrapped: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.findVariableInitializationBeforeLoop[LocalVariableDescriptor]

'siblings' @ [159:14] ==> public fun PsiElement.siblings(forward: Boolean = ..., withItself: Boolean = ...): Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'filterIsInstance' @ [160:14] ==> public inline fun <reified R> Sequence<*>.filterIsInstance(): Sequence<KtExpression> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified R> -> KtExpression

'ArrayList' @ [162:29] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> KtExpression

'prevStatements' @ [163:23] ==> val prevStatements: Sequence<KtExpression> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.findVariableInitializationBeforeLoop[LocalVariableDescriptor]

'extractVariableInitialization' @ [164:38] ==> private fun extractVariableInitialization(statement: KtExpression, variable: KtProperty): VariableInitialization? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file utils.kt[SimpleFunctionDescriptorImpl]

'statement' @ [164:68] ==> val statement: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.findVariableInitializationBeforeLoop[LocalVariableDescriptor]

'variable' @ [164:79] ==> val variable: KtProperty defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.findVariableInitializationBeforeLoop[LocalVariableDescriptor]

'variableInitialization' @ [165:13] ==> val variableInitialization: VariableInitialization? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.findVariableInitializationBeforeLoop[LocalVariableDescriptor]

'variableInitialization' @ [166:20] ==> val variableInitialization: VariableInitialization? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.findVariableInitializationBeforeLoop[LocalVariableDescriptor]

'takeIf' @ [166:43] ==> @InlineOnly @SinceKotlin public inline fun <T> VariableInitialization.takeIf(predicate: (VariableInitialization) -> Boolean): VariableInitialization? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> VariableInitialization

'statementsBetween' @ [167:17] ==> val statementsBetween: ArrayList<KtExpression> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.findVariableInitializationBeforeLoop[LocalVariableDescriptor]

'all' @ [167:35] ==> public inline fun <T> Iterable<KtExpression>.all(predicate: (KtExpression) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'canSwapExecutionOrder' @ [167:41] ==> public fun canSwapExecutionOrder(expressionBefore: KtExpression, expressionAfter: KtExpression): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file utils.kt[SimpleFunctionDescriptorImpl]

'variableInitialization' @ [167:63] ==> val variableInitialization: VariableInitialization? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.findVariableInitializationBeforeLoop[LocalVariableDescriptor]

'initializationStatement' @ [167:86] ==> public final val initializationStatement: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.VariableInitialization[PropertyDescriptorImpl]

'it' @ [167:111] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.findVariableInitializationBeforeLoop.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'statementsBetween' @ [171:9] ==> val statementsBetween: ArrayList<KtExpression> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.findVariableInitializationBeforeLoop[LocalVariableDescriptor]

'add' @ [171:27] ==> public open fun add(element: KtExpression): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'statement' @ [171:31] ==> val statement: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.findVariableInitializationBeforeLoop[LocalVariableDescriptor]

'statement' @ [178:9] ==> value-parameter statement: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.extractVariableInitialization[ValueParameterDescriptorImpl]

'variable' @ [178:22] ==> value-parameter variable: KtProperty defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.extractVariableInitialization[ValueParameterDescriptorImpl]

'variable' @ [179:27] ==> value-parameter variable: KtProperty defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.extractVariableInitialization[ValueParameterDescriptorImpl]

'initializer' @ [179:36] ==> public final var KtProperty.initializer: KtExpression?[MyPropertyDescriptor]

'VariableInitialization' @ [180:16] ==> public constructor VariableInitialization(variable: KtProperty, initializationStatement: KtExpression, initializer: KtExpression) defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.VariableInitialization[ClassConstructorDescriptorImpl]

'variable' @ [180:39] ==> value-parameter variable: KtProperty defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.extractVariableInitialization[ValueParameterDescriptorImpl]

'variable' @ [180:49] ==> value-parameter variable: KtProperty defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.extractVariableInitialization[ValueParameterDescriptorImpl]

'initializer' @ [180:59] ==> val initializer: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.extractVariableInitialization[LocalVariableDescriptor]

'statement' @ [183:22] ==> value-parameter statement: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.extractVariableInitialization[ValueParameterDescriptorImpl]

'asAssignment' @ [183:32] ==> public fun KtExpression.asAssignment(): KtBinaryExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'!' @ [184:9] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'assignment' @ [184:10] ==> val assignment: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.extractVariableInitialization[LocalVariableDescriptor]

'left' @ [184:21] ==> public final val KtBinaryExpression.left: KtExpression?[MyPropertyDescriptor]

'isVariableReference' @ [184:26] ==> public fun KtExpression?.isVariableReference(variable: KtCallableDeclaration): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file commonUtils.kt[SimpleFunctionDescriptorImpl]

'variable' @ [184:46] ==> value-parameter variable: KtProperty defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.extractVariableInitialization[ValueParameterDescriptorImpl]

'assignment' @ [186:23] ==> val assignment: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.extractVariableInitialization[LocalVariableDescriptor]

'right' @ [186:34] ==> public final val KtBinaryExpression.right: KtExpression?[MyPropertyDescriptor]

'VariableInitialization' @ [187:12] ==> public constructor VariableInitialization(variable: KtProperty, initializationStatement: KtExpression, initializer: KtExpression) defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.VariableInitialization[ClassConstructorDescriptorImpl]

'variable' @ [187:35] ==> value-parameter variable: KtProperty defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.extractVariableInitialization[ValueParameterDescriptorImpl]

'assignment' @ [187:45] ==> val assignment: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.extractVariableInitialization[LocalVariableDescriptor]

'initializer' @ [187:57] ==> val initializer: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.extractVariableInitialization[LocalVariableDescriptor]

'this' @ [195:26] ==> <this> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isSimpleCollectionInstantiation[ReceiverParameterDescriptorImpl]

'callExpression' @ [196:9] ==> val callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isSimpleCollectionInstantiation[LocalVariableDescriptor]

'valueArguments' @ [196:24] ==> public final val KtCallExpression.valueArguments: (MutableList<(KtValueArgument..KtValueArgument?)>..List<(KtValueArgument..KtValueArgument?)>)[MyPropertyDescriptor]

'isNotEmpty' @ [196:39] ==> @InlineOnly public inline fun <T> Collection<(KtValueArgument..KtValueArgument?)>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtValueArgument..org.jetbrains.kotlin.psi.KtValueArgument?)

'callExpression' @ [198:26] ==> val callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isSimpleCollectionInstantiation[LocalVariableDescriptor]

'analyze' @ [198:41] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'PARTIAL' @ [198:65] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'callExpression' @ [199:24] ==> val callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isSimpleCollectionInstantiation[LocalVariableDescriptor]

'getResolvedCall' @ [199:39] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [199:55] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isSimpleCollectionInstantiation[LocalVariableDescriptor]

'resolvedCall' @ [200:22] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isSimpleCollectionInstantiation[LocalVariableDescriptor]

'resultingDescriptor' @ [200:35] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.resultingDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'when (descriptor) {
        is ConstructorDescriptor -> {
            val classDescriptor = descriptor.containingDeclaration
            val classFqName = classDescriptor.importableFqName?.asString()
            return when (classFqName) {
                "java.util.ArrayList" -> CollectionKind.LIST
                "java.util.HashSet", "java.util.LinkedHashSet" -> CollectionKind.SET
                else -> null
            }
        }

        is FunctionDescriptor -> {
            val fqName = descriptor.importableFqName?.asString()
            return when (fqName) {
                "kotlin.collections.arrayListOf", "kotlin.collections.mutableListOf" -> CollectionKind.LIST
                "kotlin.collections.hashSetOf", "kotlin.collections.mutableSetOf" -> CollectionKind.SET
                else -> null
            }
        }

        else -> return null
    }' @ [202:5] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Nothing, entry1: Nothing, entry2: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Nothing

'descriptor' @ [202:11] ==> val descriptor: CallableDescriptor defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isSimpleCollectionInstantiation[LocalVariableDescriptor]

'descriptor' @ [204:35] ==> val descriptor: CallableDescriptor defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isSimpleCollectionInstantiation[LocalVariableDescriptor]

'containingDeclaration' @ [204:46] ==> public final val ConstructorDescriptor.containingDeclaration: ClassifierDescriptorWithTypeParameters[MyPropertyDescriptor]

'classDescriptor' @ [205:31] ==> val classDescriptor: ClassifierDescriptorWithTypeParameters defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isSimpleCollectionInstantiation[LocalVariableDescriptor]

'importableFqName' @ [205:47] ==> public val DeclarationDescriptor.importableFqName: FqName? defined in org.jetbrains.kotlin.idea.imports[DeserializedPropertyDescriptor]

'asString' @ [205:65] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'when (classFqName) {
                "java.util.ArrayList" -> CollectionKind.LIST
                "java.util.HashSet", "java.util.LinkedHashSet" -> CollectionKind.SET
                else -> null
            }' @ [206:20] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: CollectionKind?, entry1: CollectionKind?, entry2: CollectionKind?): CollectionKind?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> CollectionKind?

'classFqName' @ [206:26] ==> val classFqName: String? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isSimpleCollectionInstantiation[LocalVariableDescriptor]

'LIST' @ [207:57] ==> enum entry LIST defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.CollectionKind[FakeCallableDescriptorForObject]

'SET' @ [208:82] ==> enum entry SET defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.CollectionKind[FakeCallableDescriptorForObject]

'descriptor' @ [214:26] ==> val descriptor: CallableDescriptor defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isSimpleCollectionInstantiation[LocalVariableDescriptor]

'importableFqName' @ [214:37] ==> public val DeclarationDescriptor.importableFqName: FqName? defined in org.jetbrains.kotlin.idea.imports[DeserializedPropertyDescriptor]

'asString' @ [214:55] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'when (fqName) {
                "kotlin.collections.arrayListOf", "kotlin.collections.mutableListOf" -> CollectionKind.LIST
                "kotlin.collections.hashSetOf", "kotlin.collections.mutableSetOf" -> CollectionKind.SET
                else -> null
            }' @ [215:20] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: CollectionKind?, entry1: CollectionKind?, entry2: CollectionKind?): CollectionKind?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> CollectionKind?

'fqName' @ [215:26] ==> val fqName: String? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isSimpleCollectionInstantiation[LocalVariableDescriptor]

'LIST' @ [216:104] ==> enum entry LIST defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.CollectionKind[FakeCallableDescriptorForObject]

'SET' @ [217:101] ==> enum entry SET defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.CollectionKind[FakeCallableDescriptorForObject]

'tryChangeAndCheckErrors' @ [227:12] ==> public fun <TExpression : KtExpression> tryChangeAndCheckErrors(expressionToChange: KtProperty, scopeToExclude: KtElement? = ..., performChange: (KtProperty) -> Unit): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain[SimpleFunctionDescriptorImpl]
Inferred types:
    <TExpression : KtExpression> -> KtProperty

'variable' @ [227:36] ==> value-parameter variable: KtProperty defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canChangeLocalVariableType[ValueParameterDescriptorImpl]

'loop' @ [227:46] ==> value-parameter loop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canChangeLocalVariableType[ValueParameterDescriptorImpl]

'it' @ [228:9] ==> value-parameter it: KtProperty defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canChangeLocalVariableType.<anonymous>[ValueParameterDescriptorImpl]

'typeReference' @ [228:12] ==> public final var KtProperty.typeReference: KtTypeReference?[MyPropertyDescriptor]

'KtPsiFactory' @ [228:28] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'it' @ [228:41] ==> value-parameter it: KtProperty defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canChangeLocalVariableType.<anonymous>[ValueParameterDescriptorImpl]

'createType' @ [228:45] ==> public final fun createType(type: String): KtTypeReference defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'newTypeText' @ [228:56] ==> value-parameter newTypeText: String defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canChangeLocalVariableType[ValueParameterDescriptorImpl]

'expressionToChange' @ [237:26] ==> value-parameter expressionToChange: TExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[ValueParameterDescriptorImpl]

'analyze' @ [237:45] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'FULL' @ [237:69] ==> enum entry FULL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'expressionToChange' @ [240:17] ==> value-parameter expressionToChange: TExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[ValueParameterDescriptorImpl]

'parents' @ [240:36] ==> public val PsiElement.parents: Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'filterIsInstance' @ [241:26] ==> public inline fun <reified R> Sequence<*>.filterIsInstance(): Sequence<KtBlockExpression> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified R> -> KtBlockExpression

'firstOrNull' @ [242:26] ==> public inline fun <T> Sequence<KtBlockExpression>.firstOrNull(predicate: (KtBlockExpression) -> Boolean): KtBlockExpression? defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtBlockExpression

'!' @ [242:40] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'it' @ [242:41] ==> value-parameter it: KtBlockExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors.<anonymous>[ValueParameterDescriptorImpl]

'isUsedAsExpression' @ [242:44] ==> public fun KtExpression.isUsedAsExpression(context: BindingContext): Boolean defined in org.jetbrains.kotlin.resolve.bindingContextUtil[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [242:63] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[LocalVariableDescriptor]

'Key' @ [246:22] ==> public constructor Key<T : (Any..Any?)>(@NotNull @NonNls p0: String) defined in com.intellij.openapi.util.Key[JavaClassConstructorDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Unit

'Key' @ [247:28] ==> public constructor Key<T : (Any..Any?)>(@NotNull @NonNls p0: String) defined in com.intellij.openapi.util.Key[JavaClassConstructorDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Unit

'Key' @ [248:25] ==> public constructor Key<T : (Any..Any?)>(@NotNull @NonNls p0: String) defined in com.intellij.openapi.util.Key[JavaClassConstructorDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Collection<DiagnosticFactory<*>>

'expressionToChange' @ [250:5] ==> value-parameter expressionToChange: TExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[ValueParameterDescriptorImpl]

'putCopyableUserData' @ [250:24] ==> public abstract fun <T : (Any..Any?)> putCopyableUserData(p0: (Key<(Unit..Unit?)>..Key<(Unit..Unit?)>?), @Nullable p1: Unit?): Unit defined in org.jetbrains.kotlin.psi.KtExpression[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Unit

'EXPRESSION' @ [250:44] ==> val EXPRESSION: Key<Unit> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[LocalVariableDescriptor]

'Unit' @ [250:56] ==> public object Unit defined in kotlin[FakeCallableDescriptorForObject]

'scopeToExclude' @ [251:5] ==> value-parameter scopeToExclude: KtElement? = ... defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[ValueParameterDescriptorImpl]

'putCopyableUserData' @ [251:21] ==> public abstract fun <T : (Any..Any?)> putCopyableUserData(p0: (Key<(Unit..Unit?)>..Key<(Unit..Unit?)>?), @Nullable p1: Unit?): Unit defined in org.jetbrains.kotlin.psi.KtElement[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Unit

'SCOPE_TO_EXCLUDE' @ [251:41] ==> val SCOPE_TO_EXCLUDE: Key<Unit> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[LocalVariableDescriptor]

'Unit' @ [251:59] ==> public object Unit defined in kotlin[FakeCallableDescriptorForObject]

'block' @ [253:5] ==> val block: KtBlockExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[LocalVariableDescriptor]

'forEachDescendantOfType' @ [253:11] ==> public inline fun <reified T : PsiElement> PsiElement.forEachDescendantOfType(noinline action: (PsiElement) -> Unit): Unit defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> PsiElement

'bindingContext' @ [254:22] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[LocalVariableDescriptor]

'diagnostics' @ [254:37] ==> public final val BindingContext.diagnostics: Diagnostics[MyPropertyDescriptor]

'forElement' @ [254:49] ==> public abstract fun forElement(psiElement: PsiElement): Collection<Diagnostic> defined in org.jetbrains.kotlin.resolve.diagnostics.Diagnostics[DeserializedSimpleFunctionDescriptor]

'element' @ [254:60] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors.<anonymous>[ValueParameterDescriptorImpl]

'filter' @ [255:18] ==> public inline fun <T> Iterable<Diagnostic>.filter(predicate: (Diagnostic) -> Boolean): List<Diagnostic> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Diagnostic

'it' @ [255:27] ==> value-parameter it: Diagnostic defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'severity' @ [255:30] ==> public final val Diagnostic.severity: Severity[MyPropertyDescriptor]

'ERROR' @ [255:51] ==> enum entry ERROR defined in org.jetbrains.kotlin.diagnostics.Severity[FakeCallableDescriptorForObject]

'errors' @ [256:13] ==> val errors: List<Diagnostic> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors.<anonymous>[LocalVariableDescriptor]

'isNotEmpty' @ [256:20] ==> @InlineOnly public inline fun <T> Collection<Diagnostic>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Diagnostic

'element' @ [257:13] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors.<anonymous>[ValueParameterDescriptorImpl]

'putCopyableUserData' @ [257:21] ==> public abstract fun <T : (Any..Any?)> putCopyableUserData(p0: (Key<(Collection<DiagnosticFactory<*>>..Collection<DiagnosticFactory<*>>?)>..Key<(Collection<DiagnosticFactory<*>>..Collection<DiagnosticFactory<*>>?)>?), @Nullable p1: Collection<DiagnosticFactory<*>>?): Unit defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Collection<DiagnosticFactory<*>>

'ERRORS_BEFORE' @ [257:41] ==> val ERRORS_BEFORE: Key<Collection<DiagnosticFactory<*>>> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[LocalVariableDescriptor]

'errors' @ [257:56] ==> val errors: List<Diagnostic> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors.<anonymous>[LocalVariableDescriptor]

'map' @ [257:63] ==> public inline fun <T, R> Iterable<Diagnostic>.map(transform: (Diagnostic) -> DiagnosticFactory<out (Diagnostic..Diagnostic?)>): List<DiagnosticFactory<out (Diagnostic..Diagnostic?)>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Diagnostic
    <R> -> DiagnosticFactory<out (org.jetbrains.kotlin.diagnostics.Diagnostic..org.jetbrains.kotlin.diagnostics.Diagnostic?)>

'it' @ [257:69] ==> value-parameter it: Diagnostic defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'factory' @ [257:72] ==> public final val Diagnostic.factory: DiagnosticFactory<*>[MyPropertyDescriptor]

'block' @ [261:21] ==> val block: KtBlockExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[LocalVariableDescriptor]

'copied' @ [261:27] ==> public fun <T : PsiElement> KtBlockExpression.copied(): KtBlockExpression defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : PsiElement> -> KtBlockExpression

'Suppress' @ [264:5] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'expressionCopy' @ [266:9] ==> val expressionCopy: TExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[LocalVariableDescriptor]

'blockCopy' @ [266:26] ==> val blockCopy: KtBlockExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[LocalVariableDescriptor]

'findDescendantOfType' @ [266:36] ==> public inline fun <reified T : PsiElement> PsiElement.findDescendantOfType(noinline predicate: (KtExpression) -> Boolean = ...): KtExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtExpression

'it' @ [266:73] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors.<anonymous>[ValueParameterDescriptorImpl]

'getCopyableUserData' @ [266:76] ==> @Nullable @Contract public abstract fun <T : (Any..Any?)> getCopyableUserData(p0: (Key<(Unit..Unit?)>..Key<(Unit..Unit?)>?)): Unit? defined in org.jetbrains.kotlin.psi.KtExpression[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Unit

'EXPRESSION' @ [266:96] ==> val EXPRESSION: Key<Unit> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[LocalVariableDescriptor]

'scopeToExcludeCopy' @ [267:9] ==> val scopeToExcludeCopy: KtElement? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[LocalVariableDescriptor]

'blockCopy' @ [267:30] ==> val blockCopy: KtBlockExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[LocalVariableDescriptor]

'findDescendantOfType' @ [267:40] ==> public inline fun <reified T : PsiElement> PsiElement.findDescendantOfType(noinline predicate: (KtElement) -> Boolean = ...): KtElement? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtElement

'it' @ [267:74] ==> value-parameter it: KtElement defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors.<anonymous>[ValueParameterDescriptorImpl]

'getCopyableUserData' @ [267:77] ==> @Nullable @Contract public abstract fun <T : (Any..Any?)> getCopyableUserData(p0: (Key<(Unit..Unit?)>..Key<(Unit..Unit?)>?)): Unit? defined in org.jetbrains.kotlin.psi.KtElement[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Unit

'SCOPE_TO_EXCLUDE' @ [267:97] ==> val SCOPE_TO_EXCLUDE: Key<Unit> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[LocalVariableDescriptor]

'expressionToChange' @ [270:9] ==> value-parameter expressionToChange: TExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[ValueParameterDescriptorImpl]

'putCopyableUserData' @ [270:28] ==> public abstract fun <T : (Any..Any?)> putCopyableUserData(p0: (Key<(Unit..Unit?)>..Key<(Unit..Unit?)>?), @Nullable p1: Unit?): Unit defined in org.jetbrains.kotlin.psi.KtExpression[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Unit

'EXPRESSION' @ [270:48] ==> val EXPRESSION: Key<Unit> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[LocalVariableDescriptor]

'scopeToExclude' @ [271:9] ==> value-parameter scopeToExclude: KtElement? = ... defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[ValueParameterDescriptorImpl]

'putCopyableUserData' @ [271:25] ==> public abstract fun <T : (Any..Any?)> putCopyableUserData(p0: (Key<(Unit..Unit?)>..Key<(Unit..Unit?)>?), @Nullable p1: Unit?): Unit defined in org.jetbrains.kotlin.psi.KtElement[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Unit

'SCOPE_TO_EXCLUDE' @ [271:45] ==> val SCOPE_TO_EXCLUDE: Key<Unit> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[LocalVariableDescriptor]

'invoke' @ [274:5] ==> public abstract operator fun invoke(p1: TExpression): Unit defined in kotlin.Function1[FunctionInvokeDescriptor]

'expressionCopy' @ [274:19] ==> val expressionCopy: TExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[LocalVariableDescriptor]

'blockCopy' @ [276:29] ==> val blockCopy: KtBlockExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[LocalVariableDescriptor]

'analyzeAsReplacement' @ [276:39] ==> @JvmOverloads public fun KtExpression.analyzeAsReplacement(expressionToBeReplaced: KtExpression, bindingContext: BindingContext, resolutionFacade: ResolutionFacade = ..., trace: BindingTrace = ..., contextDependency: ContextDependency = ...): BindingContext defined in org.jetbrains.kotlin.idea.analysis[DeserializedSimpleFunctionDescriptor]

'block' @ [276:60] ==> val block: KtBlockExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[LocalVariableDescriptor]

'bindingContext' @ [276:67] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[LocalVariableDescriptor]

'newBindingContext' @ [277:12] ==> val newBindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[LocalVariableDescriptor]

'diagnostics' @ [277:30] ==> public final val BindingContext.diagnostics: Diagnostics[MyPropertyDescriptor]

'none' @ [277:42] ==> public inline fun <T> Iterable<Diagnostic>.none(predicate: (Diagnostic) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Diagnostic

'it' @ [278:9] ==> value-parameter it: Diagnostic defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors.<anonymous>[ValueParameterDescriptorImpl]

'severity' @ [278:12] ==> public final val Diagnostic.severity: Severity[MyPropertyDescriptor]

'ERROR' @ [278:33] ==> enum entry ERROR defined in org.jetbrains.kotlin.diagnostics.Severity[FakeCallableDescriptorForObject]

'!' @ [279:16] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'scopeToExcludeCopy' @ [279:17] ==> val scopeToExcludeCopy: KtElement? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[LocalVariableDescriptor]

'isAncestor' @ [279:36] ==> public fun PsiElement?.isAncestor(element: PsiElement, strict: Boolean = ...): Boolean defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'it' @ [279:47] ==> value-parameter it: Diagnostic defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors.<anonymous>[ValueParameterDescriptorImpl]

'psiElement' @ [279:50] ==> public final val Diagnostic.psiElement: PsiElement[MyPropertyDescriptor]

'it' @ [280:16] ==> value-parameter it: Diagnostic defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors.<anonymous>[ValueParameterDescriptorImpl]

'factory' @ [280:19] ==> public final val Diagnostic.factory: DiagnosticFactory<*>[MyPropertyDescriptor]

'it' @ [280:32] ==> value-parameter it: Diagnostic defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors.<anonymous>[ValueParameterDescriptorImpl]

'psiElement' @ [280:35] ==> public final val Diagnostic.psiElement: PsiElement[MyPropertyDescriptor]

'getCopyableUserData' @ [280:46] ==> @Nullable @Contract public abstract fun <T : (Any..Any?)> getCopyableUserData(p0: (Key<(Collection<DiagnosticFactory<*>>..Collection<DiagnosticFactory<*>>?)>..Key<(Collection<DiagnosticFactory<*>>..Collection<DiagnosticFactory<*>>?)>?)): Collection<DiagnosticFactory<*>>? defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Collection<DiagnosticFactory<*>>

'ERRORS_BEFORE' @ [280:66] ==> val ERRORS_BEFORE: Key<Collection<DiagnosticFactory<*>>> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.tryChangeAndCheckErrors[LocalVariableDescriptor]

'emptyList' @ [280:84] ==> public fun <T> emptyList(): List<DiagnosticFactory<*>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DiagnosticFactory<*>

'setOf' @ [284:47] ==> public fun <T> setOf(vararg elements: String): Set<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'analyze' @ [294:26] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'PARTIAL' @ [294:50] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'ConstantExpressionEvaluator' @ [295:9] ==> public companion object defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[FakeCallableDescriptorForObject]

'getConstant' @ [295:37] ==> @JvmStatic public final fun getConstant(expression: KtExpression, bindingContext: BindingContext): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.Companion[DeserializedSimpleFunctionDescriptor]

'this' @ [295:49] ==> <this> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.hasNoSideEffect[ReceiverParameterDescriptorImpl]

'bindingContext' @ [295:55] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.hasNoSideEffect[LocalVariableDescriptor]

'this' @ [297:26] ==> <this> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.hasNoSideEffect[ReceiverParameterDescriptorImpl]

'callExpression' @ [298:9] ==> val callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.hasNoSideEffect[LocalVariableDescriptor]

'valueArguments' @ [298:24] ==> public final val KtCallExpression.valueArguments: (MutableList<(KtValueArgument..KtValueArgument?)>..List<(KtValueArgument..KtValueArgument?)>)[MyPropertyDescriptor]

'any' @ [298:39] ==> public inline fun <T> Iterable<(KtValueArgument..KtValueArgument?)>.any(predicate: ((KtValueArgument..KtValueArgument?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtValueArgument..org.jetbrains.kotlin.psi.KtValueArgument?)

'it' @ [298:45] ==> value-parameter it: (KtValueArgument..KtValueArgument?) defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.hasNoSideEffect.<anonymous>[ValueParameterDescriptorImpl]

'getArgumentExpression' @ [298:48] ==> @IfNotParsed @Nullable public open fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.KtValueArgument[JavaMethodDescriptor]

'hasNoSideEffect' @ [298:73] ==> public fun KtExpression.hasNoSideEffect(): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file utils.kt[SimpleFunctionDescriptorImpl]

'callExpression' @ [300:24] ==> val callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.hasNoSideEffect[LocalVariableDescriptor]

'getResolvedCall' @ [300:39] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [300:55] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.hasNoSideEffect[LocalVariableDescriptor]

'resolvedCall' @ [301:33] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.hasNoSideEffect[LocalVariableDescriptor]

'resultingDescriptor' @ [301:46] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.resultingDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'constructorDescriptor' @ [302:27] ==> val constructorDescriptor: ConstructorDescriptor defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.hasNoSideEffect[LocalVariableDescriptor]

'containingDeclaration' @ [302:49] ==> public final val ConstructorDescriptor.containingDeclaration: ClassifierDescriptorWithTypeParameters[MyPropertyDescriptor]

'classDescriptor' @ [303:23] ==> val classDescriptor: ClassifierDescriptorWithTypeParameters defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.hasNoSideEffect[LocalVariableDescriptor]

'importableFqName' @ [303:39] ==> public val DeclarationDescriptor.importableFqName: FqName? defined in org.jetbrains.kotlin.idea.imports[DeserializedPropertyDescriptor]

'asString' @ [303:57] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'classFqName' @ [304:12] ==> val classFqName: String? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.hasNoSideEffect[LocalVariableDescriptor]

'NO_SIDE_EFFECT_STANDARD_CLASSES' @ [304:27] ==> private val NO_SIDE_EFFECT_STANDARD_CLASSES: Set<String> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file utils.kt[PropertyDescriptorImpl]

'assert' @ [309:5] ==> @InlineOnly public inline fun assert(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'expressionBefore' @ [309:12] ==> value-parameter expressionBefore: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'isPhysical' @ [309:29] ==> public final val KtExpression.isPhysical: Boolean[MyPropertyDescriptor]

'assert' @ [310:5] ==> @InlineOnly public inline fun assert(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'expressionAfter' @ [310:12] ==> value-parameter expressionAfter: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'isPhysical' @ [310:28] ==> public final val KtExpression.isPhysical: Boolean[MyPropertyDescriptor]

'expressionBefore' @ [312:9] ==> value-parameter expressionBefore: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'expressionBefore' @ [313:13] ==> value-parameter expressionBefore: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'expressionBefore' @ [314:13] ==> value-parameter expressionBefore: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'hasUsages' @ [314:30] ==> public fun KtCallableDeclaration.hasUsages(inElement: KtElement): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file commonUtils.kt[SimpleFunctionDescriptorImpl]

'expressionAfter' @ [314:40] ==> value-parameter expressionAfter: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'canSwapExecutionOrder' @ [315:16] ==> public fun canSwapExecutionOrder(expressionBefore: KtExpression, expressionAfter: KtExpression): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file utils.kt[SimpleFunctionDescriptorImpl]

'expressionBefore' @ [315:38] ==> value-parameter expressionBefore: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'initializer' @ [315:55] ==> public final var KtProperty.initializer: KtExpression?[MyPropertyDescriptor]

'expressionAfter' @ [315:83] ==> value-parameter expressionAfter: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'expressionAfter' @ [318:9] ==> value-parameter expressionAfter: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'expressionAfter' @ [319:13] ==> value-parameter expressionAfter: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'canSwapExecutionOrder' @ [320:16] ==> public fun canSwapExecutionOrder(expressionBefore: KtExpression, expressionAfter: KtExpression): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file utils.kt[SimpleFunctionDescriptorImpl]

'expressionBefore' @ [320:38] ==> value-parameter expressionBefore: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'expressionAfter' @ [320:56] ==> value-parameter expressionAfter: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'initializer' @ [320:72] ==> public final var KtProperty.initializer: KtExpression?[MyPropertyDescriptor]

'expressionBefore' @ [323:9] ==> value-parameter expressionBefore: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'isOrdinaryAssignment' @ [323:51] ==> public open fun isOrdinaryAssignment(@NotNull p0: PsiElement): Boolean defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'expressionBefore' @ [323:72] ==> value-parameter expressionBefore: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'expressionBefore' @ [324:24] ==> value-parameter expressionBefore: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'left' @ [324:41] ==> public final val KtBinaryExpression.left: KtExpression?[MyPropertyDescriptor]

'leftName' @ [325:22] ==> val leftName: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[LocalVariableDescriptor]

'mainReference' @ [325:31] ==> public val KtSimpleNameExpression.mainReference: KtSimpleNameReference defined in org.jetbrains.kotlin.idea.references[DeserializedPropertyDescriptor]

'resolve' @ [325:45] ==> @Nullable public open fun resolve(): PsiElement? defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[JavaMethodDescriptor]

'target' @ [326:13] ==> val target: KtProperty defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[LocalVariableDescriptor]

'hasUsages' @ [326:20] ==> public fun KtCallableDeclaration.hasUsages(inElement: KtElement): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file commonUtils.kt[SimpleFunctionDescriptorImpl]

'expressionAfter' @ [326:30] ==> value-parameter expressionAfter: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'canSwapExecutionOrder' @ [327:16] ==> public fun canSwapExecutionOrder(expressionBefore: KtExpression, expressionAfter: KtExpression): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file utils.kt[SimpleFunctionDescriptorImpl]

'expressionBefore' @ [327:38] ==> value-parameter expressionBefore: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'right' @ [327:55] ==> public final val KtBinaryExpression.right: KtExpression?[MyPropertyDescriptor]

'expressionAfter' @ [327:77] ==> value-parameter expressionAfter: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'expressionAfter' @ [330:9] ==> value-parameter expressionAfter: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'isOrdinaryAssignment' @ [330:50] ==> public open fun isOrdinaryAssignment(@NotNull p0: PsiElement): Boolean defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'expressionAfter' @ [330:71] ==> value-parameter expressionAfter: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'expressionAfter' @ [331:24] ==> value-parameter expressionAfter: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'left' @ [331:40] ==> public final val KtBinaryExpression.left: KtExpression?[MyPropertyDescriptor]

'leftName' @ [332:22] ==> val leftName: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[LocalVariableDescriptor]

'mainReference' @ [332:31] ==> public val KtSimpleNameExpression.mainReference: KtSimpleNameReference defined in org.jetbrains.kotlin.idea.references[DeserializedPropertyDescriptor]

'resolve' @ [332:45] ==> @Nullable public open fun resolve(): PsiElement? defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[JavaMethodDescriptor]

'target' @ [333:13] ==> val target: KtProperty defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[LocalVariableDescriptor]

'hasUsages' @ [333:20] ==> public fun KtCallableDeclaration.hasUsages(inElement: KtElement): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file commonUtils.kt[SimpleFunctionDescriptorImpl]

'expressionBefore' @ [333:30] ==> value-parameter expressionBefore: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'canSwapExecutionOrder' @ [334:16] ==> public fun canSwapExecutionOrder(expressionBefore: KtExpression, expressionAfter: KtExpression): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file utils.kt[SimpleFunctionDescriptorImpl]

'expressionBefore' @ [334:38] ==> value-parameter expressionBefore: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'expressionAfter' @ [334:56] ==> value-parameter expressionAfter: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'right' @ [334:72] ==> public final val KtBinaryExpression.right: KtExpression?[MyPropertyDescriptor]

'expressionBefore' @ [337:9] ==> value-parameter expressionBefore: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'hasNoSideEffect' @ [337:26] ==> public fun KtExpression.hasNoSideEffect(): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file utils.kt[SimpleFunctionDescriptorImpl]

'expressionAfter' @ [337:47] ==> value-parameter expressionAfter: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.canSwapExecutionOrder[ValueParameterDescriptorImpl]

'hasNoSideEffect' @ [337:63] ==> public fun KtExpression.hasNoSideEffect(): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file utils.kt[SimpleFunctionDescriptorImpl]

'when {
        isConstant() -> return true

        this is KtSimpleNameExpression -> {
            val declaration = mainReference.resolve() as? KtCallableDeclaration ?: return false
            if (loop.isAncestor(declaration)) return false // should be declared outside the loop
            val variable = declaration.resolveToDescriptorIfAny() as? VariableDescriptor ?: return false

            if (checkNoOtherUsagesInLoop && declaration.countUsages(loop) > 1) return false

            if (!variable.isVar) return true
            if (declaration !is KtVariableDeclaration) return false
            if (!KtPsiUtil.isLocal(declaration)) return false // it's difficult to analyze non-local declarations
            //TODO: check that there are no local functions or lambdas that can modify it implicitly
            return !declaration.hasWriteUsages(loop)
        }

        //TODO: qualified expression?
        //TODO: this

        else -> return false
    }' @ [344:5] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Nothing, entry1: Nothing, entry2: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Nothing

'isConstant' @ [345:9] ==> public fun KtExpression.isConstant(): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file commonUtils.kt[SimpleFunctionDescriptorImpl]

'this' @ [347:9] ==> <this> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isStableInLoop[ReceiverParameterDescriptorImpl]

'mainReference' @ [348:31] ==> public val KtSimpleNameExpression.mainReference: KtSimpleNameReference defined in org.jetbrains.kotlin.idea.references[DeserializedPropertyDescriptor]

'resolve' @ [348:45] ==> @Nullable public open fun resolve(): PsiElement? defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[JavaMethodDescriptor]

'loop' @ [349:17] ==> value-parameter loop: KtLoopExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isStableInLoop[ValueParameterDescriptorImpl]

'isAncestor' @ [349:22] ==> public fun PsiElement?.isAncestor(element: PsiElement, strict: Boolean = ...): Boolean defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'declaration' @ [349:33] ==> val declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isStableInLoop[LocalVariableDescriptor]

'declaration' @ [350:28] ==> val declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isStableInLoop[LocalVariableDescriptor]

'resolveToDescriptorIfAny' @ [350:40] ==> public fun KtDeclaration.resolveToDescriptorIfAny(bodyResolveMode: BodyResolveMode = ...): DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'checkNoOtherUsagesInLoop' @ [352:17] ==> value-parameter checkNoOtherUsagesInLoop: Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isStableInLoop[ValueParameterDescriptorImpl]

'declaration' @ [352:45] ==> val declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isStableInLoop[LocalVariableDescriptor]

'countUsages' @ [352:57] ==> public fun KtCallableDeclaration.countUsages(inElement: KtElement): Int defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file commonUtils.kt[SimpleFunctionDescriptorImpl]

'loop' @ [352:69] ==> value-parameter loop: KtLoopExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isStableInLoop[ValueParameterDescriptorImpl]

'!' @ [354:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'variable' @ [354:18] ==> val variable: VariableDescriptor defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isStableInLoop[LocalVariableDescriptor]

'isVar' @ [354:27] ==> public final val VariableDescriptor.isVar: Boolean[MyPropertyDescriptor]

'declaration' @ [355:17] ==> val declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isStableInLoop[LocalVariableDescriptor]

'!' @ [356:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isLocal' @ [356:28] ==> public open fun isLocal(@NotNull p0: KtDeclaration): Boolean defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'declaration' @ [356:36] ==> val declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isStableInLoop[LocalVariableDescriptor]

'!' @ [358:20] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'declaration' @ [358:21] ==> val declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isStableInLoop[LocalVariableDescriptor]

'hasWriteUsages' @ [358:33] ==> public fun KtVariableDeclaration.hasWriteUsages(inElement: KtElement): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file commonUtils.kt[SimpleFunctionDescriptorImpl]

'loop' @ [358:48] ==> value-parameter loop: KtLoopExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isStableInLoop[ValueParameterDescriptorImpl]

'anyDescendantOfType' @ [369:12] ==> public inline fun <reified T : PsiElement> PsiElement.anyDescendantOfType(noinline predicate: (KtExpressionWithLabel) -> Boolean = ...): Boolean defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtExpressionWithLabel

'isEmbeddedBreakOrContinue' @ [369:57] ==> private fun isEmbeddedBreakOrContinue(expression: KtExpressionWithLabel): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file utils.kt[SimpleFunctionDescriptorImpl]

'it' @ [369:83] ==> value-parameter it: KtExpressionWithLabel defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.containsEmbeddedBreakOrContinue.<anonymous>[ValueParameterDescriptorImpl]

'collectDescendantsOfType' @ [373:12] ==> public inline fun <reified T : PsiElement> PsiElement.collectDescendantsOfType(noinline predicate: (KtExpressionWithLabel) -> Boolean = ...): List<KtExpressionWithLabel> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtExpressionWithLabel

'isEmbeddedBreakOrContinue' @ [373:62] ==> private fun isEmbeddedBreakOrContinue(expression: KtExpressionWithLabel): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file utils.kt[SimpleFunctionDescriptorImpl]

'it' @ [373:88] ==> value-parameter it: KtExpressionWithLabel defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.countEmbeddedBreaksAndContinues.<anonymous>[ValueParameterDescriptorImpl]

'size' @ [373:94] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'expression' @ [377:9] ==> value-parameter expression: KtExpressionWithLabel defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isEmbeddedBreakOrContinue[ValueParameterDescriptorImpl]

'expression' @ [377:45] ==> value-parameter expression: KtExpressionWithLabel defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isEmbeddedBreakOrContinue[ValueParameterDescriptorImpl]

'expression' @ [378:18] ==> value-parameter expression: KtExpressionWithLabel defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isEmbeddedBreakOrContinue[ValueParameterDescriptorImpl]

'parent' @ [378:29] ==> public final val KtExpressionWithLabel.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'when (parent) {
        is KtBlockExpression -> false

        is KtContainerNode -> {
            val containerExpression = parent.parent as KtExpression
            containerExpression.isUsedAsExpression(containerExpression.analyze(BodyResolveMode.PARTIAL))
        }

        else -> true
    }' @ [379:12] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean, entry2: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'parent' @ [379:18] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isEmbeddedBreakOrContinue[LocalVariableDescriptor]

'parent' @ [383:39] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isEmbeddedBreakOrContinue[LocalVariableDescriptor]

'parent' @ [383:46] ==> public final val KtContainerNode.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'containerExpression' @ [384:13] ==> val containerExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isEmbeddedBreakOrContinue[LocalVariableDescriptor]

'isUsedAsExpression' @ [384:33] ==> public fun KtExpression.isUsedAsExpression(context: BindingContext): Boolean defined in org.jetbrains.kotlin.resolve.bindingContextUtil[DeserializedSimpleFunctionDescriptor]

'containerExpression' @ [384:52] ==> val containerExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.isEmbeddedBreakOrContinue[LocalVariableDescriptor]

'analyze' @ [384:72] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'PARTIAL' @ [384:96] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'statements' @ [392:17] ==> public final val statements: List<KtExpression> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'singleOrNull' @ [392:28] ==> public fun <T> List<KtExpression>.singleOrNull(): KtExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'this' @ [392:75] ==> <this> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.unwrapBlock[ReceiverParameterDescriptorImpl]

'this' @ [393:12] ==> <this> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.unwrapBlock[ReceiverParameterDescriptorImpl]

'copy' @ [393:17] ==> public final fun copy(outerLoop: KtForExpression = ..., innerLoop: KtForExpression = ..., statements: List<KtExpression> = ..., inputVariable: KtCallableDeclaration = ..., indexVariable: KtCallableDeclaration? = ..., lazySequence: Boolean = ..., pseudocodeProvider: () -> Pseudocode = ..., initializationStatementsToDelete: Collection<KtExpression> = ..., previousTransformations: MutableList<SequenceTransformation> = ..., incrementExpressions: Collection<KtUnaryExpression> = ...): MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[SimpleFunctionDescriptorImpl]

'block' @ [393:35] ==> val block: KtBlockExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.unwrapBlock[LocalVariableDescriptor]

'statements' @ [393:41] ==> public final val KtBlockExpression.statements: List<(KtExpression..KtExpression?)>[MyPropertyDescriptor]

