'component1' @ [73:18] ==> public final operator fun component1(): SequenceTransformation defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [73:34] ==> public final operator fun component2(): MatchingState defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'matchOneTransformation' @ [73:50] ==> private final fun matchOneTransformation(state: MatchingState): Pair<SequenceTransformation, MatchingState>? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher[SimpleFunctionDescriptorImpl]

'state' @ [73:73] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[ValueParameterDescriptorImpl]

'assert' @ [74:13] ==> @InlineOnly public inline fun assert(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'currentState' @ [74:20] ==> var currentState: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'indexVariable' @ [74:33] ==> public final val indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'state' @ [74:50] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[ValueParameterDescriptorImpl]

'indexVariable' @ [74:56] ==> public final val indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'transformation' @ [76:17] ==> var transformation: SequenceTransformation defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'Sequence' @ [77:44] ==> public constructor Sequence(transformation: SequenceTransformation, newState: MatchingState) defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.TransformationMatch.Sequence[ClassConstructorDescriptorImpl]

'transformation' @ [77:53] ==> var transformation: SequenceTransformation defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'currentState' @ [77:69] ==> var currentState: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'transformation' @ [80:36] ==> var transformation: SequenceTransformation defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'effectiveCondition' @ [80:51] ==> public abstract val effectiveCondition: Condition defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase[PropertyDescriptorImpl]

'toAtomicConditions' @ [80:70] ==> public abstract fun toAtomicConditions(): List<AtomicCondition> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.Condition[SimpleFunctionDescriptorImpl]

'toMutableList' @ [80:91] ==> public fun <T> Collection<AtomicCondition>.toMutableList(): MutableList<AtomicCondition> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> AtomicCondition

'currentState' @ [82:17] ==> var currentState: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'currentState' @ [82:32] ==> var currentState: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'unwrapBlock' @ [82:45] ==> public fun MatchingState.unwrapBlock(): MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file utils.kt[SimpleFunctionDescriptorImpl]

'!=' @ [84:21] ==> public open fun equals(other: Any?): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.TransformationMatch.Result[DeserializedSimpleFunctionDescriptor]

'match' @ [84:52] ==> public open fun match(state: MatchingState): TransformationMatch.Result? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.result.MaxOrMinTransformation.Matcher[SimpleFunctionDescriptorImpl]

'currentState' @ [84:58] ==> var currentState: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'component1' @ [86:22] ==> public final operator fun component1(): SequenceTransformation defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [86:42] ==> public final operator fun component2(): MatchingState defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'matchOneTransformation' @ [86:55] ==> private final fun matchOneTransformation(state: MatchingState): Pair<SequenceTransformation, MatchingState>? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher[SimpleFunctionDescriptorImpl]

'currentState' @ [86:78] ==> var currentState: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'nextTransformation' @ [87:21] ==> val nextTransformation: SequenceTransformation defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'assert' @ [88:17] ==> @InlineOnly public inline fun assert(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'nextState' @ [88:24] ==> val nextState: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'indexVariable' @ [88:34] ==> public final val indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'currentState' @ [88:51] ==> var currentState: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'indexVariable' @ [88:64] ==> public final val indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'atomicConditions' @ [90:17] ==> val atomicConditions: MutableList<AtomicCondition> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'addAll' @ [90:34] ==> public abstract fun addAll(elements: Collection<AtomicCondition>): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'nextTransformation' @ [90:41] ==> val nextTransformation: SequenceTransformation defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'effectiveCondition' @ [90:60] ==> public abstract val effectiveCondition: Condition defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase[PropertyDescriptorImpl]

'toAtomicConditions' @ [90:79] ==> public abstract fun toAtomicConditions(): List<AtomicCondition> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.Condition[SimpleFunctionDescriptorImpl]

'currentState' @ [92:17] ==> var currentState: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'nextState' @ [92:32] ==> val nextState: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'createTransformationsByAtomicConditions' @ [95:35] ==> private final fun createTransformationsByAtomicConditions(loop: KtForExpression, inputVariable: KtCallableDeclaration, indexVariable: KtCallableDeclaration?, conditions: List<AtomicCondition>, restStatements: List<KtExpression>): List<FilterTransformationBase> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher[SimpleFunctionDescriptorImpl]

'currentState' @ [96:21] ==> var currentState: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'outerLoop' @ [96:34] ==> public final val outerLoop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'currentState' @ [97:21] ==> var currentState: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'inputVariable' @ [97:34] ==> public final val inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'currentState' @ [98:21] ==> var currentState: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'indexVariable' @ [98:34] ==> public final val indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'atomicConditions' @ [99:21] ==> val atomicConditions: MutableList<AtomicCondition> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'currentState' @ [100:21] ==> var currentState: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'statements' @ [100:34] ==> public final val statements: List<KtExpression> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'assert' @ [101:13] ==> @InlineOnly public inline fun assert(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'transformations' @ [101:20] ==> val transformations: List<FilterTransformationBase> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'isNotEmpty' @ [101:36] ==> @InlineOnly public inline fun <T> Collection<FilterTransformationBase>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FilterTransformationBase

'FindTransformationMatcher' @ [103:43] ==> public object FindTransformationMatcher : TransformationMatcher defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.result in file FindTransformationMatcher.kt[FakeCallableDescriptorForObject]

'matchWithFilterBefore' @ [103:69] ==> public final fun matchWithFilterBefore(state: MatchingState, filterTransformation: FilterTransformationBase?): TransformationMatch.Result? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.result.FindTransformationMatcher[SimpleFunctionDescriptorImpl]

'currentState' @ [103:91] ==> var currentState: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'transformations' @ [103:105] ==> val transformations: List<FilterTransformationBase> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'last' @ [103:121] ==> public fun <T> List<FilterTransformationBase>.last(): FilterTransformationBase defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FilterTransformationBase

'if (findTransformationMatch != null) {
                TransformationMatch.Result(findTransformationMatch.resultTransformation,
                                           transformations.dropLast(1) + findTransformationMatch.sequenceTransformations)
            }
            else {
                TransformationMatch.Sequence(transformations, currentState)
            }' @ [104:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: TransformationMatch?, elseBranch: TransformationMatch?): TransformationMatch?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> TransformationMatch?

'findTransformationMatch' @ [104:24] ==> val findTransformationMatch: TransformationMatch.Result? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'Result' @ [105:37] ==> public constructor Result(resultTransformation: ResultTransformation, sequenceTransformations: List<SequenceTransformation>) defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.TransformationMatch.Result[ClassConstructorDescriptorImpl]

'findTransformationMatch' @ [105:44] ==> val findTransformationMatch: TransformationMatch.Result? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'resultTransformation' @ [105:68] ==> public final val resultTransformation: ResultTransformation defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.TransformationMatch.Result[PropertyDescriptorImpl]

'transformations' @ [106:44] ==> val transformations: List<FilterTransformationBase> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'dropLast' @ [106:60] ==> public fun <T> List<FilterTransformationBase>.dropLast(n: Int): List<FilterTransformationBase> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FilterTransformationBase

'findTransformationMatch' @ [106:74] ==> val findTransformationMatch: TransformationMatch.Result? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'sequenceTransformations' @ [106:98] ==> public final val sequenceTransformations: List<SequenceTransformation> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.TransformationMatch.Result[PropertyDescriptorImpl]

'Sequence' @ [109:37] ==> public constructor Sequence(transformations: List<SequenceTransformation>, newState: MatchingState) defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.TransformationMatch.Sequence[ClassConstructorDescriptorImpl]

'transformations' @ [109:46] ==> val transformations: List<FilterTransformationBase> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'currentState' @ [109:63] ==> var currentState: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.match[LocalVariableDescriptor]

'conditions' @ [120:17] ==> value-parameter conditions: List<AtomicCondition> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[ValueParameterDescriptorImpl]

'size' @ [120:28] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'listOf' @ [121:24] ==> public fun <T> listOf(element: FilterTransformationBase): List<FilterTransformationBase> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FilterTransformationBase

'createFilterTransformation' @ [121:31] ==> private final fun createFilterTransformation(loop: KtForExpression, inputVariable: KtCallableDeclaration, indexVariable: KtCallableDeclaration?, condition: Condition, onlyFilterOrFilterNot: Boolean = ...): FilterTransformationBase defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher[SimpleFunctionDescriptorImpl]

'loop' @ [121:58] ==> value-parameter loop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[ValueParameterDescriptorImpl]

'inputVariable' @ [121:64] ==> value-parameter inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[ValueParameterDescriptorImpl]

'indexVariable' @ [121:79] ==> value-parameter indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[ValueParameterDescriptorImpl]

'conditions' @ [121:94] ==> value-parameter conditions: List<AtomicCondition> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[ValueParameterDescriptorImpl]

'single' @ [121:105] ==> public fun <T> List<AtomicCondition>.single(): AtomicCondition defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> AtomicCondition

'conditions' @ [124:35] ==> value-parameter conditions: List<AtomicCondition> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[ValueParameterDescriptorImpl]

'map' @ [124:46] ==> public inline fun <T, R> Iterable<AtomicCondition>.map(transform: (AtomicCondition) -> FilterTransformationBase): List<FilterTransformationBase> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> AtomicCondition
    <R> -> FilterTransformationBase

'createFilterTransformation' @ [124:52] ==> private final fun createFilterTransformation(loop: KtForExpression, inputVariable: KtCallableDeclaration, indexVariable: KtCallableDeclaration?, condition: Condition, onlyFilterOrFilterNot: Boolean = ...): FilterTransformationBase defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher[SimpleFunctionDescriptorImpl]

'loop' @ [124:79] ==> value-parameter loop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[ValueParameterDescriptorImpl]

'inputVariable' @ [124:85] ==> value-parameter inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[ValueParameterDescriptorImpl]

'indexVariable' @ [124:100] ==> value-parameter indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[ValueParameterDescriptorImpl]

'it' @ [124:115] ==> value-parameter it: AtomicCondition defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions.<anonymous>[ValueParameterDescriptorImpl]

'ArrayList' @ [126:41] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> FilterTransformationBase

'transformations' @ [128:34] ==> var transformations: List<FilterTransformationBase> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'lastOrNull' @ [128:50] ==> public inline fun <T> List<FilterTransformationBase>.lastOrNull(predicate: (FilterTransformationBase) -> Boolean): FilterTransformationBase? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FilterTransformationBase

'it' @ [128:63] ==> value-parameter it: FilterTransformationBase defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions.<anonymous>[ValueParameterDescriptorImpl]

'indexVariable' @ [128:66] ==> public abstract val indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase[PropertyDescriptorImpl]

'lastUseOfIndex' @ [129:17] ==> val lastUseOfIndex: FilterTransformationBase? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'transformations' @ [130:29] ==> var transformations: List<FilterTransformationBase> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'indexOf' @ [130:45] ==> public abstract fun indexOf(element: FilterTransformationBase): Int defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'lastUseOfIndex' @ [130:53] ==> val lastUseOfIndex: FilterTransformationBase? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'CompositeCondition' @ [131:33] ==> public companion object defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.CompositeCondition[FakeCallableDescriptorForObject]

'create' @ [131:52] ==> public final fun create(conditions: List<AtomicCondition>): Condition defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.CompositeCondition.Companion[SimpleFunctionDescriptorImpl]

'conditions' @ [131:59] ==> value-parameter conditions: List<AtomicCondition> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[ValueParameterDescriptorImpl]

'take' @ [131:70] ==> public fun <T> Iterable<AtomicCondition>.take(n: Int): List<AtomicCondition> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> AtomicCondition

'index' @ [131:75] ==> val index: Int defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'resultTransformations' @ [132:17] ==> val resultTransformations: ArrayList<FilterTransformationBase> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'add' @ [132:39] ==> public open fun add(element: FilterTransformationBase): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'createFilterTransformation' @ [132:43] ==> private final fun createFilterTransformation(loop: KtForExpression, inputVariable: KtCallableDeclaration, indexVariable: KtCallableDeclaration?, condition: Condition, onlyFilterOrFilterNot: Boolean = ...): FilterTransformationBase defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher[SimpleFunctionDescriptorImpl]

'loop' @ [132:70] ==> value-parameter loop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[ValueParameterDescriptorImpl]

'inputVariable' @ [132:76] ==> value-parameter inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[ValueParameterDescriptorImpl]

'indexVariable' @ [132:91] ==> value-parameter indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[ValueParameterDescriptorImpl]

'condition' @ [132:106] ==> val condition: Condition defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'transformations' @ [133:17] ==> var transformations: List<FilterTransformationBase> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'transformations' @ [133:35] ==> var transformations: List<FilterTransformationBase> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'drop' @ [133:51] ==> public fun <T> Iterable<FilterTransformationBase>.drop(n: Int): List<FilterTransformationBase> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FilterTransformationBase

'index' @ [133:56] ==> val index: Int defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'component1' @ [136:19] ==> public final operator fun component1(): FilterTransformationBase defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [136:35] ==> public final operator fun component2(): AtomicCondition defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'transformations' @ [136:49] ==> var transformations: List<FilterTransformationBase> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'zip' @ [136:65] ==> public infix fun <T, R> Iterable<FilterTransformationBase>.zip(other: Iterable<AtomicCondition>): List<Pair<FilterTransformationBase, AtomicCondition>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FilterTransformationBase
    <R> -> AtomicCondition

'conditions' @ [136:69] ==> value-parameter conditions: List<AtomicCondition> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[ValueParameterDescriptorImpl]

'if (transformation !is FilterTransformation && isSmartCastUsed(inputVariable, restStatements)) { // filterIsInstance of filterNotNull
                    resultTransformations.add(transformation)
                }
                else {
                    val prevFilter = resultTransformations.lastOrNull() as? FilterTransformation
                    if (prevFilter != null) {
                        val mergedCondition = CompositeCondition.create(prevFilter.effectiveCondition.toAtomicConditions() + transformation.effectiveCondition.toAtomicConditions())
                        val mergedTransformation = createFilterTransformation(loop, inputVariable, indexVariable, mergedCondition, onlyFilterOrFilterNot = true)
                        resultTransformations[resultTransformations.lastIndex] = mergedTransformation
                    }
                    else {
                        resultTransformations.add(createFilterTransformation(loop, inputVariable, indexVariable, condition, onlyFilterOrFilterNot = true))
                    }
                }' @ [137:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any, elseBranch: Any): Any[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any

'transformation' @ [137:21] ==> val transformation: FilterTransformationBase defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'isSmartCastUsed' @ [137:64] ==> private final fun isSmartCastUsed(inputVariable: KtCallableDeclaration, statements: List<KtExpression>): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher[SimpleFunctionDescriptorImpl]

'inputVariable' @ [137:80] ==> value-parameter inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[ValueParameterDescriptorImpl]

'restStatements' @ [137:95] ==> value-parameter restStatements: List<KtExpression> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[ValueParameterDescriptorImpl]

'resultTransformations' @ [138:21] ==> val resultTransformations: ArrayList<FilterTransformationBase> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'add' @ [138:43] ==> public open fun add(element: FilterTransformationBase): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'transformation' @ [138:47] ==> val transformation: FilterTransformationBase defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'resultTransformations' @ [141:38] ==> val resultTransformations: ArrayList<FilterTransformationBase> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'lastOrNull' @ [141:60] ==> public fun <T> List<FilterTransformationBase>.lastOrNull(): FilterTransformationBase? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FilterTransformationBase

'if (prevFilter != null) {
                        val mergedCondition = CompositeCondition.create(prevFilter.effectiveCondition.toAtomicConditions() + transformation.effectiveCondition.toAtomicConditions())
                        val mergedTransformation = createFilterTransformation(loop, inputVariable, indexVariable, mergedCondition, onlyFilterOrFilterNot = true)
                        resultTransformations[resultTransformations.lastIndex] = mergedTransformation
                    }
                    else {
                        resultTransformations.add(createFilterTransformation(loop, inputVariable, indexVariable, condition, onlyFilterOrFilterNot = true))
                    }' @ [142:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any, elseBranch: Any): Any[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any

'prevFilter' @ [142:25] ==> val prevFilter: FilterTransformation? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'CompositeCondition' @ [143:47] ==> public companion object defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.CompositeCondition[FakeCallableDescriptorForObject]

'create' @ [143:66] ==> public final fun create(conditions: List<AtomicCondition>): Condition defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.CompositeCondition.Companion[SimpleFunctionDescriptorImpl]

'prevFilter' @ [143:73] ==> val prevFilter: FilterTransformation? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'effectiveCondition' @ [143:84] ==> public open val effectiveCondition: Condition defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformation[PropertyDescriptorImpl]

'toAtomicConditions' @ [143:103] ==> public abstract fun toAtomicConditions(): List<AtomicCondition> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.Condition[SimpleFunctionDescriptorImpl]

'transformation' @ [143:126] ==> val transformation: FilterTransformationBase defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'effectiveCondition' @ [143:141] ==> public abstract val effectiveCondition: Condition defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase[PropertyDescriptorImpl]

'toAtomicConditions' @ [143:160] ==> public abstract fun toAtomicConditions(): List<AtomicCondition> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.Condition[SimpleFunctionDescriptorImpl]

'createFilterTransformation' @ [144:52] ==> private final fun createFilterTransformation(loop: KtForExpression, inputVariable: KtCallableDeclaration, indexVariable: KtCallableDeclaration?, condition: Condition, onlyFilterOrFilterNot: Boolean = ...): FilterTransformationBase defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher[SimpleFunctionDescriptorImpl]

'loop' @ [144:79] ==> value-parameter loop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[ValueParameterDescriptorImpl]

'inputVariable' @ [144:85] ==> value-parameter inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[ValueParameterDescriptorImpl]

'indexVariable' @ [144:100] ==> value-parameter indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[ValueParameterDescriptorImpl]

'mergedCondition' @ [144:115] ==> val mergedCondition: Condition defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'resultTransformations' @ [145:25] ==> val resultTransformations: ArrayList<FilterTransformationBase> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'resultTransformations' @ [145:47] ==> val resultTransformations: ArrayList<FilterTransformationBase> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'lastIndex' @ [145:69] ==> public val <T> List<FilterTransformationBase>.lastIndex: Int defined in kotlin.collections[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> FilterTransformationBase

'mergedTransformation' @ [145:82] ==> val mergedTransformation: FilterTransformationBase defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'resultTransformations' @ [148:25] ==> val resultTransformations: ArrayList<FilterTransformationBase> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'add' @ [148:47] ==> public open fun add(element: FilterTransformationBase): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'createFilterTransformation' @ [148:51] ==> private final fun createFilterTransformation(loop: KtForExpression, inputVariable: KtCallableDeclaration, indexVariable: KtCallableDeclaration?, condition: Condition, onlyFilterOrFilterNot: Boolean = ...): FilterTransformationBase defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher[SimpleFunctionDescriptorImpl]

'loop' @ [148:78] ==> value-parameter loop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[ValueParameterDescriptorImpl]

'inputVariable' @ [148:84] ==> value-parameter inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[ValueParameterDescriptorImpl]

'indexVariable' @ [148:99] ==> value-parameter indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[ValueParameterDescriptorImpl]

'condition' @ [148:114] ==> val condition: AtomicCondition defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'resultTransformations' @ [152:20] ==> val resultTransformations: ArrayList<FilterTransformationBase> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createTransformationsByAtomicConditions[LocalVariableDescriptor]

'state' @ [156:31] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'statements' @ [156:37] ==> public final val statements: List<KtExpression> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'firstOrNull' @ [156:48] ==> public fun <T> List<KtExpression>.firstOrNull(): KtExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'ifStatement' @ [157:29] ==> val ifStatement: KtIfExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'condition' @ [157:41] ==> public final val KtIfExpression.condition: KtExpression?[MyPropertyDescriptor]

'ifStatement' @ [158:30] ==> val ifStatement: KtIfExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'then' @ [158:42] ==> public final val KtIfExpression.then: KtExpression?[MyPropertyDescriptor]

'ifStatement' @ [159:30] ==> val ifStatement: KtIfExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'`else`' @ [159:42] ==> public final val KtIfExpression.`else`: KtExpression?[MyPropertyDescriptor]

'if (elseBranch == null) {
                return matchOneTransformation(state, condition, false, thenBranch, state.statements.drop(1))
            }
            else if (state.statements.size == 1) {
                val thenStatement = thenBranch.blockExpressionsOrSingle().singleOrNull()
                if (thenStatement is KtBreakExpression || thenStatement is KtContinueExpression) {
                    return matchOneTransformation(state, condition, false, thenBranch, listOf(elseBranch))
                }

                val elseStatement = elseBranch.blockExpressionsOrSingle().singleOrNull()
                if (elseStatement is KtBreakExpression || elseStatement is KtContinueExpression) {
                    return matchOneTransformation(state, condition, true, elseBranch, listOf(thenBranch))
                }
            }' @ [161:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'elseBranch' @ [161:17] ==> val elseBranch: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'matchOneTransformation' @ [162:24] ==> private final fun matchOneTransformation(state: MatchingState, condition: KtExpression, negateCondition: Boolean, then: KtExpression, restStatements: List<KtExpression>): Pair<SequenceTransformation, MatchingState>? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher[SimpleFunctionDescriptorImpl]

'state' @ [162:47] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'condition' @ [162:54] ==> val condition: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'thenBranch' @ [162:72] ==> val thenBranch: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'state' @ [162:84] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'statements' @ [162:90] ==> public final val statements: List<KtExpression> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'drop' @ [162:101] ==> public fun <T> Iterable<KtExpression>.drop(n: Int): List<KtExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'state' @ [164:22] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'statements' @ [164:28] ==> public final val statements: List<KtExpression> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'size' @ [164:39] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'thenBranch' @ [165:37] ==> val thenBranch: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'blockExpressionsOrSingle' @ [165:48] ==> public fun KtElement.blockExpressionsOrSingle(): Sequence<KtElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'singleOrNull' @ [165:75] ==> public fun <T> Sequence<KtElement>.singleOrNull(): KtElement? defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtElement

'thenStatement' @ [166:21] ==> val thenStatement: KtElement? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'thenStatement' @ [166:59] ==> val thenStatement: KtElement? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'matchOneTransformation' @ [167:28] ==> private final fun matchOneTransformation(state: MatchingState, condition: KtExpression, negateCondition: Boolean, then: KtExpression, restStatements: List<KtExpression>): Pair<SequenceTransformation, MatchingState>? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher[SimpleFunctionDescriptorImpl]

'state' @ [167:51] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'condition' @ [167:58] ==> val condition: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'thenBranch' @ [167:76] ==> val thenBranch: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'listOf' @ [167:88] ==> public fun <T> listOf(element: KtExpression): List<KtExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'elseBranch' @ [167:95] ==> val elseBranch: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'elseBranch' @ [170:37] ==> val elseBranch: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'blockExpressionsOrSingle' @ [170:48] ==> public fun KtElement.blockExpressionsOrSingle(): Sequence<KtElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'singleOrNull' @ [170:75] ==> public fun <T> Sequence<KtElement>.singleOrNull(): KtElement? defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtElement

'elseStatement' @ [171:21] ==> val elseStatement: KtElement? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'elseStatement' @ [171:59] ==> val elseStatement: KtElement? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'matchOneTransformation' @ [172:28] ==> private final fun matchOneTransformation(state: MatchingState, condition: KtExpression, negateCondition: Boolean, then: KtExpression, restStatements: List<KtExpression>): Pair<SequenceTransformation, MatchingState>? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher[SimpleFunctionDescriptorImpl]

'state' @ [172:51] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'condition' @ [172:58] ==> val condition: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'elseBranch' @ [172:75] ==> val elseBranch: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'listOf' @ [172:87] ==> public fun <T> listOf(element: KtExpression): List<KtExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'thenBranch' @ [172:94] ==> val thenBranch: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'!' @ [188:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'state' @ [188:18] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'inputVariable' @ [188:24] ==> public final val inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'hasUsages' @ [188:38] ==> public fun KtCallableDeclaration.hasUsages(inElement: KtElement): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file commonUtils.kt[SimpleFunctionDescriptorImpl]

'condition' @ [188:48] ==> value-parameter condition: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'state' @ [188:63] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'indexVariable' @ [188:69] ==> public final val indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'!' @ [188:94] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'state' @ [188:95] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'indexVariable' @ [188:101] ==> public final val indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'hasUsages' @ [188:115] ==> public fun KtCallableDeclaration.hasUsages(inElement: KtElement): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file commonUtils.kt[SimpleFunctionDescriptorImpl]

'condition' @ [188:125] ==> value-parameter condition: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'if (restStatements.isEmpty()) {
                val transformation = createFilterTransformation(state.outerLoop, state.inputVariable, state.indexVariable, Condition.create(condition, negateCondition))
                val newState = state.copy(statements = listOf(then))
                return transformation to newState
            }
            else {
                val statement = then.blockExpressionsOrSingle().singleOrNull() ?: return null
                when (statement) {
                    is KtContinueExpression -> {
                        if (statement.targetLoop() != state.innerLoop) return null
                        val transformation = createFilterTransformation(state.outerLoop, state.inputVariable, state.indexVariable, Condition.create(condition, !negateCondition))
                        val newState = state.copy(statements = restStatements)
                        return transformation to newState
                    }

                    is KtBreakExpression -> {
                        if (statement.targetLoop() != state.outerLoop) return null
                        val transformation = TakeWhileTransformation(state.outerLoop, state.inputVariable, if (negateCondition) condition else condition.negate())
                        val newState = state.copy(statements = restStatements)
                        return transformation to newState
                    }

                    else -> return null
                }
            }' @ [190:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nothing, elseBranch: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nothing

'restStatements' @ [190:17] ==> value-parameter restStatements: List<KtExpression> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'isEmpty' @ [190:32] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'createFilterTransformation' @ [191:38] ==> private final fun createFilterTransformation(loop: KtForExpression, inputVariable: KtCallableDeclaration, indexVariable: KtCallableDeclaration?, condition: Condition, onlyFilterOrFilterNot: Boolean = ...): FilterTransformationBase defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher[SimpleFunctionDescriptorImpl]

'state' @ [191:65] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'outerLoop' @ [191:71] ==> public final val outerLoop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'state' @ [191:82] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'inputVariable' @ [191:88] ==> public final val inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'state' @ [191:103] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'indexVariable' @ [191:109] ==> public final val indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'Condition' @ [191:124] ==> public companion object defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.Condition[FakeCallableDescriptorForObject]

'create' @ [191:134] ==> public final fun create(expression: KtExpression, negated: Boolean = ...): Condition defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.Condition.Companion[SimpleFunctionDescriptorImpl]

'condition' @ [191:141] ==> value-parameter condition: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'negateCondition' @ [191:152] ==> value-parameter negateCondition: Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'state' @ [192:32] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'copy' @ [192:38] ==> public final fun copy(outerLoop: KtForExpression = ..., innerLoop: KtForExpression = ..., statements: List<KtExpression> = ..., inputVariable: KtCallableDeclaration = ..., indexVariable: KtCallableDeclaration? = ..., lazySequence: Boolean = ..., pseudocodeProvider: () -> Pseudocode = ..., initializationStatementsToDelete: Collection<KtExpression> = ..., previousTransformations: MutableList<SequenceTransformation> = ..., incrementExpressions: Collection<KtUnaryExpression> = ...): MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[SimpleFunctionDescriptorImpl]

'listOf' @ [192:56] ==> public fun <T> listOf(element: KtExpression): List<KtExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'then' @ [192:63] ==> value-parameter then: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'transformation' @ [193:24] ==> val transformation: FilterTransformationBase defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'newState' @ [193:42] ==> val newState: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'then' @ [196:33] ==> value-parameter then: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'blockExpressionsOrSingle' @ [196:38] ==> public fun KtElement.blockExpressionsOrSingle(): Sequence<KtElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'singleOrNull' @ [196:65] ==> public fun <T> Sequence<KtElement>.singleOrNull(): KtElement? defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtElement

'when (statement) {
                    is KtContinueExpression -> {
                        if (statement.targetLoop() != state.innerLoop) return null
                        val transformation = createFilterTransformation(state.outerLoop, state.inputVariable, state.indexVariable, Condition.create(condition, !negateCondition))
                        val newState = state.copy(statements = restStatements)
                        return transformation to newState
                    }

                    is KtBreakExpression -> {
                        if (statement.targetLoop() != state.outerLoop) return null
                        val transformation = TakeWhileTransformation(state.outerLoop, state.inputVariable, if (negateCondition) condition else condition.negate())
                        val newState = state.copy(statements = restStatements)
                        return transformation to newState
                    }

                    else -> return null
                }' @ [197:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Nothing, entry1: Nothing, entry2: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Nothing

'statement' @ [197:23] ==> val statement: KtElement defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'statement' @ [199:29] ==> val statement: KtElement defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'targetLoop' @ [199:39] ==> public fun KtExpressionWithLabel.targetLoop(): KtLoopExpression? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file commonUtils.kt[SimpleFunctionDescriptorImpl]

'state' @ [199:55] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'innerLoop' @ [199:61] ==> public final val innerLoop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'createFilterTransformation' @ [200:46] ==> private final fun createFilterTransformation(loop: KtForExpression, inputVariable: KtCallableDeclaration, indexVariable: KtCallableDeclaration?, condition: Condition, onlyFilterOrFilterNot: Boolean = ...): FilterTransformationBase defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher[SimpleFunctionDescriptorImpl]

'state' @ [200:73] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'outerLoop' @ [200:79] ==> public final val outerLoop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'state' @ [200:90] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'inputVariable' @ [200:96] ==> public final val inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'state' @ [200:111] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'indexVariable' @ [200:117] ==> public final val indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'Condition' @ [200:132] ==> public companion object defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.Condition[FakeCallableDescriptorForObject]

'create' @ [200:142] ==> public final fun create(expression: KtExpression, negated: Boolean = ...): Condition defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.Condition.Companion[SimpleFunctionDescriptorImpl]

'condition' @ [200:149] ==> value-parameter condition: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'!' @ [200:160] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'negateCondition' @ [200:161] ==> value-parameter negateCondition: Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'state' @ [201:40] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'copy' @ [201:46] ==> public final fun copy(outerLoop: KtForExpression = ..., innerLoop: KtForExpression = ..., statements: List<KtExpression> = ..., inputVariable: KtCallableDeclaration = ..., indexVariable: KtCallableDeclaration? = ..., lazySequence: Boolean = ..., pseudocodeProvider: () -> Pseudocode = ..., initializationStatementsToDelete: Collection<KtExpression> = ..., previousTransformations: MutableList<SequenceTransformation> = ..., incrementExpressions: Collection<KtUnaryExpression> = ...): MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[SimpleFunctionDescriptorImpl]

'restStatements' @ [201:64] ==> value-parameter restStatements: List<KtExpression> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'transformation' @ [202:32] ==> val transformation: FilterTransformationBase defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'newState' @ [202:50] ==> val newState: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'statement' @ [206:29] ==> val statement: KtElement defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'targetLoop' @ [206:39] ==> public fun KtExpressionWithLabel.targetLoop(): KtLoopExpression? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file commonUtils.kt[SimpleFunctionDescriptorImpl]

'state' @ [206:55] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'outerLoop' @ [206:61] ==> public final val outerLoop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'TakeWhileTransformation' @ [207:46] ==> public constructor TakeWhileTransformation(loop: KtForExpression, inputVariable: KtCallableDeclaration, condition: KtExpression) defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.TakeWhileTransformation[ClassConstructorDescriptorImpl]

'state' @ [207:70] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'outerLoop' @ [207:76] ==> public final val outerLoop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'state' @ [207:87] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'inputVariable' @ [207:93] ==> public final val inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'if (negateCondition) condition else condition.negate()' @ [207:108] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtExpression, elseBranch: KtExpression): KtExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtExpression

'negateCondition' @ [207:112] ==> value-parameter negateCondition: Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'condition' @ [207:129] ==> value-parameter condition: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'condition' @ [207:144] ==> value-parameter condition: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'negate' @ [207:154] ==> public fun KtExpression.negate(): KtExpression defined in org.jetbrains.kotlin.idea.intentions in file Utils.kt[SimpleFunctionDescriptorImpl]

'state' @ [208:40] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'copy' @ [208:46] ==> public final fun copy(outerLoop: KtForExpression = ..., innerLoop: KtForExpression = ..., statements: List<KtExpression> = ..., inputVariable: KtCallableDeclaration = ..., indexVariable: KtCallableDeclaration? = ..., lazySequence: Boolean = ..., pseudocodeProvider: () -> Pseudocode = ..., initializationStatementsToDelete: Collection<KtExpression> = ..., previousTransformations: MutableList<SequenceTransformation> = ..., incrementExpressions: Collection<KtUnaryExpression> = ...): MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[SimpleFunctionDescriptorImpl]

'restStatements' @ [208:64] ==> value-parameter restStatements: List<KtExpression> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[ValueParameterDescriptorImpl]

'transformation' @ [209:32] ==> val transformation: TakeWhileTransformation defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'newState' @ [209:50] ==> val newState: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.matchOneTransformation[LocalVariableDescriptor]

'indexVariable' @ [225:17] ==> value-parameter indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[ValueParameterDescriptorImpl]

'condition' @ [225:42] ==> value-parameter condition: Condition defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[ValueParameterDescriptorImpl]

'hasUsagesOf' @ [225:52] ==> public fun Condition.hasUsagesOf(variable: KtCallableDeclaration): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence in file Condition.kt[SimpleFunctionDescriptorImpl]

'indexVariable' @ [225:64] ==> value-parameter indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[ValueParameterDescriptorImpl]

'FilterTransformation' @ [226:24] ==> public constructor FilterTransformation(loop: KtForExpression, inputVariable: KtCallableDeclaration, indexVariable: KtCallableDeclaration?, effectiveCondition: Condition, isFilterNot: Boolean) defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformation[ClassConstructorDescriptorImpl]

'loop' @ [226:45] ==> value-parameter loop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[ValueParameterDescriptorImpl]

'inputVariable' @ [226:51] ==> value-parameter inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[ValueParameterDescriptorImpl]

'indexVariable' @ [226:66] ==> value-parameter indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[ValueParameterDescriptorImpl]

'condition' @ [226:81] ==> value-parameter condition: Condition defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[ValueParameterDescriptorImpl]

'condition' @ [229:41] ==> value-parameter condition: Condition defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[ValueParameterDescriptorImpl]

'asExpression' @ [229:51] ==> public abstract fun asExpression(): KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.Condition[SimpleFunctionDescriptorImpl]

'!' @ [230:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'onlyFilterOrFilterNot' @ [230:18] ==> value-parameter onlyFilterOrFilterNot: Boolean = ... defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[ValueParameterDescriptorImpl]

'conditionAsExpression' @ [231:21] ==> val conditionAsExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[LocalVariableDescriptor]

'!' @ [232:24] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'conditionAsExpression' @ [232:25] ==> val conditionAsExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[LocalVariableDescriptor]

'isNegated' @ [232:47] ==> public final val KtIsExpression.isNegated: Boolean[MyPropertyDescriptor]

'conditionAsExpression' @ [233:24] ==> val conditionAsExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[LocalVariableDescriptor]

'leftHandSide' @ [233:46] ==> public final val KtIsExpression.leftHandSide: KtExpression[MyPropertyDescriptor]

'isSimpleName' @ [233:59] ==> public fun KtExpression?.isSimpleName(name: Name): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file commonUtils.kt[SimpleFunctionDescriptorImpl]

'inputVariable' @ [233:72] ==> value-parameter inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[ValueParameterDescriptorImpl]

'nameAsSafeName' @ [233:86] ==> public final val KtCallableDeclaration.nameAsSafeName: Name[MyPropertyDescriptor]

'conditionAsExpression' @ [235:35] ==> val conditionAsExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[LocalVariableDescriptor]

'typeReference' @ [235:57] ==> public final val KtIsExpression.typeReference: KtTypeReference?[MyPropertyDescriptor]

'typeRef' @ [236:25] ==> val typeRef: KtTypeReference? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[LocalVariableDescriptor]

'FilterIsInstanceTransformation' @ [237:32] ==> public constructor FilterIsInstanceTransformation(loop: KtForExpression, inputVariable: KtCallableDeclaration, type: KtTypeReference, effectiveCondition: Condition) defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterIsInstanceTransformation[ClassConstructorDescriptorImpl]

'loop' @ [237:63] ==> value-parameter loop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[ValueParameterDescriptorImpl]

'inputVariable' @ [237:69] ==> value-parameter inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[ValueParameterDescriptorImpl]

'typeRef' @ [237:84] ==> val typeRef: KtTypeReference? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[LocalVariableDescriptor]

'condition' @ [237:93] ==> value-parameter condition: Condition defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[ValueParameterDescriptorImpl]

'conditionAsExpression' @ [241:21] ==> val conditionAsExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[LocalVariableDescriptor]

'conditionAsExpression' @ [242:24] ==> val conditionAsExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[LocalVariableDescriptor]

'operationToken' @ [242:46] ==> public final val KtBinaryExpression.operationToken: IElementType[MyPropertyDescriptor]

'EXCLEQ' @ [242:73] ==> public final val EXCLEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'conditionAsExpression' @ [243:24] ==> val conditionAsExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[LocalVariableDescriptor]

'right' @ [243:46] ==> public final val KtBinaryExpression.right: KtExpression?[MyPropertyDescriptor]

'isNullExpression' @ [243:52] ==> public fun KtExpression?.isNullExpression(): Boolean defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations in file IfThenUtils.kt[SimpleFunctionDescriptorImpl]

'conditionAsExpression' @ [244:24] ==> val conditionAsExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[LocalVariableDescriptor]

'left' @ [244:46] ==> public final val KtBinaryExpression.left: KtExpression?[MyPropertyDescriptor]

'isSimpleName' @ [244:51] ==> public fun KtExpression?.isSimpleName(name: Name): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file commonUtils.kt[SimpleFunctionDescriptorImpl]

'inputVariable' @ [244:64] ==> value-parameter inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[ValueParameterDescriptorImpl]

'nameAsSafeName' @ [244:78] ==> public final val KtCallableDeclaration.nameAsSafeName: Name[MyPropertyDescriptor]

'FilterNotNullTransformation' @ [246:28] ==> public constructor FilterNotNullTransformation(loop: KtForExpression, inputVariable: KtCallableDeclaration, effectiveCondition: Condition) defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterNotNullTransformation[ClassConstructorDescriptorImpl]

'loop' @ [246:56] ==> value-parameter loop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[ValueParameterDescriptorImpl]

'inputVariable' @ [246:62] ==> value-parameter inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[ValueParameterDescriptorImpl]

'condition' @ [246:77] ==> value-parameter condition: Condition defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[ValueParameterDescriptorImpl]

'conditionAsExpression' @ [250:17] ==> val conditionAsExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[LocalVariableDescriptor]

'conditionAsExpression' @ [250:64] ==> val conditionAsExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[LocalVariableDescriptor]

'operationToken' @ [250:86] ==> public final val KtPrefixExpression.operationToken: (IElementType..IElementType?)[MyPropertyDescriptor]

'EXCL' @ [250:113] ==> public final val EXCL: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'FilterTransformation' @ [251:24] ==> public constructor FilterTransformation(loop: KtForExpression, inputVariable: KtCallableDeclaration, indexVariable: KtCallableDeclaration?, effectiveCondition: Condition, isFilterNot: Boolean) defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformation[ClassConstructorDescriptorImpl]

'loop' @ [251:45] ==> value-parameter loop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[ValueParameterDescriptorImpl]

'inputVariable' @ [251:51] ==> value-parameter inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[ValueParameterDescriptorImpl]

'condition' @ [251:72] ==> value-parameter condition: Condition defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[ValueParameterDescriptorImpl]

'FilterTransformation' @ [254:20] ==> public constructor FilterTransformation(loop: KtForExpression, inputVariable: KtCallableDeclaration, indexVariable: KtCallableDeclaration?, effectiveCondition: Condition, isFilterNot: Boolean) defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformation[ClassConstructorDescriptorImpl]

'loop' @ [254:41] ==> value-parameter loop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[ValueParameterDescriptorImpl]

'inputVariable' @ [254:47] ==> value-parameter inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[ValueParameterDescriptorImpl]

'condition' @ [254:68] ==> value-parameter condition: Condition defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.createFilterTransformation[ValueParameterDescriptorImpl]

'statements' @ [258:20] ==> value-parameter statements: List<KtExpression> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.isSmartCastUsed[ValueParameterDescriptorImpl]

'any' @ [258:31] ==> public inline fun <T> Iterable<KtExpression>.any(predicate: (KtExpression) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'statement' @ [259:17] ==> value-parameter statement: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.isSmartCastUsed.<anonymous>[ValueParameterDescriptorImpl]

'anyDescendantOfType' @ [259:27] ==> public inline fun <reified T : PsiElement> PsiElement.anyDescendantOfType(noinline predicate: (KtNameReferenceExpression) -> Boolean = ...): Boolean defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtNameReferenceExpression

'it' @ [260:21] ==> value-parameter it: KtNameReferenceExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.isSmartCastUsed.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'mainReference' @ [260:24] ==> public val KtSimpleNameExpression.mainReference: KtSimpleNameReference defined in org.jetbrains.kotlin.idea.references[DeserializedPropertyDescriptor]

'resolve' @ [260:38] ==> @Nullable public open fun resolve(): PsiElement? defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[JavaMethodDescriptor]

'inputVariable' @ [260:51] ==> value-parameter inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.isSmartCastUsed[ValueParameterDescriptorImpl]

'it' @ [260:68] ==> value-parameter it: KtNameReferenceExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.isSmartCastUsed.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'analyze' @ [260:71] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'PARTIAL' @ [260:95] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'SMARTCAST' @ [260:119] ==> public final val SMARTCAST: (WritableSlice<(KtExpression..KtExpression?), (ExplicitSmartCasts..ExplicitSmartCasts?)>..WritableSlice<(KtExpression..KtExpression?), (ExplicitSmartCasts..ExplicitSmartCasts?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'it' @ [260:130] ==> value-parameter it: KtNameReferenceExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase.Matcher.isSmartCastUsed.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'FilterTransformationBase' @ [273:5] ==> public constructor FilterTransformationBase() defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase[ClassConstructorDescriptorImpl]

'isFilterNot' @ [276:13] ==> public final val isFilterNot: Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformation[PropertyDescriptorImpl]

'assert' @ [277:13] ==> @InlineOnly public inline fun assert(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'indexVariable' @ [277:20] ==> public open val indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformation[PropertyDescriptorImpl]

'when {
        indexVariable != null -> "filterIndexed"
        isFilterNot -> "filterNot"
        else -> "filter"
    }' @ [281:32] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: String, entry1: String, entry2: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> String

'indexVariable' @ [282:9] ==> public open val indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformation[PropertyDescriptorImpl]

'isFilterNot' @ [283:9] ==> public final val isFilterNot: Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformation[PropertyDescriptorImpl]

'functionName' @ [288:19] ==> private final val functionName: String defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformation[PropertyDescriptorImpl]

'if (indexVariable != null)
            generateLambda(inputVariable, indexVariable, effectiveCondition.asExpression())
        else
            generateLambda(inputVariable, if (isFilterNot) effectiveCondition.asNegatedExpression() else effectiveCondition.asExpression())' @ [291:22] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtLambdaExpression, elseBranch: KtLambdaExpression): KtLambdaExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtLambdaExpression

'indexVariable' @ [291:26] ==> public open val indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformation[PropertyDescriptorImpl]

'generateLambda' @ [292:13] ==> public fun generateLambda(inputVariable: KtCallableDeclaration, indexVariable: KtCallableDeclaration?, expression: KtExpression): KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file utils.kt[SimpleFunctionDescriptorImpl]

'inputVariable' @ [292:28] ==> public open val inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformation[PropertyDescriptorImpl]

'indexVariable' @ [292:43] ==> public open val indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformation[PropertyDescriptorImpl]

'effectiveCondition' @ [292:58] ==> public open val effectiveCondition: Condition defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformation[PropertyDescriptorImpl]

'asExpression' @ [292:77] ==> public abstract fun asExpression(): KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.Condition[SimpleFunctionDescriptorImpl]

'generateLambda' @ [294:13] ==> public fun generateLambda(inputVariable: KtCallableDeclaration, expression: KtExpression): KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file utils.kt[SimpleFunctionDescriptorImpl]

'inputVariable' @ [294:28] ==> public open val inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformation[PropertyDescriptorImpl]

'if (isFilterNot) effectiveCondition.asNegatedExpression() else effectiveCondition.asExpression()' @ [294:43] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtExpression, elseBranch: KtExpression): KtExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtExpression

'isFilterNot' @ [294:47] ==> public final val isFilterNot: Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformation[PropertyDescriptorImpl]

'effectiveCondition' @ [294:60] ==> public open val effectiveCondition: Condition defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformation[PropertyDescriptorImpl]

'asNegatedExpression' @ [294:79] ==> public abstract fun asNegatedExpression(): KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.Condition[SimpleFunctionDescriptorImpl]

'effectiveCondition' @ [294:106] ==> public open val effectiveCondition: Condition defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformation[PropertyDescriptorImpl]

'asExpression' @ [294:125] ==> public abstract fun asExpression(): KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.Condition[SimpleFunctionDescriptorImpl]

'chainedCallGenerator' @ [295:16] ==> value-parameter chainedCallGenerator: ChainedCallGenerator defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformation.generateCode[ValueParameterDescriptorImpl]

'generate' @ [295:37] ==> public abstract fun generate(pattern: String, vararg args: Any, receiver: KtExpression = ..., safeCall: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.ChainedCallGenerator[SimpleFunctionDescriptorImpl]

'functionName' @ [295:59] ==> private final val functionName: String defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformation[PropertyDescriptorImpl]

'lambda' @ [295:73] ==> val lambda: KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformation.generateCode[LocalVariableDescriptor]

'FilterTransformationBase' @ [304:5] ==> public constructor FilterTransformationBase() defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase[ClassConstructorDescriptorImpl]

'chainedCallGenerator' @ [312:16] ==> value-parameter chainedCallGenerator: ChainedCallGenerator defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterIsInstanceTransformation.generateCode[ValueParameterDescriptorImpl]

'generate' @ [312:37] ==> public abstract fun generate(pattern: String, vararg args: Any, receiver: KtExpression = ..., safeCall: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.ChainedCallGenerator[SimpleFunctionDescriptorImpl]

'type' @ [312:72] ==> private final val type: KtTypeReference defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterIsInstanceTransformation[PropertyDescriptorImpl]

'FilterTransformationBase' @ [320:5] ==> public constructor FilterTransformationBase() defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterTransformationBase[ClassConstructorDescriptorImpl]

'previousTransformation' @ [325:13] ==> value-parameter previousTransformation: SequenceTransformation defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterNotNullTransformation.mergeWithPrevious[ValueParameterDescriptorImpl]

'MapTransformation' @ [326:20] ==> public constructor MapTransformation(loop: KtForExpression, inputVariable: KtCallableDeclaration, indexVariable: KtCallableDeclaration?, mapping: KtExpression, mapNotNull: Boolean) defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.MapTransformation[ClassConstructorDescriptorImpl]

'loop' @ [326:38] ==> public open val loop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterNotNullTransformation[PropertyDescriptorImpl]

'previousTransformation' @ [326:44] ==> value-parameter previousTransformation: SequenceTransformation defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterNotNullTransformation.mergeWithPrevious[ValueParameterDescriptorImpl]

'inputVariable' @ [326:67] ==> public final val inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.MapTransformation[PropertyDescriptorImpl]

'previousTransformation' @ [326:82] ==> value-parameter previousTransformation: SequenceTransformation defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterNotNullTransformation.mergeWithPrevious[ValueParameterDescriptorImpl]

'indexVariable' @ [326:105] ==> public final val indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.MapTransformation[PropertyDescriptorImpl]

'previousTransformation' @ [326:120] ==> value-parameter previousTransformation: SequenceTransformation defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterNotNullTransformation.mergeWithPrevious[ValueParameterDescriptorImpl]

'mapping' @ [326:143] ==> public final val mapping: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.MapTransformation[PropertyDescriptorImpl]

'chainedCallGenerator' @ [335:16] ==> value-parameter chainedCallGenerator: ChainedCallGenerator defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FilterNotNullTransformation.generateCode[ValueParameterDescriptorImpl]

'generate' @ [335:37] ==> public abstract fun generate(pattern: String, vararg args: Any, receiver: KtExpression = ..., safeCall: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.ChainedCallGenerator[SimpleFunctionDescriptorImpl]

'generateLambda' @ [354:22] ==> public fun generateLambda(inputVariable: KtCallableDeclaration, expression: KtExpression): KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file utils.kt[SimpleFunctionDescriptorImpl]

'inputVariable' @ [354:37] ==> public final val inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.TakeWhileTransformation[PropertyDescriptorImpl]

'condition' @ [354:52] ==> public final val condition: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.TakeWhileTransformation[PropertyDescriptorImpl]

'chainedCallGenerator' @ [355:16] ==> value-parameter chainedCallGenerator: ChainedCallGenerator defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.TakeWhileTransformation.generateCode[ValueParameterDescriptorImpl]

'generate' @ [355:37] ==> public abstract fun generate(pattern: String, vararg args: Any, receiver: KtExpression = ..., safeCall: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.ChainedCallGenerator[SimpleFunctionDescriptorImpl]

'lambda' @ [355:66] ==> val lambda: KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.TakeWhileTransformation.generateCode[LocalVariableDescriptor]

