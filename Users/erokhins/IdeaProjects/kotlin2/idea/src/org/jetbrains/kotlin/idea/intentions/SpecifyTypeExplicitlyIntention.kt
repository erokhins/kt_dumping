'SelfTargetingRangeIntention<KtCallableDeclaration>' @ [49:9] ==> public constructor SelfTargetingRangeIntention<TElement : PsiElement>(elementType: Class<KtCallableDeclaration>, text: String, familyName: String = ...) defined in org.jetbrains.kotlin.idea.intentions.SelfTargetingRangeIntention[DeserializedClassConstructorDescriptor]
Inferred types:
    <TElement : PsiElement> -> KtCallableDeclaration

'java' @ [49:89] ==> public val <T> KClass<KtCallableDeclaration>.java: Class<KtCallableDeclaration> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtCallableDeclaration

'element' @ [53:13] ==> value-parameter element: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.applicabilityRange[ValueParameterDescriptorImpl]

'containingFile' @ [53:21] ==> public final val KtCallableDeclaration.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'element' @ [54:13] ==> value-parameter element: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.applicabilityRange[ValueParameterDescriptorImpl]

'element' @ [55:13] ==> value-parameter element: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.applicabilityRange[ValueParameterDescriptorImpl]

'element' @ [56:13] ==> value-parameter element: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.applicabilityRange[ValueParameterDescriptorImpl]

'typeReference' @ [56:21] ==> public final var KtCallableDeclaration.typeReference: KtTypeReference?[MyPropertyDescriptor]

'getTypeForDeclaration' @ [58:13] ==> public final fun getTypeForDeclaration(declaration: KtCallableDeclaration): KotlinType defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion[SimpleFunctionDescriptorImpl]

'element' @ [58:35] ==> value-parameter element: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.applicabilityRange[ValueParameterDescriptorImpl]

'isError' @ [58:44] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types[DeserializedPropertyDescriptor]

'element' @ [60:13] ==> value-parameter element: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.applicabilityRange[ValueParameterDescriptorImpl]

'element' @ [60:43] ==> value-parameter element: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.applicabilityRange[ValueParameterDescriptorImpl]

'hasBlockBody' @ [60:51] ==> public open fun hasBlockBody(): Boolean defined in org.jetbrains.kotlin.psi.KtNamedFunction[JavaMethodDescriptor]

'text' @ [62:9] ==> public final var SpecifyTypeExplicitlyIntention.text: String[MyPropertyDescriptor]

'if (element is KtFunction) "Specify return type explicitly" else "Specify type explicitly"' @ [62:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'element' @ [62:20] ==> value-parameter element: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.applicabilityRange[ValueParameterDescriptorImpl]

'element' @ [64:28] ==> value-parameter element: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.applicabilityRange[ValueParameterDescriptorImpl]

'initializer' @ [64:71] ==> public final val KtDeclarationWithInitializer.initializer: KtExpression?[MyPropertyDescriptor]

'if (initializer != null) {
            TextRange(element.startOffset, initializer.startOffset - 1)
        }
        else {
            TextRange(element.startOffset, element.endOffset)
        }' @ [65:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: TextRange?, elseBranch: TextRange?): TextRange?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> TextRange?

'initializer' @ [65:20] ==> val initializer: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.applicabilityRange[LocalVariableDescriptor]

'TextRange' @ [66:13] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'element' @ [66:23] ==> value-parameter element: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.applicabilityRange[ValueParameterDescriptorImpl]

'startOffset' @ [66:31] ==> public val PsiElement.startOffset: Int defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'initializer' @ [66:44] ==> val initializer: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.applicabilityRange[LocalVariableDescriptor]

'startOffset' @ [66:56] ==> public val PsiElement.startOffset: Int defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'TextRange' @ [69:13] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'element' @ [69:23] ==> value-parameter element: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.applicabilityRange[ValueParameterDescriptorImpl]

'startOffset' @ [69:31] ==> public val PsiElement.startOffset: Int defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'element' @ [69:44] ==> value-parameter element: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.applicabilityRange[ValueParameterDescriptorImpl]

'endOffset' @ [69:52] ==> public val PsiElement.endOffset: Int defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'getTypeForDeclaration' @ [74:20] ==> public final fun getTypeForDeclaration(declaration: KtCallableDeclaration): KotlinType defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion[SimpleFunctionDescriptorImpl]

'element' @ [74:42] ==> value-parameter element: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.applyTo[ValueParameterDescriptorImpl]

'addTypeAnnotation' @ [75:9] ==> public final fun addTypeAnnotation(editor: Editor?, declaration: KtCallableDeclaration, exprType: KotlinType): Unit defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion[SimpleFunctionDescriptorImpl]

'editor' @ [75:27] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.applyTo[ValueParameterDescriptorImpl]

'element' @ [75:35] ==> value-parameter element: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.applyTo[ValueParameterDescriptorImpl]

'type' @ [75:44] ==> val type: KotlinType defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.applyTo[LocalVariableDescriptor]

'setter' @ [80:21] ==> public abstract val setter: PropertySetterDescriptor? defined in org.jetbrains.kotlin.descriptors.PropertyDescriptor[JavaPropertyDescriptor]

'valueParameters' @ [80:29] ==> public final val PropertySetterDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'firstOrNull' @ [80:46] ==> public fun <T> List<(ValueParameterDescriptor..ValueParameterDescriptor?)>.firstOrNull(): ValueParameterDescriptor? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)

'type' @ [80:61] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'let' @ [80:67] ==> @InlineOnly public inline fun <T, R> KotlinType.let(block: (KotlinType) -> KotlinType?): KotlinType? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType
    <R> -> KotlinType?

'if (it.isError) null else it' @ [80:73] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType?, elseBranch: KotlinType?): KotlinType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType?

'it' @ [80:77] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.<get-setterType>.<anonymous>[ValueParameterDescriptorImpl]

'isError' @ [80:80] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types[DeserializedPropertyDescriptor]

'it' @ [80:99] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.<get-setterType>.<anonymous>[ValueParameterDescriptorImpl]

'when (declaration) {
                is KtFunction -> if (declaration.isLocal || declaration.hasDeclaredReturnType()) return null
                is KtProperty -> if (declaration.isLocal || declaration.typeReference != null) return null
                else -> return null
            }' @ [85:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'declaration' @ [85:19] ==> value-parameter declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.dangerousFlexibleTypeOrNull[ValueParameterDescriptorImpl]

'declaration' @ [86:38] ==> value-parameter declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.dangerousFlexibleTypeOrNull[ValueParameterDescriptorImpl]

'isLocal' @ [86:50] ==> public final val KtFunction.isLocal: Boolean[MyPropertyDescriptor]

'declaration' @ [86:61] ==> value-parameter declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.dangerousFlexibleTypeOrNull[ValueParameterDescriptorImpl]

'hasDeclaredReturnType' @ [86:73] ==> public abstract fun hasDeclaredReturnType(): Boolean defined in org.jetbrains.kotlin.psi.KtFunction[JavaMethodDescriptor]

'declaration' @ [87:38] ==> value-parameter declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.dangerousFlexibleTypeOrNull[ValueParameterDescriptorImpl]

'isLocal' @ [87:50] ==> public final val KtProperty.isLocal: Boolean[MyPropertyDescriptor]

'declaration' @ [87:61] ==> value-parameter declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.dangerousFlexibleTypeOrNull[ValueParameterDescriptorImpl]

'typeReference' @ [87:73] ==> public final var KtProperty.typeReference: KtTypeReference?[MyPropertyDescriptor]

'declaration' @ [91:17] ==> value-parameter declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.dangerousFlexibleTypeOrNull[ValueParameterDescriptorImpl]

'containingClassOrObject' @ [91:29] ==> public val KtDeclaration.containingClassOrObject: KtClassOrObject? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'isLocal' @ [91:54] ==> public final val KtClassOrObject.isLocal: Boolean[MyPropertyDescriptor]

'declaration' @ [93:28] ==> value-parameter declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.dangerousFlexibleTypeOrNull[ValueParameterDescriptorImpl]

'resolveToDescriptorIfAny' @ [93:40] ==> public fun KtDeclaration.resolveToDescriptorIfAny(bodyResolveMode: BodyResolveMode = ...): DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'publicAPIOnly' @ [94:17] ==> value-parameter publicAPIOnly: Boolean defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.dangerousFlexibleTypeOrNull[ValueParameterDescriptorImpl]

'!' @ [94:34] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'callable' @ [94:35] ==> val callable: CallableDescriptor defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.dangerousFlexibleTypeOrNull[LocalVariableDescriptor]

'visibility' @ [94:44] ==> public final val CallableDescriptor.visibility: Visibility[MyPropertyDescriptor]

'isPublicAPI' @ [94:55] ==> public final val isPublicAPI: Boolean defined in org.jetbrains.kotlin.descriptors.Visibility[DeserializedPropertyDescriptor]

'callable' @ [95:24] ==> val callable: CallableDescriptor defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.dangerousFlexibleTypeOrNull[LocalVariableDescriptor]

'returnType' @ [95:33] ==> public final val CallableDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'if (reportPlatformArguments) {
                if (!type.isFlexibleRecursive()) return null
            }
            else {
                if (!type.isFlexible()) return null
            }' @ [96:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'reportPlatformArguments' @ [96:17] ==> value-parameter reportPlatformArguments: Boolean defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.dangerousFlexibleTypeOrNull[ValueParameterDescriptorImpl]

'!' @ [97:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'type' @ [97:22] ==> val type: KotlinType defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.dangerousFlexibleTypeOrNull[LocalVariableDescriptor]

'isFlexibleRecursive' @ [97:27] ==> internal fun KotlinType.isFlexibleRecursive(): Boolean defined in org.jetbrains.kotlin.idea.intentions in file Utils.kt[SimpleFunctionDescriptorImpl]

'!' @ [100:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'type' @ [100:22] ==> val type: KotlinType defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.dangerousFlexibleTypeOrNull[LocalVariableDescriptor]

'isFlexible' @ [100:27] ==> public fun KotlinType.isFlexible(): Boolean defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'type' @ [102:20] ==> val type: KotlinType defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.dangerousFlexibleTypeOrNull[LocalVariableDescriptor]

'declaration' @ [106:30] ==> value-parameter declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.getTypeForDeclaration[ValueParameterDescriptorImpl]

'analyze' @ [106:42] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'DECLARATION_TO_DESCRIPTOR' @ [106:67] ==> public final val DECLARATION_TO_DESCRIPTOR: (ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'declaration' @ [106:94] ==> value-parameter declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.getTypeForDeclaration[ValueParameterDescriptorImpl]

'descriptor' @ [107:25] ==> val descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.getTypeForDeclaration[LocalVariableDescriptor]

'returnType' @ [107:61] ==> public final val CallableDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'type' @ [108:17] ==> val type: KotlinType? defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.getTypeForDeclaration[LocalVariableDescriptor]

'type' @ [108:33] ==> val type: KotlinType? defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.getTypeForDeclaration[LocalVariableDescriptor]

'isError' @ [108:38] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types[DeserializedPropertyDescriptor]

'descriptor' @ [108:49] ==> val descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.getTypeForDeclaration[LocalVariableDescriptor]

'descriptor' @ [109:24] ==> val descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.getTypeForDeclaration[LocalVariableDescriptor]

'setterType' @ [109:35] ==> private final val PropertyDescriptor.setterType: KotlinType? defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion[PropertyDescriptorImpl]

'createErrorType' @ [109:60] ==> @NotNull public open fun createErrorType(@NotNull p0: String): SimpleType defined in org.jetbrains.kotlin.types.ErrorUtils[JavaMethodDescriptor]

'type' @ [111:20] ==> val type: KotlinType? defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.getTypeForDeclaration[LocalVariableDescriptor]

'createErrorType' @ [111:39] ==> @NotNull public open fun createErrorType(@NotNull p0: String): SimpleType defined in org.jetbrains.kotlin.types.ErrorUtils[JavaMethodDescriptor]

'contextElement' @ [115:36] ==> value-parameter contextElement: KtElement defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate[ValueParameterDescriptorImpl]

'getResolutionFacade' @ [115:51] ==> public fun KtElement.getResolutionFacade(): ResolutionFacade defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'resolutionFacade' @ [116:34] ==> val resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate[LocalVariableDescriptor]

'analyze' @ [116:51] ==> public abstract fun analyze(element: KtElement, bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.resolve.ResolutionFacade[DeserializedSimpleFunctionDescriptor]

'contextElement' @ [116:59] ==> value-parameter contextElement: KtElement defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate[ValueParameterDescriptorImpl]

'PARTIAL' @ [116:91] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'contextElement' @ [117:25] ==> value-parameter contextElement: KtElement defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate[ValueParameterDescriptorImpl]

'getResolutionScope' @ [117:40] ==> public fun PsiElement.getResolutionScope(bindingContext: BindingContext, resolutionFacade: ResolutionFacade): LexicalScope defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [117:59] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate[LocalVariableDescriptor]

'resolutionFacade' @ [117:75] ==> val resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate[LocalVariableDescriptor]

'exprType' @ [120:30] ==> value-parameter exprType: KotlinType defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate[ValueParameterDescriptorImpl]

'constructor' @ [120:39] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'declarationDescriptor' @ [120:51] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'descriptor' @ [121:17] ==> val descriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate[LocalVariableDescriptor]

'descriptor' @ [121:39] ==> val descriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate[LocalVariableDescriptor]

'descriptor' @ [122:29] ==> val descriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate[LocalVariableDescriptor]

'containingDeclaration' @ [122:40] ==> public final val TypeParameterDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'owner' @ [123:21] ==> val owner: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate[LocalVariableDescriptor]

'owner' @ [123:52] ==> val owner: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate[LocalVariableDescriptor]

'typeParameters' @ [123:58] ==> public final val FunctionDescriptor.typeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'contains' @ [123:73] ==> public abstract fun contains(element: (TypeParameterDescriptor..TypeParameterDescriptor?)): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'descriptor' @ [123:82] ==> val descriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate[LocalVariableDescriptor]

'checkTypeParameters' @ [124:21] ==> var checkTypeParameters: Boolean defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate[LocalVariableDescriptor]

'with' @ [128:25] ==> @InlineOnly public inline fun <T, R> with(receiver: List<KotlinType>, block: List<KotlinType>.() -> List<KotlinType>): List<KotlinType> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> List<KotlinType>
    <R> -> List<KotlinType>

'exprType' @ [128:31] ==> value-parameter exprType: KotlinType defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate[ValueParameterDescriptorImpl]

'getResolvableApproximations' @ [128:40] ==> public fun KotlinType.getResolvableApproximations(scope: LexicalScope?, checkTypeParameters: Boolean, allowIntersections: Boolean = ...): Sequence<KotlinType> defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'scope' @ [128:68] ==> val scope: LexicalScope defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate[LocalVariableDescriptor]

'checkTypeParameters' @ [128:75] ==> var checkTypeParameters: Boolean defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate[LocalVariableDescriptor]

'toList' @ [128:96] ==> public fun <T> Sequence<KotlinType>.toList(): List<KotlinType> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'when {
                    exprType.isNullabilityFlexible() -> flatMap {
                        listOf(TypeUtils.makeNotNullable(it), TypeUtils.makeNullable(it))
                    }
                    else -> this
                }' @ [129:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: List<KotlinType>, entry1: List<KotlinType>): List<KotlinType>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> List<KotlinType>

'exprType' @ [130:21] ==> value-parameter exprType: KotlinType defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate[ValueParameterDescriptorImpl]

'isNullabilityFlexible' @ [130:30] ==> public fun KotlinType.isNullabilityFlexible(): Boolean defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'flatMap' @ [130:57] ==> public inline fun <T, R> Iterable<KotlinType>.flatMap(transform: (KotlinType) -> Iterable<KotlinType>): List<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType
    <R> -> KotlinType

'listOf' @ [131:25] ==> public fun <T> listOf(vararg elements: KotlinType): List<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'makeNotNullable' @ [131:42] ==> @NotNull public open fun makeNotNullable(@NotNull p0: KotlinType): KotlinType defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'it' @ [131:58] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'makeNullable' @ [131:73] ==> @NotNull public open fun makeNullable(@NotNull p0: KotlinType): KotlinType defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'it' @ [131:86] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'this' @ [133:29] ==> <this> defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate.<anonymous>[ReceiverParameterDescriptorImpl]

'ifEmpty' @ [135:15] ==> public inline fun <T, C : Collection<KotlinType>> List<KotlinType>.ifEmpty(body: () -> List<KotlinType>): List<KotlinType> defined in org.jetbrains.kotlin.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType
    <C : Collection<T>> -> List<KotlinType>

'ChooseValueExpression<KotlinType>' @ [137:29] ==> public constructor ChooseValueExpression<T : Any>(lookupItems: Collection<KotlinType>, defaultItem: KotlinType, advertisementText: String? = ...) defined in org.jetbrains.kotlin.idea.intentions.ChooseValueExpression[ClassConstructorDescriptorImpl]
Inferred types:
    <T : Any> -> KotlinType

'types' @ [137:63] ==> val types: List<KotlinType> defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate[LocalVariableDescriptor]

'types' @ [137:70] ==> val types: List<KotlinType> defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate[LocalVariableDescriptor]

'first' @ [137:76] ==> public fun <T> List<KotlinType>.first(): KotlinType defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'IdeDescriptorRenderers' @ [138:69] ==> public object IdeDescriptorRenderers defined in org.jetbrains.kotlin.idea.util[FakeCallableDescriptorForObject]

'SOURCE_CODE_SHORT_NAMES_IN_TYPES' @ [138:92] ==> @field:JvmField public final val SOURCE_CODE_SHORT_NAMES_IN_TYPES: DescriptorRenderer defined in org.jetbrains.kotlin.idea.util.IdeDescriptorRenderers[DeserializedPropertyDescriptor]

'renderType' @ [138:125] ==> public abstract fun renderType(type: KotlinType): String defined in org.jetbrains.kotlin.renderer.DescriptorRenderer[DeserializedSimpleFunctionDescriptor]

'element' @ [138:136] ==> value-parameter element: KotlinType defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate.<no name provided>.getLookupString[ValueParameterDescriptorImpl]

'IdeDescriptorRenderers' @ [139:63] ==> public object IdeDescriptorRenderers defined in org.jetbrains.kotlin.idea.util[FakeCallableDescriptorForObject]

'SOURCE_CODE' @ [139:86] ==> @field:JvmField public final val SOURCE_CODE: DescriptorRenderer defined in org.jetbrains.kotlin.idea.util.IdeDescriptorRenderers[DeserializedPropertyDescriptor]

'renderType' @ [139:98] ==> public abstract fun renderType(type: KotlinType): String defined in org.jetbrains.kotlin.renderer.DescriptorRenderer[DeserializedSimpleFunctionDescriptor]

'element' @ [139:109] ==> value-parameter element: KotlinType defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeExpressionForTemplate.<no name provided>.getResult[ValueParameterDescriptorImpl]

'if (editor != null) {
                addTypeAnnotationWithTemplate(editor, declaration, exprType)
            }
            else {
                declaration.setType(exprType)
            }' @ [144:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'editor' @ [144:17] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotation[ValueParameterDescriptorImpl]

'addTypeAnnotationWithTemplate' @ [145:17] ==> private final fun addTypeAnnotationWithTemplate(editor: Editor, declaration: KtCallableDeclaration, exprType: KotlinType): Unit defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion[SimpleFunctionDescriptorImpl]

'editor' @ [145:47] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotation[ValueParameterDescriptorImpl]

'declaration' @ [145:55] ==> value-parameter declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotation[ValueParameterDescriptorImpl]

'exprType' @ [145:68] ==> value-parameter exprType: KotlinType defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotation[ValueParameterDescriptorImpl]

'declaration' @ [148:17] ==> value-parameter declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotation[ValueParameterDescriptorImpl]

'setType' @ [148:29] ==> public fun KtCallableDeclaration.setType(type: KotlinType, shortenReferences: Boolean = ...): Unit defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]

'exprType' @ [148:37] ==> value-parameter exprType: KotlinType defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotation[ValueParameterDescriptorImpl]

'TemplateEditingAdapter' @ [153:29] ==> public constructor TemplateEditingAdapter() defined in com.intellij.codeInsight.template.TemplateEditingAdapter[JavaClassConstructorDescriptor]

'declaration' @ [155:35] ==> value-parameter declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeReferencePostprocessor[ValueParameterDescriptorImpl]

'typeReference' @ [155:47] ==> public final var KtCallableDeclaration.typeReference: KtTypeReference?[MyPropertyDescriptor]

'typeRef' @ [156:25] ==> val typeRef: KtTypeReference? defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeReferencePostprocessor.<no name provided>.templateFinished[LocalVariableDescriptor]

'typeRef' @ [156:44] ==> val typeRef: KtTypeReference? defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeReferencePostprocessor.<no name provided>.templateFinished[LocalVariableDescriptor]

'isValid' @ [156:52] ==> public final val KtTypeReference.isValid: Boolean[MyPropertyDescriptor]

'runWriteAction' @ [157:25] ==> public fun <T> runWriteAction(action: () -> KtElement): KtElement defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtElement

'ShortenReferences' @ [157:42] ==> public companion object defined in org.jetbrains.kotlin.idea.core.ShortenReferences[FakeCallableDescriptorForObject]

'DEFAULT' @ [157:60] ==> @field:JvmField public final val DEFAULT: ShortenReferences defined in org.jetbrains.kotlin.idea.core.ShortenReferences.Companion[DeserializedPropertyDescriptor]

'process' @ [157:68] ==> @JvmOverloads public final fun process(element: KtElement, elementFilter: (PsiElement) -> ShortenReferences.FilterResult = ...): KtElement defined in org.jetbrains.kotlin.idea.core.ShortenReferences[DeserializedSimpleFunctionDescriptor]

'typeRef' @ [157:76] ==> val typeRef: KtTypeReference? defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.createTypeReferencePostprocessor.<no name provided>.templateFinished[LocalVariableDescriptor]

'assert' @ [164:13] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'!' @ [164:20] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'exprType' @ [164:21] ==> value-parameter exprType: KotlinType defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotationWithTemplate[ValueParameterDescriptorImpl]

'isError' @ [164:30] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types[DeserializedPropertyDescriptor]

'+' @ [164:41] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'declaration' @ [164:102] ==> value-parameter declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotationWithTemplate[ValueParameterDescriptorImpl]

'getElementTextWithContext' @ [164:114] ==> public fun PsiElement.getElementTextWithContext(): String defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'exprType' @ [164:158] ==> value-parameter exprType: KotlinType defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotationWithTemplate[ValueParameterDescriptorImpl]

'declaration' @ [166:27] ==> value-parameter declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotationWithTemplate[ValueParameterDescriptorImpl]

'project' @ [166:39] ==> public final val KtCallableDeclaration.project: Project[MyPropertyDescriptor]

'createTypeExpressionForTemplate' @ [167:30] ==> public final fun createTypeExpressionForTemplate(exprType: KotlinType, contextElement: KtElement): Expression? defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion[SimpleFunctionDescriptorImpl]

'exprType' @ [167:62] ==> value-parameter exprType: KotlinType defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotationWithTemplate[ValueParameterDescriptorImpl]

'declaration' @ [167:72] ==> value-parameter declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotationWithTemplate[ValueParameterDescriptorImpl]

'declaration' @ [169:13] ==> value-parameter declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotationWithTemplate[ValueParameterDescriptorImpl]

'setType' @ [169:25] ==> public fun KtCallableDeclaration.setType(typeString: String, shortenReferences: Boolean = ...): Unit defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]

'FQ_NAMES' @ [169:48] ==> public final val FQ_NAMES: (KotlinBuiltIns.FqNames..KotlinBuiltIns.FqNames?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaPropertyDescriptor]

'any' @ [169:57] ==> public final val any: (FqNameUnsafe..FqNameUnsafe?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns.FqNames[JavaPropertyDescriptor]

'asString' @ [169:61] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqNameUnsafe[JavaMethodDescriptor]

'getInstance' @ [171:32] ==> public open fun getInstance(@NotNull p0: Project): (PsiDocumentManager..PsiDocumentManager?) defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'project' @ [171:44] ==> val project: Project defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotationWithTemplate[LocalVariableDescriptor]

'commitAllDocuments' @ [171:53] ==> public abstract fun commitAllDocuments(): Unit defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'getInstance' @ [172:32] ==> public open fun getInstance(@NotNull p0: Project): (PsiDocumentManager..PsiDocumentManager?) defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'project' @ [172:44] ==> val project: Project defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotationWithTemplate[LocalVariableDescriptor]

'doPostponedOperationsAndUnblockDocument' @ [172:53] ==> public abstract fun doPostponedOperationsAndUnblockDocument(@NotNull p0: Document): Unit defined in com.intellij.psi.PsiDocumentManager[JavaMethodDescriptor]

'editor' @ [172:93] ==> value-parameter editor: Editor defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotationWithTemplate[ValueParameterDescriptorImpl]

'document' @ [172:100] ==> public final val Editor.document: Document[MyPropertyDescriptor]

'declaration' @ [174:30] ==> value-parameter declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotationWithTemplate[ValueParameterDescriptorImpl]

'typeReference' @ [174:42] ==> public final var KtCallableDeclaration.typeReference: KtTypeReference?[MyPropertyDescriptor]

'TemplateBuilderImpl' @ [175:27] ==> public constructor TemplateBuilderImpl(@NotNull p0: PsiElement) defined in com.intellij.codeInsight.template.TemplateBuilderImpl[JavaClassConstructorDescriptor]

'newTypeRef' @ [175:47] ==> val newTypeRef: KtTypeReference defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotationWithTemplate[LocalVariableDescriptor]

'builder' @ [176:13] ==> val builder: TemplateBuilderImpl defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotationWithTemplate[LocalVariableDescriptor]

'replaceElement' @ [176:21] ==> public open fun replaceElement(@NotNull p0: PsiElement, p1: (Expression..Expression?)): Unit defined in com.intellij.codeInsight.template.TemplateBuilderImpl[JavaMethodDescriptor]

'newTypeRef' @ [176:36] ==> val newTypeRef: KtTypeReference defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotationWithTemplate[LocalVariableDescriptor]

'expression' @ [176:48] ==> val expression: Expression defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotationWithTemplate[LocalVariableDescriptor]

'editor' @ [178:13] ==> value-parameter editor: Editor defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotationWithTemplate[ValueParameterDescriptorImpl]

'caretModel' @ [178:20] ==> public final val Editor.caretModel: CaretModel[MyPropertyDescriptor]

'moveToOffset' @ [178:31] ==> public abstract fun moveToOffset(p0: Int): Unit defined in com.intellij.openapi.editor.CaretModel[JavaMethodDescriptor]

'newTypeRef' @ [178:44] ==> val newTypeRef: KtTypeReference defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotationWithTemplate[LocalVariableDescriptor]

'node' @ [178:55] ==> public final var KtTypeReference.node: ASTNode[MyPropertyDescriptor]

'startOffset' @ [178:60] ==> public final val ASTNode.startOffset: Int[MyPropertyDescriptor]

'getInstance' @ [180:29] ==> public open fun getInstance(p0: (Project..Project?)): (TemplateManager..TemplateManager?) defined in com.intellij.codeInsight.template.TemplateManager[JavaMethodDescriptor]

'project' @ [180:41] ==> val project: Project defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotationWithTemplate[LocalVariableDescriptor]

'startTemplate' @ [180:50] ==> public abstract fun startTemplate(@NotNull p0: Editor, @NotNull p1: Template, p2: (TemplateEditingListener..TemplateEditingListener?)): Unit defined in com.intellij.codeInsight.template.TemplateManager[JavaMethodDescriptor]

'editor' @ [180:64] ==> value-parameter editor: Editor defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotationWithTemplate[ValueParameterDescriptorImpl]

'builder' @ [180:72] ==> val builder: TemplateBuilderImpl defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotationWithTemplate[LocalVariableDescriptor]

'buildInlineTemplate' @ [180:80] ==> public open fun buildInlineTemplate(): (Template..Template?) defined in com.intellij.codeInsight.template.TemplateBuilderImpl[JavaMethodDescriptor]

'createTypeReferencePostprocessor' @ [180:103] ==> public final fun createTypeReferencePostprocessor(declaration: KtCallableDeclaration): TemplateEditingAdapter defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion[SimpleFunctionDescriptorImpl]

'declaration' @ [180:136] ==> value-parameter declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.SpecifyTypeExplicitlyIntention.Companion.addTypeAnnotationWithTemplate[ValueParameterDescriptorImpl]

