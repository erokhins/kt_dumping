'KotlinInternalMode' @ [52:13] ==> public companion object Instance defined in org.jetbrains.kotlin.idea.actions.internal.KotlinInternalMode[FakeCallableDescriptorForObject]

'enabled' @ [52:32] ==> public final var enabled: Boolean defined in org.jetbrains.kotlin.idea.actions.internal.KotlinInternalMode.Instance[DeserializedPropertyDescriptor]

'arrayOf' @ [53:31] ==> public inline fun <reified @PureReifiable T> arrayOf(vararg elements: Attachment?): Array<Attachment?> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified @PureReifiable T> -> Attachment?

'attachmentByPsiFile' @ [53:39] ==> public fun attachmentByPsiFile(file: PsiFile?): Attachment? defined in org.jetbrains.kotlin.idea.util.attachment in file attachmentUtils.kt[SimpleFunctionDescriptorImpl]

'tmpFile' @ [53:59] ==> value-parameter tmpFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.getErrorMessageForExtractFunctionResult[ValueParameterDescriptorImpl]

'attachmentByPsiFile' @ [54:39] ==> public fun attachmentByPsiFile(file: PsiFile?): Attachment? defined in org.jetbrains.kotlin.idea.util.attachment in file attachmentUtils.kt[SimpleFunctionDescriptorImpl]

'breakpointFile' @ [54:59] ==> value-parameter breakpointFile: PsiFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment[ValueParameterDescriptorImpl]

'attachmentByPsiFile' @ [55:39] ==> public fun attachmentByPsiFile(file: PsiFile?): Attachment? defined in org.jetbrains.kotlin.idea.util.attachment in file attachmentUtils.kt[SimpleFunctionDescriptorImpl]

'codeFragment' @ [55:59] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment[ValueParameterDescriptorImpl]

'Attachment' @ [56:39] ==> public constructor Attachment(@NotNull p0: String, @NotNull p1: String) defined in com.intellij.openapi.diagnostic.Attachment[JavaClassConstructorDescriptor]

'breakpointLine' @ [56:77] ==> value-parameter breakpointLine: Int defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment[ValueParameterDescriptorImpl]

'Attachment' @ [57:39] ==> public constructor Attachment(@NotNull p0: String, @NotNull p1: String) defined in com.intellij.openapi.diagnostic.Attachment[JavaClassConstructorDescriptor]

'codeFragment' @ [57:66] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment[ValueParameterDescriptorImpl]

'context' @ [57:79] ==> public final val KtCodeFragment.context: PsiElement?[MyPropertyDescriptor]

'text' @ [57:88] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'Attachment' @ [58:39] ==> public constructor Attachment(@NotNull p0: String, @NotNull p1: String) defined in com.intellij.openapi.diagnostic.Attachment[JavaClassConstructorDescriptor]

'analysisResult' @ [58:65] ==> value-parameter analysisResult: AnalysisResult defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.getErrorMessageForExtractFunctionResult[ValueParameterDescriptorImpl]

'messages' @ [58:80] ==> public final val messages: List<AnalysisResult.ErrorMessage> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.AnalysisResult[PropertyDescriptorImpl]

'joinToString' @ [58:89] ==> public fun <T> Iterable<AnalysisResult.ErrorMessage>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((AnalysisResult.ErrorMessage) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ErrorMessage

'it' @ [58:112] ==> value-parameter it: AnalysisResult.ErrorMessage defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.getErrorMessageForExtractFunctionResult.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [58:118] ==> value-parameter it: AnalysisResult.ErrorMessage defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.getErrorMessageForExtractFunctionResult.<anonymous>[ValueParameterDescriptorImpl]

'renderMessage' @ [58:121] ==> public final fun renderMessage(): String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.AnalysisResult.ErrorMessage[SimpleFunctionDescriptorImpl]

'LOG' @ [59:13] ==> internal val LOG: Logger defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'error' @ [59:17] ==> public open fun error(p0: (Any..Any?)): Unit defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'createEvent' @ [59:36] ==> public open fun createEvent(p0: (String..String?), p1: (String..String?), vararg p2: (Attachment..Attachment?)): (IdeaLoggingEvent..IdeaLoggingEvent?) defined in com.intellij.diagnostic.LogMessageEx[JavaMethodDescriptor]

'getThrowableText' @ [61:35] ==> @NotNull public open fun getThrowableText(@NotNull p0: Throwable): String defined in com.intellij.util.ExceptionUtil[JavaMethodDescriptor]

'Throwable' @ [61:52] ==> public constructor Throwable(message: String?) defined in kotlin.Throwable[DeserializedClassConstructorDescriptor]

'analysisResult' @ [61:93] ==> value-parameter analysisResult: AnalysisResult defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.getErrorMessageForExtractFunctionResult[ValueParameterDescriptorImpl]

'messages' @ [61:108] ==> public final val messages: List<AnalysisResult.ErrorMessage> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.AnalysisResult[PropertyDescriptorImpl]

'joinToString' @ [61:117] ==> public fun <T> Iterable<AnalysisResult.ErrorMessage>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((AnalysisResult.ErrorMessage) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ErrorMessage

'it' @ [61:132] ==> value-parameter it: AnalysisResult.ErrorMessage defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.getErrorMessageForExtractFunctionResult.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [61:135] ==> public final val name: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.AnalysisResult.ErrorMessage[DeserializedPropertyDescriptor]

'mergeAttachments' @ [62:21] ==> public fun mergeAttachments(vararg attachments: Attachment?): Attachment defined in org.jetbrains.kotlin.idea.util.attachment[SimpleFunctionDescriptorImpl]

'attachments' @ [62:39] ==> val attachments: Array<Attachment?> defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.getErrorMessageForExtractFunctionResult[LocalVariableDescriptor]

'analysisResult' @ [64:16] ==> value-parameter analysisResult: AnalysisResult defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.getErrorMessageForExtractFunctionResult[ValueParameterDescriptorImpl]

'messages' @ [64:31] ==> public final val messages: List<AnalysisResult.ErrorMessage> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.AnalysisResult[PropertyDescriptorImpl]

'joinToString' @ [64:40] ==> public fun <T> Iterable<AnalysisResult.ErrorMessage>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((AnalysisResult.ErrorMessage) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ErrorMessage

'when(errorMessage) {
                ErrorMessage.NO_EXPRESSION -> "Cannot perform an action without an expression"
                ErrorMessage.NO_CONTAINER -> "Cannot perform an action at this breakpoint ${breakpointFile.name}:$breakpointLine"
                ErrorMessage.SYNTAX_ERRORS -> "Cannot perform an action due to erroneous code"
                ErrorMessage.SUPER_CALL -> "Cannot perform an action for expression with super call"
                ErrorMessage.DENOTABLE_TYPES -> "Cannot perform an action because following types are unavailable from debugger scope"
                ErrorMessage.ERROR_TYPES -> "Cannot perform an action because this code fragment contains erroneous types"
                ErrorMessage.MULTIPLE_EXIT_POINTS,
                ErrorMessage.DECLARATIONS_OUT_OF_SCOPE,
                ErrorMessage.OUTPUT_AND_EXIT_POINT,
                ErrorMessage.DECLARATIONS_ARE_USED_OUTSIDE -> "Cannot perform an action for this expression"
                ErrorMessage.MULTIPLE_OUTPUT -> throw AssertionError("Unexpected error: $errorMessage")
            }' @ [65:27] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: String, entry1: String, entry2: String, entry3: String, entry4: String, entry5: String, entry6: String, entry7: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> String

'errorMessage' @ [65:32] ==> value-parameter errorMessage: AnalysisResult.ErrorMessage defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.getErrorMessageForExtractFunctionResult.<anonymous>[ValueParameterDescriptorImpl]

'NO_EXPRESSION' @ [66:30] ==> enum entry NO_EXPRESSION defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.AnalysisResult.ErrorMessage[FakeCallableDescriptorForObject]

'NO_CONTAINER' @ [67:30] ==> enum entry NO_CONTAINER defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.AnalysisResult.ErrorMessage[FakeCallableDescriptorForObject]

'breakpointFile' @ [67:93] ==> value-parameter breakpointFile: PsiFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment[ValueParameterDescriptorImpl]

'name' @ [67:108] ==> public final var PsiFile.name: String[MyPropertyDescriptor]

'breakpointLine' @ [67:115] ==> value-parameter breakpointLine: Int defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment[ValueParameterDescriptorImpl]

'SYNTAX_ERRORS' @ [68:30] ==> enum entry SYNTAX_ERRORS defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.AnalysisResult.ErrorMessage[FakeCallableDescriptorForObject]

'SUPER_CALL' @ [69:30] ==> enum entry SUPER_CALL defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.AnalysisResult.ErrorMessage[FakeCallableDescriptorForObject]

'DENOTABLE_TYPES' @ [70:30] ==> enum entry DENOTABLE_TYPES defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.AnalysisResult.ErrorMessage[FakeCallableDescriptorForObject]

'ERROR_TYPES' @ [71:30] ==> enum entry ERROR_TYPES defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.AnalysisResult.ErrorMessage[FakeCallableDescriptorForObject]

'MULTIPLE_EXIT_POINTS' @ [72:30] ==> enum entry MULTIPLE_EXIT_POINTS defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.AnalysisResult.ErrorMessage[FakeCallableDescriptorForObject]

'DECLARATIONS_OUT_OF_SCOPE' @ [73:30] ==> enum entry DECLARATIONS_OUT_OF_SCOPE defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.AnalysisResult.ErrorMessage[FakeCallableDescriptorForObject]

'OUTPUT_AND_EXIT_POINT' @ [74:30] ==> enum entry OUTPUT_AND_EXIT_POINT defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.AnalysisResult.ErrorMessage[FakeCallableDescriptorForObject]

'DECLARATIONS_ARE_USED_OUTSIDE' @ [75:30] ==> enum entry DECLARATIONS_ARE_USED_OUTSIDE defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.AnalysisResult.ErrorMessage[FakeCallableDescriptorForObject]

'MULTIPLE_OUTPUT' @ [76:30] ==> enum entry MULTIPLE_OUTPUT defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.AnalysisResult.ErrorMessage[FakeCallableDescriptorForObject]

'AssertionError' @ [76:55] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'errorMessage' @ [76:90] ==> value-parameter errorMessage: AnalysisResult.ErrorMessage defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.getErrorMessageForExtractFunctionResult.<anonymous>[ValueParameterDescriptorImpl]

'errorMessage' @ [78:13] ==> value-parameter errorMessage: AnalysisResult.ErrorMessage defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.getErrorMessageForExtractFunctionResult.<anonymous>[ValueParameterDescriptorImpl]

'additionalInfo' @ [78:26] ==> public final var additionalInfo: List<String>? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.AnalysisResult.ErrorMessage[PropertyDescriptorImpl]

'let' @ [78:42] ==> @InlineOnly public inline fun <T, R> List<String>.let(block: (List<String>) -> String): String defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> List<String>
    <R> -> String

'message' @ [78:50] ==> val message: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.getErrorMessageForExtractFunctionResult.<anonymous>[LocalVariableDescriptor]

'it' @ [78:61] ==> value-parameter it: List<String> defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.getErrorMessageForExtractFunctionResult.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'joinToString' @ [78:64] ==> public fun <T> Iterable<String>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((String) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'message' @ [78:90] ==> val message: String defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.getErrorMessageForExtractFunctionResult.<anonymous>[LocalVariableDescriptor]

'codeFragment' @ [83:28] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment[ValueParameterDescriptorImpl]

'getContextContainingFile' @ [83:41] ==> public final fun getContextContainingFile(): KtFile? defined in org.jetbrains.kotlin.psi.KtCodeFragment[DeserializedSimpleFunctionDescriptor]

'addDebugExpressionIntoTmpFileForExtractFunction' @ [85:35] ==> public fun addDebugExpressionIntoTmpFileForExtractFunction(originalFile: KtFile, codeFragment: KtCodeFragment, line: Int): List<KtExpression> defined in org.jetbrains.kotlin.idea.debugger.evaluate[SimpleFunctionDescriptorImpl]

'originalFile' @ [85:83] ==> val originalFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.generateFunction[LocalVariableDescriptor]

'codeFragment' @ [85:97] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment[ValueParameterDescriptorImpl]

'breakpointLine' @ [85:111] ==> value-parameter breakpointLine: Int defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment[ValueParameterDescriptorImpl]

'newDebugExpressions' @ [86:13] ==> val newDebugExpressions: List<KtExpression> defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.generateFunction[LocalVariableDescriptor]

'isEmpty' @ [86:33] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'newDebugExpressions' @ [87:23] ==> val newDebugExpressions: List<KtExpression> defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.generateFunction[LocalVariableDescriptor]

'first' @ [87:43] ==> public fun <T> List<KtExpression>.first(): KtExpression defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'containingKtFile' @ [87:51] ==> public final val KtExpression.containingKtFile: KtFile[MyPropertyDescriptor]

'LOG' @ [89:13] ==> internal val LOG: Logger defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'isDebugEnabled' @ [89:17] ==> public final val Logger.isDebugEnabled: Boolean[MyPropertyDescriptor]

'LOG' @ [90:13] ==> internal val LOG: Logger defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'debug' @ [90:17] ==> public abstract fun debug(@NonNls p0: (String..String?)): Unit defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'runReadAction' @ [90:37] ==> public fun <T> runReadAction(action: () -> (String..String?)): (String..String?) defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.String..kotlin.String?)

'tmpFile' @ [90:53] ==> val tmpFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.generateFunction[LocalVariableDescriptor]

'text' @ [90:61] ==> public final val KtFile.text: (String..String?)[MyPropertyDescriptor]

'tmpFile' @ [93:29] ==> val tmpFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.generateFunction[LocalVariableDescriptor]

'declarations' @ [93:37] ==> public final val KtFile.declarations: List<(KtDeclaration..KtDeclaration?)>[MyPropertyDescriptor]

'firstOrNull' @ [93:50] ==> public fun <T> List<(KtDeclaration..KtDeclaration?)>.firstOrNull(): KtDeclaration? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtDeclaration..org.jetbrains.kotlin.psi.KtDeclaration?)

'ExtractionOptions' @ [95:23] ==> public constructor ExtractionOptions(inferUnitTypeForUnusedValues: Boolean = ..., enableListBoxing: Boolean = ..., extractAsProperty: Boolean = ..., allowSpecialClassNames: Boolean = ..., captureLocalFunctions: Boolean = ..., canWrapInWith: Boolean = ...) defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionOptions[ClassConstructorDescriptorImpl]

'ExtractionData' @ [100:30] ==> public constructor ExtractionData(originalFile: KtFile, originalRange: KotlinPsiRange, targetSibling: PsiElement, duplicateContainer: PsiElement? = ..., options: ExtractionOptions = ...) defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[ClassConstructorDescriptorImpl]

'tmpFile' @ [100:45] ==> val tmpFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.generateFunction[LocalVariableDescriptor]

'newDebugExpressions' @ [100:54] ==> val newDebugExpressions: List<KtExpression> defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.generateFunction[LocalVariableDescriptor]

'toRange' @ [100:74] ==> public fun List<PsiElement>.toRange(significantOnly: Boolean = ...): KotlinPsiRange defined in org.jetbrains.kotlin.idea.util.psi.patternMatching[DeserializedSimpleFunctionDescriptor]

'targetSibling' @ [100:85] ==> val targetSibling: KtDeclaration defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.generateFunction[LocalVariableDescriptor]

'options' @ [100:106] ==> val options: ExtractionOptions defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.generateFunction[LocalVariableDescriptor]

'performAnalysis' @ [100:115] ==> public fun ExtractionData.performAnalysis(): AnalysisResult defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine in file extractableAnalysisUtil.kt[SimpleFunctionDescriptorImpl]

'analysisResult' @ [101:13] ==> val analysisResult: AnalysisResult defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.generateFunction[LocalVariableDescriptor]

'status' @ [101:28] ==> public final val status: AnalysisResult.Status defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.AnalysisResult[PropertyDescriptorImpl]

'SUCCESS' @ [101:45] ==> enum entry SUCCESS defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.AnalysisResult.Status[FakeCallableDescriptorForObject]

'createEvaluateException' @ [102:41] ==> public open fun createEvaluateException(p0: (String..String?)): (EvaluateException..EvaluateException?) defined in com.intellij.debugger.engine.evaluation.EvaluateExceptionUtil[JavaMethodDescriptor]

'getErrorMessageForExtractFunctionResult' @ [102:65] ==> local final fun getErrorMessageForExtractFunctionResult(analysisResult: AnalysisResult, tmpFile: KtFile): String defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment[SimpleFunctionDescriptorImpl]

'analysisResult' @ [102:105] ==> val analysisResult: AnalysisResult defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.generateFunction[LocalVariableDescriptor]

'tmpFile' @ [102:121] ==> val tmpFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.generateFunction[LocalVariableDescriptor]

'analysisResult' @ [105:32] ==> val analysisResult: AnalysisResult defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.generateFunction[LocalVariableDescriptor]

'descriptor' @ [105:47] ==> public final val descriptor: ExtractableCodeDescriptor? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.AnalysisResult[PropertyDescriptorImpl]

'validate' @ [105:60] ==> @JvmOverloads public fun ExtractableCodeDescriptor.validate(target: ExtractionTarget = ...): ExtractableCodeDescriptorWithConflicts defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine in file extractableAnalysisUtil.kt[SimpleFunctionDescriptorImpl]

'!' @ [106:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'validationResult' @ [106:14] ==> val validationResult: ExtractableCodeDescriptorWithConflicts defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.generateFunction[LocalVariableDescriptor]

'conflicts' @ [106:31] ==> public final val conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptorWithConflicts[PropertyDescriptorImpl]

'isEmpty' @ [106:41] ==> public final val <K : (Any..Any?), V : (Any..Any?)> MultiMap<PsiElement, String>.isEmpty: Boolean[MyPropertyDescriptor]
Inferred types:
    <K : (Any..Any?)> -> PsiElement
    <V : (Any..Any?)> -> String

'createEvaluateException' @ [107:41] ==> public open fun createEvaluateException(p0: (String..String?)): (EvaluateException..EvaluateException?) defined in com.intellij.debugger.engine.evaluation.EvaluateExceptionUtil[JavaMethodDescriptor]

'validationResult' @ [107:123] ==> val validationResult: ExtractableCodeDescriptorWithConflicts defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.generateFunction[LocalVariableDescriptor]

'conflicts' @ [107:140] ==> public final val conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptorWithConflicts[PropertyDescriptorImpl]

'keySet' @ [107:150] ==> @NotNull public open fun keySet(): (MutableSet<(PsiElement..PsiElement?)>..Set<(PsiElement..PsiElement?)>) defined in com.intellij.util.containers.MultiMap[JavaMethodDescriptor]

'joinToString' @ [107:159] ==> public fun <T> Iterable<(PsiElement..PsiElement?)>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: (((PsiElement..PsiElement?)) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)

'it' @ [107:179] ==> value-parameter it: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.generateFunction.<anonymous>[ValueParameterDescriptorImpl]

'text' @ [107:182] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'ExtractionGeneratorOptions' @ [110:32] ==> public constructor ExtractionGeneratorOptions(inTempFile: Boolean = ..., target: ExtractionTarget = ..., dummyName: String? = ..., allowExpressionBody: Boolean = ..., delayInitialOccurrenceReplacement: Boolean = ...) defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorOptions[ClassConstructorDescriptorImpl]

'GENERATED_FUNCTION_NAME' @ [111:71] ==> internal val GENERATED_FUNCTION_NAME: String defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'ExtractionGeneratorConfiguration' @ [113:16] ==> public constructor ExtractionGeneratorConfiguration(descriptor: ExtractableCodeDescriptor, generatorOptions: ExtractionGeneratorOptions) defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[ClassConstructorDescriptorImpl]

'validationResult' @ [113:49] ==> val validationResult: ExtractableCodeDescriptorWithConflicts defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.generateFunction[LocalVariableDescriptor]

'descriptor' @ [113:66] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptorWithConflicts[PropertyDescriptorImpl]

'generatorOptions' @ [113:78] ==> val generatorOptions: ExtractionGeneratorOptions defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment.generateFunction[LocalVariableDescriptor]

'generateDeclaration' @ [113:96] ==> public fun ExtractionGeneratorConfiguration.generateDeclaration(declarationToReplace: KtNamedDeclaration? = ...): ExtractionResult defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine in file extractorUtil.kt[SimpleFunctionDescriptorImpl]

'runReadAction' @ [116:12] ==> public fun <T> runReadAction(action: () -> ExtractionResult?): ExtractionResult? defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExtractionResult?

'generateFunction' @ [116:28] ==> local final fun generateFunction(): ExtractionResult? defined in org.jetbrains.kotlin.idea.debugger.evaluate.getFunctionForExtractedFragment[SimpleFunctionDescriptorImpl]

'codeFragment' @ [120:5] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionIntoTmpFileForExtractFunction[ValueParameterDescriptorImpl]

'markContextElement' @ [120:18] ==> private fun KtCodeFragment.markContextElement(): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate in file extractFunctionForDebuggerUtil.kt[SimpleFunctionDescriptorImpl]

'codeFragment' @ [121:5] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionIntoTmpFileForExtractFunction[ValueParameterDescriptorImpl]

'markSmartCasts' @ [121:18] ==> private fun KtCodeFragment.markSmartCasts(): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate in file extractFunctionForDebuggerUtil.kt[SimpleFunctionDescriptorImpl]

'originalFile' @ [123:19] ==> value-parameter originalFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionIntoTmpFileForExtractFunction[ValueParameterDescriptorImpl]

'copy' @ [123:32] ==> public final fun copy(): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtFile[JavaMethodDescriptor]

'tmpFile' @ [124:5] ==> val tmpFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionIntoTmpFileForExtractFunction[LocalVariableDescriptor]

'suppressDiagnosticsInDebugMode' @ [124:13] ==> public var KtFile.suppressDiagnosticsInDebugMode: Boolean defined in org.jetbrains.kotlin.psi.codeFragmentUtil[DeserializedPropertyDescriptor]

'tmpFile' @ [125:5] ==> val tmpFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionIntoTmpFileForExtractFunction[LocalVariableDescriptor]

'analysisContext' @ [125:13] ==> public var KtFile.analysisContext: PsiElement? defined in org.jetbrains.kotlin.psi[DeserializedPropertyDescriptor]

'originalFile' @ [125:31] ==> value-parameter originalFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionIntoTmpFileForExtractFunction[ValueParameterDescriptorImpl]

'analysisContext' @ [125:44] ==> public var KtFile.analysisContext: PsiElement? defined in org.jetbrains.kotlin.psi[DeserializedPropertyDescriptor]

'getExpressionToAddDebugExpressionBefore' @ [127:26] ==> private fun getExpressionToAddDebugExpressionBefore(tmpFile: KtFile, contextElement: PsiElement?, line: Int): PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate in file extractFunctionForDebuggerUtil.kt[SimpleFunctionDescriptorImpl]

'tmpFile' @ [127:66] ==> val tmpFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionIntoTmpFileForExtractFunction[LocalVariableDescriptor]

'codeFragment' @ [127:75] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionIntoTmpFileForExtractFunction[ValueParameterDescriptorImpl]

'getOriginalContext' @ [127:88] ==> public final fun getOriginalContext(): KtElement? defined in org.jetbrains.kotlin.psi.KtCodeFragment[DeserializedSimpleFunctionDescriptor]

'line' @ [127:110] ==> value-parameter line: Int defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionIntoTmpFileForExtractFunction[ValueParameterDescriptorImpl]

'emptyList' @ [127:126] ==> public fun <T> emptyList(): List<KtExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'addImportsToFile' @ [129:5] ==> private fun addImportsToFile(newImportList: KtImportList?, tmpFile: KtFile): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate in file extractFunctionForDebuggerUtil.kt[SimpleFunctionDescriptorImpl]

'codeFragment' @ [129:22] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionIntoTmpFileForExtractFunction[ValueParameterDescriptorImpl]

'importsAsImportList' @ [129:35] ==> public final fun importsAsImportList(): KtImportList? defined in org.jetbrains.kotlin.psi.KtCodeFragment[DeserializedSimpleFunctionDescriptor]

'tmpFile' @ [129:58] ==> val tmpFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionIntoTmpFileForExtractFunction[LocalVariableDescriptor]

'addDebugExpressionBeforeContextElement' @ [131:36] ==> private fun addDebugExpressionBeforeContextElement(codeFragment: KtCodeFragment, contextElement: PsiElement): List<KtExpression> defined in org.jetbrains.kotlin.idea.debugger.evaluate[SimpleFunctionDescriptorImpl]

'codeFragment' @ [131:75] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionIntoTmpFileForExtractFunction[ValueParameterDescriptorImpl]

'contextElement' @ [131:89] ==> val contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionIntoTmpFileForExtractFunction[LocalVariableDescriptor]

'contentElementsInTmpFile' @ [132:5] ==> val contentElementsInTmpFile: List<KtExpression> defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionIntoTmpFileForExtractFunction[LocalVariableDescriptor]

'forEach' @ [132:30] ==> @HidesMembers public inline fun <T> Iterable<KtExpression>.forEach(action: (KtExpression) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'it' @ [132:40] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionIntoTmpFileForExtractFunction.<anonymous>[ValueParameterDescriptorImpl]

'insertSmartCasts' @ [132:43] ==> private fun KtExpression.insertSmartCasts(): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate in file extractFunctionForDebuggerUtil.kt[SimpleFunctionDescriptorImpl]

'codeFragment' @ [134:5] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionIntoTmpFileForExtractFunction[ValueParameterDescriptorImpl]

'clearContextElement' @ [134:18] ==> private fun KtCodeFragment.clearContextElement(): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate in file extractFunctionForDebuggerUtil.kt[SimpleFunctionDescriptorImpl]

'codeFragment' @ [135:5] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionIntoTmpFileForExtractFunction[ValueParameterDescriptorImpl]

'clearSmartCasts' @ [135:18] ==> private fun KtCodeFragment.clearSmartCasts(): Unit defined in org.jetbrains.kotlin.idea.debugger.evaluate in file extractFunctionForDebuggerUtil.kt[SimpleFunctionDescriptorImpl]

'contentElementsInTmpFile' @ [137:12] ==> val contentElementsInTmpFile: List<KtExpression> defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionIntoTmpFileForExtractFunction[LocalVariableDescriptor]

'NotNullableCopyableUserDataProperty' @ [140:55] ==> public constructor NotNullableCopyableUserDataProperty<in R : PsiElement, T : Any>(key: Key<Boolean>, defaultValue: Boolean) defined in org.jetbrains.kotlin.psi.NotNullableCopyableUserDataProperty[DeserializedClassConstructorDescriptor]
Inferred types:
    <in R : PsiElement> -> PsiElement
    <T : Any> -> Boolean

'create' @ [140:95] ==> @NotNull public open fun <T : (Any..Any?)> create(@NotNull @NonNls p0: String): Key<(Boolean..Boolean?)> defined in com.intellij.openapi.util.Key[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Boolean

'getOriginalContext' @ [143:5] ==> public final fun getOriginalContext(): KtElement? defined in org.jetbrains.kotlin.psi.KtCodeFragment[DeserializedSimpleFunctionDescriptor]

'IS_CONTEXT_ELEMENT' @ [143:27] ==> private var PsiElement.IS_CONTEXT_ELEMENT: Boolean defined in org.jetbrains.kotlin.idea.debugger.evaluate in file extractFunctionForDebuggerUtil.kt[PropertyDescriptorImpl]

'getOriginalContext' @ [147:5] ==> public final fun getOriginalContext(): KtElement? defined in org.jetbrains.kotlin.psi.KtCodeFragment[DeserializedSimpleFunctionDescriptor]

'IS_CONTEXT_ELEMENT' @ [147:27] ==> private var PsiElement.IS_CONTEXT_ELEMENT: Boolean defined in org.jetbrains.kotlin.idea.debugger.evaluate in file extractFunctionForDebuggerUtil.kt[PropertyDescriptorImpl]

'this' @ [151:12] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.evaluate.findContextElement[ReceiverParameterDescriptorImpl]

'findDescendantOfType' @ [151:17] ==> public inline fun <reified T : PsiElement> PsiElement.findDescendantOfType(noinline predicate: (KtElement) -> Boolean = ...): KtElement? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtElement

'it' @ [151:40] ==> value-parameter it: KtElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findContextElement.<anonymous>[ValueParameterDescriptorImpl]

'IS_CONTEXT_ELEMENT' @ [151:43] ==> private var PsiElement.IS_CONTEXT_ELEMENT: Boolean defined in org.jetbrains.kotlin.idea.debugger.evaluate in file extractFunctionForDebuggerUtil.kt[PropertyDescriptorImpl]

'CopyableUserDataProperty' @ [154:57] ==> public constructor CopyableUserDataProperty<in R : PsiElement, T : Any>(key: Key<PsiElement>) defined in org.jetbrains.kotlin.psi.CopyableUserDataProperty[DeserializedClassConstructorDescriptor]
Inferred types:
    <in R : PsiElement> -> PsiElement
    <T : Any> -> PsiElement

'create' @ [154:86] ==> @NotNull public open fun <T : (Any..Any?)> create(@NotNull @NonNls p0: String): Key<(PsiElement..PsiElement?)> defined in com.intellij.openapi.util.Key[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> PsiElement

'runInReadActionWithWriteActionPriorityWithPCE' @ [157:26] ==> public fun <T : Any> runInReadActionWithWriteActionPriorityWithPCE(f: () -> BindingContext): BindingContext defined in org.jetbrains.kotlin.idea[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> BindingContext

'analyzeFully' @ [157:74] ==> public fun KtElement.analyzeFully(): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'KtPsiFactory' @ [158:19] ==> @JvmOverloads public constructor KtPsiFactory(project: Project, markGenerated: Boolean = ...) defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedClassConstructorDescriptor]

'project' @ [158:32] ==> public final val KtCodeFragment.project: Project[MyPropertyDescriptor]

'getContentElement' @ [160:5] ==> public abstract fun getContentElement(): KtElement? defined in org.jetbrains.kotlin.psi.KtCodeFragment[DeserializedSimpleFunctionDescriptor]

'forEachDescendantOfType' @ [160:26] ==> public inline fun <reified T : PsiElement> PsiElement.forEachDescendantOfType(noinline action: (KtExpression) -> Unit): Unit defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtExpression

'bindingContext' @ [161:25] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.debugger.evaluate.markSmartCasts[LocalVariableDescriptor]

'get' @ [161:40] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(p0: (ReadOnlySlice<(KtExpression..KtExpression?), (ExplicitSmartCasts..ExplicitSmartCasts?)>..ReadOnlySlice<(KtExpression..KtExpression?), (ExplicitSmartCasts..ExplicitSmartCasts?)>?), p1: (KtExpression..KtExpression?)): ExplicitSmartCasts? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> KtExpression
    <V : (Any..Any?)> -> ExplicitSmartCasts

'SMARTCAST' @ [161:44] ==> public final val SMARTCAST: (WritableSlice<(KtExpression..KtExpression?), (ExplicitSmartCasts..ExplicitSmartCasts?)>..WritableSlice<(KtExpression..KtExpression?), (ExplicitSmartCasts..ExplicitSmartCasts?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'expression' @ [161:55] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.debugger.evaluate.markSmartCasts.<anonymous>[ValueParameterDescriptorImpl]

'defaultType' @ [161:68] ==> public abstract val defaultType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.ExplicitSmartCasts[DeserializedPropertyDescriptor]

'smartCast' @ [162:13] ==> val smartCast: KotlinType? defined in org.jetbrains.kotlin.idea.debugger.evaluate.markSmartCasts.<anonymous>[LocalVariableDescriptor]

'factory' @ [163:41] ==> val factory: KtPsiFactory defined in org.jetbrains.kotlin.idea.debugger.evaluate.markSmartCasts[LocalVariableDescriptor]

'createExpressionByPattern' @ [163:49] ==> public fun KtPsiFactory.createExpressionByPattern(pattern: String, vararg args: Any, reformat: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'DescriptorRenderer' @ [164:31] ==> public companion object defined in org.jetbrains.kotlin.renderer.DescriptorRenderer[FakeCallableDescriptorForObject]

'FQ_NAMES_IN_TYPES' @ [164:50] ==> @field:JvmField public final val FQ_NAMES_IN_TYPES: DescriptorRenderer defined in org.jetbrains.kotlin.renderer.DescriptorRenderer.Companion[DeserializedPropertyDescriptor]

'renderType' @ [164:68] ==> public abstract fun renderType(type: KotlinType): String defined in org.jetbrains.kotlin.renderer.DescriptorRenderer[DeserializedSimpleFunctionDescriptor]

'smartCast' @ [164:79] ==> val smartCast: KotlinType? defined in org.jetbrains.kotlin.idea.debugger.evaluate.markSmartCasts.<anonymous>[LocalVariableDescriptor]

'expression' @ [165:21] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.debugger.evaluate.markSmartCasts.<anonymous>[ValueParameterDescriptorImpl]

'expression' @ [167:13] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.debugger.evaluate.markSmartCasts.<anonymous>[ValueParameterDescriptorImpl]

'DEBUG_SMART_CAST' @ [167:24] ==> private var PsiElement.DEBUG_SMART_CAST: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate in file extractFunctionForDebuggerUtil.kt[PropertyDescriptorImpl]

'smartCastedExpression' @ [167:43] ==> val smartCastedExpression: KtParenthesizedExpression defined in org.jetbrains.kotlin.idea.debugger.evaluate.markSmartCasts.<anonymous>[LocalVariableDescriptor]

'forEachDescendantOfType' @ [173:5] ==> public inline fun <reified T : PsiElement> PsiElement.forEachDescendantOfType(noinline action: (KtExpression) -> Unit): Unit defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtExpression

'it' @ [174:27] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.idea.debugger.evaluate.insertSmartCasts.<anonymous>[ValueParameterDescriptorImpl]

'DEBUG_SMART_CAST' @ [174:30] ==> private var PsiElement.DEBUG_SMART_CAST: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate in file extractFunctionForDebuggerUtil.kt[PropertyDescriptorImpl]

'replacement' @ [175:13] ==> val replacement: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.insertSmartCasts.<anonymous>[LocalVariableDescriptor]

'runReadAction' @ [175:34] ==> public fun <T> runReadAction(action: () -> (PsiElement..PsiElement?)): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)

'it' @ [175:50] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.idea.debugger.evaluate.insertSmartCasts.<anonymous>[ValueParameterDescriptorImpl]

'replace' @ [175:53] ==> public abstract fun replace(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtExpression[JavaMethodDescriptor]

'replacement' @ [175:61] ==> val replacement: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.insertSmartCasts.<anonymous>[LocalVariableDescriptor]

'getContentElement' @ [180:5] ==> public abstract fun getContentElement(): KtElement? defined in org.jetbrains.kotlin.psi.KtCodeFragment[DeserializedSimpleFunctionDescriptor]

'forEachDescendantOfType' @ [180:26] ==> public inline fun <reified T : PsiElement> PsiElement.forEachDescendantOfType(noinline action: (KtExpression) -> Unit): Unit defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtExpression

'it' @ [180:66] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.idea.debugger.evaluate.clearSmartCasts.<anonymous>[ValueParameterDescriptorImpl]

'DEBUG_SMART_CAST' @ [180:69] ==> private var PsiElement.DEBUG_SMART_CAST: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate in file extractFunctionForDebuggerUtil.kt[PropertyDescriptorImpl]

'newImportList' @ [184:9] ==> value-parameter newImportList: KtImportList? defined in org.jetbrains.kotlin.idea.debugger.evaluate.addImportsToFile[ValueParameterDescriptorImpl]

'newImportList' @ [184:34] ==> value-parameter newImportList: KtImportList? defined in org.jetbrains.kotlin.idea.debugger.evaluate.addImportsToFile[ValueParameterDescriptorImpl]

'imports' @ [184:48] ==> public final val KtImportList.imports: (MutableList<(KtImportDirective..KtImportDirective?)>..List<(KtImportDirective..KtImportDirective?)>)[MyPropertyDescriptor]

'isNotEmpty' @ [184:56] ==> @InlineOnly public inline fun <T> Collection<(KtImportDirective..KtImportDirective?)>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtImportDirective..org.jetbrains.kotlin.psi.KtImportDirective?)

'tmpFile' @ [185:33] ==> value-parameter tmpFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.addImportsToFile[ValueParameterDescriptorImpl]

'importList' @ [185:41] ==> public final val KtFile.importList: KtImportList?[MyPropertyDescriptor]

'KtPsiFactory' @ [186:26] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'tmpFile' @ [186:39] ==> value-parameter tmpFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.addImportsToFile[ValueParameterDescriptorImpl]

'if (tmpFileImportList == null) {
            val packageDirective = tmpFile.packageDirective
            tmpFile.addAfter(psiFactory.createNewLine(), packageDirective)
            tmpFile.addAfter(newImportList, tmpFile.packageDirective)
        }
        else {
            newImportList.imports.forEach {
                tmpFileImportList.add(psiFactory.createNewLine())
                tmpFileImportList.add(it)
            }

            tmpFileImportList.add(psiFactory.createNewLine())
        }' @ [187:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (PsiElement..PsiElement?), elseBranch: (PsiElement..PsiElement?)): (PsiElement..PsiElement?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)

'tmpFileImportList' @ [187:13] ==> val tmpFileImportList: KtImportList? defined in org.jetbrains.kotlin.idea.debugger.evaluate.addImportsToFile[LocalVariableDescriptor]

'tmpFile' @ [188:36] ==> value-parameter tmpFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.addImportsToFile[ValueParameterDescriptorImpl]

'packageDirective' @ [188:44] ==> public final val KtFile.packageDirective: KtPackageDirective?[MyPropertyDescriptor]

'tmpFile' @ [189:13] ==> value-parameter tmpFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.addImportsToFile[ValueParameterDescriptorImpl]

'addAfter' @ [189:21] ==> public open fun addAfter(@NotNull p0: PsiElement, p1: PsiElement?): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtFile[JavaMethodDescriptor]

'psiFactory' @ [189:30] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.debugger.evaluate.addImportsToFile[LocalVariableDescriptor]

'createNewLine' @ [189:41] ==> public final fun createNewLine(): PsiElement defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'packageDirective' @ [189:58] ==> val packageDirective: KtPackageDirective? defined in org.jetbrains.kotlin.idea.debugger.evaluate.addImportsToFile[LocalVariableDescriptor]

'tmpFile' @ [190:13] ==> value-parameter tmpFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.addImportsToFile[ValueParameterDescriptorImpl]

'addAfter' @ [190:21] ==> public open fun addAfter(@NotNull p0: PsiElement, p1: PsiElement?): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtFile[JavaMethodDescriptor]

'newImportList' @ [190:30] ==> value-parameter newImportList: KtImportList? defined in org.jetbrains.kotlin.idea.debugger.evaluate.addImportsToFile[ValueParameterDescriptorImpl]

'tmpFile' @ [190:45] ==> value-parameter tmpFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.addImportsToFile[ValueParameterDescriptorImpl]

'packageDirective' @ [190:53] ==> public final val KtFile.packageDirective: KtPackageDirective?[MyPropertyDescriptor]

'newImportList' @ [193:13] ==> value-parameter newImportList: KtImportList? defined in org.jetbrains.kotlin.idea.debugger.evaluate.addImportsToFile[ValueParameterDescriptorImpl]

'imports' @ [193:27] ==> public final val KtImportList.imports: (MutableList<(KtImportDirective..KtImportDirective?)>..List<(KtImportDirective..KtImportDirective?)>)[MyPropertyDescriptor]

'forEach' @ [193:35] ==> @HidesMembers public inline fun <T> Iterable<(KtImportDirective..KtImportDirective?)>.forEach(action: ((KtImportDirective..KtImportDirective?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtImportDirective..org.jetbrains.kotlin.psi.KtImportDirective?)

'tmpFileImportList' @ [194:17] ==> val tmpFileImportList: KtImportList? defined in org.jetbrains.kotlin.idea.debugger.evaluate.addImportsToFile[LocalVariableDescriptor]

'add' @ [194:35] ==> public open fun add(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtImportList[JavaMethodDescriptor]

'psiFactory' @ [194:39] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.debugger.evaluate.addImportsToFile[LocalVariableDescriptor]

'createNewLine' @ [194:50] ==> public final fun createNewLine(): PsiElement defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'tmpFileImportList' @ [195:17] ==> val tmpFileImportList: KtImportList? defined in org.jetbrains.kotlin.idea.debugger.evaluate.addImportsToFile[LocalVariableDescriptor]

'add' @ [195:35] ==> public open fun add(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtImportList[JavaMethodDescriptor]

'it' @ [195:39] ==> value-parameter it: (KtImportDirective..KtImportDirective?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.addImportsToFile.<anonymous>[ValueParameterDescriptorImpl]

'tmpFileImportList' @ [198:13] ==> val tmpFileImportList: KtImportList? defined in org.jetbrains.kotlin.idea.debugger.evaluate.addImportsToFile[LocalVariableDescriptor]

'add' @ [198:31] ==> public open fun add(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtImportList[JavaMethodDescriptor]

'psiFactory' @ [198:35] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.debugger.evaluate.addImportsToFile[LocalVariableDescriptor]

'createNewLine' @ [198:46] ==> public final fun createNewLine(): PsiElement defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'contextElement' @ [204:9] ==> value-parameter contextElement: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore[ValueParameterDescriptorImpl]

'?:' @ [205:25] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: Int?, right: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> Int

'getStartLineOffset' @ [205:42] ==> @Nullable public open fun getStartLineOffset(@NotNull file: PsiFile, line: Int): Int? defined in org.jetbrains.kotlin.idea.codeInsight.CodeInsightUtils[JavaMethodDescriptor]

'tmpFile' @ [205:61] ==> value-parameter tmpFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore[ValueParameterDescriptorImpl]

'line' @ [205:70] ==> value-parameter line: Int defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore[ValueParameterDescriptorImpl]

'tmpFile' @ [207:31] ==> value-parameter tmpFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore[ValueParameterDescriptorImpl]

'findElementAt' @ [207:39] ==> public open fun findElementAt(p0: Int): PsiElement? defined in org.jetbrains.kotlin.psi.KtFile[JavaMethodDescriptor]

'lineStart' @ [207:53] ==> val lineStart: Int defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore[LocalVariableDescriptor]

'getTopmostElementAtOffset' @ [209:33] ==> @NotNull public open fun getTopmostElementAtOffset(@NotNull element: PsiElement, offset: Int): PsiElement defined in org.jetbrains.kotlin.idea.codeInsight.CodeInsightUtils[JavaMethodDescriptor]

'elementAtOffset' @ [209:59] ==> val elementAtOffset: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore[LocalVariableDescriptor]

'lineStart' @ [209:76] ==> val lineStart: Int defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore[LocalVariableDescriptor]

'p' @ [212:55] ==> value-parameter p: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore.shouldStop[ValueParameterDescriptorImpl]

'el' @ [212:81] ==> value-parameter el: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore.shouldStop[ValueParameterDescriptorImpl]

'el' @ [212:104] ==> value-parameter el: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore.shouldStop[ValueParameterDescriptorImpl]

'tmpFile' @ [214:21] ==> value-parameter tmpFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore[ValueParameterDescriptorImpl]

'findContextElement' @ [214:29] ==> private fun KtFile.findContextElement(): KtElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate in file extractFunctionForDebuggerUtil.kt[SimpleFunctionDescriptorImpl]

'elementAt' @ [216:18] ==> val elementAt: KtElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore[LocalVariableDescriptor]

'parent' @ [216:29] ==> public final val KtElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'shouldStop' @ [217:9] ==> local final fun shouldStop(el: PsiElement?, p: PsiElement?): Boolean defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore[SimpleFunctionDescriptorImpl]

'elementAt' @ [217:20] ==> val elementAt: KtElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore[LocalVariableDescriptor]

'parent' @ [217:31] ==> var parent: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore[LocalVariableDescriptor]

'elementAt' @ [218:16] ==> val elementAt: KtElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore[LocalVariableDescriptor]

'parent' @ [221:26] ==> var parent: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore[LocalVariableDescriptor]

'parent' @ [221:34] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [223:12] ==> var parent: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore[LocalVariableDescriptor]

'parentOfParent' @ [223:30] ==> var parentOfParent: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore[LocalVariableDescriptor]

'shouldStop' @ [224:13] ==> local final fun shouldStop(el: PsiElement?, p: PsiElement?): Boolean defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore[SimpleFunctionDescriptorImpl]

'parent' @ [224:24] ==> var parent: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore[LocalVariableDescriptor]

'parentOfParent' @ [224:32] ==> var parentOfParent: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore[LocalVariableDescriptor]

'parent' @ [228:9] ==> var parent: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore[LocalVariableDescriptor]

'parent' @ [228:18] ==> var parent: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore[LocalVariableDescriptor]

'parent' @ [228:25] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parentOfParent' @ [229:9] ==> var parentOfParent: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore[LocalVariableDescriptor]

'parent' @ [229:26] ==> var parent: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore[LocalVariableDescriptor]

'parent' @ [229:34] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [232:12] ==> var parent: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.getExpressionToAddDebugExpressionBefore[LocalVariableDescriptor]

'findElementBefore' @ [236:25] ==> private fun findElementBefore(contextElement: PsiElement): PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate in file extractFunctionForDebuggerUtil.kt[SimpleFunctionDescriptorImpl]

'contextElement' @ [236:43] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement[ValueParameterDescriptorImpl]

'elementBefore' @ [238:18] ==> val elementBefore: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement[LocalVariableDescriptor]

'parent' @ [238:33] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'emptyList' @ [238:50] ==> public fun <T> emptyList(): List<KtExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'KtPsiFactory' @ [240:22] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'codeFragment' @ [240:35] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement[ValueParameterDescriptorImpl]

'parent' @ [242:5] ==> val parent: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement[LocalVariableDescriptor]

'addBefore' @ [242:12] ==> public abstract fun addBefore(@NotNull p0: PsiElement, @Nullable p1: PsiElement?): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'psiFactory' @ [242:22] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement[LocalVariableDescriptor]

'createNewLine' @ [242:33] ==> public final fun createNewLine(): PsiElement defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'elementBefore' @ [242:50] ==> val elementBefore: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement[LocalVariableDescriptor]

'when (expr) {
            is KtBlockExpression -> return expr.statements.flatMap(::insertExpression)
            is KtExpression -> {
                val newDebugExpression = parent.addBefore(expr, elementBefore)
                if (newDebugExpression == null) {
                    LOG.error("Couldn't insert debug expression ${expr.text} to context file before ${elementBefore.text}")
                    return emptyList()
                }
                parent.addBefore(psiFactory.createNewLine(), elementBefore)
                return listOf(newDebugExpression as KtExpression)
            }
        }' @ [245:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Nothing, entry1: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Nothing

'expr' @ [245:15] ==> value-parameter expr: KtElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement.insertExpression[ValueParameterDescriptorImpl]

'expr' @ [246:44] ==> value-parameter expr: KtElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement.insertExpression[ValueParameterDescriptorImpl]

'statements' @ [246:49] ==> public final val KtBlockExpression.statements: List<(KtExpression..KtExpression?)>[MyPropertyDescriptor]

'flatMap' @ [246:60] ==> public inline fun <T, R> Iterable<(KtExpression..KtExpression?)>.flatMap(transform: ((KtExpression..KtExpression?)) -> Iterable<KtExpression>): List<KtExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)
    <R> -> KtExpression

'parent' @ [248:42] ==> val parent: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement[LocalVariableDescriptor]

'addBefore' @ [248:49] ==> public abstract fun addBefore(@NotNull p0: PsiElement, @Nullable p1: PsiElement?): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'expr' @ [248:59] ==> value-parameter expr: KtElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement.insertExpression[ValueParameterDescriptorImpl]

'elementBefore' @ [248:65] ==> val elementBefore: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement[LocalVariableDescriptor]

'newDebugExpression' @ [249:21] ==> val newDebugExpression: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement.insertExpression[LocalVariableDescriptor]

'LOG' @ [250:21] ==> internal val LOG: Logger defined in org.jetbrains.kotlin.idea.debugger.evaluate in file KotlinEvaluationBuilder.kt[PropertyDescriptorImpl]

'error' @ [250:25] ==> public open fun error(@NonNls p0: (String..String?)): Unit defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'expr' @ [250:67] ==> value-parameter expr: KtElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement.insertExpression[ValueParameterDescriptorImpl]

'text' @ [250:72] ==> public final val KtExpression.text: (String..String?)[MyPropertyDescriptor]

'elementBefore' @ [250:103] ==> val elementBefore: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement[LocalVariableDescriptor]

'text' @ [250:117] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'emptyList' @ [251:28] ==> public fun <T> emptyList(): List<KtExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'parent' @ [253:17] ==> val parent: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement[LocalVariableDescriptor]

'addBefore' @ [253:24] ==> public abstract fun addBefore(@NotNull p0: PsiElement, @Nullable p1: PsiElement?): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'psiFactory' @ [253:34] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement[LocalVariableDescriptor]

'createNewLine' @ [253:45] ==> public final fun createNewLine(): PsiElement defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'elementBefore' @ [253:62] ==> val elementBefore: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement[LocalVariableDescriptor]

'listOf' @ [254:24] ==> public fun <T> listOf(element: KtExpression): List<KtExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'newDebugExpression' @ [254:31] ==> val newDebugExpression: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement.insertExpression[LocalVariableDescriptor]

'emptyList' @ [257:16] ==> public fun <T> emptyList(): List<KtExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'codeFragment' @ [260:26] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement[ValueParameterDescriptorImpl]

'context' @ [260:39] ==> public final val KtCodeFragment.context: PsiElement?[MyPropertyDescriptor]

'containingFile' @ [260:48] ==> public final val PsiElement.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'containingFile' @ [261:9] ==> val containingFile: PsiFile? defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement[LocalVariableDescriptor]

'insertExpression' @ [262:9] ==> local final fun insertExpression(expr: KtElement?): List<KtExpression> defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement[SimpleFunctionDescriptorImpl]

'containingFile' @ [262:26] ==> val containingFile: PsiFile? defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement[LocalVariableDescriptor]

'getContentElement' @ [262:41] ==> public abstract fun getContentElement(): KtElement? defined in org.jetbrains.kotlin.psi.KtCodeFragment[DeserializedSimpleFunctionDescriptor]

'codeFragment' @ [265:27] ==> value-parameter codeFragment: KtCodeFragment defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement[ValueParameterDescriptorImpl]

'getContentElement' @ [265:40] ==> public abstract fun getContentElement(): KtElement? defined in org.jetbrains.kotlin.psi.KtCodeFragment[DeserializedSimpleFunctionDescriptor]

'emptyList' @ [265:70] ==> public fun <T> emptyList(): List<KtExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'insertExpression' @ [266:12] ==> local final fun insertExpression(expr: KtElement?): List<KtExpression> defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement[SimpleFunctionDescriptorImpl]

'debugExpression' @ [266:29] ==> val debugExpression: KtElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.addDebugExpressionBeforeContextElement[LocalVariableDescriptor]

'KtPsiFactory' @ [270:22] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'contextElement' @ [270:35] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'psiFactory' @ [273:27] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[LocalVariableDescriptor]

'createAnonymousInitializer' @ [273:38] ==> public final fun createAnonymousInitializer(): KtAnonymousInitializer defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'classBody' @ [274:31] ==> value-parameter classBody: KtClassBody defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore.insertNewInitializer[ValueParameterDescriptorImpl]

'addAfter' @ [274:41] ==> public open fun addAfter(@NotNull p0: PsiElement, p1: PsiElement?): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtClassBody[JavaMethodDescriptor]

'initializer' @ [274:50] ==> val initializer: KtAnonymousInitializer defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore.insertNewInitializer[LocalVariableDescriptor]

'classBody' @ [274:63] ==> value-parameter classBody: KtClassBody defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore.insertNewInitializer[ValueParameterDescriptorImpl]

'firstChild' @ [274:73] ==> public final val KtClassBody.firstChild: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'newInitializer' @ [275:21] ==> val newInitializer: KtAnonymousInitializer defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore.insertNewInitializer[LocalVariableDescriptor]

'body' @ [275:36] ==> public abstract val body: KtExpression? defined in org.jetbrains.kotlin.psi.KtAnonymousInitializer[DeserializedPropertyDescriptor]

'block' @ [276:16] ==> val block: KtBlockExpression? defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore.insertNewInitializer[LocalVariableDescriptor]

'lastChild' @ [276:23] ==> public final val KtBlockExpression.lastChild: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'when {
        contextElement is KtFile -> {
            val fakeFunction = psiFactory.createFunction("fun _debug_fun_() {}")
            contextElement.add(psiFactory.createNewLine())
            val newFakeFun = contextElement.add(fakeFunction) as KtNamedFunction
            newFakeFun.bodyExpression!!.lastChild
        }
        contextElement is KtProperty && !contextElement.isLocal -> {
            val delegateExpressionOrInitializer = contextElement.delegateExpressionOrInitializer
            if (delegateExpressionOrInitializer != null) {
                wrapInLambdaCall(delegateExpressionOrInitializer)
            }
            else {
                val getter = contextElement.getter!!
                if (!getter.hasBlockBody()) {
                    wrapInLambdaCall(getter.bodyExpression!!)
                }
                else {
                    (getter.bodyExpression as KtBlockExpression).statements.first()
                }
            }
        }
        contextElement is KtParameter -> {
            val ownerFunction = contextElement.ownerFunction!!
            findElementBefore(ownerFunction)
        }
        contextElement is KtPrimaryConstructor -> {
            val classOrObject = contextElement.getContainingClassOrObject()
            insertNewInitializer(classOrObject.getOrCreateBody())
        }
        contextElement is KtClassOrObject -> {
            insertNewInitializer(contextElement.getOrCreateBody())
        }
        contextElement is KtFunctionLiteral -> {
            val block = contextElement.bodyExpression!!
            block.statements.firstOrNull() ?: block.lastChild
        }
        contextElement is KtDeclarationWithBody && !contextElement.hasBody() -> {
            val block = psiFactory.createBlock("")
            val newBlock = contextElement.add(block) as KtBlockExpression
            newBlock.rBrace
        }
        contextElement is KtDeclarationWithBody && !contextElement.hasBlockBody() -> {
            wrapInLambdaCall(contextElement.bodyExpression!!)
        }
        contextElement is KtDeclarationWithBody && contextElement.hasBlockBody() -> {
            val block = contextElement.bodyExpression as KtBlockExpression
            val last = block.statements.lastOrNull()
            last as? KtReturnExpression ?: block.rBrace
        }
        contextElement is KtWhenEntry -> {
            val entryExpression = contextElement.expression
            if (entryExpression is KtBlockExpression) {
                entryExpression.statements.firstOrNull() ?: entryExpression.lastChild
            }
            else {
                wrapInLambdaCall(entryExpression!!)
            }
        }
        else -> {
            contextElement
        }
    }' @ [279:12] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: PsiElement?, entry1: PsiElement?, entry2: PsiElement?, entry3: PsiElement?, entry4: PsiElement?, entry5: PsiElement?, entry6: PsiElement?, entry7: PsiElement?, entry8: PsiElement?, entry9: PsiElement?, entry10: PsiElement?): PsiElement?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> PsiElement?

'contextElement' @ [280:9] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'psiFactory' @ [281:32] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[LocalVariableDescriptor]

'createFunction' @ [281:43] ==> public final fun createFunction(funDecl: String): KtNamedFunction defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'contextElement' @ [282:13] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'add' @ [282:28] ==> public abstract fun add(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'psiFactory' @ [282:32] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[LocalVariableDescriptor]

'createNewLine' @ [282:43] ==> public final fun createNewLine(): PsiElement defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'contextElement' @ [283:30] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'add' @ [283:45] ==> public abstract fun add(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'fakeFunction' @ [283:49] ==> val fakeFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[LocalVariableDescriptor]

'newFakeFun' @ [284:13] ==> val newFakeFun: KtNamedFunction defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[LocalVariableDescriptor]

'bodyExpression' @ [284:24] ==> public final val KtNamedFunction.bodyExpression: KtExpression?[MyPropertyDescriptor]

'lastChild' @ [284:41] ==> public final val KtExpression.lastChild: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'contextElement' @ [286:9] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'!' @ [286:41] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'contextElement' @ [286:42] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'isLocal' @ [286:57] ==> public final val KtProperty.isLocal: Boolean[MyPropertyDescriptor]

'contextElement' @ [287:51] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'delegateExpressionOrInitializer' @ [287:66] ==> public final val KtProperty.delegateExpressionOrInitializer: KtExpression?[MyPropertyDescriptor]

'if (delegateExpressionOrInitializer != null) {
                wrapInLambdaCall(delegateExpressionOrInitializer)
            }
            else {
                val getter = contextElement.getter!!
                if (!getter.hasBlockBody()) {
                    wrapInLambdaCall(getter.bodyExpression!!)
                }
                else {
                    (getter.bodyExpression as KtBlockExpression).statements.first()
                }
            }' @ [288:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: PsiElement?, elseBranch: PsiElement?): PsiElement?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> PsiElement?

'delegateExpressionOrInitializer' @ [288:17] ==> val delegateExpressionOrInitializer: KtExpression? defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[LocalVariableDescriptor]

'wrapInLambdaCall' @ [289:17] ==> private fun wrapInLambdaCall(expression: KtExpression): PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate in file extractFunctionForDebuggerUtil.kt[SimpleFunctionDescriptorImpl]

'delegateExpressionOrInitializer' @ [289:34] ==> val delegateExpressionOrInitializer: KtExpression? defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[LocalVariableDescriptor]

'contextElement' @ [292:30] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'getter' @ [292:45] ==> public final val KtProperty.getter: KtPropertyAccessor?[MyPropertyDescriptor]

'if (!getter.hasBlockBody()) {
                    wrapInLambdaCall(getter.bodyExpression!!)
                }
                else {
                    (getter.bodyExpression as KtBlockExpression).statements.first()
                }' @ [293:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: PsiElement?, elseBranch: PsiElement?): PsiElement?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> PsiElement?

'!' @ [293:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'getter' @ [293:22] ==> val getter: KtPropertyAccessor defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[LocalVariableDescriptor]

'hasBlockBody' @ [293:29] ==> public open fun hasBlockBody(): Boolean defined in org.jetbrains.kotlin.psi.KtPropertyAccessor[JavaMethodDescriptor]

'wrapInLambdaCall' @ [294:21] ==> private fun wrapInLambdaCall(expression: KtExpression): PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate in file extractFunctionForDebuggerUtil.kt[SimpleFunctionDescriptorImpl]

'getter' @ [294:38] ==> val getter: KtPropertyAccessor defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[LocalVariableDescriptor]

'bodyExpression' @ [294:45] ==> public final val KtPropertyAccessor.bodyExpression: KtExpression?[MyPropertyDescriptor]

'getter' @ [297:22] ==> val getter: KtPropertyAccessor defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[LocalVariableDescriptor]

'bodyExpression' @ [297:29] ==> public final val KtPropertyAccessor.bodyExpression: KtExpression?[MyPropertyDescriptor]

'statements' @ [297:66] ==> public final val KtBlockExpression.statements: List<(KtExpression..KtExpression?)>[MyPropertyDescriptor]

'first' @ [297:77] ==> public fun <T> List<(KtExpression..KtExpression?)>.first(): (KtExpression..KtExpression?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)

'contextElement' @ [301:9] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'contextElement' @ [302:33] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'ownerFunction' @ [302:48] ==> public final val KtParameter.ownerFunction: KtDeclarationWithBody?[MyPropertyDescriptor]

'findElementBefore' @ [303:13] ==> private fun findElementBefore(contextElement: PsiElement): PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate in file extractFunctionForDebuggerUtil.kt[SimpleFunctionDescriptorImpl]

'ownerFunction' @ [303:31] ==> val ownerFunction: KtDeclarationWithBody defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[LocalVariableDescriptor]

'contextElement' @ [305:9] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'contextElement' @ [306:33] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'getContainingClassOrObject' @ [306:48] ==> public open fun getContainingClassOrObject(): KtClassOrObject defined in org.jetbrains.kotlin.psi.KtPrimaryConstructor[DeserializedSimpleFunctionDescriptor]

'insertNewInitializer' @ [307:13] ==> local final fun insertNewInitializer(classBody: KtClassBody): PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[SimpleFunctionDescriptorImpl]

'classOrObject' @ [307:34] ==> val classOrObject: KtClassOrObject defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[LocalVariableDescriptor]

'getOrCreateBody' @ [307:48] ==> public fun KtClassOrObject.getOrCreateBody(): KtClassBody defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'contextElement' @ [309:9] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'insertNewInitializer' @ [310:13] ==> local final fun insertNewInitializer(classBody: KtClassBody): PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[SimpleFunctionDescriptorImpl]

'contextElement' @ [310:34] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'getOrCreateBody' @ [310:49] ==> public fun KtClassOrObject.getOrCreateBody(): KtClassBody defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'contextElement' @ [312:9] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'contextElement' @ [313:25] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'bodyExpression' @ [313:40] ==> public final val KtFunctionLiteral.bodyExpression: KtBlockExpression?[MyPropertyDescriptor]

'block' @ [314:13] ==> val block: KtBlockExpression defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[LocalVariableDescriptor]

'statements' @ [314:19] ==> public final val KtBlockExpression.statements: List<(KtExpression..KtExpression?)>[MyPropertyDescriptor]

'firstOrNull' @ [314:30] ==> public fun <T> List<(KtExpression..KtExpression?)>.firstOrNull(): KtExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)

'block' @ [314:47] ==> val block: KtBlockExpression defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[LocalVariableDescriptor]

'lastChild' @ [314:53] ==> public final val KtBlockExpression.lastChild: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'contextElement' @ [316:9] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'!' @ [316:52] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'contextElement' @ [316:53] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'hasBody' @ [316:68] ==> public abstract fun hasBody(): Boolean defined in org.jetbrains.kotlin.psi.KtDeclarationWithBody[JavaMethodDescriptor]

'psiFactory' @ [317:25] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[LocalVariableDescriptor]

'createBlock' @ [317:36] ==> public final fun createBlock(bodyText: String): KtBlockExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'contextElement' @ [318:28] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'add' @ [318:43] ==> public abstract fun add(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'block' @ [318:47] ==> val block: KtBlockExpression defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[LocalVariableDescriptor]

'newBlock' @ [319:13] ==> val newBlock: KtBlockExpression defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[LocalVariableDescriptor]

'rBrace' @ [319:22] ==> public final val KtBlockExpression.rBrace: PsiElement?[MyPropertyDescriptor]

'contextElement' @ [321:9] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'!' @ [321:52] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'contextElement' @ [321:53] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'hasBlockBody' @ [321:68] ==> public abstract fun hasBlockBody(): Boolean defined in org.jetbrains.kotlin.psi.KtDeclarationWithBody[JavaMethodDescriptor]

'wrapInLambdaCall' @ [322:13] ==> private fun wrapInLambdaCall(expression: KtExpression): PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate in file extractFunctionForDebuggerUtil.kt[SimpleFunctionDescriptorImpl]

'contextElement' @ [322:30] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'bodyExpression' @ [322:45] ==> public final val KtDeclarationWithBody.bodyExpression: KtExpression?[MyPropertyDescriptor]

'contextElement' @ [324:9] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'contextElement' @ [324:52] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'hasBlockBody' @ [324:67] ==> public abstract fun hasBlockBody(): Boolean defined in org.jetbrains.kotlin.psi.KtDeclarationWithBody[JavaMethodDescriptor]

'contextElement' @ [325:25] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'bodyExpression' @ [325:40] ==> public final val KtDeclarationWithBody.bodyExpression: KtExpression?[MyPropertyDescriptor]

'block' @ [326:24] ==> val block: KtBlockExpression defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[LocalVariableDescriptor]

'statements' @ [326:30] ==> public final val KtBlockExpression.statements: List<(KtExpression..KtExpression?)>[MyPropertyDescriptor]

'lastOrNull' @ [326:41] ==> public fun <T> List<(KtExpression..KtExpression?)>.lastOrNull(): KtExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)

'last' @ [327:13] ==> val last: KtExpression? defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[LocalVariableDescriptor]

'block' @ [327:44] ==> val block: KtBlockExpression defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[LocalVariableDescriptor]

'rBrace' @ [327:50] ==> public final val KtBlockExpression.rBrace: PsiElement?[MyPropertyDescriptor]

'contextElement' @ [329:9] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'contextElement' @ [330:35] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'expression' @ [330:50] ==> public final val KtWhenEntry.expression: KtExpression?[MyPropertyDescriptor]

'if (entryExpression is KtBlockExpression) {
                entryExpression.statements.firstOrNull() ?: entryExpression.lastChild
            }
            else {
                wrapInLambdaCall(entryExpression!!)
            }' @ [331:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: PsiElement?, elseBranch: PsiElement?): PsiElement?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> PsiElement?

'entryExpression' @ [331:17] ==> val entryExpression: KtExpression? defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[LocalVariableDescriptor]

'entryExpression' @ [332:17] ==> val entryExpression: KtExpression? defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[LocalVariableDescriptor]

'statements' @ [332:33] ==> public final val KtBlockExpression.statements: List<(KtExpression..KtExpression?)>[MyPropertyDescriptor]

'firstOrNull' @ [332:44] ==> public fun <T> List<(KtExpression..KtExpression?)>.firstOrNull(): KtExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)

'entryExpression' @ [332:61] ==> val entryExpression: KtExpression? defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[LocalVariableDescriptor]

'lastChild' @ [332:77] ==> public final val KtBlockExpression.lastChild: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'wrapInLambdaCall' @ [335:17] ==> private fun wrapInLambdaCall(expression: KtExpression): PsiElement? defined in org.jetbrains.kotlin.idea.debugger.evaluate in file extractFunctionForDebuggerUtil.kt[SimpleFunctionDescriptorImpl]

'entryExpression' @ [335:34] ==> val entryExpression: KtExpression? defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[LocalVariableDescriptor]

'contextElement' @ [339:13] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.debugger.evaluate.findElementBefore[ValueParameterDescriptorImpl]

'KtPsiFactory' @ [345:26] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'expression' @ [345:39] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.debugger.evaluate.replaceByLambdaCall[ValueParameterDescriptorImpl]

'createExpression' @ [345:51] ==> public final fun createExpression(text: String): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'expression' @ [345:75] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.debugger.evaluate.replaceByLambdaCall[ValueParameterDescriptorImpl]

'text' @ [345:86] ==> public final val KtExpression.text: (String..String?)[MyPropertyDescriptor]

'expression' @ [346:12] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.debugger.evaluate.replaceByLambdaCall[ValueParameterDescriptorImpl]

'replaced' @ [346:23] ==> public inline fun <reified T : PsiElement> PsiElement.replaced(newElement: KtCallExpression): KtCallExpression defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtCallExpression

'callExpression' @ [346:32] ==> val callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.debugger.evaluate.replaceByLambdaCall[LocalVariableDescriptor]

'replaceByLambdaCall' @ [350:24] ==> private fun replaceByLambdaCall(expression: KtExpression): KtCallExpression defined in org.jetbrains.kotlin.idea.debugger.evaluate in file extractFunctionForDebuggerUtil.kt[SimpleFunctionDescriptorImpl]

'expression' @ [350:44] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.debugger.evaluate.wrapInLambdaCall[ValueParameterDescriptorImpl]

'replacedBody' @ [351:13] ==> val replacedBody: KtCallExpression defined in org.jetbrains.kotlin.idea.debugger.evaluate.wrapInLambdaCall[LocalVariableDescriptor]

'calleeExpression' @ [351:26] ==> public final val KtCallExpression.calleeExpression: KtExpression?[MyPropertyDescriptor]

'bodyExpression' @ [351:68] ==> public final val KtLambdaExpression.bodyExpression: KtBlockExpression?[MyPropertyDescriptor]

'firstChild' @ [351:84] ==> public final val KtBlockExpression.firstChild: (PsiElement..PsiElement?)[MyPropertyDescriptor]

