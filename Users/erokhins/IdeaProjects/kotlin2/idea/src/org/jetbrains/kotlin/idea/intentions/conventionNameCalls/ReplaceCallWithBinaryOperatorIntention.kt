'IntentionBasedInspection<KtDotQualifiedExpression>' @ [41:45] ==> public constructor IntentionBasedInspection<TElement : PsiElement>(intention: KClass<out SelfTargetingRangeIntention<KtDotQualifiedExpression>>, additionalChecker: (KtDotQualifiedExpression) -> Boolean, problemText: String? = ...) defined in org.jetbrains.kotlin.idea.inspections.IntentionBasedInspection[DeserializedClassConstructorDescriptor]
Inferred types:
    <TElement : PsiElement> -> KtDotQualifiedExpression

'ReplaceCallWithBinaryOperatorIntention' @ [42:9] ==> public constructor ReplaceCallWithBinaryOperatorIntention() defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention[ClassConstructorDescriptorImpl]

'qualifiedExpression' @ [44:36] ==> value-parameter qualifiedExpression: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithComparisonInspection.<init>.<anonymous>[ValueParameterDescriptorImpl]

'callExpression' @ [44:56] ==> public val KtQualifiedExpression.callExpression: KtCallExpression? defined in org.jetbrains.kotlin.idea.intentions in file Utils.kt[PropertyDescriptorImpl]

'calleeExpression' @ [44:72] ==> public final val KtCallExpression.calleeExpression: KtExpression?[MyPropertyDescriptor]

'calleeExpression' @ [45:30] ==> val calleeExpression: KtSimpleNameExpression? defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithComparisonInspection.<init>.<anonymous>[LocalVariableDescriptor]

'getReferencedNameAsName' @ [45:48] ==> public abstract fun getReferencedNameAsName(): Name defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[DeserializedSimpleFunctionDescriptor]

'identifier' @ [46:13] ==> val identifier: Name? defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithComparisonInspection.<init>.<anonymous>[LocalVariableDescriptor]

'EQUALS' @ [46:51] ==> @field:JvmField public final val EQUALS: Name defined in org.jetbrains.kotlin.util.OperatorNameConventions[DeserializedPropertyDescriptor]

'identifier' @ [46:61] ==> val identifier: Name? defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithComparisonInspection.<init>.<anonymous>[LocalVariableDescriptor]

'COMPARE_TO' @ [46:99] ==> @field:JvmField public final val COMPARE_TO: Name defined in org.jetbrains.kotlin.util.OperatorNameConventions[DeserializedPropertyDescriptor]

'SelfTargetingRangeIntention<KtDotQualifiedExpression>' @ [50:48] ==> public constructor SelfTargetingRangeIntention<TElement : PsiElement>(elementType: Class<KtDotQualifiedExpression>, text: String, familyName: String = ...) defined in org.jetbrains.kotlin.idea.intentions.SelfTargetingRangeIntention[DeserializedClassConstructorDescriptor]
Inferred types:
    <TElement : PsiElement> -> KtDotQualifiedExpression

'KtDotQualifiedExpression' @ [51:9] ==> public companion object defined in org.jetbrains.kotlin.psi.KtDotQualifiedExpression[FakeCallableDescriptorForObject]

'java' @ [51:41] ==> public val <T> KClass<KtDotQualifiedExpression>.java: Class<KtDotQualifiedExpression> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtDotQualifiedExpression

'when (this) {
        KtTokens.LT -> KtTokens.GT
        KtTokens.GT -> KtTokens.LT

        KtTokens.GTEQ -> KtTokens.LTEQ
        KtTokens.LTEQ -> KtTokens.GTEQ

        else -> null
    }' @ [55:64] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KtSingleValueToken?, entry1: KtSingleValueToken?, entry2: KtSingleValueToken?, entry3: KtSingleValueToken?, entry4: KtSingleValueToken?): KtSingleValueToken?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KtSingleValueToken?

'this' @ [55:70] ==> <this> defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.inverted[ReceiverParameterDescriptorImpl]

'LT' @ [56:18] ==> public final val LT: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'GT' @ [56:33] ==> public final val GT: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'GT' @ [57:18] ==> public final val GT: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'LT' @ [57:33] ==> public final val LT: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'GTEQ' @ [59:18] ==> public final val GTEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'LTEQ' @ [59:35] ==> public final val LTEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'LTEQ' @ [60:18] ==> public final val LTEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'GTEQ' @ [60:35] ==> public final val GTEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'element' @ [66:32] ==> value-parameter element: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applicabilityRange[ValueParameterDescriptorImpl]

'callExpression' @ [66:40] ==> public val KtQualifiedExpression.callExpression: KtCallExpression? defined in org.jetbrains.kotlin.idea.intentions in file Utils.kt[PropertyDescriptorImpl]

'calleeExpression' @ [66:56] ==> public final val KtCallExpression.calleeExpression: KtExpression?[MyPropertyDescriptor]

'operation' @ [67:25] ==> private final fun operation(calleeExpression: KtSimpleNameExpression): KtSingleValueToken? defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention[SimpleFunctionDescriptorImpl]

'calleeExpression' @ [67:35] ==> val calleeExpression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applicabilityRange[LocalVariableDescriptor]

'element' @ [69:28] ==> value-parameter element: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applicabilityRange[ValueParameterDescriptorImpl]

'toResolvedCall' @ [69:36] ==> public fun KtQualifiedExpression.toResolvedCall(bodyResolveMode: BodyResolveMode): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.idea.intentions in file Utils.kt[SimpleFunctionDescriptorImpl]

'PARTIAL' @ [69:67] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'!' @ [70:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'resolvedCall' @ [70:14] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applicabilityRange[LocalVariableDescriptor]

'isReallySuccess' @ [70:27] ==> public fun ResolvedCall<*>.isReallySuccess(): Boolean defined in org.jetbrains.kotlin.resolve.calls.model[DeserializedSimpleFunctionDescriptor]

'resolvedCall' @ [71:13] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applicabilityRange[LocalVariableDescriptor]

'call' @ [71:26] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out CallableDescriptor)

'typeArgumentList' @ [71:31] ==> public final val Call.typeArgumentList: KtTypeArgumentList?[MyPropertyDescriptor]

'resolvedCall' @ [72:24] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applicabilityRange[LocalVariableDescriptor]

'call' @ [72:37] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out CallableDescriptor)

'valueArguments' @ [72:42] ==> public final val Call.valueArguments: List<(ValueArgument..ValueArgument?)>[MyPropertyDescriptor]

'singleOrNull' @ [72:57] ==> public fun <T> List<(ValueArgument..ValueArgument?)>.singleOrNull(): ValueArgument? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)

'!=' @ [73:13] ==> public open fun equals(other: Any?): Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'resolvedCall' @ [73:14] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applicabilityRange[LocalVariableDescriptor]

'getArgumentMapping' @ [73:27] ==> @NotNull public abstract fun getArgumentMapping(@NotNull p0: ValueArgument): ArgumentMapping defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCall[JavaMethodDescriptor]

'argument' @ [73:46] ==> val argument: ValueArgument defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applicabilityRange[LocalVariableDescriptor]

'valueParameter' @ [73:74] ==> public abstract val valueParameter: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.model.ArgumentMatch[DeserializedPropertyDescriptor]

'index' @ [73:89] ==> public abstract val index: Int defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'!' @ [75:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'element' @ [75:14] ==> value-parameter element: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applicabilityRange[ValueParameterDescriptorImpl]

'isReceiverExpressionWithValue' @ [75:22] ==> public fun KtQualifiedExpression.isReceiverExpressionWithValue(): Boolean defined in org.jetbrains.kotlin.idea.intentions in file Utils.kt[SimpleFunctionDescriptorImpl]

'text' @ [77:9] ==> public final var ReplaceCallWithBinaryOperatorIntention.text: String[MyPropertyDescriptor]

'operation' @ [77:33] ==> val operation: KtSingleValueToken defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applicabilityRange[LocalVariableDescriptor]

'value' @ [77:43] ==> public final val KtSingleValueToken.value: String[MyPropertyDescriptor]

'calleeExpression' @ [78:16] ==> val calleeExpression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applicabilityRange[LocalVariableDescriptor]

'textRange' @ [78:33] ==> public final val KtSimpleNameExpression.textRange: (TextRange..TextRange?)[MyPropertyDescriptor]

'element' @ [82:30] ==> value-parameter element: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[ValueParameterDescriptorImpl]

'callExpression' @ [82:38] ==> public val KtQualifiedExpression.callExpression: KtCallExpression? defined in org.jetbrains.kotlin.idea.intentions in file Utils.kt[PropertyDescriptorImpl]

'operation' @ [83:25] ==> private final fun operation(calleeExpression: KtSimpleNameExpression): KtSingleValueToken? defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention[SimpleFunctionDescriptorImpl]

'callExpression' @ [83:35] ==> val callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[LocalVariableDescriptor]

'calleeExpression' @ [83:50] ==> public final val KtCallExpression.calleeExpression: KtExpression?[MyPropertyDescriptor]

'callExpression' @ [84:24] ==> val callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[LocalVariableDescriptor]

'valueArguments' @ [84:39] ==> public final val KtCallExpression.valueArguments: (MutableList<(KtValueArgument..KtValueArgument?)>..List<(KtValueArgument..KtValueArgument?)>)[MyPropertyDescriptor]

'single' @ [84:54] ==> public fun <T> List<(KtValueArgument..KtValueArgument?)>.single(): (KtValueArgument..KtValueArgument?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtValueArgument..org.jetbrains.kotlin.psi.KtValueArgument?)

'getArgumentExpression' @ [84:63] ==> @IfNotParsed @Nullable public open fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.KtValueArgument[JavaMethodDescriptor]

'element' @ [85:24] ==> value-parameter element: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[ValueParameterDescriptorImpl]

'receiverExpression' @ [85:32] ==> public open val receiverExpression: KtExpression defined in org.jetbrains.kotlin.psi.KtDotQualifiedExpression[DeserializedPropertyDescriptor]

'KtPsiFactory' @ [87:23] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'element' @ [87:36] ==> value-parameter element: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[ValueParameterDescriptorImpl]

'when (operation) {
            KtTokens.EXCLEQ -> {
                val prefixExpression = element.getWrappingPrefixExpressionIfAny() ?: return
                val newExpression = factory.createExpressionByPattern("$0 != $1", receiver, argument)
                prefixExpression.replace(newExpression)
            }
            in OperatorConventions.COMPARISON_OPERATIONS -> {
                val binaryParent = element.parent as? KtBinaryExpression ?: return
                val newExpression = factory.createExpressionByPattern("$0 ${operation.value} $1", receiver, argument)
                binaryParent.replace(newExpression)
            }
            else -> {
                val newExpression = factory.createExpressionByPattern("$0 ${operation.value} $1", receiver, argument)
                element.replace(newExpression)
            }
        }' @ [88:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: PsiElement, entry1: PsiElement, entry2: PsiElement): PsiElement[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> PsiElement

'operation' @ [88:15] ==> val operation: KtSingleValueToken defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[LocalVariableDescriptor]

'EXCLEQ' @ [89:22] ==> public final val EXCLEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'element' @ [90:40] ==> value-parameter element: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[ValueParameterDescriptorImpl]

'getWrappingPrefixExpressionIfAny' @ [90:48] ==> private final fun PsiElement.getWrappingPrefixExpressionIfAny(): KtPrefixExpression? defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention[SimpleFunctionDescriptorImpl]

'factory' @ [91:37] ==> val factory: KtPsiFactory defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[LocalVariableDescriptor]

'createExpressionByPattern' @ [91:45] ==> public fun KtPsiFactory.createExpressionByPattern(pattern: String, vararg args: Any, reformat: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'receiver' @ [91:83] ==> val receiver: KtExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[LocalVariableDescriptor]

'argument' @ [91:93] ==> val argument: KtExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[LocalVariableDescriptor]

'prefixExpression' @ [92:17] ==> val prefixExpression: KtPrefixExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[LocalVariableDescriptor]

'replace' @ [92:34] ==> public open fun replace(newElement: PsiElement): PsiElement defined in org.jetbrains.kotlin.psi.KtPrefixExpression[DeserializedSimpleFunctionDescriptor]

'newExpression' @ [92:42] ==> val newExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[LocalVariableDescriptor]

'in' @ [94:13] ==> public abstract fun contains(@Nullable element: KtSingleValueToken?): Boolean defined in com.google.common.collect.ImmutableSet[JavaMethodDescriptor]

'COMPARISON_OPERATIONS' @ [94:36] ==> public final val COMPARISON_OPERATIONS: (ImmutableSet<(KtSingleValueToken..KtSingleValueToken?)>..ImmutableSet<(KtSingleValueToken..KtSingleValueToken?)>?) defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaPropertyDescriptor]

'element' @ [95:36] ==> value-parameter element: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[ValueParameterDescriptorImpl]

'parent' @ [95:44] ==> public final val KtDotQualifiedExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'factory' @ [96:37] ==> val factory: KtPsiFactory defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[LocalVariableDescriptor]

'createExpressionByPattern' @ [96:45] ==> public fun KtPsiFactory.createExpressionByPattern(pattern: String, vararg args: Any, reformat: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'operation' @ [96:77] ==> val operation: KtSingleValueToken defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[LocalVariableDescriptor]

'value' @ [96:87] ==> public final val KtSingleValueToken.value: String[MyPropertyDescriptor]

'receiver' @ [96:99] ==> val receiver: KtExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[LocalVariableDescriptor]

'argument' @ [96:109] ==> val argument: KtExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[LocalVariableDescriptor]

'binaryParent' @ [97:17] ==> val binaryParent: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[LocalVariableDescriptor]

'replace' @ [97:30] ==> public open fun replace(newElement: PsiElement): PsiElement defined in org.jetbrains.kotlin.psi.KtBinaryExpression[DeserializedSimpleFunctionDescriptor]

'newExpression' @ [97:38] ==> val newExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[LocalVariableDescriptor]

'factory' @ [100:37] ==> val factory: KtPsiFactory defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[LocalVariableDescriptor]

'createExpressionByPattern' @ [100:45] ==> public fun KtPsiFactory.createExpressionByPattern(pattern: String, vararg args: Any, reformat: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'operation' @ [100:77] ==> val operation: KtSingleValueToken defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[LocalVariableDescriptor]

'value' @ [100:87] ==> public final val KtSingleValueToken.value: String[MyPropertyDescriptor]

'receiver' @ [100:99] ==> val receiver: KtExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[LocalVariableDescriptor]

'argument' @ [100:109] ==> val argument: KtExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[LocalVariableDescriptor]

'element' @ [101:17] ==> value-parameter element: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[ValueParameterDescriptorImpl]

'replace' @ [101:25] ==> @NotNull public open fun replace(@NotNull p0: PsiElement): PsiElement defined in org.jetbrains.kotlin.psi.KtDotQualifiedExpression[JavaMethodDescriptor]

'newExpression' @ [101:33] ==> val newExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.applyTo[LocalVariableDescriptor]

'getLastParentOfTypeInRow' @ [108:14] ==> public inline fun <reified T : PsiElement> PsiElement.getLastParentOfTypeInRow(): KtParenthesizedExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtParenthesizedExpression

'this' @ [108:71] ==> <this> defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.getWrappingPrefixExpressionIfAny[ReceiverParameterDescriptorImpl]

'parent' @ [108:77] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'calleeExpression' @ [111:26] ==> value-parameter calleeExpression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.operation[ValueParameterDescriptorImpl]

'getReferencedNameAsName' @ [111:43] ==> public abstract fun getReferencedNameAsName(): Name defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[DeserializedSimpleFunctionDescriptor]

'calleeExpression' @ [112:28] ==> value-parameter calleeExpression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.operation[ValueParameterDescriptorImpl]

'parent' @ [112:45] ==> public final val KtSimpleNameExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [112:52] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'when (identifier) {
            OperatorNameConventions.EQUALS -> {
                val resolvedCall = dotQualified.toResolvedCall(BodyResolveMode.PARTIAL) ?: return null
                val overriddenDescriptors = resolvedCall.resultingDescriptor.findOriginalTopMostOverriddenDescriptors()
                if (overriddenDescriptors.none { it.fqNameUnsafe.asString() == "kotlin.Any.equals" }) return null

                val prefixExpression = dotQualified.getWrappingPrefixExpressionIfAny()
                if (prefixExpression != null && prefixExpression.operationToken == KtTokens.EXCL) KtTokens.EXCLEQ
                else KtTokens.EQEQ
            }
            OperatorNameConventions.COMPARE_TO -> {
                // callee -> call -> DotQualified -> Binary
                val binaryParent = dotQualified.parent as? KtBinaryExpression ?: return null
                val notZero = when {
                    binaryParent.right?.text == "0" -> binaryParent.left
                    binaryParent.left?.text == "0" -> binaryParent.right
                    else -> return null
                }
                if (notZero != dotQualified) return null
                val token = binaryParent.operationToken as? KtSingleValueToken ?: return null
                if (token in OperatorConventions.COMPARISON_OPERATIONS) {
                    if (notZero == binaryParent.left) token else token.inverted()
                }
                else {
                    null
                }
            }
            else -> OperatorConventions.BINARY_OPERATION_NAMES.inverse()[identifier]
        }' @ [113:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KtSingleValueToken?, entry1: KtSingleValueToken?, entry2: KtSingleValueToken?): KtSingleValueToken?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KtSingleValueToken?

'identifier' @ [113:22] ==> val identifier: Name defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.operation[LocalVariableDescriptor]

'OperatorNameConventions' @ [114:13] ==> public object OperatorNameConventions defined in org.jetbrains.kotlin.util[FakeCallableDescriptorForObject]

'EQUALS' @ [114:37] ==> @field:JvmField public final val EQUALS: Name defined in org.jetbrains.kotlin.util.OperatorNameConventions[DeserializedPropertyDescriptor]

'dotQualified' @ [115:36] ==> val dotQualified: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.operation[LocalVariableDescriptor]

'toResolvedCall' @ [115:49] ==> public fun KtQualifiedExpression.toResolvedCall(bodyResolveMode: BodyResolveMode): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.idea.intentions in file Utils.kt[SimpleFunctionDescriptorImpl]

'PARTIAL' @ [115:80] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'resolvedCall' @ [116:45] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.operation[LocalVariableDescriptor]

'resultingDescriptor' @ [116:58] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.resultingDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out CallableDescriptor)

'findOriginalTopMostOverriddenDescriptors' @ [116:78] ==> public fun <D : CallableDescriptor> CallableDescriptor.findOriginalTopMostOverriddenDescriptors(): Set<CallableDescriptor> defined in org.jetbrains.kotlin.resolve[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <D : CallableDescriptor> -> CallableDescriptor

'overriddenDescriptors' @ [117:21] ==> val overriddenDescriptors: Set<CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.operation[LocalVariableDescriptor]

'none' @ [117:43] ==> public inline fun <T> Iterable<CallableDescriptor>.none(predicate: (CallableDescriptor) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> CallableDescriptor

'it' @ [117:50] ==> value-parameter it: CallableDescriptor defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.operation.<anonymous>[ValueParameterDescriptorImpl]

'fqNameUnsafe' @ [117:53] ==> public val DeclarationDescriptor.fqNameUnsafe: FqNameUnsafe defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'asString' @ [117:66] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqNameUnsafe[JavaMethodDescriptor]

'dotQualified' @ [119:40] ==> val dotQualified: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.operation[LocalVariableDescriptor]

'getWrappingPrefixExpressionIfAny' @ [119:53] ==> private final fun PsiElement.getWrappingPrefixExpressionIfAny(): KtPrefixExpression? defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention[SimpleFunctionDescriptorImpl]

'if (prefixExpression != null && prefixExpression.operationToken == KtTokens.EXCL) KtTokens.EXCLEQ
                else KtTokens.EQEQ' @ [120:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (KtSingleValueToken..KtSingleValueToken?), elseBranch: (KtSingleValueToken..KtSingleValueToken?)): (KtSingleValueToken..KtSingleValueToken?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (org.jetbrains.kotlin.lexer.KtSingleValueToken..org.jetbrains.kotlin.lexer.KtSingleValueToken?)

'prefixExpression' @ [120:21] ==> val prefixExpression: KtPrefixExpression? defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.operation[LocalVariableDescriptor]

'prefixExpression' @ [120:49] ==> val prefixExpression: KtPrefixExpression? defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.operation[LocalVariableDescriptor]

'operationToken' @ [120:66] ==> public final val KtPrefixExpression.operationToken: (IElementType..IElementType?)[MyPropertyDescriptor]

'EXCL' @ [120:93] ==> public final val EXCL: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'EXCLEQ' @ [120:108] ==> public final val EXCLEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'EQEQ' @ [121:31] ==> public final val EQEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'OperatorNameConventions' @ [123:13] ==> public object OperatorNameConventions defined in org.jetbrains.kotlin.util[FakeCallableDescriptorForObject]

'COMPARE_TO' @ [123:37] ==> @field:JvmField public final val COMPARE_TO: Name defined in org.jetbrains.kotlin.util.OperatorNameConventions[DeserializedPropertyDescriptor]

'dotQualified' @ [125:36] ==> val dotQualified: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.operation[LocalVariableDescriptor]

'parent' @ [125:49] ==> public final val KtDotQualifiedExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'when {
                    binaryParent.right?.text == "0" -> binaryParent.left
                    binaryParent.left?.text == "0" -> binaryParent.right
                    else -> return null
                }' @ [126:31] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KtExpression?, entry1: KtExpression?, entry2: KtExpression?): KtExpression?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KtExpression?

'binaryParent' @ [127:21] ==> val binaryParent: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.operation[LocalVariableDescriptor]

'right' @ [127:34] ==> public final val KtBinaryExpression.right: KtExpression?[MyPropertyDescriptor]

'text' @ [127:41] ==> public final val KtExpression.text: (String..String?)[MyPropertyDescriptor]

'binaryParent' @ [127:56] ==> val binaryParent: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.operation[LocalVariableDescriptor]

'left' @ [127:69] ==> public final val KtBinaryExpression.left: KtExpression?[MyPropertyDescriptor]

'binaryParent' @ [128:21] ==> val binaryParent: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.operation[LocalVariableDescriptor]

'left' @ [128:34] ==> public final val KtBinaryExpression.left: KtExpression?[MyPropertyDescriptor]

'text' @ [128:40] ==> public final val KtExpression.text: (String..String?)[MyPropertyDescriptor]

'binaryParent' @ [128:55] ==> val binaryParent: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.operation[LocalVariableDescriptor]

'right' @ [128:68] ==> public final val KtBinaryExpression.right: KtExpression?[MyPropertyDescriptor]

'notZero' @ [131:21] ==> val notZero: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.operation[LocalVariableDescriptor]

'dotQualified' @ [131:32] ==> val dotQualified: KtDotQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.operation[LocalVariableDescriptor]

'binaryParent' @ [132:29] ==> val binaryParent: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.operation[LocalVariableDescriptor]

'operationToken' @ [132:42] ==> public final val KtBinaryExpression.operationToken: IElementType[MyPropertyDescriptor]

'if (token in OperatorConventions.COMPARISON_OPERATIONS) {
                    if (notZero == binaryParent.left) token else token.inverted()
                }
                else {
                    null
                }' @ [133:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtSingleValueToken?, elseBranch: KtSingleValueToken?): KtSingleValueToken?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtSingleValueToken?

'token' @ [133:21] ==> val token: KtSingleValueToken defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.operation[LocalVariableDescriptor]

'COMPARISON_OPERATIONS' @ [133:50] ==> public final val COMPARISON_OPERATIONS: (ImmutableSet<(KtSingleValueToken..KtSingleValueToken?)>..ImmutableSet<(KtSingleValueToken..KtSingleValueToken?)>?) defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaPropertyDescriptor]

'if (notZero == binaryParent.left) token else token.inverted()' @ [134:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtSingleValueToken?, elseBranch: KtSingleValueToken?): KtSingleValueToken?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtSingleValueToken?

'notZero' @ [134:25] ==> val notZero: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.operation[LocalVariableDescriptor]

'binaryParent' @ [134:36] ==> val binaryParent: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.operation[LocalVariableDescriptor]

'left' @ [134:49] ==> public final val KtBinaryExpression.left: KtExpression?[MyPropertyDescriptor]

'token' @ [134:55] ==> val token: KtSingleValueToken defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.operation[LocalVariableDescriptor]

'token' @ [134:66] ==> val token: KtSingleValueToken defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.operation[LocalVariableDescriptor]

'inverted' @ [134:72] ==> private final fun IElementType.inverted(): KtSingleValueToken? defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention[SimpleFunctionDescriptorImpl]

'OperatorConventions.BINARY_OPERATION_NAMES.inverse()[identifier]' @ [140:21] ==> public abstract fun get(@Nullable key: Name?): KtSingleValueToken? defined in com.google.common.collect.ImmutableBiMap[JavaMethodDescriptor]

'BINARY_OPERATION_NAMES' @ [140:41] ==> public final val BINARY_OPERATION_NAMES: (ImmutableBiMap<(KtSingleValueToken..KtSingleValueToken?), (Name..Name?)>..ImmutableBiMap<(KtSingleValueToken..KtSingleValueToken?), (Name..Name?)>?) defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaPropertyDescriptor]

'inverse' @ [140:64] ==> public abstract fun inverse(): (ImmutableBiMap<(Name..Name?), (KtSingleValueToken..KtSingleValueToken?)>..ImmutableBiMap<(Name..Name?), (KtSingleValueToken..KtSingleValueToken?)>?) defined in com.google.common.collect.ImmutableBiMap[JavaMethodDescriptor]

'identifier' @ [140:74] ==> val identifier: Name defined in org.jetbrains.kotlin.idea.intentions.conventionNameCalls.ReplaceCallWithBinaryOperatorIntention.operation[LocalVariableDescriptor]

