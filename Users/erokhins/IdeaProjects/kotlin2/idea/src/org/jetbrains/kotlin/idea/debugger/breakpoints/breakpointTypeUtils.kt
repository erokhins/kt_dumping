'getInstance' @ [44:30] ==> @NotNull public open fun getInstance(@NotNull p0: Project): PsiManager defined in com.intellij.psi.PsiManager[JavaMethodDescriptor]

'project' @ [44:42] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt[ValueParameterDescriptorImpl]

'findFile' @ [44:51] ==> @Nullable public abstract fun findFile(@NotNull p0: VirtualFile): PsiFile? defined in com.intellij.psi.PsiManager[JavaMethodDescriptor]

'file' @ [44:60] ==> value-parameter file: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt[ValueParameterDescriptorImpl]

'psiFile' @ [46:9] ==> val psiFile: PsiFile? defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt[LocalVariableDescriptor]

'psiFile' @ [46:28] ==> val psiFile: PsiFile? defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt[LocalVariableDescriptor]

'virtualFile' @ [46:36] ==> public final val PsiFile.virtualFile: (VirtualFile..VirtualFile?)[MyPropertyDescriptor]

'fileType' @ [46:48] ==> public final val VirtualFile.fileType: FileType[MyPropertyDescriptor]

'INSTANCE' @ [46:75] ==> public final val INSTANCE: (KotlinFileType..KotlinFileType?) defined in org.jetbrains.kotlin.idea.KotlinFileType[JavaPropertyDescriptor]

'?:' @ [50:20] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: Document?, right: Document): Document[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> Document

'getInstance' @ [50:40] ==> @NotNull public open fun getInstance(): FileDocumentManager defined in com.intellij.openapi.fileEditor.FileDocumentManager[JavaMethodDescriptor]

'getDocument' @ [50:54] ==> @Nullable public abstract fun getDocument(@NotNull p0: VirtualFile): Document? defined in com.intellij.openapi.fileEditor.FileDocumentManager[JavaMethodDescriptor]

'file' @ [50:66] ==> value-parameter file: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt[ValueParameterDescriptorImpl]

'getInstance' @ [53:19] ==> public open fun getInstance(): (XDebuggerUtil..XDebuggerUtil?) defined in com.intellij.xdebugger.XDebuggerUtil[JavaMethodDescriptor]

'iterateLine' @ [53:33] ==> public final fun iterateLine(@NotNull p0: Project, @NotNull p1: Document, p2: Int, @NotNull p3: ((PsiElement..PsiElement?)) -> Boolean): Unit defined in com.intellij.xdebugger.XDebuggerUtil[MyFunctionDescriptor]

'project' @ [53:45] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt[ValueParameterDescriptorImpl]

'document' @ [53:54] ==> val document: Document defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt[LocalVariableDescriptor]

'line' @ [53:64] ==> value-parameter line: Int defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt[ValueParameterDescriptorImpl]

'el' @ [55:13] ==> value-parameter el: PsiElement defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt.<no name provided>[ValueParameterDescriptorImpl]

'!=' @ [55:36] ==> public open fun equals(other: Any?): Boolean defined in com.intellij.psi.PsiComment[DeserializedSimpleFunctionDescriptor]

'getParentOfType' @ [55:48] ==> @Nullable @Contract public open fun <T : (PsiElement..PsiElement?)> getParentOfType(@Nullable p0: PsiElement?, @NotNull p1: Class<(PsiComment..PsiComment?)>, p2: Boolean): PsiComment? defined in com.intellij.psi.util.PsiTreeUtil[JavaMethodDescriptor]
Inferred types:
    <T : (PsiElement..PsiElement?)> -> (com.intellij.psi.PsiComment..com.intellij.psi.PsiComment?)

'el' @ [55:64] ==> value-parameter el: PsiElement defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt.<no name provided>[ValueParameterDescriptorImpl]

'java' @ [55:86] ==> public val <T> KClass<PsiComment>.java: Class<PsiComment> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> PsiComment

'el' @ [59:23] ==> value-parameter el: PsiElement defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt.<no name provided>[ValueParameterDescriptorImpl]

'element' @ [60:22] ==> var element: PsiElement defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt.<no name provided>[LocalVariableDescriptor]

'parent' @ [60:30] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [61:16] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt.<no name provided>[LocalVariableDescriptor]

'parent' @ [62:26] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt.<no name provided>[LocalVariableDescriptor]

'textOffset' @ [62:33] ==> public final val PsiElement.textOffset: Int[MyPropertyDescriptor]

'offset' @ [63:17] ==> val offset: Int defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt.<no name provided>[LocalVariableDescriptor]

'document' @ [63:32] ==> val document: Document defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt[LocalVariableDescriptor]

'getLineNumber' @ [63:41] ==> @Contract public abstract fun getLineNumber(p0: Int): Int defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'offset' @ [63:55] ==> val offset: Int defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt.<no name provided>[LocalVariableDescriptor]

'line' @ [63:66] ==> value-parameter line: Int defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt[ValueParameterDescriptorImpl]

'element' @ [65:13] ==> var element: PsiElement defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt.<no name provided>[LocalVariableDescriptor]

'parent' @ [65:23] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt.<no name provided>[LocalVariableDescriptor]

'parent' @ [66:13] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt.<no name provided>[LocalVariableDescriptor]

'element' @ [66:22] ==> var element: PsiElement defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt.<no name provided>[LocalVariableDescriptor]

'parent' @ [66:30] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'if (element is KtProperty || element is KtParameter) {
            result = if ((element is KtParameter && element.hasValOrVar()) || (element is KtProperty && !element.isLocal)) {
                KotlinFieldBreakpointType::class.java
            }
            else {
                KotlinLineBreakpointType::class.java
            }
            return false
        }
        else {
            result = KotlinLineBreakpointType::class.java
        }' @ [69:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'element' @ [69:13] ==> var element: PsiElement defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt.<no name provided>[LocalVariableDescriptor]

'element' @ [69:38] ==> var element: PsiElement defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt.<no name provided>[LocalVariableDescriptor]

'result' @ [70:13] ==> var result: Class<*>? defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt[LocalVariableDescriptor]

'if ((element is KtParameter && element.hasValOrVar()) || (element is KtProperty && !element.isLocal)) {
                KotlinFieldBreakpointType::class.java
            }
            else {
                KotlinLineBreakpointType::class.java
            }' @ [70:22] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Class<*>?, elseBranch: Class<*>?): Class<*>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Class<*>?

'element' @ [70:27] ==> var element: PsiElement defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt.<no name provided>[LocalVariableDescriptor]

'element' @ [70:53] ==> var element: PsiElement defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt.<no name provided>[LocalVariableDescriptor]

'hasValOrVar' @ [70:61] ==> public open fun hasValOrVar(): Boolean defined in org.jetbrains.kotlin.psi.KtParameter[JavaMethodDescriptor]

'element' @ [70:80] ==> var element: PsiElement defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt.<no name provided>[LocalVariableDescriptor]

'!' @ [70:105] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'element' @ [70:106] ==> var element: PsiElement defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt.<no name provided>[LocalVariableDescriptor]

'isLocal' @ [70:114] ==> public final val KtProperty.isLocal: Boolean[MyPropertyDescriptor]

'KotlinFieldBreakpointType' @ [71:17] ==> public constructor KotlinFieldBreakpointType() defined in org.jetbrains.kotlin.idea.debugger.breakpoints.KotlinFieldBreakpointType[ClassConstructorDescriptorImpl]

'java' @ [71:50] ==> public val <T> KClass<KotlinFieldBreakpointType>.java: Class<KotlinFieldBreakpointType> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KotlinFieldBreakpointType

'KotlinLineBreakpointType' @ [74:17] ==> public constructor KotlinLineBreakpointType() defined in org.jetbrains.kotlin.idea.debugger.breakpoints.KotlinLineBreakpointType[JavaClassConstructorDescriptor]

'java' @ [74:49] ==> public val <T> KClass<KotlinLineBreakpointType>.java: Class<KotlinLineBreakpointType> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KotlinLineBreakpointType

'result' @ [79:13] ==> var result: Class<*>? defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt[LocalVariableDescriptor]

'KotlinLineBreakpointType' @ [79:22] ==> public constructor KotlinLineBreakpointType() defined in org.jetbrains.kotlin.idea.debugger.breakpoints.KotlinLineBreakpointType[JavaClassConstructorDescriptor]

'java' @ [79:54] ==> public val <T> KClass<KotlinLineBreakpointType>.java: Class<KotlinLineBreakpointType> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KotlinLineBreakpointType

'result' @ [85:12] ==> var result: Class<*>? defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt[LocalVariableDescriptor]

'breakpointTypeClass' @ [85:22] ==> value-parameter breakpointTypeClass: Class<*> defined in org.jetbrains.kotlin.idea.debugger.breakpoints.canPutAt[ValueParameterDescriptorImpl]

'?:' @ [92:16] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtFile?, right: KtFile): KtFile[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtFile

'getInstance' @ [92:27] ==> @NotNull public open fun getInstance(@NotNull p0: Project): PsiManager defined in com.intellij.psi.PsiManager[JavaMethodDescriptor]

'project' @ [92:39] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants[ValueParameterDescriptorImpl]

'findFile' @ [92:48] ==> @Nullable public abstract fun findFile(@NotNull p0: VirtualFile): PsiFile? defined in com.intellij.psi.PsiManager[JavaMethodDescriptor]

'position' @ [92:57] ==> value-parameter position: XSourcePosition defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants[ValueParameterDescriptorImpl]

'file' @ [92:66] ==> public final val XSourcePosition.file: VirtualFile[MyPropertyDescriptor]

'emptyList' @ [92:93] ==> public fun <T> emptyList(): List<JavaLineBreakpointType.JavaBreakpointVariant> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JavaBreakpointVariant

'createFromLine' @ [94:30] ==> public open fun createFromLine(@NotNull p0: PsiFile, p1: Int): (SourcePosition..SourcePosition?) defined in com.intellij.debugger.SourcePosition[JavaMethodDescriptor]

'file' @ [94:45] ==> val file: KtFile defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants[LocalVariableDescriptor]

'position' @ [94:51] ==> value-parameter position: XSourcePosition defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants[ValueParameterDescriptorImpl]

'line' @ [94:60] ==> public final val XSourcePosition.line: Int[MyPropertyDescriptor]

'getLambdasAtLineIfAny' @ [95:19] ==> public fun getLambdasAtLineIfAny(sourcePosition: SourcePosition): List<KtFunction> defined in org.jetbrains.kotlin.idea.debugger.breakpoints in file breakpointTypeUtils.kt[SimpleFunctionDescriptorImpl]

'pos' @ [95:41] ==> val pos: (SourcePosition..SourcePosition?) defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants[LocalVariableDescriptor]

'lambdas' @ [96:9] ==> val lambdas: List<KtFunction> defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants[LocalVariableDescriptor]

'isEmpty' @ [96:17] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'emptyList' @ [96:35] ==> public fun <T> emptyList(): List<JavaLineBreakpointType.JavaBreakpointVariant> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JavaBreakpointVariant

'LinkedList' @ [98:18] ==> public constructor LinkedList<E : (Any..Any?)>() defined in java.util.LinkedList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> JavaBreakpointVariant

'pos' @ [100:21] ==> val pos: (SourcePosition..SourcePosition?) defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants[LocalVariableDescriptor]

'elementAt' @ [100:25] ==> public final val SourcePosition.elementAt: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parentsWithSelf' @ [100:35] ==> public val PsiElement.parentsWithSelf: Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'firstIsInstance' @ [100:51] ==> public inline fun <reified T> Sequence<*>.firstIsInstance(): KtElement defined in org.jetbrains.kotlin.utils.addToStdlib[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T> -> KtElement

'getContainingMethod' @ [101:47] ==> @Nullable public open fun getContainingMethod(@Nullable elem: PsiElement?): PsiElement? defined in org.jetbrains.kotlin.idea.debugger.breakpoints.KotlinLineBreakpointType[JavaMethodDescriptor]

'elementAt' @ [101:67] ==> val elementAt: KtElement defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants[LocalVariableDescriptor]

'mainMethod' @ [102:9] ==> val mainMethod: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants[LocalVariableDescriptor]

'result' @ [103:9] ==> val result: LinkedList<JavaLineBreakpointType.JavaBreakpointVariant> defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants[LocalVariableDescriptor]

'add' @ [103:16] ==> public open fun add(element: JavaLineBreakpointType.JavaBreakpointVariant): Boolean defined in java.util.LinkedList[JavaMethodDescriptor]

'kotlinBreakpointType' @ [103:20] ==> value-parameter kotlinBreakpointType: KotlinLineBreakpointType defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants[ValueParameterDescriptorImpl]

'KotlinLineBreakpointVariant' @ [103:41] ==> public constructor KotlinLineBreakpointVariant(position: (XSourcePosition..XSourcePosition?), element: (PsiElement..PsiElement?)) defined in org.jetbrains.kotlin.idea.debugger.breakpoints.KotlinLineBreakpointType.KotlinLineBreakpointVariant[JavaClassConstructorDescriptor]

'createByElement' @ [104:37] ==> @Nullable public open fun createByElement(@Nullable p0: PsiElement?): XSourcePositionImpl? defined in com.intellij.xdebugger.impl.XSourcePositionImpl[JavaMethodDescriptor]

'mainMethod' @ [104:53] ==> val mainMethod: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants[LocalVariableDescriptor]

'getTopmostElementAtOffset' @ [105:34] ==> @NotNull public open fun getTopmostElementAtOffset(@NotNull element: PsiElement, offset: Int): PsiElement defined in org.jetbrains.kotlin.idea.codeInsight.CodeInsightUtils[JavaMethodDescriptor]

'elementAt' @ [105:60] ==> val elementAt: KtElement defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants[LocalVariableDescriptor]

'pos' @ [105:71] ==> val pos: (SourcePosition..SourcePosition?) defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants[LocalVariableDescriptor]

'offset' @ [105:75] ==> public final val SourcePosition.offset: Int[MyPropertyDescriptor]

'lambdas' @ [108:5] ==> val lambdas: List<KtFunction> defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants[LocalVariableDescriptor]

'forEachIndexed' @ [108:13] ==> public inline fun <T> Iterable<KtFunction>.forEachIndexed(action: (index: Int, KtFunction) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtFunction

'result' @ [109:9] ==> val result: LinkedList<JavaLineBreakpointType.JavaBreakpointVariant> defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants[LocalVariableDescriptor]

'add' @ [109:16] ==> public open fun add(element: JavaLineBreakpointType.JavaBreakpointVariant): Boolean defined in java.util.LinkedList[JavaMethodDescriptor]

'kotlinBreakpointType' @ [109:20] ==> value-parameter kotlinBreakpointType: KotlinLineBreakpointType defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants[ValueParameterDescriptorImpl]

'KotlinLambdaBreakpointVariant' @ [109:41] ==> public constructor KotlinLambdaBreakpointVariant(position: (XSourcePosition..XSourcePosition?), function: (KtFunction..KtFunction?), lambdaOrdinal: (Int..Int?)) defined in org.jetbrains.kotlin.idea.debugger.breakpoints.KotlinLineBreakpointType.KotlinLambdaBreakpointVariant[JavaClassConstructorDescriptor]

'createByElement' @ [110:37] ==> @Nullable public open fun createByElement(@Nullable p0: PsiElement?): XSourcePositionImpl? defined in com.intellij.xdebugger.impl.XSourcePositionImpl[JavaMethodDescriptor]

'lambda' @ [110:53] ==> value-parameter lambda: KtFunction defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants.<anonymous>[ValueParameterDescriptorImpl]

'bodyExpression' @ [110:60] ==> public final val KtFunction.bodyExpression: KtExpression?[MyPropertyDescriptor]

'lambda' @ [110:77] ==> value-parameter lambda: KtFunction defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants.<anonymous>[ValueParameterDescriptorImpl]

'ordinal' @ [110:85] ==> value-parameter ordinal: Int defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants.<anonymous>[ValueParameterDescriptorImpl]

'kotlinBreakpointType' @ [113:26] ==> value-parameter kotlinBreakpointType: KotlinLineBreakpointType defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants[ValueParameterDescriptorImpl]

'JavaBreakpointVariant' @ [113:74] ==> public constructor JavaBreakpointVariant(@NotNull p0: XSourcePosition) defined in com.intellij.debugger.ui.breakpoints.JavaLineBreakpointType.JavaBreakpointVariant[JavaClassConstructorDescriptor]

'position' @ [113:96] ==> value-parameter position: XSourcePosition defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants[ValueParameterDescriptorImpl]

'result' @ [114:5] ==> val result: LinkedList<JavaLineBreakpointType.JavaBreakpointVariant> defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants[LocalVariableDescriptor]

'addFirst' @ [114:12] ==> public open fun addFirst(p0: (JavaLineBreakpointType.JavaBreakpointVariant..JavaLineBreakpointType.JavaBreakpointVariant?)): Unit defined in java.util.LinkedList[JavaMethodDescriptor]

'allBreakpoint' @ [114:21] ==> val allBreakpoint: JavaLineBreakpointType.JavaBreakpointVariant defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants[LocalVariableDescriptor]

'result' @ [116:12] ==> val result: LinkedList<JavaLineBreakpointType.JavaBreakpointVariant> defined in org.jetbrains.kotlin.idea.debugger.breakpoints.computeVariants[LocalVariableDescriptor]

'sourcePosition' @ [120:16] ==> value-parameter sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.breakpoints.getLambdasAtLineIfAny[ValueParameterDescriptorImpl]

'file' @ [120:31] ==> public final val SourcePosition.file: PsiFile[MyPropertyDescriptor]

'emptyList' @ [120:57] ==> public fun <T> emptyList(): List<KtFunction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtFunction

'sourcePosition' @ [121:22] ==> value-parameter sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.breakpoints.getLambdasAtLineIfAny[ValueParameterDescriptorImpl]

'line' @ [121:37] ==> public final val SourcePosition.line: Int[MyPropertyDescriptor]

'getLambdasAtLineIfAny' @ [122:12] ==> public fun getLambdasAtLineIfAny(file: KtFile, line: Int): List<KtFunction> defined in org.jetbrains.kotlin.idea.debugger.breakpoints in file breakpointTypeUtils.kt[SimpleFunctionDescriptorImpl]

'file' @ [122:34] ==> val file: KtFile defined in org.jetbrains.kotlin.idea.debugger.breakpoints.getLambdasAtLineIfAny[LocalVariableDescriptor]

'lineNumber' @ [122:40] ==> val lineNumber: Int defined in org.jetbrains.kotlin.idea.debugger.breakpoints.getLambdasAtLineIfAny[LocalVariableDescriptor]

'findElementAtLine' @ [126:23] ==> public fun findElementAtLine(file: KtFile, line: Int): PsiElement? defined in org.jetbrains.kotlin.idea.debugger in file debuggerUtil.kt[SimpleFunctionDescriptorImpl]

'file' @ [126:41] ==> value-parameter file: KtFile defined in org.jetbrains.kotlin.idea.debugger.breakpoints.getLambdasAtLineIfAny[ValueParameterDescriptorImpl]

'line' @ [126:47] ==> value-parameter line: Int defined in org.jetbrains.kotlin.idea.debugger.breakpoints.getLambdasAtLineIfAny[ValueParameterDescriptorImpl]

'emptyList' @ [126:77] ==> public fun <T> emptyList(): List<KtFunction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtFunction

'lineElement' @ [128:17] ==> val lineElement: KtElement defined in org.jetbrains.kotlin.idea.debugger.breakpoints.getLambdasAtLineIfAny[LocalVariableDescriptor]

'startOffset' @ [128:29] ==> public val PsiElement.startOffset: Int defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'lineElement' @ [129:15] ==> val lineElement: KtElement defined in org.jetbrains.kotlin.idea.debugger.breakpoints.getLambdasAtLineIfAny[LocalVariableDescriptor]

'endOffset' @ [129:27] ==> public val PsiElement.endOffset: Int defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'findElementsOfClassInRange' @ [132:13] ==> @NotNull public open fun findElementsOfClassInRange(@NotNull file: PsiFile, startOffset: Int, endOffset: Int, vararg classes: (Class<out (PsiElement..PsiElement?)>..Class<out (PsiElement..PsiElement?)>?)): (MutableList<(PsiElement..PsiElement?)>..List<(PsiElement..PsiElement?)>) defined in org.jetbrains.kotlin.idea.codeInsight.CodeInsightUtils[JavaMethodDescriptor]

'file' @ [132:40] ==> value-parameter file: KtFile defined in org.jetbrains.kotlin.idea.debugger.breakpoints.getLambdasAtLineIfAny[ValueParameterDescriptorImpl]

'start' @ [132:46] ==> val start: Int defined in org.jetbrains.kotlin.idea.debugger.breakpoints.getLambdasAtLineIfAny[LocalVariableDescriptor]

'end' @ [132:53] ==> val end: Int defined in org.jetbrains.kotlin.idea.debugger.breakpoints.getLambdasAtLineIfAny[LocalVariableDescriptor]

'java' @ [132:76] ==> public val <T> KClass<KtFunction>.java: Class<KtFunction> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtFunction

'filterIsInstance' @ [133:14] ==> public inline fun <reified R> Iterable<*>.filterIsInstance(): List<KtFunction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified R> -> KtFunction

'filter' @ [135:14] ==> public inline fun <T> Iterable<KtFunction>.filter(predicate: (KtFunction) -> Boolean): List<KtFunction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtFunction

'it' @ [135:23] ==> value-parameter it: KtFunction defined in org.jetbrains.kotlin.idea.debugger.breakpoints.getLambdasAtLineIfAny.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [135:50] ==> value-parameter it: KtFunction defined in org.jetbrains.kotlin.idea.debugger.breakpoints.getLambdasAtLineIfAny.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [135:53] ==> public final val KtFunction.name: String?[MyPropertyDescriptor]

'toSet' @ [136:14] ==> public fun <T> Iterable<KtFunction>.toSet(): Set<KtFunction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtFunction

'allLiterals' @ [138:12] ==> val allLiterals: Set<KtFunction> defined in org.jetbrains.kotlin.idea.debugger.breakpoints.getLambdasAtLineIfAny[LocalVariableDescriptor]

'filter' @ [138:24] ==> public inline fun <T> Iterable<KtFunction>.filter(predicate: (KtFunction) -> Boolean): List<KtFunction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtFunction

'?:' @ [139:25] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtExpression?, right: KtExpression): KtExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtExpression

'it' @ [139:26] ==> value-parameter it: KtFunction defined in org.jetbrains.kotlin.idea.debugger.breakpoints.getLambdasAtLineIfAny.<anonymous>[ValueParameterDescriptorImpl]

'bodyExpression' @ [139:29] ==> public final val KtFunction.bodyExpression: KtExpression?[MyPropertyDescriptor]

'statements' @ [139:68] ==> public final val KtBlockExpression.statements: List<(KtExpression..KtExpression?)>[MyPropertyDescriptor]

'firstOrNull' @ [139:80] ==> public fun <T> List<(KtExpression..KtExpression?)>.firstOrNull(): KtExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)

'it' @ [139:97] ==> value-parameter it: KtFunction defined in org.jetbrains.kotlin.idea.debugger.breakpoints.getLambdasAtLineIfAny.<anonymous>[ValueParameterDescriptorImpl]

'statement' @ [140:9] ==> val statement: KtExpression defined in org.jetbrains.kotlin.idea.debugger.breakpoints.getLambdasAtLineIfAny.<anonymous>[LocalVariableDescriptor]

'getLineNumber' @ [140:19] ==> public fun PsiElement.getLineNumber(start: Boolean = ...): Int defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'line' @ [140:38] ==> value-parameter line: Int defined in org.jetbrains.kotlin.idea.debugger.breakpoints.getLambdasAtLineIfAny[ValueParameterDescriptorImpl]

'statement' @ [140:46] ==> val statement: KtExpression defined in org.jetbrains.kotlin.idea.debugger.breakpoints.getLambdasAtLineIfAny.<anonymous>[LocalVariableDescriptor]

'getLineNumber' @ [140:56] ==> public fun PsiElement.getLineNumber(start: Boolean = ...): Int defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'line' @ [140:80] ==> value-parameter line: Int defined in org.jetbrains.kotlin.idea.debugger.breakpoints.getLambdasAtLineIfAny[ValueParameterDescriptorImpl]

