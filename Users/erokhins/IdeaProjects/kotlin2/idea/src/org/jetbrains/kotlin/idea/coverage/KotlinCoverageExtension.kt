'JavaCoverageEngineExtension' @ [42:33] ==> public constructor JavaCoverageEngineExtension() defined in com.intellij.coverage.JavaCoverageEngineExtension[JavaClassConstructorDescriptor]

'getInstance' @ [43:30] ==> @NotNull public open fun getInstance(@NotNull p0: raw (Class<(Any..Any?)>..Class<*>)): Logger defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'KotlinCoverageExtension' @ [43:42] ==> public companion object defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension[FakeCallableDescriptorForObject]

'java' @ [43:73] ==> public val <T> KClass<KotlinCoverageExtension>.java: Class<KotlinCoverageExtension> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KotlinCoverageExtension

'conf' @ [45:73] ==> value-parameter conf: RunConfigurationBase? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.isApplicableTo[ValueParameterDescriptorImpl]

'sourceFile' @ [48:13] ==> value-parameter sourceFile: PsiFile defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.suggestQualifiedName[ValueParameterDescriptorImpl]

'collectGeneratedClassQualifiedNames' @ [49:26] ==> public final fun collectGeneratedClassQualifiedNames(outputRoot: VirtualFile?, file: KtFile): List<String>? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion[SimpleFunctionDescriptorImpl]

'findOutputRoot' @ [49:62] ==> private final fun findOutputRoot(file: KtFile): VirtualFile? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion[SimpleFunctionDescriptorImpl]

'sourceFile' @ [49:77] ==> value-parameter sourceFile: PsiFile defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.suggestQualifiedName[ValueParameterDescriptorImpl]

'sourceFile' @ [49:90] ==> value-parameter sourceFile: PsiFile defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.suggestQualifiedName[ValueParameterDescriptorImpl]

'qNames' @ [50:17] ==> val qNames: List<String>? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.suggestQualifiedName[LocalVariableDescriptor]

'names' @ [51:17] ==> value-parameter names: MutableSet<String> defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.suggestQualifiedName[ValueParameterDescriptorImpl]

'addAll' @ [51:23] ==> public abstract fun addAll(elements: Collection<String>): Boolean defined in kotlin.collections.MutableSet[DeserializedSimpleFunctionDescriptor]

'qNames' @ [51:30] ==> val qNames: List<String>? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.suggestQualifiedName[LocalVariableDescriptor]

'element' @ [61:13] ==> value-parameter element: PsiNamedElement defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.getSummaryCoverageInfo[ValueParameterDescriptorImpl]

'LOG' @ [64:9] ==> private final val LOG: Logger defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension[PropertyDescriptorImpl]

'info' @ [64:13] ==> public abstract fun info(@NonNls p0: (String..String?)): Unit defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'+' @ [64:18] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'element' @ [64:47] ==> value-parameter element: PsiNamedElement defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.getSummaryCoverageInfo[ValueParameterDescriptorImpl]

'name' @ [64:55] ==> public final var KtFile.name: String[MyPropertyDescriptor]

'collectGeneratedClassQualifiedNames' @ [66:30] ==> public final fun collectGeneratedClassQualifiedNames(outputRoot: VirtualFile?, file: KtFile): List<String>? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion[SimpleFunctionDescriptorImpl]

'findOutputRoot' @ [66:66] ==> private final fun findOutputRoot(file: KtFile): VirtualFile? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion[SimpleFunctionDescriptorImpl]

'element' @ [66:81] ==> value-parameter element: PsiNamedElement defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.getSummaryCoverageInfo[ValueParameterDescriptorImpl]

'element' @ [66:91] ==> value-parameter element: PsiNamedElement defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.getSummaryCoverageInfo[ValueParameterDescriptorImpl]

'if (qualifiedNames == null) null else totalCoverageForQualifiedNames(coverageAnnotator, qualifiedNames)' @ [67:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: PackageAnnotator.ClassCoverageInfo?, elseBranch: PackageAnnotator.ClassCoverageInfo?): PackageAnnotator.ClassCoverageInfo?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> ClassCoverageInfo?

'qualifiedNames' @ [67:20] ==> val qualifiedNames: List<String>? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.getSummaryCoverageInfo[LocalVariableDescriptor]

'totalCoverageForQualifiedNames' @ [67:54] ==> private final fun totalCoverageForQualifiedNames(coverageAnnotator: JavaCoverageAnnotator, qualifiedNames: List<String>): PackageAnnotator.ClassCoverageInfo defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion[SimpleFunctionDescriptorImpl]

'coverageAnnotator' @ [67:85] ==> value-parameter coverageAnnotator: JavaCoverageAnnotator defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.getSummaryCoverageInfo[ValueParameterDescriptorImpl]

'qualifiedNames' @ [67:104] ==> val qualifiedNames: List<String>? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.getSummaryCoverageInfo[LocalVariableDescriptor]

'srcFile' @ [81:13] ==> value-parameter srcFile: PsiFile defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.collectOutputFiles[ValueParameterDescriptorImpl]

'getInstance' @ [82:48] ==> public open fun getInstance(@NotNull p0: Project): (ProjectRootManager..ProjectRootManager?) defined in com.intellij.openapi.roots.ProjectRootManager[JavaMethodDescriptor]

'srcFile' @ [82:60] ==> value-parameter srcFile: PsiFile defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.collectOutputFiles[ValueParameterDescriptorImpl]

'getProject' @ [82:68] ==> @NotNull @Contract public abstract fun getProject(): Project defined in com.intellij.psi.PsiFile[JavaMethodDescriptor]

'fileIndex' @ [82:82] ==> public final val ProjectRootManager.fileIndex: ProjectFileIndex[MyPropertyDescriptor]

'fileIndex' @ [83:17] ==> val fileIndex: ProjectFileIndex defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.collectOutputFiles[LocalVariableDescriptor]

'isInLibraryClasses' @ [83:27] ==> public abstract fun isInLibraryClasses(@NotNull p0: VirtualFile): Boolean defined in com.intellij.openapi.roots.ProjectFileIndex[JavaMethodDescriptor]

'srcFile' @ [83:46] ==> value-parameter srcFile: PsiFile defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.collectOutputFiles[ValueParameterDescriptorImpl]

'getVirtualFile' @ [83:54] ==> public abstract fun getVirtualFile(): (VirtualFile..VirtualFile?) defined in com.intellij.psi.PsiFile[JavaMethodDescriptor]

'fileIndex' @ [84:17] ==> val fileIndex: ProjectFileIndex defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.collectOutputFiles[LocalVariableDescriptor]

'isInLibrarySource' @ [84:27] ==> public abstract fun isInLibrarySource(@NotNull p0: VirtualFile): Boolean defined in com.intellij.openapi.roots.ProjectFileIndex[JavaMethodDescriptor]

'srcFile' @ [84:45] ==> value-parameter srcFile: PsiFile defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.collectOutputFiles[ValueParameterDescriptorImpl]

'getVirtualFile' @ [84:53] ==> public abstract fun getVirtualFile(): (VirtualFile..VirtualFile?) defined in com.intellij.psi.PsiFile[JavaMethodDescriptor]

'runReadAction' @ [88:13] ==> public fun <T> runReadAction(action: () -> MutableSet<File>): MutableSet<File> defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> MutableSet<File>

'findOutputRoot' @ [89:34] ==> private final fun findOutputRoot(file: KtFile): VirtualFile? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion[SimpleFunctionDescriptorImpl]

'srcFile' @ [89:49] ==> value-parameter srcFile: PsiFile defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.collectOutputFiles[ValueParameterDescriptorImpl]

'getClassesGeneratedFromFile' @ [90:42] ==> private final fun getClassesGeneratedFromFile(outputRoot: VirtualFile?, file: KtFile): List<VirtualFile> defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion[SimpleFunctionDescriptorImpl]

'outputRoot' @ [90:70] ==> val outputRoot: VirtualFile? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.collectOutputFiles.<anonymous>[LocalVariableDescriptor]

'srcFile' @ [90:82] ==> value-parameter srcFile: PsiFile defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.collectOutputFiles[ValueParameterDescriptorImpl]

'existingClassFiles' @ [91:17] ==> val existingClassFiles: List<VirtualFile> defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.collectOutputFiles.<anonymous>[LocalVariableDescriptor]

'mapTo' @ [91:36] ==> public inline fun <T, R, C : MutableCollection<in File>> Iterable<VirtualFile>.mapTo(destination: MutableSet<File>, transform: (VirtualFile) -> File): MutableSet<File> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> VirtualFile
    <R> -> File
    <C : MutableCollection<in R>> -> MutableSet<File>

'classFiles' @ [91:42] ==> value-parameter classFiles: MutableSet<File> defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.collectOutputFiles[ValueParameterDescriptorImpl]

'File' @ [91:56] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'it' @ [91:61] ==> value-parameter it: VirtualFile defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.collectOutputFiles.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'path' @ [91:64] ==> public final val VirtualFile.path: String[MyPropertyDescriptor]

'getInstance' @ [99:34] ==> @NotNull public open fun getInstance(@NotNull p0: raw (Class<(Any..Any?)>..Class<*>)): Logger defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'KotlinCoverageExtension' @ [99:46] ==> public companion object defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension[FakeCallableDescriptorForObject]

'java' @ [99:77] ==> public val <T> KClass<KotlinCoverageExtension>.java: Class<KotlinCoverageExtension> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KotlinCoverageExtension

'getClassesGeneratedFromFile' @ [102:38] ==> private final fun getClassesGeneratedFromFile(outputRoot: VirtualFile?, file: KtFile): List<VirtualFile> defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion[SimpleFunctionDescriptorImpl]

'outputRoot' @ [102:66] ==> value-parameter outputRoot: VirtualFile? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.collectGeneratedClassQualifiedNames[ValueParameterDescriptorImpl]

'file' @ [102:78] ==> value-parameter file: KtFile defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.collectGeneratedClassQualifiedNames[ValueParameterDescriptorImpl]

'existingClassFiles' @ [103:17] ==> val existingClassFiles: List<VirtualFile> defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.collectGeneratedClassQualifiedNames[LocalVariableDescriptor]

'isEmpty' @ [103:36] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'LOG' @ [106:13] ==> private final val LOG: Logger defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion[PropertyDescriptorImpl]

'debug' @ [106:17] ==> public abstract fun debug(@NonNls p0: (String..String?)): Unit defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'existingClassFiles' @ [106:39] ==> val existingClassFiles: List<VirtualFile> defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.collectGeneratedClassQualifiedNames[LocalVariableDescriptor]

'joinToString' @ [106:58] ==> public fun <T> Iterable<VirtualFile>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((VirtualFile) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> VirtualFile

'it' @ [106:73] ==> value-parameter it: VirtualFile defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.collectGeneratedClassQualifiedNames.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [106:76] ==> public final val VirtualFile.name: String[MyPropertyDescriptor]

'existingClassFiles' @ [107:20] ==> val existingClassFiles: List<VirtualFile> defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.collectGeneratedClassQualifiedNames[LocalVariableDescriptor]

'map' @ [107:39] ==> public inline fun <T, R> Iterable<VirtualFile>.map(transform: (VirtualFile) -> String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> VirtualFile
    <R> -> String

'!!' @ [108:36] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: String?): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> String

'getRelativePath' @ [108:48] ==> @Nullable public open fun getRelativePath(@NotNull p0: VirtualFile, @NotNull p1: VirtualFile): String? defined in com.intellij.openapi.vfs.VfsUtilCore[JavaMethodDescriptor]

'it' @ [108:64] ==> value-parameter it: VirtualFile defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.collectGeneratedClassQualifiedNames.<anonymous>[ValueParameterDescriptorImpl]

'outputRoot' @ [108:68] ==> value-parameter outputRoot: VirtualFile? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.collectGeneratedClassQualifiedNames[ValueParameterDescriptorImpl]

'trimEnd' @ [109:28] ==> @NotNull @Contract public open fun trimEnd(@NotNull p0: String, @NonNls @NotNull p1: String): String defined in com.intellij.openapi.util.text.StringUtil[JavaMethodDescriptor]

'relativePath' @ [109:36] ==> val relativePath: String defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.collectGeneratedClassQualifiedNames.<anonymous>[LocalVariableDescriptor]

'replace' @ [109:60] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'ClassCoverageInfo' @ [115:43] ==> public constructor ClassCoverageInfo() defined in com.intellij.coverage.PackageAnnotator.ClassCoverageInfo[JavaClassConstructorDescriptor]

'result' @ [116:13] ==> val result: PackageAnnotator.ClassCoverageInfo defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.totalCoverageForQualifiedNames[LocalVariableDescriptor]

'totalClassCount' @ [116:20] ==> public final var totalClassCount: Int defined in com.intellij.coverage.PackageAnnotator.ClassCoverageInfo[JavaPropertyDescriptor]

'qualifiedNames' @ [117:13] ==> value-parameter qualifiedNames: List<String> defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.totalCoverageForQualifiedNames[ValueParameterDescriptorImpl]

'forEach' @ [117:28] ==> @HidesMembers public inline fun <T> Iterable<String>.forEach(action: (String) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'coverageAnnotator' @ [118:33] ==> value-parameter coverageAnnotator: JavaCoverageAnnotator defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.totalCoverageForQualifiedNames[ValueParameterDescriptorImpl]

'getClassCoverageInfo' @ [118:51] ==> @Nullable public open fun getClassCoverageInfo(p0: (String..String?)): PackageAnnotator.ClassCoverageInfo? defined in com.intellij.coverage.JavaCoverageAnnotator[JavaMethodDescriptor]

'it' @ [118:72] ==> value-parameter it: String defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.totalCoverageForQualifiedNames.<anonymous>[ValueParameterDescriptorImpl]

'if (classInfo != null) {
                    result.totalClassCount += classInfo.totalClassCount
                    result.coveredClassCount += classInfo.coveredClassCount
                    result.totalMethodCount += classInfo.totalMethodCount
                    result.coveredMethodCount += classInfo.coveredMethodCount
                    result.totalLineCount += classInfo.totalLineCount
                    result.fullyCoveredLineCount += classInfo.fullyCoveredLineCount
                    result.partiallyCoveredLineCount += classInfo.partiallyCoveredLineCount
                }
                else {
                    LOG.debug("Found no coverage for $it")
                }' @ [119:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'classInfo' @ [119:21] ==> val classInfo: PackageAnnotator.ClassCoverageInfo? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.totalCoverageForQualifiedNames.<anonymous>[LocalVariableDescriptor]

'result' @ [120:21] ==> val result: PackageAnnotator.ClassCoverageInfo defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.totalCoverageForQualifiedNames[LocalVariableDescriptor]

'totalClassCount' @ [120:28] ==> public final var totalClassCount: Int defined in com.intellij.coverage.PackageAnnotator.ClassCoverageInfo[JavaPropertyDescriptor]

'classInfo' @ [120:47] ==> val classInfo: PackageAnnotator.ClassCoverageInfo? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.totalCoverageForQualifiedNames.<anonymous>[LocalVariableDescriptor]

'totalClassCount' @ [120:57] ==> public final var totalClassCount: Int defined in com.intellij.coverage.PackageAnnotator.ClassCoverageInfo[JavaPropertyDescriptor]

'result' @ [121:21] ==> val result: PackageAnnotator.ClassCoverageInfo defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.totalCoverageForQualifiedNames[LocalVariableDescriptor]

'coveredClassCount' @ [121:28] ==> public final var coveredClassCount: Int defined in com.intellij.coverage.PackageAnnotator.ClassCoverageInfo[JavaPropertyDescriptor]

'classInfo' @ [121:49] ==> val classInfo: PackageAnnotator.ClassCoverageInfo? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.totalCoverageForQualifiedNames.<anonymous>[LocalVariableDescriptor]

'coveredClassCount' @ [121:59] ==> public final var coveredClassCount: Int defined in com.intellij.coverage.PackageAnnotator.ClassCoverageInfo[JavaPropertyDescriptor]

'result' @ [122:21] ==> val result: PackageAnnotator.ClassCoverageInfo defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.totalCoverageForQualifiedNames[LocalVariableDescriptor]

'totalMethodCount' @ [122:28] ==> public final var totalMethodCount: Int defined in com.intellij.coverage.PackageAnnotator.ClassCoverageInfo[JavaPropertyDescriptor]

'classInfo' @ [122:48] ==> val classInfo: PackageAnnotator.ClassCoverageInfo? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.totalCoverageForQualifiedNames.<anonymous>[LocalVariableDescriptor]

'totalMethodCount' @ [122:58] ==> public final var totalMethodCount: Int defined in com.intellij.coverage.PackageAnnotator.ClassCoverageInfo[JavaPropertyDescriptor]

'result' @ [123:21] ==> val result: PackageAnnotator.ClassCoverageInfo defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.totalCoverageForQualifiedNames[LocalVariableDescriptor]

'coveredMethodCount' @ [123:28] ==> public final var coveredMethodCount: Int defined in com.intellij.coverage.PackageAnnotator.ClassCoverageInfo[JavaPropertyDescriptor]

'classInfo' @ [123:50] ==> val classInfo: PackageAnnotator.ClassCoverageInfo? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.totalCoverageForQualifiedNames.<anonymous>[LocalVariableDescriptor]

'coveredMethodCount' @ [123:60] ==> public final var coveredMethodCount: Int defined in com.intellij.coverage.PackageAnnotator.ClassCoverageInfo[JavaPropertyDescriptor]

'result' @ [124:21] ==> val result: PackageAnnotator.ClassCoverageInfo defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.totalCoverageForQualifiedNames[LocalVariableDescriptor]

'totalLineCount' @ [124:28] ==> public final var totalLineCount: Int defined in com.intellij.coverage.PackageAnnotator.ClassCoverageInfo[JavaPropertyDescriptor]

'classInfo' @ [124:46] ==> val classInfo: PackageAnnotator.ClassCoverageInfo? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.totalCoverageForQualifiedNames.<anonymous>[LocalVariableDescriptor]

'totalLineCount' @ [124:56] ==> public final var totalLineCount: Int defined in com.intellij.coverage.PackageAnnotator.ClassCoverageInfo[JavaPropertyDescriptor]

'result' @ [125:21] ==> val result: PackageAnnotator.ClassCoverageInfo defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.totalCoverageForQualifiedNames[LocalVariableDescriptor]

'fullyCoveredLineCount' @ [125:28] ==> public final var fullyCoveredLineCount: Int defined in com.intellij.coverage.PackageAnnotator.ClassCoverageInfo[JavaPropertyDescriptor]

'classInfo' @ [125:53] ==> val classInfo: PackageAnnotator.ClassCoverageInfo? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.totalCoverageForQualifiedNames.<anonymous>[LocalVariableDescriptor]

'fullyCoveredLineCount' @ [125:63] ==> public final var fullyCoveredLineCount: Int defined in com.intellij.coverage.PackageAnnotator.ClassCoverageInfo[JavaPropertyDescriptor]

'result' @ [126:21] ==> val result: PackageAnnotator.ClassCoverageInfo defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.totalCoverageForQualifiedNames[LocalVariableDescriptor]

'partiallyCoveredLineCount' @ [126:28] ==> public final var partiallyCoveredLineCount: Int defined in com.intellij.coverage.PackageAnnotator.ClassCoverageInfo[JavaPropertyDescriptor]

'classInfo' @ [126:57] ==> val classInfo: PackageAnnotator.ClassCoverageInfo? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.totalCoverageForQualifiedNames.<anonymous>[LocalVariableDescriptor]

'partiallyCoveredLineCount' @ [126:67] ==> public final var partiallyCoveredLineCount: Int defined in com.intellij.coverage.PackageAnnotator.ClassCoverageInfo[JavaPropertyDescriptor]

'LOG' @ [129:21] ==> private final val LOG: Logger defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion[PropertyDescriptorImpl]

'debug' @ [129:25] ==> public abstract fun debug(@NonNls p0: (String..String?)): Unit defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'it' @ [129:55] ==> value-parameter it: String defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.totalCoverageForQualifiedNames.<anonymous>[ValueParameterDescriptorImpl]

'result' @ [132:20] ==> val result: PackageAnnotator.ClassCoverageInfo defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.totalCoverageForQualifiedNames[LocalVariableDescriptor]

'file' @ [136:32] ==> value-parameter file: KtFile defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.getClassesGeneratedFromFile[ValueParameterDescriptorImpl]

'packageFqName' @ [136:37] ==> public final val KtFile.packageFqName: FqName[MyPropertyDescriptor]

'asString' @ [136:51] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'replace' @ [136:62] ==> public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'outputRoot' @ [137:36] ==> value-parameter outputRoot: VirtualFile? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.getClassesGeneratedFromFile[ValueParameterDescriptorImpl]

'findFileByRelativePath' @ [137:48] ==> @Nullable public open fun findFileByRelativePath(@NotNull p0: String): VirtualFile? defined in com.intellij.openapi.vfs.VirtualFile[JavaMethodDescriptor]

'relativePath' @ [137:71] ==> val relativePath: String defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.getClassesGeneratedFromFile[LocalVariableDescriptor]

'packageOutputDir' @ [138:17] ==> val packageOutputDir: VirtualFile? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.getClassesGeneratedFromFile[LocalVariableDescriptor]

'listOf' @ [138:50] ==> @InlineOnly public inline fun <T> listOf(): List<VirtualFile> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> VirtualFile

'collectClassFilePrefixes' @ [140:28] ==> private final fun collectClassFilePrefixes(file: KtFile): Collection<String> defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion[SimpleFunctionDescriptorImpl]

'file' @ [140:53] ==> value-parameter file: KtFile defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.getClassesGeneratedFromFile[ValueParameterDescriptorImpl]

'LOG' @ [141:13] ==> private final val LOG: Logger defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion[PropertyDescriptorImpl]

'debug' @ [141:17] ==> public abstract fun debug(@NonNls p0: (String..String?)): Unit defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'prefixes' @ [141:47] ==> val prefixes: Collection<String> defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.getClassesGeneratedFromFile[LocalVariableDescriptor]

'joinToString' @ [141:56] ==> public fun <T> Iterable<String>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((String) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'packageOutputDir' @ [142:20] ==> val packageOutputDir: VirtualFile? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.getClassesGeneratedFromFile[LocalVariableDescriptor]

'children' @ [142:37] ==> public final val VirtualFile.children: (Array<(VirtualFile..VirtualFile?)>..Array<out (VirtualFile..VirtualFile?)>?)[MyPropertyDescriptor]

'filter' @ [142:46] ==> public inline fun <T> Array<out (VirtualFile..VirtualFile?)>.filter(predicate: ((VirtualFile..VirtualFile?)) -> Boolean): List<(VirtualFile..VirtualFile?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.openapi.vfs.VirtualFile..com.intellij.openapi.vfs.VirtualFile?)

'prefixes' @ [143:25] ==> val prefixes: Collection<String> defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.getClassesGeneratedFromFile[LocalVariableDescriptor]

'any' @ [143:34] ==> public inline fun <T> Iterable<String>.any(predicate: (String) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'file' @ [144:18] ==> value-parameter file: (VirtualFile..VirtualFile?) defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.getClassesGeneratedFromFile.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [144:23] ==> public final val VirtualFile.name: String[MyPropertyDescriptor]

'startsWith' @ [144:28] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'it' @ [144:39] ==> value-parameter it: String defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.getClassesGeneratedFromFile.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'==' @ [144:52] ==> public open fun equals(other: Any?): Boolean defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'getExtension' @ [144:63] ==> @NotNull public open fun getExtension(@NotNull p0: String): String defined in com.intellij.openapi.util.io.FileUtilRt[JavaMethodDescriptor]

'file' @ [144:76] ==> value-parameter file: (VirtualFile..VirtualFile?) defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.getClassesGeneratedFromFile.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [144:81] ==> public final val VirtualFile.name: String[MyPropertyDescriptor]

'file' @ [145:17] ==> value-parameter file: (VirtualFile..VirtualFile?) defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.getClassesGeneratedFromFile.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [145:22] ==> public final val VirtualFile.name: String[MyPropertyDescriptor]

'it' @ [145:30] ==> value-parameter it: String defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.getClassesGeneratedFromFile.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'findModuleForPsiElement' @ [151:41] ==> @Nullable public open fun findModuleForPsiElement(@NotNull p0: PsiElement): Module? defined in com.intellij.openapi.module.ModuleUtilCore[JavaMethodDescriptor]

'file' @ [151:65] ==> value-parameter file: KtFile defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.findOutputRoot[ValueParameterDescriptorImpl]

'module' @ [152:17] ==> val module: Module? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.findOutputRoot[LocalVariableDescriptor]

'getInstance' @ [153:48] ==> public open fun getInstance(@NotNull p0: Project): (ProjectRootManager..ProjectRootManager?) defined in com.intellij.openapi.roots.ProjectRootManager[JavaMethodDescriptor]

'file' @ [153:60] ==> value-parameter file: KtFile defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.findOutputRoot[ValueParameterDescriptorImpl]

'project' @ [153:65] ==> public final val KtFile.project: Project[MyPropertyDescriptor]

'fileIndex' @ [153:74] ==> public final val ProjectRootManager.fileIndex: ProjectFileIndex[MyPropertyDescriptor]

'fileIndex' @ [154:27] ==> val fileIndex: ProjectFileIndex defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.findOutputRoot[LocalVariableDescriptor]

'isInTestSourceContent' @ [154:37] ==> public abstract fun isInTestSourceContent(@NotNull p0: VirtualFile): Boolean defined in com.intellij.openapi.roots.ProjectFileIndex[JavaMethodDescriptor]

'file' @ [154:59] ==> value-parameter file: KtFile defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.findOutputRoot[ValueParameterDescriptorImpl]

'virtualFile' @ [154:64] ==> public final val KtFile.virtualFile: (VirtualFile..VirtualFile?)[MyPropertyDescriptor]

'getInstance' @ [155:67] ==> @Nullable public open fun getInstance(p0: (Module..Module?)): CompilerModuleExtension? defined in com.intellij.openapi.roots.CompilerModuleExtension[JavaMethodDescriptor]

'module' @ [155:79] ==> val module: Module? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.findOutputRoot[LocalVariableDescriptor]

'if (inTests)
                compilerOutputExtension!!.compilerOutputPathForTests
            else
                compilerOutputExtension!!.compilerOutputPath' @ [156:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: VirtualFile?, elseBranch: VirtualFile?): VirtualFile?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> VirtualFile?

'inTests' @ [156:24] ==> val inTests: Boolean defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.findOutputRoot[LocalVariableDescriptor]

'compilerOutputExtension' @ [157:17] ==> val compilerOutputExtension: CompilerModuleExtension? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.findOutputRoot[LocalVariableDescriptor]

'compilerOutputPathForTests' @ [157:43] ==> public final var CompilerModuleExtension.compilerOutputPathForTests: VirtualFile?[MyPropertyDescriptor]

'compilerOutputExtension' @ [159:17] ==> val compilerOutputExtension: CompilerModuleExtension? defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.findOutputRoot[LocalVariableDescriptor]

'compilerOutputPath' @ [159:43] ==> public final var CompilerModuleExtension.compilerOutputPath: VirtualFile?[MyPropertyDescriptor]

'file' @ [163:26] ==> value-parameter file: KtFile defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.collectClassFilePrefixes[ValueParameterDescriptorImpl]

'children' @ [163:31] ==> public final val KtFile.children: (Array<(PsiElement..PsiElement?)>..Array<out (PsiElement..PsiElement?)>)[MyPropertyDescriptor]

'filter' @ [163:40] ==> public inline fun <T> Array<out (PsiElement..PsiElement?)>.filter(predicate: ((PsiElement..PsiElement?)) -> Boolean): List<(PsiElement..PsiElement?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)

'it' @ [163:49] ==> value-parameter it: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.collectClassFilePrefixes.<anonymous>[ValueParameterDescriptorImpl]

'map' @ [163:73] ==> public inline fun <T, R> Iterable<(PsiElement..PsiElement?)>.map(transform: ((PsiElement..PsiElement?)) -> String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)
    <R> -> String

'!!' @ [163:79] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: String?): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> String

'it' @ [163:80] ==> value-parameter it: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.collectClassFilePrefixes.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [163:103] ==> public final val KtClassOrObject.name: String?[MyPropertyDescriptor]

'JvmFileClassUtil' @ [164:37] ==> public object JvmFileClassUtil defined in org.jetbrains.kotlin.fileClasses[FakeCallableDescriptorForObject]

'getFileClassInfoNoResolve' @ [164:54] ==> @JvmStatic public final fun getFileClassInfoNoResolve(file: KtFile): JvmFileClassInfo defined in org.jetbrains.kotlin.fileClasses.JvmFileClassUtil[DeserializedSimpleFunctionDescriptor]

'file' @ [164:80] ==> value-parameter file: KtFile defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.collectClassFilePrefixes[ValueParameterDescriptorImpl]

'fileClassFqName' @ [164:86] ==> public abstract val fileClassFqName: FqName defined in org.jetbrains.kotlin.fileClasses.JvmFileClassInfo[DeserializedPropertyDescriptor]

'result' @ [165:20] ==> val result: List<String> defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.collectClassFilePrefixes[LocalVariableDescriptor]

'union' @ [165:27] ==> public infix fun <T> Iterable<String>.union(other: Iterable<String>): Set<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'arrayListOf' @ [165:33] ==> public fun <T> arrayListOf(vararg elements: String): ArrayList<String> /* = ArrayList<String> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'packagePartFqName' @ [165:45] ==> val packagePartFqName: FqName defined in org.jetbrains.kotlin.idea.coverage.KotlinCoverageExtension.Companion.collectClassFilePrefixes[LocalVariableDescriptor]

'shortName' @ [165:63] ==> @NotNull public open fun shortName(): Name defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'asString' @ [165:75] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

