'IntentionBasedInspection<KtCallExpression>' @ [68:43] ==> public constructor IntentionBasedInspection<TElement : PsiElement>(intention: KClass<out SelfTargetingRangeIntention<KtCallExpression>>, problemText: String? = ...) defined in org.jetbrains.kotlin.idea.inspections.IntentionBasedInspection[DeserializedClassConstructorDescriptor]
Inferred types:
    <TElement : PsiElement> -> KtCallExpression

'UsePropertyAccessSyntaxIntention' @ [68:86] ==> public constructor UsePropertyAccessSyntaxIntention() defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention[ClassConstructorDescriptorImpl]

'mutableListOf' @ [70:22] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableListOf(): MutableList<FqNameUnsafe> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FqNameUnsafe

'fqNameList' @ [73:17] ==> public final val fqNameList: MutableList<FqNameUnsafe> defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxInspection[PropertyDescriptorImpl]

'map' @ [73:28] ==> public inline fun <T, R> Iterable<FqNameUnsafe>.map(transform: (FqNameUnsafe) -> String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FqNameUnsafe
    <R> -> String

'it' @ [73:34] ==> value-parameter it: FqNameUnsafe defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxInspection.<get-fqNameStrings>.<anonymous>[ValueParameterDescriptorImpl]

'asString' @ [73:37] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqNameUnsafe[JavaMethodDescriptor]

'fqNameList' @ [75:13] ==> public final val fqNameList: MutableList<FqNameUnsafe> defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxInspection[PropertyDescriptorImpl]

'clear' @ [75:24] ==> public abstract fun clear(): Unit defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'value' @ [76:13] ==> value-parameter value: List<String> defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxInspection.<set-fqNameStrings>[ValueParameterDescriptorImpl]

'mapTo' @ [76:19] ==> public inline fun <T, R, C : MutableCollection<in FqNameUnsafe>> Iterable<String>.mapTo(destination: MutableList<FqNameUnsafe>, transform: (String) -> FqNameUnsafe): MutableList<FqNameUnsafe> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String
    <R> -> FqNameUnsafe
    <C : MutableCollection<in R>> -> MutableList<FqNameUnsafe>

'fqNameList' @ [76:25] ==> public final val fqNameList: MutableList<FqNameUnsafe> defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxInspection[PropertyDescriptorImpl]

'fqNameStrings' @ [80:9] ==> private final var fqNameStrings: List<String> defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxInspection[PropertyDescriptorImpl]

'NotPropertiesServiceImpl' @ [80:25] ==> public companion object defined in org.jetbrains.kotlin.idea.intentions.NotPropertiesServiceImpl[FakeCallableDescriptorForObject]

'default' @ [80:50] ==> public final val default: List<String> defined in org.jetbrains.kotlin.idea.intentions.NotPropertiesServiceImpl.Companion[PropertyDescriptorImpl]

'NotPropertyListPanel' @ [84:20] ==> public constructor NotPropertyListPanel(data: List<FqNameUnsafe>) defined in org.jetbrains.kotlin.idea.configuration.ui.NotPropertyListPanel[ClassConstructorDescriptorImpl]

'fqNameList' @ [84:41] ==> public final val fqNameList: MutableList<FqNameUnsafe> defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxInspection[PropertyDescriptorImpl]

'create' @ [85:33] ==> @NotNull public open fun <Comp : (JComponent..JComponent?)> create(@NotNull p0: NotPropertyListPanel, @NotNull p1: String): LabeledComponent<(NotPropertyListPanel..NotPropertyListPanel?)> defined in com.intellij.openapi.ui.LabeledComponent[JavaMethodDescriptor]
Inferred types:
    <Comp : (JComponent..JComponent?)> -> NotPropertyListPanel

'list' @ [85:40] ==> val list: NotPropertyListPanel defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxInspection.createOptionsPanel[LocalVariableDescriptor]

'getInstance' @ [92:55] ==> public open fun getInstance(@NotNull p0: Project): (InspectionProjectProfileManager..InspectionProjectProfileManager?) defined in com.intellij.profile.codeInspection.InspectionProjectProfileManager[JavaMethodDescriptor]

'project' @ [92:67] ==> private final val project: Project defined in org.jetbrains.kotlin.idea.intentions.NotPropertiesServiceImpl[PropertyDescriptorImpl]

'inspectionProfile' @ [92:76] ==> public final val InspectionProjectProfileManager.inspectionProfile: InspectionProfile[MyPropertyDescriptor]

'profile' @ [93:20] ==> val profile: InspectionProfile defined in org.jetbrains.kotlin.idea.intentions.NotPropertiesServiceImpl.getNotProperties[LocalVariableDescriptor]

'getUnwrappedTool' @ [93:28] ==> public abstract fun <T : (InspectionProfileEntry..InspectionProfileEntry?)> getUnwrappedTool(@NotNull p0: Key<(UsePropertyAccessSyntaxInspection..UsePropertyAccessSyntaxInspection?)>, @NotNull p1: PsiElement): (UsePropertyAccessSyntaxInspection..UsePropertyAccessSyntaxInspection?) defined in com.intellij.codeInspection.InspectionProfile[JavaMethodDescriptor]
Inferred types:
    <T : (InspectionProfileEntry..InspectionProfileEntry?)> -> UsePropertyAccessSyntaxInspection

'USE_PROPERTY_ACCESS_INSPECTION' @ [93:45] ==> public final val USE_PROPERTY_ACCESS_INSPECTION: Key<UsePropertyAccessSyntaxInspection> defined in org.jetbrains.kotlin.idea.intentions.NotPropertiesServiceImpl.Companion[PropertyDescriptorImpl]

'element' @ [93:77] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.intentions.NotPropertiesServiceImpl.getNotProperties[ValueParameterDescriptorImpl]

'tool' @ [94:17] ==> val tool: (UsePropertyAccessSyntaxInspection..UsePropertyAccessSyntaxInspection?) defined in org.jetbrains.kotlin.idea.intentions.NotPropertiesServiceImpl.getNotProperties[LocalVariableDescriptor]

'fqNameList' @ [94:23] ==> public final val fqNameList: MutableList<FqNameUnsafe> defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxInspection[PropertyDescriptorImpl]

'default' @ [94:37] ==> public final val default: List<String> defined in org.jetbrains.kotlin.idea.intentions.NotPropertiesServiceImpl.Companion[PropertyDescriptorImpl]

'map' @ [94:45] ==> public inline fun <T, R> Iterable<String>.map(transform: (String) -> FqNameUnsafe): List<FqNameUnsafe> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String
    <R> -> FqNameUnsafe

'toSet' @ [94:66] ==> public fun <T> Iterable<FqNameUnsafe>.toSet(): Set<FqNameUnsafe> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FqNameUnsafe

'listOf' @ [99:23] ==> public fun <T> listOf(vararg elements: String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'create' @ [111:90] ==> @NotNull public open fun <T : (Any..Any?)> create(@NotNull @NonNls p0: String): Key<(UsePropertyAccessSyntaxInspection..UsePropertyAccessSyntaxInspection?)> defined in com.intellij.openapi.util.Key[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> UsePropertyAccessSyntaxInspection

'SelfTargetingOffsetIndependentIntention<KtCallExpression>' @ [115:42] ==> public constructor SelfTargetingOffsetIndependentIntention<TElement : KtElement>(elementType: Class<KtCallExpression>, text: String, familyName: String = ...) defined in org.jetbrains.kotlin.idea.intentions.SelfTargetingOffsetIndependentIntention[DeserializedClassConstructorDescriptor]
Inferred types:
    <TElement : KtElement> -> KtCallExpression

'KtCallExpression' @ [115:100] ==> public constructor KtCallExpression(@NotNull p0: ASTNode) defined in org.jetbrains.kotlin.psi.KtCallExpression[JavaClassConstructorDescriptor]

'java' @ [115:124] ==> public val <T> KClass<KtCallExpression>.java: Class<KtCallExpression> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtCallExpression

'detectPropertyNameToUse' @ [117:16] ==> public final fun detectPropertyNameToUse(callExpression: KtCallExpression): Name? defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention[SimpleFunctionDescriptorImpl]

'element' @ [117:40] ==> value-parameter element: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.isApplicableTo[ValueParameterDescriptorImpl]

'applyTo' @ [121:9] ==> public final fun applyTo(element: KtCallExpression, propertyName: Name): KtExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention[SimpleFunctionDescriptorImpl]

'element' @ [121:17] ==> value-parameter element: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.applyTo[ValueParameterDescriptorImpl]

'detectPropertyNameToUse' @ [121:26] ==> public final fun detectPropertyNameToUse(callExpression: KtCallExpression): Name? defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention[SimpleFunctionDescriptorImpl]

'element' @ [121:50] ==> value-parameter element: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.applyTo[ValueParameterDescriptorImpl]

'element' @ [125:25] ==> value-parameter element: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.applyTo[ValueParameterDescriptorImpl]

'valueArguments' @ [125:33] ==> public final val KtCallExpression.valueArguments: (MutableList<(KtValueArgument..KtValueArgument?)>..List<(KtValueArgument..KtValueArgument?)>)[MyPropertyDescriptor]

'when (arguments.size) {
            0 -> replaceWithPropertyGet(element, propertyName)
            1 -> replaceWithPropertySet(element, propertyName)
            else -> error("More than one argument in call to accessor")
        }' @ [126:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KtExpression, entry1: KtExpression, entry2: KtExpression): KtExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KtExpression

'arguments' @ [126:22] ==> val arguments: (MutableList<(KtValueArgument..KtValueArgument?)>..List<(KtValueArgument..KtValueArgument?)>) defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.applyTo[LocalVariableDescriptor]

'size' @ [126:32] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'replaceWithPropertyGet' @ [127:18] ==> private final fun replaceWithPropertyGet(callExpression: KtCallExpression, propertyName: Name): KtExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention[SimpleFunctionDescriptorImpl]

'element' @ [127:41] ==> value-parameter element: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.applyTo[ValueParameterDescriptorImpl]

'propertyName' @ [127:50] ==> value-parameter propertyName: Name defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.applyTo[ValueParameterDescriptorImpl]

'replaceWithPropertySet' @ [128:18] ==> private final fun replaceWithPropertySet(callExpression: KtCallExpression, propertyName: Name): KtExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention[SimpleFunctionDescriptorImpl]

'element' @ [128:41] ==> value-parameter element: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.applyTo[ValueParameterDescriptorImpl]

'propertyName' @ [128:50] ==> value-parameter propertyName: Name defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.applyTo[ValueParameterDescriptorImpl]

'error' @ [129:21] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'callExpression' @ [134:13] ==> value-parameter callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[ValueParameterDescriptorImpl]

'getQualifiedExpressionForSelector' @ [134:28] ==> public fun KtElement.getQualifiedExpressionForSelector(): KtQualifiedExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'receiverExpression' @ [134:65] ==> public open val receiverExpression: KtExpression defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[DeserializedPropertyDescriptor]

'callExpression' @ [136:22] ==> value-parameter callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[ValueParameterDescriptorImpl]

'calleeExpression' @ [136:37] ==> public final val KtCallExpression.calleeExpression: KtExpression?[MyPropertyDescriptor]

'callExpression' @ [138:32] ==> value-parameter callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[ValueParameterDescriptorImpl]

'getResolutionFacade' @ [138:47] ==> public fun KtElement.getResolutionFacade(): ResolutionFacade defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'resolutionFacade' @ [139:30] ==> val resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'analyze' @ [139:47] ==> public abstract fun analyze(element: KtElement, bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.resolve.ResolutionFacade[DeserializedSimpleFunctionDescriptor]

'callExpression' @ [139:55] ==> value-parameter callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[ValueParameterDescriptorImpl]

'PARTIAL_FOR_COMPLETION' @ [139:87] ==> enum entry PARTIAL_FOR_COMPLETION defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'callExpression' @ [140:28] ==> value-parameter callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[ValueParameterDescriptorImpl]

'getResolvedCall' @ [140:43] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [140:59] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'!' @ [141:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'resolvedCall' @ [141:14] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'isReallySuccess' @ [141:27] ==> public fun ResolvedCall<*>.isReallySuccess(): Boolean defined in org.jetbrains.kotlin.resolve.calls.model[DeserializedSimpleFunctionDescriptor]

'resolvedCall' @ [143:24] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'resultingDescriptor' @ [143:37] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.resultingDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'?:' @ [145:29] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: Set<FqNameUnsafe>?, right: Set<FqNameUnsafe>): Set<FqNameUnsafe>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> Set<FqNameUnsafe>

'inspection' @ [145:30] ==> public final var inspection: IntentionBasedInspection<KtCallExpression>? defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention[DeserializedPropertyDescriptor]

'fqNameList' @ [145:81] ==> public final val fqNameList: MutableList<FqNameUnsafe> defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxInspection[PropertyDescriptorImpl]

'toSet' @ [145:93] ==> public fun <T> Iterable<FqNameUnsafe>.toSet(): Set<FqNameUnsafe> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FqNameUnsafe

'NotPropertiesService' @ [146:29] ==> public companion object defined in org.jetbrains.kotlin.idea.core.NotPropertiesService[FakeCallableDescriptorForObject]

'getNotProperties' @ [146:50] ==> public final fun getNotProperties(element: PsiElement): Set<FqNameUnsafe> defined in org.jetbrains.kotlin.idea.core.NotPropertiesService.Companion[DeserializedSimpleFunctionDescriptor]

'callExpression' @ [146:67] ==> value-parameter callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[ValueParameterDescriptorImpl]

'function' @ [147:13] ==> val function: FunctionDescriptor defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'shouldNotConvertToProperty' @ [147:22] ==> public fun FunctionDescriptor.shouldNotConvertToProperty(notProperties: Set<FqNameUnsafe>): Boolean defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'notProperties' @ [147:49] ==> val notProperties: Set<FqNameUnsafe> defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'callExpression' @ [149:31] ==> value-parameter callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[ValueParameterDescriptorImpl]

'getResolutionScope' @ [149:46] ==> public fun PsiElement.getResolutionScope(bindingContext: BindingContext, resolutionFacade: ResolutionFacade): LexicalScope defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [149:65] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'resolutionFacade' @ [149:81] ==> val resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'findSyntheticProperty' @ [150:24] ==> private final fun findSyntheticProperty(function: FunctionDescriptor, syntheticScopes: SyntheticScopes): SyntheticJavaPropertyDescriptor? defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention[SimpleFunctionDescriptorImpl]

'function' @ [150:46] ==> val function: FunctionDescriptor defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'resolutionFacade' @ [150:56] ==> val resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'getFrontendService' @ [150:73] ==> public abstract fun <T : Any> getFrontendService(serviceClass: Class<SyntheticScopes>): SyntheticScopes defined in org.jetbrains.kotlin.idea.resolve.ResolutionFacade[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> SyntheticScopes

'java' @ [150:115] ==> public val <T> KClass<SyntheticScopes>.java: Class<SyntheticScopes> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> SyntheticScopes

'bindingContext' @ [152:28] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'getDataFlowInfoBefore' @ [152:43] ==> public fun BindingContext.getDataFlowInfoBefore(position: PsiElement): DataFlowInfo defined in org.jetbrains.kotlin.resolve.bindingContextUtil[DeserializedSimpleFunctionDescriptor]

'callee' @ [152:65] ==> val callee: KtNameReferenceExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'callExpression' @ [153:35] ==> value-parameter callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[ValueParameterDescriptorImpl]

'getQualifiedExpressionForSelectorOrThis' @ [153:50] ==> public fun KtExpression.getQualifiedExpressionForSelectorOrThis(): KtExpression defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [154:28] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'EXPECTED_EXPRESSION_TYPE' @ [154:58] ==> public final val EXPECTED_EXPRESSION_TYPE: (WritableSlice<(KtExpression..KtExpression?), (KotlinType..KotlinType?)>..WritableSlice<(KtExpression..KtExpression?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'qualifiedExpression' @ [154:84] ==> val qualifiedExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'NO_EXPECTED_TYPE' @ [154:118] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'!' @ [156:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'checkWillResolveToProperty' @ [156:14] ==> private final fun checkWillResolveToProperty(resolvedCall: ResolvedCall<out CallableDescriptor>, property: SyntheticJavaPropertyDescriptor, bindingContext: BindingContext, resolutionScope: LexicalScope, dataFlowInfo: DataFlowInfo, expectedType: KotlinType, facade: ResolutionFacade): Boolean defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention[SimpleFunctionDescriptorImpl]

'resolvedCall' @ [156:41] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'property' @ [156:55] ==> val property: SyntheticJavaPropertyDescriptor defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'bindingContext' @ [156:65] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'resolutionScope' @ [156:81] ==> val resolutionScope: LexicalScope defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'dataFlowInfo' @ [156:98] ==> val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'expectedType' @ [156:112] ==> val expectedType: KotlinType defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'resolutionFacade' @ [156:126] ==> val resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'callExpression' @ [158:26] ==> value-parameter callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[ValueParameterDescriptorImpl]

'valueArguments' @ [158:41] ==> public final val KtCallExpression.valueArguments: (MutableList<(KtValueArgument..KtValueArgument?)>..List<(KtValueArgument..KtValueArgument?)>)[MyPropertyDescriptor]

'size' @ [158:56] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'isSetUsage' @ [160:13] ==> val isSetUsage: Boolean defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'qualifiedExpression' @ [160:27] ==> val qualifiedExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'isUsedAsExpression' @ [160:47] ==> public fun KtExpression.isUsedAsExpression(context: BindingContext): Boolean defined in org.jetbrains.kotlin.resolve.bindingContextUtil[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [160:66] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'qualifiedExpression' @ [162:26] ==> val qualifiedExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'parent' @ [162:46] ==> public final val KtExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [163:17] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'qualifiedExpression' @ [163:53] ==> val qualifiedExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'parent' @ [163:76] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'bodyExpression' @ [163:83] ==> public final val KtDeclarationWithBody.bodyExpression: KtExpression?[MyPropertyDescriptor]

'function' @ [164:17] ==> val function: FunctionDescriptor defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'returnType' @ [164:26] ==> public final val FunctionDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'isUnit' @ [164:38] ==> public fun KotlinType.isUnit(): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'isSetUsage' @ [167:13] ==> val isSetUsage: Boolean defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'property' @ [167:27] ==> val property: SyntheticJavaPropertyDescriptor defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'type' @ [167:36] ==> public final val SyntheticJavaPropertyDescriptor.type: KotlinType[MyPropertyDescriptor]

'function' @ [167:44] ==> val function: FunctionDescriptor defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'valueParameters' @ [167:53] ==> public final val FunctionDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'single' @ [167:69] ==> public fun <T> List<(ValueParameterDescriptor..ValueParameterDescriptor?)>.single(): (ValueParameterDescriptor..ValueParameterDescriptor?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)

'type' @ [167:78] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'qualifiedExpression' @ [168:43] ==> val qualifiedExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'copied' @ [168:63] ==> public fun <T : PsiElement> KtExpression.copied(): KtExpression defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : PsiElement> -> KtExpression

'?:' @ [169:39] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtExpression?, right: KtExpression): KtExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtExpression

'qualifiedExpressionCopy' @ [169:40] ==> val qualifiedExpressionCopy: KtExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'selectorExpression' @ [169:92] ==> public open val selectorExpression: KtExpression? defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[DeserializedPropertyDescriptor]

'qualifiedExpressionCopy' @ [169:114] ==> val qualifiedExpressionCopy: KtExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'applyTo' @ [170:33] ==> public final fun applyTo(element: KtCallExpression, propertyName: Name): KtExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention[SimpleFunctionDescriptorImpl]

'callExpressionCopy' @ [170:41] ==> val callExpressionCopy: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'property' @ [170:61] ==> val property: SyntheticJavaPropertyDescriptor defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'name' @ [170:70] ==> public final val SyntheticJavaPropertyDescriptor.name: Name[MyPropertyDescriptor]

'DelegatingBindingTrace' @ [171:32] ==> public constructor DelegatingBindingTrace(parentContext: BindingContext, name: String, withParentDiagnostics: Boolean = ..., filter: BindingTraceFilter = ..., allowSliceRewrite: Boolean = ...) defined in org.jetbrains.kotlin.resolve.DelegatingBindingTrace[DeserializedClassConstructorDescriptor]

'bindingContext' @ [171:55] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'newExpression' @ [172:37] ==> val newExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'analyzeInContext' @ [172:51] ==> @JvmOverloads public fun KtExpression.analyzeInContext(scope: LexicalScope, contextExpression: KtExpression = ..., trace: BindingTrace = ..., dataFlowInfo: DataFlowInfo = ..., expectedType: KotlinType = ..., isStatement: Boolean = ..., contextDependency: ContextDependency = ..., expressionTypingServices: ExpressionTypingServices = ...): BindingContext defined in org.jetbrains.kotlin.idea.analysis[DeserializedSimpleFunctionDescriptor]

'resolutionScope' @ [173:21] ==> val resolutionScope: LexicalScope defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'callExpression' @ [174:41] ==> value-parameter callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[ValueParameterDescriptorImpl]

'bindingTrace' @ [175:29] ==> val bindingTrace: DelegatingBindingTrace defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'dataFlowInfo' @ [176:36] ==> val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'expectedType' @ [177:36] ==> val expectedType: KotlinType defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'newBindingContext' @ [180:17] ==> val newBindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'diagnostics' @ [180:35] ==> public final val BindingContext.diagnostics: Diagnostics[MyPropertyDescriptor]

'any' @ [180:47] ==> public inline fun <T> Iterable<Diagnostic>.any(predicate: (Diagnostic) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Diagnostic

'it' @ [180:53] ==> value-parameter it: Diagnostic defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse.<anonymous>[ValueParameterDescriptorImpl]

'severity' @ [180:56] ==> public final val Diagnostic.severity: Severity[MyPropertyDescriptor]

'ERROR' @ [180:77] ==> enum entry ERROR defined in org.jetbrains.kotlin.diagnostics.Severity[FakeCallableDescriptorForObject]

'property' @ [183:16] ==> val property: SyntheticJavaPropertyDescriptor defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.detectPropertyNameToUse[LocalVariableDescriptor]

'name' @ [183:25] ==> public final val SyntheticJavaPropertyDescriptor.name: Name[MyPropertyDescriptor]

'resolvedCall' @ [195:23] ==> value-parameter resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.checkWillResolveToProperty[ValueParameterDescriptorImpl]

'call' @ [195:36] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'callElement' @ [195:41] ==> public final val Call.callElement: KtElement[MyPropertyDescriptor]

'project' @ [195:53] ==> public final val KtElement.project: Project[MyPropertyDescriptor]

'DelegatingCall' @ [196:32] ==> public constructor DelegatingCall(@NotNull p0: Call) defined in org.jetbrains.kotlin.resolve.calls.util.DelegatingCall[JavaClassConstructorDescriptor]

'resolvedCall' @ [196:47] ==> value-parameter resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.checkWillResolveToProperty[ValueParameterDescriptorImpl]

'call' @ [196:60] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'KtPsiFactory' @ [197:37] ==> @JvmOverloads public constructor KtPsiFactory(project: Project, markGenerated: Boolean = ...) defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedClassConstructorDescriptor]

'project' @ [197:50] ==> val project: Project defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.checkWillResolveToProperty[LocalVariableDescriptor]

'createExpressionByPattern' @ [197:59] ==> public fun KtPsiFactory.createExpressionByPattern(pattern: String, vararg args: Any, reformat: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'property' @ [197:91] ==> value-parameter property: SyntheticJavaPropertyDescriptor defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.checkWillResolveToProperty[ValueParameterDescriptorImpl]

'name' @ [197:100] ==> public final val SyntheticJavaPropertyDescriptor.name: Name[MyPropertyDescriptor]

'newCallee' @ [199:50] ==> private final val newCallee: KtExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.checkWillResolveToProperty.<no name provided>[PropertyDescriptorImpl]

'emptyList' @ [201:69] ==> public fun <T> emptyList(): List<ValueArgument> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ValueArgument

'emptyList' @ [202:80] ==> public fun <T> emptyList(): List<LambdaArgument> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> LambdaArgument

'DelegatingBindingTrace' @ [205:28] ==> public constructor DelegatingBindingTrace(parentContext: BindingContext, name: String, withParentDiagnostics: Boolean = ..., filter: BindingTraceFilter = ..., allowSliceRewrite: Boolean = ...) defined in org.jetbrains.kotlin.resolve.DelegatingBindingTrace[DeserializedClassConstructorDescriptor]

'bindingContext' @ [205:51] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.checkWillResolveToProperty[ValueParameterDescriptorImpl]

'create' @ [206:50] ==> @NotNull public open fun create(@NotNull p0: BindingTrace, @NotNull p1: LexicalScope, @NotNull p2: Call, @NotNull p3: KotlinType, @NotNull p4: DataFlowInfo, @NotNull p5: ContextDependency, @NotNull p6: CheckArgumentTypesMode, p7: Boolean): BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaMethodDescriptor]

'bindingTrace' @ [206:57] ==> val bindingTrace: DelegatingBindingTrace defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.checkWillResolveToProperty[LocalVariableDescriptor]

'resolutionScope' @ [206:71] ==> value-parameter resolutionScope: LexicalScope defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.checkWillResolveToProperty[ValueParameterDescriptorImpl]

'newCall' @ [206:88] ==> val newCall: <no name provided> defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.checkWillResolveToProperty[LocalVariableDescriptor]

'expectedType' @ [206:97] ==> value-parameter expectedType: KotlinType defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.checkWillResolveToProperty[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [206:111] ==> value-parameter dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.checkWillResolveToProperty[ValueParameterDescriptorImpl]

'INDEPENDENT' @ [207:75] ==> enum entry INDEPENDENT defined in org.jetbrains.kotlin.resolve.calls.context.ContextDependency[FakeCallableDescriptorForObject]

'CHECK_VALUE_ARGUMENTS' @ [207:111] ==> enum entry CHECK_VALUE_ARGUMENTS defined in org.jetbrains.kotlin.resolve.calls.context.CheckArgumentTypesMode[FakeCallableDescriptorForObject]

'facade' @ [209:28] ==> value-parameter facade: ResolutionFacade defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.checkWillResolveToProperty[ValueParameterDescriptorImpl]

'frontendService' @ [209:35] ==> public inline fun <reified T : Any> ResolutionFacade.frontendService(): CallResolver defined in org.jetbrains.kotlin.idea.resolve[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : Any> -> CallResolver

'callResolver' @ [210:22] ==> val callResolver: CallResolver defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.checkWillResolveToProperty[LocalVariableDescriptor]

'resolveSimpleProperty' @ [210:35] ==> @NotNull public open fun resolveSimpleProperty(@NotNull p0: BasicCallResolutionContext): OverloadResolutionResults<(VariableDescriptor..VariableDescriptor?)> defined in org.jetbrains.kotlin.resolve.calls.CallResolver[JavaMethodDescriptor]

'context' @ [210:57] ==> val context: BasicCallResolutionContext defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.checkWillResolveToProperty[LocalVariableDescriptor]

'result' @ [211:16] ==> val result: OverloadResolutionResults<(VariableDescriptor..VariableDescriptor?)> defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.checkWillResolveToProperty[LocalVariableDescriptor]

'isSuccess' @ [211:23] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<(VariableDescriptor..VariableDescriptor?)>.isSuccess: Boolean[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.VariableDescriptor..org.jetbrains.kotlin.descriptors.VariableDescriptor?)

'result' @ [211:36] ==> val result: OverloadResolutionResults<(VariableDescriptor..VariableDescriptor?)> defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.checkWillResolveToProperty[LocalVariableDescriptor]

'resultingDescriptor' @ [211:43] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<(VariableDescriptor..VariableDescriptor?)>.resultingDescriptor: (VariableDescriptor..VariableDescriptor?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.VariableDescriptor..org.jetbrains.kotlin.descriptors.VariableDescriptor?)

'original' @ [211:63] ==> public final val VariableDescriptor.original: CallableDescriptor[MyPropertyDescriptor]

'property' @ [211:75] ==> value-parameter property: SyntheticJavaPropertyDescriptor defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.checkWillResolveToProperty[ValueParameterDescriptorImpl]

'SyntheticJavaPropertyDescriptor' @ [215:9] ==> public companion object defined in org.jetbrains.kotlin.synthetic.SyntheticJavaPropertyDescriptor[FakeCallableDescriptorForObject]

'findByGetterOrSetter' @ [215:41] ==> public final fun findByGetterOrSetter(getterOrSetter: FunctionDescriptor, syntheticScopes: SyntheticScopes): SyntheticJavaPropertyDescriptor? defined in org.jetbrains.kotlin.synthetic.SyntheticJavaPropertyDescriptor.Companion[DeserializedSimpleFunctionDescriptor]

'function' @ [215:62] ==> value-parameter function: FunctionDescriptor defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.findSyntheticProperty[ValueParameterDescriptorImpl]

'syntheticScopes' @ [215:72] ==> value-parameter syntheticScopes: SyntheticScopes defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.findSyntheticProperty[ValueParameterDescriptorImpl]

'let' @ [215:90] ==> @InlineOnly public inline fun <T, R> SyntheticJavaPropertyDescriptor.let(block: (SyntheticJavaPropertyDescriptor) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SyntheticJavaPropertyDescriptor
    <R> -> Nothing

'it' @ [215:103] ==> value-parameter it: SyntheticJavaPropertyDescriptor defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.findSyntheticProperty.<anonymous>[ValueParameterDescriptorImpl]

'function' @ [217:28] ==> value-parameter function: FunctionDescriptor defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.findSyntheticProperty[ValueParameterDescriptorImpl]

'overriddenDescriptors' @ [217:37] ==> public final var FunctionDescriptor.overriddenDescriptors: (MutableCollection<out (FunctionDescriptor..FunctionDescriptor?)>..Collection<(FunctionDescriptor..FunctionDescriptor?)>)[MyPropertyDescriptor]

'findSyntheticProperty' @ [218:13] ==> private final fun findSyntheticProperty(function: FunctionDescriptor, syntheticScopes: SyntheticScopes): SyntheticJavaPropertyDescriptor? defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention[SimpleFunctionDescriptorImpl]

'overridden' @ [218:35] ==> val overridden: (FunctionDescriptor..FunctionDescriptor?) defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.findSyntheticProperty[LocalVariableDescriptor]

'syntheticScopes' @ [218:47] ==> value-parameter syntheticScopes: SyntheticScopes defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.findSyntheticProperty[ValueParameterDescriptorImpl]

'let' @ [218:65] ==> @InlineOnly public inline fun <T, R> SyntheticJavaPropertyDescriptor.let(block: (SyntheticJavaPropertyDescriptor) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SyntheticJavaPropertyDescriptor
    <R> -> Nothing

'it' @ [218:78] ==> value-parameter it: SyntheticJavaPropertyDescriptor defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.findSyntheticProperty.<anonymous>[ValueParameterDescriptorImpl]

'KtPsiFactory' @ [225:29] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'callExpression' @ [225:42] ==> value-parameter callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertyGet[ValueParameterDescriptorImpl]

'createExpression' @ [225:58] ==> public final fun createExpression(text: String): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'propertyName' @ [225:75] ==> value-parameter propertyName: Name defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertyGet[ValueParameterDescriptorImpl]

'render' @ [225:88] ==> public fun Name.render(): String defined in org.jetbrains.kotlin.renderer[DeserializedSimpleFunctionDescriptor]

'callExpression' @ [226:16] ==> value-parameter callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertyGet[ValueParameterDescriptorImpl]

'replaced' @ [226:31] ==> public inline fun <reified T : PsiElement> PsiElement.replaced(newElement: KtExpression): KtExpression defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtExpression

'newExpression' @ [226:40] ==> val newExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertyGet[LocalVariableDescriptor]

'callExpression' @ [230:20] ==> value-parameter callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[ValueParameterDescriptorImpl]

'getQualifiedExpressionForSelector' @ [230:35] ==> public fun KtElement.getQualifiedExpressionForSelector(): KtQualifiedExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'callExpression' @ [230:74] ==> value-parameter callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[ValueParameterDescriptorImpl]

'call' @ [231:26] ==> val call: KtExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

'parent' @ [231:31] ==> public final val KtExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'callExpression' @ [232:29] ==> value-parameter callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[ValueParameterDescriptorImpl]

'callParent' @ [233:13] ==> val callParent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

'call' @ [233:52] ==> val call: KtExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

'callParent' @ [233:60] ==> val callParent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

'bodyExpression' @ [233:71] ==> public final val KtDeclarationWithBody.bodyExpression: KtExpression?[MyPropertyDescriptor]

'ConvertToBlockBodyIntention' @ [234:13] ==> public companion object defined in org.jetbrains.kotlin.idea.intentions.ConvertToBlockBodyIntention[FakeCallableDescriptorForObject]

'convert' @ [234:41] ==> public final fun convert(declaration: KtDeclarationWithBody): KtDeclarationWithBody defined in org.jetbrains.kotlin.idea.intentions.ConvertToBlockBodyIntention.Companion[SimpleFunctionDescriptorImpl]

'callParent' @ [234:49] ==> val callParent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

'callParent' @ [235:35] ==> val callParent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

'bodyExpression' @ [235:46] ==> public final val KtDeclarationWithBody.bodyExpression: KtExpression?[MyPropertyDescriptor]

'statements' @ [235:85] ==> public final val KtBlockExpression.statements: List<(KtExpression..KtExpression?)>[MyPropertyDescriptor]

'first' @ [235:97] ==> public fun <T> List<(KtExpression..KtExpression?)>.first(): (KtExpression..KtExpression?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)

'callToConvert' @ [236:13] ==> var callToConvert: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

'?:' @ [236:29] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtCallExpression?, right: KtCallExpression?): KtCallExpression?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtCallExpression?

'firstStatement' @ [236:30] ==> val firstStatement: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

'selectorExpression' @ [236:73] ==> public open val selectorExpression: KtExpression? defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[DeserializedPropertyDescriptor]

'firstStatement' @ [237:20] ==> val firstStatement: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

'IllegalStateException' @ [238:26] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'callParent' @ [238:101] ==> val callParent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

'text' @ [238:112] ==> public final val KtDeclarationWithBody.text: (String..String?)[MyPropertyDescriptor]

'callToConvert' @ [241:35] ==> var callToConvert: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

'getQualifiedExpressionForSelector' @ [241:49] ==> public fun KtElement.getQualifiedExpressionForSelector(): KtQualifiedExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'callToConvert' @ [242:24] ==> var callToConvert: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

'valueArguments' @ [242:38] ==> public final val KtCallExpression.valueArguments: (MutableList<(KtValueArgument..KtValueArgument?)>..List<(KtValueArgument..KtValueArgument?)>)[MyPropertyDescriptor]

'single' @ [242:53] ==> public fun <T> List<(KtValueArgument..KtValueArgument?)>.single(): (KtValueArgument..KtValueArgument?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtValueArgument..org.jetbrains.kotlin.psi.KtValueArgument?)

'if (qualifiedExpression != null) {
            val pattern = when (qualifiedExpression) {
                is KtDotQualifiedExpression -> "$0.$1=$2"
                is KtSafeQualifiedExpression -> "$0?.$1=$2"
                else -> error(qualifiedExpression) //TODO: make it sealed?
            }
            val newExpression = KtPsiFactory(callToConvert).createExpressionByPattern(
                    pattern,
                    qualifiedExpression.receiverExpression,
                    propertyName,
                    argument.getArgumentExpression()!!
            )
            return qualifiedExpression.replaced(newExpression)
        }
        else {
            val newExpression = KtPsiFactory(callToConvert).createExpressionByPattern("$0=$1", propertyName, argument.getArgumentExpression()!!)
            return callToConvert.replaced(newExpression)
        }' @ [243:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nothing, elseBranch: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nothing

'qualifiedExpression' @ [243:13] ==> val qualifiedExpression: KtQualifiedExpression? defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

'when (qualifiedExpression) {
                is KtDotQualifiedExpression -> "$0.$1=$2"
                is KtSafeQualifiedExpression -> "$0?.$1=$2"
                else -> error(qualifiedExpression) //TODO: make it sealed?
            }' @ [244:27] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: String, entry1: String, entry2: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> String

'qualifiedExpression' @ [244:33] ==> val qualifiedExpression: KtQualifiedExpression? defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

'error' @ [247:25] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'qualifiedExpression' @ [247:31] ==> val qualifiedExpression: KtQualifiedExpression? defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

'KtPsiFactory' @ [249:33] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'callToConvert' @ [249:46] ==> var callToConvert: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

'createExpressionByPattern' @ [249:61] ==> public fun KtPsiFactory.createExpressionByPattern(pattern: String, vararg args: Any, reformat: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'pattern' @ [250:21] ==> val pattern: String defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

'qualifiedExpression' @ [251:21] ==> val qualifiedExpression: KtQualifiedExpression? defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

'receiverExpression' @ [251:41] ==> public open val receiverExpression: KtExpression defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[DeserializedPropertyDescriptor]

'propertyName' @ [252:21] ==> value-parameter propertyName: Name defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[ValueParameterDescriptorImpl]

'argument' @ [253:21] ==> val argument: (KtValueArgument..KtValueArgument?) defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

'getArgumentExpression' @ [253:30] ==> @IfNotParsed @Nullable public open fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.KtValueArgument[JavaMethodDescriptor]

'qualifiedExpression' @ [255:20] ==> val qualifiedExpression: KtQualifiedExpression? defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

'replaced' @ [255:40] ==> public inline fun <reified T : PsiElement> PsiElement.replaced(newElement: KtExpression): KtExpression defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtExpression

'newExpression' @ [255:49] ==> val newExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

'KtPsiFactory' @ [258:33] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'callToConvert' @ [258:46] ==> var callToConvert: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

'createExpressionByPattern' @ [258:61] ==> public fun KtPsiFactory.createExpressionByPattern(pattern: String, vararg args: Any, reformat: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'propertyName' @ [258:96] ==> value-parameter propertyName: Name defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[ValueParameterDescriptorImpl]

'argument' @ [258:110] ==> val argument: (KtValueArgument..KtValueArgument?) defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

'getArgumentExpression' @ [258:119] ==> @IfNotParsed @Nullable public open fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.KtValueArgument[JavaMethodDescriptor]

'callToConvert' @ [259:20] ==> var callToConvert: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

'replaced' @ [259:34] ==> public inline fun <reified T : PsiElement> PsiElement.replaced(newElement: KtExpression): KtExpression defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtExpression

'newExpression' @ [259:43] ==> val newExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.UsePropertyAccessSyntaxIntention.replaceWithPropertySet[LocalVariableDescriptor]

