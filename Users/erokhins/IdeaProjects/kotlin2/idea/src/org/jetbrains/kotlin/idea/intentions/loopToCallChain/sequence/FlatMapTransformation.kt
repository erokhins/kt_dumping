'generateLambda' @ [39:22] ==> public fun generateLambda(inputVariable: KtCallableDeclaration, expression: KtExpression): KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file utils.kt[SimpleFunctionDescriptorImpl]

'inputVariable' @ [39:37] ==> public final val inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation[PropertyDescriptorImpl]

'transform' @ [39:52] ==> public final val transform: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation[PropertyDescriptorImpl]

'chainedCallGenerator' @ [40:16] ==> value-parameter chainedCallGenerator: ChainedCallGenerator defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.generateCode[ValueParameterDescriptorImpl]

'generate' @ [40:37] ==> public abstract fun generate(pattern: String, vararg args: Any, receiver: KtExpression = ..., safeCall: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.ChainedCallGenerator[SimpleFunctionDescriptorImpl]

'lambda' @ [40:64] ==> val lambda: KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.generateCode[LocalVariableDescriptor]

'state' @ [57:30] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[ValueParameterDescriptorImpl]

'statements' @ [57:36] ==> public final val statements: List<KtExpression> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'singleOrNull' @ [57:47] ==> public fun <T> List<KtExpression>.singleOrNull(): KtExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'nestedLoop' @ [59:29] ==> val nestedLoop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'loopRange' @ [59:40] ==> public final val KtForExpression.loopRange: KtExpression?[MyPropertyDescriptor]

'transform' @ [61:38] ==> val transform: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'analyze' @ [61:48] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'PARTIAL' @ [61:72] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'getType' @ [61:81] ==> @Nullable public abstract fun getType(@NotNull p0: KtExpression): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]

'transform' @ [61:89] ==> val transform: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'transform' @ [62:28] ==> val transform: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'builtIns' @ [62:38] ==> public val KtElement.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.idea.project[DeserializedPropertyDescriptor]

'FuzzyType' @ [63:32] ==> public constructor FuzzyType(type: KotlinType, freeParameters: Collection<TypeParameterDescriptor>) defined in org.jetbrains.kotlin.idea.util.FuzzyType[DeserializedClassConstructorDescriptor]

'builtIns' @ [63:42] ==> val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'iterableType' @ [63:51] ==> public final val KotlinBuiltIns.iterableType: KotlinType[MyPropertyDescriptor]

'builtIns' @ [63:65] ==> val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'iterable' @ [63:74] ==> public final val KotlinBuiltIns.iterable: ClassDescriptor[MyPropertyDescriptor]

'declaredTypeParameters' @ [63:83] ==> public final val ClassDescriptor.declaredTypeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'iterableType' @ [64:17] ==> val iterableType: FuzzyType defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'checkIsSuperTypeOf' @ [64:30] ==> public final fun checkIsSuperTypeOf(otherType: KotlinType): TypeSubstitutor? defined in org.jetbrains.kotlin.idea.util.FuzzyType[DeserializedSimpleFunctionDescriptor]

'nestedSequenceType' @ [64:49] ==> val nestedSequenceType: KotlinType defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'nestedLoop' @ [66:34] ==> val nestedLoop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'body' @ [66:45] ==> public final val KtForExpression.body: KtExpression?[MyPropertyDescriptor]

'nestedLoop' @ [67:36] ==> val nestedLoop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'loopParameter' @ [67:47] ==> public final val KtForExpression.loopParameter: KtParameter?[MyPropertyDescriptor]

'state' @ [69:17] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[ValueParameterDescriptorImpl]

'indexVariable' @ [69:23] ==> public final val indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'state' @ [69:48] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[ValueParameterDescriptorImpl]

'indexVariable' @ [69:54] ==> public final val indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'hasUsages' @ [69:68] ==> public fun KtCallableDeclaration.hasUsages(inElement: KtElement): Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain in file commonUtils.kt[SimpleFunctionDescriptorImpl]

'transform' @ [69:78] ==> val transform: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'MapTransformation' @ [71:48] ==> public constructor MapTransformation(loop: KtForExpression, inputVariable: KtCallableDeclaration, indexVariable: KtCallableDeclaration?, mapping: KtExpression, mapNotNull: Boolean) defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.MapTransformation[ClassConstructorDescriptorImpl]

'state' @ [71:66] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[ValueParameterDescriptorImpl]

'outerLoop' @ [71:72] ==> public final val outerLoop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'state' @ [71:83] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[ValueParameterDescriptorImpl]

'inputVariable' @ [71:89] ==> public final val inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'state' @ [71:104] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[ValueParameterDescriptorImpl]

'indexVariable' @ [71:110] ==> public final val indexVariable: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'transform' @ [71:125] ==> val transform: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'KtPsiFactory' @ [72:42] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'nestedLoop' @ [72:55] ==> val nestedLoop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'createExpressionByPattern' @ [72:67] ==> public fun KtPsiFactory.createExpressionByPattern(pattern: String, vararg args: Any, reformat: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'state' @ [72:99] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[ValueParameterDescriptorImpl]

'inputVariable' @ [72:105] ==> public final val inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'nameAsSafeName' @ [72:119] ==> public final val KtCallableDeclaration.nameAsSafeName: Name[MyPropertyDescriptor]

'if (state.lazySequence) inputVarExpression.asSequence() else inputVarExpression' @ [73:38] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtExpression, elseBranch: KtExpression): KtExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtExpression

'state' @ [73:42] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[ValueParameterDescriptorImpl]

'lazySequence' @ [73:48] ==> public final val lazySequence: Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'inputVarExpression' @ [73:62] ==> val inputVarExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'asSequence' @ [73:81] ==> private final fun KtExpression.asSequence(): KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher[SimpleFunctionDescriptorImpl]

'inputVarExpression' @ [73:99] ==> val inputVarExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'FlatMapTransformation' @ [74:45] ==> public constructor FlatMapTransformation(loop: KtForExpression, inputVariable: KtCallableDeclaration, transform: KtExpression) defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation[ClassConstructorDescriptorImpl]

'state' @ [74:67] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[ValueParameterDescriptorImpl]

'outerLoop' @ [74:73] ==> public final val outerLoop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'state' @ [74:84] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[ValueParameterDescriptorImpl]

'inputVariable' @ [74:90] ==> public final val inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'transformToUse' @ [74:105] ==> val transformToUse: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'state' @ [75:32] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[ValueParameterDescriptorImpl]

'copy' @ [75:38] ==> public final fun copy(outerLoop: KtForExpression = ..., innerLoop: KtForExpression = ..., statements: List<KtExpression> = ..., inputVariable: KtCallableDeclaration = ..., indexVariable: KtCallableDeclaration? = ..., lazySequence: Boolean = ..., pseudocodeProvider: () -> Pseudocode = ..., initializationStatementsToDelete: Collection<KtExpression> = ..., previousTransformations: MutableList<SequenceTransformation> = ..., incrementExpressions: Collection<KtUnaryExpression> = ...): MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[SimpleFunctionDescriptorImpl]

'nestedLoop' @ [76:37] ==> val nestedLoop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'listOf' @ [77:38] ==> public fun <T> listOf(element: KtExpression): List<KtExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'nestedLoopBody' @ [77:45] ==> val nestedLoopBody: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'newInputVariable' @ [78:41] ==> val newInputVariable: KtParameter defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'Sequence' @ [80:44] ==> public constructor Sequence(transformations: List<SequenceTransformation>, newState: MatchingState) defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.TransformationMatch.Sequence[ClassConstructorDescriptorImpl]

'listOf' @ [80:53] ==> public fun <T> listOf(vararg elements: SequenceTransformation): List<SequenceTransformation> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SequenceTransformation

'mapIndexedTransformation' @ [80:60] ==> val mapIndexedTransformation: MapTransformation defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'flatMapTransformation' @ [80:86] ==> val flatMapTransformation: FlatMapTransformation defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'newState' @ [80:110] ==> val newState: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'if (state.lazySequence) transform.asSequence() else transform' @ [83:34] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtExpression, elseBranch: KtExpression): KtExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtExpression

'state' @ [83:38] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[ValueParameterDescriptorImpl]

'lazySequence' @ [83:44] ==> public final val lazySequence: Boolean defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'transform' @ [83:58] ==> val transform: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'asSequence' @ [83:68] ==> private final fun KtExpression.asSequence(): KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher[SimpleFunctionDescriptorImpl]

'transform' @ [83:86] ==> val transform: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'FlatMapTransformation' @ [84:34] ==> public constructor FlatMapTransformation(loop: KtForExpression, inputVariable: KtCallableDeclaration, transform: KtExpression) defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation[ClassConstructorDescriptorImpl]

'state' @ [84:56] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[ValueParameterDescriptorImpl]

'outerLoop' @ [84:62] ==> public final val outerLoop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'state' @ [84:73] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[ValueParameterDescriptorImpl]

'inputVariable' @ [84:79] ==> public final val inputVariable: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[PropertyDescriptorImpl]

'transformToUse' @ [84:94] ==> val transformToUse: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'state' @ [85:28] ==> value-parameter state: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[ValueParameterDescriptorImpl]

'copy' @ [85:34] ==> public final fun copy(outerLoop: KtForExpression = ..., innerLoop: KtForExpression = ..., statements: List<KtExpression> = ..., inputVariable: KtCallableDeclaration = ..., indexVariable: KtCallableDeclaration? = ..., lazySequence: Boolean = ..., pseudocodeProvider: () -> Pseudocode = ..., initializationStatementsToDelete: Collection<KtExpression> = ..., previousTransformations: MutableList<SequenceTransformation> = ..., incrementExpressions: Collection<KtUnaryExpression> = ...): MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.MatchingState[SimpleFunctionDescriptorImpl]

'nestedLoop' @ [86:33] ==> val nestedLoop: KtForExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'listOf' @ [87:34] ==> public fun <T> listOf(element: KtExpression): List<KtExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'nestedLoopBody' @ [87:41] ==> val nestedLoopBody: KtExpression defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'newInputVariable' @ [88:37] ==> val newInputVariable: KtParameter defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'Sequence' @ [90:40] ==> public constructor Sequence(transformation: SequenceTransformation, newState: MatchingState) defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.TransformationMatch.Sequence[ClassConstructorDescriptorImpl]

'transformation' @ [90:49] ==> val transformation: FlatMapTransformation defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'newState' @ [90:65] ==> val newState: MatchingState defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.match[LocalVariableDescriptor]

'KtPsiFactory' @ [94:20] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'this' @ [94:33] ==> <this> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.asSequence[ReceiverParameterDescriptorImpl]

'createExpressionByPattern' @ [94:39] ==> public fun KtPsiFactory.createExpressionByPattern(pattern: String, vararg args: Any, reformat: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'this' @ [94:84] ==> <this> defined in org.jetbrains.kotlin.idea.intentions.loopToCallChain.sequence.FlatMapTransformation.Matcher.asSequence[ReceiverParameterDescriptorImpl]

