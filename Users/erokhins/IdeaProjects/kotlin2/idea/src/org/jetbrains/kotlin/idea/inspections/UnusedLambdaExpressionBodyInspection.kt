'AbstractKotlinInspection' @ [36:46] ==> public constructor AbstractKotlinInspection() defined in org.jetbrains.kotlin.idea.inspections.AbstractKotlinInspection[DeserializedClassConstructorDescriptor]

'KtVisitorVoid' @ [38:25] ==> public constructor KtVisitorVoid() defined in org.jetbrains.kotlin.psi.KtVisitorVoid[JavaClassConstructorDescriptor]

'expression' @ [40:31] ==> value-parameter expression: KtCallExpression defined in org.jetbrains.kotlin.idea.inspections.UnusedLambdaExpressionBodyInspection.buildVisitor.<no name provided>.visitCallExpression[ValueParameterDescriptorImpl]

'analyze' @ [40:42] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'PARTIAL' @ [40:66] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'expression' @ [41:21] ==> value-parameter expression: KtCallExpression defined in org.jetbrains.kotlin.idea.inspections.UnusedLambdaExpressionBodyInspection.buildVisitor.<no name provided>.visitCallExpression[ValueParameterDescriptorImpl]

'used' @ [41:32] ==> private final fun KtExpression.used(context: BindingContext): Boolean defined in org.jetbrains.kotlin.idea.inspections.UnusedLambdaExpressionBodyInspection[SimpleFunctionDescriptorImpl]

'context' @ [41:37] ==> val context: BindingContext defined in org.jetbrains.kotlin.idea.inspections.UnusedLambdaExpressionBodyInspection.buildVisitor.<no name provided>.visitCallExpression[LocalVariableDescriptor]

'expression' @ [45:34] ==> value-parameter expression: KtCallExpression defined in org.jetbrains.kotlin.idea.inspections.UnusedLambdaExpressionBodyInspection.buildVisitor.<no name provided>.visitCallExpression[ValueParameterDescriptorImpl]

'getResolvedCall' @ [45:45] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'context' @ [45:61] ==> val context: BindingContext defined in org.jetbrains.kotlin.idea.inspections.UnusedLambdaExpressionBodyInspection.buildVisitor.<no name provided>.visitCallExpression[LocalVariableDescriptor]

'resultingDescriptor' @ [45:71] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.resultingDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out CallableDescriptor)

'!' @ [46:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'descriptor' @ [46:22] ==> val descriptor: CallableDescriptor defined in org.jetbrains.kotlin.idea.inspections.UnusedLambdaExpressionBodyInspection.buildVisitor.<no name provided>.visitCallExpression[LocalVariableDescriptor]

'returnsFunction' @ [46:33] ==> private final fun CallableDescriptor.returnsFunction(): Boolean defined in org.jetbrains.kotlin.idea.inspections.UnusedLambdaExpressionBodyInspection[SimpleFunctionDescriptorImpl]

'descriptor' @ [50:32] ==> val descriptor: CallableDescriptor defined in org.jetbrains.kotlin.idea.inspections.UnusedLambdaExpressionBodyInspection.buildVisitor.<no name provided>.visitCallExpression[LocalVariableDescriptor]

'source' @ [50:43] ==> public final val CallableDescriptor.source: SourceElement[MyPropertyDescriptor]

'getPsi' @ [50:50] ==> public fun SourceElement.getPsi(): PsiElement? defined in org.jetbrains.kotlin.resolve.source[DeserializedSimpleFunctionDescriptor]

'function' @ [51:21] ==> val function: KtFunction defined in org.jetbrains.kotlin.idea.inspections.UnusedLambdaExpressionBodyInspection.buildVisitor.<no name provided>.visitCallExpression[LocalVariableDescriptor]

'hasBlockBody' @ [51:30] ==> public abstract fun hasBlockBody(): Boolean defined in org.jetbrains.kotlin.psi.KtFunction[JavaMethodDescriptor]

'function' @ [51:48] ==> val function: KtFunction defined in org.jetbrains.kotlin.idea.inspections.UnusedLambdaExpressionBodyInspection.buildVisitor.<no name provided>.visitCallExpression[LocalVariableDescriptor]

'bodyExpression' @ [51:57] ==> public final val KtFunction.bodyExpression: KtExpression?[MyPropertyDescriptor]

'holder' @ [55:17] ==> value-parameter holder: ProblemsHolder defined in org.jetbrains.kotlin.idea.inspections.UnusedLambdaExpressionBodyInspection.buildVisitor[ValueParameterDescriptorImpl]

'registerProblem' @ [55:24] ==> public open fun registerProblem(@NotNull p0: PsiElement, @NotNull @Nls p1: String, @Nullable vararg p2: (LocalQuickFix..LocalQuickFix?)): Unit defined in com.intellij.codeInspection.ProblemsHolder[JavaMethodDescriptor]

'expression' @ [55:40] ==> value-parameter expression: KtCallExpression defined in org.jetbrains.kotlin.idea.inspections.UnusedLambdaExpressionBodyInspection.buildVisitor.<no name provided>.visitCallExpression[ValueParameterDescriptorImpl]

'RemoveEqTokenFromFunctionDeclarationFix' @ [57:40] ==> public constructor RemoveEqTokenFromFunctionDeclarationFix(function: KtFunction) defined in org.jetbrains.kotlin.idea.inspections.UnusedLambdaExpressionBodyInspection.RemoveEqTokenFromFunctionDeclarationFix[ClassConstructorDescriptorImpl]

'function' @ [57:80] ==> val function: KtFunction defined in org.jetbrains.kotlin.idea.inspections.UnusedLambdaExpressionBodyInspection.buildVisitor.<no name provided>.visitCallExpression[LocalVariableDescriptor]

'context' @ [62:71] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.idea.inspections.UnusedLambdaExpressionBodyInspection.used[ValueParameterDescriptorImpl]

'USED_AS_EXPRESSION' @ [62:94] ==> public final val USED_AS_EXPRESSION: (WritableSlice<(KtElement..KtElement?), (Boolean..Boolean?)>..WritableSlice<(KtElement..KtElement?), (Boolean..Boolean?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'this' @ [62:114] ==> <this> defined in org.jetbrains.kotlin.idea.inspections.UnusedLambdaExpressionBodyInspection.used[ReceiverParameterDescriptorImpl]

'returnType' @ [64:56] ==> public final val CallableDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'isFunctionType' @ [64:68] ==> public val KotlinType.isFunctionType: Boolean defined in org.jetbrains.kotlin.builtins[DeserializedPropertyDescriptor]

'name' @ [69:48] ==> public final val UnusedLambdaExpressionBodyInspection.RemoveEqTokenFromFunctionDeclarationFix.name: String[MyPropertyDescriptor]

'!' @ [72:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'getInstance' @ [72:42] ==> public open fun getInstance(): (FileModificationService..FileModificationService?) defined in com.intellij.codeInsight.FileModificationService[JavaMethodDescriptor]

'preparePsiElementForWrite' @ [72:56] ==> public open fun preparePsiElementForWrite(@Nullable p0: PsiElement?): Boolean defined in com.intellij.codeInsight.FileModificationService[JavaMethodDescriptor]

'function' @ [72:82] ==> public final val function: KtFunction defined in org.jetbrains.kotlin.idea.inspections.UnusedLambdaExpressionBodyInspection.RemoveEqTokenFromFunctionDeclarationFix[PropertyDescriptorImpl]

'function' @ [76:13] ==> public final val function: KtFunction defined in org.jetbrains.kotlin.idea.inspections.UnusedLambdaExpressionBodyInspection.RemoveEqTokenFromFunctionDeclarationFix[PropertyDescriptorImpl]

'equalsToken' @ [76:22] ==> public final val KtFunction.equalsToken: PsiElement?[MyPropertyDescriptor]

'apply' @ [76:35] ==> @InlineOnly public inline fun <T> PsiElement.apply(block: (PsiElement).() -> Unit): PsiElement defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'prevSibling' @ [78:21] ==> public final val PsiElement.prevSibling: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'isSpace' @ [78:33] ==> private final fun PsiElement.isSpace(): Boolean defined in org.jetbrains.kotlin.idea.inspections.UnusedLambdaExpressionBodyInspection.RemoveEqTokenFromFunctionDeclarationFix[SimpleFunctionDescriptorImpl]

'nextSibling' @ [78:46] ==> public final val PsiElement.nextSibling: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'isSpace' @ [78:58] ==> private final fun PsiElement.isSpace(): Boolean defined in org.jetbrains.kotlin.idea.inspections.UnusedLambdaExpressionBodyInspection.RemoveEqTokenFromFunctionDeclarationFix[SimpleFunctionDescriptorImpl]

'prevSibling' @ [79:21] ==> public final val PsiElement.prevSibling: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'delete' @ [79:33] ==> public abstract fun delete(): Unit defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'delete' @ [81:17] ==> public abstract fun delete(): Unit defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'text' @ [85:44] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

