'IntentionBasedInspection<KtPrefixExpression>' @ [27:51] ==> public constructor IntentionBasedInspection<TElement : PsiElement>(intention: KClass<out SelfTargetingRangeIntention<KtPrefixExpression>>, problemText: String? = ...) defined in org.jetbrains.kotlin.idea.inspections.IntentionBasedInspection[DeserializedClassConstructorDescriptor]
Inferred types:
    <TElement : PsiElement> -> KtPrefixExpression

'SimplifyNegatedBinaryExpressionIntention' @ [27:96] ==> public constructor SimplifyNegatedBinaryExpressionIntention() defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention[ClassConstructorDescriptorImpl]

'SelfTargetingRangeIntention<KtPrefixExpression>' @ [29:50] ==> public constructor SelfTargetingRangeIntention<TElement : PsiElement>(elementType: Class<KtPrefixExpression>, text: String, familyName: String = ...) defined in org.jetbrains.kotlin.idea.intentions.SelfTargetingRangeIntention[DeserializedClassConstructorDescriptor]
Inferred types:
    <TElement : PsiElement> -> KtPrefixExpression

'KtPrefixExpression' @ [29:98] ==> public constructor KtPrefixExpression(@NotNull p0: ASTNode) defined in org.jetbrains.kotlin.psi.KtPrefixExpression[JavaClassConstructorDescriptor]

'java' @ [29:124] ==> public val <T> KClass<KtPrefixExpression>.java: Class<KtPrefixExpression> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtPrefixExpression

'when (this) {
        KtTokens.IN_KEYWORD -> KtTokens.NOT_IN
        KtTokens.NOT_IN -> KtTokens.IN_KEYWORD

        KtTokens.IS_KEYWORD -> KtTokens.NOT_IS
        KtTokens.NOT_IS -> KtTokens.IS_KEYWORD

        KtTokens.EQEQ -> KtTokens.EXCLEQ
        KtTokens.EXCLEQ -> KtTokens.EQEQ

        KtTokens.LT -> KtTokens.GTEQ
        KtTokens.GTEQ -> KtTokens.LT

        KtTokens.GT -> KtTokens.LTEQ
        KtTokens.LTEQ -> KtTokens.GT

        else -> null
    }' @ [31:62] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KtSingleValueToken?, entry1: KtSingleValueToken?, entry2: KtSingleValueToken?, entry3: KtSingleValueToken?, entry4: KtSingleValueToken?, entry5: KtSingleValueToken?, entry6: KtSingleValueToken?, entry7: KtSingleValueToken?, entry8: KtSingleValueToken?, entry9: KtSingleValueToken?, entry10: KtSingleValueToken?): KtSingleValueToken?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KtSingleValueToken?

'this' @ [31:68] ==> <this> defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.negate[ReceiverParameterDescriptorImpl]

'IN_KEYWORD' @ [32:18] ==> public final val IN_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'NOT_IN' @ [32:41] ==> public final val NOT_IN: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'NOT_IN' @ [33:18] ==> public final val NOT_IN: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'IN_KEYWORD' @ [33:37] ==> public final val IN_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'IS_KEYWORD' @ [35:18] ==> public final val IS_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'NOT_IS' @ [35:41] ==> public final val NOT_IS: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'NOT_IS' @ [36:18] ==> public final val NOT_IS: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'IS_KEYWORD' @ [36:37] ==> public final val IS_KEYWORD: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'EQEQ' @ [38:18] ==> public final val EQEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'EXCLEQ' @ [38:35] ==> public final val EXCLEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'EXCLEQ' @ [39:18] ==> public final val EXCLEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'EQEQ' @ [39:37] ==> public final val EQEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'LT' @ [41:18] ==> public final val LT: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'GTEQ' @ [41:33] ==> public final val GTEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'GTEQ' @ [42:18] ==> public final val GTEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'LT' @ [42:35] ==> public final val LT: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'GT' @ [44:18] ==> public final val GT: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'LTEQ' @ [44:33] ==> public final val LTEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'LTEQ' @ [45:18] ==> public final val LTEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'GT' @ [45:35] ==> public final val GT: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'if (isApplicableTo(element)) element.operationReference.textRange else null' @ [51:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: TextRange?, elseBranch: TextRange?): TextRange?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> TextRange?

'isApplicableTo' @ [51:20] ==> public final fun isApplicableTo(element: KtPrefixExpression): Boolean defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention[SimpleFunctionDescriptorImpl]

'element' @ [51:35] ==> value-parameter element: KtPrefixExpression defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.applicabilityRange[ValueParameterDescriptorImpl]

'element' @ [51:45] ==> value-parameter element: KtPrefixExpression defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.applicabilityRange[ValueParameterDescriptorImpl]

'operationReference' @ [51:53] ==> public final val KtPrefixExpression.operationReference: KtSimpleNameExpression[MyPropertyDescriptor]

'textRange' @ [51:72] ==> public final val KtSimpleNameExpression.textRange: (TextRange..TextRange?)[MyPropertyDescriptor]

'element' @ [55:13] ==> value-parameter element: KtPrefixExpression defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.isApplicableTo[ValueParameterDescriptorImpl]

'operationToken' @ [55:21] ==> public final val KtPrefixExpression.operationToken: (IElementType..IElementType?)[MyPropertyDescriptor]

'EXCL' @ [55:48] ==> public final val EXCL: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'?:' @ [57:26] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtOperationExpression?, right: KtOperationExpression): KtOperationExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtOperationExpression

'deparenthesize' @ [57:36] ==> @Nullable public open fun deparenthesize(@Nullable p0: KtExpression?): KtExpression? defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'element' @ [57:51] ==> value-parameter element: KtPrefixExpression defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.isApplicableTo[ValueParameterDescriptorImpl]

'baseExpression' @ [57:59] ==> public final val KtPrefixExpression.baseExpression: KtExpression?[MyPropertyDescriptor]

'when (expression) {
            is KtIsExpression -> { if (expression.typeReference == null) return false }
            is KtBinaryExpression -> { if (expression.left == null || expression.right == null) return false }
            else -> return false
        }' @ [58:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'expression' @ [58:15] ==> val expression: KtOperationExpression defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.isApplicableTo[LocalVariableDescriptor]

'expression' @ [59:40] ==> val expression: KtOperationExpression defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.isApplicableTo[LocalVariableDescriptor]

'typeReference' @ [59:51] ==> public final val KtIsExpression.typeReference: KtTypeReference?[MyPropertyDescriptor]

'expression' @ [60:44] ==> val expression: KtOperationExpression defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.isApplicableTo[LocalVariableDescriptor]

'left' @ [60:55] ==> public final val KtBinaryExpression.left: KtExpression?[MyPropertyDescriptor]

'expression' @ [60:71] ==> val expression: KtOperationExpression defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.isApplicableTo[LocalVariableDescriptor]

'right' @ [60:82] ==> public final val KtBinaryExpression.right: KtExpression?[MyPropertyDescriptor]

'expression' @ [64:25] ==> val expression: KtOperationExpression defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.isApplicableTo[LocalVariableDescriptor]

'operationReference' @ [64:36] ==> public final val KtOperationExpression.operationReference: KtSimpleNameExpression[MyPropertyDescriptor]

'getReferencedNameElementType' @ [64:55] ==> public abstract fun getReferencedNameElementType(): IElementType defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[DeserializedSimpleFunctionDescriptor]

'operation' @ [65:32] ==> val operation: KtSingleValueToken defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.isApplicableTo[LocalVariableDescriptor]

'negate' @ [65:42] ==> private final fun IElementType.negate(): KtSingleValueToken? defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention[SimpleFunctionDescriptorImpl]

'text' @ [67:9] ==> public final var SimplifyNegatedBinaryExpressionIntention.text: String[MyPropertyDescriptor]

'operation' @ [67:37] ==> val operation: KtSingleValueToken defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.isApplicableTo[LocalVariableDescriptor]

'value' @ [67:47] ==> public final val KtSingleValueToken.value: String[MyPropertyDescriptor]

'negatedOperation' @ [67:72] ==> val negatedOperation: KtSingleValueToken defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.isApplicableTo[LocalVariableDescriptor]

'value' @ [67:89] ==> public final val KtSingleValueToken.value: String[MyPropertyDescriptor]

'!!' @ [72:26] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: KtExpression?): KtExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> KtExpression

'deparenthesize' @ [72:36] ==> @Nullable public open fun deparenthesize(@Nullable p0: KtExpression?): KtExpression? defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'element' @ [72:51] ==> value-parameter element: KtPrefixExpression defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.applyTo[ValueParameterDescriptorImpl]

'baseExpression' @ [72:59] ==> public final val KtPrefixExpression.baseExpression: KtExpression?[MyPropertyDescriptor]

'!!' @ [73:25] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: KtSingleValueToken?): KtSingleValueToken[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> KtSingleValueToken

'expression' @ [73:26] ==> val expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.applyTo[LocalVariableDescriptor]

'operationReference' @ [73:63] ==> public final val KtOperationExpression.operationReference: KtSimpleNameExpression[MyPropertyDescriptor]

'getReferencedNameElementType' @ [73:82] ==> public abstract fun getReferencedNameElementType(): IElementType defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[DeserializedSimpleFunctionDescriptor]

'negate' @ [73:113] ==> private final fun IElementType.negate(): KtSingleValueToken? defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention[SimpleFunctionDescriptorImpl]

'value' @ [73:124] ==> public final val KtSingleValueToken.value: String[MyPropertyDescriptor]

'KtPsiFactory' @ [75:26] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'expression' @ [75:39] ==> val expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.applyTo[LocalVariableDescriptor]

'when (expression) {
            is KtIsExpression -> psiFactory.createExpressionByPattern("$0 $1 $2", expression.leftHandSide, operation, expression.typeReference!!)
            is KtBinaryExpression -> psiFactory.createExpressionByPattern("$0 $1 $2", expression.left!!, operation, expression.right!!)
            else -> throw IllegalArgumentException()
        }' @ [76:29] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KtExpression, entry1: KtExpression, entry2: KtExpression): KtExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KtExpression

'expression' @ [76:35] ==> val expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.applyTo[LocalVariableDescriptor]

'psiFactory' @ [77:34] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.applyTo[LocalVariableDescriptor]

'createExpressionByPattern' @ [77:45] ==> public fun KtPsiFactory.createExpressionByPattern(pattern: String, vararg args: Any, reformat: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'expression' @ [77:83] ==> val expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.applyTo[LocalVariableDescriptor]

'leftHandSide' @ [77:94] ==> public final val KtIsExpression.leftHandSide: KtExpression[MyPropertyDescriptor]

'operation' @ [77:108] ==> val operation: String defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.applyTo[LocalVariableDescriptor]

'expression' @ [77:119] ==> val expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.applyTo[LocalVariableDescriptor]

'typeReference' @ [77:130] ==> public final val KtIsExpression.typeReference: KtTypeReference?[MyPropertyDescriptor]

'psiFactory' @ [78:38] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.applyTo[LocalVariableDescriptor]

'createExpressionByPattern' @ [78:49] ==> public fun KtPsiFactory.createExpressionByPattern(pattern: String, vararg args: Any, reformat: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'expression' @ [78:87] ==> val expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.applyTo[LocalVariableDescriptor]

'left' @ [78:98] ==> public final val KtBinaryExpression.left: KtExpression?[MyPropertyDescriptor]

'operation' @ [78:106] ==> val operation: String defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.applyTo[LocalVariableDescriptor]

'expression' @ [78:117] ==> val expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.applyTo[LocalVariableDescriptor]

'right' @ [78:128] ==> public final val KtBinaryExpression.right: KtExpression?[MyPropertyDescriptor]

'IllegalArgumentException' @ [79:27] ==> public final fun <init>(): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'element' @ [81:9] ==> value-parameter element: KtPrefixExpression defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.applyTo[ValueParameterDescriptorImpl]

'replace' @ [81:17] ==> public open fun replace(newElement: PsiElement): PsiElement defined in org.jetbrains.kotlin.psi.KtPrefixExpression[DeserializedSimpleFunctionDescriptor]

'newExpression' @ [81:25] ==> val newExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.SimplifyNegatedBinaryExpressionIntention.applyTo[LocalVariableDescriptor]

