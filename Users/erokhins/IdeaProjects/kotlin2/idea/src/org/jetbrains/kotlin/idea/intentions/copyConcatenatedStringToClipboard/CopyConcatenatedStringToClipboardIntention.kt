'SelfTargetingOffsetIndependentIntention<KtBinaryExpression>' @ [29:52] ==> public constructor SelfTargetingOffsetIndependentIntention<TElement : KtElement>(elementType: Class<KtBinaryExpression>, text: String, familyName: String = ...) defined in org.jetbrains.kotlin.idea.intentions.SelfTargetingOffsetIndependentIntention[DeserializedClassConstructorDescriptor]
Inferred types:
    <TElement : KtElement> -> KtBinaryExpression

'KtBinaryExpression' @ [30:9] ==> public constructor KtBinaryExpression(@NotNull p0: ASTNode) defined in org.jetbrains.kotlin.psi.KtBinaryExpression[JavaClassConstructorDescriptor]

'java' @ [30:35] ==> public val <T> KClass<KtBinaryExpression>.java: Class<KtBinaryExpression> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtBinaryExpression

'ConcatenatedStringGenerator' @ [32:20] ==> public constructor ConcatenatedStringGenerator() defined in org.jetbrains.kotlin.idea.intentions.copyConcatenatedStringToClipboard.ConcatenatedStringGenerator[ClassConstructorDescriptorImpl]

'create' @ [32:50] ==> public final fun create(element: KtBinaryExpression): String defined in org.jetbrains.kotlin.idea.intentions.copyConcatenatedStringToClipboard.ConcatenatedStringGenerator[SimpleFunctionDescriptorImpl]

'element' @ [32:57] ==> value-parameter element: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.copyConcatenatedStringToClipboard.CopyConcatenatedStringToClipboardIntention.applyTo[ValueParameterDescriptorImpl]

'getInstance' @ [33:26] ==> public open fun getInstance(): (CopyPasteManager..CopyPasteManager?) defined in com.intellij.openapi.ide.CopyPasteManager[JavaMethodDescriptor]

'setContents' @ [33:40] ==> public abstract fun setContents(@NotNull p0: Transferable): Unit defined in com.intellij.openapi.ide.CopyPasteManager[JavaMethodDescriptor]

'StringSelection' @ [33:52] ==> public constructor StringSelection(p0: (String..String?)) defined in java.awt.datatransfer.StringSelection[JavaClassConstructorDescriptor]

'text' @ [33:68] ==> val text: String defined in org.jetbrains.kotlin.idea.intentions.copyConcatenatedStringToClipboard.CopyConcatenatedStringToClipboardIntention.applyTo[LocalVariableDescriptor]

'element' @ [37:13] ==> value-parameter element: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.copyConcatenatedStringToClipboard.CopyConcatenatedStringToClipboardIntention.isApplicableTo[ValueParameterDescriptorImpl]

'operationToken' @ [37:21] ==> public final val KtBinaryExpression.operationToken: IElementType[MyPropertyDescriptor]

'PLUS' @ [37:48] ==> public final val PLUS: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'element' @ [38:28] ==> value-parameter element: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.copyConcatenatedStringToClipboard.CopyConcatenatedStringToClipboardIntention.isApplicableTo[ValueParameterDescriptorImpl]

'getResolvedCall' @ [38:36] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'element' @ [38:52] ==> value-parameter element: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.copyConcatenatedStringToClipboard.CopyConcatenatedStringToClipboardIntention.isApplicableTo[ValueParameterDescriptorImpl]

'analyze' @ [38:60] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'isString' @ [39:31] ==> public open fun isString(@Nullable p0: KotlinType?): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'resolvedCall' @ [39:40] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.copyConcatenatedStringToClipboard.CopyConcatenatedStringToClipboardIntention.isApplicableTo[LocalVariableDescriptor]

'candidateDescriptor' @ [39:53] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.candidateDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'returnType' @ [39:73] ==> public final val CallableDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

