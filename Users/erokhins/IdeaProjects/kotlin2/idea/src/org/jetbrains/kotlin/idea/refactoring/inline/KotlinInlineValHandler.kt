'InlineActionHandler' @ [50:65] ==> public constructor InlineActionHandler() defined in com.intellij.lang.refactoring.InlineActionHandler[JavaClassConstructorDescriptor]

'this' @ [52:20] ==> public constructor KotlinInlineValHandler(withPrompt: Boolean) defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler[ClassConstructorDescriptorImpl]

'l' @ [54:54] ==> value-parameter l: Language defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.isEnabledForLanguage[ValueParameterDescriptorImpl]

'INSTANCE' @ [54:74] ==> @NotNull public final val INSTANCE: KotlinLanguage defined in org.jetbrains.kotlin.idea.KotlinLanguage[JavaPropertyDescriptor]

'element' @ [57:16] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.canInlineElement[ValueParameterDescriptorImpl]

'element' @ [57:41] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.canInlineElement[ValueParameterDescriptorImpl]

'name' @ [57:49] ==> public final val KtProperty.name: String?[MyPropertyDescriptor]

'element' @ [61:27] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[ValueParameterDescriptorImpl]

'declaration' @ [62:20] ==> val declaration: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'name' @ [62:32] ==> public final val KtProperty.name: String?[MyPropertyDescriptor]

'declaration' @ [64:20] ==> val declaration: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'containingKtFile' @ [64:32] ==> public final val KtProperty.containingKtFile: KtFile[MyPropertyDescriptor]

'file' @ [65:13] ==> val file: KtFile defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'isCompiled' @ [65:18] ==> public final val KtFile.isCompiled: Boolean[MyPropertyDescriptor]

'showErrorHint' @ [66:20] ==> private final fun showErrorHint(project: Project, editor: Editor?, message: String): Unit defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler[SimpleFunctionDescriptorImpl]

'project' @ [66:34] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[ValueParameterDescriptorImpl]

'editor' @ [66:43] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[ValueParameterDescriptorImpl]

'name' @ [66:68] ==> val name: String defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'declaration' @ [69:22] ==> val declaration: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'getter' @ [69:34] ==> public final val KtProperty.getter: KtPropertyAccessor?[MyPropertyDescriptor]

'takeIf' @ [69:42] ==> @InlineOnly @SinceKotlin public inline fun <T> KtPropertyAccessor.takeIf(predicate: (KtPropertyAccessor) -> Boolean): KtPropertyAccessor? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtPropertyAccessor

'it' @ [69:51] ==> value-parameter it: KtPropertyAccessor defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement.<anonymous>[ValueParameterDescriptorImpl]

'hasBody' @ [69:54] ==> public open fun hasBody(): Boolean defined in org.jetbrains.kotlin.psi.KtPropertyAccessor[JavaMethodDescriptor]

'declaration' @ [70:22] ==> val declaration: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'setter' @ [70:34] ==> public final val KtProperty.setter: KtPropertyAccessor?[MyPropertyDescriptor]

'takeIf' @ [70:42] ==> @InlineOnly @SinceKotlin public inline fun <T> KtPropertyAccessor.takeIf(predicate: (KtPropertyAccessor) -> Boolean): KtPropertyAccessor? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtPropertyAccessor

'it' @ [70:51] ==> value-parameter it: KtPropertyAccessor defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement.<anonymous>[ValueParameterDescriptorImpl]

'hasBody' @ [70:54] ==> public open fun hasBody(): Boolean defined in org.jetbrains.kotlin.psi.KtPropertyAccessor[JavaMethodDescriptor]

'getter' @ [72:14] ==> val getter: KtPropertyAccessor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'setter' @ [72:32] ==> val setter: KtPropertyAccessor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'declaration' @ [72:51] ==> val declaration: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'initializer' @ [72:63] ==> public final var KtProperty.initializer: KtExpression?[MyPropertyDescriptor]

'showErrorHint' @ [73:20] ==> private final fun showErrorHint(project: Project, editor: Editor?, message: String): Unit defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler[SimpleFunctionDescriptorImpl]

'project' @ [73:34] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[ValueParameterDescriptorImpl]

'editor' @ [73:43] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[ValueParameterDescriptorImpl]

'component1' @ [76:14] ==> public final operator fun component1(): Collection<KtExpression> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.Usages[SimpleFunctionDescriptorImpl]

'component2' @ [76:36] ==> public final operator fun component2(): MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.Usages[SimpleFunctionDescriptorImpl]

'findUsages' @ [76:49] ==> private final fun findUsages(declaration: KtProperty): KotlinInlineValHandler.Usages defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler[SimpleFunctionDescriptorImpl]

'declaration' @ [76:60] ==> val declaration: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'referenceExpressions' @ [78:13] ==> val referenceExpressions: Collection<KtExpression> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'isEmpty' @ [78:34] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.Collection[DeserializedSimpleFunctionDescriptor]

'conflicts' @ [78:47] ==> val conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'isEmpty' @ [78:57] ==> public final val <K : (Any..Any?), V : (Any..Any?)> MultiMap<PsiElement, String>.isEmpty: Boolean[MyPropertyDescriptor]
Inferred types:
    <K : (Any..Any?)> -> PsiElement
    <V : (Any..Any?)> -> String

'if (declaration.isLocal) "Variable" else "Property"' @ [79:24] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'declaration' @ [79:28] ==> val declaration: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'isLocal' @ [79:40] ==> public final val KtProperty.isLocal: Boolean[MyPropertyDescriptor]

'showErrorHint' @ [80:20] ==> private final fun showErrorHint(project: Project, editor: Editor?, message: String): Unit defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler[SimpleFunctionDescriptorImpl]

'project' @ [80:34] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[ValueParameterDescriptorImpl]

'editor' @ [80:43] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[ValueParameterDescriptorImpl]

'kind' @ [80:53] ==> val kind: String defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'name' @ [80:60] ==> val name: String defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'referenceExpressions' @ [83:40] ==> val referenceExpressions: Collection<KtExpression> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'filter' @ [83:61] ==> public inline fun <T> Iterable<KtExpression>.filter(predicate: (KtExpression) -> Boolean): List<KtExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'it' @ [83:70] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement.<anonymous>[ValueParameterDescriptorImpl]

'containingFile' @ [83:73] ==> public final val KtExpression.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'file' @ [83:91] ==> val file: KtFile defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'referencesInOriginalFile' @ [84:32] ==> val referencesInOriginalFile: List<KtExpression> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'isNotEmpty' @ [84:57] ==> @InlineOnly public inline fun <T> Collection<KtExpression>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'highlightElements' @ [85:9] ==> public fun highlightElements(project: Project, editor: Editor?, elements: List<PsiElement>): Unit defined in org.jetbrains.kotlin.idea.refactoring.inline in file inlineUtils.kt[SimpleFunctionDescriptorImpl]

'project' @ [85:27] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[ValueParameterDescriptorImpl]

'editor' @ [85:36] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[ValueParameterDescriptorImpl]

'referencesInOriginalFile' @ [85:44] ==> val referencesInOriginalFile: List<KtExpression> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'declaration' @ [90:26] ==> val declaration: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'resolveToDescriptor' @ [90:38] ==> public fun KtDeclaration.resolveToDescriptor(bodyResolveMode: BodyResolveMode = ...): DeclarationDescriptor defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'declaration' @ [91:30] ==> val declaration: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'typeReference' @ [91:42] ==> public final var KtProperty.typeReference: KtTypeReference?[MyPropertyDescriptor]

'if (getter == null && setter == null) {
            val initialization = extractInitialization(declaration, referenceExpressions, project, editor) ?: return
            readReplacement = buildCodeToInline(declaration, descriptor.type, isTypeExplicit, initialization.value, false, editor) ?: return
            writeReplacement = null
            assignmentToDelete = initialization.assignment
        }
        else {
            readReplacement = getter?.let {
                buildCodeToInline(getter, descriptor.type, isTypeExplicit, getter.bodyExpression!!, getter.hasBlockBody(), editor) ?: return
            }
            writeReplacement = setter?.let {
                buildCodeToInline(setter, setter.builtIns.unitType, true, setter.bodyExpression!!, setter.hasBlockBody(), editor) ?: return
            }
            assignmentToDelete = null
        }' @ [92:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'getter' @ [92:13] ==> val getter: KtPropertyAccessor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'setter' @ [92:31] ==> val setter: KtPropertyAccessor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'extractInitialization' @ [93:34] ==> private final fun extractInitialization(declaration: KtProperty, referenceExpressions: Collection<KtExpression>, project: Project, editor: Editor?): KotlinInlineValHandler.Initialization? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler[SimpleFunctionDescriptorImpl]

'declaration' @ [93:56] ==> val declaration: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'referenceExpressions' @ [93:69] ==> val referenceExpressions: Collection<KtExpression> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'project' @ [93:91] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[ValueParameterDescriptorImpl]

'editor' @ [93:100] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[ValueParameterDescriptorImpl]

'readReplacement' @ [94:13] ==> val readReplacement: CodeToInline? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'buildCodeToInline' @ [94:31] ==> internal fun buildCodeToInline(declaration: KtDeclaration, returnType: KotlinType?, isReturnTypeExplicit: Boolean, bodyOrInitializer: KtExpression, isBlockBody: Boolean, editor: Editor?): CodeToInline? defined in org.jetbrains.kotlin.idea.refactoring.inline in file inlineUtils.kt[SimpleFunctionDescriptorImpl]

'declaration' @ [94:49] ==> val declaration: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'descriptor' @ [94:62] ==> val descriptor: ValueDescriptor defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'type' @ [94:73] ==> public final val ValueDescriptor.type: KotlinType[MyPropertyDescriptor]

'isTypeExplicit' @ [94:79] ==> val isTypeExplicit: Boolean defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'initialization' @ [94:95] ==> val initialization: KotlinInlineValHandler.Initialization defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'value' @ [94:110] ==> public final val value: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.Initialization[PropertyDescriptorImpl]

'editor' @ [94:124] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[ValueParameterDescriptorImpl]

'writeReplacement' @ [95:13] ==> val writeReplacement: CodeToInline? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'assignmentToDelete' @ [96:13] ==> val assignmentToDelete: KtBinaryExpression? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'initialization' @ [96:34] ==> val initialization: KotlinInlineValHandler.Initialization defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'assignment' @ [96:49] ==> public final val assignment: KtBinaryExpression? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.Initialization[PropertyDescriptorImpl]

'readReplacement' @ [99:13] ==> val readReplacement: CodeToInline? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'getter' @ [99:31] ==> val getter: KtPropertyAccessor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'let' @ [99:39] ==> @InlineOnly public inline fun <T, R> KtPropertyAccessor.let(block: (KtPropertyAccessor) -> CodeToInline): CodeToInline defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtPropertyAccessor
    <R> -> CodeToInline

'buildCodeToInline' @ [100:17] ==> internal fun buildCodeToInline(declaration: KtDeclaration, returnType: KotlinType?, isReturnTypeExplicit: Boolean, bodyOrInitializer: KtExpression, isBlockBody: Boolean, editor: Editor?): CodeToInline? defined in org.jetbrains.kotlin.idea.refactoring.inline in file inlineUtils.kt[SimpleFunctionDescriptorImpl]

'getter' @ [100:35] ==> val getter: KtPropertyAccessor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'descriptor' @ [100:43] ==> val descriptor: ValueDescriptor defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'type' @ [100:54] ==> public final val ValueDescriptor.type: KotlinType[MyPropertyDescriptor]

'isTypeExplicit' @ [100:60] ==> val isTypeExplicit: Boolean defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'getter' @ [100:76] ==> val getter: KtPropertyAccessor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'bodyExpression' @ [100:83] ==> public final val KtPropertyAccessor.bodyExpression: KtExpression?[MyPropertyDescriptor]

'getter' @ [100:101] ==> val getter: KtPropertyAccessor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'hasBlockBody' @ [100:108] ==> public open fun hasBlockBody(): Boolean defined in org.jetbrains.kotlin.psi.KtPropertyAccessor[JavaMethodDescriptor]

'editor' @ [100:124] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[ValueParameterDescriptorImpl]

'writeReplacement' @ [102:13] ==> val writeReplacement: CodeToInline? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'setter' @ [102:32] ==> val setter: KtPropertyAccessor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'let' @ [102:40] ==> @InlineOnly public inline fun <T, R> KtPropertyAccessor.let(block: (KtPropertyAccessor) -> CodeToInline): CodeToInline defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtPropertyAccessor
    <R> -> CodeToInline

'buildCodeToInline' @ [103:17] ==> internal fun buildCodeToInline(declaration: KtDeclaration, returnType: KotlinType?, isReturnTypeExplicit: Boolean, bodyOrInitializer: KtExpression, isBlockBody: Boolean, editor: Editor?): CodeToInline? defined in org.jetbrains.kotlin.idea.refactoring.inline in file inlineUtils.kt[SimpleFunctionDescriptorImpl]

'setter' @ [103:35] ==> val setter: KtPropertyAccessor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'setter' @ [103:43] ==> val setter: KtPropertyAccessor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'builtIns' @ [103:50] ==> public val KtElement.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.idea.project[DeserializedPropertyDescriptor]

'unitType' @ [103:59] ==> public final val KotlinBuiltIns.unitType: SimpleType[MyPropertyDescriptor]

'setter' @ [103:75] ==> val setter: KtPropertyAccessor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'bodyExpression' @ [103:82] ==> public final val KtPropertyAccessor.bodyExpression: KtExpression?[MyPropertyDescriptor]

'setter' @ [103:100] ==> val setter: KtPropertyAccessor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'hasBlockBody' @ [103:107] ==> public open fun hasBlockBody(): Boolean defined in org.jetbrains.kotlin.psi.KtPropertyAccessor[JavaMethodDescriptor]

'editor' @ [103:123] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[ValueParameterDescriptorImpl]

'assignmentToDelete' @ [105:13] ==> val assignmentToDelete: KtBinaryExpression? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'if (!conflicts.isEmpty) {
            val conflictsCopy = conflicts.copy()
            val allOrSome = if (referenceExpressions.isEmpty()) "All" else "The following"
            conflictsCopy.putValue(null, "$allOrSome usages are not supported by the Inline refactoring. They won't be processed.")

            project.checkConflictsInteractively(conflictsCopy) {
                performRefactoring(declaration, readReplacement, writeReplacement, assignmentToDelete, editor, hasHighlightings)
            }
        }
        else {
            performRefactoring(declaration, readReplacement, writeReplacement, assignmentToDelete, editor, hasHighlightings)
        }' @ [108:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'!' @ [108:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'conflicts' @ [108:14] ==> val conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'isEmpty' @ [108:24] ==> public final val <K : (Any..Any?), V : (Any..Any?)> MultiMap<PsiElement, String>.isEmpty: Boolean[MyPropertyDescriptor]
Inferred types:
    <K : (Any..Any?)> -> PsiElement
    <V : (Any..Any?)> -> String

'conflicts' @ [109:33] ==> val conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'copy' @ [109:43] ==> @NotNull public open fun copy(): MultiMap<(PsiElement..PsiElement?), (String..String?)> defined in com.intellij.util.containers.MultiMap[JavaMethodDescriptor]

'if (referenceExpressions.isEmpty()) "All" else "The following"' @ [110:29] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'referenceExpressions' @ [110:33] ==> val referenceExpressions: Collection<KtExpression> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'isEmpty' @ [110:54] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.Collection[DeserializedSimpleFunctionDescriptor]

'conflictsCopy' @ [111:13] ==> val conflictsCopy: MultiMap<(PsiElement..PsiElement?), (String..String?)> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'putValue' @ [111:27] ==> public open fun putValue(@Nullable p0: PsiElement?, p1: (String..String?)): Unit defined in com.intellij.util.containers.MultiMap[JavaMethodDescriptor]

'allOrSome' @ [111:44] ==> val allOrSome: String defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'project' @ [113:13] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[ValueParameterDescriptorImpl]

'checkConflictsInteractively' @ [113:21] ==> public fun Project.checkConflictsInteractively(conflicts: MultiMap<PsiElement, String>, onShowConflicts: () -> Unit = ..., onAccept: () -> Unit): Unit defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'conflictsCopy' @ [113:49] ==> val conflictsCopy: MultiMap<(PsiElement..PsiElement?), (String..String?)> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'performRefactoring' @ [114:17] ==> private final fun performRefactoring(declaration: KtProperty, readReplacement: CodeToInline?, writeReplacement: CodeToInline?, assignmentToDelete: KtBinaryExpression?, editor: Editor?, hasHighlightings: Boolean): Unit defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler[SimpleFunctionDescriptorImpl]

'declaration' @ [114:36] ==> val declaration: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'readReplacement' @ [114:49] ==> val readReplacement: CodeToInline? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'writeReplacement' @ [114:66] ==> val writeReplacement: CodeToInline? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'assignmentToDelete' @ [114:84] ==> val assignmentToDelete: KtBinaryExpression? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'editor' @ [114:104] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[ValueParameterDescriptorImpl]

'hasHighlightings' @ [114:112] ==> val hasHighlightings: Boolean defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'performRefactoring' @ [118:13] ==> private final fun performRefactoring(declaration: KtProperty, readReplacement: CodeToInline?, writeReplacement: CodeToInline?, assignmentToDelete: KtBinaryExpression?, editor: Editor?, hasHighlightings: Boolean): Unit defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler[SimpleFunctionDescriptorImpl]

'declaration' @ [118:32] ==> val declaration: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'readReplacement' @ [118:45] ==> val readReplacement: CodeToInline? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'writeReplacement' @ [118:62] ==> val writeReplacement: CodeToInline? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'assignmentToDelete' @ [118:80] ==> val assignmentToDelete: KtBinaryExpression? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'editor' @ [118:100] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[ValueParameterDescriptorImpl]

'hasHighlightings' @ [118:108] ==> val hasHighlightings: Boolean defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.inlineElement[LocalVariableDescriptor]

'search' @ [125:43] ==> @NotNull public open fun search(@NotNull p0: PsiElement): Query<(PsiReference..PsiReference?)> defined in com.intellij.psi.search.searches.ReferencesSearch[JavaMethodDescriptor]

'declaration' @ [125:50] ==> value-parameter declaration: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.findUsages[ValueParameterDescriptorImpl]

'mutableListOf' @ [126:36] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableListOf(): MutableList<KtExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'create' @ [127:39] ==> @NotNull public open fun <K : (Any..Any?), V : (Any..Any?)> create(): MultiMap<(PsiElement..PsiElement?), (String..String?)> defined in com.intellij.util.containers.MultiMap[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> PsiElement
    <V : (Any..Any?)> -> String

'references' @ [128:21] ==> val references: Query<(PsiReference..PsiReference?)> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.findUsages[LocalVariableDescriptor]

'ref' @ [129:30] ==> val ref: (PsiReference..PsiReference?) defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.findUsages[LocalVariableDescriptor]

'element' @ [129:34] ==> public final val PsiReference.element: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'refElement' @ [130:17] ==> val refElement: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.findUsages[LocalVariableDescriptor]

'conflictUsages' @ [131:17] ==> val conflictUsages: MultiMap<(PsiElement..PsiElement?), (String..String?)> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.findUsages[LocalVariableDescriptor]

'putValue' @ [131:32] ==> public open fun putValue(@Nullable p0: PsiElement?, p1: (String..String?)): Unit defined in com.intellij.util.containers.MultiMap[JavaMethodDescriptor]

'refElement' @ [131:41] ==> val refElement: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.findUsages[LocalVariableDescriptor]

'refElement' @ [131:74] ==> val refElement: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.findUsages[LocalVariableDescriptor]

'text' @ [131:85] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'refElement' @ [135:31] ==> val refElement: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.findUsages[LocalVariableDescriptor]

'getQualifiedExpressionForSelectorOrThis' @ [135:61] ==> public fun KtExpression.getQualifiedExpressionForSelectorOrThis(): KtExpression defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'expression' @ [137:17] ==> val expression: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.findUsages[LocalVariableDescriptor]

'expression' @ [138:21] ==> val expression: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.findUsages[LocalVariableDescriptor]

'readWriteAccess' @ [138:32] ==> public fun KtExpression.readWriteAccess(useResolveForReadWrite: Boolean): ReferenceAccess defined in org.jetbrains.kotlin.idea.references[DeserializedSimpleFunctionDescriptor]

'READ_WRITE' @ [138:98] ==> enum entry READ_WRITE defined in org.jetbrains.kotlin.idea.references.ReferenceAccess[FakeCallableDescriptorForObject]

'conflictUsages' @ [139:21] ==> val conflictUsages: MultiMap<(PsiElement..PsiElement?), (String..String?)> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.findUsages[LocalVariableDescriptor]

'putValue' @ [139:36] ==> public open fun putValue(@Nullable p0: PsiElement?, p1: (String..String?)): Unit defined in com.intellij.util.containers.MultiMap[JavaMethodDescriptor]

'expression' @ [139:45] ==> val expression: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.findUsages[LocalVariableDescriptor]

'expression' @ [139:79] ==> val expression: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.findUsages[LocalVariableDescriptor]

'parent' @ [139:90] ==> public final val KtExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'text' @ [139:97] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'referenceExpressions' @ [141:17] ==> val referenceExpressions: MutableList<KtExpression> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.findUsages[LocalVariableDescriptor]

'add' @ [141:38] ==> public abstract fun add(element: KtExpression): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'expression' @ [141:42] ==> val expression: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.findUsages[LocalVariableDescriptor]

'Usages' @ [144:16] ==> public constructor Usages(referenceExpressions: Collection<KtExpression>, conflicts: MultiMap<PsiElement, String>) defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.Usages[ClassConstructorDescriptorImpl]

'referenceExpressions' @ [144:23] ==> val referenceExpressions: MutableList<KtExpression> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.findUsages[LocalVariableDescriptor]

'conflictUsages' @ [144:45] ==> val conflictUsages: MultiMap<(PsiElement..PsiElement?), (String..String?)> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.findUsages[LocalVariableDescriptor]

'referenceExpressions' @ [155:27] ==> value-parameter referenceExpressions: Collection<KtExpression> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.extractInitialization[ValueParameterDescriptorImpl]

'filter' @ [155:48] ==> public inline fun <T> Iterable<KtExpression>.filter(predicate: (KtExpression) -> Boolean): List<KtExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'it' @ [155:57] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.extractInitialization.<anonymous>[ValueParameterDescriptorImpl]

'readWriteAccess' @ [155:60] ==> public fun KtExpression.readWriteAccess(useResolveForReadWrite: Boolean): ReferenceAccess defined in org.jetbrains.kotlin.idea.references[DeserializedSimpleFunctionDescriptor]

'READ' @ [155:126] ==> enum entry READ defined in org.jetbrains.kotlin.idea.references.ReferenceAccess[FakeCallableDescriptorForObject]

'declaration' @ [157:40] ==> value-parameter declaration: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.extractInitialization[ValueParameterDescriptorImpl]

'initializer' @ [157:52] ==> public final var KtProperty.initializer: KtExpression?[MyPropertyDescriptor]

'if (initializerInDeclaration != null) {
            if (!writeUsages.isEmpty()) {
                reportAmbiguousAssignment(project, editor, declaration.name!!, writeUsages)
                return null
            }
            return Initialization(initializerInDeclaration, assignment = null)
        }
        else {
            val assignment = writeUsages.singleOrNull()
                    ?.getAssignmentByLHS()
                    ?.takeIf { it.operationToken == KtTokens.EQ }
            val initializer = assignment?.right
            if (initializer == null) {
                reportAmbiguousAssignment(project, editor, declaration.name!!, writeUsages)
                return null
            }
            return Initialization(initializer, assignment)
        }' @ [158:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nothing, elseBranch: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nothing

'initializerInDeclaration' @ [158:13] ==> val initializerInDeclaration: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.extractInitialization[LocalVariableDescriptor]

'!' @ [159:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'writeUsages' @ [159:18] ==> val writeUsages: List<KtExpression> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.extractInitialization[LocalVariableDescriptor]

'isEmpty' @ [159:30] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'reportAmbiguousAssignment' @ [160:17] ==> private final fun reportAmbiguousAssignment(project: Project, editor: Editor?, name: String, assignments: Collection<PsiElement>): Unit defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler[SimpleFunctionDescriptorImpl]

'project' @ [160:43] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.extractInitialization[ValueParameterDescriptorImpl]

'editor' @ [160:52] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.extractInitialization[ValueParameterDescriptorImpl]

'declaration' @ [160:60] ==> value-parameter declaration: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.extractInitialization[ValueParameterDescriptorImpl]

'name' @ [160:72] ==> public final val KtProperty.name: String?[MyPropertyDescriptor]

'writeUsages' @ [160:80] ==> val writeUsages: List<KtExpression> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.extractInitialization[LocalVariableDescriptor]

'Initialization' @ [163:20] ==> public constructor Initialization(value: KtExpression, assignment: KtBinaryExpression?) defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.Initialization[ClassConstructorDescriptorImpl]

'initializerInDeclaration' @ [163:35] ==> val initializerInDeclaration: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.extractInitialization[LocalVariableDescriptor]

'writeUsages' @ [166:30] ==> val writeUsages: List<KtExpression> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.extractInitialization[LocalVariableDescriptor]

'singleOrNull' @ [166:42] ==> public fun <T> List<KtExpression>.singleOrNull(): KtExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'getAssignmentByLHS' @ [167:23] ==> public fun KtExpression.getAssignmentByLHS(): KtBinaryExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'takeIf' @ [168:23] ==> @InlineOnly @SinceKotlin public inline fun <T> KtBinaryExpression.takeIf(predicate: (KtBinaryExpression) -> Boolean): KtBinaryExpression? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtBinaryExpression

'it' @ [168:32] ==> value-parameter it: KtBinaryExpression defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.extractInitialization.<anonymous>[ValueParameterDescriptorImpl]

'operationToken' @ [168:35] ==> public final val KtBinaryExpression.operationToken: IElementType[MyPropertyDescriptor]

'EQ' @ [168:62] ==> public final val EQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'assignment' @ [169:31] ==> val assignment: KtBinaryExpression? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.extractInitialization[LocalVariableDescriptor]

'right' @ [169:43] ==> public final val KtBinaryExpression.right: KtExpression?[MyPropertyDescriptor]

'initializer' @ [170:17] ==> val initializer: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.extractInitialization[LocalVariableDescriptor]

'reportAmbiguousAssignment' @ [171:17] ==> private final fun reportAmbiguousAssignment(project: Project, editor: Editor?, name: String, assignments: Collection<PsiElement>): Unit defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler[SimpleFunctionDescriptorImpl]

'project' @ [171:43] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.extractInitialization[ValueParameterDescriptorImpl]

'editor' @ [171:52] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.extractInitialization[ValueParameterDescriptorImpl]

'declaration' @ [171:60] ==> value-parameter declaration: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.extractInitialization[ValueParameterDescriptorImpl]

'name' @ [171:72] ==> public final val KtProperty.name: String?[MyPropertyDescriptor]

'writeUsages' @ [171:80] ==> val writeUsages: List<KtExpression> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.extractInitialization[LocalVariableDescriptor]

'Initialization' @ [174:20] ==> public constructor Initialization(value: KtExpression, assignment: KtBinaryExpression?) defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.Initialization[ClassConstructorDescriptorImpl]

'initializer' @ [174:35] ==> val initializer: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.extractInitialization[LocalVariableDescriptor]

'assignment' @ [174:48] ==> val assignment: KtBinaryExpression? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.extractInitialization[LocalVariableDescriptor]

'PropertyUsageReplacementStrategy' @ [186:35] ==> public constructor PropertyUsageReplacementStrategy(readReplacement: CodeToInline?, writeReplacement: CodeToInline?) defined in org.jetbrains.kotlin.idea.codeInliner.PropertyUsageReplacementStrategy[ClassConstructorDescriptorImpl]

'readReplacement' @ [186:68] ==> value-parameter readReplacement: CodeToInline? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.performRefactoring[ValueParameterDescriptorImpl]

'writeReplacement' @ [186:85] ==> value-parameter writeReplacement: CodeToInline? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.performRefactoring[ValueParameterDescriptorImpl]

'editor' @ [188:25] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.performRefactoring[ValueParameterDescriptorImpl]

'let' @ [188:33] ==> @InlineOnly public inline fun <T, R> Editor.let(block: (Editor) -> PsiReference?): PsiReference? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Editor
    <R> -> PsiReference?

'findReference' @ [188:57] ==> @Nullable public open fun findReference(@NotNull p0: Editor, p1: Int): PsiReference? defined in com.intellij.codeInsight.TargetElementUtil[JavaMethodDescriptor]

'it' @ [188:71] ==> value-parameter it: Editor defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.performRefactoring.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [188:75] ==> value-parameter it: Editor defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.performRefactoring.<anonymous>[ValueParameterDescriptorImpl]

'caretModel' @ [188:78] ==> public final val Editor.caretModel: CaretModel[MyPropertyDescriptor]

'offset' @ [188:89] ==> public final val CaretModel.offset: Int[MyPropertyDescriptor]

'KotlinInlineValDialog' @ [190:22] ==> public constructor KotlinInlineValDialog(property: KtProperty, reference: KtSimpleNameReference?, replacementStrategy: UsageReplacementStrategy, assignmentToDelete: KtBinaryExpression?, withPreview: Boolean = ...) defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValDialog[ClassConstructorDescriptorImpl]

'declaration' @ [190:44] ==> value-parameter declaration: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.performRefactoring[ValueParameterDescriptorImpl]

'reference' @ [190:57] ==> val reference: KtSimpleNameReference? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.performRefactoring[LocalVariableDescriptor]

'replacementStrategy' @ [190:68] ==> val replacementStrategy: PropertyUsageReplacementStrategy defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.performRefactoring[LocalVariableDescriptor]

'assignmentToDelete' @ [190:89] ==> value-parameter assignmentToDelete: KtBinaryExpression? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.performRefactoring[ValueParameterDescriptorImpl]

'withPrompt' @ [190:123] ==> private final val withPrompt: Boolean defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler[PropertyDescriptorImpl]

'if (withPrompt && !ApplicationManager.getApplication().isUnitTestMode && dialog.shouldBeShown()) {
            dialog.show()
            if (!dialog.isOK && hasHighlightings) {
                val statusBar = WindowManager.getInstance().getStatusBar(declaration.project)
                statusBar?.info = RefactoringBundle.message("press.escape.to.remove.the.highlighting")
            }
        }
        else {
            dialog.doAction()
        }' @ [192:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'withPrompt' @ [192:13] ==> private final val withPrompt: Boolean defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler[PropertyDescriptorImpl]

'!' @ [192:27] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'getApplication' @ [192:47] ==> public open fun getApplication(): (Application..Application?) defined in com.intellij.openapi.application.ApplicationManager[JavaMethodDescriptor]

'isUnitTestMode' @ [192:64] ==> public final val Application.isUnitTestMode: Boolean[MyPropertyDescriptor]

'dialog' @ [192:82] ==> val dialog: KotlinInlineValDialog defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.performRefactoring[LocalVariableDescriptor]

'shouldBeShown' @ [192:89] ==> public final fun shouldBeShown(): Boolean defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValDialog[SimpleFunctionDescriptorImpl]

'dialog' @ [193:13] ==> val dialog: KotlinInlineValDialog defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.performRefactoring[LocalVariableDescriptor]

'show' @ [193:20] ==> public open fun show(): Unit defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValDialog[JavaMethodDescriptor]

'!' @ [194:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'dialog' @ [194:18] ==> val dialog: KotlinInlineValDialog defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.performRefactoring[LocalVariableDescriptor]

'isOK' @ [194:25] ==> public final val KotlinInlineValDialog.isOK: Boolean[MyPropertyDescriptor]

'hasHighlightings' @ [194:33] ==> value-parameter hasHighlightings: Boolean defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.performRefactoring[ValueParameterDescriptorImpl]

'getInstance' @ [195:47] ==> public open fun getInstance(): (WindowManager..WindowManager?) defined in com.intellij.openapi.wm.WindowManager[JavaMethodDescriptor]

'getStatusBar' @ [195:61] ==> public abstract fun getStatusBar(p0: (Project..Project?)): (StatusBar..StatusBar?) defined in com.intellij.openapi.wm.WindowManager[JavaMethodDescriptor]

'declaration' @ [195:74] ==> value-parameter declaration: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.performRefactoring[ValueParameterDescriptorImpl]

'project' @ [195:86] ==> public final val KtProperty.project: Project[MyPropertyDescriptor]

'statusBar' @ [196:17] ==> val statusBar: (StatusBar..StatusBar?) defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.performRefactoring[LocalVariableDescriptor]

'info' @ [196:28] ==> public final var StatusBar.info: (String..String?)[MyPropertyDescriptor]

'message' @ [196:53] ==> public open fun message(@PropertyKey p0: (String..String?)): (String..String?) defined in com.intellij.refactoring.RefactoringBundle[JavaMethodDescriptor]

'dialog' @ [200:13] ==> val dialog: KotlinInlineValDialog defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.performRefactoring[LocalVariableDescriptor]

'doAction' @ [200:20] ==> public open fun doAction(): Unit defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValDialog[SimpleFunctionDescriptorImpl]

'if (assignments.isEmpty()) "variable.has.no.initializer" else "variable.has.no.dominating.definition"' @ [205:19] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'assignments' @ [205:23] ==> value-parameter assignments: Collection<PsiElement> defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.reportAmbiguousAssignment[ValueParameterDescriptorImpl]

'isEmpty' @ [205:35] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.Collection[DeserializedSimpleFunctionDescriptor]

'getCannotRefactorMessage' @ [206:41] ==> public open fun getCannotRefactorMessage(@Nullable p0: String?): (String..String?) defined in com.intellij.refactoring.RefactoringBundle[JavaMethodDescriptor]

'message' @ [206:84] ==> public open fun message(@NotNull @PropertyKey p0: String, @NotNull vararg p1: (Any..Any?)): (String..String?) defined in com.intellij.refactoring.RefactoringBundle[JavaMethodDescriptor]

'key' @ [206:92] ==> val key: String defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.reportAmbiguousAssignment[LocalVariableDescriptor]

'name' @ [206:97] ==> value-parameter name: String defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.reportAmbiguousAssignment[ValueParameterDescriptorImpl]

'showErrorHint' @ [207:9] ==> private final fun showErrorHint(project: Project, editor: Editor?, message: String): Unit defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler[SimpleFunctionDescriptorImpl]

'project' @ [207:23] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.reportAmbiguousAssignment[ValueParameterDescriptorImpl]

'editor' @ [207:32] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.reportAmbiguousAssignment[ValueParameterDescriptorImpl]

'message' @ [207:40] ==> val message: (String..String?) defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.reportAmbiguousAssignment[LocalVariableDescriptor]

'showErrorHint' @ [211:31] ==> public open fun showErrorHint(@NotNull p0: Project, @Nullable p1: Editor?, @NotNull @Nls p2: String, @NotNull @Nls p3: String, @Nullable p4: String?): Unit defined in com.intellij.refactoring.util.CommonRefactoringUtil[JavaMethodDescriptor]

'project' @ [211:45] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.showErrorHint[ValueParameterDescriptorImpl]

'editor' @ [211:54] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.showErrorHint[ValueParameterDescriptorImpl]

'message' @ [211:62] ==> value-parameter message: String defined in org.jetbrains.kotlin.idea.refactoring.inline.KotlinInlineValHandler.showErrorHint[ValueParameterDescriptorImpl]

'message' @ [211:89] ==> public open fun message(@PropertyKey p0: (String..String?)): (String..String?) defined in com.intellij.refactoring.RefactoringBundle[JavaMethodDescriptor]

'INLINE_VARIABLE' @ [211:130] ==> public const final val INLINE_VARIABLE: String defined in com.intellij.refactoring.HelpID[JavaPropertyDescriptor]

