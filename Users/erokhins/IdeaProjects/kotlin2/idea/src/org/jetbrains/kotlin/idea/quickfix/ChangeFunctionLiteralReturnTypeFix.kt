'KotlinQuickFixAction<KtLambdaExpression>' @ [43:5] ==> public constructor KotlinQuickFixAction<out T : PsiElement>(element: KtLambdaExpression) defined in org.jetbrains.kotlin.idea.quickfix.KotlinQuickFixAction[ClassConstructorDescriptorImpl]
Inferred types:
    <out T : PsiElement> -> KtLambdaExpression

'functionLiteralExpression' @ [43:46] ==> value-parameter functionLiteralExpression: KtLambdaExpression defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.<init>[ValueParameterDescriptorImpl]

'IdeDescriptorRenderers' @ [45:36] ==> public object IdeDescriptorRenderers defined in org.jetbrains.kotlin.idea.util[FakeCallableDescriptorForObject]

'SOURCE_CODE_SHORT_NAMES_IN_TYPES' @ [45:59] ==> @field:JvmField public final val SOURCE_CODE_SHORT_NAMES_IN_TYPES: DescriptorRenderer defined in org.jetbrains.kotlin.idea.util.IdeDescriptorRenderers[DeserializedPropertyDescriptor]

'renderType' @ [45:92] ==> public abstract fun renderType(type: KotlinType): String defined in org.jetbrains.kotlin.renderer.DescriptorRenderer[DeserializedSimpleFunctionDescriptor]

'type' @ [45:103] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.<init>[ValueParameterDescriptorImpl]

'IdeDescriptorRenderers' @ [46:34] ==> public object IdeDescriptorRenderers defined in org.jetbrains.kotlin.idea.util[FakeCallableDescriptorForObject]

'SOURCE_CODE' @ [46:57] ==> @field:JvmField public final val SOURCE_CODE: DescriptorRenderer defined in org.jetbrains.kotlin.idea.util.IdeDescriptorRenderers[DeserializedPropertyDescriptor]

'renderType' @ [46:69] ==> public abstract fun renderType(type: KotlinType): String defined in org.jetbrains.kotlin.renderer.DescriptorRenderer[DeserializedSimpleFunctionDescriptor]

'type' @ [46:80] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.<init>[ValueParameterDescriptorImpl]

'element' @ [48:17] ==> protected final val element: KtLambdaExpression? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix[PropertyDescriptorImpl]

'functionLiteral' @ [48:26] ==> public final val KtLambdaExpression.functionLiteral: KtFunctionLiteral[MyPropertyDescriptor]

'typeReference' @ [48:43] ==> public final var KtFunctionLiteral.typeReference: KtTypeReference?[MyPropertyDescriptor]

'createAppropriateQuickFix' @ [49:39] ==> private final fun createAppropriateQuickFix(functionLiteralExpression: KtLambdaExpression, type: KotlinType): IntentionAction? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix[SimpleFunctionDescriptorImpl]

'functionLiteralExpression' @ [49:65] ==> value-parameter functionLiteralExpression: KtLambdaExpression defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.<init>[ValueParameterDescriptorImpl]

'type' @ [49:92] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.<init>[ValueParameterDescriptorImpl]

'functionLiteralExpression' @ [52:23] ==> value-parameter functionLiteralExpression: KtLambdaExpression defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[ValueParameterDescriptorImpl]

'analyze' @ [52:49] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'context' @ [53:35] ==> val context: BindingContext defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'getType' @ [53:43] ==> @Nullable public abstract fun getType(@NotNull p0: KtExpression): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]

'functionLiteralExpression' @ [53:51] ==> value-parameter functionLiteralExpression: KtLambdaExpression defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[ValueParameterDescriptorImpl]

'error' @ [53:81] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'functionLiteralType' @ [55:24] ==> val functionLiteralType: KotlinType defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'constructor' @ [55:44] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'builtIns' @ [55:56] ==> public final val TypeConstructor.builtIns: KotlinBuiltIns[MyPropertyDescriptor]

'builtIns' @ [56:29] ==> val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'getFunction' @ [56:38] ==> @NotNull public open fun getFunction(p0: Int): ClassDescriptor defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'functionLiteralType' @ [56:50] ==> val functionLiteralType: KotlinType defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'arguments' @ [56:70] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'size' @ [56:80] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'LinkedList' @ [57:43] ==> public constructor LinkedList<E : (Any..Any?)>() defined in java.util.LinkedList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> KotlinType

'functionLiteralType' @ [58:32] ==> val functionLiteralType: KotlinType defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'arguments' @ [58:52] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'functionClassTypeParameters' @ [59:13] ==> val functionClassTypeParameters: LinkedList<KotlinType> defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'add' @ [59:41] ==> public open fun add(element: KotlinType): Boolean defined in java.util.LinkedList[JavaMethodDescriptor]

'typeProjection' @ [59:45] ==> val typeProjection: TypeProjection defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'type' @ [59:60] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'functionClassTypeParameters' @ [62:9] ==> val functionClassTypeParameters: LinkedList<KotlinType> defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'removeAt' @ [62:37] ==> public open fun removeAt(p0: Int): KotlinType defined in java.util.LinkedList[JavaMethodDescriptor]

'functionClassTypeParameters' @ [62:46] ==> val functionClassTypeParameters: LinkedList<KotlinType> defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'size' @ [62:74] ==> public open val size: Int defined in java.util.LinkedList[JavaPropertyDescriptor]

'functionClassTypeParameters' @ [63:9] ==> val functionClassTypeParameters: LinkedList<KotlinType> defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'add' @ [63:37] ==> public open fun add(element: KotlinType): Boolean defined in java.util.LinkedList[JavaMethodDescriptor]

'type' @ [63:41] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[ValueParameterDescriptorImpl]

'substituteParameters' @ [64:53] ==> @NotNull public open fun substituteParameters(@NotNull p0: ClassDescriptor, @NotNull p1: (MutableList<(KotlinType..KotlinType?)>..List<(KotlinType..KotlinType?)>)): KotlinType defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'functionClass' @ [64:74] ==> val functionClass: ClassDescriptor defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'functionClassTypeParameters' @ [64:89] ==> val functionClassTypeParameters: LinkedList<KotlinType> defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'getParentOfType' @ [66:49] ==> @Nullable @Contract public open fun <T : (PsiElement..PsiElement?)> getParentOfType(@Nullable p0: PsiElement?, @NotNull p1: Class<(KtProperty..KtProperty?)>): KtProperty? defined in com.intellij.psi.util.PsiTreeUtil[JavaMethodDescriptor]
Inferred types:
    <T : (PsiElement..PsiElement?)> -> (org.jetbrains.kotlin.psi.KtProperty..org.jetbrains.kotlin.psi.KtProperty?)

'functionLiteralExpression' @ [66:65] ==> value-parameter functionLiteralExpression: KtLambdaExpression defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[ValueParameterDescriptorImpl]

'java' @ [66:110] ==> public val <T> KClass<KtProperty>.java: Class<KtProperty> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtProperty

'correspondingProperty' @ [67:13] ==> val correspondingProperty: KtProperty? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'correspondingProperty' @ [68:13] ==> val correspondingProperty: KtProperty? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'initializer' @ [68:35] ==> public final var KtProperty.initializer: KtExpression?[MyPropertyDescriptor]

'let' @ [68:48] ==> @InlineOnly public inline fun <T, R> KtExpression.let(block: (KtExpression) -> Boolean): Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression
    <R> -> Boolean

'canEvaluateTo' @ [68:67] ==> public open fun canEvaluateTo(p0: (KtExpression..KtExpression?), p1: (KtExpression..KtExpression?)): Boolean defined in org.jetbrains.kotlin.idea.core.quickfix.QuickFixUtil[JavaMethodDescriptor]

'it' @ [68:81] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix.<anonymous>[ValueParameterDescriptorImpl]

'functionLiteralExpression' @ [68:85] ==> value-parameter functionLiteralExpression: KtLambdaExpression defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[ValueParameterDescriptorImpl]

'correspondingProperty' @ [70:48] ==> val correspondingProperty: KtProperty? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'typeReference' @ [70:70] ==> public final var KtProperty.typeReference: KtTypeReference?[MyPropertyDescriptor]

'context' @ [71:32] ==> val context: BindingContext defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'get' @ [71:40] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(p0: (ReadOnlySlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>..ReadOnlySlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>?), p1: (KtTypeReference..KtTypeReference?)): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtTypeReference..org.jetbrains.kotlin.psi.KtTypeReference?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)

'TYPE' @ [71:59] ==> public final val TYPE: (WritableSlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>..WritableSlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'correspondingPropertyTypeRef' @ [71:65] ==> val correspondingPropertyTypeRef: KtTypeReference? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'if (propertyType != null && !KotlinTypeChecker.DEFAULT.isSubtypeOf(eventualFunctionLiteralType, propertyType))
                ChangeVariableTypeFix(correspondingProperty, eventualFunctionLiteralType)
            else
                null' @ [72:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: IntentionAction?, elseBranch: IntentionAction?): IntentionAction?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> IntentionAction?

'propertyType' @ [72:24] ==> val propertyType: KotlinType? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'!' @ [72:48] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'DEFAULT' @ [72:67] ==> public final val DEFAULT: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaPropertyDescriptor]

'isSubtypeOf' @ [72:75] ==> public abstract fun isSubtypeOf(@NotNull p0: KotlinType, @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaMethodDescriptor]

'eventualFunctionLiteralType' @ [72:87] ==> val eventualFunctionLiteralType: KotlinType defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'propertyType' @ [72:116] ==> val propertyType: KotlinType? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'ChangeVariableTypeFix' @ [73:17] ==> public constructor ChangeVariableTypeFix(element: KtVariableDeclaration, type: KotlinType) defined in org.jetbrains.kotlin.idea.quickfix.ChangeVariableTypeFix[ClassConstructorDescriptorImpl]

'correspondingProperty' @ [73:39] ==> val correspondingProperty: KtProperty? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'eventualFunctionLiteralType' @ [73:62] ==> val eventualFunctionLiteralType: KotlinType defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'functionLiteralExpression' @ [78:28] ==> value-parameter functionLiteralExpression: KtLambdaExpression defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[ValueParameterDescriptorImpl]

'getParentResolvedCall' @ [78:54] ==> public fun KtElement?.getParentResolvedCall(context: BindingContext, strict: Boolean = ...): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'context' @ [78:76] ==> val context: BindingContext defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'resolvedCall' @ [79:13] ==> val resolvedCall: ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'resolvedCall' @ [80:33] ==> val resolvedCall: ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'call' @ [80:46] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out CallableDescriptor)

'getValueArgumentForExpression' @ [80:51] ==> public fun Call.getValueArgumentForExpression(expression: KtExpression): ValueArgument? defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'functionLiteralExpression' @ [80:81] ==> value-parameter functionLiteralExpression: KtLambdaExpression defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[ValueParameterDescriptorImpl]

'getParameterDeclarationForValueArgument' @ [81:55] ==> @Nullable public open fun getParameterDeclarationForValueArgument(@NotNull p0: ResolvedCall<*>, @Nullable p1: ValueArgument?): KtParameter? defined in org.jetbrains.kotlin.idea.core.quickfix.QuickFixUtil[JavaMethodDescriptor]

'resolvedCall' @ [81:95] ==> val resolvedCall: ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'valueArgument' @ [81:109] ==> val valueArgument: ValueArgument? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'correspondingParameter' @ [82:17] ==> val correspondingParameter: KtParameter? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'correspondingParameter' @ [83:53] ==> val correspondingParameter: KtParameter? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'typeReference' @ [83:76] ==> public final var KtParameter.typeReference: KtTypeReference?[MyPropertyDescriptor]

'context' @ [84:37] ==> val context: BindingContext defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'get' @ [84:45] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(p0: (ReadOnlySlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>..ReadOnlySlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>?), p1: (KtTypeReference..KtTypeReference?)): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtTypeReference..org.jetbrains.kotlin.psi.KtTypeReference?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)

'TYPE' @ [84:64] ==> public final val TYPE: (WritableSlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>..WritableSlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'correspondingParameterTypeRef' @ [84:70] ==> val correspondingParameterTypeRef: KtTypeReference? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'if (parameterType != null && !KotlinTypeChecker.DEFAULT.isSubtypeOf(eventualFunctionLiteralType, parameterType))
                    ChangeParameterTypeFix(correspondingParameter, eventualFunctionLiteralType)
                else
                    null' @ [85:24] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: IntentionAction?, elseBranch: IntentionAction?): IntentionAction?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> IntentionAction?

'parameterType' @ [85:28] ==> val parameterType: KotlinType? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'!' @ [85:53] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'DEFAULT' @ [85:72] ==> public final val DEFAULT: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaPropertyDescriptor]

'isSubtypeOf' @ [85:80] ==> public abstract fun isSubtypeOf(@NotNull p0: KotlinType, @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaMethodDescriptor]

'eventualFunctionLiteralType' @ [85:92] ==> val eventualFunctionLiteralType: KotlinType defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'parameterType' @ [85:121] ==> val parameterType: KotlinType? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'ChangeParameterTypeFix' @ [86:21] ==> public constructor ChangeParameterTypeFix(element: KtParameter, type: KotlinType) defined in org.jetbrains.kotlin.idea.quickfix.ChangeParameterTypeFix[ClassConstructorDescriptorImpl]

'correspondingParameter' @ [86:44] ==> val correspondingParameter: KtParameter? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'eventualFunctionLiteralType' @ [86:68] ==> val eventualFunctionLiteralType: KotlinType defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'getParentOfType' @ [93:42] ==> @Nullable @Contract public open fun <T : (PsiElement..PsiElement?)> getParentOfType(@Nullable p0: PsiElement?, @NotNull p1: Class<(KtFunction..KtFunction?)>, p2: Boolean): KtFunction? defined in com.intellij.psi.util.PsiTreeUtil[JavaMethodDescriptor]
Inferred types:
    <T : (PsiElement..PsiElement?)> -> (org.jetbrains.kotlin.psi.KtFunction..org.jetbrains.kotlin.psi.KtFunction?)

'functionLiteralExpression' @ [93:58] ==> value-parameter functionLiteralExpression: KtLambdaExpression defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[ValueParameterDescriptorImpl]

'java' @ [93:103] ==> public val <T> KClass<KtFunction>.java: Class<KtFunction> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtFunction

'parentFunction' @ [94:13] ==> val parentFunction: KtFunction? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'canFunctionOrGetterReturnExpression' @ [94:52] ==> public open fun canFunctionOrGetterReturnExpression(@NotNull p0: KtDeclaration, @NotNull p1: KtExpression): Boolean defined in org.jetbrains.kotlin.idea.core.quickfix.QuickFixUtil[JavaMethodDescriptor]

'parentFunction' @ [94:88] ==> val parentFunction: KtFunction? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'functionLiteralExpression' @ [94:104] ==> value-parameter functionLiteralExpression: KtLambdaExpression defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[ValueParameterDescriptorImpl]

'parentFunction' @ [95:47] ==> val parentFunction: KtFunction? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'typeReference' @ [95:62] ==> public final var KtFunction.typeReference: KtTypeReference?[MyPropertyDescriptor]

'context' @ [96:44] ==> val context: BindingContext defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'get' @ [96:52] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(p0: (ReadOnlySlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>..ReadOnlySlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>?), p1: (KtTypeReference..KtTypeReference?)): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtTypeReference..org.jetbrains.kotlin.psi.KtTypeReference?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)

'TYPE' @ [96:71] ==> public final val TYPE: (WritableSlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>..WritableSlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'parentFunctionReturnTypeRef' @ [96:77] ==> val parentFunctionReturnTypeRef: KtTypeReference? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'if (parentFunctionReturnType != null && !KotlinTypeChecker.DEFAULT.isSubtypeOf(eventualFunctionLiteralType, parentFunctionReturnType))
                ChangeCallableReturnTypeFix.ForEnclosing(parentFunction, eventualFunctionLiteralType)
            else
                null' @ [97:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: IntentionAction?, elseBranch: IntentionAction?): IntentionAction?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> IntentionAction?

'parentFunctionReturnType' @ [97:24] ==> val parentFunctionReturnType: KotlinType? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'!' @ [97:60] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'DEFAULT' @ [97:79] ==> public final val DEFAULT: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaPropertyDescriptor]

'isSubtypeOf' @ [97:87] ==> public abstract fun isSubtypeOf(@NotNull p0: KotlinType, @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaMethodDescriptor]

'eventualFunctionLiteralType' @ [97:99] ==> val eventualFunctionLiteralType: KotlinType defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'parentFunctionReturnType' @ [97:128] ==> val parentFunctionReturnType: KotlinType? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'ForEnclosing' @ [98:45] ==> public constructor ForEnclosing(element: KtFunction, type: KotlinType) defined in org.jetbrains.kotlin.idea.quickfix.ChangeCallableReturnTypeFix.ForEnclosing[ClassConstructorDescriptorImpl]

'parentFunction' @ [98:58] ==> val parentFunction: KtFunction? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'eventualFunctionLiteralType' @ [98:74] ==> val eventualFunctionLiteralType: KotlinType defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.createAppropriateQuickFix[LocalVariableDescriptor]

'appropriateQuickFix' @ [106:30] ==> private final val appropriateQuickFix: IntentionAction? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix[PropertyDescriptorImpl]

'text' @ [106:51] ==> public final val IntentionAction.text: String[MyPropertyDescriptor]

'typePresentation' @ [106:102] ==> private final val typePresentation: String defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix[PropertyDescriptorImpl]

'message' @ [108:49] ==> @NotNull public open fun message(@NonNls @PropertyKey p0: (String..String?), vararg p1: (Any..Any?)): String defined in org.jetbrains.kotlin.idea.KotlinBundle[JavaMethodDescriptor]

'super' @ [111:16] ==> <this> defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix[LazyClassReceiverParameterDescriptor]

'isAvailable' @ [111:22] ==> public open fun isAvailable(project: Project, editor: Editor?, file: PsiFile): Boolean defined in org.jetbrains.kotlin.idea.quickfix.KotlinQuickFixAction[SimpleFunctionDescriptorImpl]

'project' @ [111:34] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.isAvailable[ValueParameterDescriptorImpl]

'editor' @ [111:43] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.isAvailable[ValueParameterDescriptorImpl]

'file' @ [111:51] ==> value-parameter file: PsiFile defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.isAvailable[ValueParameterDescriptorImpl]

'functionLiteralReturnTypeRef' @ [112:20] ==> private final val functionLiteralReturnTypeRef: KtTypeReference? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix[PropertyDescriptorImpl]

'appropriateQuickFix' @ [112:60] ==> private final val appropriateQuickFix: IntentionAction? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix[PropertyDescriptorImpl]

'appropriateQuickFix' @ [112:91] ==> private final val appropriateQuickFix: IntentionAction? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix[PropertyDescriptorImpl]

'isAvailable' @ [112:111] ==> public abstract fun isAvailable(@NotNull p0: Project, p1: (Editor..Editor?), p2: (PsiFile..PsiFile?)): Boolean defined in com.intellij.codeInsight.intention.IntentionAction[JavaMethodDescriptor]

'project' @ [112:123] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.isAvailable[ValueParameterDescriptorImpl]

'editor' @ [112:132] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.isAvailable[ValueParameterDescriptorImpl]

'file' @ [112:142] ==> value-parameter file: PsiFile defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.isAvailable[ValueParameterDescriptorImpl]

'functionLiteralReturnTypeRef' @ [116:9] ==> private final val functionLiteralReturnTypeRef: KtTypeReference? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix[PropertyDescriptorImpl]

'let' @ [116:39] ==> @InlineOnly public inline fun <T, R> KtTypeReference.let(block: (KtTypeReference) -> KtElement): KtElement defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtTypeReference
    <R> -> KtElement

'it' @ [117:30] ==> value-parameter it: KtTypeReference defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.invoke.<anonymous>[ValueParameterDescriptorImpl]

'replace' @ [117:33] ==> public open fun replace(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtTypeReference[JavaMethodDescriptor]

'KtPsiFactory' @ [117:41] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'file' @ [117:54] ==> value-parameter file: KtFile defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.invoke[ValueParameterDescriptorImpl]

'createType' @ [117:60] ==> public final fun createType(type: String): KtTypeReference defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'typeSourceCode' @ [117:71] ==> private final val typeSourceCode: String defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix[PropertyDescriptorImpl]

'ShortenReferences' @ [118:13] ==> public companion object defined in org.jetbrains.kotlin.idea.core.ShortenReferences[FakeCallableDescriptorForObject]

'DEFAULT' @ [118:31] ==> @field:JvmField public final val DEFAULT: ShortenReferences defined in org.jetbrains.kotlin.idea.core.ShortenReferences.Companion[DeserializedPropertyDescriptor]

'process' @ [118:39] ==> @JvmOverloads public final fun process(element: KtElement, elementFilter: (PsiElement) -> ShortenReferences.FilterResult = ...): KtElement defined in org.jetbrains.kotlin.idea.core.ShortenReferences[DeserializedSimpleFunctionDescriptor]

'newTypeRef' @ [118:47] ==> val newTypeRef: KtTypeReference defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.invoke.<anonymous>[LocalVariableDescriptor]

'appropriateQuickFix' @ [120:13] ==> private final val appropriateQuickFix: IntentionAction? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix[PropertyDescriptorImpl]

'appropriateQuickFix' @ [120:44] ==> private final val appropriateQuickFix: IntentionAction? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix[PropertyDescriptorImpl]

'isAvailable' @ [120:64] ==> public abstract fun isAvailable(@NotNull p0: Project, p1: (Editor..Editor?), p2: (PsiFile..PsiFile?)): Boolean defined in com.intellij.codeInsight.intention.IntentionAction[JavaMethodDescriptor]

'project' @ [120:76] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.invoke[ValueParameterDescriptorImpl]

'editor' @ [120:85] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.invoke[ValueParameterDescriptorImpl]

'file' @ [120:95] ==> value-parameter file: KtFile defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.invoke[ValueParameterDescriptorImpl]

'appropriateQuickFix' @ [121:13] ==> private final val appropriateQuickFix: IntentionAction? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix[PropertyDescriptorImpl]

'invoke' @ [121:33] ==> public abstract operator fun invoke(@NotNull p0: Project, p1: (Editor..Editor?), p2: (PsiFile..PsiFile?)): Unit defined in com.intellij.codeInsight.intention.IntentionAction[JavaMethodDescriptor]

'project' @ [121:40] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.invoke[ValueParameterDescriptorImpl]

'editor' @ [121:49] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.invoke[ValueParameterDescriptorImpl]

'file' @ [121:57] ==> value-parameter file: KtFile defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.invoke[ValueParameterDescriptorImpl]

'KotlinSingleIntentionActionFactory' @ [125:24] ==> public constructor KotlinSingleIntentionActionFactory() defined in org.jetbrains.kotlin.idea.quickfix.KotlinSingleIntentionActionFactory[ClassConstructorDescriptorImpl]

'?:' @ [127:45] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtLambdaExpression?, right: KtLambdaExpression): KtLambdaExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtLambdaExpression

'getParentElementOfType' @ [127:58] ==> @Nullable public open fun <T : (PsiElement..PsiElement?)> getParentElementOfType(p0: (Diagnostic..Diagnostic?), p1: (Class<(KtLambdaExpression..KtLambdaExpression?)>..Class<(KtLambdaExpression..KtLambdaExpression?)>?)): KtLambdaExpression? defined in org.jetbrains.kotlin.idea.core.quickfix.QuickFixUtil[JavaMethodDescriptor]
Inferred types:
    <T : (PsiElement..PsiElement?)> -> (org.jetbrains.kotlin.psi.KtLambdaExpression..org.jetbrains.kotlin.psi.KtLambdaExpression?)

'diagnostic' @ [127:81] ==> value-parameter diagnostic: Diagnostic defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.Companion.createAction[ValueParameterDescriptorImpl]

'KtLambdaExpression' @ [127:93] ==> public constructor KtLambdaExpression(p0: (CharSequence..CharSequence?)) defined in org.jetbrains.kotlin.psi.KtLambdaExpression[JavaClassConstructorDescriptor]

'java' @ [127:119] ==> public val <T> KClass<KtLambdaExpression>.java: Class<KtLambdaExpression> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtLambdaExpression

'ChangeFunctionLiteralReturnTypeFix' @ [128:20] ==> public constructor ChangeFunctionLiteralReturnTypeFix(functionLiteralExpression: KtLambdaExpression, type: KotlinType) defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix[ClassConstructorDescriptorImpl]

'functionLiteralExpression' @ [128:55] ==> val functionLiteralExpression: KtLambdaExpression defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.Companion.createAction[LocalVariableDescriptor]

'functionLiteralExpression' @ [128:82] ==> val functionLiteralExpression: KtLambdaExpression defined in org.jetbrains.kotlin.idea.quickfix.ChangeFunctionLiteralReturnTypeFix.Companion.createAction[LocalVariableDescriptor]

'builtIns' @ [128:108] ==> public val KtElement.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.idea.project[DeserializedPropertyDescriptor]

'unitType' @ [128:117] ==> public final val KotlinBuiltIns.unitType: SimpleType[MyPropertyDescriptor]

