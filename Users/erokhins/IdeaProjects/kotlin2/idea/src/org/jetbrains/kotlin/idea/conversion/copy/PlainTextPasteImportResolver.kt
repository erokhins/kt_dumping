'dataForConversion' @ [41:24] ==> public final val dataForConversion: DataForConversion defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'file' @ [41:42] ==> public final val file: PsiJavaFile defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion[PropertyDescriptorImpl]

'targetFile' @ [42:27] ==> public final val targetFile: KtFile defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'project' @ [42:38] ==> public final val KtFile.project: Project[MyPropertyDescriptor]

'file' @ [44:30] ==> private final val file: PsiJavaFile defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'importList' @ [44:35] ==> public final val PsiJavaFile.importList: PsiImportList?[MyPropertyDescriptor]

'getInstance' @ [45:63] ==> public open fun getInstance(p0: (Project..Project?)): (PsiElementFactory..PsiElementFactory?) defined in com.intellij.psi.PsiElementFactory.SERVICE[JavaMethodDescriptor]

'project' @ [45:75] ==> private final val project: Project defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'getValue' @ [47:35] ==> @InlineOnly public operator inline fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> T

'targetFile' @ [47:42] ==> public final val targetFile: KtFile defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'analyzeFully' @ [47:53] ==> public fun KtElement.analyzeFully(): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'targetFile' @ [48:36] ==> public final val targetFile: KtFile defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'getResolutionFacade' @ [48:47] ==> public fun KtElement.getResolutionFacade(): ResolutionFacade defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'getInstance' @ [50:53] ==> public open fun getInstance(p0: (Project..Project?)): (PsiShortNamesCache..PsiShortNamesCache?) defined in com.intellij.psi.search.PsiShortNamesCache[JavaMethodDescriptor]

'project' @ [50:65] ==> private final val project: Project defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'file' @ [51:25] ==> private final val file: PsiJavaFile defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'resolveScope' @ [51:30] ==> public final val PsiJavaFile.resolveScope: GlobalSearchScope[MyPropertyDescriptor]

'HashSet' @ [53:49] ==> public constructor HashSet<E : (Any..Any?)>() defined in java.util.HashSet[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> String

'ArrayList' @ [57:24] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> PsiImportStatementBase

'descriptor' @ [60:16] ==> value-parameter descriptor: DeclarationDescriptorWithVisibility? defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.canBeImported[ValueParameterDescriptorImpl]

'descriptor' @ [61:19] ==> value-parameter descriptor: DeclarationDescriptorWithVisibility? defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.canBeImported[ValueParameterDescriptorImpl]

'canBeReferencedViaImport' @ [61:30] ==> public fun DeclarationDescriptor.canBeReferencedViaImport(): Boolean defined in org.jetbrains.kotlin.idea.imports[DeserializedSimpleFunctionDescriptor]

'descriptor' @ [62:19] ==> value-parameter descriptor: DeclarationDescriptorWithVisibility? defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.canBeImported[ValueParameterDescriptorImpl]

'isVisible' @ [62:30] ==> public fun DeclarationDescriptorWithVisibility.isVisible(context: PsiElement, receiverExpression: KtExpression?, bindingContext: BindingContext, resolutionFacade: ResolutionFacade): Boolean defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]

'targetFile' @ [62:40] ==> public final val targetFile: KtFile defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'bindingContext' @ [62:58] ==> private final val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'resolutionFacade' @ [62:74] ==> private final val resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'importList' @ [66:9] ==> private final val importList: PsiImportList defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'add' @ [66:20] ==> public abstract fun add(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiImportList[JavaMethodDescriptor]

'importStatement' @ [66:24] ==> value-parameter importStatement: PsiImportStatementBase defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.addImport[ValueParameterDescriptorImpl]

'shouldAddToTarget' @ [67:13] ==> value-parameter shouldAddToTarget: Boolean = ... defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.addImport[ValueParameterDescriptorImpl]

'addedImports' @ [68:13] ==> public final val addedImports: ArrayList<PsiImportStatementBase> defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'add' @ [68:26] ==> public open fun add(element: PsiImportStatementBase): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'importStatement' @ [68:30] ==> value-parameter importStatement: PsiImportStatementBase defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.addImport[ValueParameterDescriptorImpl]

'importDirective' @ [74:30] ==> value-parameter importDirective: KtImportDirective defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.addImportsFromTargetFile.tryConvertKotlinImport[ValueParameterDescriptorImpl]

'importPath' @ [74:46] ==> public final val KtImportDirective.importPath: ImportPath?[MyPropertyDescriptor]

'importDirective' @ [75:37] ==> value-parameter importDirective: KtImportDirective defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.addImportsFromTargetFile.tryConvertKotlinImport[ValueParameterDescriptorImpl]

'importedReference' @ [75:53] ==> public final val KtImportDirective.importedReference: KtExpression?[MyPropertyDescriptor]

'importPath' @ [76:17] ==> val importPath: ImportPath? defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.addImportsFromTargetFile.tryConvertKotlinImport[LocalVariableDescriptor]

'!' @ [76:39] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'importPath' @ [76:40] ==> val importPath: ImportPath? defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.addImportsFromTargetFile.tryConvertKotlinImport[LocalVariableDescriptor]

'hasAlias' @ [76:51] ==> public final fun hasAlias(): Boolean defined in org.jetbrains.kotlin.resolve.ImportPath[DeserializedSimpleFunctionDescriptor]

'importedReference' @ [76:65] ==> val importedReference: KtExpression? defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.addImportsFromTargetFile.tryConvertKotlinImport[LocalVariableDescriptor]

'importedReference' @ [77:32] ==> val importedReference: KtExpression? defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.addImportsFromTargetFile.tryConvertKotlinImport[LocalVariableDescriptor]

'receiverExpression' @ [78:26] ==> public open val receiverExpression: KtExpression defined in org.jetbrains.kotlin.psi.KtDotQualifiedExpression[DeserializedPropertyDescriptor]

'referenceExpression' @ [79:26] ==> public fun KtExpression.referenceExpression(): KtReferenceExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'mainReference' @ [80:27] ==> public val KtReferenceExpression.mainReference: KtReference defined in org.jetbrains.kotlin.idea.references[DeserializedPropertyDescriptor]

'resolve' @ [81:27] ==> @Nullable public abstract fun resolve(): PsiElement? defined in org.jetbrains.kotlin.idea.references.KtReference[JavaMethodDescriptor]

'importedReference' @ [82:32] ==> val importedReference: KtExpression? defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.addImportsFromTargetFile.tryConvertKotlinImport[LocalVariableDescriptor]

'selectorExpression' @ [83:26] ==> public open val selectorExpression: KtExpression? defined in org.jetbrains.kotlin.psi.KtDotQualifiedExpression[DeserializedPropertyDescriptor]

'referenceExpression' @ [84:27] ==> public fun KtExpression.referenceExpression(): KtReferenceExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'mainReference' @ [85:27] ==> public val KtReferenceExpression.mainReference: KtReference defined in org.jetbrains.kotlin.idea.references[DeserializedPropertyDescriptor]

'resolve' @ [86:27] ==> @Nullable public abstract fun resolve(): PsiElement? defined in org.jetbrains.kotlin.idea.references.KtReference[JavaMethodDescriptor]

'receiver' @ [88:41] ==> val receiver: PsiElement? defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.addImportsFromTargetFile.tryConvertKotlinImport[LocalVariableDescriptor]

'receiver' @ [89:39] ==> val receiver: PsiElement? defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.addImportsFromTargetFile.tryConvertKotlinImport[LocalVariableDescriptor]

'selector' @ [90:39] ==> val selector: PsiElement? defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.addImportsFromTargetFile.tryConvertKotlinImport[LocalVariableDescriptor]

'if (importPath.isAllUnder) {
                    if (isClassReceiver)
                        addImport(psiElementFactory.createImportStaticStatement(receiver as PsiClass, "*"))
                    else if (isPackageReceiver)
                        addImport(psiElementFactory.createImportStatementOnDemand((receiver as PsiPackage).qualifiedName))
                }
                else {
                    if (isClassSelector)
                        addImport(psiElementFactory.createImportStatement(selector as PsiClass))
                    else if (isClassReceiver)
                        addImport(psiElementFactory.createImportStaticStatement(receiver as PsiClass, importPath.importedName!!.asString()))
                }' @ [92:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'importPath' @ [92:21] ==> val importPath: ImportPath? defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.addImportsFromTargetFile.tryConvertKotlinImport[LocalVariableDescriptor]

'isAllUnder' @ [92:32] ==> public final val isAllUnder: Boolean defined in org.jetbrains.kotlin.resolve.ImportPath[DeserializedPropertyDescriptor]

'if (isClassReceiver)
                        addImport(psiElementFactory.createImportStaticStatement(receiver as PsiClass, "*"))
                    else if (isPackageReceiver)
                        addImport(psiElementFactory.createImportStatementOnDemand((receiver as PsiPackage).qualifiedName))' @ [93:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'isClassReceiver' @ [93:25] ==> val isClassReceiver: Boolean defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.addImportsFromTargetFile.tryConvertKotlinImport[LocalVariableDescriptor]

'addImport' @ [94:25] ==> private final fun addImport(importStatement: PsiImportStatementBase, shouldAddToTarget: Boolean = ...): Unit defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[SimpleFunctionDescriptorImpl]

'psiElementFactory' @ [94:35] ==> private final val psiElementFactory: (PsiElementFactory..PsiElementFactory?) defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'createImportStaticStatement' @ [94:53] ==> @NotNull public abstract fun createImportStaticStatement(@NotNull p0: PsiClass, @NotNull p1: String): PsiImportStaticStatement defined in com.intellij.psi.PsiElementFactory[JavaMethodDescriptor]

'receiver' @ [94:81] ==> val receiver: PsiElement? defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.addImportsFromTargetFile.tryConvertKotlinImport[LocalVariableDescriptor]

'isPackageReceiver' @ [95:30] ==> val isPackageReceiver: Boolean defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.addImportsFromTargetFile.tryConvertKotlinImport[LocalVariableDescriptor]

'addImport' @ [96:25] ==> private final fun addImport(importStatement: PsiImportStatementBase, shouldAddToTarget: Boolean = ...): Unit defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[SimpleFunctionDescriptorImpl]

'psiElementFactory' @ [96:35] ==> private final val psiElementFactory: (PsiElementFactory..PsiElementFactory?) defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'createImportStatementOnDemand' @ [96:53] ==> @NotNull public abstract fun createImportStatementOnDemand(@NotNull @NonNls p0: String): PsiImportStatement defined in com.intellij.psi.PsiElementFactory[JavaMethodDescriptor]

'receiver' @ [96:84] ==> val receiver: PsiElement? defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.addImportsFromTargetFile.tryConvertKotlinImport[LocalVariableDescriptor]

'qualifiedName' @ [96:108] ==> public final val PsiPackage.qualifiedName: String[MyPropertyDescriptor]

'if (isClassSelector)
                        addImport(psiElementFactory.createImportStatement(selector as PsiClass))
                    else if (isClassReceiver)
                        addImport(psiElementFactory.createImportStaticStatement(receiver as PsiClass, importPath.importedName!!.asString()))' @ [99:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'isClassSelector' @ [99:25] ==> val isClassSelector: Boolean defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.addImportsFromTargetFile.tryConvertKotlinImport[LocalVariableDescriptor]

'addImport' @ [100:25] ==> private final fun addImport(importStatement: PsiImportStatementBase, shouldAddToTarget: Boolean = ...): Unit defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[SimpleFunctionDescriptorImpl]

'psiElementFactory' @ [100:35] ==> private final val psiElementFactory: (PsiElementFactory..PsiElementFactory?) defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'createImportStatement' @ [100:53] ==> @NotNull public abstract fun createImportStatement(@NotNull p0: PsiClass): PsiImportStatement defined in com.intellij.psi.PsiElementFactory[JavaMethodDescriptor]

'selector' @ [100:75] ==> val selector: PsiElement? defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.addImportsFromTargetFile.tryConvertKotlinImport[LocalVariableDescriptor]

'isClassReceiver' @ [101:30] ==> val isClassReceiver: Boolean defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.addImportsFromTargetFile.tryConvertKotlinImport[LocalVariableDescriptor]

'addImport' @ [102:25] ==> private final fun addImport(importStatement: PsiImportStatementBase, shouldAddToTarget: Boolean = ...): Unit defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[SimpleFunctionDescriptorImpl]

'psiElementFactory' @ [102:35] ==> private final val psiElementFactory: (PsiElementFactory..PsiElementFactory?) defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'createImportStaticStatement' @ [102:53] ==> @NotNull public abstract fun createImportStaticStatement(@NotNull p0: PsiClass, @NotNull p1: String): PsiImportStaticStatement defined in com.intellij.psi.PsiElementFactory[JavaMethodDescriptor]

'receiver' @ [102:81] ==> val receiver: PsiElement? defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.addImportsFromTargetFile.tryConvertKotlinImport[LocalVariableDescriptor]

'importPath' @ [102:103] ==> val importPath: ImportPath? defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.addImportsFromTargetFile.tryConvertKotlinImport[LocalVariableDescriptor]

'importedName' @ [102:114] ==> public final val importedName: Name? defined in org.jetbrains.kotlin.resolve.ImportPath[DeserializedPropertyDescriptor]

'asString' @ [102:129] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'importList' @ [106:13] ==> private final val importList: PsiImportList defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'dataForConversion' @ [106:28] ==> public final val dataForConversion: DataForConversion defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'elementsAndTexts' @ [106:46] ==> public final val elementsAndTexts: ElementAndTextList defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion[PropertyDescriptorImpl]

'toList' @ [106:63] ==> public final fun toList(): List<Any> defined in org.jetbrains.kotlin.idea.conversion.copy.ElementAndTextList[SimpleFunctionDescriptorImpl]

'runWriteAction' @ [107:13] ==> public fun <T> runWriteAction(action: () -> Unit): Unit defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Unit

'targetFile' @ [108:17] ==> public final val targetFile: KtFile defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'importDirectives' @ [108:28] ==> public final val KtFile.importDirectives: (MutableList<(KtImportDirective..KtImportDirective?)>..List<(KtImportDirective..KtImportDirective?)>)[MyPropertyDescriptor]

'forEach' @ [108:45] ==> @HidesMembers public inline fun <T> Iterable<(KtImportDirective..KtImportDirective?)>.forEach(action: ((KtImportDirective..KtImportDirective?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtImportDirective..org.jetbrains.kotlin.psi.KtImportDirective?)

'tryConvertKotlinImport' @ [108:55] ==> local final fun tryConvertKotlinImport(importDirective: KtImportDirective): Unit defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.addImportsFromTargetFile[SimpleFunctionDescriptorImpl]

'collectElements' @ [114:53] ==> @NotNull public final fun collectElements(@Nullable p0: PsiElement?, @NotNull p1: ((PsiElement..PsiElement?)) -> Boolean): (Array<(PsiElement..PsiElement?)>..Array<out (PsiElement..PsiElement?)>) defined in com.intellij.psi.util.PsiTreeUtil[SamAdapterFunctionDescriptor]

'file' @ [114:69] ==> private final val file: PsiJavaFile defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'it' @ [115:13] ==> value-parameter it: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.<anonymous>[ValueParameterDescriptorImpl]

'reference' @ [115:16] ==> public final val PsiElement.reference: PsiReference?[MyPropertyDescriptor]

'it' @ [116:16] ==> value-parameter it: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.<anonymous>[ValueParameterDescriptorImpl]

'reference' @ [116:19] ==> public final val PsiElement.reference: PsiReference?[MyPropertyDescriptor]

'it' @ [117:16] ==> value-parameter it: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.<anonymous>[ValueParameterDescriptorImpl]

'reference' @ [117:19] ==> public final val PsiElement.reference: PsiReference?[MyPropertyDescriptor]

'resolve' @ [117:30] ==> @Nullable public abstract fun resolve(): PsiElement? defined in com.intellij.psi.PsiReference[JavaMethodDescriptor]

'reference' @ [121:17] ==> value-parameter reference: PsiQualifiedReference defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference[ValueParameterDescriptorImpl]

'resolve' @ [121:27] ==> @Nullable public abstract fun resolve(): PsiElement? defined in com.intellij.psi.PsiQualifiedReference[JavaMethodDescriptor]

'reference' @ [122:33] ==> value-parameter reference: PsiQualifiedReference defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference[ValueParameterDescriptorImpl]

'referenceName' @ [122:43] ==> public final val PsiQualifiedReference.referenceName: String?[MyPropertyDescriptor]

'referenceName' @ [123:17] ==> val referenceName: String defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference[LocalVariableDescriptor]

'failedToResolveReferenceNames' @ [123:34] ==> private final val failedToResolveReferenceNames: HashSet<String> defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'shortNameCache' @ [124:27] ==> private final val shortNameCache: (PsiShortNamesCache..PsiShortNamesCache?) defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'getClassesByName' @ [124:42] ==> @NotNull public abstract fun getClassesByName(@NotNull @NonNls p0: String, @NotNull p1: GlobalSearchScope): (Array<(PsiClass..PsiClass?)>..Array<out (PsiClass..PsiClass?)>) defined in com.intellij.psi.search.PsiShortNamesCache[JavaMethodDescriptor]

'referenceName' @ [124:59] ==> val referenceName: String defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference[LocalVariableDescriptor]

'scope' @ [124:74] ==> private final val scope: GlobalSearchScope defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'mapNotNull' @ [125:22] ==> public inline fun <T, R : Any> Array<out (PsiClass..PsiClass?)>.mapNotNull(transform: ((PsiClass..PsiClass?)) -> Pair<(PsiClass..PsiClass?), ClassDescriptor?>?): List<Pair<(PsiClass..PsiClass?), ClassDescriptor?>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiClass..com.intellij.psi.PsiClass?)
    <R : Any> -> Pair<(com.intellij.psi.PsiClass..com.intellij.psi.PsiClass?), ClassDescriptor?>

'psiClass' @ [126:46] ==> value-parameter psiClass: (PsiClass..PsiClass?) defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference.<anonymous>[ValueParameterDescriptorImpl]

'containingFile' @ [126:55] ==> public final val PsiClass.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'if (ProjectRootsUtil.isInProjectOrLibraryContent(containingFile)) {
                            val resolutionFacade = KotlinCacheService.getInstance(project).getResolutionFacadeByFile(
                                    containingFile, JvmPlatform
                            )
                            psiClass to psiClass.resolveToDescriptor(resolutionFacade)
                        }
                        else {
                            null
                        }' @ [127:25] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Pair<(PsiClass..PsiClass?), ClassDescriptor?>?, elseBranch: Pair<(PsiClass..PsiClass?), ClassDescriptor?>?): Pair<(PsiClass..PsiClass?), ClassDescriptor?>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Pair<(com.intellij.psi.PsiClass..com.intellij.psi.PsiClass?), ClassDescriptor?>?

'ProjectRootsUtil' @ [127:29] ==> public object ProjectRootsUtil defined in org.jetbrains.kotlin.idea.util[FakeCallableDescriptorForObject]

'isInProjectOrLibraryContent' @ [127:46] ==> @JvmStatic public final fun isInProjectOrLibraryContent(element: PsiElement): Boolean defined in org.jetbrains.kotlin.idea.util.ProjectRootsUtil[DeserializedSimpleFunctionDescriptor]

'containingFile' @ [127:74] ==> val containingFile: (PsiFile..PsiFile?) defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference.<anonymous>[LocalVariableDescriptor]

'KotlinCacheService' @ [128:52] ==> public companion object defined in org.jetbrains.kotlin.caches.resolve.KotlinCacheService[FakeCallableDescriptorForObject]

'getInstance' @ [128:71] ==> public final fun getInstance(project: Project): KotlinCacheService defined in org.jetbrains.kotlin.caches.resolve.KotlinCacheService.Companion[DeserializedSimpleFunctionDescriptor]

'project' @ [128:83] ==> private final val project: Project defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'getResolutionFacadeByFile' @ [128:92] ==> public abstract fun getResolutionFacadeByFile(file: PsiFile, platform: TargetPlatform): ResolutionFacade defined in org.jetbrains.kotlin.caches.resolve.KotlinCacheService[DeserializedSimpleFunctionDescriptor]

'containingFile' @ [129:37] ==> val containingFile: (PsiFile..PsiFile?) defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference.<anonymous>[LocalVariableDescriptor]

'JvmPlatform' @ [129:53] ==> public object JvmPlatform : TargetPlatform defined in org.jetbrains.kotlin.resolve.jvm.platform[FakeCallableDescriptorForObject]

'psiClass' @ [131:29] ==> value-parameter psiClass: (PsiClass..PsiClass?) defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference.<anonymous>[ValueParameterDescriptorImpl]

'psiClass' @ [131:41] ==> value-parameter psiClass: (PsiClass..PsiClass?) defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference.<anonymous>[ValueParameterDescriptorImpl]

'resolveToDescriptor' @ [131:50] ==> public fun PsiClass.resolveToDescriptor(resolutionFacade: ResolutionFacade, declarationTranslator: (KtClassOrObject) -> KtClassOrObject? = ...): ClassDescriptor? defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'resolutionFacade' @ [131:70] ==> val resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference.<anonymous>[LocalVariableDescriptor]

'filter' @ [137:22] ==> public inline fun <T> Iterable<Pair<(PsiClass..PsiClass?), ClassDescriptor?>>.filter(predicate: (Pair<(PsiClass..PsiClass?), ClassDescriptor?>) -> Boolean): List<Pair<(PsiClass..PsiClass?), ClassDescriptor?>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<(com.intellij.psi.PsiClass..com.intellij.psi.PsiClass?), ClassDescriptor?>

'canBeImported' @ [137:31] ==> private final fun canBeImported(descriptor: DeclarationDescriptorWithVisibility?): Boolean defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[SimpleFunctionDescriptorImpl]

'it' @ [137:45] ==> value-parameter it: Pair<(PsiClass..PsiClass?), ClassDescriptor?> defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference.<anonymous>[ValueParameterDescriptorImpl]

'second' @ [137:48] ==> public final val second: ClassDescriptor? defined in kotlin.Pair[DeserializedPropertyDescriptor]

'classes' @ [139:13] ==> val classes: List<Pair<(PsiClass..PsiClass?), ClassDescriptor?>> defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference[LocalVariableDescriptor]

'find' @ [139:21] ==> @InlineOnly public inline fun <T> Iterable<Pair<(PsiClass..PsiClass?), ClassDescriptor?>>.find(predicate: (Pair<(PsiClass..PsiClass?), ClassDescriptor?>) -> Boolean): Pair<(PsiClass..PsiClass?), ClassDescriptor?>? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<(com.intellij.psi.PsiClass..com.intellij.psi.PsiClass?), ClassDescriptor?>

'component1' @ [139:29] ==> public final operator fun component1(): (PsiClass..PsiClass?) defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [139:32] ==> public final operator fun component2(): ClassDescriptor? defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'JavaToKotlinClassMap' @ [139:47] ==> public object JavaToKotlinClassMap : PlatformToKotlinClassMap defined in org.jetbrains.kotlin.platform[FakeCallableDescriptorForObject]

'mapPlatformClass' @ [139:68] ==> public open fun mapPlatformClass(classDescriptor: ClassDescriptor): Collection<ClassDescriptor> defined in org.jetbrains.kotlin.platform.JavaToKotlinClassMap[DeserializedSimpleFunctionDescriptor]

'descriptor' @ [139:85] ==> val descriptor: ClassDescriptor? defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference.<anonymous>[LocalVariableDescriptor]

'isNotEmpty' @ [139:99] ==> @InlineOnly public inline fun <T> Collection<ClassDescriptor>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ClassDescriptor

'let' @ [140:23] ==> @InlineOnly public inline fun <T, R> Pair<(PsiClass..PsiClass?), ClassDescriptor?>.let(block: (Pair<(PsiClass..PsiClass?), ClassDescriptor?>) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<(com.intellij.psi.PsiClass..com.intellij.psi.PsiClass?), ClassDescriptor?>
    <R> -> Unit

'component1' @ [140:30] ==> public final operator fun component1(): (PsiClass..PsiClass?) defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [140:40] ==> public final operator fun component2(): ClassDescriptor? defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'addImport' @ [140:46] ==> private final fun addImport(importStatement: PsiImportStatementBase, shouldAddToTarget: Boolean = ...): Unit defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[SimpleFunctionDescriptorImpl]

'psiElementFactory' @ [140:56] ==> private final val psiElementFactory: (PsiElementFactory..PsiElementFactory?) defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'createImportStatement' @ [140:74] ==> @NotNull public abstract fun createImportStatement(@NotNull p0: PsiClass): PsiImportStatement defined in com.intellij.psi.PsiElementFactory[JavaMethodDescriptor]

'psiClass' @ [140:96] ==> val psiClass: (PsiClass..PsiClass?) defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference.<anonymous>[LocalVariableDescriptor]

'reference' @ [141:17] ==> value-parameter reference: PsiQualifiedReference defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference[ValueParameterDescriptorImpl]

'resolve' @ [141:27] ==> @Nullable public abstract fun resolve(): PsiElement? defined in com.intellij.psi.PsiQualifiedReference[JavaMethodDescriptor]

'classes' @ [143:13] ==> val classes: List<Pair<(PsiClass..PsiClass?), ClassDescriptor?>> defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference[LocalVariableDescriptor]

'singleOrNull' @ [143:21] ==> public fun <T> List<Pair<(PsiClass..PsiClass?), ClassDescriptor?>>.singleOrNull(): Pair<(PsiClass..PsiClass?), ClassDescriptor?>? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<(com.intellij.psi.PsiClass..com.intellij.psi.PsiClass?), ClassDescriptor?>

'let' @ [143:37] ==> @InlineOnly public inline fun <T, R> Pair<(PsiClass..PsiClass?), ClassDescriptor?>.let(block: (Pair<(PsiClass..PsiClass?), ClassDescriptor?>) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<(com.intellij.psi.PsiClass..com.intellij.psi.PsiClass?), ClassDescriptor?>
    <R> -> Unit

'component1' @ [143:44] ==> public final operator fun component1(): (PsiClass..PsiClass?) defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [143:54] ==> public final operator fun component2(): ClassDescriptor? defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'addImport' @ [144:17] ==> private final fun addImport(importStatement: PsiImportStatementBase, shouldAddToTarget: Boolean = ...): Unit defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[SimpleFunctionDescriptorImpl]

'psiElementFactory' @ [144:27] ==> private final val psiElementFactory: (PsiElementFactory..PsiElementFactory?) defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'createImportStatement' @ [144:45] ==> @NotNull public abstract fun createImportStatement(@NotNull p0: PsiClass): PsiImportStatement defined in com.intellij.psi.PsiElementFactory[JavaMethodDescriptor]

'psiClass' @ [144:67] ==> val psiClass: (PsiClass..PsiClass?) defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference.<anonymous>[LocalVariableDescriptor]

'if (reference.resolve() != null) return true
            else {
                if (classes.isNotEmpty()) {
                    ambiguityInResolution = true
                    return false
                }
            }' @ [147:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'reference' @ [147:17] ==> value-parameter reference: PsiQualifiedReference defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference[ValueParameterDescriptorImpl]

'resolve' @ [147:27] ==> @Nullable public abstract fun resolve(): PsiElement? defined in com.intellij.psi.PsiQualifiedReference[JavaMethodDescriptor]

'classes' @ [149:21] ==> val classes: List<Pair<(PsiClass..PsiClass?), ClassDescriptor?>> defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference[LocalVariableDescriptor]

'isNotEmpty' @ [149:29] ==> @InlineOnly public inline fun <T> Collection<Pair<(PsiClass..PsiClass?), ClassDescriptor?>>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<(com.intellij.psi.PsiClass..com.intellij.psi.PsiClass?), ClassDescriptor?>

'ambiguityInResolution' @ [150:21] ==> private final var ambiguityInResolution: Boolean defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'shortNameCache' @ [155:28] ==> private final val shortNameCache: (PsiShortNamesCache..PsiShortNamesCache?) defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'getMethodsByName' @ [155:43] ==> @NotNull public abstract fun getMethodsByName(@NonNls @NotNull p0: String, @NotNull p1: GlobalSearchScope): (Array<(PsiMethod..PsiMethod?)>..Array<out (PsiMethod..PsiMethod?)>) defined in com.intellij.psi.search.PsiShortNamesCache[JavaMethodDescriptor]

'referenceName' @ [155:60] ==> val referenceName: String defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference[LocalVariableDescriptor]

'scope' @ [155:75] ==> private final val scope: GlobalSearchScope defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'asList' @ [155:82] ==> public fun <T> Array<out (PsiMethod..PsiMethod?)>.asList(): List<(PsiMethod..PsiMethod?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiMethod..com.intellij.psi.PsiMethod?)

'shortNameCache' @ [156:28] ==> private final val shortNameCache: (PsiShortNamesCache..PsiShortNamesCache?) defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'getFieldsByName' @ [156:43] ==> @NotNull public abstract fun getFieldsByName(@NotNull @NonNls p0: String, @NotNull p1: GlobalSearchScope): (Array<(PsiField..PsiField?)>..Array<out (PsiField..PsiField?)>) defined in com.intellij.psi.search.PsiShortNamesCache[JavaMethodDescriptor]

'referenceName' @ [156:59] ==> val referenceName: String defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference[LocalVariableDescriptor]

'scope' @ [156:74] ==> private final val scope: GlobalSearchScope defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'asList' @ [156:81] ==> public fun <T> Array<out (PsiField..PsiField?)>.asList(): List<(PsiField..PsiField?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiField..com.intellij.psi.PsiField?)

'map' @ [157:22] ==> public inline fun <T, R> Iterable<(Any..Any?)>.map(transform: ((Any..Any?)) -> PsiMember): List<PsiMember> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.Any..kotlin.Any?)
    <R> -> PsiMember

'it' @ [157:28] ==> value-parameter it: (Any..Any?) defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference.<anonymous>[ValueParameterDescriptorImpl]

'filter' @ [158:22] ==> public inline fun <T> Iterable<PsiMember>.filter(predicate: (PsiMember) -> Boolean): List<PsiMember> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiMember

'it' @ [158:31] ==> value-parameter it: PsiMember defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference.<anonymous>[ValueParameterDescriptorImpl]

'getNullableModuleInfo' @ [158:34] ==> public fun PsiElement.getNullableModuleInfo(): IdeaModuleInfo? defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'map' @ [159:22] ==> public inline fun <T, R> Iterable<PsiMember>.map(transform: (PsiMember) -> Pair<PsiMember, DeclarationDescriptorWithVisibility?>): List<Pair<PsiMember, DeclarationDescriptorWithVisibility?>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiMember
    <R> -> Pair<PsiMember, DeclarationDescriptorWithVisibility?>

'it' @ [159:28] ==> value-parameter it: PsiMember defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [159:34] ==> value-parameter it: PsiMember defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference.<anonymous>[ValueParameterDescriptorImpl]

'getJavaMemberDescriptor' @ [159:37] ==> @JvmOverloads public fun PsiMember.getJavaMemberDescriptor(resolutionFacade: ResolutionFacade? = ...): DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'resolutionFacade' @ [159:61] ==> private final val resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'filter' @ [160:22] ==> public inline fun <T> Iterable<Pair<PsiMember, DeclarationDescriptorWithVisibility?>>.filter(predicate: (Pair<PsiMember, DeclarationDescriptorWithVisibility?>) -> Boolean): List<Pair<PsiMember, DeclarationDescriptorWithVisibility?>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<PsiMember, DeclarationDescriptorWithVisibility?>

'canBeImported' @ [160:31] ==> private final fun canBeImported(descriptor: DeclarationDescriptorWithVisibility?): Boolean defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[SimpleFunctionDescriptorImpl]

'it' @ [160:45] ==> value-parameter it: Pair<PsiMember, DeclarationDescriptorWithVisibility?> defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference.<anonymous>[ValueParameterDescriptorImpl]

'second' @ [160:48] ==> public final val second: DeclarationDescriptorWithVisibility? defined in kotlin.Pair[DeserializedPropertyDescriptor]

'members' @ [162:13] ==> val members: List<Pair<PsiMember, DeclarationDescriptorWithVisibility?>> defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference[LocalVariableDescriptor]

'singleOrNull' @ [162:21] ==> public fun <T> List<Pair<PsiMember, DeclarationDescriptorWithVisibility?>>.singleOrNull(): Pair<PsiMember, DeclarationDescriptorWithVisibility?>? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<PsiMember, DeclarationDescriptorWithVisibility?>

'let' @ [162:37] ==> @InlineOnly public inline fun <T, R> Pair<PsiMember, DeclarationDescriptorWithVisibility?>.let(block: (Pair<PsiMember, DeclarationDescriptorWithVisibility?>) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<PsiMember, DeclarationDescriptorWithVisibility?>
    <R> -> Unit

'component1' @ [162:44] ==> public final operator fun component1(): PsiMember defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [162:55] ==> public final operator fun component2(): DeclarationDescriptorWithVisibility? defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'addImport' @ [163:17] ==> private final fun addImport(importStatement: PsiImportStatementBase, shouldAddToTarget: Boolean = ...): Unit defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[SimpleFunctionDescriptorImpl]

'psiElementFactory' @ [163:27] ==> private final val psiElementFactory: (PsiElementFactory..PsiElementFactory?) defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'createImportStaticStatement' @ [163:45] ==> @NotNull public abstract fun createImportStaticStatement(@NotNull p0: PsiClass, @NotNull p1: String): PsiImportStaticStatement defined in com.intellij.psi.PsiElementFactory[JavaMethodDescriptor]

'psiMember' @ [163:73] ==> val psiMember: PsiMember defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference.<anonymous>[LocalVariableDescriptor]

'containingClass' @ [163:83] ==> public final val PsiMember.containingClass: PsiClass?[MyPropertyDescriptor]

'psiMember' @ [163:102] ==> val psiMember: PsiMember defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference.<anonymous>[LocalVariableDescriptor]

'name' @ [163:112] ==> public final val PsiMember.name: String?[MyPropertyDescriptor]

'if (reference.resolve() != null) return false
            else {
                if (members.isNotEmpty()) {
                    ambiguityInResolution = true
                }
                else {
                    couldNotResolve = true
                }
            }' @ [166:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'reference' @ [166:17] ==> value-parameter reference: PsiQualifiedReference defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference[ValueParameterDescriptorImpl]

'resolve' @ [166:27] ==> @Nullable public abstract fun resolve(): PsiElement? defined in com.intellij.psi.PsiQualifiedReference[JavaMethodDescriptor]

'if (members.isNotEmpty()) {
                    ambiguityInResolution = true
                }
                else {
                    couldNotResolve = true
                }' @ [168:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'members' @ [168:21] ==> val members: List<Pair<PsiMember, DeclarationDescriptorWithVisibility?>> defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.tryResolveReference[LocalVariableDescriptor]

'isNotEmpty' @ [168:29] ==> @InlineOnly public inline fun <T> Collection<Pair<PsiMember, DeclarationDescriptorWithVisibility?>>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<PsiMember, DeclarationDescriptorWithVisibility?>

'ambiguityInResolution' @ [169:21] ==> private final var ambiguityInResolution: Boolean defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'couldNotResolve' @ [172:21] ==> private final var couldNotResolve: Boolean defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'runWriteAction' @ [178:9] ==> public fun <T> runWriteAction(action: () -> Unit): Unit defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Unit

'elementsWithUnresolvedRef' @ [179:13] ==> val elementsWithUnresolvedRef: (Array<(PsiElement..PsiElement?)>..Array<out (PsiElement..PsiElement?)>) defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences[LocalVariableDescriptor]

'reversed' @ [179:39] ==> public fun <T> Array<out (PsiElement..PsiElement?)>.reversed(): List<(PsiElement..PsiElement?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)

'forEach' @ [179:50] ==> @HidesMembers public inline fun <T> Iterable<(PsiElement..PsiElement?)>.forEach(action: ((PsiElement..PsiElement?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)

'it' @ [180:33] ==> value-parameter it: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'reference' @ [180:36] ==> public final val PsiElement.reference: PsiReference?[MyPropertyDescriptor]

'!' @ [181:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'tryResolveReference' @ [181:22] ==> local final fun tryResolveReference(reference: PsiQualifiedReference): Boolean defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences[SimpleFunctionDescriptorImpl]

'reference' @ [181:42] ==> val reference: PsiQualifiedReference defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.<anonymous>.<anonymous>[LocalVariableDescriptor]

'failedToResolveReferenceNames' @ [181:54] ==> private final val failedToResolveReferenceNames: HashSet<String> defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver[PropertyDescriptorImpl]

'reference' @ [181:87] ==> val reference: PsiQualifiedReference defined in org.jetbrains.kotlin.idea.conversion.copy.PlainTextPasteImportResolver.tryResolveReferences.<anonymous>.<anonymous>[LocalVariableDescriptor]

'referenceName' @ [181:97] ==> public final val PsiQualifiedReference.referenceName: String?[MyPropertyDescriptor]

