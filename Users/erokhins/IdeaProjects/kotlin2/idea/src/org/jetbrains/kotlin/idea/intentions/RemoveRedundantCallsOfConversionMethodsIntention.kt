'IntentionBasedInspection<KtQualifiedExpression>' @ [31:59] ==> public constructor IntentionBasedInspection<TElement : PsiElement>(intention: KClass<out SelfTargetingRangeIntention<KtQualifiedExpression>>, problemText: String? = ...) defined in org.jetbrains.kotlin.idea.inspections.IntentionBasedInspection[DeserializedClassConstructorDescriptor]
Inferred types:
    <TElement : PsiElement> -> KtQualifiedExpression

'RemoveRedundantCallsOfConversionMethodsIntention' @ [32:9] ==> public constructor RemoveRedundantCallsOfConversionMethodsIntention() defined in org.jetbrains.kotlin.idea.intentions.RemoveRedundantCallsOfConversionMethodsIntention[ClassConstructorDescriptorImpl]

'LIKE_UNUSED_SYMBOL' @ [34:94] ==> enum entry LIKE_UNUSED_SYMBOL defined in com.intellij.codeInspection.ProblemHighlightType[FakeCallableDescriptorForObject]

'SelfTargetingRangeIntention<KtQualifiedExpression>' @ [37:58] ==> public constructor SelfTargetingRangeIntention<TElement : PsiElement>(elementType: Class<KtQualifiedExpression>, text: String, familyName: String = ...) defined in org.jetbrains.kotlin.idea.intentions.SelfTargetingRangeIntention[DeserializedClassConstructorDescriptor]
Inferred types:
    <TElement : PsiElement> -> KtQualifiedExpression

'java' @ [37:138] ==> public val <T> KClass<KtQualifiedExpression>.java: Class<KtQualifiedExpression> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtQualifiedExpression

'mapOf' @ [39:34] ==> public fun <K, V> mapOf(vararg pairs: Pair<String, String?>): Map<String, String?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> String
    <V> -> String?

'to' @ [39:40] ==> public infix fun <A, B> String.to(that: String?): Pair<String, String?> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> String?

'String' @ [39:56] ==> public companion object defined in kotlin.String[FakeCallableDescriptorForObject]

'qualifiedName' @ [39:70] ==> public abstract val qualifiedName: String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor]

'to' @ [40:40] ==> public infix fun <A, B> String.to(that: String?): Pair<String, String?> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> String?

'Double' @ [40:56] ==> public companion object defined in kotlin.Double[FakeCallableDescriptorForObject]

'qualifiedName' @ [40:70] ==> public abstract val qualifiedName: String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor]

'to' @ [41:40] ==> public infix fun <A, B> String.to(that: String?): Pair<String, String?> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> String?

'Float' @ [41:55] ==> public companion object defined in kotlin.Float[FakeCallableDescriptorForObject]

'qualifiedName' @ [41:68] ==> public abstract val qualifiedName: String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor]

'to' @ [42:40] ==> public infix fun <A, B> String.to(that: String?): Pair<String, String?> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> String?

'Long' @ [42:54] ==> public companion object defined in kotlin.Long[FakeCallableDescriptorForObject]

'qualifiedName' @ [42:66] ==> public abstract val qualifiedName: String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor]

'to' @ [43:40] ==> public infix fun <A, B> String.to(that: String?): Pair<String, String?> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> String?

'Int' @ [43:53] ==> public companion object defined in kotlin.Int[FakeCallableDescriptorForObject]

'qualifiedName' @ [43:64] ==> public abstract val qualifiedName: String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor]

'to' @ [44:40] ==> public infix fun <A, B> String.to(that: String?): Pair<String, String?> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> String?

'Char' @ [44:54] ==> public companion object defined in kotlin.Char[FakeCallableDescriptorForObject]

'qualifiedName' @ [44:66] ==> public abstract val qualifiedName: String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor]

'to' @ [45:40] ==> public infix fun <A, B> String.to(that: String?): Pair<String, String?> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> String?

'Short' @ [45:55] ==> public companion object defined in kotlin.Short[FakeCallableDescriptorForObject]

'qualifiedName' @ [45:68] ==> public abstract val qualifiedName: String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor]

'to' @ [46:40] ==> public infix fun <A, B> String.to(that: String?): Pair<String, String?> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> String?

'Byte' @ [46:54] ==> public companion object defined in kotlin.Byte[FakeCallableDescriptorForObject]

'qualifiedName' @ [46:66] ==> public abstract val qualifiedName: String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor]

'element' @ [50:9] ==> value-parameter element: KtQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveRedundantCallsOfConversionMethodsIntention.applyTo[ValueParameterDescriptorImpl]

'replaced' @ [50:17] ==> public inline fun <reified T : PsiElement> PsiElement.replaced(newElement: KtExpression): KtExpression defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtExpression

'element' @ [50:26] ==> value-parameter element: KtQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveRedundantCallsOfConversionMethodsIntention.applyTo[ValueParameterDescriptorImpl]

'receiverExpression' @ [50:34] ==> public open val receiverExpression: KtExpression defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[DeserializedPropertyDescriptor]

'element' @ [54:34] ==> value-parameter element: KtQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveRedundantCallsOfConversionMethodsIntention.applicabilityRange[ValueParameterDescriptorImpl]

'selectorExpression' @ [54:42] ==> public open val selectorExpression: KtExpression? defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[DeserializedPropertyDescriptor]

'selectorExpression' @ [55:38] ==> val selectorExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveRedundantCallsOfConversionMethodsIntention.applicabilityRange[LocalVariableDescriptor]

'text' @ [55:57] ==> public final val KtExpression.text: (String..String?)[MyPropertyDescriptor]

'targetClassMap' @ [56:29] ==> private final val targetClassMap: Map<String, String?> defined in org.jetbrains.kotlin.idea.intentions.RemoveRedundantCallsOfConversionMethodsIntention[PropertyDescriptorImpl]

'selectorExpressionText' @ [56:44] ==> val selectorExpressionText: (String..String?) defined in org.jetbrains.kotlin.idea.intentions.RemoveRedundantCallsOfConversionMethodsIntention.applicabilityRange[LocalVariableDescriptor]

'if(element.receiverExpression.isApplicableReceiverExpression(qualifiedName)) {
            selectorExpression.textRange
        }
        else {
            null
        }' @ [57:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: TextRange?, elseBranch: TextRange?): TextRange?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> TextRange?

'element' @ [57:19] ==> value-parameter element: KtQualifiedExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveRedundantCallsOfConversionMethodsIntention.applicabilityRange[ValueParameterDescriptorImpl]

'receiverExpression' @ [57:27] ==> public open val receiverExpression: KtExpression defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[DeserializedPropertyDescriptor]

'isApplicableReceiverExpression' @ [57:46] ==> private final fun KtExpression.isApplicableReceiverExpression(qualifiedName: String): Boolean defined in org.jetbrains.kotlin.idea.intentions.RemoveRedundantCallsOfConversionMethodsIntention[SimpleFunctionDescriptorImpl]

'qualifiedName' @ [57:77] ==> val qualifiedName: String defined in org.jetbrains.kotlin.idea.intentions.RemoveRedundantCallsOfConversionMethodsIntention.applicabilityRange[LocalVariableDescriptor]

'selectorExpression' @ [58:13] ==> val selectorExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveRedundantCallsOfConversionMethodsIntention.applicabilityRange[LocalVariableDescriptor]

'textRange' @ [58:32] ==> public final val KtExpression.textRange: (TextRange..TextRange?)[MyPropertyDescriptor]

'when (this) {
            is KtStringTemplateExpression -> String::class.qualifiedName
            is KtConstantExpression -> getType(analyze())?.getJetTypeFqName(false)
            else -> {
                getResolvedCall(analyze())?.candidateDescriptor?.returnType?.let {
                    if (it.isFlexible()) null
                    else if (it.isMarkedNullable && parent !is KtSafeQualifiedExpression) null
                    else it.getJetTypeFqName(false)
                }
            }
        }' @ [66:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: String?, entry1: String?, entry2: String?): String?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> String?

'this' @ [66:22] ==> <this> defined in org.jetbrains.kotlin.idea.intentions.RemoveRedundantCallsOfConversionMethodsIntention.isApplicableReceiverExpression[ReceiverParameterDescriptorImpl]

'String' @ [67:46] ==> public companion object defined in kotlin.String[FakeCallableDescriptorForObject]

'qualifiedName' @ [67:60] ==> public abstract val qualifiedName: String? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor]

'getType' @ [68:40] ==> public fun KtExpression.getType(context: BindingContext): KotlinType? defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'analyze' @ [68:48] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'getJetTypeFqName' @ [68:60] ==> public fun KotlinType.getJetTypeFqName(printTypeArguments: Boolean): String defined in org.jetbrains.kotlin.js.descriptorUtils[DeserializedSimpleFunctionDescriptor]

'getResolvedCall' @ [70:17] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'analyze' @ [70:33] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'candidateDescriptor' @ [70:45] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.candidateDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out CallableDescriptor)

'returnType' @ [70:66] ==> public final val CallableDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'let' @ [70:78] ==> @InlineOnly public inline fun <T, R> KotlinType.let(block: (KotlinType) -> String?): String? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType
    <R> -> String?

'if (it.isFlexible()) null
                    else if (it.isMarkedNullable && parent !is KtSafeQualifiedExpression) null
                    else it.getJetTypeFqName(false)' @ [71:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String?, elseBranch: String?): String?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String?

'it' @ [71:25] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.idea.intentions.RemoveRedundantCallsOfConversionMethodsIntention.isApplicableReceiverExpression.<anonymous>[ValueParameterDescriptorImpl]

'isFlexible' @ [71:28] ==> public fun KotlinType.isFlexible(): Boolean defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'if (it.isMarkedNullable && parent !is KtSafeQualifiedExpression) null
                    else it.getJetTypeFqName(false)' @ [72:26] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String?, elseBranch: String?): String?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String?

'it' @ [72:30] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.idea.intentions.RemoveRedundantCallsOfConversionMethodsIntention.isApplicableReceiverExpression.<anonymous>[ValueParameterDescriptorImpl]

'isMarkedNullable' @ [72:33] ==> public abstract val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'parent' @ [72:53] ==> public final val KtExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'it' @ [73:26] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.idea.intentions.RemoveRedundantCallsOfConversionMethodsIntention.isApplicableReceiverExpression.<anonymous>[ValueParameterDescriptorImpl]

'getJetTypeFqName' @ [73:29] ==> public fun KotlinType.getJetTypeFqName(printTypeArguments: Boolean): String defined in org.jetbrains.kotlin.js.descriptorUtils[DeserializedSimpleFunctionDescriptor]

'qualifiedName' @ [76:14] ==> value-parameter qualifiedName: String defined in org.jetbrains.kotlin.idea.intentions.RemoveRedundantCallsOfConversionMethodsIntention.isApplicableReceiverExpression[ValueParameterDescriptorImpl]

