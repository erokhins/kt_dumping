'PsiElementRenameHandler' @ [40:30] ==> public constructor PsiElementRenameHandler() defined in com.intellij.refactoring.rename.PsiElementRenameHandler[JavaClassConstructorDescriptor]

'?:' @ [42:21] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: Caret?, right: Caret): Caret[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> Caret

'CARET' @ [42:36] ==> public final val CARET: (DataKey<(Caret..Caret?)>..DataKey<(Caret..Caret?)>?) defined in com.intellij.openapi.actionSystem.CommonDataKeys[JavaPropertyDescriptor]

'getData' @ [42:42] ==> @Nullable public open fun getData(@NotNull p0: DataContext): Caret? defined in com.intellij.openapi.actionSystem.DataKey[JavaMethodDescriptor]

'dataContext' @ [42:50] ==> value-parameter dataContext: DataContext defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.getStringTemplate[ValueParameterDescriptorImpl]

'?:' @ [43:22] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtFile?, right: KtFile): KtFile[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtFile

'PSI_FILE' @ [43:37] ==> public final val PSI_FILE: (DataKey<(PsiFile..PsiFile?)>..DataKey<(PsiFile..PsiFile?)>?) defined in com.intellij.openapi.actionSystem.CommonDataKeys[JavaPropertyDescriptor]

'getData' @ [43:46] ==> @Nullable public open fun getData(@NotNull p0: DataContext): PsiFile? defined in com.intellij.openapi.actionSystem.DataKey[JavaMethodDescriptor]

'dataContext' @ [43:54] ==> value-parameter dataContext: DataContext defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.getStringTemplate[ValueParameterDescriptorImpl]

'ktFile' @ [44:16] ==> val ktFile: KtFile defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.getStringTemplate[LocalVariableDescriptor]

'findElementAt' @ [44:23] ==> public open fun findElementAt(p0: Int): PsiElement? defined in org.jetbrains.kotlin.psi.KtFile[JavaMethodDescriptor]

'caret' @ [44:37] ==> val caret: Caret defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.getStringTemplate[LocalVariableDescriptor]

'offset' @ [44:43] ==> public final val Caret.offset: Int[MyPropertyDescriptor]

'getNonStrictParentOfType' @ [44:52] ==> public inline fun <reified T : PsiElement> PsiElement.getNonStrictParentOfType(): KtStringTemplateExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtStringTemplateExpression

'getStringTemplate' @ [48:30] ==> private final fun getStringTemplate(dataContext: DataContext): KtStringTemplateExpression? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler[SimpleFunctionDescriptorImpl]

'dataContext' @ [48:48] ==> value-parameter dataContext: DataContext defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.isAvailableOnDataContext[ValueParameterDescriptorImpl]

'!' @ [49:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'nameExpression' @ [49:14] ==> val nameExpression: KtStringTemplateExpression defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.isAvailableOnDataContext[LocalVariableDescriptor]

'isPlain' @ [49:29] ==> public fun KtStringTemplateExpression.isPlain(): Boolean defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'?:' @ [50:21] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtAnnotationEntry?, right: KtAnnotationEntry): KtAnnotationEntry[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtAnnotationEntry

'nameExpression' @ [50:23] ==> val nameExpression: KtStringTemplateExpression defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.isAvailableOnDataContext[LocalVariableDescriptor]

'parent' @ [50:38] ==> public final val KtStringTemplateExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [50:67] ==> public final val KtValueArgument.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [50:100] ==> public final val KtValueArgumentList.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'entry' @ [52:30] ==> val entry: KtAnnotationEntry defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.isAvailableOnDataContext[LocalVariableDescriptor]

'analyze' @ [52:36] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'PARTIAL' @ [52:60] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'TYPE' @ [52:84] ==> public final val TYPE: (WritableSlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>..WritableSlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'entry' @ [52:90] ==> val entry: KtAnnotationEntry defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.isAvailableOnDataContext[LocalVariableDescriptor]

'typeReference' @ [52:96] ==> public final val KtAnnotationEntry.typeReference: KtTypeReference?[MyPropertyDescriptor]

'annotationType' @ [54:16] ==> val annotationType: KotlinType defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.isAvailableOnDataContext[LocalVariableDescriptor]

'constructor' @ [54:31] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'declarationDescriptor' @ [54:43] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'importableFqName' @ [54:66] ==> public val DeclarationDescriptor.importableFqName: FqName? defined in org.jetbrains.kotlin.idea.imports[DeserializedPropertyDescriptor]

'JVM_NAME' @ [54:102] ==> public final val JVM_NAME: (FqName..FqName?) defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaPropertyDescriptor]

'getStringTemplate' @ [58:30] ==> private final fun getStringTemplate(dataContext: DataContext): KtStringTemplateExpression? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler[SimpleFunctionDescriptorImpl]

'dataContext' @ [58:48] ==> value-parameter dataContext: DataContext defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.wrapDataContext[ValueParameterDescriptorImpl]

'nameExpression' @ [59:20] ==> val nameExpression: KtStringTemplateExpression defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.wrapDataContext[LocalVariableDescriptor]

'plainContent' @ [59:35] ==> public val KtStringTemplateExpression.plainContent: String defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'nameExpression' @ [60:21] ==> val nameExpression: KtStringTemplateExpression defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.wrapDataContext[LocalVariableDescriptor]

'getStrictParentOfType' @ [60:36] ==> public inline fun <reified T : PsiElement> PsiElement.getStrictParentOfType(): KtAnnotationEntry? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtAnnotationEntry

'getParentOfType' @ [61:42] ==> @SafeVarargs @Nullable @Contract public open fun <T : (PsiElement..PsiElement?)> getParentOfType(@Nullable p0: PsiElement?, @NotNull vararg p1: (Class<out ({KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)> & KtAnnotationsContainer}..{KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)> & KtAnnotationsContainer}..{KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)>? & KtAnnotationsContainer?})>?)> & KtAnnotationsContainer}..{KtAnnotationsContainer? & KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)> & KtAnnotationsContainer}..{KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)> & KtAnnotationsContainer}..{KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)>? & KtAnnotationsContainer?})>?)>?})>..Class<out ({KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)> & KtAnnotationsContainer}..{KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)> & KtAnnotationsContainer}..{KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)>? & KtAnnotationsContainer?})>?)> & KtAnnotationsContainer}..{KtAnnotationsContainer? & KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)> & KtAnnotationsContainer}..{KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)> & KtAnnotationsContainer}..{KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)>? & KtAnnotationsContainer?})>?)>?})>?)): {KtAnnotationsContainer? & KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)> & KtAnnotationsContainer}..{KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)> & KtAnnotationsContainer}..{KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)>? & KtAnnotationsContainer?})>?)>?} defined in com.intellij.psi.util.PsiTreeUtil[JavaMethodDescriptor]
Inferred types:
    <T : (PsiElement..PsiElement?)> -> {KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)> & KtAnnotationsContainer}..{KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)> & KtAnnotationsContainer}..{KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)>? & KtAnnotationsContainer?})>?)> & KtAnnotationsContainer}

'entry' @ [61:58] ==> val entry: KtAnnotationEntry defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.wrapDataContext[LocalVariableDescriptor]

'java' @ [61:87] ==> public val <T> KClass<KtModifierList>.java: Class<KtModifierList> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtModifierList

'java' @ [61:121] ==> public val <T> KClass<KtFileAnnotationList>.java: Class<KtFileAnnotationList> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtFileAnnotationList

'when (annotationList) {
            is KtModifierList ->
                (annotationList.parent as? KtDeclaration)?.toLightMethods()?.firstOrNull { it.name == name } ?: return null

            is KtFileAnnotationList -> annotationList.getContainingKtFile().findFacadeClass() ?: return null

            else -> return null
        }' @ [62:26] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: {PsiTypeParameterListOwner & PsiTarget & PsiNameIdentifierOwner & PsiDocCommentOwner & PomRenameableTarget<(com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)>}, entry1: {PsiTypeParameterListOwner & PsiTarget & PsiNameIdentifierOwner & PsiDocCommentOwner & PomRenameableTarget<(com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)>}, entry2: {PsiTypeParameterListOwner & PsiTarget & PsiNameIdentifierOwner & PsiDocCommentOwner & PomRenameableTarget<(com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)>}): {PsiTypeParameterListOwner & PsiTarget & PsiNameIdentifierOwner & PsiDocCommentOwner & PomRenameableTarget<(com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)>}[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> {PsiTypeParameterListOwner & PsiTarget & PsiNameIdentifierOwner & PsiDocCommentOwner & PomRenameableTarget<(com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)>}

'annotationList' @ [62:32] ==> val annotationList: {KtAnnotationsContainer? & KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)> & KtAnnotationsContainer}..{KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)> & KtAnnotationsContainer}..{KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)>? & KtAnnotationsContainer?})>?)>?} defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.wrapDataContext[LocalVariableDescriptor]

'?:' @ [64:17] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: PsiMethod?, right: PsiMethod): PsiMethod[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> PsiMethod

'annotationList' @ [64:18] ==> val annotationList: {KtAnnotationsContainer? & KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)> & KtAnnotationsContainer}..{KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)> & KtAnnotationsContainer}..{KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)>? & KtAnnotationsContainer?})>?)>?} defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.wrapDataContext[LocalVariableDescriptor]

'parent' @ [64:33] ==> public final val KtModifierList.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'toLightMethods' @ [64:60] ==> public fun PsiElement.toLightMethods(): List<PsiMethod> defined in org.jetbrains.kotlin.asJava[DeserializedSimpleFunctionDescriptor]

'firstOrNull' @ [64:78] ==> public inline fun <T> Iterable<PsiMethod>.firstOrNull(predicate: (PsiMethod) -> Boolean): PsiMethod? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiMethod

'it' @ [64:92] ==> value-parameter it: PsiMethod defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.wrapDataContext.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [64:95] ==> public final var PsiMethod.name: String[MyPropertyDescriptor]

'name' @ [64:103] ==> val name: String defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.wrapDataContext[LocalVariableDescriptor]

'annotationList' @ [66:40] ==> val annotationList: {KtAnnotationsContainer? & KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)> & KtAnnotationsContainer}..{KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)> & KtAnnotationsContainer}..{KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>..com.intellij.psi.stubs.StubElement<out ({KtElementImplStub<out Any?> & KtAnnotationsContainer}..{KtElementImplStub<out Any?>? & KtAnnotationsContainer?})>?)>? & KtAnnotationsContainer?})>?)>?} defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.wrapDataContext[LocalVariableDescriptor]

'getContainingKtFile' @ [66:55] ==> @NotNull public open fun getContainingKtFile(): KtFile defined in org.jetbrains.kotlin.psi.KtElementImplStub[JavaMethodDescriptor]

'findFacadeClass' @ [66:77] ==> public fun KtFile.findFacadeClass(): KtLightClass? defined in org.jetbrains.kotlin.asJava[DeserializedSimpleFunctionDescriptor]

'DataContext' @ [70:16] ==> public fun DataContext(function: ((String..String?)) -> Any?): DataContext defined in com.intellij.openapi.actionSystem[SimpleFunctionDescriptorImpl]

'PSI_ELEMENT' @ [71:32] ==> public final val PSI_ELEMENT: (DataKey<(PsiElement..PsiElement?)>..DataKey<(PsiElement..PsiElement?)>?) defined in com.intellij.openapi.actionSystem.CommonDataKeys[JavaPropertyDescriptor]

'`is`' @ [71:44] ==> public final fun `is`(p0: (String..String?)): Boolean defined in com.intellij.openapi.actionSystem.DataKey[JavaMethodDescriptor]

'id' @ [71:49] ==> value-parameter id: (String..String?) defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.wrapDataContext.<anonymous>[ValueParameterDescriptorImpl]

'newElement' @ [71:73] ==> val newElement: {PsiTypeParameterListOwner & PsiTarget & PsiNameIdentifierOwner & PsiDocCommentOwner & PomRenameableTarget<(com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)>} defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.wrapDataContext[LocalVariableDescriptor]

'dataContext' @ [72:13] ==> value-parameter dataContext: DataContext defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.wrapDataContext[ValueParameterDescriptorImpl]

'getData' @ [72:25] ==> @Nullable public abstract fun getData(@NonNls p0: (String..String?)): Any? defined in com.intellij.openapi.actionSystem.DataContext[JavaMethodDescriptor]

'id' @ [72:33] ==> value-parameter id: (String..String?) defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.wrapDataContext.<anonymous>[ValueParameterDescriptorImpl]

'super' @ [77:9] ==> <this> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler[LazyClassReceiverParameterDescriptor]

'invoke' @ [77:15] ==> public open fun invoke(@NotNull p0: Project, p1: (Editor..Editor?), p2: (PsiFile..PsiFile?), p3: (DataContext..DataContext?)): Unit defined in com.intellij.refactoring.rename.PsiElementRenameHandler[JavaMethodDescriptor]

'project' @ [77:22] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.invoke[ValueParameterDescriptorImpl]

'editor' @ [77:31] ==> value-parameter editor: Editor defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.invoke[ValueParameterDescriptorImpl]

'file' @ [77:39] ==> value-parameter file: PsiFile defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.invoke[ValueParameterDescriptorImpl]

'wrapDataContext' @ [77:45] ==> private final fun wrapDataContext(dataContext: DataContext): DataContext? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler[SimpleFunctionDescriptorImpl]

'dataContext' @ [77:61] ==> value-parameter dataContext: DataContext defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.invoke[ValueParameterDescriptorImpl]

'super' @ [81:9] ==> <this> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler[LazyClassReceiverParameterDescriptor]

'invoke' @ [81:15] ==> public open fun invoke(@NotNull p0: Project, @NotNull p1: (Array<(PsiElement..PsiElement?)>..Array<out (PsiElement..PsiElement?)>), p2: (DataContext..DataContext?)): Unit defined in com.intellij.refactoring.rename.PsiElementRenameHandler[JavaMethodDescriptor]

'project' @ [81:22] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.invoke[ValueParameterDescriptorImpl]

'elements' @ [81:31] ==> value-parameter elements: Array<out PsiElement> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.invoke[ValueParameterDescriptorImpl]

'wrapDataContext' @ [81:41] ==> private final fun wrapDataContext(dataContext: DataContext): DataContext? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler[SimpleFunctionDescriptorImpl]

'dataContext' @ [81:57] ==> value-parameter dataContext: DataContext defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameJvmNameHandler.invoke[ValueParameterDescriptorImpl]

