'IntentionBasedInspection<KtTypeArgumentList>' @ [45:47] ==> public constructor IntentionBasedInspection<TElement : PsiElement>(intention: KClass<out SelfTargetingRangeIntention<KtTypeArgumentList>>, problemText: String? = ...) defined in org.jetbrains.kotlin.idea.inspections.IntentionBasedInspection[DeserializedClassConstructorDescriptor]
Inferred types:
    <TElement : PsiElement> -> KtTypeArgumentList

'RemoveExplicitTypeArgumentsIntention' @ [45:92] ==> public companion object defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention[FakeCallableDescriptorForObject]

'LIKE_UNUSED_SYMBOL' @ [47:34] ==> enum entry LIKE_UNUSED_SYMBOL defined in com.intellij.codeInspection.ProblemHighlightType[FakeCallableDescriptorForObject]

'SelfTargetingOffsetIndependentIntention<KtTypeArgumentList>' @ [50:46] ==> public constructor SelfTargetingOffsetIndependentIntention<TElement : KtElement>(elementType: Class<KtTypeArgumentList>, text: String, familyName: String = ...) defined in org.jetbrains.kotlin.idea.intentions.SelfTargetingOffsetIndependentIntention[DeserializedClassConstructorDescriptor]
Inferred types:
    <TElement : KtElement> -> KtTypeArgumentList

'java' @ [50:132] ==> public val <T> KClass<KtTypeArgumentList>.java: Class<KtTypeArgumentList> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtTypeArgumentList

'element' @ [54:34] ==> value-parameter element: KtTypeArgumentList defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[ValueParameterDescriptorImpl]

'parent' @ [54:42] ==> public final val KtTypeArgumentList.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'callExpression' @ [55:17] ==> val callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'typeArguments' @ [55:32] ==> public final val KtCallExpression.typeArguments: (MutableList<(KtTypeProjection..KtTypeProjection?)>..List<(KtTypeProjection..KtTypeProjection?)>)[MyPropertyDescriptor]

'isEmpty' @ [55:46] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'callExpression' @ [57:36] ==> val callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'getResolutionFacade' @ [57:51] ==> public fun KtElement.getResolutionFacade(): ResolutionFacade defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'resolutionFacade' @ [58:34] ==> val resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'analyze' @ [58:51] ==> public abstract fun analyze(element: KtElement, bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.resolve.ResolutionFacade[DeserializedSimpleFunctionDescriptor]

'callExpression' @ [58:59] ==> val callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'PARTIAL' @ [58:91] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'callExpression' @ [59:32] ==> val callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'getResolvedCall' @ [59:47] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [59:63] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'component1' @ [61:18] ==> public final operator fun component1(): KtExpression defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [61:37] ==> public final operator fun component2(): KotlinType? defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'findContextToAnalyze' @ [61:53] ==> private final fun findContextToAnalyze(expression: KtExpression, bindingContext: BindingContext): Pair<KtExpression, KotlinType?> defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion[SimpleFunctionDescriptorImpl]

'callExpression' @ [61:74] ==> val callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'bindingContext' @ [61:90] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'contextExpression' @ [62:35] ==> val contextExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'getResolutionScope' @ [62:53] ==> public fun PsiElement.getResolutionScope(bindingContext: BindingContext, resolutionFacade: ResolutionFacade): LexicalScope defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [62:72] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'resolutionFacade' @ [62:88] ==> val resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'Key' @ [64:23] ==> public constructor Key<T : (Any..Any?)>(@NotNull @NonNls p0: String) defined in com.intellij.openapi.util.Key[JavaClassConstructorDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Unit

'callExpression' @ [65:13] ==> val callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'putCopyableUserData' @ [65:28] ==> public open fun <T : (Any..Any?)> putCopyableUserData(@NotNull p0: Key<(Unit..Unit?)>, p1: Unit?): Unit defined in org.jetbrains.kotlin.psi.KtCallExpression[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Unit

'key' @ [65:48] ==> val key: Key<Unit> defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'Unit' @ [65:53] ==> public object Unit defined in kotlin[FakeCallableDescriptorForObject]

'contextExpression' @ [66:39] ==> val contextExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'copied' @ [66:57] ==> public fun <T : PsiElement> KtExpression.copied(): KtExpression defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : PsiElement> -> KtExpression

'callExpression' @ [67:13] ==> val callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'putCopyableUserData' @ [67:28] ==> public open fun <T : (Any..Any?)> putCopyableUserData(@NotNull p0: Key<(Unit..Unit?)>, p1: Unit?): Unit defined in org.jetbrains.kotlin.psi.KtCallExpression[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Unit

'key' @ [67:48] ==> val key: Key<Unit> defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'expressionToAnalyze' @ [69:37] ==> val expressionToAnalyze: KtExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'findDescendantOfType' @ [69:57] ==> public inline fun <reified T : PsiElement> PsiElement.findDescendantOfType(noinline predicate: (KtCallExpression) -> Boolean = ...): KtCallExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtCallExpression

'it' @ [69:98] ==> value-parameter it: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo.<anonymous>[ValueParameterDescriptorImpl]

'getCopyableUserData' @ [69:101] ==> public open fun <T : (Any..Any?)> getCopyableUserData(@NotNull p0: Key<(Unit..Unit?)>): Unit? defined in org.jetbrains.kotlin.psi.KtCallExpression[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Unit

'key' @ [69:121] ==> val key: Key<Unit> defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'newCallExpression' @ [70:13] ==> val newCallExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'typeArgumentList' @ [70:31] ==> public final val KtCallExpression.typeArgumentList: KtTypeArgumentList?[MyPropertyDescriptor]

'delete' @ [70:50] ==> public open fun delete(): Unit defined in org.jetbrains.kotlin.psi.KtTypeArgumentList[JavaMethodDescriptor]

'expressionToAnalyze' @ [72:37] ==> val expressionToAnalyze: KtExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'analyzeInContext' @ [72:57] ==> @JvmOverloads public fun KtExpression.analyzeInContext(scope: LexicalScope, contextExpression: KtExpression = ..., trace: BindingTrace = ..., dataFlowInfo: DataFlowInfo = ..., expectedType: KotlinType = ..., isStatement: Boolean = ..., contextDependency: ContextDependency = ..., expressionTypingServices: ExpressionTypingServices = ...): BindingContext defined in org.jetbrains.kotlin.idea.analysis[DeserializedSimpleFunctionDescriptor]

'resolutionScope' @ [73:21] ==> val resolutionScope: LexicalScope defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'contextExpression' @ [74:21] ==> val contextExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'DelegatingBindingTrace' @ [75:29] ==> public constructor DelegatingBindingTrace(parentContext: BindingContext, name: String, withParentDiagnostics: Boolean = ..., filter: BindingTraceFilter = ..., allowSliceRewrite: Boolean = ...) defined in org.jetbrains.kotlin.resolve.DelegatingBindingTrace[DeserializedClassConstructorDescriptor]

'bindingContext' @ [75:52] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'bindingContext' @ [76:36] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'getDataFlowInfoBefore' @ [76:51] ==> public fun BindingContext.getDataFlowInfoBefore(position: PsiElement): DataFlowInfo defined in org.jetbrains.kotlin.resolve.bindingContextUtil[DeserializedSimpleFunctionDescriptor]

'contextExpression' @ [76:73] ==> val contextExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'expectedType' @ [77:36] ==> val expectedType: KotlinType? defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'NO_EXPECTED_TYPE' @ [77:62] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'contextExpression' @ [78:35] ==> val contextExpression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'isUsedAsStatement' @ [78:53] ==> public fun KtExpression.isUsedAsStatement(context: BindingContext): Boolean defined in org.jetbrains.kotlin.resolve.bindingContextUtil[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [78:71] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'newCallExpression' @ [81:27] ==> val newCallExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'getResolvedCall' @ [81:45] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'newBindingContext' @ [81:61] ==> val newBindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'originalCall' @ [83:24] ==> val originalCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'typeArguments' @ [83:37] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.typeArguments: (MutableMap<(TypeParameterDescriptor..TypeParameterDescriptor?), (KotlinType..KotlinType?)>..Map<(TypeParameterDescriptor..TypeParameterDescriptor?), (KotlinType..KotlinType?)>)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'newCall' @ [84:27] ==> val newCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'typeArguments' @ [84:35] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.typeArguments: (MutableMap<(TypeParameterDescriptor..TypeParameterDescriptor?), (KotlinType..KotlinType?)>..Map<(TypeParameterDescriptor..TypeParameterDescriptor?), (KotlinType..KotlinType?)>)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'if (approximateFlexible) {
                    KotlinTypeChecker.DEFAULT.equalTypes(type1, type2)
                }
                else {
                    type1 == type2
                }' @ [87:24] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Boolean, elseBranch: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Boolean

'approximateFlexible' @ [87:28] ==> value-parameter approximateFlexible: Boolean defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[ValueParameterDescriptorImpl]

'DEFAULT' @ [88:39] ==> public final val DEFAULT: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaPropertyDescriptor]

'equalTypes' @ [88:47] ==> public abstract fun equalTypes(@NotNull p0: KotlinType, @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaMethodDescriptor]

'type1' @ [88:58] ==> value-parameter type1: KotlinType defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo.equalTypes[ValueParameterDescriptorImpl]

'type2' @ [88:65] ==> value-parameter type2: KotlinType defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo.equalTypes[ValueParameterDescriptorImpl]

'type1' @ [91:21] ==> value-parameter type1: KotlinType defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo.equalTypes[ValueParameterDescriptorImpl]

'type2' @ [91:30] ==> value-parameter type2: KotlinType defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo.equalTypes[ValueParameterDescriptorImpl]

'args' @ [95:20] ==> val args: (MutableMap<(TypeParameterDescriptor..TypeParameterDescriptor?), (KotlinType..KotlinType?)>..Map<(TypeParameterDescriptor..TypeParameterDescriptor?), (KotlinType..KotlinType?)>) defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'size' @ [95:25] ==> public abstract val size: Int defined in kotlin.collections.MutableMap[DeserializedPropertyDescriptor]

'newArgs' @ [95:33] ==> val newArgs: (MutableMap<(TypeParameterDescriptor..TypeParameterDescriptor?), (KotlinType..KotlinType?)>..Map<(TypeParameterDescriptor..TypeParameterDescriptor?), (KotlinType..KotlinType?)>) defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'size' @ [95:41] ==> public abstract val size: Int defined in kotlin.collections.MutableMap[DeserializedPropertyDescriptor]

'args' @ [95:49] ==> val args: (MutableMap<(TypeParameterDescriptor..TypeParameterDescriptor?), (KotlinType..KotlinType?)>..Map<(TypeParameterDescriptor..TypeParameterDescriptor?), (KotlinType..KotlinType?)>) defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'values' @ [95:54] ==> public abstract val values: MutableCollection<(KotlinType..KotlinType?)> defined in kotlin.collections.MutableMap[DeserializedPropertyDescriptor]

'zip' @ [95:61] ==> public infix fun <T, R> Iterable<(KotlinType..KotlinType?)>.zip(other: Iterable<(KotlinType..KotlinType?)>): List<Pair<(KotlinType..KotlinType?), (KotlinType..KotlinType?)>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)
    <R> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)

'newArgs' @ [95:65] ==> val newArgs: (MutableMap<(TypeParameterDescriptor..TypeParameterDescriptor?), (KotlinType..KotlinType?)>..Map<(TypeParameterDescriptor..TypeParameterDescriptor?), (KotlinType..KotlinType?)>) defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'values' @ [95:73] ==> public abstract val values: MutableCollection<(KotlinType..KotlinType?)> defined in kotlin.collections.MutableMap[DeserializedPropertyDescriptor]

'all' @ [95:81] ==> public inline fun <T> Iterable<Pair<(KotlinType..KotlinType?), (KotlinType..KotlinType?)>>.all(predicate: (Pair<(KotlinType..KotlinType?), (KotlinType..KotlinType?)>) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<(org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?), (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)>

'component1' @ [95:88] ==> public final operator fun component1(): (KotlinType..KotlinType?) defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [95:97] ==> public final operator fun component2(): (KotlinType..KotlinType?) defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'equalTypes' @ [96:17] ==> local final fun equalTypes(type1: KotlinType, type2: KotlinType): Boolean defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo[SimpleFunctionDescriptorImpl]

'argType' @ [96:28] ==> val argType: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo.<anonymous>[LocalVariableDescriptor]

'newArgType' @ [96:37] ==> val newArgType: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.isApplicableTo.<anonymous>[LocalVariableDescriptor]

'expression' @ [101:29] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[ValueParameterDescriptorImpl]

'parentsWithSelf' @ [101:40] ==> public val PsiElement.parentsWithSelf: Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'element' @ [102:21] ==> val element: PsiElement defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'element' @ [104:21] ==> val element: PsiElement defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'getQualifiedExpressionForSelector' @ [104:29] ==> public fun KtElement.getQualifiedExpressionForSelector(): KtQualifiedExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'element' @ [105:21] ==> val element: PsiElement defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'!' @ [106:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'element' @ [106:22] ==> val element: PsiElement defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'isUsedAsExpression' @ [106:30] ==> public fun KtExpression.isUsedAsExpression(context: BindingContext): Boolean defined in org.jetbrains.kotlin.resolve.bindingContextUtil[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [106:49] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[ValueParameterDescriptorImpl]

'element' @ [106:73] ==> val element: PsiElement defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'element' @ [108:30] ==> val element: PsiElement defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'parent' @ [108:38] ==> public final val KtExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'when (parent) {
                    is KtNamedFunction -> {
                        val expectedType = if (element == parent.bodyExpression && !parent.hasBlockBody() && parent.hasDeclaredReturnType())
                            (bindingContext[BindingContext.DECLARATION_TO_DESCRIPTOR, parent] as? FunctionDescriptor)?.returnType
                        else
                            null
                        return element to expectedType
                    }

                    is KtVariableDeclaration -> {
                        val expectedType = if (element == parent.initializer && parent.typeReference != null)
                            (bindingContext[BindingContext.DECLARATION_TO_DESCRIPTOR, parent] as? ValueDescriptor)?.type
                        else
                            null
                        return element to expectedType
                    }

                    is KtParameter -> {
                        val expectedType = if (element == parent.defaultValue)
                            (bindingContext[BindingContext.DECLARATION_TO_DESCRIPTOR, parent] as? ValueDescriptor)?.type
                        else
                            null
                        return element to expectedType
                    }

                    is KtPropertyAccessor -> {
                        val property = parent.parent as KtProperty
                        val expectedType = when {
                            element != parent.bodyExpression || parent.hasBlockBody() -> null
                            parent.isSetter -> parent.builtIns.unitType
                            property.typeReference == null -> null
                            else -> (bindingContext[BindingContext.DECLARATION_TO_DESCRIPTOR, parent] as? FunctionDescriptor)?.returnType
                        }
                        return element to expectedType
                    }
                }' @ [109:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Nothing, entry1: Nothing, entry2: Nothing, entry3: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Nothing

'parent' @ [109:23] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'if (element == parent.bodyExpression && !parent.hasBlockBody() && parent.hasDeclaredReturnType())
                            (bindingContext[BindingContext.DECLARATION_TO_DESCRIPTOR, parent] as? FunctionDescriptor)?.returnType
                        else
                            null' @ [111:44] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType?, elseBranch: KotlinType?): KotlinType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType?

'element' @ [111:48] ==> val element: PsiElement defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'parent' @ [111:59] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'bodyExpression' @ [111:66] ==> public final val KtNamedFunction.bodyExpression: KtExpression?[MyPropertyDescriptor]

'!' @ [111:84] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'parent' @ [111:85] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'hasBlockBody' @ [111:92] ==> public open fun hasBlockBody(): Boolean defined in org.jetbrains.kotlin.psi.KtNamedFunction[JavaMethodDescriptor]

'parent' @ [111:110] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'hasDeclaredReturnType' @ [111:117] ==> public open fun hasDeclaredReturnType(): Boolean defined in org.jetbrains.kotlin.psi.KtNamedFunction[JavaMethodDescriptor]

'bindingContext' @ [112:30] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[ValueParameterDescriptorImpl]

'DECLARATION_TO_DESCRIPTOR' @ [112:60] ==> public final val DECLARATION_TO_DESCRIPTOR: (ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'parent' @ [112:87] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'returnType' @ [112:120] ==> public final val FunctionDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'element' @ [115:32] ==> val element: PsiElement defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'expectedType' @ [115:43] ==> val expectedType: KotlinType? defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'if (element == parent.initializer && parent.typeReference != null)
                            (bindingContext[BindingContext.DECLARATION_TO_DESCRIPTOR, parent] as? ValueDescriptor)?.type
                        else
                            null' @ [119:44] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType?, elseBranch: KotlinType?): KotlinType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType?

'element' @ [119:48] ==> val element: PsiElement defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'parent' @ [119:59] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'initializer' @ [119:66] ==> public final val KtVariableDeclaration.initializer: KtExpression?[MyPropertyDescriptor]

'parent' @ [119:81] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'typeReference' @ [119:88] ==> public final var KtVariableDeclaration.typeReference: KtTypeReference?[MyPropertyDescriptor]

'bindingContext' @ [120:30] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[ValueParameterDescriptorImpl]

'DECLARATION_TO_DESCRIPTOR' @ [120:60] ==> public final val DECLARATION_TO_DESCRIPTOR: (ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'parent' @ [120:87] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'type' @ [120:117] ==> public final val ValueDescriptor.type: KotlinType[MyPropertyDescriptor]

'element' @ [123:32] ==> val element: PsiElement defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'expectedType' @ [123:43] ==> val expectedType: KotlinType? defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'if (element == parent.defaultValue)
                            (bindingContext[BindingContext.DECLARATION_TO_DESCRIPTOR, parent] as? ValueDescriptor)?.type
                        else
                            null' @ [127:44] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType?, elseBranch: KotlinType?): KotlinType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType?

'element' @ [127:48] ==> val element: PsiElement defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'parent' @ [127:59] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'defaultValue' @ [127:66] ==> public final val KtParameter.defaultValue: KtExpression?[MyPropertyDescriptor]

'bindingContext' @ [128:30] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[ValueParameterDescriptorImpl]

'DECLARATION_TO_DESCRIPTOR' @ [128:60] ==> public final val DECLARATION_TO_DESCRIPTOR: (ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'parent' @ [128:87] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'type' @ [128:117] ==> public final val ValueDescriptor.type: KotlinType[MyPropertyDescriptor]

'element' @ [131:32] ==> val element: PsiElement defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'expectedType' @ [131:43] ==> val expectedType: KotlinType? defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'parent' @ [135:40] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'parent' @ [135:47] ==> public final val KtPropertyAccessor.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'when {
                            element != parent.bodyExpression || parent.hasBlockBody() -> null
                            parent.isSetter -> parent.builtIns.unitType
                            property.typeReference == null -> null
                            else -> (bindingContext[BindingContext.DECLARATION_TO_DESCRIPTOR, parent] as? FunctionDescriptor)?.returnType
                        }' @ [136:44] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KotlinType?, entry1: KotlinType?, entry2: KotlinType?, entry3: KotlinType?): KotlinType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KotlinType?

'element' @ [137:29] ==> val element: PsiElement defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'parent' @ [137:40] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'bodyExpression' @ [137:47] ==> public final val KtPropertyAccessor.bodyExpression: KtExpression?[MyPropertyDescriptor]

'parent' @ [137:65] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'hasBlockBody' @ [137:72] ==> public open fun hasBlockBody(): Boolean defined in org.jetbrains.kotlin.psi.KtPropertyAccessor[JavaMethodDescriptor]

'parent' @ [138:29] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'isSetter' @ [138:36] ==> public final val KtPropertyAccessor.isSetter: Boolean[MyPropertyDescriptor]

'parent' @ [138:48] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'builtIns' @ [138:55] ==> public val KtElement.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.idea.project[DeserializedPropertyDescriptor]

'unitType' @ [138:64] ==> public final val KotlinBuiltIns.unitType: SimpleType[MyPropertyDescriptor]

'property' @ [139:29] ==> val property: KtProperty defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'typeReference' @ [139:38] ==> public final var KtProperty.typeReference: KtTypeReference?[MyPropertyDescriptor]

'bindingContext' @ [140:38] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[ValueParameterDescriptorImpl]

'DECLARATION_TO_DESCRIPTOR' @ [140:68] ==> public final val DECLARATION_TO_DESCRIPTOR: (ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'parent' @ [140:95] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'returnType' @ [140:128] ==> public final val FunctionDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'element' @ [142:32] ==> val element: PsiElement defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'expectedType' @ [142:43] ==> val expectedType: KotlinType? defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[LocalVariableDescriptor]

'expression' @ [147:20] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion.findContextToAnalyze[ValueParameterDescriptorImpl]

'isApplicableTo' @ [152:16] ==> public final fun isApplicableTo(element: KtTypeArgumentList, approximateFlexible: Boolean): Boolean defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion[SimpleFunctionDescriptorImpl]

'element' @ [152:31] ==> value-parameter element: KtTypeArgumentList defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.isApplicableTo[ValueParameterDescriptorImpl]

'element' @ [156:9] ==> value-parameter element: KtTypeArgumentList defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.applyTo[ValueParameterDescriptorImpl]

'delete' @ [156:17] ==> public open fun delete(): Unit defined in org.jetbrains.kotlin.psi.KtTypeArgumentList[JavaMethodDescriptor]

