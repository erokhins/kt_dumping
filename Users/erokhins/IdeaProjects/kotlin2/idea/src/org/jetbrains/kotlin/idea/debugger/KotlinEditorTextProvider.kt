'findExpressionInner' @ [35:26] ==> public final fun findExpressionInner(element: PsiElement, allowMethodCalls: Boolean): KtExpression? defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion[SimpleFunctionDescriptorImpl]

'elementAtCaret' @ [35:46] ==> value-parameter elementAtCaret: PsiElement defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.getEditorText[ValueParameterDescriptorImpl]

'getElementInfo' @ [37:30] ==> public final fun <T> getElementInfo(expr: KtExpression, f: (PsiElement) -> (String..String?)): (String..String?) defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> (kotlin.String..kotlin.String?)

'expression' @ [37:45] ==> val expression: KtExpression defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.getEditorText[LocalVariableDescriptor]

'it' @ [37:59] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.getEditorText.<anonymous>[ValueParameterDescriptorImpl]

'text' @ [37:62] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'TextWithImportsImpl' @ [38:16] ==> public constructor TextWithImportsImpl(p0: (CodeFragmentKind..CodeFragmentKind?), @NotNull p1: String, @NotNull p2: String, @Nullable p3: FileType?) defined in com.intellij.debugger.engine.evaluation.TextWithImportsImpl[JavaClassConstructorDescriptor]

'EXPRESSION' @ [38:53] ==> enum entry EXPRESSION defined in com.intellij.debugger.engine.evaluation.CodeFragmentKind[FakeCallableDescriptorForObject]

'expressionText' @ [38:65] ==> val expressionText: (String..String?) defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.getEditorText[LocalVariableDescriptor]

'INSTANCE' @ [38:100] ==> public final val INSTANCE: (KotlinFileType..KotlinFileType?) defined in org.jetbrains.kotlin.idea.KotlinFileType[JavaPropertyDescriptor]

'findExpressionInner' @ [42:26] ==> public final fun findExpressionInner(element: PsiElement, allowMethodCalls: Boolean): KtExpression? defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion[SimpleFunctionDescriptorImpl]

'elementAtCaret' @ [42:46] ==> value-parameter elementAtCaret: PsiElement defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.findExpression[ValueParameterDescriptorImpl]

'allowMethodCalls' @ [42:62] ==> value-parameter allowMethodCalls: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.findExpression[ValueParameterDescriptorImpl]

'getElementInfo' @ [44:31] ==> public final fun <T> getElementInfo(expr: KtExpression, f: (PsiElement) -> (TextRange..TextRange?)): (TextRange..TextRange?) defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> (com.intellij.openapi.util.TextRange..com.intellij.openapi.util.TextRange?)

'expression' @ [44:46] ==> val expression: KtExpression defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.findExpression[LocalVariableDescriptor]

'it' @ [44:60] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.findExpression.<anonymous>[ValueParameterDescriptorImpl]

'textRange' @ [44:63] ==> public final val PsiElement.textRange: (TextRange..TextRange?)[MyPropertyDescriptor]

'Pair' @ [45:16] ==> public constructor Pair<A : (Any..Any?), B : (Any..Any?)>(p0: (PsiElement..PsiElement?), p1: (TextRange..TextRange?)) defined in com.intellij.openapi.util.Pair[JavaClassConstructorDescriptor]
Inferred types:
    <A : (Any..Any?)> -> PsiElement
    <B : (Any..Any?)> -> TextRange

'expression' @ [45:21] ==> val expression: KtExpression defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.findExpression[LocalVariableDescriptor]

'expressionRange' @ [45:33] ==> val expressionRange: (TextRange..TextRange?) defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.findExpression[LocalVariableDescriptor]

'invoke' @ [51:34] ==> public abstract operator fun invoke(p1: PsiElement): T defined in kotlin.Function1[FunctionInvokeDescriptor]

'expr' @ [51:36] ==> value-parameter expr: KtExpression defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.getElementInfo[ValueParameterDescriptorImpl]

'expr' @ [52:17] ==> value-parameter expr: KtExpression defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.getElementInfo[ValueParameterDescriptorImpl]

'expr' @ [53:38] ==> value-parameter expr: KtExpression defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.getElementInfo[ValueParameterDescriptorImpl]

'nameIdentifier' @ [53:43] ==> public final val KtProperty.nameIdentifier: PsiElement?[MyPropertyDescriptor]

'nameIdentifier' @ [54:21] ==> val nameIdentifier: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.getElementInfo[LocalVariableDescriptor]

'expressionText' @ [55:21] ==> var expressionText: T defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.getElementInfo[LocalVariableDescriptor]

'invoke' @ [55:38] ==> public abstract operator fun invoke(p1: PsiElement): T defined in kotlin.Function1[FunctionInvokeDescriptor]

'nameIdentifier' @ [55:40] ==> val nameIdentifier: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.getElementInfo[LocalVariableDescriptor]

'expressionText' @ [58:20] ==> var expressionText: T defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.getElementInfo[LocalVariableDescriptor]

'!' @ [62:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isAcceptedAsCodeFragmentContext' @ [62:18] ==> public final fun isAcceptedAsCodeFragmentContext(element: PsiElement): Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion[SimpleFunctionDescriptorImpl]

'element' @ [62:50] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[ValueParameterDescriptorImpl]

'?:' @ [64:29] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtElement?, right: KtElement): KtElement[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtElement

'getParentOfType' @ [64:41] ==> @Nullable @Contract public open fun <T : (PsiElement..PsiElement?)> getParentOfType(@Nullable p0: PsiElement?, @NotNull p1: Class<(KtElement..KtElement?)>): KtElement? defined in com.intellij.psi.util.PsiTreeUtil[JavaMethodDescriptor]
Inferred types:
    <T : (PsiElement..PsiElement?)> -> (org.jetbrains.kotlin.psi.KtElement..org.jetbrains.kotlin.psi.KtElement?)

'element' @ [64:57] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[ValueParameterDescriptorImpl]

'java' @ [64:83] ==> public val <T> KClass<KtElement>.java: Class<KtElement> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtElement

'ktElement' @ [66:17] ==> val ktElement: KtElement defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'ktElement' @ [67:38] ==> val ktElement: KtElement defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'nameIdentifier' @ [67:48] ==> public final val KtProperty.nameIdentifier: PsiElement?[MyPropertyDescriptor]

'nameIdentifier' @ [68:21] ==> val nameIdentifier: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'element' @ [68:39] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[ValueParameterDescriptorImpl]

'ktElement' @ [69:28] ==> val ktElement: KtElement defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'ktElement' @ [73:26] ==> val ktElement: KtElement defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'parent' @ [73:36] ==> public final val KtElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'when (parent) {
                is KtThisExpression -> parent
                is KtSuperExpression -> {
                    val pparent = parent.parent
                    when (pparent) {
                        is KtQualifiedExpression -> pparent
                        else -> parent
                    }
                }
                is KtReferenceExpression -> {
                    val pparent = parent.parent
                    if (pparent is KtQualifiedExpression && pparent.selectorExpression == parent) {
                        pparent
                    }
                    else {
                        parent
                    }
                }
                is KtQualifiedExpression -> {
                    if (parent.receiverExpression != ktElement) {
                        parent
                    }
                    else {
                        null
                    }
                }
                is KtOperationExpression -> {
                    if (parent.operationReference == ktElement) {
                        parent
                    }
                    else {
                        null
                    }
                }
                else -> null
            }' @ [75:33] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KtExpression?, entry1: KtExpression?, entry2: KtExpression?, entry3: KtExpression?, entry4: KtExpression?, entry5: KtExpression?): KtExpression?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KtExpression?

'parent' @ [75:39] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'parent' @ [76:40] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'parent' @ [78:35] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'parent' @ [78:42] ==> public final val KtSuperExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'when (pparent) {
                        is KtQualifiedExpression -> pparent
                        else -> parent
                    }' @ [79:21] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KtExpression, entry1: KtExpression): KtExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KtExpression

'pparent' @ [79:27] ==> val pparent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'pparent' @ [80:53] ==> val pparent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'parent' @ [81:33] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'parent' @ [85:35] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'parent' @ [85:42] ==> public final val KtReferenceExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'if (pparent is KtQualifiedExpression && pparent.selectorExpression == parent) {
                        pparent
                    }
                    else {
                        parent
                    }' @ [86:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtExpression, elseBranch: KtExpression): KtExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtExpression

'pparent' @ [86:25] ==> val pparent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'pparent' @ [86:61] ==> val pparent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'selectorExpression' @ [86:69] ==> public open val selectorExpression: KtExpression? defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[DeserializedPropertyDescriptor]

'parent' @ [86:91] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'pparent' @ [87:25] ==> val pparent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'parent' @ [90:25] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'if (parent.receiverExpression != ktElement) {
                        parent
                    }
                    else {
                        null
                    }' @ [94:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtQualifiedExpression?, elseBranch: KtQualifiedExpression?): KtQualifiedExpression?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtQualifiedExpression?

'parent' @ [94:25] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'receiverExpression' @ [94:32] ==> public open val receiverExpression: KtExpression defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[DeserializedPropertyDescriptor]

'ktElement' @ [94:54] ==> val ktElement: KtElement defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'parent' @ [95:25] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'if (parent.operationReference == ktElement) {
                        parent
                    }
                    else {
                        null
                    }' @ [102:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtOperationExpression?, elseBranch: KtOperationExpression?): KtOperationExpression?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtOperationExpression?

'parent' @ [102:25] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'operationReference' @ [102:32] ==> public final val KtOperationExpression.operationReference: KtSimpleNameExpression[MyPropertyDescriptor]

'ktElement' @ [102:54] ==> val ktElement: KtElement defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'parent' @ [103:25] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'!' @ [112:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'allowMethodCalls' @ [112:18] ==> value-parameter allowMethodCalls: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[ValueParameterDescriptorImpl]

'newExpression' @ [112:38] ==> val newExpression: KtExpression? defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'this' @ [113:43] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner.isCall[ReceiverParameterDescriptorImpl]

'this' @ [113:71] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner.isCall[ReceiverParameterDescriptorImpl]

'this' @ [113:104] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner.isCall[ReceiverParameterDescriptorImpl]

'newExpression' @ [115:21] ==> val newExpression: KtExpression? defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'isCall' @ [115:35] ==> local final fun PsiElement.isCall(): Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[SimpleFunctionDescriptorImpl]

'newExpression' @ [115:47] ==> val newExpression: KtExpression? defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'newExpression' @ [115:89] ==> val newExpression: KtExpression? defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'selectorExpression' @ [115:103] ==> public open val selectorExpression: KtExpression? defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[DeserializedPropertyDescriptor]

'isCall' @ [115:124] ==> local final fun PsiElement.isCall(): Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[SimpleFunctionDescriptorImpl]

'when {
                newExpression is KtExpression -> newExpression
                ktElement is KtSimpleNameExpression -> {
                    val context = ktElement.analyze()
                    val qualifier = context[BindingContext.QUALIFIER, ktElement]
                    if (qualifier != null && !DescriptorUtils.isObject(qualifier.descriptor)) {
                        null
                    }
                    else {
                        ktElement
                    }
                }
                else -> null
            }' @ [120:20] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KtExpression?, entry1: KtExpression?, entry2: KtExpression?): KtExpression?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KtExpression?

'newExpression' @ [121:17] ==> val newExpression: KtExpression? defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'newExpression' @ [121:50] ==> val newExpression: KtExpression? defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'ktElement' @ [122:17] ==> val ktElement: KtElement defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'ktElement' @ [123:35] ==> val ktElement: KtElement defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'analyze' @ [123:45] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'context' @ [124:37] ==> val context: BindingContext defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'QUALIFIER' @ [124:60] ==> public final val QUALIFIER: (WritableSlice<(KtExpression..KtExpression?), (Qualifier..Qualifier?)>..WritableSlice<(KtExpression..KtExpression?), (Qualifier..Qualifier?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'ktElement' @ [124:71] ==> val ktElement: KtElement defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'if (qualifier != null && !DescriptorUtils.isObject(qualifier.descriptor)) {
                        null
                    }
                    else {
                        ktElement
                    }' @ [125:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtSimpleNameExpression?, elseBranch: KtSimpleNameExpression?): KtSimpleNameExpression?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtSimpleNameExpression?

'qualifier' @ [125:25] ==> val qualifier: Qualifier? defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'!' @ [125:46] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isObject' @ [125:63] ==> public open fun isObject(@Nullable p0: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'qualifier' @ [125:72] ==> val qualifier: Qualifier? defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'descriptor' @ [125:82] ==> public abstract val descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.receivers.Qualifier[DeserializedPropertyDescriptor]

'ktElement' @ [129:25] ==> val ktElement: KtElement defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.findExpressionInner[LocalVariableDescriptor]

'arrayOf' @ [138:17] ==> public inline fun <reified @PureReifiable T> arrayOf(vararg elements: Class<out NavigatablePsiElement>): Array<Class<out NavigatablePsiElement>> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified @PureReifiable T> -> Class<out NavigatablePsiElement>

'java' @ [138:43] ==> public val <T> KClass<KtUserType>.java: Class<KtUserType> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtUserType

'java' @ [138:74] ==> public val <T> KClass<KtImportDirective>.java: Class<KtImportDirective> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtImportDirective

'java' @ [138:106] ==> public val <T> KClass<KtPackageDirective>.java: Class<KtPackageDirective> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtPackageDirective

'KtValueArgumentName' @ [138:112] ==> public constructor KtValueArgumentName(@NotNull p0: ASTNode) defined in org.jetbrains.kotlin.psi.KtValueArgumentName[JavaClassConstructorDescriptor]

'java' @ [138:139] ==> public val <T> KClass<KtValueArgumentName>.java: Class<KtValueArgumentName> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtValueArgumentName

'!' @ [141:20] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'NOT_ACCEPTED_AS_CONTEXT_TYPES' @ [141:21] ==> private final val NOT_ACCEPTED_AS_CONTEXT_TYPES: Array<Class<out NavigatablePsiElement>> defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion[PropertyDescriptorImpl]

'contains' @ [141:51] ==> public operator fun <@OnlyInputTypes T> Array<out Class<out (Any..Any?)>>.contains(element: Class<out (Any..Any?)>): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <@OnlyInputTypes T> -> Class<out (kotlin.Any..kotlin.Any?)>

'element' @ [141:60] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.isAcceptedAsCodeFragmentContext[ValueParameterDescriptorImpl]

'java' @ [141:75] ==> public val <T> KClass<out PsiElement>.java: Class<out PsiElement> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> Captured(out PsiElement)

'==' @ [142:20] ==> public open fun equals(other: Any?): Boolean defined in com.intellij.psi.NavigatablePsiElement[DeserializedSimpleFunctionDescriptor]

'getParentOfType' @ [142:32] ==> @SafeVarargs @Nullable @Contract public open fun <T : (PsiElement..PsiElement?)> getParentOfType(@Nullable p0: PsiElement?, @NotNull vararg p1: (Class<out (NavigatablePsiElement..NavigatablePsiElement?)>..Class<out (NavigatablePsiElement..NavigatablePsiElement?)>?)): NavigatablePsiElement? defined in com.intellij.psi.util.PsiTreeUtil[JavaMethodDescriptor]
Inferred types:
    <T : (PsiElement..PsiElement?)> -> (com.intellij.psi.NavigatablePsiElement..com.intellij.psi.NavigatablePsiElement?)

'element' @ [142:48] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion.isAcceptedAsCodeFragmentContext[ValueParameterDescriptorImpl]

'NOT_ACCEPTED_AS_CONTEXT_TYPES' @ [142:58] ==> private final val NOT_ACCEPTED_AS_CONTEXT_TYPES: Array<Class<out NavigatablePsiElement>> defined in org.jetbrains.kotlin.idea.debugger.KotlinEditorTextProvider.Companion[PropertyDescriptorImpl]

