'RenameKotlinPsiProcessor' @ [68:39] ==> public constructor RenameKotlinPsiProcessor() defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPsiProcessor[ClassConstructorDescriptorImpl]

'element' @ [70:37] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.canProcessElement[ValueParameterDescriptorImpl]

'namedUnwrappedElement' @ [70:45] ==> public val PsiElement.namedUnwrappedElement: PsiNamedElement? defined in org.jetbrains.kotlin.asJava[DeserializedPropertyDescriptor]

'namedUnwrappedElement' @ [71:16] ==> val namedUnwrappedElement: PsiNamedElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.canProcessElement[LocalVariableDescriptor]

'namedUnwrappedElement' @ [71:56] ==> val namedUnwrappedElement: PsiNamedElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.canProcessElement[LocalVariableDescriptor]

'namedUnwrappedElement' @ [71:96] ==> val namedUnwrappedElement: PsiNamedElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.canProcessElement[LocalVariableDescriptor]

'hasValOrVar' @ [71:118] ==> public open fun hasValOrVar(): Boolean defined in org.jetbrains.kotlin.psi.KtParameter[JavaMethodDescriptor]

'getInstance' @ [74:89] ==> public open fun getInstance(): (JavaRefactoringSettings..JavaRefactoringSettings?) defined in com.intellij.refactoring.JavaRefactoringSettings[JavaMethodDescriptor]

'RENAME_SEARCH_IN_COMMENTS_FOR_FIELD' @ [74:103] ==> public final var RENAME_SEARCH_IN_COMMENTS_FOR_FIELD: Boolean defined in com.intellij.refactoring.JavaRefactoringSettings[JavaPropertyDescriptor]

'getInstance' @ [77:33] ==> public open fun getInstance(): (JavaRefactoringSettings..JavaRefactoringSettings?) defined in com.intellij.refactoring.JavaRefactoringSettings[JavaMethodDescriptor]

'RENAME_SEARCH_IN_COMMENTS_FOR_FIELD' @ [77:47] ==> public final var RENAME_SEARCH_IN_COMMENTS_FOR_FIELD: Boolean defined in com.intellij.refactoring.JavaRefactoringSettings[JavaPropertyDescriptor]

'enabled' @ [77:85] ==> value-parameter enabled: Boolean defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.setToSearchInComments[ValueParameterDescriptorImpl]

'getInstance' @ [80:94] ==> public open fun getInstance(): (JavaRefactoringSettings..JavaRefactoringSettings?) defined in com.intellij.refactoring.JavaRefactoringSettings[JavaMethodDescriptor]

'RENAME_SEARCH_FOR_TEXT_FOR_FIELD' @ [80:108] ==> public final var RENAME_SEARCH_FOR_TEXT_FOR_FIELD: Boolean defined in com.intellij.refactoring.JavaRefactoringSettings[JavaPropertyDescriptor]

'getInstance' @ [83:33] ==> public open fun getInstance(): (JavaRefactoringSettings..JavaRefactoringSettings?) defined in com.intellij.refactoring.JavaRefactoringSettings[JavaMethodDescriptor]

'RENAME_SEARCH_FOR_TEXT_FOR_FIELD' @ [83:47] ==> public final var RENAME_SEARCH_FOR_TEXT_FOR_FIELD: Boolean defined in com.intellij.refactoring.JavaRefactoringSettings[JavaPropertyDescriptor]

'enabled' @ [83:82] ==> value-parameter enabled: Boolean defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.setToSearchForTextOccurrences[ValueParameterDescriptorImpl]

'?:' @ [87:26] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: PropertyDescriptor?, right: PropertyDescriptor): PropertyDescriptor[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> PropertyDescriptor

'element' @ [87:27] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.getJvmNames[ValueParameterDescriptorImpl]

'unwrapped' @ [87:35] ==> public val PsiElement.unwrapped: PsiElement? defined in org.jetbrains.kotlin.asJava[DeserializedPropertyDescriptor]

'resolveToDescriptor' @ [87:65] ==> public fun KtDeclaration.resolveToDescriptor(bodyResolveMode: BodyResolveMode = ...): DeclarationDescriptor defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'to' @ [87:120] ==> public infix fun <A, B> Nothing?.to(that: Nothing?): Pair<Nothing?, Nothing?> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Nothing?
    <B> -> Nothing?

'descriptor' @ [88:26] ==> val descriptor: PropertyDescriptor defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.getJvmNames[LocalVariableDescriptor]

'getter' @ [88:37] ==> public abstract val getter: PropertyGetterDescriptor? defined in org.jetbrains.kotlin.descriptors.PropertyDescriptor[JavaPropertyDescriptor]

'let' @ [88:45] ==> @InlineOnly public inline fun <T, R> PropertyGetterDescriptor.let(block: (PropertyGetterDescriptor) -> String?): String? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PropertyGetterDescriptor
    <R> -> String?

'getJvmName' @ [88:67] ==> @Nullable public open fun getJvmName(@NotNull p0: Annotated): String? defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'it' @ [88:78] ==> value-parameter it: PropertyGetterDescriptor defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.getJvmNames.<anonymous>[ValueParameterDescriptorImpl]

'descriptor' @ [89:26] ==> val descriptor: PropertyDescriptor defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.getJvmNames[LocalVariableDescriptor]

'setter' @ [89:37] ==> public abstract val setter: PropertySetterDescriptor? defined in org.jetbrains.kotlin.descriptors.PropertyDescriptor[JavaPropertyDescriptor]

'let' @ [89:45] ==> @InlineOnly public inline fun <T, R> PropertySetterDescriptor.let(block: (PropertySetterDescriptor) -> String?): String? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PropertySetterDescriptor
    <R> -> String?

'getJvmName' @ [89:67] ==> @Nullable public open fun getJvmName(@NotNull p0: Annotated): String? defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'it' @ [89:78] ==> value-parameter it: PropertySetterDescriptor defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.getJvmNames.<anonymous>[ValueParameterDescriptorImpl]

'getterName' @ [90:16] ==> val getterName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.getJvmNames[LocalVariableDescriptor]

'setterName' @ [90:30] ==> val setterName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.getJvmNames[LocalVariableDescriptor]

'super' @ [94:29] ==> <this> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor[LazyClassReceiverParameterDescriptor]

'findReferences' @ [94:35] ==> public open fun findReferences(element: PsiElement): Collection<PsiReference> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPsiProcessor[SimpleFunctionDescriptorImpl]

'element' @ [94:50] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findReferences[ValueParameterDescriptorImpl]

'component1' @ [95:14] ==> public final operator fun component1(): String? defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [95:29] ==> public final operator fun component2(): String? defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'getJvmNames' @ [95:46] ==> private final fun getJvmNames(element: PsiElement): Pair<String?, String?> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor[SimpleFunctionDescriptorImpl]

'element' @ [95:58] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findReferences[ValueParameterDescriptorImpl]

'when {
            getterJvmName == null && setterJvmName == null -> allReferences
            element is KtElement -> allReferences.filter {
                it is KtReference
                || (getterJvmName == null && (it.resolve() as? PsiNamedElement)?.name != setterJvmName)
                || (setterJvmName == null && (it.resolve() as? PsiNamedElement)?.name != getterJvmName)
            }
            element is KtLightDeclaration<*, *> -> {
                val name = element.name
                if (name == getterJvmName || name == setterJvmName) allReferences.filterNot { it is KtReference } else allReferences
            }
            else -> emptyList()
        }' @ [96:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Collection<PsiReference>, entry1: Collection<PsiReference>, entry2: Collection<PsiReference>, entry3: Collection<PsiReference>): Collection<PsiReference>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Collection<PsiReference>

'getterJvmName' @ [97:13] ==> val getterJvmName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findReferences[LocalVariableDescriptor]

'setterJvmName' @ [97:38] ==> val setterJvmName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findReferences[LocalVariableDescriptor]

'allReferences' @ [97:63] ==> val allReferences: Collection<PsiReference> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findReferences[LocalVariableDescriptor]

'element' @ [98:13] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findReferences[ValueParameterDescriptorImpl]

'allReferences' @ [98:37] ==> val allReferences: Collection<PsiReference> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findReferences[LocalVariableDescriptor]

'filter' @ [98:51] ==> public inline fun <T> Iterable<PsiReference>.filter(predicate: (PsiReference) -> Boolean): List<PsiReference> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiReference

'it' @ [99:17] ==> value-parameter it: PsiReference defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findReferences.<anonymous>[ValueParameterDescriptorImpl]

'getterJvmName' @ [100:21] ==> val getterJvmName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findReferences[LocalVariableDescriptor]

'!=' @ [100:46] ==> public open fun equals(other: Any?): Boolean defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'it' @ [100:47] ==> value-parameter it: PsiReference defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findReferences.<anonymous>[ValueParameterDescriptorImpl]

'resolve' @ [100:50] ==> @Nullable public abstract fun resolve(): PsiElement? defined in com.intellij.psi.PsiReference[JavaMethodDescriptor]

'name' @ [100:82] ==> public final val PsiNamedElement.name: String?[MyPropertyDescriptor]

'setterJvmName' @ [100:90] ==> val setterJvmName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findReferences[LocalVariableDescriptor]

'setterJvmName' @ [101:21] ==> val setterJvmName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findReferences[LocalVariableDescriptor]

'!=' @ [101:46] ==> public open fun equals(other: Any?): Boolean defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'it' @ [101:47] ==> value-parameter it: PsiReference defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findReferences.<anonymous>[ValueParameterDescriptorImpl]

'resolve' @ [101:50] ==> @Nullable public abstract fun resolve(): PsiElement? defined in com.intellij.psi.PsiReference[JavaMethodDescriptor]

'name' @ [101:82] ==> public final val PsiNamedElement.name: String?[MyPropertyDescriptor]

'getterJvmName' @ [101:90] ==> val getterJvmName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findReferences[LocalVariableDescriptor]

'element' @ [103:13] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findReferences[ValueParameterDescriptorImpl]

'element' @ [104:28] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findReferences[ValueParameterDescriptorImpl]

'name' @ [104:36] ==> public final val <out T : KtDeclaration, out D : PsiElement> KtLightDeclaration<KtDeclaration, PsiElement>.name: String?[MyPropertyDescriptor]
Inferred types:
    <out T : KtDeclaration> -> KtDeclaration
    <out D : PsiElement> -> PsiElement

'if (name == getterJvmName || name == setterJvmName) allReferences.filterNot { it is KtReference } else allReferences' @ [105:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Collection<PsiReference>, elseBranch: Collection<PsiReference>): Collection<PsiReference>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Collection<PsiReference>

'name' @ [105:21] ==> val name: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findReferences[LocalVariableDescriptor]

'getterJvmName' @ [105:29] ==> val getterJvmName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findReferences[LocalVariableDescriptor]

'name' @ [105:46] ==> val name: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findReferences[LocalVariableDescriptor]

'setterJvmName' @ [105:54] ==> val setterJvmName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findReferences[LocalVariableDescriptor]

'allReferences' @ [105:69] ==> val allReferences: Collection<PsiReference> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findReferences[LocalVariableDescriptor]

'filterNot' @ [105:83] ==> public inline fun <T> Iterable<PsiReference>.filterNot(predicate: (PsiReference) -> Boolean): List<PsiReference> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiReference

'it' @ [105:95] ==> value-parameter it: PsiReference defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findReferences.<anonymous>[ValueParameterDescriptorImpl]

'allReferences' @ [105:120] ==> val allReferences: Collection<PsiReference> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findReferences[LocalVariableDescriptor]

'emptyList' @ [107:21] ==> public fun <T> emptyList(): List<PsiReference> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiReference

'getType' @ [118:38] ==> public open fun getType(@NotNull p0: PsiElement): (String..String?) defined in com.intellij.usageView.UsageViewUtil[JavaMethodDescriptor]

'declaration' @ [118:46] ==> value-parameter declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides[ValueParameterDescriptorImpl]

'capitalize' @ [118:59] ==> public fun String.capitalize(): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'candidate' @ [119:28] ==> value-parameter candidate: PsiNamedElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.reportAccidentalOverride[ValueParameterDescriptorImpl]

'renderDescription' @ [119:38] ==> internal fun PsiNamedElement.renderDescription(): String defined in org.jetbrains.kotlin.idea.refactoring.rename in file renameConflictUtils.kt[SimpleFunctionDescriptorImpl]

'candidate' @ [120:25] ==> value-parameter candidate: PsiNamedElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.reportAccidentalOverride[ValueParameterDescriptorImpl]

'representativeContainer' @ [120:35] ==> internal fun PsiElement.representativeContainer(): PsiNamedElement? defined in org.jetbrains.kotlin.idea.refactoring.rename in file renameConflictUtils.kt[SimpleFunctionDescriptorImpl]

'renderDescription' @ [120:62] ==> internal fun PsiNamedElement.renderDescription(): String defined in org.jetbrains.kotlin.idea.refactoring.rename in file renameConflictUtils.kt[SimpleFunctionDescriptorImpl]

'what' @ [121:29] ==> val what: String defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.reportAccidentalOverride[LocalVariableDescriptor]

'withWhat' @ [121:73] ==> val withWhat: String defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.reportAccidentalOverride[LocalVariableDescriptor]

'where' @ [121:86] ==> val where: String defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.reportAccidentalOverride[LocalVariableDescriptor]

'result' @ [122:13] ==> value-parameter result: MutableList<UsageInfo> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides[ValueParameterDescriptorImpl]

'BasicUnresolvableCollisionUsageInfo' @ [122:23] ==> public constructor BasicUnresolvableCollisionUsageInfo(element: PsiElement, referencedElement: PsiElement, _description: String) defined in org.jetbrains.kotlin.idea.refactoring.rename.BasicUnresolvableCollisionUsageInfo[ClassConstructorDescriptorImpl]

'candidate' @ [122:59] ==> value-parameter candidate: PsiNamedElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.reportAccidentalOverride[ValueParameterDescriptorImpl]

'candidate' @ [122:70] ==> value-parameter candidate: PsiNamedElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.reportAccidentalOverride[ValueParameterDescriptorImpl]

'message' @ [122:81] ==> val message: String defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.reportAccidentalOverride[LocalVariableDescriptor]

'descriptor' @ [125:13] ==> value-parameter descriptor: VariableDescriptor defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides[ValueParameterDescriptorImpl]

'declaration' @ [126:28] ==> value-parameter declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides[ValueParameterDescriptorImpl]

'containingClassOrObject' @ [126:40] ==> public val KtDeclaration.containingClassOrObject: KtClassOrObject? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'descriptor' @ [127:38] ==> value-parameter descriptor: VariableDescriptor defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides[ValueParameterDescriptorImpl]

'containingDeclaration' @ [127:49] ==> public final val PropertyDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'descriptor' @ [129:56] ==> value-parameter descriptor: VariableDescriptor defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides[ValueParameterDescriptorImpl]

'guessByFirstCharacter' @ [130:43] ==> @NotNull public open fun guessByFirstCharacter(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'newName' @ [130:65] ==> value-parameter newName: String defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides[ValueParameterDescriptorImpl]

'dfs' @ [133:13] ==> public open fun <N : (Any..Any?), R : (Any..Any?)> dfs(@NotNull p0: (MutableCollection<(ClassDescriptor..ClassDescriptor?)>..Collection<(ClassDescriptor..ClassDescriptor?)>), @NotNull p1: DFS.Neighbors<(ClassDescriptor..ClassDescriptor?)>, @NotNull p2: DFS.NodeHandler<(ClassDescriptor..ClassDescriptor?), (Unit..Unit?)>): (Unit..Unit?) defined in org.jetbrains.kotlin.utils.DFS[JavaMethodDescriptor]
Inferred types:
    <N : (Any..Any?)> -> (org.jetbrains.kotlin.descriptors.ClassDescriptor..org.jetbrains.kotlin.descriptors.ClassDescriptor?)
    <R : (Any..Any?)> -> (kotlin.Unit..kotlin.Unit?)

'listOf' @ [134:17] ==> public fun <T> listOf(element: ClassDescriptor): List<ClassDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ClassDescriptor

'initialClassDescriptor' @ [134:24] ==> val initialClassDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides[LocalVariableDescriptor]

'Neighbors' @ [135:21] ==> public final fun <N : (Any..Any?)> Neighbors(function: ((ClassDescriptor..ClassDescriptor?)) -> (MutableIterable<(ClassDescriptor..ClassDescriptor?)>..Iterable<(ClassDescriptor..ClassDescriptor?)>)): DFS.Neighbors<ClassDescriptor> defined in org.jetbrains.kotlin.utils.DFS[SimpleFunctionDescriptorImpl]
Inferred types:
    <N : (Any..Any?)> -> ClassDescriptor

'getSuperclassDescriptors' @ [135:66] ==> @NotNull public open fun getSuperclassDescriptors(@NotNull p0: ClassDescriptor): (MutableList<(ClassDescriptor..ClassDescriptor?)>..List<(ClassDescriptor..ClassDescriptor?)>) defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'it' @ [135:91] ==> value-parameter it: (ClassDescriptor..ClassDescriptor?) defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.<anonymous>[ValueParameterDescriptorImpl]

'DFS.AbstractNodeHandler<ClassDescriptor, Unit>' @ [136:26] ==> public constructor AbstractNodeHandler<N : (Any..Any?), R : (Any..Any?)>() defined in org.jetbrains.kotlin.utils.DFS.AbstractNodeHandler[JavaClassConstructorDescriptor]
Inferred types:
    <N : (Any..Any?)> -> ClassDescriptor
    <R : (Any..Any?)> -> Unit

'current' @ [138:29] ==> value-parameter current: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.<no name provided>.beforeChildren[ValueParameterDescriptorImpl]

'initialClassDescriptor' @ [138:40] ==> val initialClassDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides[LocalVariableDescriptor]

'current' @ [139:26] ==> value-parameter current: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.<no name provided>.beforeChildren[ValueParameterDescriptorImpl]

'findCallableMemberBySignature' @ [139:34] ==> public fun ClassDescriptor.findCallableMemberBySignature(signature: CallableMemberDescriptor, allowOverridabilityConflicts: Boolean = ...): CallableMemberDescriptor? defined in org.jetbrains.kotlin.util[DeserializedSimpleFunctionDescriptor]

'prototype' @ [139:64] ==> val prototype: <no name provided> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides[LocalVariableDescriptor]

'let' @ [139:77] ==> @InlineOnly public inline fun <T, R> CallableMemberDescriptor.let(block: (CallableMemberDescriptor) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> CallableMemberDescriptor
    <R> -> Nothing

'candidateDescriptor' @ [140:45] ==> value-parameter candidateDescriptor: CallableMemberDescriptor defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.<no name provided>.beforeChildren.<anonymous>[ValueParameterDescriptorImpl]

'source' @ [140:65] ==> public final val CallableMemberDescriptor.source: SourceElement[MyPropertyDescriptor]

'getPsi' @ [140:72] ==> public fun SourceElement.getPsi(): PsiElement? defined in org.jetbrains.kotlin.resolve.source[DeserializedSimpleFunctionDescriptor]

'reportAccidentalOverride' @ [141:29] ==> local final fun reportAccidentalOverride(candidate: PsiNamedElement): Unit defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides[SimpleFunctionDescriptorImpl]

'candidate' @ [141:54] ==> val candidate: PsiNamedElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.<no name provided>.beforeChildren.<anonymous>[LocalVariableDescriptor]

'!' @ [153:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'declaration' @ [153:14] ==> value-parameter declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides[ValueParameterDescriptorImpl]

'hasModifier' @ [153:26] ==> public abstract fun hasModifier(@NotNull p0: KtModifierKeywordToken): Boolean defined in org.jetbrains.kotlin.psi.KtNamedDeclaration[JavaMethodDescriptor]

'PRIVATE_KEYWORD' @ [153:47] ==> public final val PRIVATE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'initialClass' @ [154:35] ==> val initialClass: KtClassOrObject defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides[LocalVariableDescriptor]

'toLightClass' @ [154:48] ==> public fun KtClassOrObject.toLightClass(): KtLightClass? defined in org.jetbrains.kotlin.asJava[DeserializedSimpleFunctionDescriptor]

'declaration' @ [155:30] ==> value-parameter declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides[ValueParameterDescriptorImpl]

'toLightMethods' @ [155:42] ==> public fun PsiElement.toLightMethods(): List<PsiMethod> defined in org.jetbrains.kotlin.asJava[DeserializedSimpleFunctionDescriptor]

'mapNotNull' @ [155:59] ==> public inline fun <T, R : Any> Iterable<PsiMethod>.mapNotNull(transform: (PsiMethod) -> <no name provided>?): List<<no name provided>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiMethod
    <R : Any> -> <no name provided>

'it' @ [156:17] ==> value-parameter it: PsiMethod defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.<anonymous>[ValueParameterDescriptorImpl]

'accessorNameByPropertyName' @ [157:34] ==> public fun accessorNameByPropertyName(name: String, accessor: KtLightMethod): String? defined in org.jetbrains.kotlin.asJava[DeserializedSimpleFunctionDescriptor]

'newName' @ [157:61] ==> value-parameter newName: String defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides[ValueParameterDescriptorImpl]

'it' @ [157:70] ==> value-parameter it: PsiMethod defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [158:43] ==> value-parameter it: PsiMethod defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.<anonymous>[ValueParameterDescriptorImpl]

'methodName' @ [159:46] ==> val methodName: String defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.<anonymous>[LocalVariableDescriptor]

'dfs' @ [162:17] ==> public open fun <N : (Any..Any?), R : (Any..Any?)> dfs(@NotNull p0: (MutableCollection<(PsiClass..PsiClass?)>..Collection<(PsiClass..PsiClass?)>), @NotNull p1: DFS.Neighbors<(PsiClass..PsiClass?)>, @NotNull p2: DFS.NodeHandler<(PsiClass..PsiClass?), (Unit..Unit?)>): (Unit..Unit?) defined in org.jetbrains.kotlin.utils.DFS[JavaMethodDescriptor]
Inferred types:
    <N : (Any..Any?)> -> (com.intellij.psi.PsiClass..com.intellij.psi.PsiClass?)
    <R : (Any..Any?)> -> (kotlin.Unit..kotlin.Unit?)

'listOf' @ [163:21] ==> public fun <T> listOf(element: KtLightClass): List<KtLightClass> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtLightClass

'initialPsiClass' @ [163:28] ==> val initialPsiClass: KtLightClass defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides[LocalVariableDescriptor]

'Neighbors' @ [164:25] ==> public final fun <N : (Any..Any?)> Neighbors(function: ((PsiClass..PsiClass?)) -> (MutableIterable<(PsiClass..PsiClass?)>..Iterable<(PsiClass..PsiClass?)>)): DFS.Neighbors<PsiClass> defined in org.jetbrains.kotlin.utils.DFS[SimpleFunctionDescriptorImpl]
Inferred types:
    <N : (Any..Any?)> -> PsiClass

'search' @ [164:75] ==> @NotNull public open fun search(@NotNull p0: PsiClass): Query<(PsiClass..PsiClass?)> defined in com.intellij.psi.search.searches.DirectClassInheritorsSearch[JavaMethodDescriptor]

'it' @ [164:82] ==> value-parameter it: (PsiClass..PsiClass?) defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.<anonymous>[ValueParameterDescriptorImpl]

'DFS.AbstractNodeHandler<PsiClass, Unit>' @ [165:30] ==> public constructor AbstractNodeHandler<N : (Any..Any?), R : (Any..Any?)>() defined in org.jetbrains.kotlin.utils.DFS.AbstractNodeHandler[JavaClassConstructorDescriptor]
Inferred types:
    <N : (Any..Any?)> -> PsiClass
    <R : (Any..Any?)> -> Unit

'current' @ [167:33] ==> value-parameter current: PsiClass defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.<no name provided>.beforeChildren[ValueParameterDescriptorImpl]

'initialPsiClass' @ [167:44] ==> val initialPsiClass: KtLightClass defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides[LocalVariableDescriptor]

'current' @ [169:33] ==> value-parameter current: PsiClass defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.<no name provided>.beforeChildren[ValueParameterDescriptorImpl]

'current' @ [170:48] ==> value-parameter current: PsiClass defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.<no name provided>.beforeChildren[ValueParameterDescriptorImpl]

'kotlinOrigin' @ [170:56] ==> public abstract val kotlinOrigin: KtClassOrObject? defined in org.jetbrains.kotlin.asJava.classes.KtLightClass[DeserializedPropertyDescriptor]

'findPropertyByName' @ [170:70] ==> public fun KtClassOrObject.findPropertyByName(name: String): KtNamedDeclaration? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'newName' @ [170:89] ==> value-parameter newName: String defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides[ValueParameterDescriptorImpl]

'reportAccidentalOverride' @ [171:33] ==> local final fun reportAccidentalOverride(candidate: PsiNamedElement): Unit defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides[SimpleFunctionDescriptorImpl]

'property' @ [171:58] ==> val property: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.<no name provided>.beforeChildren[LocalVariableDescriptor]

'prototypes' @ [175:47] ==> val prototypes: List<<no name provided>> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides[LocalVariableDescriptor]

'current' @ [176:33] ==> value-parameter current: PsiClass defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.<no name provided>.beforeChildren[ValueParameterDescriptorImpl]

'findMethodBySignature' @ [176:41] ==> @Nullable public abstract fun findMethodBySignature(p0: (PsiMethod..PsiMethod?), p1: Boolean): PsiMethod? defined in com.intellij.psi.PsiClass[JavaMethodDescriptor]

'psiMethod' @ [176:63] ==> val psiMethod: <no name provided> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.<no name provided>.beforeChildren[LocalVariableDescriptor]

'let' @ [176:82] ==> @InlineOnly public inline fun <T, R> PsiMethod.let(block: (PsiMethod) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiMethod
    <R> -> Nothing

'it' @ [177:53] ==> value-parameter it: PsiMethod defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.<no name provided>.beforeChildren.<anonymous>[ValueParameterDescriptorImpl]

'unwrapped' @ [177:56] ==> public val PsiElement.unwrapped: PsiElement? defined in org.jetbrains.kotlin.asJava[DeserializedPropertyDescriptor]

'reportAccidentalOverride' @ [178:37] ==> local final fun reportAccidentalOverride(candidate: PsiNamedElement): Unit defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides[SimpleFunctionDescriptorImpl]

'candidate' @ [178:62] ==> val candidate: PsiNamedElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.checkAccidentalOverrides.<no name provided>.beforeChildren.<anonymous>[LocalVariableDescriptor]

'newName' @ [200:13] ==> value-parameter newName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findCollisions[ValueParameterDescriptorImpl]

'element' @ [201:27] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findCollisions[ValueParameterDescriptorImpl]

'namedUnwrappedElement' @ [201:35] ==> public val PsiElement.namedUnwrappedElement: PsiNamedElement? defined in org.jetbrains.kotlin.asJava[DeserializedPropertyDescriptor]

'declaration' @ [202:26] ==> val declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findCollisions[LocalVariableDescriptor]

'resolveToDescriptor' @ [202:38] ==> public fun KtDeclaration.resolveToDescriptor(bodyResolveMode: BodyResolveMode = ...): DeclarationDescriptor defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'SmartList' @ [204:26] ==> public constructor SmartList<E : (Any..Any?)>() defined in org.jetbrains.kotlin.utils.SmartList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> UsageInfo

'checkRedeclarations' @ [205:9] ==> internal fun checkRedeclarations(descriptor: DeclarationDescriptor, newName: String, result: MutableList<UsageInfo>): Unit defined in org.jetbrains.kotlin.idea.refactoring.rename in file renameConflictUtils.kt[SimpleFunctionDescriptorImpl]

'descriptor' @ [205:29] ==> val descriptor: VariableDescriptor defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findCollisions[LocalVariableDescriptor]

'newName' @ [205:41] ==> value-parameter newName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findCollisions[ValueParameterDescriptorImpl]

'collisions' @ [205:50] ==> val collisions: SmartList<UsageInfo> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findCollisions[LocalVariableDescriptor]

'checkAccidentalOverrides' @ [206:9] ==> private final fun checkAccidentalOverrides(declaration: KtNamedDeclaration, newName: String, descriptor: VariableDescriptor, result: MutableList<UsageInfo>): Unit defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor[SimpleFunctionDescriptorImpl]

'declaration' @ [206:34] ==> val declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findCollisions[LocalVariableDescriptor]

'newName' @ [206:47] ==> value-parameter newName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findCollisions[ValueParameterDescriptorImpl]

'descriptor' @ [206:56] ==> val descriptor: VariableDescriptor defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findCollisions[LocalVariableDescriptor]

'collisions' @ [206:68] ==> val collisions: SmartList<UsageInfo> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findCollisions[LocalVariableDescriptor]

'checkOriginalUsagesRetargeting' @ [207:9] ==> internal fun checkOriginalUsagesRetargeting(declaration: KtNamedDeclaration, newName: String, originalUsages: MutableList<UsageInfo>, newUsages: MutableList<UsageInfo>): Unit defined in org.jetbrains.kotlin.idea.refactoring.rename in file renameConflictUtils.kt[SimpleFunctionDescriptorImpl]

'declaration' @ [207:40] ==> val declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findCollisions[LocalVariableDescriptor]

'newName' @ [207:53] ==> value-parameter newName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findCollisions[ValueParameterDescriptorImpl]

'result' @ [207:62] ==> value-parameter result: MutableList<UsageInfo> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findCollisions[ValueParameterDescriptorImpl]

'collisions' @ [207:70] ==> val collisions: SmartList<UsageInfo> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findCollisions[LocalVariableDescriptor]

'checkNewNameUsagesRetargeting' @ [208:9] ==> internal fun checkNewNameUsagesRetargeting(declaration: KtNamedDeclaration, newName: String, newUsages: MutableList<UsageInfo>): Unit defined in org.jetbrains.kotlin.idea.refactoring.rename in file renameConflictUtils.kt[SimpleFunctionDescriptorImpl]

'declaration' @ [208:39] ==> val declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findCollisions[LocalVariableDescriptor]

'newName' @ [208:52] ==> value-parameter newName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findCollisions[ValueParameterDescriptorImpl]

'collisions' @ [208:61] ==> val collisions: SmartList<UsageInfo> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findCollisions[LocalVariableDescriptor]

'result' @ [209:9] ==> value-parameter result: MutableList<UsageInfo> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findCollisions[ValueParameterDescriptorImpl]

'collisions' @ [209:19] ==> val collisions: SmartList<UsageInfo> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findCollisions[LocalVariableDescriptor]

'findDeepestOverriddenDeclaration' @ [213:39] ==> private final fun findDeepestOverriddenDeclaration(declaration: KtCallableDeclaration): KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor[SimpleFunctionDescriptorImpl]

'callableDeclaration' @ [213:72] ==> value-parameter callableDeclaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.chooseCallableToRename[ValueParameterDescriptorImpl]

'deepestSuperDeclaration' @ [214:13] ==> val deepestSuperDeclaration: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.chooseCallableToRename[LocalVariableDescriptor]

'deepestSuperDeclaration' @ [214:48] ==> val deepestSuperDeclaration: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.chooseCallableToRename[LocalVariableDescriptor]

'callableDeclaration' @ [214:75] ==> value-parameter callableDeclaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.chooseCallableToRename[ValueParameterDescriptorImpl]

'callableDeclaration' @ [215:20] ==> value-parameter callableDeclaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.chooseCallableToRename[ValueParameterDescriptorImpl]

'!!' @ [218:13] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: Application?): Application[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> Application

'getApplication' @ [218:32] ==> public open fun getApplication(): (Application..Application?) defined in com.intellij.openapi.application.ApplicationManager[JavaMethodDescriptor]

'isUnitTestMode' @ [218:51] ==> public final val Application.isUnitTestMode: Boolean[MyPropertyDescriptor]

'deepestSuperDeclaration' @ [218:74] ==> val deepestSuperDeclaration: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.chooseCallableToRename[LocalVariableDescriptor]

'deepestSuperDeclaration' @ [221:17] ==> val deepestSuperDeclaration: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.chooseCallableToRename[LocalVariableDescriptor]

'fqName' @ [221:41] ==> public final val KtCallableDeclaration.fqName: FqName?[MyPropertyDescriptor]

'parent' @ [221:49] ==> @NotNull public open fun parent(): FqName defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'asString' @ [221:59] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'deepestSuperDeclaration' @ [222:18] ==> val deepestSuperDeclaration: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.chooseCallableToRename[LocalVariableDescriptor]

'parent' @ [222:42] ==> public final val KtCallableDeclaration.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'name' @ [222:71] ==> public final val KtClassOrObject.name: String?[MyPropertyDescriptor]

'showYesNoCancelDialog' @ [224:31] ==> @Messages.YesNoCancelResult public open fun showYesNoCancelDialog(p0: (Project..Project?), p1: (String..String?), @Nls p2: (String..String?), p3: (Icon..Icon?)): Int defined in com.intellij.openapi.ui.Messages[JavaMethodDescriptor]

'deepestSuperDeclaration' @ [225:17] ==> val deepestSuperDeclaration: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.chooseCallableToRename[LocalVariableDescriptor]

'project' @ [225:41] ==> public final val KtCallableDeclaration.project: Project[MyPropertyDescriptor]

'if (containsText != null) "Do you want to rename base property from \n$containsText" else "Do you want to rename base property"' @ [226:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'containsText' @ [226:21] ==> val containsText: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.chooseCallableToRename[LocalVariableDescriptor]

'containsText' @ [226:88] ==> val containsText: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.chooseCallableToRename[LocalVariableDescriptor]

'getQuestionIcon' @ [228:26] ==> @NotNull public open fun getQuestionIcon(): Icon defined in com.intellij.openapi.ui.Messages[JavaMethodDescriptor]

'when (result) {
            Messages.YES -> deepestSuperDeclaration
            Messages.NO -> callableDeclaration
            else -> /* Cancel rename */ null
        }' @ [230:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KtCallableDeclaration?, entry1: KtCallableDeclaration?, entry2: KtCallableDeclaration?): KtCallableDeclaration?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KtCallableDeclaration?

'result' @ [230:22] ==> val result: Int defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.chooseCallableToRename[LocalVariableDescriptor]

'YES' @ [231:22] ==> public const final val YES: Int defined in com.intellij.openapi.ui.Messages[JavaPropertyDescriptor]

'deepestSuperDeclaration' @ [231:29] ==> val deepestSuperDeclaration: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.chooseCallableToRename[LocalVariableDescriptor]

'NO' @ [232:22] ==> public const final val NO: Int defined in com.intellij.openapi.ui.Messages[JavaPropertyDescriptor]

'callableDeclaration' @ [232:28] ==> value-parameter callableDeclaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.chooseCallableToRename[ValueParameterDescriptorImpl]

'element' @ [238:37] ==> value-parameter element: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[ValueParameterDescriptorImpl]

'namedUnwrappedElement' @ [238:46] ==> public val PsiElement.namedUnwrappedElement: PsiNamedElement? defined in org.jetbrains.kotlin.asJava[DeserializedPropertyDescriptor]

'namedUnwrappedElement' @ [240:35] ==> val namedUnwrappedElement: PsiNamedElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[LocalVariableDescriptor]

'IllegalStateException' @ [241:44] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'element' @ [241:89] ==> value-parameter element: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[ValueParameterDescriptorImpl]

'chooseCallableToRename' @ [243:35] ==> private final fun chooseCallableToRename(callableDeclaration: KtCallableDeclaration): KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor[SimpleFunctionDescriptorImpl]

'callableDeclaration' @ [243:58] ==> val callableDeclaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[LocalVariableDescriptor]

'component1' @ [245:14] ==> public final operator fun component1(): String? defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [245:29] ==> public final operator fun component2(): String? defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'getJvmNames' @ [245:46] ==> private final fun getJvmNames(element: PsiElement): Pair<String?, String?> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor[SimpleFunctionDescriptorImpl]

'namedUnwrappedElement' @ [245:58] ==> val namedUnwrappedElement: PsiNamedElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[LocalVariableDescriptor]

'element' @ [246:13] ==> value-parameter element: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[ValueParameterDescriptorImpl]

'element' @ [247:24] ==> value-parameter element: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[ValueParameterDescriptorImpl]

'name' @ [247:32] ==> public final var KtLightMethod.name: String[MyPropertyDescriptor]

'element' @ [248:17] ==> value-parameter element: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[ValueParameterDescriptorImpl]

'name' @ [248:25] ==> public final var KtLightMethod.name: String[MyPropertyDescriptor]

'getterJvmName' @ [248:33] ==> val getterJvmName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[LocalVariableDescriptor]

'element' @ [248:50] ==> value-parameter element: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[ValueParameterDescriptorImpl]

'name' @ [248:58] ==> public final var KtLightMethod.name: String[MyPropertyDescriptor]

'setterJvmName' @ [248:66] ==> val setterJvmName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[LocalVariableDescriptor]

'declarationToRename' @ [248:88] ==> val declarationToRename: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[LocalVariableDescriptor]

'declarationToRename' @ [249:20] ==> val declarationToRename: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[LocalVariableDescriptor]

'toLightMethods' @ [249:40] ==> public fun PsiElement.toLightMethods(): List<PsiMethod> defined in org.jetbrains.kotlin.asJava[DeserializedSimpleFunctionDescriptor]

'firstOrNull' @ [249:57] ==> public inline fun <T> Iterable<PsiMethod>.firstOrNull(predicate: (PsiMethod) -> Boolean): PsiMethod? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiMethod

'it' @ [249:71] ==> value-parameter it: PsiMethod defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [249:74] ==> public final var PsiMethod.name: String[MyPropertyDescriptor]

'name' @ [249:82] ==> val name: String defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[LocalVariableDescriptor]

'declarationToRename' @ [252:16] ==> val declarationToRename: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[LocalVariableDescriptor]

'element' @ [256:37] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[ValueParameterDescriptorImpl]

'namedUnwrappedElement' @ [256:45] ==> public val PsiElement.namedUnwrappedElement: PsiNamedElement? defined in org.jetbrains.kotlin.asJava[DeserializedPropertyDescriptor]

'namedUnwrappedElement' @ [258:35] ==> val namedUnwrappedElement: PsiNamedElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[LocalVariableDescriptor]

'IllegalStateException' @ [259:44] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'element' @ [259:89] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[ValueParameterDescriptorImpl]

'component1' @ [262:18] ==> public final operator fun component1(): String? defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [262:33] ==> public final operator fun component2(): String? defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'getJvmNames' @ [262:50] ==> private final fun getJvmNames(element: PsiElement): Pair<String?, String?> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor[SimpleFunctionDescriptorImpl]

'namedUnwrappedElement' @ [262:62] ==> val namedUnwrappedElement: PsiNamedElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[LocalVariableDescriptor]

'if (element is KtLightMethod) {
                val name = element.name
                if (element.name != getterJvmName && element.name != setterJvmName) {
                    substitutedJavaElement
                }
                else {
                    substitutedJavaElement.toLightMethods().firstOrNull { it.name == name }
                }
            }
            else substitutedJavaElement' @ [263:36] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: PsiElement?, elseBranch: PsiElement?): PsiElement?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> PsiElement?

'element' @ [263:40] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[ValueParameterDescriptorImpl]

'element' @ [264:28] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[ValueParameterDescriptorImpl]

'name' @ [264:36] ==> public final var KtLightMethod.name: String[MyPropertyDescriptor]

'if (element.name != getterJvmName && element.name != setterJvmName) {
                    substitutedJavaElement
                }
                else {
                    substitutedJavaElement.toLightMethods().firstOrNull { it.name == name }
                }' @ [265:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: PsiElement?, elseBranch: PsiElement?): PsiElement?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> PsiElement?

'element' @ [265:21] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[ValueParameterDescriptorImpl]

'name' @ [265:29] ==> public final var KtLightMethod.name: String[MyPropertyDescriptor]

'getterJvmName' @ [265:37] ==> val getterJvmName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename.preprocessAndPass[LocalVariableDescriptor]

'element' @ [265:54] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[ValueParameterDescriptorImpl]

'name' @ [265:62] ==> public final var KtLightMethod.name: String[MyPropertyDescriptor]

'setterJvmName' @ [265:70] ==> val setterJvmName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename.preprocessAndPass[LocalVariableDescriptor]

'substitutedJavaElement' @ [266:21] ==> value-parameter substitutedJavaElement: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename.preprocessAndPass[ValueParameterDescriptorImpl]

'substitutedJavaElement' @ [269:21] ==> value-parameter substitutedJavaElement: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename.preprocessAndPass[ValueParameterDescriptorImpl]

'toLightMethods' @ [269:44] ==> public fun PsiElement.toLightMethods(): List<PsiMethod> defined in org.jetbrains.kotlin.asJava[DeserializedSimpleFunctionDescriptor]

'firstOrNull' @ [269:61] ==> public inline fun <T> Iterable<PsiMethod>.firstOrNull(predicate: (PsiMethod) -> Boolean): PsiMethod? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiMethod

'it' @ [269:75] ==> value-parameter it: PsiMethod defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename.preprocessAndPass.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [269:78] ==> public final var PsiMethod.name: String[MyPropertyDescriptor]

'name' @ [269:86] ==> val name: String defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename.preprocessAndPass[LocalVariableDescriptor]

'substitutedJavaElement' @ [272:18] ==> value-parameter substitutedJavaElement: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename.preprocessAndPass[ValueParameterDescriptorImpl]

'renameCallback' @ [273:13] ==> value-parameter renameCallback: Pass<PsiElement> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[ValueParameterDescriptorImpl]

'pass' @ [273:28] ==> public abstract fun pass(p0: (PsiElement..PsiElement?)): Unit defined in com.intellij.openapi.util.Pass[JavaMethodDescriptor]

'elementToProcess' @ [273:33] ==> val elementToProcess: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename.preprocessAndPass[LocalVariableDescriptor]

'findDeepestOverriddenDeclaration' @ [276:39] ==> private final fun findDeepestOverriddenDeclaration(declaration: KtCallableDeclaration): KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor[SimpleFunctionDescriptorImpl]

'callableDeclaration' @ [276:72] ==> val callableDeclaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[LocalVariableDescriptor]

'deepestSuperDeclaration' @ [277:13] ==> val deepestSuperDeclaration: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[LocalVariableDescriptor]

'deepestSuperDeclaration' @ [277:48] ==> val deepestSuperDeclaration: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[LocalVariableDescriptor]

'callableDeclaration' @ [277:75] ==> val callableDeclaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[LocalVariableDescriptor]

'preprocessAndPass' @ [278:20] ==> local final fun preprocessAndPass(substitutedJavaElement: PsiElement): Unit defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[SimpleFunctionDescriptorImpl]

'callableDeclaration' @ [278:38] ==> val callableDeclaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[LocalVariableDescriptor]

'listOfNotNull' @ [281:31] ==> public fun <T : Any> listOfNotNull(element: PsiMethod?): List<PsiMethod> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> PsiMethod

'deepestSuperDeclaration' @ [281:45] ==> val deepestSuperDeclaration: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[LocalVariableDescriptor]

'getRepresentativeLightMethod' @ [281:69] ==> public fun PsiElement.getRepresentativeLightMethod(): PsiMethod? defined in org.jetbrains.kotlin.asJava[DeserializedSimpleFunctionDescriptor]

'checkSuperMethodsWithPopup' @ [282:9] ==> public fun checkSuperMethodsWithPopup(declaration: KtNamedDeclaration, deepestSuperMethods: List<PsiMethod>, actionString: String, editor: Editor, action: (List<PsiElement>) -> Unit): Unit defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'callableDeclaration' @ [282:36] ==> val callableDeclaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[LocalVariableDescriptor]

'superPsiMethods' @ [282:57] ==> val superPsiMethods: List<PsiMethod> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[LocalVariableDescriptor]

'editor' @ [282:84] ==> value-parameter editor: Editor defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[ValueParameterDescriptorImpl]

'preprocessAndPass' @ [283:13] ==> local final fun preprocessAndPass(substitutedJavaElement: PsiElement): Unit defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[SimpleFunctionDescriptorImpl]

'if (it.size > 1) deepestSuperDeclaration else callableDeclaration' @ [283:31] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtCallableDeclaration, elseBranch: KtCallableDeclaration): KtCallableDeclaration[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtCallableDeclaration

'it' @ [283:35] ==> value-parameter it: List<PsiElement> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename.<anonymous>[ValueParameterDescriptorImpl]

'size' @ [283:38] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'deepestSuperDeclaration' @ [283:48] ==> val deepestSuperDeclaration: KtCallableDeclaration? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[LocalVariableDescriptor]

'callableDeclaration' @ [283:77] ==> val callableDeclaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.substituteElementToRename[LocalVariableDescriptor]

'propertyMethod' @ [287:93] ==> value-parameter propertyMethod: PsiMethod defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.PropertyMethodWrapper.<init>[ValueParameterDescriptorImpl]

'propertyMethod' @ [287:127] ==> value-parameter propertyMethod: PsiMethod defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.PropertyMethodWrapper.<init>[ValueParameterDescriptorImpl]

'propertyMethod' @ [288:34] ==> private final val propertyMethod: PsiMethod defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.PropertyMethodWrapper[PropertyDescriptorImpl]

'name' @ [288:49] ==> public final var PsiMethod.name: String[MyPropertyDescriptor]

'this' @ [289:46] ==> <this> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.PropertyMethodWrapper[LazyClassReceiverParameterDescriptor]

'this' @ [290:31] ==> <this> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.PropertyMethodWrapper[LazyClassReceiverParameterDescriptor]

'super' @ [294:9] ==> <this> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor[LazyClassReceiverParameterDescriptor]

'prepareRenaming' @ [294:15] ==> public open fun prepareRenaming(element: PsiElement, newName: String?, allRenames: MutableMap<PsiElement, String>, scope: SearchScope): Unit defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPsiProcessor[SimpleFunctionDescriptorImpl]

'element' @ [294:31] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[ValueParameterDescriptorImpl]

'newName' @ [294:40] ==> value-parameter newName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[ValueParameterDescriptorImpl]

'allRenames' @ [294:49] ==> value-parameter allRenames: MutableMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[ValueParameterDescriptorImpl]

'scope' @ [294:61] ==> value-parameter scope: SearchScope defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[ValueParameterDescriptorImpl]

'element' @ [296:37] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[ValueParameterDescriptorImpl]

'namedUnwrappedElement' @ [296:45] ==> public val PsiElement.namedUnwrappedElement: PsiNamedElement? defined in org.jetbrains.kotlin.asJava[DeserializedPropertyDescriptor]

'when(namedUnwrappedElement) {
            is KtProperty -> runReadAction { LightClassUtil.getLightClassPropertyMethods(namedUnwrappedElement) }
            is KtParameter -> runReadAction { LightClassUtil.getLightClassPropertyMethods(namedUnwrappedElement) }
            else -> throw IllegalStateException("Can't be for element $element there because of canProcessElement()")
        }' @ [297:31] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: LightClassUtil.PropertyAccessorsPsiMethods, entry1: LightClassUtil.PropertyAccessorsPsiMethods, entry2: LightClassUtil.PropertyAccessorsPsiMethods): LightClassUtil.PropertyAccessorsPsiMethods[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> PropertyAccessorsPsiMethods

'namedUnwrappedElement' @ [297:36] ==> val namedUnwrappedElement: PsiNamedElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'runReadAction' @ [298:30] ==> public fun <T> runReadAction(action: () -> LightClassUtil.PropertyAccessorsPsiMethods): LightClassUtil.PropertyAccessorsPsiMethods defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PropertyAccessorsPsiMethods

'LightClassUtil' @ [298:46] ==> public object LightClassUtil defined in org.jetbrains.kotlin.asJava[FakeCallableDescriptorForObject]

'getLightClassPropertyMethods' @ [298:61] ==> public final fun getLightClassPropertyMethods(property: KtProperty): LightClassUtil.PropertyAccessorsPsiMethods defined in org.jetbrains.kotlin.asJava.LightClassUtil[DeserializedSimpleFunctionDescriptor]

'namedUnwrappedElement' @ [298:90] ==> val namedUnwrappedElement: PsiNamedElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'runReadAction' @ [299:31] ==> public fun <T> runReadAction(action: () -> LightClassUtil.PropertyAccessorsPsiMethods): LightClassUtil.PropertyAccessorsPsiMethods defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PropertyAccessorsPsiMethods

'LightClassUtil' @ [299:47] ==> public object LightClassUtil defined in org.jetbrains.kotlin.asJava[FakeCallableDescriptorForObject]

'getLightClassPropertyMethods' @ [299:62] ==> public final fun getLightClassPropertyMethods(parameter: KtParameter): LightClassUtil.PropertyAccessorsPsiMethods defined in org.jetbrains.kotlin.asJava.LightClassUtil[DeserializedSimpleFunctionDescriptor]

'namedUnwrappedElement' @ [299:91] ==> val namedUnwrappedElement: PsiNamedElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'IllegalStateException' @ [300:27] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'element' @ [300:72] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[ValueParameterDescriptorImpl]

'if (newName != null && element is KtLightMethod) propertyNameByAccessor(newName, element) else newName' @ [303:31] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String?, elseBranch: String?): String?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String?

'newName' @ [303:35] ==> value-parameter newName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[ValueParameterDescriptorImpl]

'element' @ [303:54] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[ValueParameterDescriptorImpl]

'propertyNameByAccessor' @ [303:80] ==> public fun propertyNameByAccessor(name: String, accessor: KtLightMethod): String? defined in org.jetbrains.kotlin.asJava[DeserializedSimpleFunctionDescriptor]

'newName' @ [303:103] ==> value-parameter newName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[ValueParameterDescriptorImpl]

'element' @ [303:112] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[ValueParameterDescriptorImpl]

'newName' @ [303:126] ==> value-parameter newName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[ValueParameterDescriptorImpl]

'component1' @ [305:14] ==> public final operator fun component1(): String? defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [305:29] ==> public final operator fun component2(): String? defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'getJvmNames' @ [305:46] ==> private final fun getJvmNames(element: PsiElement): Pair<String?, String?> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor[SimpleFunctionDescriptorImpl]

'namedUnwrappedElement' @ [305:58] ==> val namedUnwrappedElement: PsiNamedElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'propertyMethods' @ [307:22] ==> val propertyMethods: LightClassUtil.PropertyAccessorsPsiMethods defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'getter' @ [307:38] ==> public final val getter: PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil.PropertyAccessorsPsiMethods[DeserializedPropertyDescriptor]

'propertyMethods' @ [308:22] ==> val propertyMethods: LightClassUtil.PropertyAccessorsPsiMethods defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'setter' @ [308:38] ==> public final val setter: PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil.PropertyAccessorsPsiMethods[DeserializedPropertyDescriptor]

'newPropertyName' @ [309:13] ==> val newPropertyName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'getter' @ [310:16] ==> val getter: KtLightMethod? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'setter' @ [310:34] ==> val setter: KtLightMethod? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'element' @ [311:17] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[ValueParameterDescriptorImpl]

'getter' @ [311:28] ==> val getter: KtLightMethod? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'element' @ [311:38] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[ValueParameterDescriptorImpl]

'setter' @ [311:49] ==> val setter: KtLightMethod? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'propertyNameByAccessor' @ [312:16] ==> public fun propertyNameByAccessor(name: String, accessor: KtLightMethod): String? defined in org.jetbrains.kotlin.asJava[DeserializedSimpleFunctionDescriptor]

'getter' @ [312:39] ==> val getter: KtLightMethod? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'name' @ [312:46] ==> public final var KtLightMethod.name: String[MyPropertyDescriptor]

'getter' @ [312:52] ==> val getter: KtLightMethod? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'propertyNameByAccessor' @ [312:63] ==> public fun propertyNameByAccessor(name: String, accessor: KtLightMethod): String? defined in org.jetbrains.kotlin.asJava[DeserializedSimpleFunctionDescriptor]

'setter' @ [312:86] ==> val setter: KtLightMethod? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'name' @ [312:93] ==> public final var KtLightMethod.name: String[MyPropertyDescriptor]

'setter' @ [312:99] ==> val setter: KtLightMethod? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'if (element == getter) setter else getter' @ [313:36] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtLightMethod, elseBranch: KtLightMethod): KtLightMethod[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtLightMethod

'element' @ [313:40] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[ValueParameterDescriptorImpl]

'getter' @ [313:51] ==> val getter: KtLightMethod? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'setter' @ [313:59] ==> val setter: KtLightMethod? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'getter' @ [313:71] ==> val getter: KtLightMethod? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'if (element == getter) JvmAbi.setterName(newPropertyName) else JvmAbi.getterName(newPropertyName)' @ [314:35] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'element' @ [314:39] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[ValueParameterDescriptorImpl]

'getter' @ [314:50] ==> val getter: KtLightMethod? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'setterName' @ [314:65] ==> @NotNull public open fun setterName(@NotNull p0: String): String defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaMethodDescriptor]

'newPropertyName' @ [314:76] ==> val newPropertyName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'getterName' @ [314:105] ==> @NotNull public open fun getterName(@NotNull p0: String): String defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaMethodDescriptor]

'newPropertyName' @ [314:116] ==> val newPropertyName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'getApplication' @ [315:36] ==> public open fun getApplication(): (Application..Application?) defined in com.intellij.openapi.application.ApplicationManager[JavaMethodDescriptor]

'isUnitTestMode' @ [315:53] ==> public final val Application.isUnitTestMode: Boolean[MyPropertyDescriptor]

'==' @ [316:20] ==> public open fun equals(other: Any?): Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'showYesNoDialog' @ [316:29] ==> @Messages.YesNoResult public open fun showYesNoDialog(p0: (String..String?), @NotNull @Nls p1: String, @Nullable p2: Icon?): Int defined in com.intellij.openapi.ui.Messages[JavaMethodDescriptor]

'accessorToRename' @ [316:70] ==> val accessorToRename: KtLightMethod defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'name' @ [316:87] ==> public final var KtLightMethod.name: String[MyPropertyDescriptor]

'getQuestionIcon' @ [318:54] ==> @NotNull public open fun getQuestionIcon(): Icon defined in com.intellij.openapi.ui.Messages[JavaMethodDescriptor]

'YES' @ [318:85] ==> public const final val YES: Int defined in com.intellij.openapi.ui.Messages[JavaPropertyDescriptor]

'allRenames' @ [319:17] ==> value-parameter allRenames: MutableMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[ValueParameterDescriptorImpl]

'accessorToRename' @ [319:28] ==> val accessorToRename: KtLightMethod defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'newAccessorName' @ [319:48] ==> val newAccessorName: String defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'propertyMethods' @ [323:32] ==> val propertyMethods: LightClassUtil.PropertyAccessorsPsiMethods defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'element' @ [324:17] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[ValueParameterDescriptorImpl]

'newPropertyName' @ [324:45] ==> val newPropertyName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'PropertyMethodWrapper' @ [325:31] ==> public constructor PropertyMethodWrapper(propertyMethod: PsiMethod) defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.PropertyMethodWrapper[ClassConstructorDescriptorImpl]

'propertyMethod' @ [325:53] ==> val propertyMethod: PsiMethod defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'when {
                    JvmAbi.isGetterName(propertyMethod.name) && getterJvmName == null ->
                        allRenames[wrapper] = JvmAbi.getterName(newPropertyName)
                    JvmAbi.isSetterName(propertyMethod.name) && setterJvmName == null ->
                        allRenames[wrapper] = JvmAbi.setterName(newPropertyName)
                }' @ [326:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'isGetterName' @ [327:28] ==> public open fun isGetterName(@NotNull p0: String): Boolean defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaMethodDescriptor]

'propertyMethod' @ [327:41] ==> val propertyMethod: PsiMethod defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'name' @ [327:56] ==> public final var PsiMethod.name: String[MyPropertyDescriptor]

'getterJvmName' @ [327:65] ==> val getterJvmName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'allRenames' @ [328:25] ==> value-parameter allRenames: MutableMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[ValueParameterDescriptorImpl]

'wrapper' @ [328:36] ==> val wrapper: RenameKotlinPropertyProcessor.PropertyMethodWrapper defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'getterName' @ [328:54] ==> @NotNull public open fun getterName(@NotNull p0: String): String defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaMethodDescriptor]

'newPropertyName' @ [328:65] ==> val newPropertyName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'isSetterName' @ [329:28] ==> public open fun isSetterName(@NotNull p0: String): Boolean defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaMethodDescriptor]

'propertyMethod' @ [329:41] ==> val propertyMethod: PsiMethod defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'name' @ [329:56] ==> public final var PsiMethod.name: String[MyPropertyDescriptor]

'setterJvmName' @ [329:65] ==> val setterJvmName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'allRenames' @ [330:25] ==> value-parameter allRenames: MutableMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[ValueParameterDescriptorImpl]

'wrapper' @ [330:36] ==> val wrapper: RenameKotlinPropertyProcessor.PropertyMethodWrapper defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'setterName' @ [330:54] ==> @NotNull public open fun setterName(@NotNull p0: String): String defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaMethodDescriptor]

'newPropertyName' @ [330:65] ==> val newPropertyName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'addRenameElements' @ [333:13] ==> private final fun addRenameElements(psiMethod: PsiMethod?, oldName: String?, newName: String?, allRenames: MutableMap<PsiElement, String>, scope: SearchScope): Unit defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor[SimpleFunctionDescriptorImpl]

'propertyMethod' @ [333:31] ==> val propertyMethod: PsiMethod defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'element' @ [333:48] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[ValueParameterDescriptorImpl]

'name' @ [333:76] ==> public final val PsiNamedElement.name: String?[MyPropertyDescriptor]

'newPropertyName' @ [333:82] ==> val newPropertyName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[LocalVariableDescriptor]

'allRenames' @ [333:99] ==> value-parameter allRenames: MutableMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[ValueParameterDescriptorImpl]

'scope' @ [333:111] ==> value-parameter scope: SearchScope defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.prepareRenaming[ValueParameterDescriptorImpl]

'element' @ [344:13] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'element' @ [345:17] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'modifierList' @ [345:25] ==> public final val KtLightMethod.modifierList: PsiModifierList[MyPropertyDescriptor]

'findAnnotation' @ [345:38] ==> @Nullable public abstract fun findAnnotation(@NotNull @NonNls p0: String): PsiAnnotation? defined in com.intellij.psi.PsiModifierList[JavaMethodDescriptor]

'JVM_NAME' @ [345:69] ==> public final val JVM_NAME: (FqName..FqName?) defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaPropertyDescriptor]

'asString' @ [345:78] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'super' @ [346:24] ==> <this> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor[LazyClassReceiverParameterDescriptor]

'renameElement' @ [346:30] ==> public open fun renameElement(p0: (PsiElement..PsiElement?), p1: (String..String?), p2: (Array<(UsageInfo..UsageInfo?)>..Array<out (UsageInfo..UsageInfo?)>?), @Nullable p3: RefactoringElementListener?): Unit defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPsiProcessor[JavaMethodDescriptor]

'element' @ [346:44] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'newName' @ [346:53] ==> value-parameter newName: String defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'usages' @ [346:62] ==> value-parameter usages: Array<UsageInfo> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'listener' @ [346:70] ==> value-parameter listener: RefactoringElementListener? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'element' @ [349:26] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'kotlinOrigin' @ [349:34] ==> public abstract val kotlinOrigin: KtDeclaration? defined in org.jetbrains.kotlin.asJava.elements.KtLightMethod[DeserializedPropertyDescriptor]

'propertyNameByAccessor' @ [350:35] ==> public fun propertyNameByAccessor(name: String, accessor: KtLightMethod): String? defined in org.jetbrains.kotlin.asJava[DeserializedSimpleFunctionDescriptor]

'newName' @ [350:58] ==> value-parameter newName: String defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'element' @ [350:67] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'newPropertyName' @ [352:17] ==> val newPropertyName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[LocalVariableDescriptor]

'origin' @ [352:45] ==> val origin: KtDeclaration? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[LocalVariableDescriptor]

'origin' @ [352:69] ==> val origin: KtDeclaration? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[LocalVariableDescriptor]

'component1' @ [353:22] ==> public final operator fun component1(): List<UsageInfo> defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [353:32] ==> public final operator fun component2(): List<UsageInfo> defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'usages' @ [353:47] ==> value-parameter usages: Array<UsageInfo> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'partition' @ [353:54] ==> public inline fun <T> Array<out UsageInfo>.partition(predicate: (UsageInfo) -> Boolean): Pair<List<UsageInfo>, List<UsageInfo>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> UsageInfo

'it' @ [353:66] ==> value-parameter it: UsageInfo defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement.<anonymous>[ValueParameterDescriptorImpl]

'reference' @ [353:69] ==> public final val UsageInfo.reference: PsiReference?[MyPropertyDescriptor]

'super' @ [354:17] ==> <this> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor[LazyClassReceiverParameterDescriptor]

'renameElement' @ [354:23] ==> public open fun renameElement(p0: (PsiElement..PsiElement?), p1: (String..String?), p2: (Array<(UsageInfo..UsageInfo?)>..Array<out (UsageInfo..UsageInfo?)>?), @Nullable p3: RefactoringElementListener?): Unit defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPsiProcessor[JavaMethodDescriptor]

'element' @ [354:37] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'newName' @ [354:46] ==> value-parameter newName: String defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'otherUsages' @ [354:55] ==> val otherUsages: List<UsageInfo> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[LocalVariableDescriptor]

'toTypedArray' @ [354:67] ==> public inline fun <reified T> Collection<UsageInfo>.toTypedArray(): Array<UsageInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T> -> UsageInfo

'listener' @ [354:83] ==> value-parameter listener: RefactoringElementListener? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'renameElement' @ [355:17] ==> public open tailrec fun renameElement(element: PsiElement, newName: String, usages: Array<UsageInfo>, listener: RefactoringElementListener?): Unit defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor[SimpleFunctionDescriptorImpl]

'origin' @ [355:31] ==> val origin: KtDeclaration? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[LocalVariableDescriptor]

'newPropertyName' @ [355:39] ==> val newPropertyName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[LocalVariableDescriptor]

'ktUsages' @ [355:56] ==> val ktUsages: List<UsageInfo> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[LocalVariableDescriptor]

'toTypedArray' @ [355:65] ==> public inline fun <reified T> Collection<UsageInfo>.toTypedArray(): Array<UsageInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T> -> UsageInfo

'listener' @ [355:81] ==> value-parameter listener: RefactoringElementListener? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'element' @ [360:13] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'element' @ [360:39] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'super' @ [361:13] ==> <this> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor[LazyClassReceiverParameterDescriptor]

'renameElement' @ [361:19] ==> public open fun renameElement(p0: (PsiElement..PsiElement?), p1: (String..String?), p2: (Array<(UsageInfo..UsageInfo?)>..Array<out (UsageInfo..UsageInfo?)>?), @Nullable p3: RefactoringElementListener?): Unit defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPsiProcessor[JavaMethodDescriptor]

'element' @ [361:33] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'newName' @ [361:42] ==> value-parameter newName: String defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'usages' @ [361:51] ==> value-parameter usages: Array<UsageInfo> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'listener' @ [361:59] ==> value-parameter listener: RefactoringElementListener? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'!!' @ [365:20] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: String?): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> String

'element' @ [365:21] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'name' @ [365:52] ==> public final val KtNamedDeclaration.name: String?[MyPropertyDescriptor]

'getterName' @ [366:36] ==> @NotNull public open fun getterName(@NotNull p0: String): String defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaMethodDescriptor]

'name' @ [366:47] ==> val name: String defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[LocalVariableDescriptor]

'setterName' @ [367:36] ==> @NotNull public open fun setterName(@NotNull p0: String): String defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaMethodDescriptor]

'name' @ [367:47] ==> val name: String defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[LocalVariableDescriptor]

'isEnumCompanionPropertyWithEntryConflict' @ [369:13] ==> public fun isEnumCompanionPropertyWithEntryConflict(element: PsiElement, expectedName: String): Boolean defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]

'element' @ [369:54] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'newName' @ [369:63] ==> value-parameter newName: String defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'component1' @ [370:19] ==> public final operator fun component1(): Int defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'component2' @ [370:22] ==> public final operator fun component2(): UsageInfo defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'usages' @ [370:32] ==> value-parameter usages: Array<UsageInfo> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'withIndex' @ [370:39] ==> public fun <T> Array<out UsageInfo>.withIndex(): Iterable<IndexedValue<UsageInfo>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> UsageInfo

'usage' @ [371:21] ==> val usage: UsageInfo defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[LocalVariableDescriptor]

'usage' @ [372:27] ==> val usage: UsageInfo defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[LocalVariableDescriptor]

'reference' @ [372:33] ==> public final val MoveRenameUsageInfo.reference: PsiReference?[MyPropertyDescriptor]

'ref' @ [374:21] ==> val ref: PsiReference defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[LocalVariableDescriptor]

'?:' @ [375:34] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtSimpleNameReference?, right: KtSimpleNameReference): KtSimpleNameReference[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtSimpleNameReference

'ref' @ [375:35] ==> val ref: PsiReference defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[LocalVariableDescriptor]

'bindToElement' @ [375:39] ==> public abstract fun bindToElement(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiReference[JavaMethodDescriptor]

'element' @ [375:53] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'mainReference' @ [375:91] ==> public val KtSimpleNameExpression.mainReference: KtSimpleNameReference defined in org.jetbrains.kotlin.idea.references[DeserializedPropertyDescriptor]

'usages' @ [376:21] ==> value-parameter usages: Array<UsageInfo> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'i' @ [376:28] ==> val i: Int defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[LocalVariableDescriptor]

'MoveRenameUsageInfo' @ [376:33] ==> public constructor MoveRenameUsageInfo(p0: (PsiReference..PsiReference?), p1: (PsiElement..PsiElement?)) defined in com.intellij.refactoring.util.MoveRenameUsageInfo[JavaClassConstructorDescriptor]

'newRef' @ [376:53] ==> val newRef: KtSimpleNameReference defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[LocalVariableDescriptor]

'usage' @ [376:61] ==> val usage: UsageInfo defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[LocalVariableDescriptor]

'referencedElement' @ [376:67] ==> public final val MoveRenameUsageInfo.referencedElement: PsiElement?[MyPropertyDescriptor]

'if (element is KtParameter) usages.filterNot {
            val refTarget = it.reference?.resolve()
            refTarget is KtLightMethod && DataClassDescriptorResolver.isComponentLike(Name.guessByFirstCharacter(refTarget.name))
        } else usages.toList()' @ [381:30] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<UsageInfo>, elseBranch: List<UsageInfo>): List<UsageInfo>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<UsageInfo>

'element' @ [381:34] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'usages' @ [381:58] ==> value-parameter usages: Array<UsageInfo> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'filterNot' @ [381:65] ==> public inline fun <T> Array<out UsageInfo>.filterNot(predicate: (UsageInfo) -> Boolean): List<UsageInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> UsageInfo

'it' @ [382:29] ==> value-parameter it: UsageInfo defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement.<anonymous>[ValueParameterDescriptorImpl]

'reference' @ [382:32] ==> public final val UsageInfo.reference: PsiReference?[MyPropertyDescriptor]

'resolve' @ [382:43] ==> @Nullable public abstract fun resolve(): PsiElement? defined in com.intellij.psi.PsiReference[JavaMethodDescriptor]

'refTarget' @ [383:13] ==> val refTarget: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement.<anonymous>[LocalVariableDescriptor]

'DataClassDescriptorResolver' @ [383:43] ==> public object DataClassDescriptorResolver defined in org.jetbrains.kotlin.resolve[FakeCallableDescriptorForObject]

'isComponentLike' @ [383:71] ==> public final fun isComponentLike(name: Name): Boolean defined in org.jetbrains.kotlin.resolve.DataClassDescriptorResolver[DeserializedSimpleFunctionDescriptor]

'guessByFirstCharacter' @ [383:92] ==> @NotNull public open fun guessByFirstCharacter(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'refTarget' @ [383:114] ==> val refTarget: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement.<anonymous>[LocalVariableDescriptor]

'name' @ [383:124] ==> public final var KtLightMethod.name: String[MyPropertyDescriptor]

'usages' @ [384:16] ==> value-parameter usages: Array<UsageInfo> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'toList' @ [384:23] ==> public fun <T> Array<out UsageInfo>.toList(): List<UsageInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> UsageInfo

'adjustedUsages' @ [386:29] ==> val adjustedUsages: List<UsageInfo> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[LocalVariableDescriptor]

'groupBy' @ [386:44] ==> public inline fun <T, K> Iterable<UsageInfo>.groupBy(keySelector: (UsageInfo) -> RenameKotlinPropertyProcessor.UsageKind): Map<RenameKotlinPropertyProcessor.UsageKind, List<UsageInfo>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> UsageInfo
    <K> -> UsageKind

'usage' @ [387:30] ==> value-parameter usage: UsageInfo defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement.<anonymous>[ValueParameterDescriptorImpl]

'reference' @ [387:36] ==> public final val UsageInfo.reference: PsiReference?[MyPropertyDescriptor]

'resolve' @ [387:47] ==> @Nullable public abstract fun resolve(): PsiElement? defined in com.intellij.psi.PsiReference[JavaMethodDescriptor]

'if (refElement is PsiMethod) {
                when (refElement.name) {
                    oldGetterName -> UsageKind.GETTER_USAGE
                    oldSetterName -> UsageKind.SETTER_USAGE
                    else -> UsageKind.SIMPLE_PROPERTY_USAGE
                }
            }
            else {
                UsageKind.SIMPLE_PROPERTY_USAGE
            }' @ [388:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: RenameKotlinPropertyProcessor.UsageKind, elseBranch: RenameKotlinPropertyProcessor.UsageKind): RenameKotlinPropertyProcessor.UsageKind[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> UsageKind

'refElement' @ [388:17] ==> val refElement: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement.<anonymous>[LocalVariableDescriptor]

'when (refElement.name) {
                    oldGetterName -> UsageKind.GETTER_USAGE
                    oldSetterName -> UsageKind.SETTER_USAGE
                    else -> UsageKind.SIMPLE_PROPERTY_USAGE
                }' @ [389:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: RenameKotlinPropertyProcessor.UsageKind, entry1: RenameKotlinPropertyProcessor.UsageKind, entry2: RenameKotlinPropertyProcessor.UsageKind): RenameKotlinPropertyProcessor.UsageKind[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> UsageKind

'refElement' @ [389:23] ==> val refElement: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement.<anonymous>[LocalVariableDescriptor]

'name' @ [389:34] ==> public final var PsiMethod.name: String[MyPropertyDescriptor]

'oldGetterName' @ [390:21] ==> val oldGetterName: String defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[LocalVariableDescriptor]

'GETTER_USAGE' @ [390:48] ==> enum entry GETTER_USAGE defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.UsageKind[FakeCallableDescriptorForObject]

'oldSetterName' @ [391:21] ==> val oldSetterName: String defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[LocalVariableDescriptor]

'SETTER_USAGE' @ [391:48] ==> enum entry SETTER_USAGE defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.UsageKind[FakeCallableDescriptorForObject]

'SIMPLE_PROPERTY_USAGE' @ [392:39] ==> enum entry SIMPLE_PROPERTY_USAGE defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.UsageKind[FakeCallableDescriptorForObject]

'SIMPLE_PROPERTY_USAGE' @ [396:27] ==> enum entry SIMPLE_PROPERTY_USAGE defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.UsageKind[FakeCallableDescriptorForObject]

'super' @ [400:9] ==> <this> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor[LazyClassReceiverParameterDescriptor]

'renameElement' @ [400:15] ==> public open fun renameElement(p0: (PsiElement..PsiElement?), p1: (String..String?), p2: (Array<(UsageInfo..UsageInfo?)>..Array<out (UsageInfo..UsageInfo?)>?), @Nullable p3: RefactoringElementListener?): Unit defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPsiProcessor[JavaMethodDescriptor]

'element' @ [400:29] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'setterName' @ [400:45] ==> @NotNull public open fun setterName(@NotNull p0: String): String defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaMethodDescriptor]

'newName' @ [400:56] ==> value-parameter newName: String defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'refKindUsages' @ [401:29] ==> val refKindUsages: Map<RenameKotlinPropertyProcessor.UsageKind, List<UsageInfo>> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[LocalVariableDescriptor]

'SETTER_USAGE' @ [401:53] ==> enum entry SETTER_USAGE defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.UsageKind[FakeCallableDescriptorForObject]

'toTypedArray' @ [401:68] ==> public inline fun <reified T> Collection<UsageInfo>.toTypedArray(): Array<UsageInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T> -> UsageInfo

'arrayOf' @ [401:86] ==> public inline fun <reified @PureReifiable T> arrayOf(vararg elements: UsageInfo): Array<UsageInfo> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified @PureReifiable T> -> UsageInfo

'super' @ [404:9] ==> <this> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor[LazyClassReceiverParameterDescriptor]

'renameElement' @ [404:15] ==> public open fun renameElement(p0: (PsiElement..PsiElement?), p1: (String..String?), p2: (Array<(UsageInfo..UsageInfo?)>..Array<out (UsageInfo..UsageInfo?)>?), @Nullable p3: RefactoringElementListener?): Unit defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPsiProcessor[JavaMethodDescriptor]

'element' @ [404:29] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'getterName' @ [404:45] ==> @NotNull public open fun getterName(@NotNull p0: String): String defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaMethodDescriptor]

'newName' @ [404:56] ==> value-parameter newName: String defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'refKindUsages' @ [405:29] ==> val refKindUsages: Map<RenameKotlinPropertyProcessor.UsageKind, List<UsageInfo>> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[LocalVariableDescriptor]

'GETTER_USAGE' @ [405:53] ==> enum entry GETTER_USAGE defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.UsageKind[FakeCallableDescriptorForObject]

'toTypedArray' @ [405:68] ==> public inline fun <reified T> Collection<UsageInfo>.toTypedArray(): Array<UsageInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T> -> UsageInfo

'arrayOf' @ [405:86] ==> public inline fun <reified @PureReifiable T> arrayOf(vararg elements: UsageInfo): Array<UsageInfo> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified @PureReifiable T> -> UsageInfo

'super' @ [408:9] ==> <this> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor[LazyClassReceiverParameterDescriptor]

'renameElement' @ [408:15] ==> public open fun renameElement(p0: (PsiElement..PsiElement?), p1: (String..String?), p2: (Array<(UsageInfo..UsageInfo?)>..Array<out (UsageInfo..UsageInfo?)>?), @Nullable p3: RefactoringElementListener?): Unit defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPsiProcessor[JavaMethodDescriptor]

'element' @ [408:29] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'newName' @ [408:38] ==> value-parameter newName: String defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'refKindUsages' @ [409:29] ==> val refKindUsages: Map<RenameKotlinPropertyProcessor.UsageKind, List<UsageInfo>> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[LocalVariableDescriptor]

'SIMPLE_PROPERTY_USAGE' @ [409:53] ==> enum entry SIMPLE_PROPERTY_USAGE defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.UsageKind[FakeCallableDescriptorForObject]

'toTypedArray' @ [409:77] ==> public inline fun <reified T> Collection<UsageInfo>.toTypedArray(): Array<UsageInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T> -> UsageInfo

'arrayOf' @ [409:95] ==> public inline fun <reified @PureReifiable T> arrayOf(vararg elements: UsageInfo): Array<UsageInfo> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified @PureReifiable T> -> UsageInfo

'usages' @ [412:9] ==> value-parameter usages: Array<UsageInfo> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'forEach' @ [412:16] ==> public inline fun <T> Array<out UsageInfo>.forEach(action: (UsageInfo) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> UsageInfo

'it' @ [412:27] ==> value-parameter it: UsageInfo defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement.<anonymous>[ValueParameterDescriptorImpl]

'apply' @ [412:67] ==> public abstract fun apply(): Unit defined in org.jetbrains.kotlin.idea.refactoring.rename.KtResolvableCollisionUsageInfo[SimpleFunctionDescriptorImpl]

'dropOverrideKeywordIfNecessary' @ [414:9] ==> public fun dropOverrideKeywordIfNecessary(element: KtNamedDeclaration): Unit defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'element' @ [414:40] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'listener' @ [416:9] ==> value-parameter listener: RefactoringElementListener? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'elementRenamed' @ [416:19] ==> public abstract fun elementRenamed(@NotNull p0: PsiElement): Unit defined in com.intellij.refactoring.listeners.RefactoringElementListener[JavaMethodDescriptor]

'element' @ [416:34] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.renameElement[ValueParameterDescriptorImpl]

'psiMethod' @ [424:13] ==> value-parameter psiMethod: PsiMethod? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.addRenameElements[ValueParameterDescriptorImpl]

'search' @ [426:33] ==> public open fun search(@NotNull p0: PsiMethod, @NotNull p1: SearchScope, p2: Boolean): (Query<(PsiMethod..PsiMethod?)>..Query<(PsiMethod..PsiMethod?)>?) defined in com.intellij.psi.search.searches.OverridingMethodsSearch[JavaMethodDescriptor]

'psiMethod' @ [426:40] ==> value-parameter psiMethod: PsiMethod? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.addRenameElements[ValueParameterDescriptorImpl]

'scope' @ [426:51] ==> value-parameter scope: SearchScope defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.addRenameElements[ValueParameterDescriptorImpl]

'forEach' @ [426:64] ==> @HidesMembers public inline fun <T> Iterable<(PsiMethod..PsiMethod?)>.forEach(action: ((PsiMethod..PsiMethod?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiMethod..com.intellij.psi.PsiMethod?)

'overrider' @ [427:36] ==> value-parameter overrider: (PsiMethod..PsiMethod?) defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.addRenameElements.<anonymous>[ValueParameterDescriptorImpl]

'namedUnwrappedElement' @ [427:46] ==> public val PsiElement.namedUnwrappedElement: PsiNamedElement? defined in org.jetbrains.kotlin.asJava[DeserializedPropertyDescriptor]

'overriderElement' @ [429:17] ==> val overriderElement: PsiNamedElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.addRenameElements.<anonymous>[LocalVariableDescriptor]

'overriderElement' @ [429:45] ==> val overriderElement: PsiNamedElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.addRenameElements.<anonymous>[LocalVariableDescriptor]

'assertNonCompileElement' @ [430:33] ==> public open fun assertNonCompileElement(p0: (PsiElement..PsiElement?)): Unit defined in com.intellij.refactoring.rename.RenameProcessor[JavaMethodDescriptor]

'overriderElement' @ [430:57] ==> val overriderElement: PsiNamedElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.addRenameElements.<anonymous>[LocalVariableDescriptor]

'overriderElement' @ [432:37] ==> val overriderElement: PsiNamedElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.addRenameElements.<anonymous>[LocalVariableDescriptor]

'name' @ [432:54] ==> public final val PsiNamedElement.name: String?[MyPropertyDescriptor]

'if (overriderElement is PsiMethod) {
                    if (newName != null && Name.isValidIdentifier(newName)) {
                        val isGetter = overriderElement.parameterList.parametersCount == 0
                        allRenames[overriderElement] = if (isGetter) JvmAbi.getterName(newName) else JvmAbi.setterName(newName)
                    }
                }
                else {
                    val newOverriderName = RefactoringUtil.suggestNewOverriderName(overriderName, oldName, newName)
                    if (newOverriderName != null) {
                        allRenames[overriderElement] = newOverriderName
                    }
                }' @ [434:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'overriderElement' @ [434:21] ==> val overriderElement: PsiNamedElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.addRenameElements.<anonymous>[LocalVariableDescriptor]

'newName' @ [435:25] ==> value-parameter newName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.addRenameElements[ValueParameterDescriptorImpl]

'isValidIdentifier' @ [435:49] ==> public open fun isValidIdentifier(@NotNull p0: String): Boolean defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'newName' @ [435:67] ==> value-parameter newName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.addRenameElements[ValueParameterDescriptorImpl]

'overriderElement' @ [436:40] ==> val overriderElement: PsiNamedElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.addRenameElements.<anonymous>[LocalVariableDescriptor]

'parameterList' @ [436:57] ==> public final val PsiMethod.parameterList: PsiParameterList[MyPropertyDescriptor]

'parametersCount' @ [436:71] ==> public final val PsiParameterList.parametersCount: Int[MyPropertyDescriptor]

'allRenames' @ [437:25] ==> value-parameter allRenames: MutableMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.addRenameElements[ValueParameterDescriptorImpl]

'overriderElement' @ [437:36] ==> val overriderElement: PsiNamedElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.addRenameElements.<anonymous>[LocalVariableDescriptor]

'if (isGetter) JvmAbi.getterName(newName) else JvmAbi.setterName(newName)' @ [437:56] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'isGetter' @ [437:60] ==> val isGetter: Boolean defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.addRenameElements.<anonymous>[LocalVariableDescriptor]

'getterName' @ [437:77] ==> @NotNull public open fun getterName(@NotNull p0: String): String defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaMethodDescriptor]

'newName' @ [437:88] ==> value-parameter newName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.addRenameElements[ValueParameterDescriptorImpl]

'setterName' @ [437:109] ==> @NotNull public open fun setterName(@NotNull p0: String): String defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaMethodDescriptor]

'newName' @ [437:120] ==> value-parameter newName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.addRenameElements[ValueParameterDescriptorImpl]

'suggestNewOverriderName' @ [441:60] ==> @Nullable public open fun suggestNewOverriderName(p0: (String..String?), p1: (String..String?), p2: (String..String?)): String? defined in com.intellij.refactoring.util.RefactoringUtil[JavaMethodDescriptor]

'overriderName' @ [441:84] ==> val overriderName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.addRenameElements.<anonymous>[LocalVariableDescriptor]

'oldName' @ [441:99] ==> value-parameter oldName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.addRenameElements[ValueParameterDescriptorImpl]

'newName' @ [441:108] ==> value-parameter newName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.addRenameElements[ValueParameterDescriptorImpl]

'newOverriderName' @ [442:25] ==> val newOverriderName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.addRenameElements.<anonymous>[LocalVariableDescriptor]

'allRenames' @ [443:25] ==> value-parameter allRenames: MutableMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.addRenameElements[ValueParameterDescriptorImpl]

'overriderElement' @ [443:36] ==> val overriderElement: PsiNamedElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.addRenameElements.<anonymous>[LocalVariableDescriptor]

'newOverriderName' @ [443:56] ==> val newOverriderName: String? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.addRenameElements.<anonymous>[LocalVariableDescriptor]

'declaration' @ [451:13] ==> value-parameter declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findDeepestOverriddenDeclaration[ValueParameterDescriptorImpl]

'modifierList' @ [451:25] ==> public final val KtCallableDeclaration.modifierList: KtModifierList?[MyPropertyDescriptor]

'hasModifier' @ [451:39] ==> public open fun hasModifier(@NotNull p0: KtModifierKeywordToken): Boolean defined in org.jetbrains.kotlin.psi.KtModifierList[JavaMethodDescriptor]

'OVERRIDE_KEYWORD' @ [451:60] ==> public final val OVERRIDE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'declaration' @ [452:34] ==> value-parameter declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findDeepestOverriddenDeclaration[ValueParameterDescriptorImpl]

'analyze' @ [452:46] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [453:30] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findDeepestOverriddenDeclaration[LocalVariableDescriptor]

'DECLARATION_TO_DESCRIPTOR' @ [453:60] ==> public final val DECLARATION_TO_DESCRIPTOR: (ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'declaration' @ [453:87] ==> value-parameter declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findDeepestOverriddenDeclaration[ValueParameterDescriptorImpl]

'descriptor' @ [454:17] ==> var descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findDeepestOverriddenDeclaration[LocalVariableDescriptor]

'descriptor' @ [455:17] ==> var descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findDeepestOverriddenDeclaration[LocalVariableDescriptor]

'bindingContext' @ [455:30] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findDeepestOverriddenDeclaration[LocalVariableDescriptor]

'VALUE_PARAMETER_AS_PROPERTY' @ [455:60] ==> public final val VALUE_PARAMETER_AS_PROPERTY: (WritableSlice<(ValueParameterDescriptor..ValueParameterDescriptor?), (PropertyDescriptor..PropertyDescriptor?)>..WritableSlice<(ValueParameterDescriptor..ValueParameterDescriptor?), (PropertyDescriptor..PropertyDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'descriptor' @ [455:89] ==> var descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findDeepestOverriddenDeclaration[LocalVariableDescriptor]

'declaration' @ [456:31] ==> value-parameter declaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findDeepestOverriddenDeclaration[ValueParameterDescriptorImpl]

'descriptor' @ [459:17] ==> var descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findDeepestOverriddenDeclaration[LocalVariableDescriptor]

'assert' @ [460:17] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'descriptor' @ [460:24] ==> var descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findDeepestOverriddenDeclaration[LocalVariableDescriptor]

'descriptor' @ [462:31] ==> var descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findDeepestOverriddenDeclaration[LocalVariableDescriptor]

'getDeepestSuperDeclarations' @ [462:65] ==> public fun <D : CallableMemberDescriptor> PropertyDescriptor.getDeepestSuperDeclarations(): Collection<PropertyDescriptor> defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <D : CallableMemberDescriptor> -> PropertyDescriptor

'supers' @ [465:31] ==> val supers: Collection<PropertyDescriptor> defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findDeepestOverriddenDeclaration[LocalVariableDescriptor]

'first' @ [465:38] ==> public fun <T> Iterable<PropertyDescriptor>.first(): PropertyDescriptor defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PropertyDescriptor

'deepest' @ [466:21] ==> val deepest: PropertyDescriptor defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findDeepestOverriddenDeclaration[LocalVariableDescriptor]

'descriptor' @ [466:32] ==> var descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findDeepestOverriddenDeclaration[LocalVariableDescriptor]

'DescriptorToSourceUtils' @ [467:43] ==> public object DescriptorToSourceUtils defined in org.jetbrains.kotlin.resolve[FakeCallableDescriptorForObject]

'descriptorToDeclaration' @ [467:67] ==> @JvmStatic public final fun descriptorToDeclaration(descriptor: DeclarationDescriptor): PsiElement? defined in org.jetbrains.kotlin.resolve.DescriptorToSourceUtils[DeserializedSimpleFunctionDescriptor]

'deepest' @ [467:91] ==> val deepest: PropertyDescriptor defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findDeepestOverriddenDeclaration[LocalVariableDescriptor]

'superPsiElement' @ [468:28] ==> val superPsiElement: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.RenameKotlinPropertyProcessor.findDeepestOverriddenDeclaration[LocalVariableDescriptor]

