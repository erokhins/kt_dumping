'ProjectRootsUtil' @ [58:9] ==> public object ProjectRootsUtil defined in org.jetbrains.kotlin.idea.util[FakeCallableDescriptorForObject]

'isProjectSourceFile' @ [58:26] ==> @JvmStatic public final fun isProjectSourceFile(project: Project, file: VirtualFile): Boolean defined in org.jetbrains.kotlin.idea.util.ProjectRootsUtil[DeserializedSimpleFunctionDescriptor]

'project' @ [58:46] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.debugger.isInlineFunctionLineNumber[ValueParameterDescriptorImpl]

'file' @ [58:55] ==> value-parameter file: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.isInlineFunctionLineNumber[ValueParameterDescriptorImpl]

'file' @ [59:27] ==> value-parameter file: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.isInlineFunctionLineNumber[ValueParameterDescriptorImpl]

'toPsiFile' @ [59:32] ==> public fun VirtualFile.toPsiFile(project: Project): PsiFile? defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'project' @ [59:42] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.debugger.isInlineFunctionLineNumber[ValueParameterDescriptorImpl]

'getLineCount' @ [59:52] ==> public fun PsiElement.getLineCount(): Int defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'lineNumber' @ [60:16] ==> value-parameter lineNumber: Int defined in org.jetbrains.kotlin.idea.debugger.isInlineFunctionLineNumber[ValueParameterDescriptorImpl]

'linesInFile' @ [60:29] ==> val linesInFile: Int defined in org.jetbrains.kotlin.idea.debugger.isInlineFunctionLineNumber[LocalVariableDescriptor]

'KotlinDebuggerCaches' @ [69:12] ==> public companion object defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinDebuggerCaches[FakeCallableDescriptorForObject]

'getOrReadDebugInfoFromBytecode' @ [69:33] ==> public final fun getOrReadDebugInfoFromBytecode(project: Project, jvmName: JvmClassName, file: VirtualFile): BytecodeDebugInfo? defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinDebuggerCaches.Companion[SimpleFunctionDescriptorImpl]

'project' @ [69:64] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.debugger.readBytecodeInfo[ValueParameterDescriptorImpl]

'jvmName' @ [69:73] ==> value-parameter jvmName: JvmClassName defined in org.jetbrains.kotlin.idea.debugger.readBytecodeInfo[ValueParameterDescriptorImpl]

'file' @ [69:82] ==> value-parameter file: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.readBytecodeInfo[ValueParameterDescriptorImpl]

'isDexDebug' @ [74:9] ==> value-parameter isDexDebug: Boolean defined in org.jetbrains.kotlin.idea.debugger.ktLocationInfo[ValueParameterDescriptorImpl]

'locationFile' @ [74:24] ==> value-parameter locationFile: KtFile? = ... defined in org.jetbrains.kotlin.idea.debugger.ktLocationInfo[ValueParameterDescriptorImpl]

'location' @ [74:48] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.ktLocationInfo[ValueParameterDescriptorImpl]

'lineNumber' @ [74:57] ==> public abstract fun lineNumber(): Int defined in com.sun.jdi.Location[JavaMethodDescriptor]

'locationFile' @ [74:72] ==> value-parameter locationFile: KtFile? = ... defined in org.jetbrains.kotlin.idea.debugger.ktLocationInfo[ValueParameterDescriptorImpl]

'getLineCount' @ [74:85] ==> public fun PsiElement.getLineCount(): Int defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'!' @ [75:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'preferInlined' @ [75:14] ==> value-parameter preferInlined: Boolean = ... defined in org.jetbrains.kotlin.idea.debugger.ktLocationInfo[ValueParameterDescriptorImpl]

'runReadAction' @ [76:31] ==> public fun <T> runReadAction(action: () -> Int?): Int? defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Int?

'getLastLineNumberForLocation' @ [76:47] ==> public fun getLastLineNumberForLocation(location: Location, project: Project, searchScope: GlobalSearchScope = ...): Int? defined in org.jetbrains.kotlin.idea.debugger in file NoStrataPositionManagerHelper.kt[SimpleFunctionDescriptorImpl]

'location' @ [76:76] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.ktLocationInfo[ValueParameterDescriptorImpl]

'project' @ [76:86] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.debugger.ktLocationInfo[ValueParameterDescriptorImpl]

'thisFunLine' @ [77:17] ==> val thisFunLine: Int? defined in org.jetbrains.kotlin.idea.debugger.ktLocationInfo[LocalVariableDescriptor]

'thisFunLine' @ [77:40] ==> val thisFunLine: Int? defined in org.jetbrains.kotlin.idea.debugger.ktLocationInfo[LocalVariableDescriptor]

'location' @ [77:55] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.ktLocationInfo[ValueParameterDescriptorImpl]

'lineNumber' @ [77:64] ==> public abstract fun lineNumber(): Int defined in com.sun.jdi.Location[JavaMethodDescriptor]

'thisFunLine' @ [78:24] ==> val thisFunLine: Int? defined in org.jetbrains.kotlin.idea.debugger.ktLocationInfo[LocalVariableDescriptor]

'locationFile' @ [78:39] ==> value-parameter locationFile: KtFile? = ... defined in org.jetbrains.kotlin.idea.debugger.ktLocationInfo[ValueParameterDescriptorImpl]

'runReadAction' @ [82:30] ==> public fun <T> runReadAction(action: () -> Pair<KtFile, Int>?): Pair<KtFile, Int>? defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<KtFile, Int>?

'getOriginalPositionOfInlinedLine' @ [82:46] ==> internal fun getOriginalPositionOfInlinedLine(location: Location, project: Project): Pair<KtFile, Int>? defined in org.jetbrains.kotlin.idea.debugger in file NoStrataPositionManagerHelper.kt[SimpleFunctionDescriptorImpl]

'location' @ [82:79] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.ktLocationInfo[ValueParameterDescriptorImpl]

'project' @ [82:89] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.debugger.ktLocationInfo[ValueParameterDescriptorImpl]

'inlinePosition' @ [83:13] ==> val inlinePosition: Pair<KtFile, Int>? defined in org.jetbrains.kotlin.idea.debugger.ktLocationInfo[LocalVariableDescriptor]

'component1' @ [84:18] ==> public final operator fun component1(): KtFile defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [84:24] ==> public final operator fun component2(): Int defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'inlinePosition' @ [84:32] ==> val inlinePosition: Pair<KtFile, Int>? defined in org.jetbrains.kotlin.idea.debugger.ktLocationInfo[LocalVariableDescriptor]

'line' @ [85:20] ==> val line: Int defined in org.jetbrains.kotlin.idea.debugger.ktLocationInfo[LocalVariableDescriptor]

'file' @ [85:32] ==> val file: KtFile defined in org.jetbrains.kotlin.idea.debugger.ktLocationInfo[LocalVariableDescriptor]

'location' @ [89:12] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.ktLocationInfo[ValueParameterDescriptorImpl]

'lineNumber' @ [89:21] ==> public abstract fun lineNumber(): Int defined in com.sun.jdi.Location[JavaMethodDescriptor]

'locationFile' @ [89:37] ==> value-parameter locationFile: KtFile? = ... defined in org.jetbrains.kotlin.idea.debugger.ktLocationInfo[ValueParameterDescriptorImpl]

'allScope' @ [96:123] ==> @NotNull public open fun allScope(@NotNull p0: Project): GlobalSearchScope defined in com.intellij.psi.search.GlobalSearchScope[JavaMethodDescriptor]

'project' @ [96:132] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.debugger.getLastLineNumberForLocation[ValueParameterDescriptorImpl]

'location' @ [97:22] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.getLastLineNumberForLocation[ValueParameterDescriptorImpl]

'lineNumber' @ [97:31] ==> public abstract fun lineNumber(): Int defined in com.sun.jdi.Location[JavaMethodDescriptor]

'FqName' @ [98:18] ==> public constructor FqName(@NotNull p0: String) defined in org.jetbrains.kotlin.name.FqName[JavaClassConstructorDescriptor]

'location' @ [98:25] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.getLastLineNumberForLocation[ValueParameterDescriptorImpl]

'declaringType' @ [98:34] ==> public abstract fun declaringType(): (ReferenceType..ReferenceType?) defined in com.sun.jdi.Location[JavaMethodDescriptor]

'name' @ [98:50] ==> public abstract fun name(): (String..String?) defined in com.sun.jdi.ReferenceType[JavaMethodDescriptor]

'location' @ [99:20] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.getLastLineNumberForLocation[ValueParameterDescriptorImpl]

'sourceName' @ [99:29] ==> public abstract fun sourceName(): (String..String?) defined in com.sun.jdi.Location[JavaMethodDescriptor]

'location' @ [101:18] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.getLastLineNumberForLocation[ValueParameterDescriptorImpl]

'method' @ [101:27] ==> public abstract fun method(): (Method..Method?) defined in com.sun.jdi.Location[JavaMethodDescriptor]

'method' @ [102:16] ==> val method: Method defined in org.jetbrains.kotlin.idea.debugger.getLastLineNumberForLocation[LocalVariableDescriptor]

'name' @ [102:23] ==> public abstract fun name(): (String..String?) defined in com.sun.jdi.Method[JavaMethodDescriptor]

'method' @ [103:21] ==> val method: Method defined in org.jetbrains.kotlin.idea.debugger.getLastLineNumberForLocation[LocalVariableDescriptor]

'signature' @ [103:28] ==> public abstract fun signature(): (String..String?) defined in com.sun.jdi.Method[JavaMethodDescriptor]

'findAndReadClassFile' @ [105:21] ==> private fun findAndReadClassFile(fqName: FqName, fileName: String, project: Project, searchScope: GlobalSearchScope, fileFilter: (VirtualFile) -> Boolean): BytecodeDebugInfo? defined in org.jetbrains.kotlin.idea.debugger in file NoStrataPositionManagerHelper.kt[SimpleFunctionDescriptorImpl]

'fqName' @ [105:42] ==> val fqName: FqName defined in org.jetbrains.kotlin.idea.debugger.getLastLineNumberForLocation[LocalVariableDescriptor]

'fileName' @ [105:50] ==> val fileName: (String..String?) defined in org.jetbrains.kotlin.idea.debugger.getLastLineNumberForLocation[LocalVariableDescriptor]

'project' @ [105:60] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.debugger.getLastLineNumberForLocation[ValueParameterDescriptorImpl]

'searchScope' @ [105:69] ==> value-parameter searchScope: GlobalSearchScope = ... defined in org.jetbrains.kotlin.idea.debugger.getLastLineNumberForLocation[ValueParameterDescriptorImpl]

'isInlineFunctionLineNumber' @ [105:84] ==> public fun isInlineFunctionLineNumber(file: VirtualFile, lineNumber: Int, project: Project): Boolean defined in org.jetbrains.kotlin.idea.debugger in file NoStrataPositionManagerHelper.kt[SimpleFunctionDescriptorImpl]

'it' @ [105:111] ==> value-parameter it: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.getLastLineNumberForLocation.<anonymous>[ValueParameterDescriptorImpl]

'lineNumber' @ [105:115] ==> val lineNumber: Int defined in org.jetbrains.kotlin.idea.debugger.getLastLineNumberForLocation[LocalVariableDescriptor]

'project' @ [105:127] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.debugger.getLastLineNumberForLocation[ValueParameterDescriptorImpl]

'debugInfo' @ [107:23] ==> val debugInfo: BytecodeDebugInfo defined in org.jetbrains.kotlin.idea.debugger.getLastLineNumberForLocation[LocalVariableDescriptor]

'lineTableMapping' @ [107:33] ==> public final val lineTableMapping: Map<BytecodeMethodKey, Map<String, Set<Int>>> defined in org.jetbrains.kotlin.idea.debugger.BytecodeDebugInfo[PropertyDescriptorImpl]

'BytecodeMethodKey' @ [107:50] ==> public constructor BytecodeMethodKey(methodName: String, signature: String) defined in org.jetbrains.kotlin.idea.debugger.BytecodeMethodKey[ClassConstructorDescriptorImpl]

'name' @ [107:68] ==> val name: String defined in org.jetbrains.kotlin.idea.debugger.getLastLineNumberForLocation[LocalVariableDescriptor]

'signature' @ [107:74] ==> val signature: String defined in org.jetbrains.kotlin.idea.debugger.getLastLineNumberForLocation[LocalVariableDescriptor]

'lineMapping' @ [108:12] ==> val lineMapping: Map<String, Set<Int>> defined in org.jetbrains.kotlin.idea.debugger.getLastLineNumberForLocation[LocalVariableDescriptor]

'values' @ [108:24] ==> public abstract val values: Collection<Set<Int>> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'firstOrNull' @ [108:31] ==> public inline fun <T> Iterable<Set<Int>>.firstOrNull(predicate: (Set<Int>) -> Boolean): Set<Int>? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Set<Int>

'it' @ [108:45] ==> value-parameter it: Set<Int> defined in org.jetbrains.kotlin.idea.debugger.getLastLineNumberForLocation.<anonymous>[ValueParameterDescriptorImpl]

'contains' @ [108:48] ==> public abstract fun contains(element: Int): Boolean defined in kotlin.collections.Set[DeserializedSimpleFunctionDescriptor]

'lineNumber' @ [108:57] ==> val lineNumber: Int defined in org.jetbrains.kotlin.idea.debugger.getLastLineNumberForLocation[LocalVariableDescriptor]

'last' @ [108:72] ==> public fun <T> Iterable<Int>.last(): Int defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Int

'ConcurrentWeakFactoryMap<BinaryCacheKey, BytecodeDebugInfo?>' @ [111:38] ==> public constructor ConcurrentWeakFactoryMap<T : (Any..Any?), V : (Any..Any?)>() defined in com.intellij.util.containers.ConcurrentWeakFactoryMap[JavaClassConstructorDescriptor]
Inferred types:
    <T : (Any..Any?)> -> BinaryCacheKey
    <V : (Any..Any?)> -> BytecodeDebugInfo?

'readClassFileImpl' @ [113:21] ==> private fun readClassFileImpl(project: Project, jvmName: JvmClassName, file: VirtualFile): ByteArray? defined in org.jetbrains.kotlin.idea.debugger in file NoStrataPositionManagerHelper.kt[SimpleFunctionDescriptorImpl]

'key' @ [113:39] ==> value-parameter key: BinaryCacheKey defined in org.jetbrains.kotlin.idea.debugger.WeakBytecodeDebugInfoStorage.create[ValueParameterDescriptorImpl]

'project' @ [113:43] ==> public final val project: Project defined in org.jetbrains.kotlin.idea.debugger.BinaryCacheKey[PropertyDescriptorImpl]

'key' @ [113:52] ==> value-parameter key: BinaryCacheKey defined in org.jetbrains.kotlin.idea.debugger.WeakBytecodeDebugInfoStorage.create[ValueParameterDescriptorImpl]

'jvmName' @ [113:56] ==> public final val jvmName: JvmClassName defined in org.jetbrains.kotlin.idea.debugger.BinaryCacheKey[PropertyDescriptorImpl]

'key' @ [113:65] ==> value-parameter key: BinaryCacheKey defined in org.jetbrains.kotlin.idea.debugger.WeakBytecodeDebugInfoStorage.create[ValueParameterDescriptorImpl]

'file' @ [113:69] ==> public final val file: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.BinaryCacheKey[PropertyDescriptorImpl]

'readDebugInfo' @ [115:24] ==> public fun readDebugInfo(bytes: ByteArray): SmapData? defined in org.jetbrains.kotlin.idea.debugger in file smapUtil.kt[SimpleFunctionDescriptorImpl]

'bytes' @ [115:38] ==> val bytes: ByteArray defined in org.jetbrains.kotlin.idea.debugger.WeakBytecodeDebugInfoStorage.create[LocalVariableDescriptor]

'readLineNumberTableMapping' @ [116:33] ==> private fun readLineNumberTableMapping(bytes: ByteArray): Map<BytecodeMethodKey, Map<String, Set<Int>>> defined in org.jetbrains.kotlin.idea.debugger in file NoStrataPositionManagerHelper.kt[SimpleFunctionDescriptorImpl]

'bytes' @ [116:60] ==> val bytes: ByteArray defined in org.jetbrains.kotlin.idea.debugger.WeakBytecodeDebugInfoStorage.create[LocalVariableDescriptor]

'BytecodeDebugInfo' @ [118:16] ==> public constructor BytecodeDebugInfo(smapData: SmapData?, lineTableMapping: Map<BytecodeMethodKey, Map<String, Set<Int>>>) defined in org.jetbrains.kotlin.idea.debugger.BytecodeDebugInfo[ClassConstructorDescriptorImpl]

'smapData' @ [118:34] ==> val smapData: SmapData? defined in org.jetbrains.kotlin.idea.debugger.WeakBytecodeDebugInfoStorage.create[LocalVariableDescriptor]

'lineNumberMapping' @ [118:44] ==> val lineNumberMapping: Map<BytecodeMethodKey, Map<String, Set<Int>>> defined in org.jetbrains.kotlin.idea.debugger.WeakBytecodeDebugInfoStorage.create[LocalVariableDescriptor]

'createConcurrentWeakKeyWeakValueMap' @ [121:30] ==> @NotNull @Contract public open fun <K : (Any..Any?), V : (Any..Any?)> createConcurrentWeakKeyWeakValueMap(): ConcurrentMap<(BinaryCacheKey..BinaryCacheKey?), BytecodeDebugInfo?> defined in com.intellij.util.containers.ContainerUtil[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.idea.debugger.BinaryCacheKey..org.jetbrains.kotlin.idea.debugger.BinaryCacheKey?)
    <V : (Any..Any?)> -> BytecodeDebugInfo?

'jvmName' @ [134:28] ==> value-parameter jvmName: JvmClassName defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl[ValueParameterDescriptorImpl]

'fqNameForClassNameWithoutDollars' @ [134:36] ==> public final val JvmClassName.fqNameForClassNameWithoutDollars: FqName[MyPropertyDescriptor]

'tail' @ [134:69] ==> public fun FqName.tail(prefix: FqName): FqName defined in org.jetbrains.kotlin.name[DeserializedSimpleFunctionDescriptor]

'jvmName' @ [134:74] ==> value-parameter jvmName: JvmClassName defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl[ValueParameterDescriptorImpl]

'packageFqName' @ [134:82] ==> public final val JvmClassName.packageFqName: FqName[MyPropertyDescriptor]

'!' @ [137:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'ProjectRootsUtil' @ [137:14] ==> public object ProjectRootsUtil defined in org.jetbrains.kotlin.idea.util[FakeCallableDescriptorForObject]

'isLibrarySourceFile' @ [137:31] ==> @JvmStatic public final fun isLibrarySourceFile(project: Project, file: VirtualFile): Boolean defined in org.jetbrains.kotlin.idea.util.ProjectRootsUtil[DeserializedSimpleFunctionDescriptor]

'project' @ [137:51] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl[ValueParameterDescriptorImpl]

'file' @ [137:60] ==> value-parameter file: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl[ValueParameterDescriptorImpl]

'ClassId' @ [139:23] ==> public constructor ClassId(@NotNull p0: FqName, @NotNull p1: Name) defined in org.jetbrains.kotlin.name.ClassId[JavaClassConstructorDescriptor]

'jvmName' @ [139:31] ==> value-parameter jvmName: JvmClassName defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl[ValueParameterDescriptorImpl]

'packageFqName' @ [139:39] ==> public final val JvmClassName.packageFqName: FqName[MyPropertyDescriptor]

'identifier' @ [139:59] ==> @NotNull public open fun identifier(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'fqNameWithInners' @ [139:70] ==> val fqNameWithInners: FqName defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl[LocalVariableDescriptor]

'asString' @ [139:87] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'VirtualFileFinder' @ [141:26] ==> public companion object SERVICE defined in org.jetbrains.kotlin.load.kotlin.VirtualFileFinder[FakeCallableDescriptorForObject]

'getInstance' @ [141:44] ==> public final fun getInstance(project: Project): VirtualFileFinder defined in org.jetbrains.kotlin.load.kotlin.VirtualFileFinder.SERVICE[DeserializedSimpleFunctionDescriptor]

'project' @ [141:56] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl[ValueParameterDescriptorImpl]

'fileFinder' @ [142:25] ==> val fileFinder: VirtualFileFinder defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl.readFromLibrary[LocalVariableDescriptor]

'findVirtualFileWithHeader' @ [142:36] ==> public abstract fun findVirtualFileWithHeader(classId: ClassId): VirtualFile? defined in org.jetbrains.kotlin.load.kotlin.VirtualFileFinder[DeserializedSimpleFunctionDescriptor]

'classId' @ [142:62] ==> val classId: ClassId defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl.readFromLibrary[LocalVariableDescriptor]

'classFile' @ [143:16] ==> val classFile: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl.readFromLibrary[LocalVariableDescriptor]

'contentsToByteArray' @ [143:26] ==> @NotNull public open fun contentsToByteArray(p0: Boolean): ByteArray defined in com.intellij.openapi.vfs.VirtualFile[JavaMethodDescriptor]

'!' @ [147:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'ProjectRootsUtil' @ [147:14] ==> public object ProjectRootsUtil defined in org.jetbrains.kotlin.idea.util[FakeCallableDescriptorForObject]

'isProjectSourceFile' @ [147:31] ==> @JvmStatic public final fun isProjectSourceFile(project: Project, file: VirtualFile): Boolean defined in org.jetbrains.kotlin.idea.util.ProjectRootsUtil[DeserializedSimpleFunctionDescriptor]

'project' @ [147:51] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl[ValueParameterDescriptorImpl]

'file' @ [147:60] ==> value-parameter file: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl[ValueParameterDescriptorImpl]

'?:' @ [149:22] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: Module?, right: Module): Module[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> Module

'getInstance' @ [149:47] ==> public open fun getInstance(p0: (Project..Project?)): (ProjectFileIndex..ProjectFileIndex?) defined in com.intellij.openapi.roots.ProjectFileIndex.SERVICE[JavaMethodDescriptor]

'project' @ [149:59] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl[ValueParameterDescriptorImpl]

'getModuleForFile' @ [149:68] ==> @Nullable public abstract fun getModuleForFile(@NotNull p0: VirtualFile): Module? defined in com.intellij.openapi.roots.ProjectFileIndex[JavaMethodDescriptor]

'file' @ [149:85] ==> value-parameter file: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl[ValueParameterDescriptorImpl]

'?:' @ [150:25] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: VirtualFile?, right: VirtualFile): VirtualFile[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> VirtualFile

'getModuleOutputDirectory' @ [150:39] ==> @Nullable public open fun getModuleOutputDirectory(@NotNull p0: Module, p1: Boolean): VirtualFile? defined in com.intellij.openapi.compiler.CompilerPaths[JavaMethodDescriptor]

'module' @ [150:64] ==> val module: Module defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl.readFromOutput[LocalVariableDescriptor]

'isForTestClasses' @ [150:88] ==> value-parameter isForTestClasses: Boolean defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl.readFromOutput[ValueParameterDescriptorImpl]

'fqNameWithInners' @ [152:25] ==> val fqNameWithInners: FqName defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl[LocalVariableDescriptor]

'asString' @ [152:42] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'replace' @ [152:53] ==> public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'findClassFileByPath' @ [153:32] ==> private fun findClassFileByPath(packageName: String, className: String, outputDir: VirtualFile): File? defined in org.jetbrains.kotlin.idea.debugger in file NoStrataPositionManagerHelper.kt[SimpleFunctionDescriptorImpl]

'jvmName' @ [153:52] ==> value-parameter jvmName: JvmClassName defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl[ValueParameterDescriptorImpl]

'packageFqName' @ [153:60] ==> public final val JvmClassName.packageFqName: FqName[MyPropertyDescriptor]

'asString' @ [153:74] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'className' @ [153:86] ==> val className: String defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl.readFromOutput[LocalVariableDescriptor]

'outputDir' @ [153:97] ==> val outputDir: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl.readFromOutput[LocalVariableDescriptor]

'classByDirectory' @ [155:13] ==> var classByDirectory: File? defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl.readFromOutput[LocalVariableDescriptor]

'!' @ [156:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isForTestClasses' @ [156:18] ==> value-parameter isForTestClasses: Boolean defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl.readFromOutput[ValueParameterDescriptorImpl]

'outputDir' @ [160:37] ==> val outputDir: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl.readFromOutput[LocalVariableDescriptor]

'name' @ [160:47] ==> public final val VirtualFile.name: String[MyPropertyDescriptor]

'outputDir' @ [161:40] ==> val outputDir: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl.readFromOutput[LocalVariableDescriptor]

'parent' @ [161:50] ==> public final val VirtualFile.parent: (VirtualFile..VirtualFile?)[MyPropertyDescriptor]

'parent' @ [161:58] ==> public final val VirtualFile.parent: (VirtualFile..VirtualFile?)[MyPropertyDescriptor]

'findChild' @ [161:66] ==> @Nullable public open fun findChild(@NotNull p0: String): VirtualFile? defined in com.intellij.openapi.vfs.VirtualFile[JavaMethodDescriptor]

'findChild' @ [161:92] ==> @Nullable public open fun findChild(@NotNull p0: String): VirtualFile? defined in com.intellij.openapi.vfs.VirtualFile[JavaMethodDescriptor]

'outputModeDirName' @ [161:102] ==> val outputModeDirName: String defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl.readFromOutput[LocalVariableDescriptor]

'classByDirectory' @ [163:13] ==> var classByDirectory: File? defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl.readFromOutput[LocalVariableDescriptor]

'findClassFileByPath' @ [163:32] ==> private fun findClassFileByPath(packageName: String, className: String, outputDir: VirtualFile): File? defined in org.jetbrains.kotlin.idea.debugger in file NoStrataPositionManagerHelper.kt[SimpleFunctionDescriptorImpl]

'jvmName' @ [163:52] ==> value-parameter jvmName: JvmClassName defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl[ValueParameterDescriptorImpl]

'packageFqName' @ [163:60] ==> public final val JvmClassName.packageFqName: FqName[MyPropertyDescriptor]

'asString' @ [163:74] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'className' @ [163:86] ==> val className: String defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl.readFromOutput[LocalVariableDescriptor]

'androidTestOutputDir' @ [163:97] ==> val androidTestOutputDir: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl.readFromOutput[LocalVariableDescriptor]

'classByDirectory' @ [166:16] ==> var classByDirectory: File? defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl.readFromOutput[LocalVariableDescriptor]

'readBytes' @ [166:33] ==> public fun File.readBytes(): ByteArray defined in kotlin.io[DeserializedSimpleFunctionDescriptor]

'readFromOutput' @ [169:46] ==> local final fun readFromOutput(isForTestClasses: Boolean): ByteArray? defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl[SimpleFunctionDescriptorImpl]

'readFromOutput' @ [171:44] ==> local final fun readFromOutput(isForTestClasses: Boolean): ByteArray? defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl[SimpleFunctionDescriptorImpl]

'readFromLibrary' @ [173:12] ==> local final fun readFromLibrary(): ByteArray? defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl[SimpleFunctionDescriptorImpl]

'readFromSourceOutput' @ [174:12] ==> local final fun readFromSourceOutput(): ByteArray? defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl[SimpleFunctionDescriptorImpl]

'readFromTestOutput' @ [175:12] ==> local final fun readFromTestOutput(): ByteArray? defined in org.jetbrains.kotlin.idea.debugger.readClassFileImpl[SimpleFunctionDescriptorImpl]

'File' @ [179:22] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'outputDir' @ [179:27] ==> value-parameter outputDir: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.findClassFileByPath[ValueParameterDescriptorImpl]

'path' @ [179:37] ==> public final val VirtualFile.path: String[MyPropertyDescriptor]

'takeIf' @ [179:43] ==> @InlineOnly @SinceKotlin public inline fun <T> File.takeIf(predicate: (File) -> Boolean): File? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> File

'exists' @ [179:56] ==> public open fun exists(): Boolean defined in java.io.File[JavaMethodDescriptor]

'File' @ [181:27] ==> public constructor File(p0: (File..File?), p1: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'outDirFile' @ [181:32] ==> val outDirFile: File defined in org.jetbrains.kotlin.idea.debugger.findClassFileByPath[LocalVariableDescriptor]

'packageName' @ [181:44] ==> value-parameter packageName: String defined in org.jetbrains.kotlin.idea.debugger.findClassFileByPath[ValueParameterDescriptorImpl]

'replace' @ [181:56] ==> public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'separator' @ [181:74] ==> public const final val separator: (String..String?) defined in java.io.File[JavaPropertyDescriptor]

'!' @ [182:9] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'parentDirectory' @ [182:10] ==> val parentDirectory: File defined in org.jetbrains.kotlin.idea.debugger.findClassFileByPath[LocalVariableDescriptor]

'exists' @ [182:26] ==> public open fun exists(): Boolean defined in java.io.File[JavaMethodDescriptor]

'getApplication' @ [184:28] ==> public open fun getApplication(): (Application..Application?) defined in com.intellij.openapi.application.ApplicationManager[JavaMethodDescriptor]

'isUnitTestMode' @ [184:45] ==> public final val Application.isUnitTestMode: Boolean[MyPropertyDescriptor]

'File' @ [185:38] ==> public constructor File(p0: (File..File?), p1: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'parentDirectory' @ [185:43] ==> val parentDirectory: File defined in org.jetbrains.kotlin.idea.debugger.findClassFileByPath[LocalVariableDescriptor]

'className' @ [185:60] ==> value-parameter className: String defined in org.jetbrains.kotlin.idea.debugger.findClassFileByPath[ValueParameterDescriptorImpl]

'beforeDexFileClassFile' @ [186:13] ==> val beforeDexFileClassFile: File defined in org.jetbrains.kotlin.idea.debugger.findClassFileByPath[LocalVariableDescriptor]

'exists' @ [186:36] ==> public open fun exists(): Boolean defined in java.io.File[JavaMethodDescriptor]

'beforeDexFileClassFile' @ [187:20] ==> val beforeDexFileClassFile: File defined in org.jetbrains.kotlin.idea.debugger.findClassFileByPath[LocalVariableDescriptor]

'File' @ [191:21] ==> public constructor File(p0: (File..File?), p1: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'parentDirectory' @ [191:26] ==> val parentDirectory: File defined in org.jetbrains.kotlin.idea.debugger.findClassFileByPath[LocalVariableDescriptor]

'className' @ [191:43] ==> value-parameter className: String defined in org.jetbrains.kotlin.idea.debugger.findClassFileByPath[ValueParameterDescriptorImpl]

'classFile' @ [192:9] ==> val classFile: File defined in org.jetbrains.kotlin.idea.debugger.findClassFileByPath[LocalVariableDescriptor]

'exists' @ [192:19] ==> public open fun exists(): Boolean defined in java.io.File[JavaMethodDescriptor]

'classFile' @ [193:16] ==> val classFile: File defined in org.jetbrains.kotlin.idea.debugger.findClassFileByPath[LocalVariableDescriptor]

'HashMap' @ [200:29] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> BytecodeMethodKey
    <V : (Any..Any?)> -> Map<String, Set<Int>>

'ClassReader' @ [202:5] ==> public constructor ClassReader(p0: (ByteArray..ByteArray?)) defined in org.jetbrains.org.objectweb.asm.ClassReader[JavaClassConstructorDescriptor]

'bytes' @ [202:17] ==> value-parameter bytes: ByteArray defined in org.jetbrains.kotlin.idea.debugger.readLineNumberTableMapping[ValueParameterDescriptorImpl]

'accept' @ [202:24] ==> public open fun accept(p0: (ClassVisitor..ClassVisitor?), p1: Int): Unit defined in org.jetbrains.org.objectweb.asm.ClassReader[JavaMethodDescriptor]

'ClassVisitor' @ [202:40] ==> public constructor ClassVisitor(p0: Int) defined in org.jetbrains.org.objectweb.asm.ClassVisitor[JavaClassConstructorDescriptor]

'API' @ [202:53] ==> public const val API: Int defined in org.jetbrains.kotlin.codegen.inline[DeserializedPropertyDescriptor]

'name' @ [204:17] ==> value-parameter name: String? defined in org.jetbrains.kotlin.idea.debugger.readLineNumberTableMapping.<no name provided>.visitMethod[ValueParameterDescriptorImpl]

'desc' @ [204:33] ==> value-parameter desc: String? defined in org.jetbrains.kotlin.idea.debugger.readLineNumberTableMapping.<no name provided>.visitMethod[ValueParameterDescriptorImpl]

'BytecodeMethodKey' @ [208:29] ==> public constructor BytecodeMethodKey(methodName: String, signature: String) defined in org.jetbrains.kotlin.idea.debugger.BytecodeMethodKey[ClassConstructorDescriptorImpl]

'name' @ [208:47] ==> value-parameter name: String? defined in org.jetbrains.kotlin.idea.debugger.readLineNumberTableMapping.<no name provided>.visitMethod[ValueParameterDescriptorImpl]

'desc' @ [208:53] ==> value-parameter desc: String? defined in org.jetbrains.kotlin.idea.debugger.readLineNumberTableMapping.<no name provided>.visitMethod[ValueParameterDescriptorImpl]

'HashMap' @ [209:38] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> String
    <V : (Any..Any?)> -> MutableSet<Int>

'lineNumberMapping' @ [210:13] ==> val lineNumberMapping: HashMap<BytecodeMethodKey, Map<String, Set<Int>>> defined in org.jetbrains.kotlin.idea.debugger.readLineNumberTableMapping[LocalVariableDescriptor]

'methodKey' @ [210:31] ==> val methodKey: BytecodeMethodKey defined in org.jetbrains.kotlin.idea.debugger.readLineNumberTableMapping.<no name provided>.visitMethod[LocalVariableDescriptor]

'methodLinesMapping' @ [210:44] ==> val methodLinesMapping: HashMap<String, MutableSet<Int>> defined in org.jetbrains.kotlin.idea.debugger.readLineNumberTableMapping.<no name provided>.visitMethod[LocalVariableDescriptor]

'MethodVisitor' @ [212:29] ==> public constructor MethodVisitor(p0: Int, p1: (MethodVisitor..MethodVisitor?)) defined in org.jetbrains.org.objectweb.asm.MethodVisitor[JavaClassConstructorDescriptor]

'ASM5' @ [212:51] ==> public const final val ASM5: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'start' @ [214:25] ==> value-parameter start: Label? defined in org.jetbrains.kotlin.idea.debugger.readLineNumberTableMapping.<no name provided>.visitMethod.<no name provided>.visitLineNumber[ValueParameterDescriptorImpl]

'methodLinesMapping' @ [215:25] ==> val methodLinesMapping: HashMap<String, MutableSet<Int>> defined in org.jetbrains.kotlin.idea.debugger.readLineNumberTableMapping.<no name provided>.visitMethod[LocalVariableDescriptor]

'getOrPutNullable' @ [215:44] ==> public inline fun <K, V> MutableMap<String, MutableSet<Int>>.getOrPutNullable(key: String, defaultValue: () -> MutableSet<Int>): MutableSet<Int> defined in org.jetbrains.kotlin.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> String
    <V> -> MutableSet<Int>

'start' @ [215:61] ==> value-parameter start: Label? defined in org.jetbrains.kotlin.idea.debugger.readLineNumberTableMapping.<no name provided>.visitMethod.<no name provided>.visitLineNumber[ValueParameterDescriptorImpl]

'toString' @ [215:67] ==> public open fun toString(): String defined in org.jetbrains.org.objectweb.asm.Label[JavaMethodDescriptor]

'LinkedHashSet' @ [215:81] ==> public constructor LinkedHashSet<E : (Any..Any?)>() defined in java.util.LinkedHashSet[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> Int

'add' @ [215:105] ==> public abstract fun add(element: Int): Boolean defined in kotlin.collections.MutableSet[DeserializedSimpleFunctionDescriptor]

'line' @ [215:109] ==> value-parameter line: Int defined in org.jetbrains.kotlin.idea.debugger.readLineNumberTableMapping.<no name provided>.visitMethod.<no name provided>.visitLineNumber[ValueParameterDescriptorImpl]

'and' @ [220:8] ==> public final infix fun and(other: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'SKIP_FRAMES' @ [220:20] ==> public const final val SKIP_FRAMES: Int defined in org.jetbrains.org.objectweb.asm.ClassReader[JavaPropertyDescriptor]

'SKIP_CODE' @ [220:48] ==> public const final val SKIP_CODE: Int defined in org.jetbrains.org.objectweb.asm.ClassReader[JavaPropertyDescriptor]

'lineNumberMapping' @ [222:12] ==> val lineNumberMapping: HashMap<BytecodeMethodKey, Map<String, Set<Int>>> defined in org.jetbrains.kotlin.idea.debugger.readLineNumberTableMapping[LocalVariableDescriptor]

'location' @ [226:22] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.getOriginalPositionOfInlinedLine[ValueParameterDescriptorImpl]

'lineNumber' @ [226:31] ==> public abstract fun lineNumber(): Int defined in com.sun.jdi.Location[JavaMethodDescriptor]

'FqName' @ [227:18] ==> public constructor FqName(@NotNull p0: String) defined in org.jetbrains.kotlin.name.FqName[JavaClassConstructorDescriptor]

'location' @ [227:25] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.getOriginalPositionOfInlinedLine[ValueParameterDescriptorImpl]

'declaringType' @ [227:34] ==> public abstract fun declaringType(): (ReferenceType..ReferenceType?) defined in com.sun.jdi.Location[JavaMethodDescriptor]

'name' @ [227:50] ==> public abstract fun name(): (String..String?) defined in com.sun.jdi.ReferenceType[JavaMethodDescriptor]

'location' @ [228:20] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.getOriginalPositionOfInlinedLine[ValueParameterDescriptorImpl]

'sourceName' @ [228:29] ==> public abstract fun sourceName(): (String..String?) defined in com.sun.jdi.Location[JavaMethodDescriptor]

'allScope' @ [229:41] ==> @NotNull public open fun allScope(@NotNull p0: Project): GlobalSearchScope defined in com.intellij.psi.search.GlobalSearchScope[JavaMethodDescriptor]

'project' @ [229:50] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.debugger.getOriginalPositionOfInlinedLine[ValueParameterDescriptorImpl]

'findAndReadClassFile' @ [231:21] ==> private fun findAndReadClassFile(fqName: FqName, fileName: String, project: Project, searchScope: GlobalSearchScope, fileFilter: (VirtualFile) -> Boolean): BytecodeDebugInfo? defined in org.jetbrains.kotlin.idea.debugger in file NoStrataPositionManagerHelper.kt[SimpleFunctionDescriptorImpl]

'fqName' @ [231:42] ==> val fqName: FqName defined in org.jetbrains.kotlin.idea.debugger.getOriginalPositionOfInlinedLine[LocalVariableDescriptor]

'fileName' @ [231:50] ==> val fileName: (String..String?) defined in org.jetbrains.kotlin.idea.debugger.getOriginalPositionOfInlinedLine[LocalVariableDescriptor]

'project' @ [231:60] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.debugger.getOriginalPositionOfInlinedLine[ValueParameterDescriptorImpl]

'searchScope' @ [231:69] ==> val searchScope: GlobalSearchScope defined in org.jetbrains.kotlin.idea.debugger.getOriginalPositionOfInlinedLine[LocalVariableDescriptor]

'isInlineFunctionLineNumber' @ [231:84] ==> public fun isInlineFunctionLineNumber(file: VirtualFile, lineNumber: Int, project: Project): Boolean defined in org.jetbrains.kotlin.idea.debugger in file NoStrataPositionManagerHelper.kt[SimpleFunctionDescriptorImpl]

'it' @ [231:111] ==> value-parameter it: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.getOriginalPositionOfInlinedLine.<anonymous>[ValueParameterDescriptorImpl]

'lineNumber' @ [231:115] ==> val lineNumber: Int defined in org.jetbrains.kotlin.idea.debugger.getOriginalPositionOfInlinedLine[LocalVariableDescriptor]

'project' @ [231:127] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.debugger.getOriginalPositionOfInlinedLine[ValueParameterDescriptorImpl]

'debugInfo' @ [233:20] ==> val debugInfo: BytecodeDebugInfo defined in org.jetbrains.kotlin.idea.debugger.getOriginalPositionOfInlinedLine[LocalVariableDescriptor]

'smapData' @ [233:30] ==> public final val smapData: SmapData? defined in org.jetbrains.kotlin.idea.debugger.BytecodeDebugInfo[PropertyDescriptorImpl]

'mapStacktraceLineToSource' @ [235:12] ==> public fun mapStacktraceLineToSource(smapData: SmapData, line: Int, project: Project, lineKind: SourceLineKind, searchScope: GlobalSearchScope): Pair<KtFile, Int>? defined in org.jetbrains.kotlin.idea.debugger in file smapUtil.kt[SimpleFunctionDescriptorImpl]

'smapData' @ [235:38] ==> val smapData: SmapData defined in org.jetbrains.kotlin.idea.debugger.getOriginalPositionOfInlinedLine[LocalVariableDescriptor]

'lineNumber' @ [235:48] ==> val lineNumber: Int defined in org.jetbrains.kotlin.idea.debugger.getOriginalPositionOfInlinedLine[LocalVariableDescriptor]

'project' @ [235:60] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.debugger.getOriginalPositionOfInlinedLine[ValueParameterDescriptorImpl]

'EXECUTED_LINE' @ [235:84] ==> enum entry EXECUTED_LINE defined in org.jetbrains.kotlin.idea.debugger.SourceLineKind[FakeCallableDescriptorForObject]

'searchScope' @ [235:99] ==> val searchScope: GlobalSearchScope defined in org.jetbrains.kotlin.idea.debugger.getOriginalPositionOfInlinedLine[LocalVariableDescriptor]

'fqName' @ [241:24] ==> value-parameter fqName: FqName defined in org.jetbrains.kotlin.idea.debugger.findAndReadClassFile[ValueParameterDescriptorImpl]

'asString' @ [241:31] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'replace' @ [241:42] ==> public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'byInternalName' @ [242:37] ==> @NotNull public open fun byInternalName(@NotNull p0: String): JvmClassName defined in org.jetbrains.kotlin.resolve.jvm.JvmClassName[JavaMethodDescriptor]

'internalName' @ [242:52] ==> val internalName: String defined in org.jetbrains.kotlin.idea.debugger.findAndReadClassFile[LocalVariableDescriptor]

'?:' @ [244:16] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtFile?, right: KtFile): KtFile[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtFile

'findSourceFileForClassIncludeLibrarySources' @ [244:30] ==> public final fun findSourceFileForClassIncludeLibrarySources(project: Project, scope: GlobalSearchScope, className: JvmClassName, fileName: String): KtFile? defined in org.jetbrains.kotlin.idea.debugger.DebuggerUtils[SimpleFunctionDescriptorImpl]

'project' @ [244:74] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.debugger.findAndReadClassFile[ValueParameterDescriptorImpl]

'searchScope' @ [244:83] ==> value-parameter searchScope: GlobalSearchScope defined in org.jetbrains.kotlin.idea.debugger.findAndReadClassFile[ValueParameterDescriptorImpl]

'jvmClassName' @ [244:96] ==> val jvmClassName: JvmClassName defined in org.jetbrains.kotlin.idea.debugger.findAndReadClassFile[LocalVariableDescriptor]

'fileName' @ [244:110] ==> value-parameter fileName: String defined in org.jetbrains.kotlin.idea.debugger.findAndReadClassFile[ValueParameterDescriptorImpl]

'file' @ [246:23] ==> val file: KtFile defined in org.jetbrains.kotlin.idea.debugger.findAndReadClassFile[LocalVariableDescriptor]

'virtualFile' @ [246:28] ==> public final val KtFile.virtualFile: (VirtualFile..VirtualFile?)[MyPropertyDescriptor]

'!' @ [247:9] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'invoke' @ [247:10] ==> public abstract operator fun invoke(p1: VirtualFile): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'virtualFile' @ [247:21] ==> val virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.findAndReadClassFile[LocalVariableDescriptor]

'readBytecodeInfo' @ [249:12] ==> public fun readBytecodeInfo(project: Project, jvmName: JvmClassName, file: VirtualFile): BytecodeDebugInfo? defined in org.jetbrains.kotlin.idea.debugger in file NoStrataPositionManagerHelper.kt[SimpleFunctionDescriptorImpl]

'project' @ [249:29] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.debugger.findAndReadClassFile[ValueParameterDescriptorImpl]

'jvmClassName' @ [249:38] ==> val jvmClassName: JvmClassName defined in org.jetbrains.kotlin.idea.debugger.findAndReadClassFile[LocalVariableDescriptor]

'virtualFile' @ [249:52] ==> val virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.findAndReadClassFile[LocalVariableDescriptor]

'position' @ [253:16] ==> value-parameter position: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.getLocationsOfInlinedLine[ValueParameterDescriptorImpl]

'line' @ [253:25] ==> public final val SourcePosition.line: Int[MyPropertyDescriptor]

'position' @ [254:16] ==> value-parameter position: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.getLocationsOfInlinedLine[ValueParameterDescriptorImpl]

'file' @ [254:25] ==> public final val SourcePosition.file: PsiFile[MyPropertyDescriptor]

'position' @ [255:19] ==> value-parameter position: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.getLocationsOfInlinedLine[ValueParameterDescriptorImpl]

'file' @ [255:28] ==> public final val SourcePosition.file: PsiFile[MyPropertyDescriptor]

'project' @ [255:33] ==> public final val PsiFile.project: Project[MyPropertyDescriptor]

'file' @ [257:27] ==> val file: PsiFile defined in org.jetbrains.kotlin.idea.debugger.getLocationsOfInlinedLine[LocalVariableDescriptor]

'getLineStartOffset' @ [257:32] ==> public fun PsiFile.getLineStartOffset(line: Int): Int? defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'line' @ [257:51] ==> val line: Int defined in org.jetbrains.kotlin.idea.debugger.getLocationsOfInlinedLine[LocalVariableDescriptor]

'listOf' @ [257:67] ==> @InlineOnly public inline fun <T> listOf(): List<Location> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Location

'file' @ [258:19] ==> val file: PsiFile defined in org.jetbrains.kotlin.idea.debugger.getLocationsOfInlinedLine[LocalVariableDescriptor]

'findElementAt' @ [258:24] ==> @Nullable @Contract public abstract fun findElementAt(p0: Int): PsiElement? defined in com.intellij.psi.PsiFile[JavaMethodDescriptor]

'lineStartOffset' @ [258:38] ==> val lineStartOffset: Int defined in org.jetbrains.kotlin.idea.debugger.getLocationsOfInlinedLine[LocalVariableDescriptor]

'listOf' @ [258:65] ==> @InlineOnly public inline fun <T> listOf(): List<Location> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Location

'element' @ [259:21] ==> val element: PsiElement defined in org.jetbrains.kotlin.idea.debugger.getLocationsOfInlinedLine[LocalVariableDescriptor]

'parents' @ [259:29] ==> public val PsiElement.parents: Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'firstIsInstanceOrNull' @ [259:37] ==> public inline fun <reified T : Any> Sequence<*>.firstIsInstanceOrNull(): KtElement? defined in org.jetbrains.kotlin.utils.addToStdlib[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : Any> -> KtElement

'listOf' @ [259:82] ==> @InlineOnly public inline fun <T> listOf(): List<Location> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Location

'runReadAction' @ [261:22] ==> public fun <T> runReadAction(action: () -> Boolean): Boolean defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Boolean

'element' @ [261:38] ==> val element: PsiElement defined in org.jetbrains.kotlin.idea.debugger.getLocationsOfInlinedLine[LocalVariableDescriptor]

'parents' @ [261:46] ==> public val PsiElement.parents: Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'any' @ [261:54] ==> public inline fun <T> Sequence<PsiElement>.any(predicate: (PsiElement) -> Boolean): Boolean defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'it' @ [261:60] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.debugger.getLocationsOfInlinedLine.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [261:80] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.debugger.getLocationsOfInlinedLine.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'hasModifier' @ [261:83] ==> public abstract fun hasModifier(@NotNull p0: KtModifierKeywordToken): Boolean defined in org.jetbrains.kotlin.psi.KtFunction[JavaMethodDescriptor]

'INLINE_KEYWORD' @ [261:104] ==> public final val INLINE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'!' @ [263:9] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isInInline' @ [263:10] ==> val isInInline: Boolean defined in org.jetbrains.kotlin.idea.debugger.getLocationsOfInlinedLine[LocalVariableDescriptor]

'isInCrossinlineArgument' @ [265:39] ==> public fun isInCrossinlineArgument(ktElement: KtElement): Boolean defined in org.jetbrains.kotlin.idea.debugger in file NoStrataPositionManagerHelper.kt[SimpleFunctionDescriptorImpl]

'ktElement' @ [265:63] ==> val ktElement: KtElement defined in org.jetbrains.kotlin.idea.debugger.getLocationsOfInlinedLine[LocalVariableDescriptor]

'!' @ [266:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isInCrossinlineArgument' @ [266:14] ==> val isInCrossinlineArgument: Boolean defined in org.jetbrains.kotlin.idea.debugger.getLocationsOfInlinedLine[LocalVariableDescriptor]

'listOf' @ [267:20] ==> @InlineOnly public inline fun <T> listOf(): List<Location> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Location

'inlinedLinesNumbers' @ [271:17] ==> private fun inlinedLinesNumbers(inlineLineNumber: Int, inlineFileName: String, destinationTypeFqName: FqName, destinationFileName: String, project: Project, sourceSearchScope: GlobalSearchScope): List<Int> defined in org.jetbrains.kotlin.idea.debugger in file NoStrataPositionManagerHelper.kt[SimpleFunctionDescriptorImpl]

'line' @ [271:37] ==> val line: Int defined in org.jetbrains.kotlin.idea.debugger.getLocationsOfInlinedLine[LocalVariableDescriptor]

'position' @ [271:47] ==> value-parameter position: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.getLocationsOfInlinedLine[ValueParameterDescriptorImpl]

'file' @ [271:56] ==> public final val SourcePosition.file: PsiFile[MyPropertyDescriptor]

'name' @ [271:61] ==> public final var PsiFile.name: String[MyPropertyDescriptor]

'FqName' @ [271:67] ==> public constructor FqName(@NotNull p0: String) defined in org.jetbrains.kotlin.name.FqName[JavaClassConstructorDescriptor]

'type' @ [271:74] ==> value-parameter type: ReferenceType defined in org.jetbrains.kotlin.idea.debugger.getLocationsOfInlinedLine[ValueParameterDescriptorImpl]

'name' @ [271:79] ==> public abstract fun name(): (String..String?) defined in com.sun.jdi.ReferenceType[JavaMethodDescriptor]

'type' @ [271:88] ==> value-parameter type: ReferenceType defined in org.jetbrains.kotlin.idea.debugger.getLocationsOfInlinedLine[ValueParameterDescriptorImpl]

'sourceName' @ [271:93] ==> public abstract fun sourceName(): (String..String?) defined in com.sun.jdi.ReferenceType[JavaMethodDescriptor]

'project' @ [271:107] ==> val project: Project defined in org.jetbrains.kotlin.idea.debugger.getLocationsOfInlinedLine[LocalVariableDescriptor]

'sourceSearchScope' @ [271:116] ==> value-parameter sourceSearchScope: GlobalSearchScope defined in org.jetbrains.kotlin.idea.debugger.getLocationsOfInlinedLine[ValueParameterDescriptorImpl]

'lines' @ [273:12] ==> val lines: List<Int> defined in org.jetbrains.kotlin.idea.debugger.getLocationsOfInlinedLine[LocalVariableDescriptor]

'flatMap' @ [273:18] ==> public inline fun <T, R> Iterable<Int>.flatMap(transform: (Int) -> Iterable<(Location..Location?)>): List<(Location..Location?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Int
    <R> -> (com.sun.jdi.Location..com.sun.jdi.Location?)

'type' @ [273:28] ==> value-parameter type: ReferenceType defined in org.jetbrains.kotlin.idea.debugger.getLocationsOfInlinedLine[ValueParameterDescriptorImpl]

'locationsOfLine' @ [273:33] ==> public abstract fun locationsOfLine(p0: Int): (MutableList<(Location..Location?)>..List<(Location..Location?)>?) defined in com.sun.jdi.ReferenceType[JavaMethodDescriptor]

'it' @ [273:49] ==> value-parameter it: Int defined in org.jetbrains.kotlin.idea.debugger.getLocationsOfInlinedLine.<anonymous>[ValueParameterDescriptorImpl]

'runReadAction' @ [277:29] ==> public fun <T> runReadAction(action: () -> Sequence<KtFunction>): Sequence<KtFunction> defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Sequence<KtFunction>

'ktElement' @ [278:9] ==> value-parameter ktElement: KtElement defined in org.jetbrains.kotlin.idea.debugger.isInCrossinlineArgument[ValueParameterDescriptorImpl]

'parents' @ [278:19] ==> public val PsiElement.parents: Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'filter' @ [278:27] ==> public fun <T> Sequence<PsiElement>.filter(predicate: (PsiElement) -> Boolean): Sequence<PsiElement> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'when (it) {
                is KtFunctionLiteral -> it.parent is KtLambdaExpression && (it.parent.parent is KtValueArgument || it.parent.parent is KtLambdaArgument)
                is KtFunction -> it.parent is KtValueArgument
                else -> false
            }' @ [279:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean, entry2: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'it' @ [279:19] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.debugger.isInCrossinlineArgument.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [280:41] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.debugger.isInCrossinlineArgument.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'parent' @ [280:44] ==> public final val KtFunctionLiteral.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'it' @ [280:77] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.debugger.isInCrossinlineArgument.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'parent' @ [280:80] ==> public final val KtFunctionLiteral.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [280:87] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'it' @ [280:116] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.debugger.isInCrossinlineArgument.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'parent' @ [280:119] ==> public final val KtFunctionLiteral.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [280:126] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'it' @ [281:34] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.debugger.isInCrossinlineArgument.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'parent' @ [281:37] ==> public final val KtFunction.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'filterIsInstance' @ [284:11] ==> public inline fun <reified R> Sequence<*>.filterIsInstance(): Sequence<KtFunction> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified R> -> KtFunction

'ktElement' @ [287:26] ==> value-parameter ktElement: KtElement defined in org.jetbrains.kotlin.idea.debugger.isInCrossinlineArgument[ValueParameterDescriptorImpl]

'analyze' @ [287:36] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'PARTIAL' @ [287:60] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'argumentFunctions' @ [288:12] ==> val argumentFunctions: Sequence<KtFunction> defined in org.jetbrains.kotlin.idea.debugger.isInCrossinlineArgument[LocalVariableDescriptor]

'any' @ [288:30] ==> public inline fun <T> Sequence<KtFunction>.any(predicate: (KtFunction) -> Boolean): Boolean defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtFunction

'getInlineArgumentDescriptor' @ [289:45] ==> @Nullable public open fun getInlineArgumentDescriptor(@NotNull p0: KtFunction, @NotNull p1: BindingContext): ValueParameterDescriptor? defined in org.jetbrains.kotlin.resolve.inline.InlineUtil[JavaMethodDescriptor]

'it' @ [289:73] ==> value-parameter it: KtFunction defined in org.jetbrains.kotlin.idea.debugger.isInCrossinlineArgument.<anonymous>[ValueParameterDescriptorImpl]

'bindingContext' @ [289:77] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.debugger.isInCrossinlineArgument[LocalVariableDescriptor]

'argumentDescriptor' @ [290:9] ==> val argumentDescriptor: ValueParameterDescriptor? defined in org.jetbrains.kotlin.idea.debugger.isInCrossinlineArgument.<anonymous>[LocalVariableDescriptor]

'isCrossinline' @ [290:29] ==> public abstract val isCrossinline: Boolean defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'destinationTypeFqName' @ [299:24] ==> value-parameter destinationTypeFqName: FqName defined in org.jetbrains.kotlin.idea.debugger.inlinedLinesNumbers[ValueParameterDescriptorImpl]

'asString' @ [299:46] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'replace' @ [299:57] ==> public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'byInternalName' @ [300:37] ==> @NotNull public open fun byInternalName(@NotNull p0: String): JvmClassName defined in org.jetbrains.kotlin.resolve.jvm.JvmClassName[JavaMethodDescriptor]

'internalName' @ [300:52] ==> val internalName: String defined in org.jetbrains.kotlin.idea.debugger.inlinedLinesNumbers[LocalVariableDescriptor]

'?:' @ [302:16] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtFile?, right: KtFile): KtFile[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtFile

'findSourceFileForClassIncludeLibrarySources' @ [302:30] ==> public final fun findSourceFileForClassIncludeLibrarySources(project: Project, scope: GlobalSearchScope, className: JvmClassName, fileName: String): KtFile? defined in org.jetbrains.kotlin.idea.debugger.DebuggerUtils[SimpleFunctionDescriptorImpl]

'project' @ [302:74] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.debugger.inlinedLinesNumbers[ValueParameterDescriptorImpl]

'sourceSearchScope' @ [302:83] ==> value-parameter sourceSearchScope: GlobalSearchScope defined in org.jetbrains.kotlin.idea.debugger.inlinedLinesNumbers[ValueParameterDescriptorImpl]

'jvmClassName' @ [302:102] ==> val jvmClassName: JvmClassName defined in org.jetbrains.kotlin.idea.debugger.inlinedLinesNumbers[LocalVariableDescriptor]

'destinationFileName' @ [302:116] ==> value-parameter destinationFileName: String defined in org.jetbrains.kotlin.idea.debugger.inlinedLinesNumbers[ValueParameterDescriptorImpl]

'listOf' @ [303:23] ==> @InlineOnly public inline fun <T> listOf(): List<Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Int

'file' @ [305:23] ==> val file: KtFile defined in org.jetbrains.kotlin.idea.debugger.inlinedLinesNumbers[LocalVariableDescriptor]

'virtualFile' @ [305:28] ==> public final val KtFile.virtualFile: (VirtualFile..VirtualFile?)[MyPropertyDescriptor]

'listOf' @ [305:50] ==> @InlineOnly public inline fun <T> listOf(): List<Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Int

'readBytecodeInfo' @ [307:21] ==> public fun readBytecodeInfo(project: Project, jvmName: JvmClassName, file: VirtualFile): BytecodeDebugInfo? defined in org.jetbrains.kotlin.idea.debugger in file NoStrataPositionManagerHelper.kt[SimpleFunctionDescriptorImpl]

'project' @ [307:38] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.debugger.inlinedLinesNumbers[ValueParameterDescriptorImpl]

'jvmClassName' @ [307:47] ==> val jvmClassName: JvmClassName defined in org.jetbrains.kotlin.idea.debugger.inlinedLinesNumbers[LocalVariableDescriptor]

'virtualFile' @ [307:61] ==> val virtualFile: VirtualFile defined in org.jetbrains.kotlin.idea.debugger.inlinedLinesNumbers[LocalVariableDescriptor]

'listOf' @ [307:84] ==> @InlineOnly public inline fun <T> listOf(): List<Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Int

'debugInfo' @ [308:20] ==> val debugInfo: BytecodeDebugInfo defined in org.jetbrains.kotlin.idea.debugger.inlinedLinesNumbers[LocalVariableDescriptor]

'smapData' @ [308:30] ==> public final val smapData: SmapData? defined in org.jetbrains.kotlin.idea.debugger.BytecodeDebugInfo[PropertyDescriptorImpl]

'listOf' @ [308:49] ==> @InlineOnly public inline fun <T> listOf(): List<Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Int

'smapData' @ [310:16] ==> val smapData: SmapData defined in org.jetbrains.kotlin.idea.debugger.inlinedLinesNumbers[LocalVariableDescriptor]

'kotlinStrata' @ [310:25] ==> public final var kotlinStrata: SMAP? defined in org.jetbrains.kotlin.idea.debugger.SmapData[PropertyDescriptorImpl]

'listOf' @ [310:48] ==> @InlineOnly public inline fun <T> listOf(): List<Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Int

'smap' @ [312:33] ==> val smap: SMAP defined in org.jetbrains.kotlin.idea.debugger.inlinedLinesNumbers[LocalVariableDescriptor]

'fileMappings' @ [312:38] ==> public final val fileMappings: List<FileMapping> defined in org.jetbrains.kotlin.codegen.inline.SMAP[DeserializedPropertyDescriptor]

'filter' @ [312:51] ==> public inline fun <T> Iterable<FileMapping>.filter(predicate: (FileMapping) -> Boolean): List<FileMapping> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FileMapping

'it' @ [312:60] ==> value-parameter it: FileMapping defined in org.jetbrains.kotlin.idea.debugger.inlinedLinesNumbers.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [312:63] ==> public final val name: String defined in org.jetbrains.kotlin.codegen.inline.FileMapping[DeserializedPropertyDescriptor]

'inlineFileName' @ [312:71] ==> value-parameter inlineFileName: String defined in org.jetbrains.kotlin.idea.debugger.inlinedLinesNumbers[ValueParameterDescriptorImpl]

'mappingsToInlinedFile' @ [313:28] ==> val mappingsToInlinedFile: List<FileMapping> defined in org.jetbrains.kotlin.idea.debugger.inlinedLinesNumbers[LocalVariableDescriptor]

'flatMap' @ [313:50] ==> public inline fun <T, R> Iterable<FileMapping>.flatMap(transform: (FileMapping) -> Iterable<RangeMapping>): List<RangeMapping> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FileMapping
    <R> -> RangeMapping

'it' @ [313:60] ==> value-parameter it: FileMapping defined in org.jetbrains.kotlin.idea.debugger.inlinedLinesNumbers.<anonymous>[ValueParameterDescriptorImpl]

'lineMappings' @ [313:63] ==> public final val lineMappings: ArrayList<RangeMapping> /* = ArrayList<RangeMapping> */ defined in org.jetbrains.kotlin.codegen.inline.FileMapping[DeserializedPropertyDescriptor]

'mappingIntervals' @ [315:12] ==> val mappingIntervals: List<RangeMapping> defined in org.jetbrains.kotlin.idea.debugger.inlinedLinesNumbers[LocalVariableDescriptor]

'asSequence' @ [315:29] ==> public fun <T> Iterable<RangeMapping>.asSequence(): Sequence<RangeMapping> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> RangeMapping

'filter' @ [316:13] ==> public fun <T> Sequence<RangeMapping>.filter(predicate: (RangeMapping) -> Boolean): Sequence<RangeMapping> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> RangeMapping

'rangeMapping' @ [316:38] ==> value-parameter rangeMapping: RangeMapping defined in org.jetbrains.kotlin.idea.debugger.inlinedLinesNumbers.<anonymous>[ValueParameterDescriptorImpl]

'hasMappingForSource' @ [316:51] ==> public final fun hasMappingForSource(sourceLine: Int): Boolean defined in org.jetbrains.kotlin.codegen.inline.RangeMapping[DeserializedSimpleFunctionDescriptor]

'inlineLineNumber' @ [316:71] ==> value-parameter inlineLineNumber: Int defined in org.jetbrains.kotlin.idea.debugger.inlinedLinesNumbers[ValueParameterDescriptorImpl]

'map' @ [317:13] ==> public fun <T, R> Sequence<RangeMapping>.map(transform: (RangeMapping) -> Int): Sequence<Int> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> RangeMapping
    <R> -> Int

'rangeMapping' @ [317:35] ==> value-parameter rangeMapping: RangeMapping defined in org.jetbrains.kotlin.idea.debugger.inlinedLinesNumbers.<anonymous>[ValueParameterDescriptorImpl]

'mapSourceToDest' @ [317:48] ==> public final fun mapSourceToDest(sourceLine: Int): Int defined in org.jetbrains.kotlin.codegen.inline.RangeMapping[DeserializedSimpleFunctionDescriptor]

'inlineLineNumber' @ [317:64] ==> value-parameter inlineLineNumber: Int defined in org.jetbrains.kotlin.idea.debugger.inlinedLinesNumbers[ValueParameterDescriptorImpl]

'filter' @ [318:13] ==> public fun <T> Sequence<Int>.filter(predicate: (Int) -> Boolean): Sequence<Int> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Int

'line' @ [318:30] ==> value-parameter line: Int defined in org.jetbrains.kotlin.idea.debugger.inlinedLinesNumbers.<anonymous>[ValueParameterDescriptorImpl]

'-' @ [318:38] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'toList' @ [319:13] ==> public fun <T> Sequence<Int>.toList(): List<Int> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Int

'Volatile' @ [322:1] ==> public constructor Volatile() defined in kotlin.jvm.Volatile[DeserializedClassConstructorDescriptor]

'emulateDexDebugInTests' @ [325:10] ==> @Volatile public var emulateDexDebugInTests: Boolean defined in org.jetbrains.kotlin.idea.debugger in file NoStrataPositionManagerHelper.kt[PropertyDescriptorImpl]

'getApplication' @ [325:55] ==> public open fun getApplication(): (Application..Application?) defined in com.intellij.openapi.application.ApplicationManager[JavaMethodDescriptor]

'isUnitTestMode' @ [325:72] ==> public final val Application.isUnitTestMode: Boolean[MyPropertyDescriptor]

'==' @ [326:9] ==> public open fun equals(other: Any?): Boolean defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'this' @ [326:10] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.isDexDebug[ReceiverParameterDescriptorImpl]

'virtualMachineProxy' @ [326:15] ==> public final val DebugProcess.virtualMachineProxy: (VirtualMachineProxy..VirtualMachineProxy?)[MyPropertyDescriptor]

'virtualMachine' @ [326:65] ==> public final val VirtualMachineProxyImpl.virtualMachine: VirtualMachine[MyPropertyDescriptor]

'name' @ [326:81] ==> public abstract fun name(): (String..String?) defined in com.sun.jdi.VirtualMachine[JavaMethodDescriptor]

