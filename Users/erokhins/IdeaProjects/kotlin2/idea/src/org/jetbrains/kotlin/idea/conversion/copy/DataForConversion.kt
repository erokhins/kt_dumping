'copiedCode' @ [38:32] ==> value-parameter copiedCode: CopiedJavaCode defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[ValueParameterDescriptorImpl]

'startOffsets' @ [38:43] ==> public final val startOffsets: IntArray defined in org.jetbrains.kotlin.idea.conversion.copy.CopiedJavaCode[PropertyDescriptorImpl]

'clone' @ [38:56] ==> public open fun clone(): IntArray defined in kotlin.IntArray[SimpleFunctionDescriptorImpl]

'copiedCode' @ [39:30] ==> value-parameter copiedCode: CopiedJavaCode defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[ValueParameterDescriptorImpl]

'endOffsets' @ [39:41] ==> public final val endOffsets: IntArray defined in org.jetbrains.kotlin.idea.conversion.copy.CopiedJavaCode[PropertyDescriptorImpl]

'clone' @ [39:52] ==> public open fun clone(): IntArray defined in kotlin.IntArray[SimpleFunctionDescriptorImpl]

'assert' @ [40:13] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'startOffsets' @ [40:20] ==> val startOffsets: IntArray defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[LocalVariableDescriptor]

'size' @ [40:33] ==> public final val size: Int defined in kotlin.IntArray[DeserializedPropertyDescriptor]

'endOffsets' @ [40:41] ==> val endOffsets: IntArray defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[LocalVariableDescriptor]

'size' @ [40:52] ==> public final val size: Int defined in kotlin.IntArray[DeserializedPropertyDescriptor]

'copiedCode' @ [42:28] ==> value-parameter copiedCode: CopiedJavaCode defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[ValueParameterDescriptorImpl]

'fileText' @ [42:39] ==> public final val fileText: String defined in org.jetbrains.kotlin.idea.conversion.copy.CopiedJavaCode[PropertyDescriptorImpl]

'getInstance' @ [43:39] ==> public open fun getInstance(p0: (Project..Project?)): (PsiFileFactory..PsiFileFactory?) defined in com.intellij.psi.PsiFileFactory[JavaMethodDescriptor]

'project' @ [43:51] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[ValueParameterDescriptorImpl]

'createFileFromText' @ [43:60] ==> public open fun createFileFromText(@NotNull p0: Language, @NotNull p1: CharSequence): (PsiFile..PsiFile?) defined in com.intellij.psi.PsiFileFactory[JavaMethodDescriptor]

'INSTANCE' @ [43:92] ==> @NotNull public final val INSTANCE: JavaLanguage defined in com.intellij.lang.java.JavaLanguage[JavaPropertyDescriptor]

'fileText' @ [43:102] ==> var fileText: String defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[LocalVariableDescriptor]

'buildImportsAndPackage' @ [45:37] ==> private final fun buildImportsAndPackage(sourceFile: PsiJavaFile): String defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion[SimpleFunctionDescriptorImpl]

'file' @ [45:60] ==> var file: PsiJavaFile defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[LocalVariableDescriptor]

'clipTextIfNeeded' @ [47:31] ==> private final fun clipTextIfNeeded(file: PsiJavaFile, fileText: String, startOffsets: IntArray, endOffsets: IntArray): String? defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion[SimpleFunctionDescriptorImpl]

'file' @ [47:48] ==> var file: PsiJavaFile defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[LocalVariableDescriptor]

'fileText' @ [47:54] ==> var fileText: String defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[LocalVariableDescriptor]

'startOffsets' @ [47:64] ==> val startOffsets: IntArray defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[LocalVariableDescriptor]

'endOffsets' @ [47:78] ==> val endOffsets: IntArray defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[LocalVariableDescriptor]

'newFileText' @ [48:17] ==> val newFileText: String? defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[LocalVariableDescriptor]

'fileText' @ [49:17] ==> var fileText: String defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[LocalVariableDescriptor]

'newFileText' @ [49:28] ==> val newFileText: String? defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[LocalVariableDescriptor]

'file' @ [50:17] ==> var file: PsiJavaFile defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[LocalVariableDescriptor]

'getInstance' @ [50:39] ==> public open fun getInstance(p0: (Project..Project?)): (PsiFileFactory..PsiFileFactory?) defined in com.intellij.psi.PsiFileFactory[JavaMethodDescriptor]

'project' @ [50:51] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[ValueParameterDescriptorImpl]

'createFileFromText' @ [50:60] ==> public open fun createFileFromText(@NotNull p0: Language, @NotNull p1: CharSequence): (PsiFile..PsiFile?) defined in com.intellij.psi.PsiFileFactory[JavaMethodDescriptor]

'INSTANCE' @ [50:92] ==> @NotNull public final val INSTANCE: JavaLanguage defined in com.intellij.lang.java.JavaLanguage[JavaPropertyDescriptor]

'newFileText' @ [50:102] ==> val newFileText: String? defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[LocalVariableDescriptor]

'ElementAndTextList' @ [53:36] ==> public constructor ElementAndTextList() defined in org.jetbrains.kotlin.idea.conversion.copy.ElementAndTextList[ClassConstructorDescriptorImpl]

'startOffsets' @ [54:23] ==> val startOffsets: IntArray defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[LocalVariableDescriptor]

'indices' @ [54:36] ==> public val IntArray.indices: IntRange defined in kotlin.collections[DeserializedPropertyDescriptor]

'elementsAndTexts' @ [55:17] ==> val elementsAndTexts: ElementAndTextList defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[LocalVariableDescriptor]

'collectElementsToConvert' @ [55:34] ==> private final fun ElementAndTextList.collectElementsToConvert(file: PsiJavaFile, fileText: String, range: TextRange): Unit defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion[SimpleFunctionDescriptorImpl]

'file' @ [55:59] ==> var file: PsiJavaFile defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[LocalVariableDescriptor]

'fileText' @ [55:65] ==> var fileText: String defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[LocalVariableDescriptor]

'TextRange' @ [55:75] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'startOffsets' @ [55:85] ==> val startOffsets: IntArray defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[LocalVariableDescriptor]

'i' @ [55:98] ==> val i: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[LocalVariableDescriptor]

'endOffsets' @ [55:102] ==> val endOffsets: IntArray defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[LocalVariableDescriptor]

'i' @ [55:113] ==> val i: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[LocalVariableDescriptor]

'DataForConversion' @ [58:20] ==> private constructor DataForConversion(elementsAndTexts: ElementAndTextList, importsAndPackage: String, file: PsiJavaFile) defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion[ClassConstructorDescriptorImpl]

'elementsAndTexts' @ [58:38] ==> val elementsAndTexts: ElementAndTextList defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[LocalVariableDescriptor]

'importsAndPackage' @ [58:56] ==> val importsAndPackage: String defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[LocalVariableDescriptor]

'file' @ [58:75] ==> var file: PsiJavaFile defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.prepare[LocalVariableDescriptor]

'startOffsets' @ [62:26] ==> value-parameter startOffsets: IntArray defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[ValueParameterDescriptorImpl]

'indices' @ [62:39] ==> public val IntArray.indices: IntRange defined in kotlin.collections[DeserializedPropertyDescriptor]

'map' @ [62:47] ==> public inline fun <T, R> Iterable<Int>.map(transform: (Int) -> TextRange): List<TextRange> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Int
    <R> -> TextRange

'TextRange' @ [62:53] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'startOffsets' @ [62:63] ==> value-parameter startOffsets: IntArray defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[ValueParameterDescriptorImpl]

'it' @ [62:76] ==> value-parameter it: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded.<anonymous>[ValueParameterDescriptorImpl]

'endOffsets' @ [62:81] ==> value-parameter endOffsets: IntArray defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[ValueParameterDescriptorImpl]

'it' @ [62:92] ==> value-parameter it: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded.<anonymous>[ValueParameterDescriptorImpl]

'sortedBy' @ [62:99] ==> public inline fun <T, R : Comparable<Int>> Iterable<TextRange>.sortedBy(crossinline selector: (TextRange) -> Int?): List<TextRange> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TextRange
    <R : Comparable<R>> -> Int

'it' @ [62:110] ==> value-parameter it: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded.<anonymous>[ValueParameterDescriptorImpl]

'start' @ [62:113] ==> public val TextRange.start: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'ranges' @ [64:50] ==> val ranges: List<TextRange> defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'all' @ [64:57] ==> public inline fun <T> Iterable<TextRange>.all(predicate: (TextRange) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TextRange

'range' @ [64:63] ==> value-parameter range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded.canDropRange[ValueParameterDescriptorImpl]

'it' @ [64:73] ==> value-parameter it: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded.canDropRange.<anonymous>[ValueParameterDescriptorImpl]

'ArrayList' @ [66:32] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> TextRange

'ranges' @ [67:27] ==> val ranges: List<TextRange> defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'range' @ [68:29] ==> val range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'start' @ [68:35] ==> public val TextRange.start: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'range' @ [69:27] ==> val range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'end' @ [69:33] ==> public val TextRange.end: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'start' @ [70:21] ==> val start: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'end' @ [70:30] ==> val end: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'file' @ [72:34] ==> value-parameter file: PsiJavaFile defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[ValueParameterDescriptorImpl]

'findElementAt' @ [72:39] ==> @Nullable @Contract public abstract fun findElementAt(p0: Int): PsiElement? defined in com.intellij.psi.PsiJavaFile[JavaMethodDescriptor]

'start' @ [72:53] ==> val start: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'startToken' @ [73:41] ==> val startToken: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'maximalParentToClip' @ [73:52] ==> private final fun PsiElement.maximalParentToClip(range: TextRange): PsiElement? defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion[SimpleFunctionDescriptorImpl]

'range' @ [73:72] ==> val range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'elementToClipLeft' @ [74:21] ==> val elementToClipLeft: PsiElement? defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'elementToClipLeft' @ [75:40] ==> val elementToClipLeft: PsiElement? defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'range' @ [75:58] ==> public val PsiElement.range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'start' @ [75:64] ==> public val TextRange.start: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'elementStart' @ [76:25] ==> val elementStart: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'start' @ [76:40] ==> val start: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'tryClipLeftSide' @ [77:41] ==> private final fun tryClipLeftSide(element: PsiElement, leftBound: Int): Int? defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion[SimpleFunctionDescriptorImpl]

'elementToClipLeft' @ [77:57] ==> val elementToClipLeft: PsiElement? defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'start' @ [77:76] ==> val start: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'clipBound' @ [78:29] ==> val clipBound: Int? defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'TextRange' @ [79:47] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'elementStart' @ [79:57] ==> val elementStart: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'clipBound' @ [79:71] ==> val clipBound: Int? defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'canDropRange' @ [80:33] ==> local final fun canDropRange(range: TextRange): Boolean defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[SimpleFunctionDescriptorImpl]

'rangeToDrop' @ [80:46] ==> val rangeToDrop: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'rangesToDrop' @ [81:33] ==> val rangesToDrop: ArrayList<TextRange> defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'add' @ [81:46] ==> public open fun add(element: TextRange): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'rangeToDrop' @ [81:50] ==> val rangeToDrop: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'file' @ [87:32] ==> value-parameter file: PsiJavaFile defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[ValueParameterDescriptorImpl]

'findElementAt' @ [87:37] ==> @Nullable @Contract public abstract fun findElementAt(p0: Int): PsiElement? defined in com.intellij.psi.PsiJavaFile[JavaMethodDescriptor]

'end' @ [87:51] ==> val end: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'endToken' @ [88:42] ==> val endToken: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'maximalParentToClip' @ [88:51] ==> private final fun PsiElement.maximalParentToClip(range: TextRange): PsiElement? defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion[SimpleFunctionDescriptorImpl]

'range' @ [88:71] ==> val range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'elementToClipRight' @ [89:21] ==> val elementToClipRight: PsiElement? defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'elementToClipRight' @ [90:38] ==> val elementToClipRight: PsiElement? defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'range' @ [90:57] ==> public val PsiElement.range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'end' @ [90:63] ==> public val TextRange.end: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'elementEnd' @ [91:25] ==> val elementEnd: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'end' @ [91:38] ==> val end: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'tryClipRightSide' @ [92:41] ==> private final fun tryClipRightSide(element: PsiElement, rightBound: Int): Int? defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion[SimpleFunctionDescriptorImpl]

'elementToClipRight' @ [92:58] ==> val elementToClipRight: PsiElement? defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'end' @ [92:78] ==> val end: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'clipBound' @ [93:29] ==> val clipBound: Int? defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'TextRange' @ [94:47] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'clipBound' @ [94:57] ==> val clipBound: Int? defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'elementEnd' @ [94:68] ==> val elementEnd: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'canDropRange' @ [95:33] ==> local final fun canDropRange(range: TextRange): Boolean defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[SimpleFunctionDescriptorImpl]

'rangeToDrop' @ [95:46] ==> val rangeToDrop: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'rangesToDrop' @ [96:33] ==> val rangesToDrop: ArrayList<TextRange> defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'add' @ [96:46] ==> public open fun add(element: TextRange): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'rangeToDrop' @ [96:50] ==> val rangeToDrop: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'rangesToDrop' @ [103:17] ==> val rangesToDrop: ArrayList<TextRange> defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'isEmpty' @ [103:30] ==> public open fun isEmpty(): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'buildString' @ [105:31] ==> @InlineOnly public inline fun buildString(builderAction: StringBuilder /* = StringBuilder */.() -> Unit): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'rangesToDrop' @ [107:31] ==> val rangesToDrop: ArrayList<TextRange> defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'assert' @ [108:21] ==> @InlineOnly public inline fun assert(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'range' @ [108:28] ==> val range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded.<anonymous>[LocalVariableDescriptor]

'start' @ [108:34] ==> public val TextRange.start: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'offset' @ [108:43] ==> var offset: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded.<anonymous>[LocalVariableDescriptor]

'append' @ [109:21] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'fileText' @ [109:28] ==> value-parameter fileText: String defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[ValueParameterDescriptorImpl]

'substring' @ [109:37] ==> @InlineOnly public inline fun String.substring(startIndex: Int, endIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'offset' @ [109:47] ==> var offset: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded.<anonymous>[LocalVariableDescriptor]

'range' @ [109:55] ==> val range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded.<anonymous>[LocalVariableDescriptor]

'start' @ [109:61] ==> public val TextRange.start: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'offset' @ [110:21] ==> var offset: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded.<anonymous>[LocalVariableDescriptor]

'range' @ [110:30] ==> val range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded.<anonymous>[LocalVariableDescriptor]

'end' @ [110:36] ==> public val TextRange.end: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'append' @ [112:17] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'fileText' @ [112:24] ==> value-parameter fileText: String defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[ValueParameterDescriptorImpl]

'substring' @ [112:33] ==> @InlineOnly public inline fun String.substring(startIndex: Int, endIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'offset' @ [112:43] ==> var offset: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded.<anonymous>[LocalVariableDescriptor]

'fileText' @ [112:51] ==> value-parameter fileText: String defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[ValueParameterDescriptorImpl]

'length' @ [112:60] ==> public open val length: Int defined in kotlin.String[DeserializedPropertyDescriptor]

'rangesToDrop' @ [116:31] ==> val rangesToDrop: ArrayList<TextRange> defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'asReversed' @ [116:44] ==> @JvmName public fun <T> MutableList<TextRange>.asReversed(): MutableList<TextRange> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TextRange

'indices' @ [117:31] ==> public val IntArray.indices: IntRange defined in kotlin.collections[DeserializedPropertyDescriptor]

'this' @ [118:38] ==> <this> defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded.update[ReceiverParameterDescriptorImpl]

'i' @ [118:43] ==> val i: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded.update[LocalVariableDescriptor]

'if (offset >= range.end) {
                            this[i] = offset - range.length
                        }
                        else {
                            assert(offset <= range.start)
                        }' @ [119:25] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'offset' @ [119:29] ==> val offset: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded.update[LocalVariableDescriptor]

'range' @ [119:39] ==> val range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded.update[LocalVariableDescriptor]

'end' @ [119:45] ==> public val TextRange.end: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'this' @ [120:29] ==> <this> defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded.update[ReceiverParameterDescriptorImpl]

'i' @ [120:34] ==> val i: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded.update[LocalVariableDescriptor]

'offset' @ [120:39] ==> val offset: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded.update[LocalVariableDescriptor]

'range' @ [120:48] ==> val range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded.update[LocalVariableDescriptor]

'length' @ [120:54] ==> public final val TextRange.length: Int[MyPropertyDescriptor]

'assert' @ [123:29] ==> @InlineOnly public inline fun assert(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'offset' @ [123:36] ==> val offset: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded.update[LocalVariableDescriptor]

'range' @ [123:46] ==> val range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded.update[LocalVariableDescriptor]

'start' @ [123:52] ==> public val TextRange.start: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'startOffsets' @ [129:13] ==> value-parameter startOffsets: IntArray defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[ValueParameterDescriptorImpl]

'update' @ [129:26] ==> local final fun IntArray.update(): Unit defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[SimpleFunctionDescriptorImpl]

'endOffsets' @ [130:13] ==> value-parameter endOffsets: IntArray defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[ValueParameterDescriptorImpl]

'update' @ [130:24] ==> local final fun IntArray.update(): Unit defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[SimpleFunctionDescriptorImpl]

'newFileText' @ [132:20] ==> val newFileText: String defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.clipTextIfNeeded[LocalVariableDescriptor]

'parentsWithSelf' @ [136:35] ==> public val PsiElement.parentsWithSelf: Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'takeWhile' @ [136:51] ==> public fun <T> Sequence<PsiElement>.takeWhile(predicate: (PsiElement) -> Boolean): Sequence<PsiElement> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'it' @ [136:63] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.maximalParentToClip.<anonymous>[ValueParameterDescriptorImpl]

'firstOrNull' @ [136:85] ==> public inline fun <T> Sequence<PsiElement>.firstOrNull(predicate: (PsiElement) -> Boolean): PsiElement? defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'it' @ [136:99] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.maximalParentToClip.<anonymous>[ValueParameterDescriptorImpl]

'range' @ [136:102] ==> public val PsiElement.range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'range' @ [136:112] ==> value-parameter range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.maximalParentToClip[ValueParameterDescriptorImpl]

'firstNotInRange' @ [137:20] ==> val firstNotInRange: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.maximalParentToClip[LocalVariableDescriptor]

'parentsWithSelf' @ [137:36] ==> public val PsiElement.parentsWithSelf: Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'lastOrNull' @ [137:52] ==> public inline fun <T> Sequence<PsiElement>.lastOrNull(predicate: (PsiElement) -> Boolean): PsiElement? defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'it' @ [137:65] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.maximalParentToClip.<anonymous>[ValueParameterDescriptorImpl]

'minimizedTextRange' @ [137:68] ==> private final fun PsiElement.minimizedTextRange(): TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion[SimpleFunctionDescriptorImpl]

'range' @ [137:92] ==> value-parameter range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.maximalParentToClip[ValueParameterDescriptorImpl]

'firstChild' @ [141:30] ==> public final val PsiElement.firstChild: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'siblings' @ [141:42] ==> public fun PsiElement.siblings(forward: Boolean = ..., withItself: Boolean = ...): Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'firstOrNull' @ [141:54] ==> public inline fun <T> Sequence<PsiElement>.firstOrNull(predicate: (PsiElement) -> Boolean): PsiElement? defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'!' @ [141:68] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'canDropElementFromText' @ [141:69] ==> private final fun canDropElementFromText(element: PsiElement): Boolean defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion[SimpleFunctionDescriptorImpl]

'it' @ [141:92] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.minimizedTextRange.<anonymous>[ValueParameterDescriptorImpl]

'range' @ [141:108] ==> public val PsiElement.range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'lastChild' @ [142:29] ==> public final val PsiElement.lastChild: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'siblings' @ [142:39] ==> public fun PsiElement.siblings(forward: Boolean = ..., withItself: Boolean = ...): Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'first' @ [142:65] ==> public inline fun <T> Sequence<PsiElement>.first(predicate: (PsiElement) -> Boolean): PsiElement defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'!' @ [142:73] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'canDropElementFromText' @ [142:74] ==> private final fun canDropElementFromText(element: PsiElement): Boolean defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion[SimpleFunctionDescriptorImpl]

'it' @ [142:97] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.minimizedTextRange.<anonymous>[ValueParameterDescriptorImpl]

'TextRange' @ [143:20] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'firstChild' @ [143:30] ==> val firstChild: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.minimizedTextRange[LocalVariableDescriptor]

'minimizedTextRange' @ [143:41] ==> private final fun PsiElement.minimizedTextRange(): TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion[SimpleFunctionDescriptorImpl]

'start' @ [143:62] ==> public val TextRange.start: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'lastChild' @ [143:69] ==> val lastChild: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.minimizedTextRange[LocalVariableDescriptor]

'minimizedTextRange' @ [143:79] ==> private final fun PsiElement.minimizedTextRange(): TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion[SimpleFunctionDescriptorImpl]

'end' @ [143:100] ==> public val TextRange.end: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'when (element) {
                is PsiWhiteSpace, is PsiComment, is PsiModifierList, is PsiAnnotation -> true

                is PsiJavaToken -> {
                    when (element.tokenType) {
                        // modifiers
                        JavaTokenType.PUBLIC_KEYWORD, JavaTokenType.PROTECTED_KEYWORD, JavaTokenType.PRIVATE_KEYWORD,
                        JavaTokenType.STATIC_KEYWORD, JavaTokenType.ABSTRACT_KEYWORD, JavaTokenType.FINAL_KEYWORD,
                        JavaTokenType.NATIVE_KEYWORD, JavaTokenType.SYNCHRONIZED_KEYWORD, JavaTokenType.STRICTFP_KEYWORD,
                        JavaTokenType.TRANSIENT_KEYWORD, JavaTokenType.VOLATILE_KEYWORD, JavaTokenType.DEFAULT_KEYWORD -> element.getParent() is PsiModifierList

                        JavaTokenType.SEMICOLON -> true

                        else -> false
                    }
                }

                is PsiCodeBlock -> element.getParent() is PsiMethod

                else -> element.firstChild == null
            }' @ [148:20] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean, entry2: Boolean, entry3: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'element' @ [148:26] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.canDropElementFromText[ValueParameterDescriptorImpl]

'when (element.tokenType) {
                        // modifiers
                        JavaTokenType.PUBLIC_KEYWORD, JavaTokenType.PROTECTED_KEYWORD, JavaTokenType.PRIVATE_KEYWORD,
                        JavaTokenType.STATIC_KEYWORD, JavaTokenType.ABSTRACT_KEYWORD, JavaTokenType.FINAL_KEYWORD,
                        JavaTokenType.NATIVE_KEYWORD, JavaTokenType.SYNCHRONIZED_KEYWORD, JavaTokenType.STRICTFP_KEYWORD,
                        JavaTokenType.TRANSIENT_KEYWORD, JavaTokenType.VOLATILE_KEYWORD, JavaTokenType.DEFAULT_KEYWORD -> element.getParent() is PsiModifierList

                        JavaTokenType.SEMICOLON -> true

                        else -> false
                    }' @ [152:21] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean, entry2: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'element' @ [152:27] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.canDropElementFromText[ValueParameterDescriptorImpl]

'tokenType' @ [152:35] ==> public final val PsiJavaToken.tokenType: (IElementType..IElementType?)[MyPropertyDescriptor]

'PUBLIC_KEYWORD' @ [154:39] ==> public final val PUBLIC_KEYWORD: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'PROTECTED_KEYWORD' @ [154:69] ==> public final val PROTECTED_KEYWORD: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'PRIVATE_KEYWORD' @ [154:102] ==> public final val PRIVATE_KEYWORD: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'STATIC_KEYWORD' @ [155:39] ==> public final val STATIC_KEYWORD: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'ABSTRACT_KEYWORD' @ [155:69] ==> public final val ABSTRACT_KEYWORD: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'FINAL_KEYWORD' @ [155:101] ==> public final val FINAL_KEYWORD: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'NATIVE_KEYWORD' @ [156:39] ==> public final val NATIVE_KEYWORD: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'SYNCHRONIZED_KEYWORD' @ [156:69] ==> public final val SYNCHRONIZED_KEYWORD: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'STRICTFP_KEYWORD' @ [156:105] ==> public final val STRICTFP_KEYWORD: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'TRANSIENT_KEYWORD' @ [157:39] ==> public final val TRANSIENT_KEYWORD: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'VOLATILE_KEYWORD' @ [157:72] ==> public final val VOLATILE_KEYWORD: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'DEFAULT_KEYWORD' @ [157:104] ==> public final val DEFAULT_KEYWORD: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'element' @ [157:123] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.canDropElementFromText[ValueParameterDescriptorImpl]

'getParent' @ [157:131] ==> @Contract public abstract fun getParent(): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'SEMICOLON' @ [159:39] ==> public final val SEMICOLON: (IElementType..IElementType?) defined in com.intellij.psi.JavaTokenType[JavaPropertyDescriptor]

'element' @ [165:36] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.canDropElementFromText[ValueParameterDescriptorImpl]

'getParent' @ [165:44] ==> @Contract public abstract fun getParent(): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'element' @ [167:25] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.canDropElementFromText[ValueParameterDescriptorImpl]

'firstChild' @ [167:33] ==> public final val PsiElement.firstChild: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'tryClipSide' @ [172:19] ==> private final fun tryClipSide(element: PsiElement, rangeBound: Int, rangeFunction: PsiElement.() -> TextRange, childrenFunction: PsiElement.() -> Sequence<PsiElement>): Int? defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion[SimpleFunctionDescriptorImpl]

'element' @ [172:31] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipLeftSide[ValueParameterDescriptorImpl]

'leftBound' @ [172:40] ==> value-parameter leftBound: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipLeftSide[ValueParameterDescriptorImpl]

'range' @ [172:53] ==> public val PsiElement.range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'allChildren' @ [172:64] ==> public val PsiElement.allChildren: PsiChildRange defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'Int' @ [175:35] ==> public companion object defined in kotlin.Int[FakeCallableDescriptorForObject]

'MAX_VALUE' @ [175:39] ==> public const final val MAX_VALUE: Int defined in kotlin.Int.Companion[DeserializedPropertyDescriptor]

'this' @ [175:51] ==> <this> defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipRightSide.transform[ReceiverParameterDescriptorImpl]

'TextRange' @ [176:41] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'end' @ [176:51] ==> public val TextRange.end: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'transform' @ [176:55] ==> local final fun Int.transform(): Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipRightSide[SimpleFunctionDescriptorImpl]

'start' @ [176:68] ==> public val TextRange.start: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'transform' @ [176:74] ==> local final fun Int.transform(): Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipRightSide[SimpleFunctionDescriptorImpl]

'tryClipSide' @ [177:20] ==> private final fun tryClipSide(element: PsiElement, rangeBound: Int, rangeFunction: PsiElement.() -> TextRange, childrenFunction: PsiElement.() -> Sequence<PsiElement>): Int? defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion[SimpleFunctionDescriptorImpl]

'element' @ [177:32] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipRightSide[ValueParameterDescriptorImpl]

'rightBound' @ [177:41] ==> value-parameter rightBound: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipRightSide[ValueParameterDescriptorImpl]

'transform' @ [177:52] ==> local final fun Int.transform(): Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipRightSide[SimpleFunctionDescriptorImpl]

'range' @ [177:67] ==> public val PsiElement.range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'transform' @ [177:73] ==> local final fun TextRange.transform(): TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipRightSide[SimpleFunctionDescriptorImpl]

'lastChild' @ [177:90] ==> public final val PsiElement.lastChild: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'siblings' @ [177:100] ==> public fun PsiElement.siblings(forward: Boolean = ..., withItself: Boolean = ...): Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'transform' @ [177:130] ==> local final fun Int.transform(): Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipRightSide[SimpleFunctionDescriptorImpl]

'element' @ [186:17] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipSide[ValueParameterDescriptorImpl]

'firstChild' @ [186:25] ==> public final val PsiElement.firstChild: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'element' @ [188:32] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipSide[ValueParameterDescriptorImpl]

'invoke' @ [188:40] ==> public abstract operator fun PsiElement.invoke(): TextRange defined in kotlin.Function1[FunctionInvokeDescriptor]

'assert' @ [189:13] ==> @InlineOnly public inline fun assert(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'elementRange' @ [189:20] ==> val elementRange: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipSide[LocalVariableDescriptor]

'start' @ [189:33] ==> public val TextRange.start: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'rangeBound' @ [189:41] ==> value-parameter rangeBound: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipSide[ValueParameterDescriptorImpl]

'rangeBound' @ [189:55] ==> value-parameter rangeBound: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipSide[ValueParameterDescriptorImpl]

'elementRange' @ [189:68] ==> val elementRange: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipSide[LocalVariableDescriptor]

'end' @ [189:81] ==> public val TextRange.end: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'elementRange' @ [191:26] ==> val elementRange: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipSide[LocalVariableDescriptor]

'start' @ [191:39] ==> public val TextRange.start: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'element' @ [192:27] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipSide[ValueParameterDescriptorImpl]

'invoke' @ [192:35] ==> public abstract operator fun PsiElement.invoke(): Sequence<PsiElement> defined in kotlin.Function1[FunctionInvokeDescriptor]

'child' @ [193:34] ==> val child: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipSide[LocalVariableDescriptor]

'invoke' @ [193:40] ==> public abstract operator fun PsiElement.invoke(): TextRange defined in kotlin.Function1[FunctionInvokeDescriptor]

'if (childRange.start >= rangeBound) { // we have cut enough already
                    break
                }
                else if (childRange.end <= rangeBound) { // need to drop the whole element
                    if (!canDropElementFromText(child)) return null
                    clipTo = childRange.end
                }
                else { // rangeBound is inside child's range
                    if (child is PsiWhiteSpace) break // no need to cut whitespace - we can leave it as is
                    return tryClipSide(child, rangeBound, rangeFunction, childrenFunction)
                }' @ [195:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'childRange' @ [195:21] ==> val childRange: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipSide[LocalVariableDescriptor]

'start' @ [195:32] ==> public val TextRange.start: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'rangeBound' @ [195:41] ==> value-parameter rangeBound: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipSide[ValueParameterDescriptorImpl]

'if (childRange.end <= rangeBound) { // need to drop the whole element
                    if (!canDropElementFromText(child)) return null
                    clipTo = childRange.end
                }
                else { // rangeBound is inside child's range
                    if (child is PsiWhiteSpace) break // no need to cut whitespace - we can leave it as is
                    return tryClipSide(child, rangeBound, rangeFunction, childrenFunction)
                }' @ [198:22] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'childRange' @ [198:26] ==> val childRange: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipSide[LocalVariableDescriptor]

'end' @ [198:37] ==> public val TextRange.end: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'rangeBound' @ [198:44] ==> value-parameter rangeBound: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipSide[ValueParameterDescriptorImpl]

'!' @ [199:25] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'canDropElementFromText' @ [199:26] ==> private final fun canDropElementFromText(element: PsiElement): Boolean defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion[SimpleFunctionDescriptorImpl]

'child' @ [199:49] ==> val child: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipSide[LocalVariableDescriptor]

'clipTo' @ [200:21] ==> var clipTo: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipSide[LocalVariableDescriptor]

'childRange' @ [200:30] ==> val childRange: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipSide[LocalVariableDescriptor]

'end' @ [200:41] ==> public val TextRange.end: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'child' @ [203:25] ==> val child: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipSide[LocalVariableDescriptor]

'tryClipSide' @ [204:28] ==> private final fun tryClipSide(element: PsiElement, rangeBound: Int, rangeFunction: PsiElement.() -> TextRange, childrenFunction: PsiElement.() -> Sequence<PsiElement>): Int? defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion[SimpleFunctionDescriptorImpl]

'child' @ [204:40] ==> val child: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipSide[LocalVariableDescriptor]

'rangeBound' @ [204:47] ==> value-parameter rangeBound: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipSide[ValueParameterDescriptorImpl]

'rangeFunction' @ [204:59] ==> value-parameter rangeFunction: PsiElement.() -> TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipSide[ValueParameterDescriptorImpl]

'childrenFunction' @ [204:74] ==> value-parameter childrenFunction: PsiElement.() -> Sequence<PsiElement> defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipSide[ValueParameterDescriptorImpl]

'clipTo' @ [208:20] ==> var clipTo: Int defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.tryClipSide[LocalVariableDescriptor]

'file' @ [216:28] ==> value-parameter file: PsiJavaFile defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.collectElementsToConvert[ValueParameterDescriptorImpl]

'elementsInRange' @ [216:33] ==> public fun PsiFile.elementsInRange(range: TextRange): List<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'range' @ [216:49] ==> value-parameter range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.collectElementsToConvert[ValueParameterDescriptorImpl]

'if (elements.isEmpty()) {
                add(fileText.substring(range.start, range.end))
            }
            else {
                add(fileText.substring(range.start, elements.first().range.start))
                elements.forEach {
                    if (shouldExpandToChildren(it))
                        this += it.allChildren.toList()
                    else
                        this += it
                }
                add(fileText.substring(elements.last().range.end, range.end))
            }' @ [217:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Boolean, elseBranch: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Boolean

'elements' @ [217:17] ==> val elements: List<PsiElement> defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.collectElementsToConvert[LocalVariableDescriptor]

'isEmpty' @ [217:26] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'add' @ [218:17] ==> public final fun add(a: String): Boolean defined in org.jetbrains.kotlin.idea.conversion.copy.ElementAndTextList[SimpleFunctionDescriptorImpl]

'fileText' @ [218:21] ==> value-parameter fileText: String defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.collectElementsToConvert[ValueParameterDescriptorImpl]

'substring' @ [218:30] ==> @InlineOnly public inline fun String.substring(startIndex: Int, endIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'range' @ [218:40] ==> value-parameter range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.collectElementsToConvert[ValueParameterDescriptorImpl]

'start' @ [218:46] ==> public val TextRange.start: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'range' @ [218:53] ==> value-parameter range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.collectElementsToConvert[ValueParameterDescriptorImpl]

'end' @ [218:59] ==> public val TextRange.end: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'add' @ [221:17] ==> public final fun add(a: String): Boolean defined in org.jetbrains.kotlin.idea.conversion.copy.ElementAndTextList[SimpleFunctionDescriptorImpl]

'fileText' @ [221:21] ==> value-parameter fileText: String defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.collectElementsToConvert[ValueParameterDescriptorImpl]

'substring' @ [221:30] ==> @InlineOnly public inline fun String.substring(startIndex: Int, endIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'range' @ [221:40] ==> value-parameter range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.collectElementsToConvert[ValueParameterDescriptorImpl]

'start' @ [221:46] ==> public val TextRange.start: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'elements' @ [221:53] ==> val elements: List<PsiElement> defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.collectElementsToConvert[LocalVariableDescriptor]

'first' @ [221:62] ==> public fun <T> List<PsiElement>.first(): PsiElement defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'range' @ [221:70] ==> public val PsiElement.range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'start' @ [221:76] ==> public val TextRange.start: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'elements' @ [222:17] ==> val elements: List<PsiElement> defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.collectElementsToConvert[LocalVariableDescriptor]

'forEach' @ [222:26] ==> @HidesMembers public inline fun <T> Iterable<PsiElement>.forEach(action: (PsiElement) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'if (shouldExpandToChildren(it))
                        this += it.allChildren.toList()
                    else
                        this += it' @ [223:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'shouldExpandToChildren' @ [223:25] ==> private final fun shouldExpandToChildren(element: PsiElement): Boolean defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion[SimpleFunctionDescriptorImpl]

'it' @ [223:48] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.collectElementsToConvert.<anonymous>[ValueParameterDescriptorImpl]

'this' @ [224:25] ==> <this> defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.collectElementsToConvert[ReceiverParameterDescriptorImpl]

'it' @ [224:33] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.collectElementsToConvert.<anonymous>[ValueParameterDescriptorImpl]

'allChildren' @ [224:36] ==> public val PsiElement.allChildren: PsiChildRange defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'toList' @ [224:48] ==> public fun <T> Sequence<PsiElement>.toList(): List<PsiElement> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'this' @ [226:25] ==> <this> defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.collectElementsToConvert[ReceiverParameterDescriptorImpl]

'it' @ [226:33] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.collectElementsToConvert.<anonymous>[ValueParameterDescriptorImpl]

'add' @ [228:17] ==> public final fun add(a: String): Boolean defined in org.jetbrains.kotlin.idea.conversion.copy.ElementAndTextList[SimpleFunctionDescriptorImpl]

'fileText' @ [228:21] ==> value-parameter fileText: String defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.collectElementsToConvert[ValueParameterDescriptorImpl]

'substring' @ [228:30] ==> @InlineOnly public inline fun String.substring(startIndex: Int, endIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'elements' @ [228:40] ==> val elements: List<PsiElement> defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.collectElementsToConvert[LocalVariableDescriptor]

'last' @ [228:49] ==> public fun <T> List<PsiElement>.last(): PsiElement defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'range' @ [228:56] ==> public val PsiElement.range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'end' @ [228:62] ==> public val TextRange.end: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'range' @ [228:67] ==> value-parameter range: TextRange defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.collectElementsToConvert[ValueParameterDescriptorImpl]

'end' @ [228:73] ==> public val TextRange.end: Int defined in org.jetbrains.kotlin.idea.conversion.copy in file RangeUtils.kt[PropertyDescriptorImpl]

'element' @ [233:67] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.shouldExpandToChildren[ValueParameterDescriptorImpl]

'buildString' @ [236:20] ==> @InlineOnly public inline fun buildString(builderAction: StringBuilder /* = StringBuilder */.() -> Unit): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'sourceFile' @ [237:35] ==> value-parameter sourceFile: PsiJavaFile defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.buildImportsAndPackage[ValueParameterDescriptorImpl]

'packageName' @ [237:46] ==> public final var PsiJavaFile.packageName: String[MyPropertyDescriptor]

'!' @ [238:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'packageName' @ [238:22] ==> val packageName: String defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.buildImportsAndPackage.<anonymous>[LocalVariableDescriptor]

'isEmpty' @ [238:34] ==> @InlineOnly public inline fun CharSequence.isEmpty(): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'append' @ [239:21] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'packageName' @ [239:38] ==> val packageName: String defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.buildImportsAndPackage.<anonymous>[LocalVariableDescriptor]

'sourceFile' @ [242:34] ==> value-parameter sourceFile: PsiJavaFile defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.buildImportsAndPackage[ValueParameterDescriptorImpl]

'importList' @ [242:45] ==> public final val PsiJavaFile.importList: PsiImportList?[MyPropertyDescriptor]

'importList' @ [243:21] ==> val importList: PsiImportList? defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.buildImportsAndPackage.<anonymous>[LocalVariableDescriptor]

'importList' @ [244:36] ==> val importList: PsiImportList? defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.buildImportsAndPackage.<anonymous>[LocalVariableDescriptor]

'importStatements' @ [244:47] ==> public final val PsiImportList.importStatements: (Array<(PsiImportStatement..PsiImportStatement?)>..Array<out (PsiImportStatement..PsiImportStatement?)>)[MyPropertyDescriptor]

'import' @ [245:45] ==> val import: (PsiImportStatement..PsiImportStatement?) defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.buildImportsAndPackage.<anonymous>[LocalVariableDescriptor]

'qualifiedName' @ [245:52] ==> public final val PsiImportStatement.qualifiedName: String?[MyPropertyDescriptor]

'if (import.isOnDemand) {
                            append("import $qualifiedName.*\n")
                        }
                        else {
                            val fqName = FqNameUnsafe(qualifiedName)
                            // skip explicit imports of platform classes mapped into Kotlin classes
                            if (fqName.isSafe && JavaToKotlinClassMap.isJavaPlatformClass(fqName.toSafe())) continue
                            append("import $qualifiedName\n")
                        }' @ [246:25] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (StringBuilder..StringBuilder?), elseBranch: (StringBuilder..StringBuilder?)): (StringBuilder..StringBuilder?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (java.lang.StringBuilder..java.lang.StringBuilder?)

'import' @ [246:29] ==> val import: (PsiImportStatement..PsiImportStatement?) defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.buildImportsAndPackage.<anonymous>[LocalVariableDescriptor]

'isOnDemand' @ [246:36] ==> public final val PsiImportStatement.isOnDemand: Boolean[MyPropertyDescriptor]

'append' @ [247:29] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'qualifiedName' @ [247:45] ==> val qualifiedName: String defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.buildImportsAndPackage.<anonymous>[LocalVariableDescriptor]

'FqNameUnsafe' @ [250:42] ==> public constructor FqNameUnsafe(@NotNull p0: String) defined in org.jetbrains.kotlin.name.FqNameUnsafe[JavaClassConstructorDescriptor]

'qualifiedName' @ [250:55] ==> val qualifiedName: String defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.buildImportsAndPackage.<anonymous>[LocalVariableDescriptor]

'fqName' @ [252:33] ==> val fqName: FqNameUnsafe defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.buildImportsAndPackage.<anonymous>[LocalVariableDescriptor]

'isSafe' @ [252:40] ==> public final val FqNameUnsafe.isSafe: Boolean[MyPropertyDescriptor]

'JavaToKotlinClassMap' @ [252:50] ==> public object JavaToKotlinClassMap : PlatformToKotlinClassMap defined in org.jetbrains.kotlin.platform[FakeCallableDescriptorForObject]

'isJavaPlatformClass' @ [252:71] ==> public final fun isJavaPlatformClass(fqName: FqName): Boolean defined in org.jetbrains.kotlin.platform.JavaToKotlinClassMap[DeserializedSimpleFunctionDescriptor]

'fqName' @ [252:91] ==> val fqName: FqNameUnsafe defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.buildImportsAndPackage.<anonymous>[LocalVariableDescriptor]

'toSafe' @ [252:98] ==> @NotNull public open fun toSafe(): FqName defined in org.jetbrains.kotlin.name.FqNameUnsafe[JavaMethodDescriptor]

'append' @ [253:29] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'qualifiedName' @ [253:45] ==> val qualifiedName: String defined in org.jetbrains.kotlin.idea.conversion.copy.DataForConversion.Companion.buildImportsAndPackage.<anonymous>[LocalVariableDescriptor]

