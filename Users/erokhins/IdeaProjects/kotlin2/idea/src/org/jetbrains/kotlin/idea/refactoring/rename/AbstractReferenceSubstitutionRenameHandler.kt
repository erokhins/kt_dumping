'MemberInplaceRenameHandler' @ [38:54] ==> public constructor MemberInplaceRenameHandler() defined in com.intellij.refactoring.rename.inplace.MemberInplaceRenameHandler[JavaClassConstructorDescriptor]

'PsiElementRenameHandler' @ [39:5] ==> public constructor PsiElementRenameHandler() defined in com.intellij.refactoring.rename.PsiElementRenameHandler[JavaClassConstructorDescriptor]

'file' @ [42:34] ==> value-parameter file: PsiFile defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.Companion.getReferenceExpression[ValueParameterDescriptorImpl]

'findElementAt' @ [42:39] ==> @Nullable @Contract public abstract fun findElementAt(p0: Int): PsiElement? defined in com.intellij.psi.PsiFile[JavaMethodDescriptor]

'offset' @ [42:53] ==> value-parameter offset: Int defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.Companion.getReferenceExpression[ValueParameterDescriptorImpl]

'elementAtCaret' @ [43:17] ==> var elementAtCaret: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.Companion.getReferenceExpression[LocalVariableDescriptor]

'node' @ [43:32] ==> public final val PsiElement.node: (ASTNode..ASTNode?)[MyPropertyDescriptor]

'elementType' @ [43:38] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'AT' @ [43:62] ==> public final val AT: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'elementAtCaret' @ [44:17] ==> var elementAtCaret: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.Companion.getReferenceExpression[LocalVariableDescriptor]

'elementAtCaret' @ [45:17] ==> var elementAtCaret: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.Companion.getReferenceExpression[LocalVariableDescriptor]

'?:' @ [45:34] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: PsiElement?, right: PsiElement): PsiElement[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> PsiElement

'getElementAtOffsetIgnoreWhitespaceAfter' @ [45:51] ==> @Nullable public open fun getElementAtOffsetIgnoreWhitespaceAfter(@NotNull file: PsiFile, offset: Int): PsiElement? defined in org.jetbrains.kotlin.idea.codeInsight.CodeInsightUtils[JavaMethodDescriptor]

'file' @ [45:91] ==> value-parameter file: PsiFile defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.Companion.getReferenceExpression[ValueParameterDescriptorImpl]

'offset' @ [45:97] ==> value-parameter offset: Int defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.Companion.getReferenceExpression[ValueParameterDescriptorImpl]

'offset' @ [46:21] ==> value-parameter offset: Int defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.Companion.getReferenceExpression[ValueParameterDescriptorImpl]

'elementAtCaret' @ [46:31] ==> var elementAtCaret: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.Companion.getReferenceExpression[LocalVariableDescriptor]

'endOffset' @ [46:46] ==> public val PsiElement.endOffset: Int defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'elementAtCaret' @ [48:20] ==> var elementAtCaret: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.Companion.getReferenceExpression[LocalVariableDescriptor]

'getNonStrictParentOfType' @ [48:35] ==> public inline fun <reified T : PsiElement> PsiElement.getNonStrictParentOfType(): KtSimpleNameExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtSimpleNameExpression

'?:' @ [52:25] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: Caret?, right: Caret): Caret[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> Caret

'CARET' @ [52:40] ==> public final val CARET: (DataKey<(Caret..Caret?)>..DataKey<(Caret..Caret?)>?) defined in com.intellij.openapi.actionSystem.CommonDataKeys[JavaPropertyDescriptor]

'getData' @ [52:46] ==> @Nullable public open fun getData(@NotNull p0: DataContext): Caret? defined in com.intellij.openapi.actionSystem.DataKey[JavaMethodDescriptor]

'dataContext' @ [52:54] ==> value-parameter dataContext: DataContext defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.Companion.getReferenceExpression[ValueParameterDescriptorImpl]

'?:' @ [53:26] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtFile?, right: KtFile): KtFile[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtFile

'PSI_FILE' @ [53:41] ==> public final val PSI_FILE: (DataKey<(PsiFile..PsiFile?)>..DataKey<(PsiFile..PsiFile?)>?) defined in com.intellij.openapi.actionSystem.CommonDataKeys[JavaPropertyDescriptor]

'getData' @ [53:50] ==> @Nullable public open fun getData(@NotNull p0: DataContext): PsiFile? defined in com.intellij.openapi.actionSystem.DataKey[JavaMethodDescriptor]

'dataContext' @ [53:58] ==> value-parameter dataContext: DataContext defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.Companion.getReferenceExpression[ValueParameterDescriptorImpl]

'getReferenceExpression' @ [54:20] ==> public final fun getReferenceExpression(file: PsiFile, offset: Int): KtSimpleNameExpression? defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.Companion[SimpleFunctionDescriptorImpl]

'ktFile' @ [54:43] ==> val ktFile: KtFile defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.Companion.getReferenceExpression[LocalVariableDescriptor]

'caret' @ [54:51] ==> val caret: Caret defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.Companion.getReferenceExpression[LocalVariableDescriptor]

'offset' @ [54:57] ==> public final val Caret.offset: Int[MyPropertyDescriptor]

'!=' @ [61:16] ==> public open fun equals(other: Any?): Boolean defined in com.intellij.openapi.editor.Editor[DeserializedSimpleFunctionDescriptor]

'EDITOR' @ [61:31] ==> public final val EDITOR: (DataKey<(Editor..Editor?)>..DataKey<(Editor..Editor?)>?) defined in com.intellij.openapi.actionSystem.CommonDataKeys[JavaPropertyDescriptor]

'getData' @ [61:38] ==> @Nullable public open fun getData(@NotNull p0: DataContext): Editor? defined in com.intellij.openapi.actionSystem.DataKey[JavaMethodDescriptor]

'dataContext' @ [61:46] ==> value-parameter dataContext: DataContext defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.isAvailableOnDataContext[ValueParameterDescriptorImpl]

'getElementToRename' @ [61:70] ==> protected abstract fun getElementToRename(dataContext: DataContext): PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler[SimpleFunctionDescriptorImpl]

'dataContext' @ [61:89] ==> value-parameter dataContext: DataContext defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.isAvailableOnDataContext[ValueParameterDescriptorImpl]

'getElementToRename' @ [65:31] ==> protected abstract fun getElementToRename(dataContext: DataContext): PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler[SimpleFunctionDescriptorImpl]

'dataContext' @ [65:50] ==> value-parameter dataContext: DataContext defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.invoke[ValueParameterDescriptorImpl]

'DataContext' @ [66:31] ==> public fun DataContext(function: ((String..String?)) -> Any?): DataContext defined in com.intellij.openapi.actionSystem[SamConstructorDescriptorImpl]

'PSI_ELEMENT' @ [67:32] ==> public final val PSI_ELEMENT: (DataKey<(PsiElement..PsiElement?)>..DataKey<(PsiElement..PsiElement?)>?) defined in com.intellij.openapi.actionSystem.CommonDataKeys[JavaPropertyDescriptor]

'`is`' @ [67:44] ==> public final fun `is`(p0: (String..String?)): Boolean defined in com.intellij.openapi.actionSystem.DataKey[JavaMethodDescriptor]

'id' @ [67:49] ==> value-parameter id: (String..String?) defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.invoke.<anonymous>[ValueParameterDescriptorImpl]

'elementToRename' @ [67:73] ==> val elementToRename: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.invoke[LocalVariableDescriptor]

'dataContext' @ [68:13] ==> value-parameter dataContext: DataContext defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.invoke[ValueParameterDescriptorImpl]

'getData' @ [68:25] ==> @Nullable public abstract fun getData(@NonNls p0: (String..String?)): Any? defined in com.intellij.openapi.actionSystem.DataContext[JavaMethodDescriptor]

'id' @ [68:33] ==> value-parameter id: (String..String?) defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.invoke.<anonymous>[ValueParameterDescriptorImpl]

'if (!ApplicationManager.getApplication().isUnitTestMode && delegateHandler.isAvailableOnDataContext(wrappingContext)) {
            delegateHandler.invoke(project, editor, file, wrappingContext)
        }
        else {
            super.invoke(project, editor, file, wrappingContext)
        }' @ [71:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'!' @ [71:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'getApplication' @ [71:33] ==> public open fun getApplication(): (Application..Application?) defined in com.intellij.openapi.application.ApplicationManager[JavaMethodDescriptor]

'isUnitTestMode' @ [71:50] ==> public final val Application.isUnitTestMode: Boolean[MyPropertyDescriptor]

'delegateHandler' @ [71:68] ==> private final val delegateHandler: RenameHandler defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler[PropertyDescriptorImpl]

'isAvailableOnDataContext' @ [71:84] ==> public abstract fun isAvailableOnDataContext(p0: (DataContext..DataContext?)): Boolean defined in com.intellij.refactoring.rename.RenameHandler[JavaMethodDescriptor]

'wrappingContext' @ [71:109] ==> val wrappingContext: DataContext defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.invoke[LocalVariableDescriptor]

'delegateHandler' @ [72:13] ==> private final val delegateHandler: RenameHandler defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler[PropertyDescriptorImpl]

'invoke' @ [72:29] ==> public abstract fun invoke(@NotNull p0: Project, p1: (Editor..Editor?), p2: (PsiFile..PsiFile?), p3: (DataContext..DataContext?)): Unit defined in com.intellij.refactoring.rename.RenameHandler[JavaMethodDescriptor]

'project' @ [72:36] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.invoke[ValueParameterDescriptorImpl]

'editor' @ [72:45] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.invoke[ValueParameterDescriptorImpl]

'file' @ [72:53] ==> value-parameter file: PsiFile? defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.invoke[ValueParameterDescriptorImpl]

'wrappingContext' @ [72:59] ==> val wrappingContext: DataContext defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.invoke[LocalVariableDescriptor]

'super' @ [75:13] ==> <this> defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler[LazyClassReceiverParameterDescriptor]

'invoke' @ [75:19] ==> public open fun invoke(@NotNull p0: Project, p1: (Editor..Editor?), p2: (PsiFile..PsiFile?), p3: (DataContext..DataContext?)): Unit defined in com.intellij.refactoring.rename.PsiElementRenameHandler[JavaMethodDescriptor]

'project' @ [75:26] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.invoke[ValueParameterDescriptorImpl]

'editor' @ [75:35] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.invoke[ValueParameterDescriptorImpl]

'file' @ [75:43] ==> value-parameter file: PsiFile? defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.invoke[ValueParameterDescriptorImpl]

'wrappingContext' @ [75:49] ==> val wrappingContext: DataContext defined in org.jetbrains.kotlin.idea.refactoring.rename.AbstractReferenceSubstitutionRenameHandler.invoke[LocalVariableDescriptor]

