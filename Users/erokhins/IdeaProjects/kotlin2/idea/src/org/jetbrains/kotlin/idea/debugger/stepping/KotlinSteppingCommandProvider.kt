'JvmSteppingCommandProvider' @ [63:39] ==> public constructor JvmSteppingCommandProvider() defined in com.intellij.debugger.impl.JvmSteppingCommandProvider[JavaClassConstructorDescriptor]

'suspendContext' @ [69:13] ==> value-parameter suspendContext: SuspendContextImpl? defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[ValueParameterDescriptorImpl]

'suspendContext' @ [69:39] ==> value-parameter suspendContext: SuspendContextImpl? defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[ValueParameterDescriptorImpl]

'isResumed' @ [69:54] ==> public final val SuspendContextImpl.isResumed: Boolean[MyPropertyDescriptor]

'suspendContext' @ [71:30] ==> value-parameter suspendContext: SuspendContextImpl? defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[ValueParameterDescriptorImpl]

'debugProcess' @ [71:45] ==> public final val SuspendContextImpl.debugProcess: DebugProcessImpl[MyPropertyDescriptor]

'debuggerContext' @ [71:58] ==> public final val DebugProcessImpl.debuggerContext: DebuggerContextImpl[MyPropertyDescriptor]

'sourcePosition' @ [71:74] ==> public final val DebuggerContextImpl.sourcePosition: (SourcePosition..SourcePosition?)[MyPropertyDescriptor]

'getStepOverCommand' @ [72:16] ==> private final fun getStepOverCommand(suspendContext: SuspendContextImpl, ignoreBreakpoints: Boolean, sourcePosition: SourcePosition): DebugProcessImpl.ResumeCommand? defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider[SimpleFunctionDescriptorImpl]

'suspendContext' @ [72:35] ==> value-parameter suspendContext: SuspendContextImpl? defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[ValueParameterDescriptorImpl]

'ignoreBreakpoints' @ [72:51] ==> value-parameter ignoreBreakpoints: Boolean defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[ValueParameterDescriptorImpl]

'sourcePosition' @ [72:70] ==> val sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[LocalVariableDescriptor]

'TestOnly' @ [75:5] ==> public constructor TestOnly() defined in org.jetbrains.annotations.TestOnly[JavaClassConstructorDescriptor]

'getStepOverCommand' @ [81:16] ==> private final fun getStepOverCommand(suspendContext: SuspendContextImpl, ignoreBreakpoints: Boolean, sourcePosition: SourcePosition): DebugProcessImpl.ResumeCommand? defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider[SimpleFunctionDescriptorImpl]

'suspendContext' @ [81:35] ==> value-parameter suspendContext: SuspendContextImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[ValueParameterDescriptorImpl]

'ignoreBreakpoints' @ [81:51] ==> value-parameter ignoreBreakpoints: Boolean defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[ValueParameterDescriptorImpl]

'debuggerContext' @ [81:70] ==> value-parameter debuggerContext: DebuggerContextImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[ValueParameterDescriptorImpl]

'sourcePosition' @ [81:86] ==> public final val DebuggerContextImpl.sourcePosition: (SourcePosition..SourcePosition?)[MyPropertyDescriptor]

'KotlinSourcePosition' @ [88:36] ==> public companion object defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.KotlinSourcePosition[FakeCallableDescriptorForObject]

'create' @ [88:57] ==> public final fun create(sourcePosition: SourcePosition): KotlinSteppingCommandProvider.KotlinSourcePosition? defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.KotlinSourcePosition.Companion[SimpleFunctionDescriptorImpl]

'sourcePosition' @ [88:64] ==> value-parameter sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[ValueParameterDescriptorImpl]

'isSpecialStepOverNeeded' @ [90:13] ==> private final fun isSpecialStepOverNeeded(kotlinSourcePosition: KotlinSteppingCommandProvider.KotlinSourcePosition): Boolean defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider[SimpleFunctionDescriptorImpl]

'kotlinSourcePosition' @ [90:37] ==> val kotlinSourcePosition: KotlinSteppingCommandProvider.KotlinSourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[LocalVariableDescriptor]

'createStepOverCommand' @ [91:43] ==> public open fun createStepOverCommand(suspendContext: (SuspendContextImpl..SuspendContextImpl?), ignoreBreakpoints: Boolean, kotlinSourcePosition: (KotlinSteppingCommandProvider.KotlinSourcePosition..KotlinSteppingCommandProvider.KotlinSourcePosition?)): (DebugProcessImpl.ResumeCommand..DebugProcessImpl.ResumeCommand?) defined in org.jetbrains.kotlin.idea.debugger.stepping.DebuggerSteppingHelper[JavaMethodDescriptor]

'suspendContext' @ [91:65] ==> value-parameter suspendContext: SuspendContextImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[ValueParameterDescriptorImpl]

'ignoreBreakpoints' @ [91:81] ==> value-parameter ignoreBreakpoints: Boolean defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[ValueParameterDescriptorImpl]

'kotlinSourcePosition' @ [91:100] ==> val kotlinSourcePosition: KotlinSteppingCommandProvider.KotlinSourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[LocalVariableDescriptor]

'sourcePosition' @ [94:20] ==> value-parameter sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[ValueParameterDescriptorImpl]

'elementAt' @ [94:35] ==> public final val SourcePosition.elementAt: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'containingFile' @ [94:45] ==> public final val PsiElement.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'suspendContext' @ [95:24] ==> value-parameter suspendContext: SuspendContextImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[ValueParameterDescriptorImpl]

'debugProcess' @ [95:39] ==> public final val SuspendContextImpl.debugProcess: DebugProcessImpl[MyPropertyDescriptor]

'invokeInManagerThread' @ [95:52] ==> public fun <T : Any> DebugProcessImpl.invokeInManagerThread(f: (DebuggerContextImpl) -> Location?): Location? defined in org.jetbrains.kotlin.idea.debugger[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> Location

'suspendContext' @ [95:76] ==> value-parameter suspendContext: SuspendContextImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[ValueParameterDescriptorImpl]

'frameProxy' @ [95:91] ==> public final val SuspendContextImpl.frameProxy: StackFrameProxyImpl?[MyPropertyDescriptor]

'location' @ [95:103] ==> public open fun location(): (Location..Location?) defined in com.intellij.debugger.jdi.StackFrameProxyImpl[JavaMethodDescriptor]

'isInSuspendMethod' @ [96:13] ==> public fun isInSuspendMethod(location: Location): Boolean defined in org.jetbrains.kotlin.idea.debugger in file debuggerUtil.kt[SimpleFunctionDescriptorImpl]

'location' @ [96:31] ==> val location: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[LocalVariableDescriptor]

'!' @ [96:44] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isOnSuspendReturnOrReenter' @ [96:45] ==> public fun isOnSuspendReturnOrReenter(location: Location): Boolean defined in org.jetbrains.kotlin.idea.debugger in file debuggerUtil.kt[SimpleFunctionDescriptorImpl]

'location' @ [96:72] ==> val location: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[LocalVariableDescriptor]

'!' @ [96:85] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isLastLineLocationInMethod' @ [96:86] ==> public fun isLastLineLocationInMethod(location: Location): Boolean defined in org.jetbrains.kotlin.idea.debugger in file debuggerUtil.kt[SimpleFunctionDescriptorImpl]

'location' @ [96:113] ==> val location: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[LocalVariableDescriptor]

'createStepOverCommandWithCustomFilter' @ [97:43] ==> public open fun createStepOverCommandWithCustomFilter(suspendContext: (SuspendContextImpl..SuspendContextImpl?), ignoreBreakpoints: Boolean, methodFilter: (KotlinSuspendCallStepOverFilter..KotlinSuspendCallStepOverFilter?)): (DebugProcessImpl.StepOverCommand..DebugProcessImpl.StepOverCommand?) defined in org.jetbrains.kotlin.idea.debugger.stepping.DebugProcessImplHelper[JavaMethodDescriptor]

'suspendContext' @ [98:21] ==> value-parameter suspendContext: SuspendContextImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[ValueParameterDescriptorImpl]

'ignoreBreakpoints' @ [98:37] ==> value-parameter ignoreBreakpoints: Boolean defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[ValueParameterDescriptorImpl]

'KotlinSuspendCallStepOverFilter' @ [98:56] ==> public constructor KotlinSuspendCallStepOverFilter(line: Int, file: PsiFile, ignoreBreakpoints: Boolean) defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSuspendCallStepOverFilter[ClassConstructorDescriptorImpl]

'sourcePosition' @ [98:88] ==> value-parameter sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[ValueParameterDescriptorImpl]

'line' @ [98:103] ==> public final val SourcePosition.line: Int[MyPropertyDescriptor]

'file' @ [98:109] ==> val file: (PsiFile..PsiFile?) defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[LocalVariableDescriptor]

'ignoreBreakpoints' @ [98:115] ==> value-parameter ignoreBreakpoints: Boolean defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOverCommand[ValueParameterDescriptorImpl]

'sourcePosition' @ [108:28] ==> value-parameter sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.KotlinSourcePosition.Companion.create[ValueParameterDescriptorImpl]

'file' @ [108:43] ==> public final val SourcePosition.file: PsiFile[MyPropertyDescriptor]

'sourcePosition' @ [109:21] ==> value-parameter sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.KotlinSourcePosition.Companion.create[ValueParameterDescriptorImpl]

'line' @ [109:36] ==> public final val SourcePosition.line: Int[MyPropertyDescriptor]

'sourcePosition' @ [111:42] ==> value-parameter sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.KotlinSourcePosition.Companion.create[ValueParameterDescriptorImpl]

'elementAt' @ [111:57] ==> public final val SourcePosition.elementAt: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parents' @ [111:67] ==> public val PsiElement.parents: Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'filterIsInstance' @ [112:51] ==> public inline fun <reified R> Sequence<*>.filterIsInstance(): Sequence<KtNamedFunction> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified R> -> KtNamedFunction

'firstOrNull' @ [113:51] ==> public inline fun <T> Sequence<KtNamedFunction>.firstOrNull(predicate: (KtNamedFunction) -> Boolean): KtNamedFunction? defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtNamedFunction

'!' @ [113:65] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'it' @ [113:66] ==> value-parameter it: KtNamedFunction defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.KotlinSourcePosition.Companion.create.<anonymous>[ValueParameterDescriptorImpl]

'isLocal' @ [113:69] ==> public final val KtNamedFunction.isLocal: Boolean[MyPropertyDescriptor]

'containingFunction' @ [115:39] ==> val containingFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.KotlinSourcePosition.Companion.create[LocalVariableDescriptor]

'getLineNumber' @ [115:58] ==> public fun PsiElement.getLineNumber(start: Boolean = ...): Int defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'containingFunction' @ [116:37] ==> val containingFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.KotlinSourcePosition.Companion.create[LocalVariableDescriptor]

'getLineNumber' @ [116:56] ==> public fun PsiElement.getLineNumber(start: Boolean = ...): Int defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'startLineNumber' @ [117:21] ==> val startLineNumber: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.KotlinSourcePosition.Companion.create[LocalVariableDescriptor]

'endLineNumber' @ [117:39] ==> val endLineNumber: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.KotlinSourcePosition.Companion.create[LocalVariableDescriptor]

'startLineNumber' @ [119:34] ==> val startLineNumber: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.KotlinSourcePosition.Companion.create[LocalVariableDescriptor]

'endLineNumber' @ [119:51] ==> val endLineNumber: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.KotlinSourcePosition.Companion.create[LocalVariableDescriptor]

'KotlinSourcePosition' @ [121:24] ==> public constructor KotlinSourcePosition(file: KtFile, function: KtNamedFunction, linesRange: IntRange, sourcePosition: SourcePosition) defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.KotlinSourcePosition[ClassConstructorDescriptorImpl]

'file' @ [121:45] ==> val file: KtFile defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.KotlinSourcePosition.Companion.create[LocalVariableDescriptor]

'containingFunction' @ [121:51] ==> val containingFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.KotlinSourcePosition.Companion.create[LocalVariableDescriptor]

'linesRange' @ [121:71] ==> val linesRange: IntRange defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.KotlinSourcePosition.Companion.create[LocalVariableDescriptor]

'sourcePosition' @ [121:83] ==> value-parameter sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.KotlinSourcePosition.Companion.create[ValueParameterDescriptorImpl]

'kotlinSourcePosition' @ [127:30] ==> value-parameter kotlinSourcePosition: KotlinSteppingCommandProvider.KotlinSourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.isSpecialStepOverNeeded[ValueParameterDescriptorImpl]

'sourcePosition' @ [127:51] ==> public final val sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.KotlinSourcePosition[PropertyDescriptorImpl]

'getInlineFunctionCallsIfAny' @ [129:36] ==> private fun getInlineFunctionCallsIfAny(sourcePosition: SourcePosition): List<KtCallExpression> defined in org.jetbrains.kotlin.idea.debugger.stepping[SimpleFunctionDescriptorImpl]

'sourcePosition' @ [129:64] ==> val sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.isSpecialStepOverNeeded[LocalVariableDescriptor]

'isNotEmpty' @ [129:80] ==> @InlineOnly public inline fun <T> Collection<KtCallExpression>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtCallExpression

'hasInlineCallsOnLine' @ [130:13] ==> val hasInlineCallsOnLine: Boolean defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.isSpecialStepOverNeeded[LocalVariableDescriptor]

'kotlinSourcePosition' @ [135:44] ==> value-parameter kotlinSourcePosition: KotlinSteppingCommandProvider.KotlinSourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.isSpecialStepOverNeeded[ValueParameterDescriptorImpl]

'function' @ [135:65] ==> public final val function: KtNamedFunction defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.KotlinSourcePosition[PropertyDescriptorImpl]

'resolveToDescriptor' @ [135:74] ==> public fun KtDeclaration.resolveToDescriptor(bodyResolveMode: BodyResolveMode = ...): DeclarationDescriptor defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'isInline' @ [136:24] ==> public open fun isInline(@Nullable p0: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.resolve.inline.InlineUtil[JavaMethodDescriptor]

'containingFunctionDescriptor' @ [136:33] ==> val containingFunctionDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.isSpecialStepOverNeeded[LocalVariableDescriptor]

'getInlineArgumentsCallsIfAny' @ [137:45] ==> private fun getInlineArgumentsCallsIfAny(sourcePosition: SourcePosition, declarationDescriptor: DeclarationDescriptor): List<KtCallExpression>? defined in org.jetbrains.kotlin.idea.debugger.stepping[SimpleFunctionDescriptorImpl]

'sourcePosition' @ [137:74] ==> val sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.isSpecialStepOverNeeded[LocalVariableDescriptor]

'containingFunctionDescriptor' @ [137:90] ==> val containingFunctionDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.isSpecialStepOverNeeded[LocalVariableDescriptor]

'inlineArgumentsCallsIfAny' @ [138:17] ==> val inlineArgumentsCallsIfAny: List<KtCallExpression>? defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.isSpecialStepOverNeeded[LocalVariableDescriptor]

'inlineArgumentsCallsIfAny' @ [138:54] ==> val inlineArgumentsCallsIfAny: List<KtCallExpression>? defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.isSpecialStepOverNeeded[LocalVariableDescriptor]

'isNotEmpty' @ [138:80] ==> @InlineOnly public inline fun <T> Collection<KtCallExpression>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtCallExpression

'TestOnly' @ [146:5] ==> public constructor TestOnly() defined in org.jetbrains.annotations.TestOnly[JavaClassConstructorDescriptor]

'getStepOutCommand' @ [148:16] ==> private final fun getStepOutCommand(suspendContext: SuspendContextImpl, sourcePosition: SourcePosition): DebugProcessImpl.ResumeCommand? defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider[SimpleFunctionDescriptorImpl]

'suspendContext' @ [148:34] ==> value-parameter suspendContext: SuspendContextImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOutCommand[ValueParameterDescriptorImpl]

'debugContext' @ [148:50] ==> value-parameter debugContext: DebuggerContextImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOutCommand[ValueParameterDescriptorImpl]

'sourcePosition' @ [148:63] ==> public final val DebuggerContextImpl.sourcePosition: (SourcePosition..SourcePosition?)[MyPropertyDescriptor]

'suspendContext' @ [152:13] ==> value-parameter suspendContext: SuspendContextImpl? defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOutCommand[ValueParameterDescriptorImpl]

'suspendContext' @ [152:39] ==> value-parameter suspendContext: SuspendContextImpl? defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOutCommand[ValueParameterDescriptorImpl]

'isResumed' @ [152:54] ==> public final val SuspendContextImpl.isResumed: Boolean[MyPropertyDescriptor]

'suspendContext' @ [154:30] ==> value-parameter suspendContext: SuspendContextImpl? defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOutCommand[ValueParameterDescriptorImpl]

'debugProcess' @ [154:45] ==> public final val SuspendContextImpl.debugProcess: DebugProcessImpl[MyPropertyDescriptor]

'debuggerContext' @ [154:58] ==> public final val DebugProcessImpl.debuggerContext: DebuggerContextImpl[MyPropertyDescriptor]

'sourcePosition' @ [154:74] ==> public final val DebuggerContextImpl.sourcePosition: (SourcePosition..SourcePosition?)[MyPropertyDescriptor]

'getStepOutCommand' @ [155:16] ==> private final fun getStepOutCommand(suspendContext: SuspendContextImpl, sourcePosition: SourcePosition): DebugProcessImpl.ResumeCommand? defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider[SimpleFunctionDescriptorImpl]

'suspendContext' @ [155:34] ==> value-parameter suspendContext: SuspendContextImpl? defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOutCommand[ValueParameterDescriptorImpl]

'sourcePosition' @ [155:50] ==> val sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOutCommand[LocalVariableDescriptor]

'sourcePosition' @ [159:20] ==> value-parameter sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOutCommand[ValueParameterDescriptorImpl]

'file' @ [159:35] ==> public final val SourcePosition.file: PsiFile[MyPropertyDescriptor]

'sourcePosition' @ [160:13] ==> value-parameter sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOutCommand[ValueParameterDescriptorImpl]

'line' @ [160:28] ==> public final val SourcePosition.line: Int[MyPropertyDescriptor]

'file' @ [162:31] ==> val file: KtFile defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOutCommand[LocalVariableDescriptor]

'getLineStartOffset' @ [162:36] ==> public fun PsiFile.getLineStartOffset(line: Int): Int? defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'sourcePosition' @ [162:55] ==> value-parameter sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOutCommand[ValueParameterDescriptorImpl]

'line' @ [162:70] ==> public final val SourcePosition.line: Int[MyPropertyDescriptor]

'getInlineFunctionsIfAny' @ [164:31] ==> private fun getInlineFunctionsIfAny(file: KtFile, offset: Int): List<KtNamedFunction> defined in org.jetbrains.kotlin.idea.debugger.stepping[SimpleFunctionDescriptorImpl]

'file' @ [164:55] ==> val file: KtFile defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOutCommand[LocalVariableDescriptor]

'lineStartOffset' @ [164:61] ==> val lineStartOffset: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOutCommand[LocalVariableDescriptor]

'getInlineArgumentIfAny' @ [165:31] ==> private fun getInlineArgumentIfAny(elementAt: PsiElement?): KtFunctionLiteral? defined in org.jetbrains.kotlin.idea.debugger.stepping in file KotlinSteppingCommandProvider.kt[SimpleFunctionDescriptorImpl]

'sourcePosition' @ [165:54] ==> value-parameter sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOutCommand[ValueParameterDescriptorImpl]

'elementAt' @ [165:69] ==> public final val SourcePosition.elementAt: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'inlineFunctions' @ [167:13] ==> val inlineFunctions: List<KtNamedFunction> defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOutCommand[LocalVariableDescriptor]

'isEmpty' @ [167:29] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'inlinedArgument' @ [167:42] ==> val inlinedArgument: KtFunctionLiteral? defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOutCommand[LocalVariableDescriptor]

'createStepOutCommand' @ [169:39] ==> public open fun createStepOutCommand(suspendContext: (SuspendContextImpl..SuspendContextImpl?), ignoreBreakpoints: Boolean, inlineFunctions: (MutableList<(KtNamedFunction..KtNamedFunction?)>..List<(KtNamedFunction..KtNamedFunction?)>?), inlineArgument: (KtFunctionLiteral..KtFunctionLiteral?)): (DebugProcessImpl.ResumeCommand..DebugProcessImpl.ResumeCommand?) defined in org.jetbrains.kotlin.idea.debugger.stepping.DebuggerSteppingHelper[JavaMethodDescriptor]

'suspendContext' @ [169:60] ==> value-parameter suspendContext: SuspendContextImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOutCommand[ValueParameterDescriptorImpl]

'inlineFunctions' @ [169:82] ==> val inlineFunctions: List<KtNamedFunction> defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOutCommand[LocalVariableDescriptor]

'inlinedArgument' @ [169:99] ==> val inlinedArgument: KtFunctionLiteral? defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.getStepOutCommand[LocalVariableDescriptor]

'this' @ [174:12] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.stepping.contains[ReceiverParameterDescriptorImpl]

'textRange' @ [174:18] ==> public final val PsiElement.textRange: (TextRange..TextRange?)[MyPropertyDescriptor]

'contains' @ [174:29] ==> public open operator fun contains(@NotNull p0: TextRange): Boolean defined in com.intellij.openapi.util.TextRange[JavaMethodDescriptor]

'element' @ [174:38] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.idea.debugger.stepping.contains[ValueParameterDescriptorImpl]

'textRange' @ [174:46] ==> public final val PsiElement.textRange: (TextRange..TextRange?)[MyPropertyDescriptor]

'getInlineFunctionCallsIfAny' @ [178:31] ==> private fun getInlineFunctionCallsIfAny(sourcePosition: SourcePosition): List<KtCallExpression> defined in org.jetbrains.kotlin.idea.debugger.stepping[SimpleFunctionDescriptorImpl]

'sourcePosition' @ [178:59] ==> value-parameter sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineCallFunctionArgumentsIfAny[ValueParameterDescriptorImpl]

'getInlineArgumentsIfAny' @ [179:12] ==> private fun getInlineArgumentsIfAny(inlineFunctionCalls: List<KtCallExpression>): List<KtFunction> defined in org.jetbrains.kotlin.idea.debugger.stepping[SimpleFunctionDescriptorImpl]

'inlineFunctionCalls' @ [179:36] ==> val inlineFunctionCalls: List<KtCallExpression> defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineCallFunctionArgumentsIfAny[LocalVariableDescriptor]

'file' @ [183:21] ==> value-parameter file: KtFile defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineFunctionsIfAny[ValueParameterDescriptorImpl]

'findElementAt' @ [183:26] ==> public open fun findElementAt(p0: Int): PsiElement? defined in org.jetbrains.kotlin.psi.KtFile[JavaMethodDescriptor]

'offset' @ [183:40] ==> value-parameter offset: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineFunctionsIfAny[ValueParameterDescriptorImpl]

'emptyList' @ [183:58] ==> public fun <T> emptyList(): List<KtNamedFunction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtNamedFunction

'elementAt' @ [184:30] ==> val elementAt: PsiElement defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineFunctionsIfAny[LocalVariableDescriptor]

'getParentOfType' @ [184:40] ==> public inline fun <reified T : PsiElement> PsiElement.getParentOfType(strict: Boolean): KtNamedFunction? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtNamedFunction

'emptyList' @ [184:90] ==> public fun <T> emptyList(): List<KtNamedFunction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtNamedFunction

'containingFunction' @ [186:22] ==> val containingFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineFunctionsIfAny[LocalVariableDescriptor]

'resolveToDescriptor' @ [186:41] ==> public fun KtDeclaration.resolveToDescriptor(bodyResolveMode: BodyResolveMode = ...): DeclarationDescriptor defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'!' @ [187:9] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isInline' @ [187:21] ==> public open fun isInline(@Nullable p0: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.resolve.inline.InlineUtil[JavaMethodDescriptor]

'descriptor' @ [187:30] ==> val descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineFunctionsIfAny[LocalVariableDescriptor]

'emptyList' @ [187:50] ==> public fun <T> emptyList(): List<KtNamedFunction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtNamedFunction

'DebuggerUtils' @ [189:12] ==> public object DebuggerUtils defined in org.jetbrains.kotlin.idea.debugger in file DebuggerUtils.kt[FakeCallableDescriptorForObject]

'analyzeElementWithInline' @ [189:26] ==> public final fun analyzeElementWithInline(function: KtNamedFunction, analyzeInlineFunctions: Boolean): Collection<KtElement> defined in org.jetbrains.kotlin.idea.debugger.DebuggerUtils[SimpleFunctionDescriptorImpl]

'containingFunction' @ [189:51] ==> val containingFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineFunctionsIfAny[LocalVariableDescriptor]

'filterIsInstance' @ [189:78] ==> public inline fun <reified R> Iterable<*>.filterIsInstance(): List<KtNamedFunction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified R> -> KtNamedFunction

'inlineFunctionCalls' @ [193:12] ==> value-parameter inlineFunctionCalls: List<KtCallExpression> defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineArgumentsIfAny[ValueParameterDescriptorImpl]

'flatMap' @ [193:32] ==> public inline fun <T, R> Iterable<KtCallExpression>.flatMap(transform: (KtCallExpression) -> Iterable<KtFunction>): List<KtFunction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtCallExpression
    <R> -> KtFunction

'it' @ [194:9] ==> value-parameter it: KtCallExpression defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineArgumentsIfAny.<anonymous>[ValueParameterDescriptorImpl]

'valueArguments' @ [194:12] ==> public final val KtCallExpression.valueArguments: (MutableList<(KtValueArgument..KtValueArgument?)>..List<(KtValueArgument..KtValueArgument?)>)[MyPropertyDescriptor]

'map' @ [195:18] ==> public inline fun <T, R> Iterable<(KtValueArgument..KtValueArgument?)>.map(transform: ((KtValueArgument..KtValueArgument?)) -> KtExpression?): List<KtExpression?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtValueArgument..org.jetbrains.kotlin.psi.KtValueArgument?)
    <R> -> KtExpression?

'filterIsInstance' @ [196:18] ==> public inline fun <reified R> Iterable<*>.filterIsInstance(): List<KtFunction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified R> -> KtFunction

'?:' @ [200:56] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtExpression?, right: KtExpression?): KtExpression?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtExpression?

'it' @ [200:57] ==> value-parameter it: ValueArgument defined in org.jetbrains.kotlin.idea.debugger.stepping.getArgumentExpression[ValueParameterDescriptorImpl]

'getArgumentExpression' @ [200:60] ==> @IfNotParsed public abstract fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.ValueArgument[DeserializedSimpleFunctionDescriptor]

'functionLiteral' @ [200:109] ==> public final val KtLambdaExpression.functionLiteral: KtFunctionLiteral[MyPropertyDescriptor]

'it' @ [200:128] ==> value-parameter it: ValueArgument defined in org.jetbrains.kotlin.idea.debugger.stepping.getArgumentExpression[ValueParameterDescriptorImpl]

'getArgumentExpression' @ [200:131] ==> @IfNotParsed public abstract fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.ValueArgument[DeserializedSimpleFunctionDescriptor]

'declarationDescriptor' @ [203:9] ==> value-parameter declarationDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineArgumentsCallsIfAny[ValueParameterDescriptorImpl]

'declarationDescriptor' @ [205:27] ==> value-parameter declarationDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineArgumentsCallsIfAny[ValueParameterDescriptorImpl]

'valueParameters' @ [205:49] ==> public final val CallableDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'filter' @ [205:65] ==> public inline fun <T> Iterable<(ValueParameterDescriptor..ValueParameterDescriptor?)>.filter(predicate: ((ValueParameterDescriptor..ValueParameterDescriptor?)) -> Boolean): List<(ValueParameterDescriptor..ValueParameterDescriptor?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)

'it' @ [205:74] ==> value-parameter it: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineArgumentsCallsIfAny.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [205:77] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'isFunctionType' @ [205:82] ==> public val KotlinType.isFunctionType: Boolean defined in org.jetbrains.kotlin.builtins[DeserializedPropertyDescriptor]

'toSet' @ [205:99] ==> public fun <T> Iterable<(ValueParameterDescriptor..ValueParameterDescriptor?)>.toSet(): Set<(ValueParameterDescriptor..ValueParameterDescriptor?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)

'valueParameters' @ [207:9] ==> val valueParameters: Set<(ValueParameterDescriptor..ValueParameterDescriptor?)> defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineArgumentsCallsIfAny[LocalVariableDescriptor]

'isEmpty' @ [207:25] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.Set[DeserializedSimpleFunctionDescriptor]

'ktCallExpression' @ [212:23] ==> value-parameter ktCallExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineArgumentsCallsIfAny.isCallOfArgument[ValueParameterDescriptorImpl]

'analyze' @ [212:40] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'PARTIAL' @ [212:64] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'ktCallExpression' @ [213:28] ==> value-parameter ktCallExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineArgumentsCallsIfAny.isCallOfArgument[ValueParameterDescriptorImpl]

'getResolvedCall' @ [213:45] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'context' @ [213:61] ==> val context: BindingContext defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineArgumentsCallsIfAny.isCallOfArgument[LocalVariableDescriptor]

'resolvedCall' @ [215:35] ==> val resolvedCall: VariableAsFunctionResolvedCallImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineArgumentsCallsIfAny.isCallOfArgument[LocalVariableDescriptor]

'variableCall' @ [215:48] ==> public open val variableCall: MutableResolvedCall<VariableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.model.VariableAsFunctionResolvedCallImpl[DeserializedPropertyDescriptor]

'candidateDescriptor' @ [215:61] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> MutableResolvedCall<VariableDescriptor>.candidateDescriptor: VariableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> VariableDescriptor

'candidateDescriptor' @ [217:16] ==> val candidateDescriptor: VariableDescriptor defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineArgumentsCallsIfAny.isCallOfArgument[LocalVariableDescriptor]

'valueParameters' @ [217:39] ==> val valueParameters: Set<(ValueParameterDescriptor..ValueParameterDescriptor?)> defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineArgumentsCallsIfAny[LocalVariableDescriptor]

'findCallsOnPosition' @ [220:12] ==> private fun findCallsOnPosition(sourcePosition: SourcePosition, filter: (KtCallExpression) -> Boolean): List<KtCallExpression> defined in org.jetbrains.kotlin.idea.debugger.stepping[SimpleFunctionDescriptorImpl]

'sourcePosition' @ [220:32] ==> value-parameter sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineArgumentsCallsIfAny[ValueParameterDescriptorImpl]

'expr' @ [225:23] ==> value-parameter expr: KtCallExpression defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineFunctionCallsIfAny.isInlineCall[ValueParameterDescriptorImpl]

'analyze' @ [225:28] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'PARTIAL' @ [225:52] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'expr' @ [226:28] ==> value-parameter expr: KtCallExpression defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineFunctionCallsIfAny.isInlineCall[ValueParameterDescriptorImpl]

'getResolvedCall' @ [226:33] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'context' @ [226:49] ==> val context: BindingContext defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineFunctionCallsIfAny.isInlineCall[LocalVariableDescriptor]

'isInline' @ [227:27] ==> public open fun isInline(@Nullable p0: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.resolve.inline.InlineUtil[JavaMethodDescriptor]

'resolvedCall' @ [227:36] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineFunctionCallsIfAny.isInlineCall[LocalVariableDescriptor]

'resultingDescriptor' @ [227:49] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.resultingDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'findCallsOnPosition' @ [230:12] ==> private fun findCallsOnPosition(sourcePosition: SourcePosition, filter: (KtCallExpression) -> Boolean): List<KtCallExpression> defined in org.jetbrains.kotlin.idea.debugger.stepping[SimpleFunctionDescriptorImpl]

'sourcePosition' @ [230:32] ==> value-parameter sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineFunctionCallsIfAny[ValueParameterDescriptorImpl]

'sourcePosition' @ [234:16] ==> value-parameter sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition[ValueParameterDescriptorImpl]

'file' @ [234:31] ==> public final val SourcePosition.file: PsiFile[MyPropertyDescriptor]

'emptyList' @ [234:57] ==> public fun <T> emptyList(): List<KtCallExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtCallExpression

'sourcePosition' @ [235:22] ==> value-parameter sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition[ValueParameterDescriptorImpl]

'line' @ [235:37] ==> public final val SourcePosition.line: Int[MyPropertyDescriptor]

'findElementAtLine' @ [237:23] ==> public fun findElementAtLine(file: KtFile, line: Int): PsiElement? defined in org.jetbrains.kotlin.idea.debugger in file debuggerUtil.kt[SimpleFunctionDescriptorImpl]

'file' @ [237:41] ==> val file: KtFile defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition[LocalVariableDescriptor]

'lineNumber' @ [237:47] ==> val lineNumber: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition[LocalVariableDescriptor]

'lineElement' @ [239:9] ==> val lineElement: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition[LocalVariableDescriptor]

'lineElement' @ [240:13] ==> val lineElement: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition[LocalVariableDescriptor]

'findCallByEndToken' @ [241:24] ==> public fun findCallByEndToken(element: PsiElement): KtCallExpression? defined in org.jetbrains.kotlin.idea.debugger in file debuggerUtil.kt[SimpleFunctionDescriptorImpl]

'lineElement' @ [241:43] ==> val lineElement: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition[LocalVariableDescriptor]

'call' @ [242:17] ==> val call: KtCallExpression? defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition[LocalVariableDescriptor]

'invoke' @ [242:33] ==> public abstract operator fun invoke(p1: KtCallExpression): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'call' @ [242:40] ==> val call: KtCallExpression? defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition[LocalVariableDescriptor]

'listOf' @ [243:24] ==> public fun <T> listOf(element: KtCallExpression): List<KtCallExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtCallExpression

'call' @ [243:31] ==> val call: KtCallExpression? defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition[LocalVariableDescriptor]

'emptyList' @ [247:16] ==> public fun <T> emptyList(): List<KtCallExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtCallExpression

'lineElement' @ [250:17] ==> val lineElement: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition[LocalVariableDescriptor]

'startOffset' @ [250:29] ==> public val PsiElement.startOffset: Int defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'lineElement' @ [251:15] ==> val lineElement: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition[LocalVariableDescriptor]

'endOffset' @ [251:27] ==> public val PsiElement.endOffset: Int defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'findElementsOfClassInRange' @ [254:13] ==> @NotNull public open fun findElementsOfClassInRange(@NotNull file: PsiFile, startOffset: Int, endOffset: Int, vararg classes: (Class<out (PsiElement..PsiElement?)>..Class<out (PsiElement..PsiElement?)>?)): (MutableList<(PsiElement..PsiElement?)>..List<(PsiElement..PsiElement?)>) defined in org.jetbrains.kotlin.idea.codeInsight.CodeInsightUtils[JavaMethodDescriptor]

'file' @ [254:40] ==> val file: KtFile defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition[LocalVariableDescriptor]

'start' @ [254:46] ==> val start: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition[LocalVariableDescriptor]

'end' @ [254:53] ==> val end: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition[LocalVariableDescriptor]

'java' @ [254:78] ==> public val <T> KClass<KtExpression>.java: Class<KtExpression> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtExpression

'map' @ [255:14] ==> public inline fun <T, R> Iterable<(PsiElement..PsiElement?)>.map(transform: ((PsiElement..PsiElement?)) -> KtExpression?): List<KtExpression?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)
    <R> -> KtExpression?

'getParentCallIfPresent' @ [255:30] ==> @Nullable public open fun getParentCallIfPresent(@NotNull p0: KtExpression): KtExpression? defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'it' @ [255:53] ==> value-parameter it: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition.<anonymous>[ValueParameterDescriptorImpl]

'filterIsInstance' @ [256:14] ==> public inline fun <reified R> Iterable<*>.filterIsInstance(): List<KtCallExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified R> -> KtCallExpression

'filter' @ [257:14] ==> public inline fun <T> Iterable<KtCallExpression>.filter(predicate: (KtCallExpression) -> Boolean): List<KtCallExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtCallExpression

'invoke' @ [257:23] ==> public abstract operator fun invoke(p1: KtCallExpression): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'it' @ [257:30] ==> value-parameter it: KtCallExpression defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition.<anonymous>[ValueParameterDescriptorImpl]

'toSet' @ [258:14] ==> public fun <T> Iterable<KtCallExpression>.toSet(): Set<KtCallExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtCallExpression

'lineNumber' @ [261:22] ==> val lineNumber: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition[LocalVariableDescriptor]

'lineNumber' @ [261:34] ==> val lineNumber: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition[LocalVariableDescriptor]

'allFilteredCalls' @ [262:12] ==> val allFilteredCalls: Set<KtCallExpression> defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition[LocalVariableDescriptor]

'filter' @ [262:29] ==> public inline fun <T> Iterable<KtCallExpression>.filter(predicate: (KtCallExpression) -> Boolean): List<KtCallExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtCallExpression

'it' @ [263:29] ==> value-parameter it: KtCallExpression defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition.<anonymous>[ValueParameterDescriptorImpl]

'getLineNumber' @ [263:32] ==> public fun PsiElement.getLineNumber(start: Boolean = ...): Int defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'linesRange' @ [263:51] ==> var linesRange: IntRange defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition[LocalVariableDescriptor]

'shouldInclude' @ [264:13] ==> val shouldInclude: Boolean defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition.<anonymous>[LocalVariableDescriptor]

'linesRange' @ [265:13] ==> var linesRange: IntRange defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition[LocalVariableDescriptor]

'..' @ [265:26] ==> public final operator fun rangeTo(other: Int): IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'min' @ [265:31] ==> public open fun min(p0: Int, p1: Int): Int defined in java.lang.Math[JavaMethodDescriptor]

'linesRange' @ [265:35] ==> var linesRange: IntRange defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition[LocalVariableDescriptor]

'start' @ [265:46] ==> public open val start: Int defined in kotlin.ranges.IntRange[DeserializedPropertyDescriptor]

'it' @ [265:53] ==> value-parameter it: KtCallExpression defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition.<anonymous>[ValueParameterDescriptorImpl]

'getLineNumber' @ [265:56] ==> public fun PsiElement.getLineNumber(start: Boolean = ...): Int defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'max' @ [265:79] ==> public open fun max(p0: Int, p1: Int): Int defined in java.lang.Math[JavaMethodDescriptor]

'linesRange' @ [265:83] ==> var linesRange: IntRange defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition[LocalVariableDescriptor]

'endInclusive' @ [265:94] ==> public open val endInclusive: Int defined in kotlin.ranges.IntRange[DeserializedPropertyDescriptor]

'it' @ [265:108] ==> value-parameter it: KtCallExpression defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition.<anonymous>[ValueParameterDescriptorImpl]

'getLineNumber' @ [265:111] ==> public fun PsiElement.getLineNumber(start: Boolean = ...): Int defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'shouldInclude' @ [267:9] ==> val shouldInclude: Boolean defined in org.jetbrains.kotlin.idea.debugger.stepping.findCallsOnPosition.<anonymous>[LocalVariableDescriptor]

'Action' @ [273:23] ==> private constructor Action(position: XSourcePositionImpl? = ..., stepOverInlineData: StepOverFilterData? = ...) defined in org.jetbrains.kotlin.idea.debugger.stepping.Action[ClassConstructorDescriptorImpl]

'debugProcess' @ [275:17] ==> value-parameter debugProcess: DebugProcessImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.STEP_OVER.apply[ValueParameterDescriptorImpl]

'createStepOverCommand' @ [275:30] ==> @NotNull public open fun createStepOverCommand(p0: (SuspendContextImpl..SuspendContextImpl?), p1: Boolean): DebugProcessImpl.ResumeCommand defined in com.intellij.debugger.engine.DebugProcessImpl[JavaMethodDescriptor]

'suspendContext' @ [275:52] ==> value-parameter suspendContext: SuspendContextImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.STEP_OVER.apply[ValueParameterDescriptorImpl]

'ignoreBreakpoints' @ [275:68] ==> value-parameter ignoreBreakpoints: Boolean defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.STEP_OVER.apply[ValueParameterDescriptorImpl]

'contextAction' @ [275:87] ==> public open fun contextAction(@NotNull p0: SuspendContextImpl): Unit defined in com.intellij.debugger.engine.DebugProcessImpl.ResumeCommand[JavaMethodDescriptor]

'suspendContext' @ [275:101] ==> value-parameter suspendContext: SuspendContextImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.STEP_OVER.apply[ValueParameterDescriptorImpl]

'Action' @ [277:22] ==> private constructor Action(position: XSourcePositionImpl? = ..., stepOverInlineData: StepOverFilterData? = ...) defined in org.jetbrains.kotlin.idea.debugger.stepping.Action[ClassConstructorDescriptorImpl]

'debugProcess' @ [279:13] ==> value-parameter debugProcess: DebugProcessImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.STEP_OUT.apply[ValueParameterDescriptorImpl]

'createStepOutCommand' @ [279:26] ==> @NotNull public open fun createStepOutCommand(p0: (SuspendContextImpl..SuspendContextImpl?)): DebugProcessImpl.ResumeCommand defined in com.intellij.debugger.engine.DebugProcessImpl[JavaMethodDescriptor]

'suspendContext' @ [279:47] ==> value-parameter suspendContext: SuspendContextImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.STEP_OUT.apply[ValueParameterDescriptorImpl]

'contextAction' @ [279:63] ==> public open fun contextAction(@NotNull p0: SuspendContextImpl): Unit defined in com.intellij.debugger.engine.DebugProcessImpl.ResumeCommand[JavaMethodDescriptor]

'suspendContext' @ [279:77] ==> value-parameter suspendContext: SuspendContextImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.STEP_OUT.apply[ValueParameterDescriptorImpl]

'Action' @ [281:58] ==> private constructor Action(position: XSourcePositionImpl? = ..., stepOverInlineData: StepOverFilterData? = ...) defined in org.jetbrains.kotlin.idea.debugger.stepping.Action[ClassConstructorDescriptorImpl]

'position' @ [281:65] ==> value-parameter position: XSourcePositionImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.RUN_TO_CURSOR.<init>[ValueParameterDescriptorImpl]

'runReadAction' @ [283:20] ==> public fun <T> runReadAction(action: () -> DebugProcessImpl.ResumeCommand): DebugProcessImpl.ResumeCommand defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ResumeCommand

'debugProcess' @ [284:17] ==> value-parameter debugProcess: DebugProcessImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.RUN_TO_CURSOR.apply[ValueParameterDescriptorImpl]

'createRunToCursorCommand' @ [284:30] ==> @NotNull public open fun createRunToCursorCommand(p0: (SuspendContextImpl..SuspendContextImpl?), @NotNull p1: XSourcePosition, p2: Boolean): DebugProcessImpl.ResumeCommand defined in com.intellij.debugger.engine.DebugProcessImpl[JavaMethodDescriptor]

'suspendContext' @ [284:55] ==> value-parameter suspendContext: SuspendContextImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.RUN_TO_CURSOR.apply[ValueParameterDescriptorImpl]

'position' @ [284:71] ==> public final val position: XSourcePositionImpl? defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.RUN_TO_CURSOR[PropertyDescriptorImpl]

'ignoreBreakpoints' @ [284:83] ==> value-parameter ignoreBreakpoints: Boolean defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.RUN_TO_CURSOR.apply[ValueParameterDescriptorImpl]

'contextAction' @ [285:15] ==> public open fun contextAction(@NotNull p0: SuspendContextImpl): Unit defined in com.intellij.debugger.engine.DebugProcessImpl.ResumeCommand[JavaMethodDescriptor]

'suspendContext' @ [285:29] ==> value-parameter suspendContext: SuspendContextImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.RUN_TO_CURSOR.apply[ValueParameterDescriptorImpl]

'Action' @ [288:71] ==> private constructor Action(position: XSourcePositionImpl? = ..., stepOverInlineData: StepOverFilterData? = ...) defined in org.jetbrains.kotlin.idea.debugger.stepping.Action[ClassConstructorDescriptorImpl]

'stepOverInlineData' @ [288:99] ==> value-parameter stepOverInlineData: StepOverFilterData defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.STEP_OVER_INLINED.<init>[ValueParameterDescriptorImpl]

'KotlinStepActionFactory' @ [290:20] ==> public constructor KotlinStepActionFactory(debuggerProcess: DebugProcessImpl) defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinStepActionFactory[ClassConstructorDescriptorImpl]

'debugProcess' @ [290:44] ==> value-parameter debugProcess: DebugProcessImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.STEP_OVER_INLINED.apply[ValueParameterDescriptorImpl]

'createKotlinStepOverInlineAction' @ [290:58] ==> public final fun createKotlinStepOverInlineAction(smartStepFilter: KotlinMethodFilter): KotlinStepActionFactory.KotlinStepAction defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinStepActionFactory[SimpleFunctionDescriptorImpl]

'KotlinStepOverInlineFilter' @ [291:21] ==> public constructor KotlinStepOverInlineFilter(project: Project, data: StepOverFilterData) defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinStepOverInlineFilter[ClassConstructorDescriptorImpl]

'debugProcess' @ [291:48] ==> value-parameter debugProcess: DebugProcessImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.STEP_OVER_INLINED.apply[ValueParameterDescriptorImpl]

'project' @ [291:61] ==> public final val DebugProcessImpl.project: Project[MyPropertyDescriptor]

'stepOverInlineData' @ [291:70] ==> public final val stepOverInlineData: StepOverFilterData? defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.STEP_OVER_INLINED[PropertyDescriptorImpl]

'contextAction' @ [291:93] ==> public abstract fun contextAction(suspendContext: SuspendContextImpl): Unit defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinStepActionFactory.KotlinStepAction[SimpleFunctionDescriptorImpl]

'suspendContext' @ [291:107] ==> value-parameter suspendContext: SuspendContextImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.STEP_OVER_INLINED.apply[ValueParameterDescriptorImpl]

'runReadAction' @ [308:33] ==> public fun <T> runReadAction(action: () -> List<KtFunction>): List<KtFunction> defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> List<KtFunction>

'getInlineCallFunctionArgumentsIfAny' @ [309:9] ==> private fun getInlineCallFunctionArgumentsIfAny(sourcePosition: SourcePosition): List<KtFunction> defined in org.jetbrains.kotlin.idea.debugger.stepping[SimpleFunctionDescriptorImpl]

'kotlinSourcePosition' @ [309:45] ==> value-parameter kotlinSourcePosition: KotlinSteppingCommandProvider.KotlinSourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'sourcePosition' @ [309:66] ==> public final val sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.KotlinSourcePosition[PropertyDescriptorImpl]

'getStepOverAction' @ [312:12] ==> public fun getStepOverAction(location: Location, sourceFile: KtFile, range: IntRange, inlineFunctionArguments: List<KtElement>, frameProxy: StackFrameProxyImpl, isDexDebug: Boolean): Action defined in org.jetbrains.kotlin.idea.debugger.stepping[SimpleFunctionDescriptorImpl]

'location' @ [312:30] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'kotlinSourcePosition' @ [312:40] ==> value-parameter kotlinSourcePosition: KotlinSteppingCommandProvider.KotlinSourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'file' @ [312:61] ==> public final val file: KtFile defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.KotlinSourcePosition[PropertyDescriptorImpl]

'kotlinSourcePosition' @ [312:67] ==> value-parameter kotlinSourcePosition: KotlinSteppingCommandProvider.KotlinSourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'linesRange' @ [312:88] ==> public final val linesRange: IntRange defined in org.jetbrains.kotlin.idea.debugger.stepping.KotlinSteppingCommandProvider.KotlinSourcePosition[PropertyDescriptorImpl]

'inlineArgumentsToSkip' @ [313:30] ==> val inlineArgumentsToSkip: List<KtFunction> defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[LocalVariableDescriptor]

'frameProxy' @ [313:53] ==> value-parameter frameProxy: StackFrameProxyImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'isDexDebug' @ [313:65] ==> value-parameter isDexDebug: Boolean defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'location' @ [324:5] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'declaringType' @ [324:14] ==> public abstract fun declaringType(): (ReferenceType..ReferenceType?) defined in com.sun.jdi.Location[JavaMethodDescriptor]

'STEP_OVER' @ [324:47] ==> public constructor STEP_OVER() defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.STEP_OVER[ClassConstructorDescriptorImpl]

'sourceFile' @ [326:19] ==> value-parameter sourceFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'project' @ [326:30] ==> public final val KtFile.project: Project[MyPropertyDescriptor]

'location' @ [328:27] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'method' @ [328:36] ==> public abstract fun method(): (Method..Method?) defined in com.sun.jdi.Location[JavaMethodDescriptor]

'allLineLocations' @ [328:45] ==> public abstract fun allLineLocations(): (MutableList<(Location..Location?)>..List<(Location..Location?)>?) defined in com.sun.jdi.Method[JavaMethodDescriptor]

'methodLocations' @ [329:32] ==> val methodLocations: (MutableList<(Location..Location?)>..List<(Location..Location?)>?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[LocalVariableDescriptor]

'keysToMap' @ [329:48] ==> public fun <K, V> Iterable<(Location..Location?)>.keysToMap(value: ((Location..Location?)) -> Pair<Int, KtFile?>): Map<(Location..Location?), Pair<Int, KtFile?>> defined in org.jetbrains.kotlin.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (com.sun.jdi.Location..com.sun.jdi.Location?)
    <V> -> Pair<Int, KtFile?>

'ktLocationInfo' @ [329:60] ==> public fun ktLocationInfo(location: Location, isDexDebug: Boolean, project: Project, preferInlined: Boolean = ..., locationFile: KtFile? = ...): Pair<Int, KtFile?> defined in org.jetbrains.kotlin.idea.debugger[SimpleFunctionDescriptorImpl]

'it' @ [329:75] ==> value-parameter it: (Location..Location?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.<anonymous>[ValueParameterDescriptorImpl]

'isDexDebug' @ [329:79] ==> value-parameter isDexDebug: Boolean defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'project' @ [329:91] ==> val project: Project defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[LocalVariableDescriptor]

'locationsLineAndFile' @ [331:41] ==> val locationsLineAndFile: Map<(Location..Location?), Pair<Int, KtFile?>> defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[LocalVariableDescriptor]

'this' @ [331:62] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.ktLineNumber[ReceiverParameterDescriptorImpl]

'ktLocationInfo' @ [331:71] ==> public fun ktLocationInfo(location: Location, isDexDebug: Boolean, project: Project, preferInlined: Boolean = ..., locationFile: KtFile? = ...): Pair<Int, KtFile?> defined in org.jetbrains.kotlin.idea.debugger[SimpleFunctionDescriptorImpl]

'this' @ [331:86] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.ktLineNumber[ReceiverParameterDescriptorImpl]

'isDexDebug' @ [331:92] ==> value-parameter isDexDebug: Boolean defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'project' @ [331:104] ==> val project: Project defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[LocalVariableDescriptor]

'first' @ [331:120] ==> public final val first: Int defined in kotlin.Pair[DeserializedPropertyDescriptor]

'locationsLineAndFile' @ [333:23] ==> val locationsLineAndFile: Map<(Location..Location?), Pair<Int, KtFile?>> defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[LocalVariableDescriptor]

'this' @ [333:44] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.ktFileName[ReceiverParameterDescriptorImpl]

'ktLocationInfo' @ [333:53] ==> public fun ktLocationInfo(location: Location, isDexDebug: Boolean, project: Project, preferInlined: Boolean = ..., locationFile: KtFile? = ...): Pair<Int, KtFile?> defined in org.jetbrains.kotlin.idea.debugger[SimpleFunctionDescriptorImpl]

'this' @ [333:68] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.ktFileName[ReceiverParameterDescriptorImpl]

'isDexDebug' @ [333:74] ==> value-parameter isDexDebug: Boolean defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'project' @ [333:86] ==> val project: Project defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[LocalVariableDescriptor]

'second' @ [333:102] ==> public final val second: KtFile? defined in kotlin.Pair[DeserializedPropertyDescriptor]

'ktFile' @ [335:16] ==> val ktFile: KtFile? defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.ktFileName[LocalVariableDescriptor]

'name' @ [335:24] ==> public final var KtFile.name: String[MyPropertyDescriptor]

'this' @ [335:32] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.ktFileName[ReceiverParameterDescriptorImpl]

'sourceName' @ [335:37] ==> public abstract fun sourceName(p0: (String..String?)): (String..String?) defined in com.sun.jdi.Location[JavaMethodDescriptor]

'KOTLIN_STRATA_NAME' @ [335:48] ==> public val KOTLIN_STRATA_NAME: String defined in org.jetbrains.kotlin.codegen.inline[DeserializedPropertyDescriptor]

'nextLocation' @ [339:13] ==> value-parameter nextLocation: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.isLocationSuitable[ValueParameterDescriptorImpl]

'method' @ [339:26] ==> public abstract fun method(): (Method..Method?) defined in com.sun.jdi.Location[JavaMethodDescriptor]

'location' @ [339:38] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'method' @ [339:47] ==> public abstract fun method(): (Method..Method?) defined in com.sun.jdi.Location[JavaMethodDescriptor]

'nextLocation' @ [343:28] ==> value-parameter nextLocation: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.isLocationSuitable[ValueParameterDescriptorImpl]

'ktLineNumber' @ [343:41] ==> local final fun Location.ktLineNumber(): Int defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[SimpleFunctionDescriptorImpl]

'ktLineNumber' @ [344:13] ==> val ktLineNumber: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.isLocationSuitable[LocalVariableDescriptor]

'range' @ [344:30] ==> value-parameter range: IntRange defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'nextLocation' @ [349:20] ==> value-parameter nextLocation: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.isLocationSuitable[ValueParameterDescriptorImpl]

'ktFileName' @ [349:33] ==> local final fun Location.ktFileName(): String defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[SimpleFunctionDescriptorImpl]

'sourceFile' @ [349:49] ==> value-parameter sourceFile: KtFile defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'name' @ [349:60] ==> public final var KtFile.name: String[MyPropertyDescriptor]

'methodLocations' @ [357:40] ==> val methodLocations: (MutableList<(Location..Location?)>..List<(Location..Location?)>?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[LocalVariableDescriptor]

'reversed' @ [357:56] ==> public fun <T> Iterable<(Location..Location?)>.reversed(): List<(Location..Location?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Location..com.sun.jdi.Location?)

'dropWhile' @ [358:18] ==> public inline fun <T> Iterable<(Location..Location?)>.dropWhile(predicate: ((Location..Location?)) -> Boolean): List<(Location..Location?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Location..com.sun.jdi.Location?)

'it' @ [358:30] ==> value-parameter it: (Location..Location?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.isBackEdgeLocation.<anonymous>[ValueParameterDescriptorImpl]

'location' @ [358:36] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'drop' @ [359:18] ==> public fun <T> Iterable<(Location..Location?)>.drop(n: Int): List<(Location..Location?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Location..com.sun.jdi.Location?)

'filter' @ [360:18] ==> public inline fun <T> Iterable<(Location..Location?)>.filter(predicate: ((Location..Location?)) -> Boolean): List<(Location..Location?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Location..com.sun.jdi.Location?)

'dropWhile' @ [361:18] ==> public inline fun <T> Iterable<(Location..Location?)>.dropWhile(predicate: ((Location..Location?)) -> Boolean): List<(Location..Location?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Location..com.sun.jdi.Location?)

'it' @ [361:30] ==> value-parameter it: (Location..Location?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.isBackEdgeLocation.<anonymous>[ValueParameterDescriptorImpl]

'ktLineNumber' @ [361:33] ==> local final fun Location.ktLineNumber(): Int defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[SimpleFunctionDescriptorImpl]

'location' @ [361:51] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'ktLineNumber' @ [361:60] ==> local final fun Location.ktLineNumber(): Int defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[SimpleFunctionDescriptorImpl]

'firstOrNull' @ [362:18] ==> public fun <T> List<(Location..Location?)>.firstOrNull(): Location? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Location..com.sun.jdi.Location?)

'previousSuitableLocation' @ [364:16] ==> val previousSuitableLocation: Location? defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.isBackEdgeLocation[LocalVariableDescriptor]

'previousSuitableLocation' @ [364:52] ==> val previousSuitableLocation: Location? defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.isBackEdgeLocation[LocalVariableDescriptor]

'ktLineNumber' @ [364:77] ==> local final fun Location.ktLineNumber(): Int defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[SimpleFunctionDescriptorImpl]

'location' @ [364:94] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'ktLineNumber' @ [364:103] ==> local final fun Location.ktLineNumber(): Int defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[SimpleFunctionDescriptorImpl]

'if (isBackEdgeLocation()) {
        // Pretend we had already done a backing step
        methodLocations
                .filter(::isLocationSuitable)
                .firstOrNull { it.ktLineNumber() == location.ktLineNumber() } ?: location
    }
    else {
        location
    }' @ [367:27] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Location, elseBranch: Location): Location[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Location

'isBackEdgeLocation' @ [367:31] ==> local final fun isBackEdgeLocation(): Boolean defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[SimpleFunctionDescriptorImpl]

'methodLocations' @ [369:9] ==> val methodLocations: (MutableList<(Location..Location?)>..List<(Location..Location?)>?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[LocalVariableDescriptor]

'filter' @ [370:18] ==> public inline fun <T> Iterable<(Location..Location?)>.filter(predicate: ((Location..Location?)) -> Boolean): List<(Location..Location?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Location..com.sun.jdi.Location?)

'firstOrNull' @ [371:18] ==> public inline fun <T> Iterable<(Location..Location?)>.firstOrNull(predicate: ((Location..Location?)) -> Boolean): Location? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Location..com.sun.jdi.Location?)

'it' @ [371:32] ==> value-parameter it: (Location..Location?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.<anonymous>[ValueParameterDescriptorImpl]

'ktLineNumber' @ [371:35] ==> local final fun Location.ktLineNumber(): Int defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[SimpleFunctionDescriptorImpl]

'location' @ [371:53] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'ktLineNumber' @ [371:62] ==> local final fun Location.ktLineNumber(): Int defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[SimpleFunctionDescriptorImpl]

'location' @ [371:82] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'location' @ [374:9] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'patchedLocation' @ [377:29] ==> val patchedLocation: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[LocalVariableDescriptor]

'ktLineNumber' @ [377:45] ==> local final fun Location.ktLineNumber(): Int defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[SimpleFunctionDescriptorImpl]

'runReadAction' @ [379:32] ==> public fun <T> runReadAction(action: () -> List<IntRange>): List<IntRange> defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> List<IntRange>

'inlineFunctionArguments' @ [380:9] ==> value-parameter inlineFunctionArguments: List<KtElement> defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'map' @ [380:33] ==> public inline fun <T, R> Iterable<KtElement>.map(transform: (KtElement) -> IntRange): List<IntRange> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtElement
    <R> -> IntRange

'it' @ [381:35] ==> value-parameter it: KtElement defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'getLineNumber' @ [381:38] ==> public fun PsiElement.getLineNumber(start: Boolean = ...): Int defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'it' @ [382:33] ==> value-parameter it: KtElement defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'getLineNumber' @ [382:36] ==> public fun PsiElement.getLineNumber(start: Boolean = ...): Int defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'startLineNumber' @ [384:13] ==> val startLineNumber: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.<anonymous>.<anonymous>[LocalVariableDescriptor]

'endLineNumber' @ [384:30] ==> val endLineNumber: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.<anonymous>.<anonymous>[LocalVariableDescriptor]

'getInlineRangeLocalVariables' @ [388:32] ==> public fun getInlineRangeLocalVariables(stackFrame: StackFrameProxyImpl): List<LocalVariable> defined in org.jetbrains.kotlin.idea.debugger.stepping[SimpleFunctionDescriptorImpl]

'frameProxy' @ [388:61] ==> value-parameter frameProxy: StackFrameProxyImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'methodLocations' @ [396:36] ==> val methodLocations: (MutableList<(Location..Location?)>..List<(Location..Location?)>?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[LocalVariableDescriptor]

'dropWhile' @ [397:14] ==> public inline fun <T> Iterable<(Location..Location?)>.dropWhile(predicate: ((Location..Location?)) -> Boolean): List<(Location..Location?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Location..com.sun.jdi.Location?)

'it' @ [397:26] ==> value-parameter it: (Location..Location?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.<anonymous>[ValueParameterDescriptorImpl]

'patchedLocation' @ [397:32] ==> val patchedLocation: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[LocalVariableDescriptor]

'drop' @ [398:14] ==> public fun <T> Iterable<(Location..Location?)>.drop(n: Int): List<(Location..Location?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Location..com.sun.jdi.Location?)

'dropWhile' @ [399:14] ==> public inline fun <T> Iterable<(Location..Location?)>.dropWhile(predicate: ((Location..Location?)) -> Boolean): List<(Location..Location?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Location..com.sun.jdi.Location?)

'it' @ [399:26] ==> value-parameter it: (Location..Location?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.<anonymous>[ValueParameterDescriptorImpl]

'ktLineNumber' @ [399:29] ==> local final fun Location.ktLineNumber(): Int defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[SimpleFunctionDescriptorImpl]

'patchedLineNumber' @ [399:47] ==> val patchedLineNumber: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[LocalVariableDescriptor]

'takeWhile' @ [400:14] ==> public inline fun <T> Iterable<(Location..Location?)>.takeWhile(predicate: ((Location..Location?)) -> Boolean): List<(Location..Location?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Location..com.sun.jdi.Location?)

'!' @ [401:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isLocationSuitable' @ [401:18] ==> local final fun isLocationSuitable(nextLocation: Location): Boolean defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[SimpleFunctionDescriptorImpl]

'loc' @ [401:37] ==> value-parameter loc: (Location..Location?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.<anonymous>[ValueParameterDescriptorImpl]

'lambdaArgumentRanges' @ [401:45] ==> val lambdaArgumentRanges: List<IntRange> defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[LocalVariableDescriptor]

'any' @ [401:66] ==> public inline fun <T> Iterable<IntRange>.any(predicate: (IntRange) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> IntRange

'loc' @ [401:72] ==> value-parameter loc: (Location..Location?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.<anonymous>[ValueParameterDescriptorImpl]

'ktLineNumber' @ [401:76] ==> local final fun Location.ktLineNumber(): Int defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[SimpleFunctionDescriptorImpl]

'it' @ [401:94] ==> value-parameter it: IntRange defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'dropWhile' @ [403:14] ==> public inline fun <T> Iterable<(Location..Location?)>.dropWhile(predicate: ((Location..Location?)) -> Boolean): List<(Location..Location?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Location..com.sun.jdi.Location?)

'it' @ [403:26] ==> value-parameter it: (Location..Location?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.<anonymous>[ValueParameterDescriptorImpl]

'ktLineNumber' @ [403:29] ==> local final fun Location.ktLineNumber(): Int defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[SimpleFunctionDescriptorImpl]

'patchedLineNumber' @ [403:47] ==> val patchedLineNumber: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[LocalVariableDescriptor]

'!' @ [405:9] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'probablyInlinedLocations' @ [405:10] ==> val probablyInlinedLocations: List<(Location..Location?)> defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[LocalVariableDescriptor]

'isEmpty' @ [405:35] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'if (isDexDebug) {
            val method = location.method()
            val locationsOfLine = method.locationsOfLine(range.last)
            if (locationsOfLine.isNotEmpty()) {
                locationsOfLine.map { it.codeIndex() }.max() ?: -1L
            }
            else {
                findReturnFromDexBytecode(location.method())
            }
        }
        else -1L' @ [411:37] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Long, elseBranch: Long): Long[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Long

'isDexDebug' @ [411:41] ==> value-parameter isDexDebug: Boolean defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'location' @ [412:26] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'method' @ [412:35] ==> public abstract fun method(): (Method..Method?) defined in com.sun.jdi.Location[JavaMethodDescriptor]

'method' @ [413:35] ==> val method: (Method..Method?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[LocalVariableDescriptor]

'locationsOfLine' @ [413:42] ==> public abstract fun locationsOfLine(p0: Int): (MutableList<(Location..Location?)>..List<(Location..Location?)>?) defined in com.sun.jdi.Method[JavaMethodDescriptor]

'range' @ [413:58] ==> value-parameter range: IntRange defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'last' @ [413:64] ==> public final val last: Int defined in kotlin.ranges.IntRange[DeserializedPropertyDescriptor]

'if (locationsOfLine.isNotEmpty()) {
                locationsOfLine.map { it.codeIndex() }.max() ?: -1L
            }
            else {
                findReturnFromDexBytecode(location.method())
            }' @ [414:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Long, elseBranch: Long): Long[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Long

'locationsOfLine' @ [414:17] ==> val locationsOfLine: (MutableList<(Location..Location?)>..List<(Location..Location?)>?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[LocalVariableDescriptor]

'isNotEmpty' @ [414:33] ==> @InlineOnly public inline fun <T> Collection<(Location..Location?)>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Location..com.sun.jdi.Location?)

'locationsOfLine' @ [415:17] ==> val locationsOfLine: (MutableList<(Location..Location?)>..List<(Location..Location?)>?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[LocalVariableDescriptor]

'map' @ [415:33] ==> public inline fun <T, R> Iterable<(Location..Location?)>.map(transform: ((Location..Location?)) -> Long): List<Long> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Location..com.sun.jdi.Location?)
    <R> -> Long

'it' @ [415:39] ==> value-parameter it: (Location..Location?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.<anonymous>[ValueParameterDescriptorImpl]

'codeIndex' @ [415:42] ==> public abstract fun codeIndex(): Long defined in com.sun.jdi.Location[JavaMethodDescriptor]

'max' @ [415:56] ==> public fun <T : Comparable<Long>> Iterable<Long>.max(): Long? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Comparable<T>> -> Long

'-' @ [415:65] ==> public final operator fun unaryMinus(): Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor]

'findReturnFromDexBytecode' @ [418:17] ==> private fun findReturnFromDexBytecode(method: Method): Long defined in org.jetbrains.kotlin.idea.debugger.stepping in file KotlinSteppingCommandProvider.kt[SimpleFunctionDescriptorImpl]

'location' @ [418:43] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'method' @ [418:52] ==> public abstract fun method(): (Method..Method?) defined in com.sun.jdi.Location[JavaMethodDescriptor]

'-' @ [421:14] ==> public final operator fun unaryMinus(): Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor]

'STEP_OVER_INLINED' @ [423:23] ==> public constructor STEP_OVER_INLINED(stepOverInlineData: StepOverFilterData) defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.STEP_OVER_INLINED[ClassConstructorDescriptorImpl]

'StepOverFilterData' @ [423:41] ==> public constructor StepOverFilterData(lineNumber: Int, stepOverLines: Set<Int>, inlineRangeVariables: List<LocalVariable>, isDexDebug: Boolean, skipAfterCodeIndex: Long = ...) defined in org.jetbrains.kotlin.idea.debugger.stepping.StepOverFilterData[ClassConstructorDescriptorImpl]

'patchedLineNumber' @ [424:17] ==> val patchedLineNumber: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[LocalVariableDescriptor]

'probablyInlinedLocations' @ [425:17] ==> val probablyInlinedLocations: List<(Location..Location?)> defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[LocalVariableDescriptor]

'map' @ [425:42] ==> public inline fun <T, R> Iterable<(Location..Location?)>.map(transform: ((Location..Location?)) -> Int): List<Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Location..com.sun.jdi.Location?)
    <R> -> Int

'it' @ [425:48] ==> value-parameter it: (Location..Location?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction.<anonymous>[ValueParameterDescriptorImpl]

'ktLineNumber' @ [425:51] ==> local final fun Location.ktLineNumber(): Int defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[SimpleFunctionDescriptorImpl]

'toSet' @ [425:68] ==> public fun <T> Iterable<Int>.toSet(): Set<Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Int

'inlineRangeVariables' @ [426:17] ==> val inlineRangeVariables: List<LocalVariable> defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[LocalVariableDescriptor]

'isDexDebug' @ [427:17] ==> value-parameter isDexDebug: Boolean defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[ValueParameterDescriptorImpl]

'returnCodeIndex' @ [428:17] ==> val returnCodeIndex: Long defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOverAction[LocalVariableDescriptor]

'STEP_OVER' @ [432:19] ==> public constructor STEP_OVER() defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.STEP_OVER[ClassConstructorDescriptorImpl]

'location' @ [441:33] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOutAction[ValueParameterDescriptorImpl]

'declaringType' @ [441:42] ==> public abstract fun declaringType(): (ReferenceType..ReferenceType?) defined in com.sun.jdi.Location[JavaMethodDescriptor]

'STEP_OUT' @ [441:75] ==> public constructor STEP_OUT() defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.STEP_OUT[ClassConstructorDescriptorImpl]

'computedReferenceType' @ [443:21] ==> val computedReferenceType: ReferenceType defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOutAction[LocalVariableDescriptor]

'allLineLocations' @ [443:43] ==> public abstract fun allLineLocations(): (MutableList<(Location..Location?)>..List<(Location..Location?)>?) defined in com.sun.jdi.ReferenceType[JavaMethodDescriptor]

'locations' @ [444:29] ==> val locations: (MutableList<(Location..Location?)>..List<(Location..Location?)>?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOutAction[LocalVariableDescriptor]

'dropWhile' @ [445:14] ==> public inline fun <T> Iterable<(Location..Location?)>.dropWhile(predicate: ((Location..Location?)) -> Boolean): List<(Location..Location?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Location..com.sun.jdi.Location?)

'it' @ [445:26] ==> value-parameter it: (Location..Location?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOutAction.<anonymous>[ValueParameterDescriptorImpl]

'location' @ [445:32] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOutAction[ValueParameterDescriptorImpl]

'drop' @ [446:14] ==> public fun <T> Iterable<(Location..Location?)>.drop(n: Int): List<(Location..Location?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Location..com.sun.jdi.Location?)

'filter' @ [447:14] ==> public inline fun <T> Iterable<(Location..Location?)>.filter(predicate: ((Location..Location?)) -> Boolean): List<(Location..Location?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Location..com.sun.jdi.Location?)

'it' @ [447:23] ==> value-parameter it: (Location..Location?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOutAction.<anonymous>[ValueParameterDescriptorImpl]

'method' @ [447:26] ==> public abstract fun method(): (Method..Method?) defined in com.sun.jdi.Location[JavaMethodDescriptor]

'location' @ [447:38] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOutAction[ValueParameterDescriptorImpl]

'method' @ [447:47] ==> public abstract fun method(): (Method..Method?) defined in com.sun.jdi.Location[JavaMethodDescriptor]

'dropWhile' @ [448:14] ==> public inline fun <T> Iterable<(Location..Location?)>.dropWhile(predicate: ((Location..Location?)) -> Boolean): List<(Location..Location?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Location..com.sun.jdi.Location?)

'it' @ [448:26] ==> value-parameter it: (Location..Location?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOutAction.<anonymous>[ValueParameterDescriptorImpl]

'lineNumber' @ [448:29] ==> public abstract fun lineNumber(): Int defined in com.sun.jdi.Location[JavaMethodDescriptor]

'location' @ [448:45] ==> value-parameter location: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOutAction[ValueParameterDescriptorImpl]

'lineNumber' @ [448:54] ==> public abstract fun lineNumber(): Int defined in com.sun.jdi.Location[JavaMethodDescriptor]

'inlineFunctions' @ [450:9] ==> value-parameter inlineFunctions: List<KtNamedFunction> defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOutAction[ValueParameterDescriptorImpl]

'isNotEmpty' @ [450:25] ==> @InlineOnly public inline fun <T> Collection<KtNamedFunction>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtNamedFunction

'suspendContext' @ [451:24] ==> value-parameter suspendContext: SuspendContextImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOutAction[ValueParameterDescriptorImpl]

'getXPositionForStepOutFromInlineFunction' @ [451:39] ==> private fun SuspendContextImpl.getXPositionForStepOutFromInlineFunction(locations: List<Location>, inlineFunctionsToSkip: List<KtNamedFunction>): XSourcePositionImpl? defined in org.jetbrains.kotlin.idea.debugger.stepping[SimpleFunctionDescriptorImpl]

'nextLineLocations' @ [451:80] ==> val nextLineLocations: List<(Location..Location?)> defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOutAction[LocalVariableDescriptor]

'inlineFunctions' @ [451:99] ==> value-parameter inlineFunctions: List<KtNamedFunction> defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOutAction[ValueParameterDescriptorImpl]

'position' @ [452:16] ==> val position: XSourcePositionImpl? defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOutAction[LocalVariableDescriptor]

'let' @ [452:26] ==> @InlineOnly public inline fun <T, R> XSourcePositionImpl.let(block: (XSourcePositionImpl) -> Action.RUN_TO_CURSOR): Action.RUN_TO_CURSOR defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> XSourcePositionImpl
    <R> -> RUN_TO_CURSOR

'RUN_TO_CURSOR' @ [452:39] ==> public constructor RUN_TO_CURSOR(position: XSourcePositionImpl) defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.RUN_TO_CURSOR[ClassConstructorDescriptorImpl]

'it' @ [452:53] ==> value-parameter it: XSourcePositionImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOutAction.<anonymous>[ValueParameterDescriptorImpl]

'STEP_OVER' @ [452:69] ==> public constructor STEP_OVER() defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.STEP_OVER[ClassConstructorDescriptorImpl]

'inlinedArgument' @ [455:9] ==> value-parameter inlinedArgument: KtFunctionLiteral? defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOutAction[ValueParameterDescriptorImpl]

'suspendContext' @ [456:24] ==> value-parameter suspendContext: SuspendContextImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOutAction[ValueParameterDescriptorImpl]

'getXPositionForStepOutFromInlinedArgument' @ [456:39] ==> private fun SuspendContextImpl.getXPositionForStepOutFromInlinedArgument(locations: List<Location>, inlinedArgumentToSkip: KtFunctionLiteral): XSourcePositionImpl? defined in org.jetbrains.kotlin.idea.debugger.stepping[SimpleFunctionDescriptorImpl]

'nextLineLocations' @ [456:81] ==> val nextLineLocations: List<(Location..Location?)> defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOutAction[LocalVariableDescriptor]

'inlinedArgument' @ [456:100] ==> value-parameter inlinedArgument: KtFunctionLiteral? defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOutAction[ValueParameterDescriptorImpl]

'position' @ [457:16] ==> val position: XSourcePositionImpl? defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOutAction[LocalVariableDescriptor]

'let' @ [457:26] ==> @InlineOnly public inline fun <T, R> XSourcePositionImpl.let(block: (XSourcePositionImpl) -> Action.RUN_TO_CURSOR): Action.RUN_TO_CURSOR defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> XSourcePositionImpl
    <R> -> RUN_TO_CURSOR

'RUN_TO_CURSOR' @ [457:39] ==> public constructor RUN_TO_CURSOR(position: XSourcePositionImpl) defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.RUN_TO_CURSOR[ClassConstructorDescriptorImpl]

'it' @ [457:53] ==> value-parameter it: XSourcePositionImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.getStepOutAction.<anonymous>[ValueParameterDescriptorImpl]

'STEP_OVER' @ [457:69] ==> public constructor STEP_OVER() defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.STEP_OVER[ClassConstructorDescriptorImpl]

'STEP_OVER' @ [460:19] ==> public constructor STEP_OVER() defined in org.jetbrains.kotlin.idea.debugger.stepping.Action.STEP_OVER[ClassConstructorDescriptorImpl]

'getNextPositionWithFilter' @ [467:12] ==> private fun SuspendContextImpl.getNextPositionWithFilter(locations: List<Location>, skip: (Int, PsiElement) -> Boolean): XSourcePositionImpl? defined in org.jetbrains.kotlin.idea.debugger.stepping[SimpleFunctionDescriptorImpl]

'locations' @ [467:38] ==> value-parameter locations: List<Location> defined in org.jetbrains.kotlin.idea.debugger.stepping.getXPositionForStepOutFromInlineFunction[ValueParameterDescriptorImpl]

'inlineFunctionsToSkip' @ [469:13] ==> value-parameter inlineFunctionsToSkip: List<KtNamedFunction> defined in org.jetbrains.kotlin.idea.debugger.stepping.getXPositionForStepOutFromInlineFunction[ValueParameterDescriptorImpl]

'any' @ [469:35] ==> public inline fun <T> Iterable<KtNamedFunction>.any(predicate: (KtNamedFunction) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtNamedFunction

'it' @ [469:41] ==> value-parameter it: KtNamedFunction defined in org.jetbrains.kotlin.idea.debugger.stepping.getXPositionForStepOutFromInlineFunction.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'textRange' @ [469:44] ==> public final val KtNamedFunction.textRange: (TextRange..TextRange?)[MyPropertyDescriptor]

'contains' @ [469:54] ==> public open operator fun contains(p0: Int): Boolean defined in com.intellij.openapi.util.TextRange[JavaMethodDescriptor]

'offset' @ [469:63] ==> value-parameter offset: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.getXPositionForStepOutFromInlineFunction.<anonymous>[ValueParameterDescriptorImpl]

'getInlineArgumentIfAny' @ [473:9] ==> private fun getInlineArgumentIfAny(elementAt: PsiElement?): KtFunctionLiteral? defined in org.jetbrains.kotlin.idea.debugger.stepping in file KotlinSteppingCommandProvider.kt[SimpleFunctionDescriptorImpl]

'elementAt' @ [473:32] ==> value-parameter elementAt: PsiElement defined in org.jetbrains.kotlin.idea.debugger.stepping.getXPositionForStepOutFromInlineFunction.<anonymous>[ValueParameterDescriptorImpl]

'getNextPositionWithFilter' @ [481:12] ==> private fun SuspendContextImpl.getNextPositionWithFilter(locations: List<Location>, skip: (Int, PsiElement) -> Boolean): XSourcePositionImpl? defined in org.jetbrains.kotlin.idea.debugger.stepping[SimpleFunctionDescriptorImpl]

'locations' @ [481:38] ==> value-parameter locations: List<Location> defined in org.jetbrains.kotlin.idea.debugger.stepping.getXPositionForStepOutFromInlinedArgument[ValueParameterDescriptorImpl]

'inlinedArgumentToSkip' @ [483:9] ==> value-parameter inlinedArgumentToSkip: KtFunctionLiteral defined in org.jetbrains.kotlin.idea.debugger.stepping.getXPositionForStepOutFromInlinedArgument[ValueParameterDescriptorImpl]

'textRange' @ [483:31] ==> public final val KtFunctionLiteral.textRange: (TextRange..TextRange?)[MyPropertyDescriptor]

'contains' @ [483:41] ==> public open operator fun contains(p0: Int): Boolean defined in com.intellij.openapi.util.TextRange[JavaMethodDescriptor]

'offset' @ [483:50] ==> value-parameter offset: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.getXPositionForStepOutFromInlinedArgument.<anonymous>[ValueParameterDescriptorImpl]

'locations' @ [491:22] ==> value-parameter locations: List<Location> defined in org.jetbrains.kotlin.idea.debugger.stepping.getNextPositionWithFilter[ValueParameterDescriptorImpl]

'runReadAction' @ [492:24] ==> public fun <T> runReadAction(action: () -> XSourcePositionImpl?): XSourcePositionImpl? defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> XSourcePositionImpl?

'?:' @ [493:34] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: SourcePosition?, right: SourcePosition): SourcePosition[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> SourcePosition

'this' @ [494:17] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.stepping.getNextPositionWithFilter[ReceiverParameterDescriptorImpl]

'debugProcess' @ [494:22] ==> public final val SuspendContextImpl.debugProcess: DebugProcessImpl[MyPropertyDescriptor]

'positionManager' @ [494:35] ==> public final val DebugProcessImpl.positionManager: CompoundPositionManager[MyPropertyDescriptor]

'getSourcePosition' @ [494:51] ==> @Nullable public open fun getSourcePosition(p0: Location?): SourcePosition? defined in com.intellij.debugger.engine.CompoundPositionManager[JavaMethodDescriptor]

'location' @ [494:69] ==> val location: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.getNextPositionWithFilter[LocalVariableDescriptor]

'sourcePosition' @ [500:24] ==> val sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.getNextPositionWithFilter.<anonymous>[LocalVariableDescriptor]

'file' @ [500:39] ==> public final val SourcePosition.file: PsiFile[MyPropertyDescriptor]

'sourcePosition' @ [501:29] ==> val sourcePosition: SourcePosition defined in org.jetbrains.kotlin.idea.debugger.stepping.getNextPositionWithFilter.<anonymous>[LocalVariableDescriptor]

'elementAt' @ [501:44] ==> public final val SourcePosition.elementAt: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'location' @ [502:31] ==> val location: Location defined in org.jetbrains.kotlin.idea.debugger.stepping.getNextPositionWithFilter[LocalVariableDescriptor]

'lineNumber' @ [502:40] ==> public abstract fun lineNumber(): Int defined in com.sun.jdi.Location[JavaMethodDescriptor]

'file' @ [503:35] ==> val file: KtFile defined in org.jetbrains.kotlin.idea.debugger.stepping.getNextPositionWithFilter.<anonymous>[LocalVariableDescriptor]

'getLineStartOffset' @ [503:40] ==> public fun PsiFile.getLineStartOffset(line: Int): Int? defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'currentLine' @ [503:59] ==> val currentLine: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.getNextPositionWithFilter.<anonymous>[LocalVariableDescriptor]

'invoke' @ [504:17] ==> public abstract operator fun invoke(p1: Int, p2: PsiElement): Boolean defined in kotlin.Function2[FunctionInvokeDescriptor]

'lineStartOffset' @ [504:22] ==> val lineStartOffset: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.getNextPositionWithFilter.<anonymous>[LocalVariableDescriptor]

'elementAt' @ [504:39] ==> val elementAt: PsiElement defined in org.jetbrains.kotlin.idea.debugger.stepping.getNextPositionWithFilter.<anonymous>[LocalVariableDescriptor]

'createByElement' @ [506:33] ==> @Nullable public open fun createByElement(@Nullable p0: PsiElement?): XSourcePositionImpl? defined in com.intellij.xdebugger.impl.XSourcePositionImpl[JavaMethodDescriptor]

'elementAt' @ [506:49] ==> val elementAt: PsiElement defined in org.jetbrains.kotlin.idea.debugger.stepping.getNextPositionWithFilter.<anonymous>[LocalVariableDescriptor]

'position' @ [508:13] ==> val position: XSourcePositionImpl? defined in org.jetbrains.kotlin.idea.debugger.stepping.getNextPositionWithFilter[LocalVariableDescriptor]

'position' @ [509:20] ==> val position: XSourcePositionImpl? defined in org.jetbrains.kotlin.idea.debugger.stepping.getNextPositionWithFilter[LocalVariableDescriptor]

'stackFrame' @ [517:12] ==> value-parameter stackFrame: StackFrameProxyImpl defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineRangeLocalVariables[ValueParameterDescriptorImpl]

'visibleVariables' @ [517:23] ==> @NotNull public open fun visibleVariables(): (MutableList<(LocalVariableProxyImpl..LocalVariableProxyImpl?)>..List<(LocalVariableProxyImpl..LocalVariableProxyImpl?)>) defined in com.intellij.debugger.jdi.StackFrameProxyImpl[JavaMethodDescriptor]

'filter' @ [518:14] ==> public inline fun <T> Iterable<(LocalVariableProxyImpl..LocalVariableProxyImpl?)>.filter(predicate: ((LocalVariableProxyImpl..LocalVariableProxyImpl?)) -> Boolean): List<(LocalVariableProxyImpl..LocalVariableProxyImpl?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.debugger.jdi.LocalVariableProxyImpl..com.intellij.debugger.jdi.LocalVariableProxyImpl?)

'it' @ [519:28] ==> value-parameter it: (LocalVariableProxyImpl..LocalVariableProxyImpl?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineRangeLocalVariables.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [519:31] ==> public open fun name(): (String..String?) defined in com.intellij.debugger.jdi.LocalVariableProxyImpl[JavaMethodDescriptor]

'name' @ [520:17] ==> val name: (String..String?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineRangeLocalVariables.<anonymous>[LocalVariableDescriptor]

'startsWith' @ [520:22] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'LOCAL_VARIABLE_NAME_PREFIX_INLINE_FUNCTION' @ [520:40] ==> public const final val LOCAL_VARIABLE_NAME_PREFIX_INLINE_FUNCTION: String defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaPropertyDescriptor]

'map' @ [522:14] ==> public inline fun <T, R> Iterable<(LocalVariableProxyImpl..LocalVariableProxyImpl?)>.map(transform: ((LocalVariableProxyImpl..LocalVariableProxyImpl?)) -> (LocalVariable..LocalVariable?)): List<(LocalVariable..LocalVariable?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.debugger.jdi.LocalVariableProxyImpl..com.intellij.debugger.jdi.LocalVariableProxyImpl?)
    <R> -> (com.sun.jdi.LocalVariable..com.sun.jdi.LocalVariable?)

'it' @ [522:20] ==> value-parameter it: (LocalVariableProxyImpl..LocalVariableProxyImpl?) defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineRangeLocalVariables.<anonymous>[ValueParameterDescriptorImpl]

'variable' @ [522:23] ==> public final val LocalVariableProxyImpl.variable: (LocalVariable..LocalVariable?)[MyPropertyDescriptor]

'elementAt' @ [526:37] ==> value-parameter elementAt: PsiElement? defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineArgumentIfAny[ValueParameterDescriptorImpl]

'getParentOfType' @ [526:48] ==> public inline fun <reified T : PsiElement> PsiElement.getParentOfType(strict: Boolean): KtLambdaExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtLambdaExpression

'functionLiteralExpression' @ [528:19] ==> val functionLiteralExpression: KtLambdaExpression defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineArgumentIfAny[LocalVariableDescriptor]

'analyze' @ [528:45] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'PARTIAL' @ [528:69] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'!' @ [529:9] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isInlinedArgument' @ [529:21] ==> public open fun isInlinedArgument(@NotNull p0: KtFunction, @NotNull p1: BindingContext, p2: Boolean): Boolean defined in org.jetbrains.kotlin.resolve.inline.InlineUtil[JavaMethodDescriptor]

'functionLiteralExpression' @ [529:39] ==> val functionLiteralExpression: KtLambdaExpression defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineArgumentIfAny[LocalVariableDescriptor]

'functionLiteral' @ [529:65] ==> public final val KtLambdaExpression.functionLiteral: KtFunctionLiteral[MyPropertyDescriptor]

'context' @ [529:82] ==> val context: BindingContext defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineArgumentIfAny[LocalVariableDescriptor]

'functionLiteralExpression' @ [531:12] ==> val functionLiteralExpression: KtLambdaExpression defined in org.jetbrains.kotlin.idea.debugger.stepping.getInlineArgumentIfAny[LocalVariableDescriptor]

'functionLiteral' @ [531:38] ==> public final val KtLambdaExpression.functionLiteral: KtFunctionLiteral[MyPropertyDescriptor]

'method' @ [535:27] ==> value-parameter method: Method defined in org.jetbrains.kotlin.idea.debugger.stepping.findReturnFromDexBytecode[ValueParameterDescriptorImpl]

'allLineLocations' @ [535:34] ==> public abstract fun allLineLocations(): (MutableList<(Location..Location?)>..List<(Location..Location?)>?) defined in com.sun.jdi.Method[JavaMethodDescriptor]

'methodLocations' @ [536:9] ==> val methodLocations: (MutableList<(Location..Location?)>..List<(Location..Location?)>?) defined in org.jetbrains.kotlin.idea.debugger.stepping.findReturnFromDexBytecode[LocalVariableDescriptor]

'isEmpty' @ [536:25] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'-' @ [536:44] ==> public final operator fun unaryMinus(): Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor]

'methodLocations' @ [538:31] ==> val methodLocations: (MutableList<(Location..Location?)>..List<(Location..Location?)>?) defined in org.jetbrains.kotlin.idea.debugger.stepping.findReturnFromDexBytecode[LocalVariableDescriptor]

'last' @ [538:47] ==> public fun <T> List<(Location..Location?)>.last(): (Location..Location?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Location..com.sun.jdi.Location?)

'codeIndex' @ [538:54] ==> public abstract fun codeIndex(): Long defined in com.sun.jdi.Location[JavaMethodDescriptor]

'if (method.locationOfCodeIndex(lastMethodCodeIndex + 1) != null) {
            lastMethodCodeIndex++
        }
        else {
            break
        }' @ [541:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Long, elseBranch: Long): Long[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Long

'method' @ [541:13] ==> value-parameter method: Method defined in org.jetbrains.kotlin.idea.debugger.stepping.findReturnFromDexBytecode[ValueParameterDescriptorImpl]

'locationOfCodeIndex' @ [541:20] ==> public abstract fun locationOfCodeIndex(p0: Long): (Location..Location?) defined in com.sun.jdi.Method[JavaMethodDescriptor]

'lastMethodCodeIndex' @ [541:40] ==> var lastMethodCodeIndex: Long defined in org.jetbrains.kotlin.idea.debugger.stepping.findReturnFromDexBytecode[LocalVariableDescriptor]

'lastMethodCodeIndex' @ [542:13] ==> var lastMethodCodeIndex: Long defined in org.jetbrains.kotlin.idea.debugger.stepping.findReturnFromDexBytecode[LocalVariableDescriptor]

'lastMethodCodeIndex' @ [549:23] ==> var lastMethodCodeIndex: Long defined in org.jetbrains.kotlin.idea.debugger.stepping.findReturnFromDexBytecode[LocalVariableDescriptor]

'method' @ [551:20] ==> value-parameter method: Method defined in org.jetbrains.kotlin.idea.debugger.stepping.findReturnFromDexBytecode[ValueParameterDescriptorImpl]

'bytecodes' @ [551:27] ==> public abstract fun bytecodes(): (ByteArray..ByteArray?) defined in com.sun.jdi.Method[JavaMethodDescriptor]

'bytecode' @ [552:13] ==> val bytecode: (ByteArray..ByteArray?) defined in org.jetbrains.kotlin.idea.debugger.stepping.findReturnFromDexBytecode[LocalVariableDescriptor]

'size' @ [552:22] ==> public final val size: Int defined in kotlin.ByteArray[DeserializedPropertyDescriptor]

'i' @ [554:12] ==> var i: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.findReturnFromDexBytecode[LocalVariableDescriptor]

'i' @ [556:9] ==> var i: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.findReturnFromDexBytecode[LocalVariableDescriptor]

'returnIndex' @ [557:9] ==> var returnIndex: Long defined in org.jetbrains.kotlin.idea.debugger.stepping.findReturnFromDexBytecode[LocalVariableDescriptor]

'bytecode' @ [559:27] ==> val bytecode: (ByteArray..ByteArray?) defined in org.jetbrains.kotlin.idea.debugger.stepping.findReturnFromDexBytecode[LocalVariableDescriptor]

'i' @ [559:36] ==> var i: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.findReturnFromDexBytecode[LocalVariableDescriptor]

'toInt' @ [559:39] ==> public open fun toInt(): Int defined in kotlin.Byte[DeserializedSimpleFunctionDescriptor]

'if (instruction == RETURN_VOID || instruction == RETURN || instruction == RETURN_WIDE || instruction == RETURN_OBJECT) {
            // Instruction found
            return returnIndex
        }
        else if (instruction == MOVE || instruction == GOTO) {
            // proceed
        }
        else {
            // Don't know the instruction and it's length. Abort.
            break
        }' @ [561:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'instruction' @ [561:13] ==> val instruction: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.findReturnFromDexBytecode[LocalVariableDescriptor]

'RETURN_VOID' @ [561:28] ==> public final val RETURN_VOID: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.DexBytecode[PropertyImportedFromObject]

'instruction' @ [561:43] ==> val instruction: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.findReturnFromDexBytecode[LocalVariableDescriptor]

'RETURN' @ [561:58] ==> public final val RETURN: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.DexBytecode[PropertyImportedFromObject]

'instruction' @ [561:68] ==> val instruction: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.findReturnFromDexBytecode[LocalVariableDescriptor]

'RETURN_WIDE' @ [561:83] ==> public final val RETURN_WIDE: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.DexBytecode[PropertyImportedFromObject]

'instruction' @ [561:98] ==> val instruction: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.findReturnFromDexBytecode[LocalVariableDescriptor]

'RETURN_OBJECT' @ [561:113] ==> public final val RETURN_OBJECT: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.DexBytecode[PropertyImportedFromObject]

'returnIndex' @ [563:20] ==> var returnIndex: Long defined in org.jetbrains.kotlin.idea.debugger.stepping.findReturnFromDexBytecode[LocalVariableDescriptor]

'if (instruction == MOVE || instruction == GOTO) {
            // proceed
        }
        else {
            // Don't know the instruction and it's length. Abort.
            break
        }' @ [565:14] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'instruction' @ [565:18] ==> val instruction: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.findReturnFromDexBytecode[LocalVariableDescriptor]

'MOVE' @ [565:33] ==> public final val MOVE: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.DexBytecode[PropertyImportedFromObject]

'instruction' @ [565:41] ==> val instruction: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.findReturnFromDexBytecode[LocalVariableDescriptor]

'GOTO' @ [565:56] ==> public final val GOTO: Int defined in org.jetbrains.kotlin.idea.debugger.stepping.DexBytecode[PropertyImportedFromObject]

'-' @ [574:12] ==> public final operator fun unaryMinus(): Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor]

