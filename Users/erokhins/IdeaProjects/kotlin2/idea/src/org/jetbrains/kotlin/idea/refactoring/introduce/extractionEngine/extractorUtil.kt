'config' @ [57:28] ==> value-parameter config: ExtractionGeneratorConfiguration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature[ValueParameterDescriptorImpl]

'generatorOptions' @ [57:35] ==> public final val generatorOptions: ExtractionGeneratorOptions defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'target' @ [57:52] ==> public final val target: ExtractionTarget defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorOptions[PropertyDescriptorImpl]

'!' @ [58:9] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'extractionTarget' @ [58:10] ==> val extractionTarget: ExtractionTarget defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature[LocalVariableDescriptor]

'isAvailable' @ [58:27] ==> public abstract fun isAvailable(descriptor: ExtractableCodeDescriptor): Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[SimpleFunctionDescriptorImpl]

'config' @ [58:39] ==> value-parameter config: ExtractionGeneratorConfiguration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature[ValueParameterDescriptorImpl]

'descriptor' @ [58:46] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'extractionTarget' @ [59:41] ==> val extractionTarget: ExtractionTarget defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature[LocalVariableDescriptor]

'targetName' @ [59:58] ==> public final val targetName: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[PropertyDescriptorImpl]

'config' @ [59:73] ==> value-parameter config: ExtractionGeneratorConfiguration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature[ValueParameterDescriptorImpl]

'descriptor' @ [59:80] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'extractionData' @ [59:91] ==> public final val extractionData: ExtractionData defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'codeFragmentText' @ [59:106] ==> public final val codeFragmentText: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[PropertyDescriptorImpl]

'ConflictsInTestsException' @ [60:40] ==> public constructor ConflictsInTestsException(@NotNull p0: (MutableCollection<out (String..String?)>..Collection<(String..String?)>)) defined in com.intellij.refactoring.BaseRefactoringProcessor.ConflictsInTestsException[JavaClassConstructorDescriptor]

'listOf' @ [60:66] ==> public fun <T> listOf(element: String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'message' @ [60:73] ==> val message: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature[LocalVariableDescriptor]

'when (extractionTarget) {
        ExtractionTarget.FUNCTION, ExtractionTarget.FAKE_LAMBDALIKE_FUNCTION -> CallableBuilder.Target.FUNCTION
        else -> CallableBuilder.Target.READ_ONLY_PROPERTY
    }' @ [63:25] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KtPsiFactory.CallableBuilder.Target, entry1: KtPsiFactory.CallableBuilder.Target): KtPsiFactory.CallableBuilder.Target[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Target

'extractionTarget' @ [63:31] ==> val extractionTarget: ExtractionTarget defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature[LocalVariableDescriptor]

'ExtractionTarget' @ [64:9] ==> public companion object defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[FakeCallableDescriptorForObject]

'FUNCTION' @ [64:26] ==> enum entry FUNCTION defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[FakeCallableDescriptorForObject]

'ExtractionTarget' @ [64:36] ==> public companion object defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[FakeCallableDescriptorForObject]

'FAKE_LAMBDALIKE_FUNCTION' @ [64:53] ==> enum entry FAKE_LAMBDALIKE_FUNCTION defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[FakeCallableDescriptorForObject]

'CallableBuilder' @ [64:81] ==> public companion object defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[FakeCallableDescriptorForObject]

'FUNCTION' @ [64:104] ==> enum entry FUNCTION defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder.Target[FakeCallableDescriptorForObject]

'CallableBuilder' @ [65:17] ==> public companion object defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[FakeCallableDescriptorForObject]

'READ_ONLY_PROPERTY' @ [65:40] ==> enum entry READ_ONLY_PROPERTY defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder.Target[FakeCallableDescriptorForObject]

'CallableBuilder' @ [67:12] ==> public constructor CallableBuilder(target: KtPsiFactory.CallableBuilder.Target) defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedClassConstructorDescriptor]

'builderTarget' @ [67:28] ==> val builderTarget: KtPsiFactory.CallableBuilder.Target defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature[LocalVariableDescriptor]

'apply' @ [67:43] ==> @InlineOnly public inline fun <T> KtPsiFactory.CallableBuilder.apply(block: KtPsiFactory.CallableBuilder.() -> Unit): KtPsiFactory.CallableBuilder defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> CallableBuilder

'listOf' @ [68:25] ==> public fun <T> listOf(element: String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'config' @ [68:32] ==> value-parameter config: ExtractionGeneratorConfiguration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature[ValueParameterDescriptorImpl]

'descriptor' @ [68:39] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'visibility' @ [68:50] ==> public final val visibility: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'config' @ [68:64] ==> value-parameter config: ExtractionGeneratorConfiguration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature[ValueParameterDescriptorImpl]

'descriptor' @ [68:71] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'modifiers' @ [68:82] ==> public final val modifiers: List<KtKeywordToken> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'map' @ [68:92] ==> public inline fun <T, R> Iterable<KtKeywordToken>.map(transform: (KtKeywordToken) -> String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtKeywordToken
    <R> -> String

'it' @ [68:98] ==> value-parameter it: KtKeywordToken defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [68:101] ==> public final val KtKeywordToken.value: String[MyPropertyDescriptor]

'modifier' @ [69:9] ==> public final fun modifier(modifier: String): KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedSimpleFunctionDescriptor]

'modifiers' @ [69:18] ==> val modifiers: List<String> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature.<anonymous>[LocalVariableDescriptor]

'joinToString' @ [69:28] ==> public fun <T> Iterable<String>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((String) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'typeParams' @ [71:9] ==> public final fun typeParams(values: Collection<String> = ...): KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedSimpleFunctionDescriptor]

'config' @ [72:17] ==> value-parameter config: ExtractionGeneratorConfiguration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature[ValueParameterDescriptorImpl]

'descriptor' @ [72:24] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'typeParameters' @ [72:35] ==> public final val typeParameters: List<TypeParameter> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'map' @ [72:50] ==> public inline fun <T, R> Iterable<TypeParameter>.map(transform: (TypeParameter) -> String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeParameter
    <R> -> String

'it' @ [73:41] ==> value-parameter it: TypeParameter defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'originalDeclaration' @ [73:44] ==> public final val originalDeclaration: KtTypeParameter defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.TypeParameter[PropertyDescriptorImpl]

'typeParameter' @ [74:33] ==> val typeParameter: KtTypeParameter defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature.<anonymous>.<anonymous>[LocalVariableDescriptor]

'extendsBound' @ [74:47] ==> public final var KtTypeParameter.extendsBound: KtTypeReference?[MyPropertyDescriptor]

'typeParameter' @ [75:21] ==> val typeParameter: KtTypeParameter defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature.<anonymous>.<anonymous>[LocalVariableDescriptor]

'name' @ [75:35] ==> public final val KtTypeParameter.name: String?[MyPropertyDescriptor]

'bound' @ [75:43] ==> val bound: KtTypeReference? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature.<anonymous>.<anonymous>[LocalVariableDescriptor]

'let' @ [75:50] ==> @InlineOnly public inline fun <T, R> KtTypeReference.let(block: (KtTypeReference) -> String): String defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtTypeReference
    <R> -> String

'+' @ [75:56] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'it' @ [75:64] ==> value-parameter it: KtTypeReference defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'text' @ [75:67] ==> public final val KtTypeReference.text: (String..String?)[MyPropertyDescriptor]

'if (config.descriptor.extractionData.options.allowSpecialClassNames && isSpecial()) {
                DEBUG_TYPE_REFERENCE_STRING
            } else {
                renderer.renderType(this)
            }' @ [80:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'config' @ [80:24] ==> value-parameter config: ExtractionGeneratorConfiguration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature[ValueParameterDescriptorImpl]

'descriptor' @ [80:31] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'extractionData' @ [80:42] ==> public final val extractionData: ExtractionData defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'options' @ [80:57] ==> public final val options: ExtractionOptions defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[PropertyDescriptorImpl]

'allowSpecialClassNames' @ [80:65] ==> public final val allowSpecialClassNames: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionOptions[PropertyDescriptorImpl]

'isSpecial' @ [80:91] ==> public fun KotlinType.isSpecial(): Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine in file extractorUtil.kt[SimpleFunctionDescriptorImpl]

'DEBUG_TYPE_REFERENCE_STRING' @ [81:17] ==> public val DEBUG_TYPE_REFERENCE_STRING: String defined in org.jetbrains.kotlin.psi.codeFragmentUtil[DeserializedPropertyDescriptor]

'renderer' @ [83:17] ==> value-parameter renderer: DescriptorRenderer defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature[ValueParameterDescriptorImpl]

'renderType' @ [83:26] ==> public abstract fun renderType(type: KotlinType): String defined in org.jetbrains.kotlin.renderer.DescriptorRenderer[DeserializedSimpleFunctionDescriptor]

'this' @ [83:37] ==> <this> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature.<anonymous>.typeAsString[ReceiverParameterDescriptorImpl]

'config' @ [87:9] ==> value-parameter config: ExtractionGeneratorConfiguration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature[ValueParameterDescriptorImpl]

'descriptor' @ [87:16] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'receiverParameter' @ [87:27] ==> public final val receiverParameter: Parameter? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'let' @ [87:46] ==> @InlineOnly public inline fun <T, R> Parameter.let(block: (Parameter) -> KtPsiFactory.CallableBuilder): KtPsiFactory.CallableBuilder defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Parameter
    <R> -> CallableBuilder

'it' @ [88:32] ==> value-parameter it: Parameter defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'getParameterType' @ [88:35] ==> public abstract fun getParameterType(allowSpecialClassNames: Boolean): KotlinType defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.Parameter[SimpleFunctionDescriptorImpl]

'config' @ [88:52] ==> value-parameter config: ExtractionGeneratorConfiguration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature[ValueParameterDescriptorImpl]

'descriptor' @ [88:59] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'extractionData' @ [88:70] ==> public final val extractionData: ExtractionData defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'options' @ [88:85] ==> public final val options: ExtractionOptions defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[PropertyDescriptorImpl]

'allowSpecialClassNames' @ [88:93] ==> public final val allowSpecialClassNames: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionOptions[PropertyDescriptorImpl]

'receiverType' @ [89:40] ==> val receiverType: KotlinType defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature.<anonymous>.<anonymous>[LocalVariableDescriptor]

'typeAsString' @ [89:53] ==> local final fun KotlinType.typeAsString(): String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature.<anonymous>[SimpleFunctionDescriptorImpl]

'receiver' @ [90:13] ==> public final fun receiver(receiverType: String): KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedSimpleFunctionDescriptor]

'if (receiverType.isFunctionType) "($receiverTypeAsString)" else receiverTypeAsString' @ [90:22] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'receiverType' @ [90:26] ==> val receiverType: KotlinType defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature.<anonymous>.<anonymous>[LocalVariableDescriptor]

'isFunctionType' @ [90:39] ==> public val KotlinType.isFunctionType: Boolean defined in org.jetbrains.kotlin.builtins[DeserializedPropertyDescriptor]

'receiverTypeAsString' @ [90:58] ==> val receiverTypeAsString: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature.<anonymous>.<anonymous>[LocalVariableDescriptor]

'receiverTypeAsString' @ [90:86] ==> val receiverTypeAsString: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature.<anonymous>.<anonymous>[LocalVariableDescriptor]

'name' @ [93:9] ==> public final fun name(name: String = ...): KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedSimpleFunctionDescriptor]

'config' @ [93:14] ==> value-parameter config: ExtractionGeneratorConfiguration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature[ValueParameterDescriptorImpl]

'generatorOptions' @ [93:21] ==> public final val generatorOptions: ExtractionGeneratorOptions defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'dummyName' @ [93:38] ==> public final val dummyName: String? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorOptions[PropertyDescriptorImpl]

'config' @ [93:51] ==> value-parameter config: ExtractionGeneratorConfiguration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature[ValueParameterDescriptorImpl]

'descriptor' @ [93:58] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'name' @ [93:69] ==> public final val name: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'config' @ [95:9] ==> value-parameter config: ExtractionGeneratorConfiguration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature[ValueParameterDescriptorImpl]

'descriptor' @ [95:16] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'parameters' @ [95:27] ==> public final val parameters: List<Parameter> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'forEach' @ [95:38] ==> @HidesMembers public inline fun <T> Iterable<Parameter>.forEach(action: (Parameter) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Parameter

'param' @ [96:13] ==> public final fun param(name: String, type: String, defaultValue: String? = ...): KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedSimpleFunctionDescriptor]

'parameter' @ [96:19] ==> value-parameter parameter: Parameter defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [96:29] ==> public abstract val name: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.Parameter[PropertyDescriptorImpl]

'parameter' @ [97:19] ==> value-parameter parameter: Parameter defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'getParameterType' @ [97:29] ==> public abstract fun getParameterType(allowSpecialClassNames: Boolean): KotlinType defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.Parameter[SimpleFunctionDescriptorImpl]

'config' @ [97:46] ==> value-parameter config: ExtractionGeneratorConfiguration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature[ValueParameterDescriptorImpl]

'descriptor' @ [97:53] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'extractionData' @ [97:64] ==> public final val extractionData: ExtractionData defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'options' @ [97:79] ==> public final val options: ExtractionOptions defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[PropertyDescriptorImpl]

'allowSpecialClassNames' @ [97:87] ==> public final val allowSpecialClassNames: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionOptions[PropertyDescriptorImpl]

'typeAsString' @ [97:111] ==> local final fun KotlinType.typeAsString(): String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature.<anonymous>[SimpleFunctionDescriptorImpl]

'with' @ [100:9] ==> @InlineOnly public inline fun <T, R> with(receiver: KotlinType, block: KotlinType.() -> KtPsiFactory.CallableBuilder): KtPsiFactory.CallableBuilder defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType
    <R> -> CallableBuilder

'config' @ [100:14] ==> value-parameter config: ExtractionGeneratorConfiguration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature[ValueParameterDescriptorImpl]

'descriptor' @ [100:21] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'returnType' @ [100:32] ==> public final val returnType: KotlinType defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'if (isDefault() || isError || extractionTarget == ExtractionTarget.PROPERTY_WITH_INITIALIZER) {
                noReturnType()
            } else {
                returnType(typeAsString())
            }' @ [101:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtPsiFactory.CallableBuilder, elseBranch: KtPsiFactory.CallableBuilder): KtPsiFactory.CallableBuilder[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> CallableBuilder

'isDefault' @ [101:17] ==> internal fun KotlinType.isDefault(): Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine in file extractableAnalysisUtil.kt[SimpleFunctionDescriptorImpl]

'isError' @ [101:32] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types[DeserializedPropertyDescriptor]

'extractionTarget' @ [101:43] ==> val extractionTarget: ExtractionTarget defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature[LocalVariableDescriptor]

'ExtractionTarget' @ [101:63] ==> public companion object defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[FakeCallableDescriptorForObject]

'PROPERTY_WITH_INITIALIZER' @ [101:80] ==> enum entry PROPERTY_WITH_INITIALIZER defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[FakeCallableDescriptorForObject]

'noReturnType' @ [102:17] ==> public final fun noReturnType(): KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedSimpleFunctionDescriptor]

'returnType' @ [104:17] ==> public final fun returnType(type: String): KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedSimpleFunctionDescriptor]

'typeAsString' @ [104:28] ==> local final fun KotlinType.typeAsString(): String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature.<anonymous>[SimpleFunctionDescriptorImpl]

'typeConstraints' @ [108:9] ==> public final fun typeConstraints(values: Collection<String>): KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedSimpleFunctionDescriptor]

'config' @ [108:25] ==> value-parameter config: ExtractionGeneratorConfiguration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature[ValueParameterDescriptorImpl]

'descriptor' @ [108:32] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'typeParameters' @ [108:43] ==> public final val typeParameters: List<TypeParameter> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'flatMap' @ [108:58] ==> public inline fun <T, R> Iterable<TypeParameter>.flatMap(transform: (TypeParameter) -> Iterable<KtTypeConstraint>): List<KtTypeConstraint> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeParameter
    <R> -> KtTypeConstraint

'it' @ [108:68] ==> value-parameter it: TypeParameter defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'originalConstraints' @ [108:71] ==> public final val originalConstraints: List<KtTypeConstraint> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.TypeParameter[PropertyDescriptorImpl]

'map' @ [108:93] ==> public inline fun <T, R> Iterable<KtTypeConstraint>.map(transform: (KtTypeConstraint) -> String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtTypeConstraint
    <R> -> String

'it' @ [108:99] ==> value-parameter it: KtTypeConstraint defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.buildSignature.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'text' @ [108:102] ==> public final val KtTypeConstraint.text: (String..String?)[MyPropertyDescriptor]

'buildSignature' @ [112:90] ==> private fun buildSignature(config: ExtractionGeneratorConfiguration, renderer: DescriptorRenderer): KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine in file extractorUtil.kt[SimpleFunctionDescriptorImpl]

'this' @ [112:105] ==> <this> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.getSignaturePreview[ReceiverParameterDescriptorImpl]

'renderer' @ [112:111] ==> value-parameter renderer: DescriptorRenderer defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.getSignaturePreview[ValueParameterDescriptorImpl]

'asString' @ [112:121] ==> public final fun asString(): String defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedSimpleFunctionDescriptor]

'IdeDescriptorRenderers' @ [115:50] ==> public object IdeDescriptorRenderers defined in org.jetbrains.kotlin.idea.util[FakeCallableDescriptorForObject]

'SOURCE_CODE' @ [115:73] ==> @field:JvmField public final val SOURCE_CODE: DescriptorRenderer defined in org.jetbrains.kotlin.idea.util.IdeDescriptorRenderers[DeserializedPropertyDescriptor]

'generatorOptions' @ [117:28] ==> public final val generatorOptions: ExtractionGeneratorOptions defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'target' @ [117:45] ==> public final val target: ExtractionTarget defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorOptions[PropertyDescriptorImpl]

'!' @ [118:9] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'extractionTarget' @ [118:10] ==> val extractionTarget: ExtractionTarget defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.getDeclarationPattern[LocalVariableDescriptor]

'isAvailable' @ [118:27] ==> public abstract fun isAvailable(descriptor: ExtractableCodeDescriptor): Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[SimpleFunctionDescriptorImpl]

'descriptor' @ [118:39] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'ConflictsInTestsException' @ [119:40] ==> public constructor ConflictsInTestsException(@NotNull p0: (MutableCollection<out (String..String?)>..Collection<(String..String?)>)) defined in com.intellij.refactoring.BaseRefactoringProcessor.ConflictsInTestsException[JavaClassConstructorDescriptor]

'listOf' @ [119:66] ==> public fun <T> listOf(element: String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'extractionTarget' @ [119:91] ==> val extractionTarget: ExtractionTarget defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.getDeclarationPattern[LocalVariableDescriptor]

'targetName' @ [119:108] ==> public final val targetName: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[PropertyDescriptorImpl]

'descriptor' @ [119:123] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'extractionData' @ [119:134] ==> public final val extractionData: ExtractionData defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'codeFragmentText' @ [119:149] ==> public final val codeFragmentText: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[PropertyDescriptorImpl]

'buildSignature' @ [122:12] ==> private fun buildSignature(config: ExtractionGeneratorConfiguration, renderer: DescriptorRenderer): KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine in file extractorUtil.kt[SimpleFunctionDescriptorImpl]

'this' @ [122:27] ==> <this> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.getDeclarationPattern[ReceiverParameterDescriptorImpl]

'descriptorRenderer' @ [122:33] ==> value-parameter descriptorRenderer: DescriptorRenderer = ... defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.getDeclarationPattern[ValueParameterDescriptorImpl]

'let' @ [122:53] ==> @InlineOnly public inline fun <T, R> KtPsiFactory.CallableBuilder.let(block: (KtPsiFactory.CallableBuilder) -> String): String defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> CallableBuilder
    <R> -> String

'builder' @ [123:9] ==> value-parameter builder: KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.getDeclarationPattern.<anonymous>[ValueParameterDescriptorImpl]

'transform' @ [123:17] ==> public final fun transform(f: StringBuilder /* = StringBuilder */.() -> Unit): Unit defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedSimpleFunctionDescriptor]

'generateSequence' @ [124:23] ==> @LowPriorityInOverloadResolution public fun <T : Any> generateSequence(seed: Int?, nextFunction: (Int) -> Int?): Sequence<Int> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> Int

'indexOf' @ [124:40] ==> public fun CharSequence.indexOf(char: Char, startIndex: Int = ..., ignoreCase: Boolean = ...): Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'indexOf' @ [124:56] ==> public fun CharSequence.indexOf(char: Char, startIndex: Int = ..., ignoreCase: Boolean = ...): Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'it' @ [124:69] ==> value-parameter it: Int defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.getDeclarationPattern.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'i' @ [125:21] ==> val i: Int defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.getDeclarationPattern.<anonymous>.<anonymous>[LocalVariableDescriptor]

'insert' @ [126:17] ==> public open fun insert(p0: Int, p1: Char): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'i' @ [126:24] ==> val i: Int defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.getDeclarationPattern.<anonymous>.<anonymous>[LocalVariableDescriptor]

'when (extractionTarget) {
            ExtractionTarget.FUNCTION,
            ExtractionTarget.FAKE_LAMBDALIKE_FUNCTION,
            ExtractionTarget.PROPERTY_WITH_GETTER -> builder.blockBody("$0")
            ExtractionTarget.PROPERTY_WITH_INITIALIZER -> builder.initializer("$0")
            ExtractionTarget.LAZY_PROPERTY -> builder.lazyBody("$0")
        }' @ [130:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KtPsiFactory.CallableBuilder, entry1: KtPsiFactory.CallableBuilder, entry2: KtPsiFactory.CallableBuilder): KtPsiFactory.CallableBuilder[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> CallableBuilder

'extractionTarget' @ [130:15] ==> val extractionTarget: ExtractionTarget defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.getDeclarationPattern[LocalVariableDescriptor]

'ExtractionTarget' @ [131:13] ==> public companion object defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[FakeCallableDescriptorForObject]

'FUNCTION' @ [131:30] ==> enum entry FUNCTION defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[FakeCallableDescriptorForObject]

'ExtractionTarget' @ [132:13] ==> public companion object defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[FakeCallableDescriptorForObject]

'FAKE_LAMBDALIKE_FUNCTION' @ [132:30] ==> enum entry FAKE_LAMBDALIKE_FUNCTION defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[FakeCallableDescriptorForObject]

'ExtractionTarget' @ [133:13] ==> public companion object defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[FakeCallableDescriptorForObject]

'PROPERTY_WITH_GETTER' @ [133:30] ==> enum entry PROPERTY_WITH_GETTER defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[FakeCallableDescriptorForObject]

'builder' @ [133:54] ==> value-parameter builder: KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.getDeclarationPattern.<anonymous>[ValueParameterDescriptorImpl]

'blockBody' @ [133:62] ==> public final fun blockBody(body: String): KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedSimpleFunctionDescriptor]

'ExtractionTarget' @ [134:13] ==> public companion object defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[FakeCallableDescriptorForObject]

'PROPERTY_WITH_INITIALIZER' @ [134:30] ==> enum entry PROPERTY_WITH_INITIALIZER defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[FakeCallableDescriptorForObject]

'builder' @ [134:59] ==> value-parameter builder: KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.getDeclarationPattern.<anonymous>[ValueParameterDescriptorImpl]

'initializer' @ [134:67] ==> public final fun initializer(body: String): KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedSimpleFunctionDescriptor]

'ExtractionTarget' @ [135:13] ==> public companion object defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[FakeCallableDescriptorForObject]

'LAZY_PROPERTY' @ [135:30] ==> enum entry LAZY_PROPERTY defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[FakeCallableDescriptorForObject]

'builder' @ [135:47] ==> value-parameter builder: KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.getDeclarationPattern.<anonymous>[ValueParameterDescriptorImpl]

'lazyBody' @ [135:55] ==> public final fun lazyBody(body: String): KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedSimpleFunctionDescriptor]

'builder' @ [138:9] ==> value-parameter builder: KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.getDeclarationPattern.<anonymous>[ValueParameterDescriptorImpl]

'asString' @ [138:17] ==> public final fun asString(): String defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedSimpleFunctionDescriptor]

'this' @ [143:27] ==> <this> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.isSpecial[ReceiverParameterDescriptorImpl]

'constructor' @ [143:32] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'declarationDescriptor' @ [143:44] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'classDescriptor' @ [144:12] ==> val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.isSpecial[LocalVariableDescriptor]

'name' @ [144:28] ==> public final val ClassDescriptor.name: Name[MyPropertyDescriptor]

'isSpecial' @ [144:33] ==> public final val Name.isSpecial: Boolean[MyPropertyDescriptor]

'isLocal' @ [144:62] ==> public open fun isLocal(@NotNull p0: DeclarationDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'classDescriptor' @ [144:70] ==> val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.isSpecial[LocalVariableDescriptor]

'from' @ [148:12] ==> value-parameter from: KtElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.createNameCounterpartMap[ValueParameterDescriptorImpl]

'collectDescendantsOfType' @ [148:17] ==> public inline fun <reified T : PsiElement> PsiElement.collectDescendantsOfType(noinline predicate: (KtSimpleNameExpression) -> Boolean = ...): List<KtSimpleNameExpression> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtSimpleNameExpression

'zip' @ [148:68] ==> public infix fun <T, R> Iterable<KtSimpleNameExpression>.zip(other: Iterable<KtSimpleNameExpression>): List<Pair<KtSimpleNameExpression, KtSimpleNameExpression>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtSimpleNameExpression
    <R> -> KtSimpleNameExpression

'to' @ [148:72] ==> value-parameter to: KtElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.createNameCounterpartMap[ValueParameterDescriptorImpl]

'collectDescendantsOfType' @ [148:75] ==> public inline fun <reified T : PsiElement> PsiElement.collectDescendantsOfType(noinline predicate: (KtSimpleNameExpression) -> Boolean = ...): List<KtSimpleNameExpression> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtSimpleNameExpression

'toMap' @ [148:127] ==> public fun <K, V> Iterable<Pair<KtSimpleNameExpression, KtSimpleNameExpression>>.toMap(): Map<KtSimpleNameExpression, KtSimpleNameExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> KtSimpleNameExpression
    <V> -> KtSimpleNameExpression

'controlFlow' @ [159:26] ==> public final val controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'outputValues' @ [159:38] ==> public final val outputValues: List<OutputValue> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'size' @ [159:51] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'HashMap' @ [161:27] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>(p0: (MutableMap<out (KtElement..KtElement?), out (KtElement..KtElement?)>..Map<out (KtElement..KtElement?), (KtElement..KtElement?)>?)) defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> KtElement
    <V : (Any..Any?)> -> KtElement

'match' @ [161:35] ==> value-parameter match: UnificationResult.WeaklyMatched defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch[ValueParameterDescriptorImpl]

'weakMatches' @ [161:41] ==> public final val weakMatches: Map<KtElement, KtElement> defined in org.jetbrains.kotlin.idea.util.psi.patternMatching.UnificationResult.WeaklyMatched[DeserializedPropertyDescriptor]

'HashMap' @ [162:34] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> OutputValue
    <V : (Any..Any?)> -> OutputValue

'!=' @ [165:17] ==> public open fun equals(other: Any?): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'currentValue' @ [165:18] ==> value-parameter currentValue: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch.matchValues[ValueParameterDescriptorImpl]

'newValue' @ [165:44] ==> value-parameter newValue: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch.matchValues[ValueParameterDescriptorImpl]

'currentValue' @ [166:17] ==> value-parameter currentValue: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch.matchValues[ValueParameterDescriptorImpl]

'originalExpressions' @ [166:30] ==> public abstract val originalExpressions: List<KtExpression> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValue[PropertyDescriptorImpl]

'zip' @ [166:50] ==> public infix fun <T, R> Iterable<KtExpression>.zip(other: Iterable<KtExpression>): List<Pair<KtExpression, KtExpression>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression
    <R> -> KtExpression

'newValue' @ [166:54] ==> value-parameter newValue: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch.matchValues[ValueParameterDescriptorImpl]

'originalExpressions' @ [166:63] ==> public abstract val originalExpressions: List<KtExpression> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValue[PropertyDescriptorImpl]

'all' @ [166:84] ==> public inline fun <T> Iterable<Pair<KtExpression, KtExpression>>.all(predicate: (Pair<KtExpression, KtExpression>) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<KtExpression, KtExpression>

'weakMatches' @ [166:90] ==> val weakMatches: HashMap<KtElement, KtElement> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch[LocalVariableDescriptor]

'it' @ [166:102] ==> value-parameter it: Pair<KtExpression, KtExpression> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch.matchValues.<anonymous>[ValueParameterDescriptorImpl]

'first' @ [166:105] ==> public final val first: KtExpression defined in kotlin.Pair[DeserializedPropertyDescriptor]

'it' @ [166:115] ==> value-parameter it: Pair<KtExpression, KtExpression> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch.matchValues.<anonymous>[ValueParameterDescriptorImpl]

'second' @ [166:118] ==> public final val second: KtExpression defined in kotlin.Pair[DeserializedPropertyDescriptor]

'currentValuesToNew' @ [167:17] ==> val currentValuesToNew: HashMap<OutputValue, OutputValue> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch[LocalVariableDescriptor]

'currentValue' @ [167:36] ==> value-parameter currentValue: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch.matchValues[ValueParameterDescriptorImpl]

'newValue' @ [167:52] ==> value-parameter newValue: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch.matchValues[ValueParameterDescriptorImpl]

'weakMatches' @ [168:17] ==> val weakMatches: HashMap<KtElement, KtElement> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch[LocalVariableDescriptor]

'keys' @ [168:29] ==> public open val keys: MutableSet<KtElement> defined in java.util.HashMap[JavaPropertyDescriptor]

'removeAll' @ [168:34] ==> public abstract fun removeAll(elements: Collection<KtElement>): Boolean defined in kotlin.collections.MutableSet[DeserializedSimpleFunctionDescriptor]

'currentValue' @ [168:44] ==> value-parameter currentValue: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch.matchValues[ValueParameterDescriptorImpl]

'originalExpressions' @ [168:57] ==> public abstract val originalExpressions: List<KtExpression> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValue[PropertyDescriptorImpl]

'if (valueCount == 1) {
            matchValues(controlFlow.outputValues.first(), newControlFlow.outputValues.first())
        } else {
            outer@
            for (currentValue in controlFlow.outputValues)
                for (newValue in newControlFlow.outputValues) {
                    if ((currentValue is ExpressionValue) != (newValue is ExpressionValue)) continue
                    if (matchValues(currentValue, newValue)) continue@outer
                }
        }' @ [174:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any, elseBranch: Any): Any[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any

'valueCount' @ [174:13] ==> val valueCount: Int defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch[LocalVariableDescriptor]

'matchValues' @ [175:13] ==> local final fun matchValues(currentValue: OutputValue, newValue: OutputValue): Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch[SimpleFunctionDescriptorImpl]

'controlFlow' @ [175:25] ==> public final val controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'outputValues' @ [175:37] ==> public final val outputValues: List<OutputValue> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'first' @ [175:50] ==> public fun <T> List<OutputValue>.first(): OutputValue defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> OutputValue

'newControlFlow' @ [175:59] ==> value-parameter newControlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch[ValueParameterDescriptorImpl]

'outputValues' @ [175:74] ==> public final val outputValues: List<OutputValue> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'first' @ [175:87] ==> public fun <T> List<OutputValue>.first(): OutputValue defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> OutputValue

'controlFlow' @ [178:34] ==> public final val controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'outputValues' @ [178:46] ==> public final val outputValues: List<OutputValue> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'newControlFlow' @ [179:34] ==> value-parameter newControlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch[ValueParameterDescriptorImpl]

'outputValues' @ [179:49] ==> public final val outputValues: List<OutputValue> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'!=' @ [180:25] ==> public open fun equals(other: Any?): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'currentValue' @ [180:26] ==> val currentValue: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch[LocalVariableDescriptor]

'newValue' @ [180:63] ==> val newValue: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch[LocalVariableDescriptor]

'matchValues' @ [181:25] ==> local final fun matchValues(currentValue: OutputValue, newValue: OutputValue): Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch[SimpleFunctionDescriptorImpl]

'currentValue' @ [181:37] ==> val currentValue: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch[LocalVariableDescriptor]

'newValue' @ [181:51] ==> val newValue: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch[LocalVariableDescriptor]

'currentValuesToNew' @ [185:16] ==> val currentValuesToNew: HashMap<OutputValue, OutputValue> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch[LocalVariableDescriptor]

'size' @ [185:35] ==> public open val size: Int defined in java.util.HashMap[JavaPropertyDescriptor]

'valueCount' @ [185:43] ==> val valueCount: Int defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch[LocalVariableDescriptor]

'weakMatches' @ [185:57] ==> val weakMatches: HashMap<KtElement, KtElement> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.processWeakMatch[LocalVariableDescriptor]

'isEmpty' @ [185:69] ==> public open fun isEmpty(): Boolean defined in java.util.HashMap[JavaMethodDescriptor]

'extractionData' @ [189:30] ==> public final val extractionData: ExtractionData defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'copy' @ [189:45] ==> public final fun copy(originalFile: KtFile = ..., originalRange: KotlinPsiRange = ..., targetSibling: PsiElement = ..., duplicateContainer: PsiElement? = ..., options: ExtractionOptions = ...): ExtractionData defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[SimpleFunctionDescriptorImpl]

'match' @ [189:66] ==> value-parameter match: UnificationResult.Matched defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.getControlFlowIfMatched[ValueParameterDescriptorImpl]

'range' @ [189:72] ==> public abstract val range: KotlinPsiRange defined in org.jetbrains.kotlin.idea.util.psi.patternMatching.UnificationResult.Matched[DeserializedPropertyDescriptor]

'performAnalysis' @ [189:79] ==> public fun ExtractionData.performAnalysis(): AnalysisResult defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine in file extractableAnalysisUtil.kt[SimpleFunctionDescriptorImpl]

'analysisResult' @ [190:13] ==> val analysisResult: AnalysisResult defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.getControlFlowIfMatched[LocalVariableDescriptor]

'status' @ [190:28] ==> public final val status: AnalysisResult.Status defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.AnalysisResult[PropertyDescriptorImpl]

'SUCCESS' @ [190:60] ==> enum entry SUCCESS defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.AnalysisResult.Status[FakeCallableDescriptorForObject]

'analysisResult' @ [192:30] ==> val analysisResult: AnalysisResult defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.getControlFlowIfMatched[LocalVariableDescriptor]

'descriptor' @ [192:45] ==> public final val descriptor: ExtractableCodeDescriptor? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.AnalysisResult[PropertyDescriptorImpl]

'controlFlow' @ [192:58] ==> public final val controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'newControlFlow' @ [193:13] ==> val newControlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.getControlFlowIfMatched[LocalVariableDescriptor]

'outputValues' @ [193:28] ==> public final val outputValues: List<OutputValue> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'isEmpty' @ [193:41] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'newControlFlow' @ [193:59] ==> val newControlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.getControlFlowIfMatched[LocalVariableDescriptor]

'controlFlow' @ [194:13] ==> public final val controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'outputValues' @ [194:25] ==> public final val outputValues: List<OutputValue> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'size' @ [194:38] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'newControlFlow' @ [194:46] ==> val newControlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.getControlFlowIfMatched[LocalVariableDescriptor]

'outputValues' @ [194:61] ==> public final val outputValues: List<OutputValue> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'size' @ [194:74] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'when (match) {
            is StronglyMatched -> true
            is WeaklyMatched -> processWeakMatch(match, newControlFlow)
            else -> throw AssertionError("Unexpected unification result: $match")
        }' @ [196:23] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean, entry2: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'match' @ [196:29] ==> value-parameter match: UnificationResult.Matched defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.getControlFlowIfMatched[ValueParameterDescriptorImpl]

'processWeakMatch' @ [198:33] ==> local final fun processWeakMatch(match: UnificationResult.WeaklyMatched, newControlFlow: ControlFlow): Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates[SimpleFunctionDescriptorImpl]

'match' @ [198:50] ==> value-parameter match: UnificationResult.Matched defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.getControlFlowIfMatched[ValueParameterDescriptorImpl]

'newControlFlow' @ [198:57] ==> val newControlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.getControlFlowIfMatched[LocalVariableDescriptor]

'AssertionError' @ [199:27] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'match' @ [199:75] ==> value-parameter match: UnificationResult.Matched defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.getControlFlowIfMatched[ValueParameterDescriptorImpl]

'if (matched) newControlFlow else null' @ [202:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: ControlFlow?, elseBranch: ControlFlow?): ControlFlow?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> ControlFlow?

'matched' @ [202:20] ==> val matched: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.getControlFlowIfMatched[LocalVariableDescriptor]

'newControlFlow' @ [202:29] ==> val newControlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.getControlFlowIfMatched[LocalVariableDescriptor]

'parameters' @ [205:29] ==> public final val parameters: List<Parameter> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'map' @ [205:40] ==> public inline fun <T, R> Iterable<Parameter>.map(transform: (Parameter) -> UnifierParameter): List<UnifierParameter> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Parameter
    <R> -> UnifierParameter

'UnifierParameter' @ [205:46] ==> public constructor UnifierParameter(descriptor: DeclarationDescriptor, expectedType: KotlinType?) defined in org.jetbrains.kotlin.idea.util.psi.patternMatching.UnifierParameter[DeserializedClassConstructorDescriptor]

'it' @ [205:63] ==> value-parameter it: Parameter defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.<anonymous>[ValueParameterDescriptorImpl]

'originalDescriptor' @ [205:66] ==> public abstract val originalDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.Parameter[PropertyDescriptorImpl]

'it' @ [205:86] ==> value-parameter it: Parameter defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.<anonymous>[ValueParameterDescriptorImpl]

'getParameterType' @ [205:89] ==> public abstract fun getParameterType(allowSpecialClassNames: Boolean): KotlinType defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.Parameter[SimpleFunctionDescriptorImpl]

'extractionData' @ [205:106] ==> public final val extractionData: ExtractionData defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'options' @ [205:121] ==> public final val options: ExtractionOptions defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[PropertyDescriptorImpl]

'allowSpecialClassNames' @ [205:129] ==> public final val allowSpecialClassNames: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionOptions[PropertyDescriptorImpl]

'KotlinPsiUnifier' @ [207:19] ==> public constructor KotlinPsiUnifier(parameters: Collection<UnifierParameter> = ..., allowWeakMatches: Boolean = ...) defined in org.jetbrains.kotlin.idea.util.psi.patternMatching.KotlinPsiUnifier[DeserializedClassConstructorDescriptor]

'unifierParameters' @ [207:36] ==> val unifierParameters: List<UnifierParameter> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates[LocalVariableDescriptor]

'getOccurrenceContainer' @ [209:24] ==> private fun ExtractableCodeDescriptor.getOccurrenceContainer(): PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine in file extractorUtil.kt[SimpleFunctionDescriptorImpl]

'emptyList' @ [209:71] ==> public final fun <T : (Any..Any?)> emptyList(): (MutableList<(DuplicateInfo..DuplicateInfo?)>..List<(DuplicateInfo..DuplicateInfo?)>?) defined in java.util.Collections[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> DuplicateInfo

'extractionData' @ [210:29] ==> public final val extractionData: ExtractionData defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'originalRange' @ [210:44] ==> public final val originalRange: KotlinPsiRange defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[PropertyDescriptorImpl]

'getPhysicalTextRange' @ [210:58] ==> public fun KotlinPsiRange.getPhysicalTextRange(): TextRange defined in org.jetbrains.kotlin.idea.refactoring.introduce in file introduceUtil.kt[SimpleFunctionDescriptorImpl]

'extractionData' @ [211:12] ==> public final val extractionData: ExtractionData defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'originalRange' @ [212:14] ==> public final val originalRange: KotlinPsiRange defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[PropertyDescriptorImpl]

'match' @ [213:14] ==> public open fun match(scope: PsiElement, unifier: KotlinPsiUnifier): List<UnificationResult.Matched> defined in org.jetbrains.kotlin.idea.util.psi.patternMatching.KotlinPsiRange[DeserializedSimpleFunctionDescriptor]

'scopeElement' @ [213:20] ==> val scopeElement: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates[LocalVariableDescriptor]

'unifier' @ [213:34] ==> val unifier: KotlinPsiUnifier defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates[LocalVariableDescriptor]

'asSequence' @ [214:14] ==> public fun <T> Iterable<UnificationResult.Matched>.asSequence(): Sequence<UnificationResult.Matched> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Matched

'filter' @ [215:14] ==> public fun <T> Sequence<UnificationResult.Matched>.filter(predicate: (UnificationResult.Matched) -> Boolean): Sequence<UnificationResult.Matched> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Matched

'!' @ [215:23] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'it' @ [215:25] ==> value-parameter it: UnificationResult.Matched defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.<anonymous>[ValueParameterDescriptorImpl]

'range' @ [215:28] ==> public abstract val range: KotlinPsiRange defined in org.jetbrains.kotlin.idea.util.psi.patternMatching.UnificationResult.Matched[DeserializedPropertyDescriptor]

'getPhysicalTextRange' @ [215:34] ==> public fun KotlinPsiRange.getPhysicalTextRange(): TextRange defined in org.jetbrains.kotlin.idea.refactoring.introduce in file introduceUtil.kt[SimpleFunctionDescriptorImpl]

'intersects' @ [215:57] ==> public open fun intersects(@NotNull p0: TextRange): Boolean defined in com.intellij.openapi.util.TextRange[JavaMethodDescriptor]

'originalTextRange' @ [215:68] ==> val originalTextRange: TextRange defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates[LocalVariableDescriptor]

'mapNotNull' @ [216:14] ==> public fun <T, R : Any> Sequence<UnificationResult.Matched>.mapNotNull(transform: (UnificationResult.Matched) -> DuplicateInfo?): Sequence<DuplicateInfo> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Matched
    <R : Any> -> DuplicateInfo

'getControlFlowIfMatched' @ [217:35] ==> local final fun getControlFlowIfMatched(match: UnificationResult.Matched): ControlFlow? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates[SimpleFunctionDescriptorImpl]

'match' @ [217:59] ==> value-parameter match: UnificationResult.Matched defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.<anonymous>[ValueParameterDescriptorImpl]

'with' @ [218:29] ==> @InlineOnly public inline fun <T, R> with(receiver: KotlinPsiRange, block: KotlinPsiRange.() -> KotlinPsiRange): KotlinPsiRange defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinPsiRange
    <R> -> KotlinPsiRange

'match' @ [218:34] ==> value-parameter match: UnificationResult.Matched defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.<anonymous>[ValueParameterDescriptorImpl]

'range' @ [218:40] ==> public abstract val range: KotlinPsiRange defined in org.jetbrains.kotlin.idea.util.psi.patternMatching.UnificationResult.Matched[DeserializedPropertyDescriptor]

'?:' @ [219:21] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KotlinPsiRange?, right: KotlinPsiRange): KotlinPsiRange[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KotlinPsiRange

'elements' @ [219:22] ==> public abstract val elements: List<PsiElement> defined in org.jetbrains.kotlin.idea.util.psi.patternMatching.KotlinPsiRange[DeserializedPropertyDescriptor]

'singleOrNull' @ [219:31] ==> public fun <T> List<PsiElement>.singleOrNull(): PsiElement? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'expression' @ [219:88] ==> public final val KtStringTemplateEntryWithExpression.expression: KtExpression?[MyPropertyDescriptor]

'toRange' @ [219:100] ==> public fun PsiElement?.toRange(): KotlinPsiRange defined in org.jetbrains.kotlin.idea.util.psi.patternMatching[DeserializedSimpleFunctionDescriptor]

'this' @ [219:113] ==> <this> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.<anonymous>.<anonymous>[ReceiverParameterDescriptorImpl]

'controlFlow' @ [221:17] ==> val controlFlow: ControlFlow? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.<anonymous>[LocalVariableDescriptor]

'let' @ [221:30] ==> @InlineOnly public inline fun <T, R> ControlFlow.let(block: (ControlFlow) -> DuplicateInfo): DuplicateInfo defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ControlFlow
    <R> -> DuplicateInfo

'DuplicateInfo' @ [221:36] ==> public constructor DuplicateInfo(range: KotlinPsiRange, controlFlow: ControlFlow, arguments: List<String>) defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.DuplicateInfo[ClassConstructorDescriptorImpl]

'range' @ [221:50] ==> val range: KotlinPsiRange defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.<anonymous>[LocalVariableDescriptor]

'it' @ [221:57] ==> value-parameter it: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'unifierParameters' @ [221:61] ==> val unifierParameters: List<UnifierParameter> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates[LocalVariableDescriptor]

'map' @ [221:79] ==> public inline fun <T, R> Iterable<UnifierParameter>.map(transform: (UnifierParameter) -> String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> UnifierParameter
    <R> -> String

'match' @ [221:85] ==> value-parameter match: UnificationResult.Matched defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.<anonymous>[ValueParameterDescriptorImpl]

'substitution' @ [221:91] ==> public abstract val substitution: Map<UnifierParameter, KtElement> defined in org.jetbrains.kotlin.idea.util.psi.patternMatching.UnificationResult.Matched[DeserializedPropertyDescriptor]

'it' @ [221:104] ==> value-parameter it: UnifierParameter defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.findDuplicates.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'text' @ [221:110] ==> public final val KtElement.text: (String..String?)[MyPropertyDescriptor]

'toList' @ [223:14] ==> public fun <T> Sequence<DuplicateInfo>.toList(): List<DuplicateInfo> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DuplicateInfo

'extractionData' @ [227:12] ==> public final val extractionData: ExtractionData defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'duplicateContainer' @ [227:27] ==> public final val duplicateContainer: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[PropertyDescriptorImpl]

'extractionData' @ [227:49] ==> public final val extractionData: ExtractionData defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'targetSibling' @ [227:64] ==> public final val targetSibling: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[PropertyDescriptorImpl]

'parent' @ [227:78] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'rangeToReplace' @ [237:31] ==> value-parameter rangeToReplace: KotlinPsiRange defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[ValueParameterDescriptorImpl]

'elements' @ [237:46] ==> public abstract val elements: List<PsiElement> defined in org.jetbrains.kotlin.idea.util.psi.patternMatching.KotlinPsiRange[DeserializedPropertyDescriptor]

'firstOrNull' @ [237:55] ==> public inline fun <T> Iterable<PsiElement>.firstOrNull(predicate: (PsiElement) -> Boolean): PsiElement? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'it' @ [237:69] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.insertCall.<anonymous>[ValueParameterDescriptorImpl]

'firstExpression' @ [238:13] ==> val firstExpression: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.insertCall[LocalVariableDescriptor]

'isLambdaOutsideParentheses' @ [238:30] ==> public fun KtExpression.isLambdaOutsideParentheses(): Boolean defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'firstExpression' @ [239:43] ==> val firstExpression: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.insertCall[LocalVariableDescriptor]

'getStrictParentOfType' @ [239:60] ==> public inline fun <reified T : PsiElement> PsiElement.getStrictParentOfType(): KtLambdaArgument? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtLambdaArgument

'functionLiteralArgument' @ [240:20] ==> val functionLiteralArgument: KtLambdaArgument defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.insertCall[LocalVariableDescriptor]

'moveInsideParenthesesAndReplaceWith' @ [240:44] ==> public fun KtLambdaArgument.moveInsideParenthesesAndReplaceWith(replacement: KtExpression, bindingContext: BindingContext): KtCallExpression defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]

'wrappedCall' @ [240:80] ==> value-parameter wrappedCall: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.insertCall[ValueParameterDescriptorImpl]

'extractableDescriptor' @ [240:93] ==> value-parameter extractableDescriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[ValueParameterDescriptorImpl]

'originalContext' @ [240:115] ==> public final val originalContext: BindingContext defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'anchor' @ [243:13] ==> value-parameter anchor: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.insertCall[ValueParameterDescriptorImpl]

'anchor' @ [244:39] ==> value-parameter anchor: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.insertCall[ValueParameterDescriptorImpl]

'parent' @ [244:46] ==> public final val KtOperationReferenceExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'when (operationExpression) {
                is KtUnaryExpression -> OperatorToFunctionIntention.convert(operationExpression).second
                is KtBinaryExpression -> {
                    InfixCallToOrdinaryIntention.convert(operationExpression).getCalleeExpressionIfAny()
                }
                else -> null
            }' @ [245:37] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KtExpression?, entry1: KtExpression?, entry2: KtExpression?): KtExpression?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KtExpression?

'operationExpression' @ [245:43] ==> val operationExpression: KtOperationExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.insertCall[LocalVariableDescriptor]

'OperatorToFunctionIntention' @ [246:41] ==> public companion object defined in org.jetbrains.kotlin.idea.intentions.OperatorToFunctionIntention[FakeCallableDescriptorForObject]

'convert' @ [246:69] ==> public final fun convert(element: KtExpression): Pair<KtExpression, KtSimpleNameExpression> defined in org.jetbrains.kotlin.idea.intentions.OperatorToFunctionIntention.Companion[DeserializedSimpleFunctionDescriptor]

'operationExpression' @ [246:77] ==> val operationExpression: KtOperationExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.insertCall[LocalVariableDescriptor]

'second' @ [246:98] ==> public final val second: KtSimpleNameExpression defined in kotlin.Pair[DeserializedPropertyDescriptor]

'InfixCallToOrdinaryIntention' @ [248:21] ==> public companion object defined in org.jetbrains.kotlin.idea.intentions.InfixCallToOrdinaryIntention[FakeCallableDescriptorForObject]

'convert' @ [248:50] ==> public final fun convert(element: KtBinaryExpression): KtExpression defined in org.jetbrains.kotlin.idea.intentions.InfixCallToOrdinaryIntention.Companion[SimpleFunctionDescriptorImpl]

'operationExpression' @ [248:58] ==> val operationExpression: KtOperationExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.insertCall[LocalVariableDescriptor]

'getCalleeExpressionIfAny' @ [248:79] ==> public fun KtElement?.getCalleeExpressionIfAny(): KtExpression? defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'newNameExpression' @ [252:20] ==> val newNameExpression: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.insertCall[LocalVariableDescriptor]

'replaced' @ [252:39] ==> public inline fun <reified T : PsiElement> PsiElement.replaced(newElement: KtExpression): KtExpression defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtExpression

'wrappedCall' @ [252:48] ==> value-parameter wrappedCall: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.insertCall[ValueParameterDescriptorImpl]

'anchor' @ [255:10] ==> value-parameter anchor: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.insertCall[ValueParameterDescriptorImpl]

'extractableSubstringInfo' @ [255:36] ==> public var KtExpression.extractableSubstringInfo: ExtractableSubstringInfo? defined in org.jetbrains.kotlin.idea.refactoring.introduce[DeserializedPropertyDescriptor]

'let' @ [255:62] ==> @InlineOnly public inline fun <T, R> ExtractableSubstringInfo.let(block: (ExtractableSubstringInfo) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExtractableSubstringInfo
    <R> -> Nothing

'it' @ [256:20] ==> value-parameter it: ExtractableSubstringInfo defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.insertCall.<anonymous>[ValueParameterDescriptorImpl]

'replaceWith' @ [256:23] ==> public fun ExtractableSubstringInfo.replaceWith(replacement: KtExpression): KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce in file introduceUtil.kt[SimpleFunctionDescriptorImpl]

'wrappedCall' @ [256:35] ==> value-parameter wrappedCall: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.insertCall[ValueParameterDescriptorImpl]

'anchor' @ [259:16] ==> value-parameter anchor: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.insertCall[ValueParameterDescriptorImpl]

'replaced' @ [259:23] ==> public inline fun <reified T : PsiElement> PsiElement.replaced(newElement: KtExpression): KtExpression defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtExpression

'wrappedCall' @ [259:32] ==> value-parameter wrappedCall: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.insertCall[ValueParameterDescriptorImpl]

'rangeToReplace' @ [262:9] ==> value-parameter rangeToReplace: KotlinPsiRange defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[ValueParameterDescriptorImpl]

'rangeToReplace' @ [264:18] ==> value-parameter rangeToReplace: KotlinPsiRange defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[ValueParameterDescriptorImpl]

'startElement' @ [264:33] ==> public final val startElement: PsiElement defined in org.jetbrains.kotlin.idea.util.psi.patternMatching.KotlinPsiRange.ListRange[DeserializedPropertyDescriptor]

'anchor' @ [265:24] ==> val anchor: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'parent' @ [265:31] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'anchor' @ [267:5] ==> val anchor: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'nextSibling' @ [267:12] ==> public final val PsiElement.nextSibling: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'let' @ [267:25] ==> @InlineOnly public inline fun <T, R> PsiElement.let(block: (PsiElement) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement
    <R> -> Unit

'rangeToReplace' @ [268:18] ==> value-parameter rangeToReplace: KotlinPsiRange defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[ValueParameterDescriptorImpl]

'endElement' @ [268:33] ==> public final val endElement: PsiElement defined in org.jetbrains.kotlin.idea.util.psi.patternMatching.KotlinPsiRange.ListRange[DeserializedPropertyDescriptor]

'to' @ [269:13] ==> val to: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.<anonymous>[LocalVariableDescriptor]

'anchor' @ [269:19] ==> val anchor: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'anchorParent' @ [270:13] ==> val anchorParent: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'deleteChildRange' @ [270:26] ==> public abstract fun deleteChildRange(p0: (PsiElement..PsiElement?), p1: (PsiElement..PsiElement?)): Unit defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'from' @ [270:43] ==> value-parameter from: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.<anonymous>[ValueParameterDescriptorImpl]

'to' @ [270:49] ==> val to: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.<anonymous>[LocalVariableDescriptor]

'declaration' @ [274:22] ==> value-parameter declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[ValueParameterDescriptorImpl]

'name' @ [274:34] ==> public final val KtNamedDeclaration.name: String?[MyPropertyDescriptor]

'quoteIfNeeded' @ [274:40] ==> public fun String.quoteIfNeeded(): String defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]

'when (declaration) {
        is KtNamedFunction -> {
            val argumentsText = arguments.joinToString(separator = ", ", prefix = "(", postfix = ")")
            val typeArguments = extractableDescriptor.typeParameters.map { it.originalDeclaration.name }
            val typeArgumentsText = with(typeArguments) {
                if (isNotEmpty()) joinToString(separator = ", ", prefix = "<", postfix = ">") else ""
            }
            "$calleeName$typeArgumentsText$argumentsText"
        }
        else -> calleeName
    }' @ [275:20] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: String?, entry1: String?): String?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> String?

'declaration' @ [275:26] ==> value-parameter declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[ValueParameterDescriptorImpl]

'arguments' @ [277:33] ==> value-parameter arguments: List<String> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[ValueParameterDescriptorImpl]

'joinToString' @ [277:43] ==> public fun <T> Iterable<String>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((String) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'extractableDescriptor' @ [278:33] ==> value-parameter extractableDescriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[ValueParameterDescriptorImpl]

'typeParameters' @ [278:55] ==> public final val typeParameters: List<TypeParameter> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'map' @ [278:70] ==> public inline fun <T, R> Iterable<TypeParameter>.map(transform: (TypeParameter) -> String?): List<String?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeParameter
    <R> -> String?

'it' @ [278:76] ==> value-parameter it: TypeParameter defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.<anonymous>[ValueParameterDescriptorImpl]

'originalDeclaration' @ [278:79] ==> public final val originalDeclaration: KtTypeParameter defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.TypeParameter[PropertyDescriptorImpl]

'name' @ [278:99] ==> public final val KtTypeParameter.name: String?[MyPropertyDescriptor]

'with' @ [279:37] ==> @InlineOnly public inline fun <T, R> with(receiver: List<String?>, block: List<String?>.() -> String): String defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> List<String?>
    <R> -> String

'typeArguments' @ [279:42] ==> val typeArguments: List<String?> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'if (isNotEmpty()) joinToString(separator = ", ", prefix = "<", postfix = ">") else ""' @ [280:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'isNotEmpty' @ [280:21] ==> @InlineOnly public inline fun <T> Collection<String?>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String?

'joinToString' @ [280:35] ==> public fun <T> Iterable<String?>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((String?) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String?

'calleeName' @ [282:15] ==> val calleeName: String? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'typeArgumentsText' @ [282:26] ==> val typeArgumentsText: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'argumentsText' @ [282:44] ==> val argumentsText: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'calleeName' @ [284:17] ==> val calleeName: String? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'generateSequence' @ [287:25] ==> @LowPriorityInOverloadResolution public fun <T : Any> generateSequence(seed: PsiElement?, nextFunction: (PsiElement) -> PsiElement?): Sequence<PsiElement> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> PsiElement

'anchor' @ [287:42] ==> val anchor: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'it' @ [287:52] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.<anonymous>[ValueParameterDescriptorImpl]

'parent' @ [287:55] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'firstOrNull' @ [287:64] ==> public inline fun <T> Sequence<PsiElement>.firstOrNull(predicate: (PsiElement) -> Boolean): PsiElement? defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'it' @ [287:78] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.<anonymous>[ValueParameterDescriptorImpl]

'parent' @ [287:81] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'?:' @ [288:17] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: PsiElement?, right: PsiElement): PsiElement[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> PsiElement

'anchorInBlock' @ [288:18] ==> val anchorInBlock: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'parent' @ [288:33] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'anchorParent' @ [288:66] ==> val anchorParent: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'KtPsiFactory' @ [290:22] ==> @JvmOverloads public constructor KtPsiFactory(project: Project, markGenerated: Boolean = ...) defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedClassConstructorDescriptor]

'anchor' @ [290:35] ==> val anchor: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'project' @ [290:42] ==> public final val PsiElement.project: Project[MyPropertyDescriptor]

'psiFactory' @ [291:19] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'createNewLine' @ [291:30] ==> public final fun createNewLine(): PsiElement defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'controlFlow' @ [293:9] ==> value-parameter controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[ValueParameterDescriptorImpl]

'outputValueBoxer' @ [293:21] ==> public final val outputValueBoxer: OutputValueBoxer defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'controlFlow' @ [293:52] ==> value-parameter controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[ValueParameterDescriptorImpl]

'outputValues' @ [293:64] ==> public final val outputValues: List<OutputValue> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'size' @ [293:77] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'controlFlow' @ [293:89] ==> value-parameter controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[ValueParameterDescriptorImpl]

'outputValues' @ [293:101] ==> public final val outputValues: List<OutputValue> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'all' @ [293:114] ==> public inline fun <T> Iterable<OutputValue>.all(predicate: (OutputValue) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> OutputValue

'it' @ [293:120] ==> value-parameter it: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.<anonymous>[ValueParameterDescriptorImpl]

'controlFlow' @ [294:35] ==> value-parameter controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[ValueParameterDescriptorImpl]

'outputValues' @ [294:47] ==> public final val outputValues: List<OutputValue> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'map' @ [294:60] ==> public inline fun <T, R> Iterable<OutputValue>.map(transform: (OutputValue) -> KtProperty): List<KtProperty> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> OutputValue
    <R> -> KtProperty

'it' @ [294:67] ==> value-parameter it: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.<anonymous>[ValueParameterDescriptorImpl]

'initializedDeclaration' @ [294:86] ==> public final val initializedDeclaration: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValue.Initializer[PropertyDescriptorImpl]

'declarationsToMerge' @ [295:21] ==> val declarationsToMerge: List<KtProperty> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'first' @ [295:41] ==> public fun <T> List<KtProperty>.first(): KtProperty defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtProperty

'isVar' @ [295:49] ==> public final val KtProperty.isVar: Boolean[MyPropertyDescriptor]

'declarationsToMerge' @ [296:13] ==> val declarationsToMerge: List<KtProperty> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'all' @ [296:33] ==> public inline fun <T> Iterable<KtProperty>.all(predicate: (KtProperty) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtProperty

'it' @ [296:39] ==> value-parameter it: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.<anonymous>[ValueParameterDescriptorImpl]

'isVar' @ [296:42] ==> public final val KtProperty.isVar: Boolean[MyPropertyDescriptor]

'isVar' @ [296:51] ==> val isVar: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'controlFlow' @ [297:13] ==> value-parameter controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[ValueParameterDescriptorImpl]

'declarationsToCopy' @ [297:25] ==> public final val declarationsToCopy: List<KtDeclaration> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'subtract' @ [297:44] ==> public infix fun <T> Iterable<KtDeclaration>.subtract(other: Iterable<KtDeclaration>): Set<KtDeclaration> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtDeclaration

'declarationsToMerge' @ [297:53] ==> val declarationsToMerge: List<KtProperty> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'forEach' @ [297:74] ==> @HidesMembers public inline fun <T> Iterable<KtDeclaration>.forEach(action: (KtDeclaration) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtDeclaration

'block' @ [298:17] ==> val block: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'addBefore' @ [298:23] ==> public abstract fun addBefore(@NotNull p0: PsiElement, @Nullable p1: PsiElement?): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'psiFactory' @ [298:33] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'createDeclaration' @ [298:44] ==> public final fun <TDeclaration : KtDeclaration> createDeclaration(text: String): KtDeclaration defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <TDeclaration : KtDeclaration> -> KtDeclaration

'it' @ [298:77] ==> value-parameter it: KtDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.<anonymous>[ValueParameterDescriptorImpl]

'text' @ [298:80] ==> public final val KtDeclaration.text: (String..String?)[MyPropertyDescriptor]

'anchorInBlock' @ [298:89] ==> val anchorInBlock: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'block' @ [299:17] ==> val block: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'addBefore' @ [299:23] ==> public abstract fun addBefore(@NotNull p0: PsiElement, @Nullable p1: PsiElement?): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'newLine' @ [299:33] ==> val newLine: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'anchorInBlock' @ [299:42] ==> val anchorInBlock: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'declarationsToMerge' @ [302:27] ==> val declarationsToMerge: List<KtProperty> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'map' @ [302:47] ==> public inline fun <T, R> Iterable<KtProperty>.map(transform: (KtProperty) -> String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtProperty
    <R> -> String

'p' @ [302:58] ==> value-parameter p: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [302:60] ==> public final val KtProperty.name: String?[MyPropertyDescriptor]

'p' @ [302:68] ==> value-parameter p: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.<anonymous>[ValueParameterDescriptorImpl]

'typeReference' @ [302:70] ==> public final var KtProperty.typeReference: KtTypeReference?[MyPropertyDescriptor]

'let' @ [302:85] ==> @InlineOnly public inline fun <T, R> KtTypeReference.let(block: (KtTypeReference) -> String): String defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtTypeReference
    <R> -> String

'it' @ [302:96] ==> value-parameter it: KtTypeReference defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'text' @ [302:99] ==> public final val KtTypeReference.text: (String..String?)[MyPropertyDescriptor]

'anchorInBlock' @ [303:13] ==> val anchorInBlock: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'replace' @ [303:28] ==> public abstract fun replace(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'psiFactory' @ [304:21] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'createDestructuringDeclaration' @ [304:32] ==> public final fun createDestructuringDeclaration(text: String): KtDestructuringDeclaration defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'if (isVar) "var" else "val"' @ [304:66] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'isVar' @ [304:70] ==> val isVar: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'entries' @ [304:98] ==> val entries: List<String> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'joinToString' @ [304:106] ==> public fun <T> Iterable<String>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((String) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'callText' @ [304:126] ==> val callText: String? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'controlFlow' @ [311:25] ==> value-parameter controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[ValueParameterDescriptorImpl]

'outputValues' @ [311:37] ==> public final val outputValues: List<OutputValue> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'size' @ [311:50] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'if (inlinableCall) {
                controlFlow.outputValueBoxer.getUnboxingExpressions(callText!!)
            }
            else {
                val varNameValidator = NewDeclarationNameValidator(block, anchorInBlock, NewDeclarationNameValidator.Target.VARIABLES)
                val resultVal = KotlinNameSuggester.suggestNamesByType(extractableDescriptor.returnType, varNameValidator, null).first()
                block.addBefore(psiFactory.createDeclaration("val $resultVal = $callText"), anchorInBlock)
                block.addBefore(newLine, anchorInBlock)
                controlFlow.outputValueBoxer.getUnboxingExpressions(resultVal)
            }' @ [313:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Map<OutputValue, String>, elseBranch: Map<OutputValue, String>): Map<OutputValue, String>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Map<OutputValue, String>

'inlinableCall' @ [313:17] ==> val inlinableCall: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'controlFlow' @ [314:17] ==> value-parameter controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[ValueParameterDescriptorImpl]

'outputValueBoxer' @ [314:29] ==> public final val outputValueBoxer: OutputValueBoxer defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'getUnboxingExpressions' @ [314:46] ==> public abstract fun getUnboxingExpressions(boxedText: String): Map<OutputValue, String> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValueBoxer[SimpleFunctionDescriptorImpl]

'callText' @ [314:69] ==> val callText: String? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'NewDeclarationNameValidator' @ [317:40] ==> public constructor NewDeclarationNameValidator(container: PsiElement, anchor: PsiElement?, target: NewDeclarationNameValidator.Target, excludedDeclarations: List<KtDeclaration> = ...) defined in org.jetbrains.kotlin.idea.core.NewDeclarationNameValidator[DeserializedClassConstructorDescriptor]

'block' @ [317:68] ==> val block: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'anchorInBlock' @ [317:75] ==> val anchorInBlock: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'VARIABLES' @ [317:125] ==> enum entry VARIABLES defined in org.jetbrains.kotlin.idea.core.NewDeclarationNameValidator.Target[FakeCallableDescriptorForObject]

'KotlinNameSuggester' @ [318:33] ==> public object KotlinNameSuggester defined in org.jetbrains.kotlin.idea.core[FakeCallableDescriptorForObject]

'suggestNamesByType' @ [318:53] ==> public final fun suggestNamesByType(type: KotlinType, validator: (String) -> Boolean, defaultName: String? = ...): List<String> defined in org.jetbrains.kotlin.idea.core.KotlinNameSuggester[DeserializedSimpleFunctionDescriptor]

'extractableDescriptor' @ [318:72] ==> value-parameter extractableDescriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[ValueParameterDescriptorImpl]

'returnType' @ [318:94] ==> public final val returnType: KotlinType defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'varNameValidator' @ [318:106] ==> val varNameValidator: NewDeclarationNameValidator defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'first' @ [318:130] ==> public fun <T> List<String>.first(): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'block' @ [319:17] ==> val block: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'addBefore' @ [319:23] ==> public abstract fun addBefore(@NotNull p0: PsiElement, @Nullable p1: PsiElement?): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'psiFactory' @ [319:33] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'createDeclaration' @ [319:44] ==> public final fun <TDeclaration : KtDeclaration> createDeclaration(text: String): KtDeclaration defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <TDeclaration : KtDeclaration> -> KtDeclaration

'resultVal' @ [319:68] ==> val resultVal: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'callText' @ [319:81] ==> val callText: String? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'anchorInBlock' @ [319:93] ==> val anchorInBlock: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'block' @ [320:17] ==> val block: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'addBefore' @ [320:23] ==> public abstract fun addBefore(@NotNull p0: PsiElement, @Nullable p1: PsiElement?): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'newLine' @ [320:33] ==> val newLine: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'anchorInBlock' @ [320:42] ==> val anchorInBlock: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'controlFlow' @ [321:17] ==> value-parameter controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[ValueParameterDescriptorImpl]

'outputValueBoxer' @ [321:29] ==> public final val outputValueBoxer: OutputValueBoxer defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'getUnboxingExpressions' @ [321:46] ==> public abstract fun getUnboxingExpressions(boxedText: String): Map<OutputValue, String> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValueBoxer[SimpleFunctionDescriptorImpl]

'resultVal' @ [321:69] ==> val resultVal: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'HashMap' @ [324:30] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> KtDeclaration
    <V : (Any..Any?)> -> KtDeclaration

'controlFlow' @ [325:18] ==> value-parameter controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[ValueParameterDescriptorImpl]

'declarationsToCopy' @ [325:30] ==> public final val declarationsToCopy: List<KtDeclaration> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'psiFactory' @ [326:24] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'createDeclaration' @ [326:35] ==> public final fun <TDeclaration : KtDeclaration> createDeclaration(text: String): KtDeclaration defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <TDeclaration : KtDeclaration> -> KtDeclaration

'decl' @ [326:68] ==> val decl: KtDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'text' @ [326:73] ==> public final val KtDeclaration.text: (String..String?)[MyPropertyDescriptor]

'copiedDeclarations' @ [327:9] ==> val copiedDeclarations: HashMap<KtDeclaration, KtDeclaration> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'decl' @ [327:28] ==> val decl: KtDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'block' @ [327:36] ==> val block: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'addBefore' @ [327:42] ==> public abstract fun addBefore(@NotNull p0: PsiElement, @Nullable p1: PsiElement?): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'declCopy' @ [327:52] ==> val declCopy: KtDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'anchorInBlock' @ [327:62] ==> val anchorInBlock: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'block' @ [328:9] ==> val block: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'addBefore' @ [328:15] ==> public abstract fun addBefore(@NotNull p0: PsiElement, @Nullable p1: PsiElement?): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'newLine' @ [328:25] ==> val newLine: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'anchorInBlock' @ [328:34] ==> val anchorInBlock: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'controlFlow' @ [331:9] ==> value-parameter controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[ValueParameterDescriptorImpl]

'outputValues' @ [331:21] ==> public final val outputValues: List<OutputValue> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'isEmpty' @ [331:34] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'anchor' @ [332:9] ==> val anchor: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'replace' @ [332:16] ==> public abstract fun replace(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'psiFactory' @ [332:24] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'createExpression' @ [332:35] ==> public final fun createExpression(text: String): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'callText' @ [332:52] ==> val callText: String? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'when (outputValue) {
            is OutputValue.ExpressionValue -> {
                val exprText = if (outputValue.callSiteReturn) {
                    val firstReturn = outputValue.originalExpressions.filterIsInstance<KtReturnExpression>().firstOrNull()
                    val label = firstReturn?.getTargetLabel()?.text ?: ""
                    "return$label $callText"
                }
                else {
                    callText
                }
                Collections.singletonList(psiFactory.createExpression(exprText))
            }

            is ParameterUpdate ->
                Collections.singletonList(
                        psiFactory.createExpression("${outputValue.parameter.argumentText} = $callText")
                )

            is Jump -> {
                when {
                    outputValue.elementToInsertAfterCall == null -> Collections.singletonList(psiFactory.createExpression(callText))
                    outputValue.conditional -> Collections.singletonList(
                            psiFactory.createExpression("if ($callText) ${outputValue.elementToInsertAfterCall.text}")
                    )
                    else -> listOf(
                            psiFactory.createExpression(callText),
                            newLine,
                            psiFactory.createExpression(outputValue.elementToInsertAfterCall.text!!)
                    )
                }
            }

            is Initializer -> {
                val newProperty = copiedDeclarations[outputValue.initializedDeclaration] as KtProperty
                newProperty.initializer = psiFactory.createExpression(callText)
                Collections.emptyList()
            }

            else -> throw IllegalArgumentException("Unknown output value: $outputValue")
        }' @ [337:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: List<PsiElement>, entry1: List<PsiElement>, entry2: List<PsiElement>, entry3: List<PsiElement>, entry4: List<PsiElement>): List<PsiElement>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> List<PsiElement>

'outputValue' @ [337:22] ==> value-parameter outputValue: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.wrapCall[ValueParameterDescriptorImpl]

'if (outputValue.callSiteReturn) {
                    val firstReturn = outputValue.originalExpressions.filterIsInstance<KtReturnExpression>().firstOrNull()
                    val label = firstReturn?.getTargetLabel()?.text ?: ""
                    "return$label $callText"
                }
                else {
                    callText
                }' @ [339:32] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'outputValue' @ [339:36] ==> value-parameter outputValue: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.wrapCall[ValueParameterDescriptorImpl]

'callSiteReturn' @ [339:48] ==> public final val callSiteReturn: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValue.ExpressionValue[PropertyDescriptorImpl]

'outputValue' @ [340:39] ==> value-parameter outputValue: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.wrapCall[ValueParameterDescriptorImpl]

'originalExpressions' @ [340:51] ==> public abstract val originalExpressions: List<KtExpression> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValue[PropertyDescriptorImpl]

'filterIsInstance' @ [340:71] ==> public inline fun <reified R> Iterable<*>.filterIsInstance(): List<KtReturnExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified R> -> KtReturnExpression

'firstOrNull' @ [340:110] ==> public fun <T> List<KtReturnExpression>.firstOrNull(): KtReturnExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtReturnExpression

'firstReturn' @ [341:33] ==> val firstReturn: KtReturnExpression? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.wrapCall[LocalVariableDescriptor]

'getTargetLabel' @ [341:46] ==> public final fun getTargetLabel(): KtSimpleNameExpression? defined in org.jetbrains.kotlin.psi.KtReturnExpression[DeserializedSimpleFunctionDescriptor]

'text' @ [341:64] ==> public final val KtSimpleNameExpression.text: (String..String?)[MyPropertyDescriptor]

'label' @ [342:29] ==> val label: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.wrapCall[LocalVariableDescriptor]

'callText' @ [342:36] ==> value-parameter callText: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.wrapCall[ValueParameterDescriptorImpl]

'callText' @ [345:21] ==> value-parameter callText: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.wrapCall[ValueParameterDescriptorImpl]

'singletonList' @ [347:29] ==> public open fun <T : (Any..Any?)> singletonList(p0: (KtExpression..KtExpression?)): (MutableList<(KtExpression..KtExpression?)>..List<(KtExpression..KtExpression?)>?) defined in java.util.Collections[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> KtExpression

'psiFactory' @ [347:43] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'createExpression' @ [347:54] ==> public final fun createExpression(text: String): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'exprText' @ [347:71] ==> val exprText: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.wrapCall[LocalVariableDescriptor]

'singletonList' @ [351:29] ==> public open fun <T : (Any..Any?)> singletonList(p0: (KtExpression..KtExpression?)): (MutableList<(KtExpression..KtExpression?)>..List<(KtExpression..KtExpression?)>?) defined in java.util.Collections[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> KtExpression

'psiFactory' @ [352:25] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'createExpression' @ [352:36] ==> public final fun createExpression(text: String): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'outputValue' @ [352:56] ==> value-parameter outputValue: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.wrapCall[ValueParameterDescriptorImpl]

'parameter' @ [352:68] ==> public final val parameter: Parameter defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValue.ParameterUpdate[PropertyDescriptorImpl]

'argumentText' @ [352:78] ==> public abstract val argumentText: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.Parameter[PropertyDescriptorImpl]

'callText' @ [352:95] ==> value-parameter callText: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.wrapCall[ValueParameterDescriptorImpl]

'when {
                    outputValue.elementToInsertAfterCall == null -> Collections.singletonList(psiFactory.createExpression(callText))
                    outputValue.conditional -> Collections.singletonList(
                            psiFactory.createExpression("if ($callText) ${outputValue.elementToInsertAfterCall.text}")
                    )
                    else -> listOf(
                            psiFactory.createExpression(callText),
                            newLine,
                            psiFactory.createExpression(outputValue.elementToInsertAfterCall.text!!)
                    )
                }' @ [356:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: List<PsiElement>, entry1: List<PsiElement>, entry2: List<PsiElement>): List<PsiElement>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> List<PsiElement>

'outputValue' @ [357:21] ==> value-parameter outputValue: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.wrapCall[ValueParameterDescriptorImpl]

'elementToInsertAfterCall' @ [357:33] ==> public final val elementToInsertAfterCall: KtElement? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValue.Jump[PropertyDescriptorImpl]

'singletonList' @ [357:81] ==> public open fun <T : (Any..Any?)> singletonList(p0: (KtExpression..KtExpression?)): (MutableList<(KtExpression..KtExpression?)>..List<(KtExpression..KtExpression?)>?) defined in java.util.Collections[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> KtExpression

'psiFactory' @ [357:95] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'createExpression' @ [357:106] ==> public final fun createExpression(text: String): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'callText' @ [357:123] ==> value-parameter callText: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.wrapCall[ValueParameterDescriptorImpl]

'outputValue' @ [358:21] ==> value-parameter outputValue: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.wrapCall[ValueParameterDescriptorImpl]

'conditional' @ [358:33] ==> public final val conditional: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValue.Jump[PropertyDescriptorImpl]

'singletonList' @ [358:60] ==> public open fun <T : (Any..Any?)> singletonList(p0: (KtExpression..KtExpression?)): (MutableList<(KtExpression..KtExpression?)>..List<(KtExpression..KtExpression?)>?) defined in java.util.Collections[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> KtExpression

'psiFactory' @ [359:29] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'createExpression' @ [359:40] ==> public final fun createExpression(text: String): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'callText' @ [359:63] ==> value-parameter callText: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.wrapCall[ValueParameterDescriptorImpl]

'outputValue' @ [359:75] ==> value-parameter outputValue: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.wrapCall[ValueParameterDescriptorImpl]

'elementToInsertAfterCall' @ [359:87] ==> public final val elementToInsertAfterCall: KtElement? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValue.Jump[PropertyDescriptorImpl]

'text' @ [359:112] ==> public final val KtElement.text: (String..String?)[MyPropertyDescriptor]

'listOf' @ [361:29] ==> public fun <T> listOf(vararg elements: PsiElement): List<PsiElement> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'psiFactory' @ [362:29] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'createExpression' @ [362:40] ==> public final fun createExpression(text: String): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'callText' @ [362:57] ==> value-parameter callText: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.wrapCall[ValueParameterDescriptorImpl]

'newLine' @ [363:29] ==> val newLine: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'psiFactory' @ [364:29] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'createExpression' @ [364:40] ==> public final fun createExpression(text: String): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'outputValue' @ [364:57] ==> value-parameter outputValue: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.wrapCall[ValueParameterDescriptorImpl]

'elementToInsertAfterCall' @ [364:69] ==> public final val elementToInsertAfterCall: KtElement? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValue.Jump[PropertyDescriptorImpl]

'text' @ [364:94] ==> public final val KtElement.text: (String..String?)[MyPropertyDescriptor]

'copiedDeclarations' @ [370:35] ==> val copiedDeclarations: HashMap<KtDeclaration, KtDeclaration> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'outputValue' @ [370:54] ==> value-parameter outputValue: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.wrapCall[ValueParameterDescriptorImpl]

'initializedDeclaration' @ [370:66] ==> public final val initializedDeclaration: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValue.Initializer[PropertyDescriptorImpl]

'newProperty' @ [371:17] ==> val newProperty: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.wrapCall[LocalVariableDescriptor]

'initializer' @ [371:29] ==> public final var KtProperty.initializer: KtExpression?[MyPropertyDescriptor]

'psiFactory' @ [371:43] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'createExpression' @ [371:54] ==> public final fun createExpression(text: String): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'callText' @ [371:71] ==> value-parameter callText: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.wrapCall[ValueParameterDescriptorImpl]

'emptyList' @ [372:29] ==> public final fun <T : (Any..Any?)> emptyList(): (MutableList<(PsiElement..PsiElement?)>..List<(PsiElement..PsiElement?)>?) defined in java.util.Collections[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> PsiElement

'IllegalArgumentException' @ [375:27] ==> public final fun <init>(p0: (String..String?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'outputValue' @ [375:76] ==> value-parameter outputValue: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.wrapCall[ValueParameterDescriptorImpl]

'controlFlow' @ [379:24] ==> value-parameter controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[ValueParameterDescriptorImpl]

'defaultOutputValue' @ [379:36] ==> public final val defaultOutputValue: OutputValue.ExpressionValue? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'controlFlow' @ [381:5] ==> value-parameter controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[ValueParameterDescriptorImpl]

'outputValues' @ [381:17] ==> public final val outputValues: List<OutputValue> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'filter' @ [382:14] ==> public inline fun <T> Iterable<OutputValue>.filter(predicate: (OutputValue) -> Boolean): List<OutputValue> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> OutputValue

'it' @ [382:23] ==> value-parameter it: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.<anonymous>[ValueParameterDescriptorImpl]

'defaultValue' @ [382:29] ==> val defaultValue: OutputValue.ExpressionValue? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'flatMap' @ [383:14] ==> public inline fun <T, R> Iterable<OutputValue>.flatMap(transform: (OutputValue) -> Iterable<PsiElement>): List<PsiElement> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> OutputValue
    <R> -> PsiElement

'wrapCall' @ [383:24] ==> local final fun wrapCall(outputValue: OutputValue, callText: String): List<PsiElement> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[SimpleFunctionDescriptorImpl]

'it' @ [383:33] ==> value-parameter it: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.<anonymous>[ValueParameterDescriptorImpl]

'unboxingExpressions' @ [383:37] ==> val unboxingExpressions: Map<OutputValue, String> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'it' @ [383:57] ==> value-parameter it: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.<anonymous>[ValueParameterDescriptorImpl]

'withIndex' @ [384:14] ==> public fun <T> Iterable<PsiElement>.withIndex(): Iterable<IndexedValue<PsiElement>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'forEach' @ [385:14] ==> @HidesMembers public inline fun <T> Iterable<IndexedValue<PsiElement>>.forEach(action: (IndexedValue<PsiElement>) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> IndexedValue<PsiElement>

'component1' @ [386:22] ==> public final operator fun component1(): Int defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'component2' @ [386:25] ==> public final operator fun component2(): PsiElement defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'it' @ [386:30] ==> value-parameter it: IndexedValue<PsiElement> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.<anonymous>[ValueParameterDescriptorImpl]

'i' @ [388:21] ==> val i: Int defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.<anonymous>[LocalVariableDescriptor]

'block' @ [389:21] ==> val block: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'addBefore' @ [389:27] ==> public abstract fun addBefore(@NotNull p0: PsiElement, @Nullable p1: PsiElement?): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'newLine' @ [389:37] ==> val newLine: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'anchorInBlock' @ [389:46] ==> val anchorInBlock: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'block' @ [391:17] ==> val block: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'addBefore' @ [391:23] ==> public abstract fun addBefore(@NotNull p0: PsiElement, @Nullable p1: PsiElement?): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'e' @ [391:33] ==> val e: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.<anonymous>[LocalVariableDescriptor]

'anchorInBlock' @ [391:36] ==> val anchorInBlock: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'defaultValue' @ [394:5] ==> val defaultValue: OutputValue.ExpressionValue? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'let' @ [394:19] ==> @InlineOnly public inline fun <T, R> OutputValue.ExpressionValue.let(block: (OutputValue.ExpressionValue) -> KtExpression?): KtExpression? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpressionValue
    <R> -> KtExpression?

'!' @ [395:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'inlinableCall' @ [395:14] ==> val inlinableCall: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'block' @ [396:13] ==> val block: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'addBefore' @ [396:19] ==> public abstract fun addBefore(@NotNull p0: PsiElement, @Nullable p1: PsiElement?): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'newLine' @ [396:29] ==> val newLine: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'anchorInBlock' @ [396:38] ==> val anchorInBlock: PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'insertCall' @ [398:9] ==> local final fun insertCall(anchor: PsiElement, wrappedCall: KtExpression): KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[SimpleFunctionDescriptorImpl]

'anchor' @ [398:20] ==> val anchor: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'wrapCall' @ [398:28] ==> local final fun wrapCall(outputValue: OutputValue, callText: String): List<PsiElement> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[SimpleFunctionDescriptorImpl]

'it' @ [398:37] ==> value-parameter it: OutputValue.ExpressionValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.<anonymous>[ValueParameterDescriptorImpl]

'unboxingExpressions' @ [398:41] ==> val unboxingExpressions: Map<OutputValue, String> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'it' @ [398:61] ==> value-parameter it: OutputValue.ExpressionValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall.<anonymous>[ValueParameterDescriptorImpl]

'first' @ [398:68] ==> public fun <T> List<PsiElement>.first(): PsiElement defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'removeTemplateEntryBracesIfPossible' @ [398:94] ==> public fun KtExpression.removeTemplateEntryBracesIfPossible(): KtExpression defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'anchor' @ [401:9] ==> val anchor: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'isValid' @ [401:16] ==> public final val PsiElement.isValid: Boolean[MyPropertyDescriptor]

'anchor' @ [402:9] ==> val anchor: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.makeCall[LocalVariableDescriptor]

'delete' @ [402:16] ==> public abstract fun delete(): Unit defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'NotNullableCopyableUserDataProperty' @ [407:12] ==> public constructor NotNullableCopyableUserDataProperty<in R : PsiElement, T : Any>(key: Key<Boolean>, defaultValue: Boolean) defined in org.jetbrains.kotlin.psi.NotNullableCopyableUserDataProperty[DeserializedClassConstructorDescriptor]
Inferred types:
    <in R : PsiElement> -> KtExpression
    <T : Any> -> Boolean

'create' @ [407:52] ==> @NotNull public open fun <T : (Any..Any?)> create(@NotNull @NonNls p0: String): Key<(Boolean..Boolean?)> defined in com.intellij.openapi.util.Key[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Boolean

'NotNullableCopyableUserDataProperty' @ [410:12] ==> public constructor NotNullableCopyableUserDataProperty<in R : PsiElement, T : Any>(key: Key<Boolean>, defaultValue: Boolean) defined in org.jetbrains.kotlin.psi.NotNullableCopyableUserDataProperty[DeserializedClassConstructorDescriptor]
Inferred types:
    <in R : PsiElement> -> KtReturnExpression
    <T : Any> -> Boolean

'create' @ [410:52] ==> @NotNull public open fun <T : (Any..Any?)> create(@NotNull @NonNls p0: String): Key<(Boolean..Boolean?)> defined in com.intellij.openapi.util.Key[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Boolean

'KtPsiFactory' @ [415:22] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'descriptor' @ [415:35] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'extractionData' @ [415:46] ==> public final val extractionData: ExtractionData defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'originalFile' @ [415:61] ==> public final val originalFile: KtFile defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[PropertyDescriptorImpl]

'descriptor' @ [417:39] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'controlFlow' @ [417:50] ==> public final val controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'outputValues' @ [417:62] ==> public final val outputValues: List<OutputValue> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'flatMapTo' @ [418:14] ==> public inline fun <T, R, C : MutableCollection<in KtReturnExpression>> Iterable<OutputValue>.flatMapTo(destination: ArrayList<KtReturnExpression>, transform: (OutputValue) -> Iterable<KtReturnExpression>): ArrayList<KtReturnExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> OutputValue
    <R> -> KtReturnExpression
    <C : MutableCollection<in R>> -> ArrayList<KtReturnExpression>

'ArrayList' @ [418:24] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> KtReturnExpression

'it' @ [418:59] ==> value-parameter it: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.getReturnsForLabelRemoval.<anonymous>[ValueParameterDescriptorImpl]

'originalExpressions' @ [418:62] ==> public abstract val originalExpressions: List<KtExpression> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValue[PropertyDescriptorImpl]

'filterIsInstance' @ [418:82] ==> public inline fun <reified R> Iterable<*>.filterIsInstance(): List<KtReturnExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified R> -> KtReturnExpression

'descriptor' @ [421:9] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'controlFlow' @ [421:20] ==> public final val controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'jumpOutputValue' @ [421:32] ==> public final val jumpOutputValue: OutputValue.Jump? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'elementsToReplace' @ [421:49] ==> public final val elementsToReplace: List<KtExpression> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValue.Jump[PropertyDescriptorImpl]

'forEach' @ [421:68] ==> @HidesMembers public inline fun <T> Iterable<KtExpression>.forEach(action: (KtExpression) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'it' @ [421:78] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.createDeclaration.<anonymous>[ValueParameterDescriptorImpl]

'isJumpElementToReplace' @ [421:81] ==> private var KtExpression.isJumpElementToReplace: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine in file extractorUtil.kt[PropertyDescriptorImpl]

'getReturnsForLabelRemoval' @ [422:9] ==> local final fun getReturnsForLabelRemoval(): ArrayList<KtReturnExpression> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[SimpleFunctionDescriptorImpl]

'forEach' @ [422:37] ==> @HidesMembers public inline fun <T> Iterable<KtReturnExpression>.forEach(action: (KtReturnExpression) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtReturnExpression

'it' @ [422:47] ==> value-parameter it: KtReturnExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.createDeclaration.<anonymous>[ValueParameterDescriptorImpl]

'isReturnForLabelRemoval' @ [422:50] ==> private var KtReturnExpression.isReturnForLabelRemoval: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine in file extractorUtil.kt[PropertyDescriptorImpl]

'with' @ [424:16] ==> @InlineOnly public inline fun <T, R> with(receiver: ExtractionData, block: ExtractionData.() -> KtNamedDeclaration): KtNamedDeclaration defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExtractionData
    <R> -> KtNamedDeclaration

'descriptor' @ [424:21] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'extractionData' @ [424:32] ==> public final val extractionData: ExtractionData defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'if (generatorOptions.inTempFile) {
                createTemporaryDeclaration("${getDeclarationPattern()}\n")
            }
            else {
                psiFactory.createDeclarationByPattern(
                        getDeclarationPattern(),
                        PsiChildRange(originalElements.firstOrNull(), originalElements.lastOrNull())
                )
            }' @ [425:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtNamedDeclaration, elseBranch: KtNamedDeclaration): KtNamedDeclaration[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtNamedDeclaration

'generatorOptions' @ [425:17] ==> public final val generatorOptions: ExtractionGeneratorOptions defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'inTempFile' @ [425:34] ==> public final val inTempFile: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorOptions[PropertyDescriptorImpl]

'createTemporaryDeclaration' @ [426:17] ==> public fun ExtractionData.createTemporaryDeclaration(pattern: String): KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine in file extractableAnalysisUtil.kt[SimpleFunctionDescriptorImpl]

'getDeclarationPattern' @ [426:47] ==> public fun ExtractionGeneratorConfiguration.getDeclarationPattern(descriptorRenderer: DescriptorRenderer = ...): String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine in file extractorUtil.kt[SimpleFunctionDescriptorImpl]

'psiFactory' @ [429:17] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'createDeclarationByPattern' @ [429:28] ==> public fun <TDeclaration : KtDeclaration> KtPsiFactory.createDeclarationByPattern(pattern: String, vararg args: Any, reformat: Boolean = ...): KtNamedDeclaration defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <TDeclaration : KtDeclaration> -> KtNamedDeclaration

'getDeclarationPattern' @ [430:25] ==> public fun ExtractionGeneratorConfiguration.getDeclarationPattern(descriptorRenderer: DescriptorRenderer = ...): String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine in file extractorUtil.kt[SimpleFunctionDescriptorImpl]

'PsiChildRange' @ [431:25] ==> public constructor PsiChildRange(first: PsiElement?, last: PsiElement?) defined in org.jetbrains.kotlin.psi.psiUtil.PsiChildRange[DeserializedClassConstructorDescriptor]

'originalElements' @ [431:39] ==> public final val originalElements: List<PsiElement> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[PropertyDescriptorImpl]

'firstOrNull' @ [431:56] ==> public fun <T> List<PsiElement>.firstOrNull(): PsiElement? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'originalElements' @ [431:71] ==> public final val originalElements: List<PsiElement> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[PropertyDescriptorImpl]

'lastOrNull' @ [431:88] ==> public fun <T> List<PsiElement>.lastOrNull(): PsiElement? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'descriptor' @ [438:16] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'controlFlow' @ [438:27] ==> public final val controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'outputValues' @ [438:39] ==> public final val outputValues: List<OutputValue> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'mapNotNull' @ [439:18] ==> public inline fun <T, R : Any> Iterable<OutputValue>.mapNotNull(transform: (OutputValue) -> KtExpression?): List<KtExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> OutputValue
    <R : Any> -> KtExpression

'when (it) {
                        is ExpressionValue -> resultExpression
                        is Jump -> if (it.conditional) psiFactory.createExpression("false") else null
                        is ParameterUpdate -> psiFactory.createExpression(it.parameter.nameForRef)
                        is Initializer -> psiFactory.createExpression(it.initializedDeclaration.name!!)
                        else -> throw IllegalArgumentException("Unknown output value: $it")
                    }' @ [440:21] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KtExpression?, entry1: KtExpression?, entry2: KtExpression?, entry3: KtExpression?, entry4: KtExpression?): KtExpression?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KtExpression?

'it' @ [440:27] ==> value-parameter it: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.getReturnArguments.<anonymous>[ValueParameterDescriptorImpl]

'resultExpression' @ [441:47] ==> value-parameter resultExpression: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.getReturnArguments[ValueParameterDescriptorImpl]

'if (it.conditional) psiFactory.createExpression("false") else null' @ [442:36] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtExpression?, elseBranch: KtExpression?): KtExpression?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtExpression?

'it' @ [442:40] ==> value-parameter it: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.getReturnArguments.<anonymous>[ValueParameterDescriptorImpl]

'conditional' @ [442:43] ==> public final val conditional: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValue.Jump[PropertyDescriptorImpl]

'psiFactory' @ [442:56] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'createExpression' @ [442:67] ==> public final fun createExpression(text: String): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'psiFactory' @ [443:47] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'createExpression' @ [443:58] ==> public final fun createExpression(text: String): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'it' @ [443:75] ==> value-parameter it: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.getReturnArguments.<anonymous>[ValueParameterDescriptorImpl]

'parameter' @ [443:78] ==> public final val parameter: Parameter defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValue.ParameterUpdate[PropertyDescriptorImpl]

'nameForRef' @ [443:88] ==> public val Parameter.nameForRef: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine in file ExtractableCodeDescriptor.kt[PropertyDescriptorImpl]

'psiFactory' @ [444:43] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'createExpression' @ [444:54] ==> public final fun createExpression(text: String): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'it' @ [444:71] ==> value-parameter it: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.getReturnArguments.<anonymous>[ValueParameterDescriptorImpl]

'initializedDeclaration' @ [444:74] ==> public final val initializedDeclaration: KtProperty defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValue.Initializer[PropertyDescriptorImpl]

'name' @ [444:97] ==> public final val KtProperty.name: String?[MyPropertyDescriptor]

'IllegalArgumentException' @ [445:39] ==> public final fun <init>(p0: (String..String?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'it' @ [445:88] ==> value-parameter it: OutputValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.getReturnArguments.<anonymous>[ValueParameterDescriptorImpl]

'descriptor' @ [451:9] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'controlFlow' @ [451:20] ==> public final val controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'defaultOutputValue' @ [451:32] ==> public final val defaultOutputValue: OutputValue.ExpressionValue? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'let' @ [451:52] ==> @InlineOnly public inline fun <T, R> OutputValue.ExpressionValue.let(block: (OutputValue.ExpressionValue) -> KtExpression?): KtExpression? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpressionValue
    <R> -> KtExpression?

'replaced' @ [452:35] ==> public inline fun <reified T : PsiElement> PsiElement.replaced(newElement: KtReturnExpression): KtReturnExpression defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtReturnExpression

'replacingExpression' @ [452:44] ==> value-parameter replacingExpression: KtReturnExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.replaceWithReturn[ValueParameterDescriptorImpl]

'returnedExpression' @ [452:65] ==> public final val KtReturnExpression.returnedExpression: KtExpression?[MyPropertyDescriptor]

'descriptor' @ [453:13] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'controlFlow' @ [453:24] ==> public final val controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'outputValueBoxer' @ [453:36] ==> public final val outputValueBoxer: OutputValueBoxer defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'extractExpressionByValue' @ [453:53] ==> public final fun extractExpressionByValue(boxedExpression: KtExpression, value: OutputValue): KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValueBoxer[SimpleFunctionDescriptorImpl]

'boxedExpression' @ [453:78] ==> val boxedExpression: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.replaceWithReturn.<anonymous>[LocalVariableDescriptor]

'it' @ [453:95] ==> value-parameter it: OutputValue.ExpressionValue defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.replaceWithReturn.<anonymous>[ValueParameterDescriptorImpl]

'declaration' @ [458:20] ==> value-parameter declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[ValueParameterDescriptorImpl]

'getGeneratedBody' @ [458:32] ==> internal fun KtNamedDeclaration.getGeneratedBody(): KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine[SimpleFunctionDescriptorImpl]

'body' @ [460:10] ==> val body: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'blockExpressionsOrSingle' @ [460:15] ==> public fun KtElement.blockExpressionsOrSingle(): Sequence<KtElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'singleOrNull' @ [460:42] ==> public fun <T> Sequence<KtElement>.singleOrNull(): KtElement? defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtElement

'let' @ [460:76] ==> @InlineOnly public inline fun <T, R> KtExpression.let(block: (KtExpression) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression
    <R> -> Unit

'it' @ [461:17] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody.<anonymous>[ValueParameterDescriptorImpl]

'mustBeParenthesizedInInitializerPosition' @ [461:20] ==> public fun KtExpression.mustBeParenthesizedInInitializerPosition(): Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce in file introduceUtil.kt[SimpleFunctionDescriptorImpl]

'it' @ [462:17] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody.<anonymous>[ValueParameterDescriptorImpl]

'replace' @ [462:20] ==> public abstract fun replace(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtExpression[JavaMethodDescriptor]

'psiFactory' @ [462:28] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'createExpressionByPattern' @ [462:39] ==> public fun KtPsiFactory.createExpressionByPattern(pattern: String, vararg args: Any, reformat: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'it' @ [462:73] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody.<anonymous>[ValueParameterDescriptorImpl]

'descriptor' @ [466:25] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'controlFlow' @ [466:36] ==> public final val controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'jumpOutputValue' @ [466:48] ==> public final val jumpOutputValue: OutputValue.Jump? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'jumpValue' @ [467:13] ==> val jumpValue: OutputValue.Jump? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'psiFactory' @ [468:35] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'createExpression' @ [468:46] ==> public final fun createExpression(text: String): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'if (jumpValue.conditional) "return true" else "return"' @ [468:63] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'jumpValue' @ [468:67] ==> val jumpValue: OutputValue.Jump? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'conditional' @ [468:77] ==> public final val conditional: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValue.Jump[PropertyDescriptorImpl]

'body' @ [469:13] ==> val body: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'collectDescendantsOfType' @ [469:18] ==> public inline fun <reified T : PsiElement> PsiElement.collectDescendantsOfType(noinline predicate: (KtExpression) -> Boolean = ...): List<KtExpression> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtExpression

'it' @ [469:59] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody.<anonymous>[ValueParameterDescriptorImpl]

'isJumpElementToReplace' @ [469:62] ==> private var KtExpression.isJumpElementToReplace: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine in file extractorUtil.kt[PropertyDescriptorImpl]

'forEach' @ [469:87] ==> @HidesMembers public inline fun <T> Iterable<KtExpression>.forEach(action: (KtExpression) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'it' @ [470:17] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody.<anonymous>[ValueParameterDescriptorImpl]

'replace' @ [470:20] ==> public abstract fun replace(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtExpression[JavaMethodDescriptor]

'replacingReturn' @ [470:28] ==> val replacingReturn: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'it' @ [471:17] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody.<anonymous>[ValueParameterDescriptorImpl]

'isJumpElementToReplace' @ [471:20] ==> private var KtExpression.isJumpElementToReplace: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine in file extractorUtil.kt[PropertyDescriptorImpl]

'body' @ [475:9] ==> val body: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'collectDescendantsOfType' @ [475:14] ==> public inline fun <reified T : PsiElement> PsiElement.collectDescendantsOfType(noinline predicate: (KtReturnExpression) -> Boolean = ...): List<KtReturnExpression> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtReturnExpression

'it' @ [475:61] ==> value-parameter it: KtReturnExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody.<anonymous>[ValueParameterDescriptorImpl]

'isReturnForLabelRemoval' @ [475:64] ==> private var KtReturnExpression.isReturnForLabelRemoval: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine in file extractorUtil.kt[PropertyDescriptorImpl]

'forEach' @ [475:90] ==> @HidesMembers public inline fun <T> Iterable<KtReturnExpression>.forEach(action: (KtReturnExpression) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtReturnExpression

'it' @ [476:13] ==> value-parameter it: KtReturnExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody.<anonymous>[ValueParameterDescriptorImpl]

'getTargetLabel' @ [476:16] ==> public final fun getTargetLabel(): KtSimpleNameExpression? defined in org.jetbrains.kotlin.psi.KtReturnExpression[DeserializedSimpleFunctionDescriptor]

'delete' @ [476:34] ==> public abstract fun delete(): Unit defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[JavaMethodDescriptor]

'it' @ [477:13] ==> value-parameter it: KtReturnExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody.<anonymous>[ValueParameterDescriptorImpl]

'isReturnForLabelRemoval' @ [477:16] ==> private var KtReturnExpression.isReturnForLabelRemoval: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine in file extractorUtil.kt[PropertyDescriptorImpl]

'body' @ [484:27] ==> val body: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'collectDescendantsOfType' @ [485:18] ==> public inline fun <reified T : PsiElement> PsiElement.collectDescendantsOfType(noinline predicate: (KtSimpleNameExpression) -> Boolean = ...): List<KtSimpleNameExpression> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtSimpleNameExpression

'it' @ [485:69] ==> value-parameter it: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody.<anonymous>[ValueParameterDescriptorImpl]

'resolveResult' @ [485:72] ==> internal var KtSimpleNameExpression.resolveResult: ResolveResult? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine in file ExtractionData.kt[PropertyDescriptorImpl]

'sortedByDescending' @ [486:18] ==> public inline fun <T, R : Comparable<Int>> Iterable<KtSimpleNameExpression>.sortedByDescending(crossinline selector: (KtSimpleNameExpression) -> Int?): List<KtSimpleNameExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtSimpleNameExpression
    <R : Comparable<R>> -> Int

'it' @ [486:39] ==> value-parameter it: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody.<anonymous>[ValueParameterDescriptorImpl]

'startOffset' @ [486:42] ==> public val PsiElement.startOffset: Int defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'currentRefs' @ [488:9] ==> val currentRefs: List<KtSimpleNameExpression> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'forEach' @ [488:21] ==> @HidesMembers public inline fun <T> Iterable<KtSimpleNameExpression>.forEach(action: (KtSimpleNameExpression) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtSimpleNameExpression

'it' @ [489:33] ==> value-parameter it: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody.<anonymous>[ValueParameterDescriptorImpl]

'resolveResult' @ [489:36] ==> internal var KtSimpleNameExpression.resolveResult: ResolveResult? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine in file ExtractionData.kt[PropertyDescriptorImpl]

'if (it.isValid) {
                it
            }
            else {
                body.findDescendantOfType<KtSimpleNameExpression> { it.resolveResult == resolveResult } ?: return@forEach
            }' @ [490:30] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtSimpleNameExpression, elseBranch: KtSimpleNameExpression): KtSimpleNameExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtSimpleNameExpression

'it' @ [490:34] ==> value-parameter it: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody.<anonymous>[ValueParameterDescriptorImpl]

'isValid' @ [490:37] ==> public final val KtSimpleNameExpression.isValid: Boolean[MyPropertyDescriptor]

'it' @ [491:17] ==> value-parameter it: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody.<anonymous>[ValueParameterDescriptorImpl]

'body' @ [494:17] ==> val body: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'findDescendantOfType' @ [494:22] ==> public inline fun <reified T : PsiElement> PsiElement.findDescendantOfType(noinline predicate: (KtSimpleNameExpression) -> Boolean = ...): KtSimpleNameExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtSimpleNameExpression

'it' @ [494:69] ==> value-parameter it: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'resolveResult' @ [494:72] ==> internal var KtSimpleNameExpression.resolveResult: ResolveResult? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine in file ExtractionData.kt[PropertyDescriptorImpl]

'resolveResult' @ [494:89] ==> val resolveResult: ResolveResult defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody.<anonymous>[LocalVariableDescriptor]

'resolveResult' @ [496:31] ==> val resolveResult: ResolveResult defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody.<anonymous>[LocalVariableDescriptor]

'originalRefExpr' @ [496:45] ==> public final val originalRefExpr: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ResolveResult[PropertyDescriptorImpl]

'descriptor' @ [497:26] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'replacementMap' @ [497:37] ==> public final val replacementMap: MultiMap<KtSimpleNameExpression, Replacement> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'originalRef' @ [497:52] ==> val originalRef: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody.<anonymous>[LocalVariableDescriptor]

'fold' @ [498:22] ==> public inline fun <T, R> Iterable<(Replacement..Replacement?)>.fold(initial: KtElement, operation: (KtElement, (Replacement..Replacement?)) -> KtElement): KtElement defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.Replacement..org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.Replacement?)
    <R> -> KtElement

'currentRef' @ [498:27] ==> val currentRef: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody.<anonymous>[LocalVariableDescriptor]

'invoke' @ [498:81] ==> public abstract fun invoke(p1: ExtractableCodeDescriptor, p2: KtElement): KtElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.Replacement[FunctionInvokeDescriptor]

'descriptor' @ [498:93] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'currentRef' @ [498:105] ==> value-parameter currentRef: KtElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'newRef' @ [499:14] ==> val newRef: KtElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody.<anonymous>[LocalVariableDescriptor]

'resolveResult' @ [499:50] ==> internal var KtSimpleNameExpression.resolveResult: ResolveResult? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine in file ExtractionData.kt[PropertyDescriptorImpl]

'resolveResult' @ [499:66] ==> val resolveResult: ResolveResult defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody.<anonymous>[LocalVariableDescriptor]

'generatorOptions' @ [502:13] ==> public final val generatorOptions: ExtractionGeneratorOptions defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'target' @ [502:30] ==> public final val target: ExtractionTarget defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorOptions[PropertyDescriptorImpl]

'ExtractionTarget' @ [502:40] ==> public companion object defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[FakeCallableDescriptorForObject]

'PROPERTY_WITH_INITIALIZER' @ [502:57] ==> enum entry PROPERTY_WITH_INITIALIZER defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[FakeCallableDescriptorForObject]

'body' @ [504:13] ==> val body: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'AssertionError' @ [504:47] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'descriptor' @ [504:86] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'extractionData' @ [504:97] ==> public final val extractionData: ExtractionData defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'codeFragmentText' @ [504:112] ==> public final val codeFragmentText: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[PropertyDescriptorImpl]

'body' @ [506:31] ==> val body: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'statements' @ [506:36] ==> public final val KtBlockExpression.statements: List<(KtExpression..KtExpression?)>[MyPropertyDescriptor]

'firstOrNull' @ [506:47] ==> public fun <T> List<(KtExpression..KtExpression?)>.firstOrNull(): KtExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)

'firstExpression' @ [507:13] ==> val firstExpression: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'descriptor' @ [508:27] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'parameters' @ [508:38] ==> public final val parameters: List<Parameter> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'param' @ [509:17] ==> val param: Parameter defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'mirrorVarName' @ [509:23] ==> public abstract val mirrorVarName: String? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.Parameter[PropertyDescriptorImpl]

'let' @ [509:38] ==> @InlineOnly public inline fun <T, R> String.let(block: (String) -> (PsiElement..PsiElement?)): (PsiElement..PsiElement?) defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String
    <R> -> (com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)

'body' @ [510:21] ==> val body: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'addBefore' @ [510:26] ==> public abstract fun addBefore(@NotNull p0: PsiElement, @Nullable p1: PsiElement?): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtExpression[JavaMethodDescriptor]

'psiFactory' @ [510:36] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'createProperty' @ [510:47] ==> public final fun createProperty(name: String, type: String?, isVar: Boolean, initializer: String?): KtProperty defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'varName' @ [510:62] ==> value-parameter varName: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody.<anonymous>[ValueParameterDescriptorImpl]

'param' @ [510:83] ==> val param: Parameter defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'name' @ [510:89] ==> public abstract val name: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.Parameter[PropertyDescriptorImpl]

'firstExpression' @ [510:96] ==> val firstExpression: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'body' @ [511:21] ==> val body: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'addBefore' @ [511:26] ==> public abstract fun addBefore(@NotNull p0: PsiElement, @Nullable p1: PsiElement?): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtExpression[JavaMethodDescriptor]

'psiFactory' @ [511:36] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'createNewLine' @ [511:47] ==> public final fun createNewLine(): PsiElement defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'firstExpression' @ [511:64] ==> val firstExpression: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'descriptor' @ [516:28] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'controlFlow' @ [516:39] ==> public final val controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'defaultOutputValue' @ [516:51] ==> public final val defaultOutputValue: OutputValue.ExpressionValue? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'body' @ [518:30] ==> val body: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'statements' @ [518:35] ==> public final val KtBlockExpression.statements: List<(KtExpression..KtExpression?)>[MyPropertyDescriptor]

'lastOrNull' @ [518:46] ==> public fun <T> List<(KtExpression..KtExpression?)>.lastOrNull(): KtExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)

'lastExpression' @ [519:13] ==> val lastExpression: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'if (!generatorOptions.inTempFile && defaultValue != null && descriptor.controlFlow.outputValueBoxer.boxingRequired && lastExpression!!.isMultiLine()) {
                    val varNameValidator = NewDeclarationNameValidator(body, lastExpression, NewDeclarationNameValidator.Target.VARIABLES)
                    val resultVal = KotlinNameSuggester.suggestNamesByType(defaultValue.valueType, varNameValidator, null).first()
                    body.addBefore(psiFactory.createDeclaration("val $resultVal = ${lastExpression.text}"), lastExpression)
                    body.addBefore(psiFactory.createNewLine(), lastExpression)
                    psiFactory.createExpression(resultVal)
                }
                else lastExpression' @ [522:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtExpression?, elseBranch: KtExpression?): KtExpression?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtExpression?

'!' @ [522:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'generatorOptions' @ [522:22] ==> public final val generatorOptions: ExtractionGeneratorOptions defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'inTempFile' @ [522:39] ==> public final val inTempFile: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorOptions[PropertyDescriptorImpl]

'defaultValue' @ [522:53] ==> val defaultValue: OutputValue.ExpressionValue? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'descriptor' @ [522:77] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'controlFlow' @ [522:88] ==> public final val controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'outputValueBoxer' @ [522:100] ==> public final val outputValueBoxer: OutputValueBoxer defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'boxingRequired' @ [522:117] ==> public abstract val boxingRequired: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValueBoxer[PropertyDescriptorImpl]

'lastExpression' @ [522:135] ==> val lastExpression: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'isMultiLine' @ [522:152] ==> public fun PsiElement.isMultiLine(): Boolean defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'NewDeclarationNameValidator' @ [523:44] ==> public constructor NewDeclarationNameValidator(container: PsiElement, anchor: PsiElement?, target: NewDeclarationNameValidator.Target, excludedDeclarations: List<KtDeclaration> = ...) defined in org.jetbrains.kotlin.idea.core.NewDeclarationNameValidator[DeserializedClassConstructorDescriptor]

'body' @ [523:72] ==> val body: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'lastExpression' @ [523:78] ==> val lastExpression: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'VARIABLES' @ [523:129] ==> enum entry VARIABLES defined in org.jetbrains.kotlin.idea.core.NewDeclarationNameValidator.Target[FakeCallableDescriptorForObject]

'KotlinNameSuggester' @ [524:37] ==> public object KotlinNameSuggester defined in org.jetbrains.kotlin.idea.core[FakeCallableDescriptorForObject]

'suggestNamesByType' @ [524:57] ==> public final fun suggestNamesByType(type: KotlinType, validator: (String) -> Boolean, defaultName: String? = ...): List<String> defined in org.jetbrains.kotlin.idea.core.KotlinNameSuggester[DeserializedSimpleFunctionDescriptor]

'defaultValue' @ [524:76] ==> val defaultValue: OutputValue.ExpressionValue? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'valueType' @ [524:89] ==> public open val valueType: KotlinType defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValue.ExpressionValue[PropertyDescriptorImpl]

'varNameValidator' @ [524:100] ==> val varNameValidator: NewDeclarationNameValidator defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'first' @ [524:124] ==> public fun <T> List<String>.first(): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'body' @ [525:21] ==> val body: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'addBefore' @ [525:26] ==> public abstract fun addBefore(@NotNull p0: PsiElement, @Nullable p1: PsiElement?): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtExpression[JavaMethodDescriptor]

'psiFactory' @ [525:36] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'createDeclaration' @ [525:47] ==> public final fun <TDeclaration : KtDeclaration> createDeclaration(text: String): KtDeclaration defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <TDeclaration : KtDeclaration> -> KtDeclaration

'resultVal' @ [525:71] ==> val resultVal: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'lastExpression' @ [525:85] ==> val lastExpression: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'text' @ [525:100] ==> public final val KtExpression.text: (String..String?)[MyPropertyDescriptor]

'lastExpression' @ [525:109] ==> val lastExpression: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'body' @ [526:21] ==> val body: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'addBefore' @ [526:26] ==> public abstract fun addBefore(@NotNull p0: PsiElement, @Nullable p1: PsiElement?): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtExpression[JavaMethodDescriptor]

'psiFactory' @ [526:36] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'createNewLine' @ [526:47] ==> public final fun createNewLine(): PsiElement defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'lastExpression' @ [526:64] ==> val lastExpression: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'psiFactory' @ [527:21] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'createExpression' @ [527:32] ==> public final fun createExpression(text: String): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'resultVal' @ [527:49] ==> val resultVal: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'lastExpression' @ [529:22] ==> val lastExpression: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'descriptor' @ [531:32] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'controlFlow' @ [531:43] ==> public final val controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'outputValueBoxer' @ [531:55] ==> public final val outputValueBoxer: OutputValueBoxer defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ControlFlow[PropertyDescriptorImpl]

'getReturnExpression' @ [531:72] ==> public final fun getReturnExpression(arguments: List<KtExpression>, psiFactory: KtPsiFactory): KtReturnExpression? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValueBoxer[SimpleFunctionDescriptorImpl]

'getReturnArguments' @ [531:92] ==> local final fun getReturnArguments(resultExpression: KtExpression?): List<KtExpression> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[SimpleFunctionDescriptorImpl]

'defaultExpression' @ [531:111] ==> val defaultExpression: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'psiFactory' @ [531:131] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'Suppress' @ [533:9] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'when(generatorOptions.target) {
            ExtractionTarget.LAZY_PROPERTY, ExtractionTarget.FAKE_LAMBDALIKE_FUNCTION -> {
                // In the case of lazy property absence of default value means that output values are of OutputValue.Initializer type
                // We just add resulting expressions without return, since returns are prohibited in the body of lazy property
                if (defaultValue == null) {
                    body.appendElement(returnExpression.returnedExpression!!)
                }
                return
            }
        }' @ [534:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Nothing

'generatorOptions' @ [534:14] ==> public final val generatorOptions: ExtractionGeneratorOptions defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'target' @ [534:31] ==> public final val target: ExtractionTarget defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorOptions[PropertyDescriptorImpl]

'ExtractionTarget' @ [535:13] ==> public companion object defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[FakeCallableDescriptorForObject]

'LAZY_PROPERTY' @ [535:30] ==> enum entry LAZY_PROPERTY defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[FakeCallableDescriptorForObject]

'ExtractionTarget' @ [535:45] ==> public companion object defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[FakeCallableDescriptorForObject]

'FAKE_LAMBDALIKE_FUNCTION' @ [535:62] ==> enum entry FAKE_LAMBDALIKE_FUNCTION defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[FakeCallableDescriptorForObject]

'defaultValue' @ [538:21] ==> val defaultValue: OutputValue.ExpressionValue? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'body' @ [539:21] ==> val body: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'appendElement' @ [539:26] ==> public fun KtBlockExpression.appendElement(element: KtElement, addNewLine: Boolean = ...): KtElement defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]

'returnExpression' @ [539:40] ==> val returnExpression: KtReturnExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'returnedExpression' @ [539:57] ==> public final val KtReturnExpression.returnedExpression: KtExpression?[MyPropertyDescriptor]

'when {
            defaultValue == null -> body.appendElement(returnExpression)
            !defaultValue.callSiteReturn -> lastExpression!!.replaceWithReturn(returnExpression)
        }' @ [545:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Any, entry1: Any): Any[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Any

'defaultValue' @ [546:13] ==> val defaultValue: OutputValue.ExpressionValue? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'body' @ [546:37] ==> val body: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'appendElement' @ [546:42] ==> public fun KtBlockExpression.appendElement(element: KtElement, addNewLine: Boolean = ...): KtElement defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]

'returnExpression' @ [546:56] ==> val returnExpression: KtReturnExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'!' @ [547:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'defaultValue' @ [547:14] ==> val defaultValue: OutputValue.ExpressionValue? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'callSiteReturn' @ [547:27] ==> public final val callSiteReturn: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.OutputValue.ExpressionValue[PropertyDescriptorImpl]

'lastExpression' @ [547:45] ==> val lastExpression: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'replaceWithReturn' @ [547:62] ==> local final fun KtExpression.replaceWithReturn(replacingExpression: KtReturnExpression): Unit defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[SimpleFunctionDescriptorImpl]

'returnExpression' @ [547:80] ==> val returnExpression: KtReturnExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'generatorOptions' @ [550:13] ==> public final val generatorOptions: ExtractionGeneratorOptions defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'allowExpressionBody' @ [550:30] ==> public final val allowExpressionBody: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorOptions[PropertyDescriptorImpl]

'body' @ [551:34] ==> val body: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'statements' @ [551:39] ==> public final val KtBlockExpression.statements: List<(KtExpression..KtExpression?)>[MyPropertyDescriptor]

'singleOrNull' @ [551:50] ==> public fun <T> List<(KtExpression..KtExpression?)>.singleOrNull(): KtExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)

'body' @ [552:29] ==> val body: KtExpression defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'parent' @ [552:34] ==> public final val KtBlockExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'UseExpressionBodyInspection' @ [553:47] ==> public constructor UseExpressionBodyInspection() defined in org.jetbrains.kotlin.idea.inspections.UseExpressionBodyInspection[ClassConstructorDescriptorImpl]

'bodyExpression' @ [554:17] ==> val bodyExpression: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'!' @ [554:43] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'bodyExpression' @ [554:44] ==> val bodyExpression: KtExpression? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'isMultiLine' @ [554:59] ==> public fun PsiElement.isMultiLine(): Boolean defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'useExpressionBodyInspection' @ [554:76] ==> val useExpressionBodyInspection: UseExpressionBodyInspection defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'isActiveFor' @ [554:104] ==> public final fun isActiveFor(declaration: KtDeclarationWithBody): Boolean defined in org.jetbrains.kotlin.idea.inspections.UseExpressionBodyInspection[SimpleFunctionDescriptorImpl]

'bodyOwner' @ [554:116] ==> val bodyOwner: KtDeclarationWithBody defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'useExpressionBodyInspection' @ [555:17] ==> val useExpressionBodyInspection: UseExpressionBodyInspection defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'simplify' @ [555:45] ==> public final fun simplify(declaration: KtDeclarationWithBody, canDeleteTypeRef: Boolean): Unit defined in org.jetbrains.kotlin.idea.inspections.UseExpressionBodyInspection[SimpleFunctionDescriptorImpl]

'bodyOwner' @ [555:54] ==> val bodyOwner: KtDeclarationWithBody defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.adjustDeclarationBody[LocalVariableDescriptor]

'!' @ [555:65] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'descriptor' @ [555:66] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'returnType' @ [555:77] ==> public final val returnType: KotlinType defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'isFlexible' @ [555:88] ==> public fun KotlinType.isFlexible(): Boolean defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'declarationToReplace' @ [561:9] ==> value-parameter declarationToReplace: KtNamedDeclaration? = ... defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[ValueParameterDescriptorImpl]

'let' @ [561:31] ==> @InlineOnly public inline fun <T, R> KtNamedDeclaration.let(block: (KtNamedDeclaration) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtNamedDeclaration
    <R> -> Nothing

'it' @ [561:44] ==> value-parameter it: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.insertDeclaration.<anonymous>[ValueParameterDescriptorImpl]

'replace' @ [561:47] ==> public abstract fun replace(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtNamedDeclaration[JavaMethodDescriptor]

'declaration' @ [561:55] ==> value-parameter declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.insertDeclaration[ValueParameterDescriptorImpl]

'with' @ [563:16] ==> @InlineOnly public inline fun <T, R> with(receiver: ExtractionData, block: ExtractionData.() -> KtNamedDeclaration): KtNamedDeclaration defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExtractionData
    <R> -> KtNamedDeclaration

'descriptor' @ [563:21] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'extractionData' @ [563:32] ==> public final val extractionData: ExtractionData defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'anchor' @ [564:35] ==> value-parameter anchor: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.insertDeclaration[ValueParameterDescriptorImpl]

'parent' @ [564:42] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'psiFactory' @ [566:30] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'createWhiteSpace' @ [566:41] ==> public final fun createWhiteSpace(text: String): PsiElement defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'if (insertBefore) {
                (targetContainer.addBefore(declaration, anchor) as KtNamedDeclaration).apply {
                    targetContainer.addBefore(emptyLines, anchor)
                }
            }
            else {
                (targetContainer.addAfter(declaration, anchor) as KtNamedDeclaration).apply {
                    if (!(targetContainer is KtClassBody && (targetContainer.parent as? KtClass)?.isEnum() ?: false)) {
                        targetContainer.addAfter(emptyLines, anchor)
                    }
                }
            }' @ [567:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtNamedDeclaration, elseBranch: KtNamedDeclaration): KtNamedDeclaration[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtNamedDeclaration

'insertBefore' @ [567:17] ==> public final val insertBefore: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[PropertyDescriptorImpl]

'targetContainer' @ [568:18] ==> val targetContainer: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.insertDeclaration.<anonymous>[LocalVariableDescriptor]

'addBefore' @ [568:34] ==> public abstract fun addBefore(@NotNull p0: PsiElement, @Nullable p1: PsiElement?): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'declaration' @ [568:44] ==> value-parameter declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.insertDeclaration[ValueParameterDescriptorImpl]

'anchor' @ [568:57] ==> value-parameter anchor: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.insertDeclaration[ValueParameterDescriptorImpl]

'apply' @ [568:88] ==> @InlineOnly public inline fun <T> KtNamedDeclaration.apply(block: KtNamedDeclaration.() -> Unit): KtNamedDeclaration defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtNamedDeclaration

'targetContainer' @ [569:21] ==> val targetContainer: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.insertDeclaration.<anonymous>[LocalVariableDescriptor]

'addBefore' @ [569:37] ==> public abstract fun addBefore(@NotNull p0: PsiElement, @Nullable p1: PsiElement?): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'emptyLines' @ [569:47] ==> val emptyLines: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.insertDeclaration.<anonymous>[LocalVariableDescriptor]

'anchor' @ [569:59] ==> value-parameter anchor: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.insertDeclaration[ValueParameterDescriptorImpl]

'targetContainer' @ [573:18] ==> val targetContainer: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.insertDeclaration.<anonymous>[LocalVariableDescriptor]

'addAfter' @ [573:34] ==> public abstract fun addAfter(@NotNull p0: PsiElement, @Nullable p1: PsiElement?): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'declaration' @ [573:43] ==> value-parameter declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.insertDeclaration[ValueParameterDescriptorImpl]

'anchor' @ [573:56] ==> value-parameter anchor: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.insertDeclaration[ValueParameterDescriptorImpl]

'apply' @ [573:87] ==> @InlineOnly public inline fun <T> KtNamedDeclaration.apply(block: KtNamedDeclaration.() -> Unit): KtNamedDeclaration defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtNamedDeclaration

'!' @ [574:25] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'targetContainer' @ [574:27] ==> val targetContainer: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.insertDeclaration.<anonymous>[LocalVariableDescriptor]

'?:' @ [574:61] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: Boolean?, right: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> Boolean

'targetContainer' @ [574:62] ==> val targetContainer: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.insertDeclaration.<anonymous>[LocalVariableDescriptor]

'parent' @ [574:78] ==> public final val KtClassBody.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'isEnum' @ [574:99] ==> public final fun isEnum(): Boolean defined in org.jetbrains.kotlin.psi.KtClass[DeserializedSimpleFunctionDescriptor]

'targetContainer' @ [575:25] ==> val targetContainer: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.insertDeclaration.<anonymous>[LocalVariableDescriptor]

'addAfter' @ [575:41] ==> public abstract fun addAfter(@NotNull p0: PsiElement, @Nullable p1: PsiElement?): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'emptyLines' @ [575:50] ==> val emptyLines: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.insertDeclaration.<anonymous>[LocalVariableDescriptor]

'anchor' @ [575:62] ==> value-parameter anchor: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.insertDeclaration[ValueParameterDescriptorImpl]

'if (generatorOptions.inTempFile) Collections.emptyList() else descriptor.duplicates' @ [582:22] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (List<DuplicateInfo>..List<DuplicateInfo>?), elseBranch: (List<DuplicateInfo>..List<DuplicateInfo>?)): (List<DuplicateInfo>..List<DuplicateInfo>?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (kotlin.collections.List<org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.DuplicateInfo>..kotlin.collections.List<org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.DuplicateInfo>?)

'generatorOptions' @ [582:26] ==> public final val generatorOptions: ExtractionGeneratorOptions defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'inTempFile' @ [582:43] ==> public final val inTempFile: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorOptions[PropertyDescriptorImpl]

'emptyList' @ [582:67] ==> public final fun <T : (Any..Any?)> emptyList(): (MutableList<(DuplicateInfo..DuplicateInfo?)>..List<(DuplicateInfo..DuplicateInfo?)>?) defined in java.util.Collections[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> DuplicateInfo

'descriptor' @ [582:84] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'duplicates' @ [582:95] ==> public final val duplicates: List<DuplicateInfo> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'with' @ [584:18] ==> @InlineOnly public inline fun <T, R> with(receiver: ExtractionData, block: ExtractionData.() -> PsiElement): PsiElement defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExtractionData
    <R> -> PsiElement

'descriptor' @ [584:23] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'extractionData' @ [584:34] ==> public final val extractionData: ExtractionData defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'targetSibling' @ [585:28] ==> public final val targetSibling: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[PropertyDescriptorImpl]

'parent' @ [585:42] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'duplicates' @ [587:32] ==> val duplicates: (List<DuplicateInfo>..List<DuplicateInfo>?) defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'mapTo' @ [587:43] ==> public inline fun <T, R, C : MutableCollection<in PsiElement>> Iterable<DuplicateInfo>.mapTo(destination: ArrayList<PsiElement>, transform: (DuplicateInfo) -> PsiElement): ArrayList<PsiElement> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DuplicateInfo
    <R> -> PsiElement
    <C : MutableCollection<in R>> -> ArrayList<PsiElement>

'ArrayList' @ [587:49] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> PsiElement

'it' @ [587:76] ==> value-parameter it: DuplicateInfo defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'range' @ [587:79] ==> public final val range: KotlinPsiRange defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.DuplicateInfo[PropertyDescriptorImpl]

'elements' @ [587:85] ==> public abstract val elements: List<PsiElement> defined in org.jetbrains.kotlin.idea.util.psi.patternMatching.KotlinPsiRange[DeserializedPropertyDescriptor]

'first' @ [587:94] ==> public fun <T> List<PsiElement>.first(): PsiElement defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'substringContextOrThis' @ [587:102] ==> public val PsiElement.substringContextOrThis: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce[DeserializedPropertyDescriptor]

'anchorCandidates' @ [588:9] ==> val anchorCandidates: ArrayList<PsiElement> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.<anonymous>[LocalVariableDescriptor]

'add' @ [588:26] ==> public open fun add(element: PsiElement): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'targetSibling' @ [588:30] ==> public final val targetSibling: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[PropertyDescriptorImpl]

'targetSibling' @ [589:13] ==> public final val targetSibling: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[PropertyDescriptorImpl]

'anchorCandidates' @ [590:13] ==> val anchorCandidates: ArrayList<PsiElement> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.<anonymous>[LocalVariableDescriptor]

'add' @ [590:30] ==> public open fun add(element: PsiElement): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'targetSibling' @ [590:34] ==> public final val targetSibling: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[PropertyDescriptorImpl]

'siblings' @ [590:48] ==> public fun PsiElement.siblings(forward: Boolean = ..., withItself: Boolean = ...): Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'last' @ [590:59] ==> public inline fun <T> Sequence<PsiElement>.last(predicate: (PsiElement) -> Boolean): PsiElement defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'it' @ [590:66] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'if (insertBefore) {
            anchorCandidates.minBy { it.startOffset }!!
        }
        else {
            anchorCandidates.maxBy { it.startOffset }!!
        }' @ [593:33] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: PsiElement, elseBranch: PsiElement): PsiElement[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> PsiElement

'insertBefore' @ [593:37] ==> public final val insertBefore: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[PropertyDescriptorImpl]

'anchorCandidates' @ [594:13] ==> val anchorCandidates: ArrayList<PsiElement> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.<anonymous>[LocalVariableDescriptor]

'minBy' @ [594:30] ==> public inline fun <T, R : Comparable<Int>> Iterable<PsiElement>.minBy(selector: (PsiElement) -> Int): PsiElement? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement
    <R : Comparable<R>> -> Int

'it' @ [594:38] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'startOffset' @ [594:41] ==> public val PsiElement.startOffset: Int defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'anchorCandidates' @ [597:13] ==> val anchorCandidates: ArrayList<PsiElement> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.<anonymous>[LocalVariableDescriptor]

'maxBy' @ [597:30] ==> public inline fun <T, R : Comparable<Int>> Iterable<PsiElement>.maxBy(selector: (PsiElement) -> Int): PsiElement? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement
    <R : Comparable<R>> -> Int

'it' @ [597:38] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'startOffset' @ [597:41] ==> public val PsiElement.startOffset: Int defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'marginalCandidate' @ [601:9] ==> val marginalCandidate: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.<anonymous>[LocalVariableDescriptor]

'parentsWithSelf' @ [601:27] ==> public val PsiElement.parentsWithSelf: Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'first' @ [601:43] ==> public inline fun <T> Sequence<PsiElement>.first(predicate: (PsiElement) -> Boolean): PsiElement defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'it' @ [601:51] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'parent' @ [601:54] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'targetParent' @ [601:64] ==> val targetParent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.<anonymous>[LocalVariableDescriptor]

'!' @ [604:24] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'generatorOptions' @ [604:26] ==> public final val generatorOptions: ExtractionGeneratorOptions defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'inTempFile' @ [604:43] ==> public final val inTempFile: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorOptions[PropertyDescriptorImpl]

'generatorOptions' @ [604:57] ==> public final val generatorOptions: ExtractionGeneratorOptions defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'target' @ [604:74] ==> public final val target: ExtractionTarget defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorOptions[PropertyDescriptorImpl]

'ExtractionTarget' @ [604:84] ==> public companion object defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[FakeCallableDescriptorForObject]

'FAKE_LAMBDALIKE_FUNCTION' @ [604:101] ==> enum entry FAKE_LAMBDALIKE_FUNCTION defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionTarget[FakeCallableDescriptorForObject]

'createDeclaration' @ [605:23] ==> local final fun createDeclaration(): KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[SimpleFunctionDescriptorImpl]

'let' @ [605:43] ==> @InlineOnly public inline fun <T, R> KtNamedDeclaration.let(block: (KtNamedDeclaration) -> KtNamedDeclaration): KtNamedDeclaration defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtNamedDeclaration
    <R> -> KtNamedDeclaration

'if (shouldInsert) insertDeclaration(it, anchor) else it' @ [605:49] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtNamedDeclaration, elseBranch: KtNamedDeclaration): KtNamedDeclaration[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtNamedDeclaration

'shouldInsert' @ [605:53] ==> val shouldInsert: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'insertDeclaration' @ [605:67] ==> local final fun insertDeclaration(declaration: KtNamedDeclaration, anchor: PsiElement): KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[SimpleFunctionDescriptorImpl]

'it' @ [605:85] ==> value-parameter it: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.<anonymous>[ValueParameterDescriptorImpl]

'anchor' @ [605:89] ==> val anchor: PsiElement defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'it' @ [605:102] ==> value-parameter it: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.<anonymous>[ValueParameterDescriptorImpl]

'adjustDeclarationBody' @ [606:5] ==> local final fun adjustDeclarationBody(declaration: KtNamedDeclaration): Unit defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[SimpleFunctionDescriptorImpl]

'declaration' @ [606:27] ==> val declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'declaration' @ [608:9] ==> val declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'declaration' @ [608:43] ==> val declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'getContainingKtFile' @ [608:55] ==> @NotNull public abstract fun getContainingKtFile(): KtFile defined in org.jetbrains.kotlin.psi.KtNamedDeclaration[JavaMethodDescriptor]

'suppressDiagnosticsInDebugMode' @ [608:77] ==> public var KtFile.suppressDiagnosticsInDebugMode: Boolean defined in org.jetbrains.kotlin.psi.codeFragmentUtil[DeserializedPropertyDescriptor]

'declaration' @ [609:9] ==> val declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'receiverTypeReference' @ [609:21] ==> public final val KtNamedFunction.receiverTypeReference: KtTypeReference?[MyPropertyDescriptor]

'debugTypeInfo' @ [609:44] ==> public var KtTypeReference.debugTypeInfo: KotlinType? defined in org.jetbrains.kotlin.psi.codeFragmentUtil[DeserializedPropertyDescriptor]

'descriptor' @ [609:60] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'receiverParameter' @ [609:71] ==> public final val receiverParameter: Parameter? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'getParameterType' @ [609:90] ==> public abstract fun getParameterType(allowSpecialClassNames: Boolean): KotlinType defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.Parameter[SimpleFunctionDescriptorImpl]

'component1' @ [611:15] ==> public final operator fun component1(): Int defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'component2' @ [611:18] ==> public final operator fun component2(): (KtParameter..KtParameter?) defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'declaration' @ [611:28] ==> val declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'valueParameters' @ [611:40] ==> public final val KtNamedFunction.valueParameters: (MutableList<(KtParameter..KtParameter?)>..List<(KtParameter..KtParameter?)>)[MyPropertyDescriptor]

'withIndex' @ [611:56] ==> public fun <T> Iterable<(KtParameter..KtParameter?)>.withIndex(): Iterable<IndexedValue<(KtParameter..KtParameter?)>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtParameter..org.jetbrains.kotlin.psi.KtParameter?)

'param' @ [612:13] ==> val param: (KtParameter..KtParameter?) defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'typeReference' @ [612:19] ==> public final var KtParameter.typeReference: KtTypeReference?[MyPropertyDescriptor]

'debugTypeInfo' @ [612:34] ==> public var KtTypeReference.debugTypeInfo: KotlinType? defined in org.jetbrains.kotlin.psi.codeFragmentUtil[DeserializedPropertyDescriptor]

'descriptor' @ [612:50] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'parameters' @ [612:61] ==> public final val parameters: List<Parameter> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'i' @ [612:72] ==> val i: Int defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'getParameterType' @ [612:75] ==> public abstract fun getParameterType(allowSpecialClassNames: Boolean): KotlinType defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.Parameter[SimpleFunctionDescriptorImpl]

'declaration' @ [615:13] ==> val declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'typeReference' @ [615:25] ==> public final var KtNamedFunction.typeReference: KtTypeReference?[MyPropertyDescriptor]

'declaration' @ [616:13] ==> val declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'typeReference' @ [616:25] ==> public final var KtNamedFunction.typeReference: KtTypeReference?[MyPropertyDescriptor]

'debugTypeInfo' @ [616:40] ==> public var KtTypeReference.debugTypeInfo: KotlinType? defined in org.jetbrains.kotlin.psi.codeFragmentUtil[DeserializedPropertyDescriptor]

'descriptor' @ [616:56] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'returnType' @ [616:67] ==> public final val returnType: KotlinType defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'builtIns' @ [616:78] ==> public val KotlinType.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.types.typeUtil[DeserializedPropertyDescriptor]

'anyType' @ [616:87] ==> public final val KotlinBuiltIns.anyType: SimpleType[MyPropertyDescriptor]

'generatorOptions' @ [620:9] ==> public final val generatorOptions: ExtractionGeneratorOptions defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'inTempFile' @ [620:26] ==> public final val inTempFile: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorOptions[PropertyDescriptorImpl]

'ExtractionResult' @ [620:45] ==> public constructor ExtractionResult(config: ExtractionGeneratorConfiguration, declaration: KtNamedDeclaration, duplicateReplacers: Map<KotlinPsiRange, () -> Unit>) defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionResult[ClassConstructorDescriptorImpl]

'this' @ [620:62] ==> <this> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[ReceiverParameterDescriptorImpl]

'declaration' @ [620:68] ==> val declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'emptyMap' @ [620:93] ==> public final fun <K : (Any..Any?), V : (Any..Any?)> emptyMap(): (MutableMap<(KotlinPsiRange..KotlinPsiRange?), (() -> Unit..(() -> Unit)?)>..Map<(KotlinPsiRange..KotlinPsiRange?), (() -> Unit..(() -> Unit)?)>?) defined in java.util.Collections[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> KotlinPsiRange
    <V : (Any..Any?)> -> Function0<Unit>

'descriptor' @ [623:25] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'parameters' @ [623:36] ==> public final val parameters: List<Parameter> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'map' @ [623:47] ==> public inline fun <T, R> Iterable<Parameter>.map(transform: (Parameter) -> String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Parameter
    <R> -> String

'it' @ [623:53] ==> value-parameter it: Parameter defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'argumentText' @ [623:56] ==> public abstract val argumentText: String defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.Parameter[PropertyDescriptorImpl]

'makeCall' @ [624:9] ==> private fun makeCall(extractableDescriptor: ExtractableCodeDescriptor, declaration: KtNamedDeclaration, controlFlow: ControlFlow, rangeToReplace: KotlinPsiRange, arguments: List<String>): Unit defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine[SimpleFunctionDescriptorImpl]

'descriptor' @ [624:18] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'declaration' @ [624:30] ==> val declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'descriptor' @ [624:43] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'controlFlow' @ [624:54] ==> public final val controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'descriptor' @ [624:67] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'extractionData' @ [624:78] ==> public final val extractionData: ExtractionData defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'originalRange' @ [624:93] ==> public final val originalRange: KotlinPsiRange defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[PropertyDescriptorImpl]

'arguments' @ [624:108] ==> val arguments: List<String> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.<anonymous>[LocalVariableDescriptor]

'!' @ [627:9] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'generatorOptions' @ [627:10] ==> public final val generatorOptions: ExtractionGeneratorOptions defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'delayInitialOccurrenceReplacement' @ [627:27] ==> public final val delayInitialOccurrenceReplacement: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorOptions[PropertyDescriptorImpl]

'invoke' @ [627:62] ==> public abstract operator fun invoke(): Unit defined in kotlin.Function0[FunctionInvokeDescriptor]

'shouldInsert' @ [629:9] ==> val shouldInsert: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'ShortenReferences' @ [630:9] ==> public companion object defined in org.jetbrains.kotlin.idea.core.ShortenReferences[FakeCallableDescriptorForObject]

'DEFAULT' @ [630:27] ==> @field:JvmField public final val DEFAULT: ShortenReferences defined in org.jetbrains.kotlin.idea.core.ShortenReferences.Companion[DeserializedPropertyDescriptor]

'process' @ [630:35] ==> @JvmOverloads public final fun process(element: KtElement, elementFilter: (PsiElement) -> ShortenReferences.FilterResult = ...): KtElement defined in org.jetbrains.kotlin.idea.core.ShortenReferences[DeserializedSimpleFunctionDescriptor]

'declaration' @ [630:43] ==> val declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'generatorOptions' @ [633:9] ==> public final val generatorOptions: ExtractionGeneratorOptions defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'inTempFile' @ [633:26] ==> public final val inTempFile: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorOptions[PropertyDescriptorImpl]

'ExtractionResult' @ [633:45] ==> public constructor ExtractionResult(config: ExtractionGeneratorConfiguration, declaration: KtNamedDeclaration, duplicateReplacers: Map<KotlinPsiRange, () -> Unit>) defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionResult[ClassConstructorDescriptorImpl]

'this' @ [633:62] ==> <this> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[ReceiverParameterDescriptorImpl]

'declaration' @ [633:68] ==> val declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'emptyMap' @ [633:81] ==> public fun <K, V> emptyMap(): Map<KotlinPsiRange, () -> Unit> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> KotlinPsiRange
    <V> -> Function0<Unit>

'HashMap' @ [635:30] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> KotlinPsiRange
    <V : (Any..Any?)> -> Function0<Unit>

'apply' @ [635:68] ==> @InlineOnly public inline fun <T> HashMap<KotlinPsiRange, () -> Unit>.apply(block: HashMap<KotlinPsiRange, () -> Unit>.() -> Unit): HashMap<KotlinPsiRange, () -> Unit> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> HashMap<KotlinPsiRange, Function0<Unit>>

'generatorOptions' @ [636:13] ==> public final val generatorOptions: ExtractionGeneratorOptions defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'delayInitialOccurrenceReplacement' @ [636:30] ==> public final val delayInitialOccurrenceReplacement: Boolean defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorOptions[PropertyDescriptorImpl]

'put' @ [637:13] ==> public open fun put(key: KotlinPsiRange, value: () -> Unit): (() -> Unit)? defined in java.util.HashMap[JavaMethodDescriptor]

'descriptor' @ [637:17] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'extractionData' @ [637:28] ==> public final val extractionData: ExtractionData defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'originalRange' @ [637:43] ==> public final val originalRange: KotlinPsiRange defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[PropertyDescriptorImpl]

'replaceInitialOccurrence' @ [637:58] ==> val replaceInitialOccurrence: () -> Unit defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'putAll' @ [639:9] ==> public fun <K, V> MutableMap<in KotlinPsiRange, in () -> Unit>.putAll(pairs: Iterable<Pair<KotlinPsiRange, () -> Unit>>): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> KotlinPsiRange
    <V> -> Function0<Unit>

'duplicates' @ [639:16] ==> val duplicates: (List<DuplicateInfo>..List<DuplicateInfo>?) defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'map' @ [639:27] ==> public inline fun <T, R> Iterable<DuplicateInfo>.map(transform: (DuplicateInfo) -> Pair<KotlinPsiRange, () -> Unit>): List<Pair<KotlinPsiRange, () -> Unit>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DuplicateInfo
    <R> -> Pair<KotlinPsiRange, Function0<Unit>>

'it' @ [639:33] ==> value-parameter it: DuplicateInfo defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'range' @ [639:36] ==> public final val range: KotlinPsiRange defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.DuplicateInfo[PropertyDescriptorImpl]

'makeCall' @ [639:47] ==> private fun makeCall(extractableDescriptor: ExtractableCodeDescriptor, declaration: KtNamedDeclaration, controlFlow: ControlFlow, rangeToReplace: KotlinPsiRange, arguments: List<String>): Unit defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine[SimpleFunctionDescriptorImpl]

'descriptor' @ [639:56] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'declaration' @ [639:68] ==> val declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'it' @ [639:81] ==> value-parameter it: DuplicateInfo defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'controlFlow' @ [639:84] ==> public final val controlFlow: ControlFlow defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.DuplicateInfo[PropertyDescriptorImpl]

'it' @ [639:97] ==> value-parameter it: DuplicateInfo defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'range' @ [639:100] ==> public final val range: KotlinPsiRange defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.DuplicateInfo[PropertyDescriptorImpl]

'it' @ [639:107] ==> value-parameter it: DuplicateInfo defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'arguments' @ [639:110] ==> public final val arguments: List<String> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.DuplicateInfo[PropertyDescriptorImpl]

'descriptor' @ [642:9] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'typeParameters' @ [642:20] ==> public final val typeParameters: List<TypeParameter> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'isNotEmpty' @ [642:35] ==> @InlineOnly public inline fun <T> Collection<TypeParameter>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeParameter

'iterator' @ [643:21] ==> public abstract fun iterator(): MutableIterator<(PsiReference..PsiReference?)> defined in com.intellij.util.Query[DeserializedSimpleFunctionDescriptor]

'search' @ [643:38] ==> @NotNull public open fun search(@NotNull p0: PsiElement, @NotNull p1: SearchScope): Query<(PsiReference..PsiReference?)> defined in com.intellij.psi.search.searches.ReferencesSearch[JavaMethodDescriptor]

'declaration' @ [643:45] ==> val declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'LocalSearchScope' @ [643:58] ==> public constructor LocalSearchScope(@NotNull p0: PsiElement) defined in com.intellij.psi.search.LocalSearchScope[JavaClassConstructorDescriptor]

'descriptor' @ [643:75] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'getOccurrenceContainer' @ [643:86] ==> private fun ExtractableCodeDescriptor.getOccurrenceContainer(): PsiElement? defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine in file extractorUtil.kt[SimpleFunctionDescriptorImpl]

'?:' @ [644:36] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtTypeArgumentList?, right: KtTypeArgumentList): KtTypeArgumentList[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtTypeArgumentList

'ref' @ [644:37] ==> val ref: (PsiReference..PsiReference?) defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'element' @ [644:41] ==> public final val PsiReference.element: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [644:49] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'typeArgumentList' @ [644:79] ==> public final val KtCallExpression.typeArgumentList: KtTypeArgumentList?[MyPropertyDescriptor]

'RemoveExplicitTypeArgumentsIntention' @ [645:17] ==> public companion object defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention[FakeCallableDescriptorForObject]

'isApplicableTo' @ [645:54] ==> public final fun isApplicableTo(element: KtTypeArgumentList, approximateFlexible: Boolean): Boolean defined in org.jetbrains.kotlin.idea.intentions.RemoveExplicitTypeArgumentsIntention.Companion[SimpleFunctionDescriptorImpl]

'typeArgumentList' @ [645:69] ==> val typeArgumentList: KtTypeArgumentList defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'typeArgumentList' @ [646:17] ==> val typeArgumentList: KtTypeArgumentList defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'delete' @ [646:34] ==> public open fun delete(): Unit defined in org.jetbrains.kotlin.psi.KtTypeArgumentList[JavaMethodDescriptor]

'getInstance' @ [651:22] ==> public open fun getInstance(@NotNull p0: Project): (CodeStyleManager..CodeStyleManager?) defined in com.intellij.psi.codeStyle.CodeStyleManager[JavaMethodDescriptor]

'descriptor' @ [651:34] ==> public final val descriptor: ExtractableCodeDescriptor defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionGeneratorConfiguration[PropertyDescriptorImpl]

'extractionData' @ [651:45] ==> public final val extractionData: ExtractionData defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractableCodeDescriptor[PropertyDescriptorImpl]

'project' @ [651:60] ==> public final val project: Project defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionData[PropertyDescriptorImpl]

'reformat' @ [651:69] ==> @NotNull public abstract fun reformat(@NotNull p0: PsiElement): PsiElement defined in com.intellij.psi.codeStyle.CodeStyleManager[JavaMethodDescriptor]

'declaration' @ [651:78] ==> val declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'ExtractionResult' @ [653:12] ==> public constructor ExtractionResult(config: ExtractionGeneratorConfiguration, declaration: KtNamedDeclaration, duplicateReplacers: Map<KotlinPsiRange, () -> Unit>) defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.ExtractionResult[ClassConstructorDescriptorImpl]

'this' @ [653:29] ==> <this> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[ReceiverParameterDescriptorImpl]

'declaration' @ [653:35] ==> val declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

'duplicateReplacers' @ [653:48] ==> val duplicateReplacers: HashMap<KotlinPsiRange, () -> Unit> defined in org.jetbrains.kotlin.idea.refactoring.introduce.extractionEngine.generateDeclaration[LocalVariableDescriptor]

