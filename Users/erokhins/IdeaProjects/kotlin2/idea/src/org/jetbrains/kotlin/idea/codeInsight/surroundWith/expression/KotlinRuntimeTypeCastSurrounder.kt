'KotlinExpressionSurrounder' @ [43:40] ==> public constructor KotlinExpressionSurrounder() defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinExpressionSurrounder[JavaClassConstructorDescriptor]

'!' @ [46:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'expression' @ [46:14] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.isApplicable[ValueParameterDescriptorImpl]

'isPhysical' @ [46:25] ==> public final val KtExpression.isPhysical: Boolean[MyPropertyDescriptor]

'expression' @ [47:20] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.isApplicable[ValueParameterDescriptorImpl]

'containingFile' @ [47:31] ==> public final val KtExpression.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'file' @ [48:13] ==> val file: (PsiFile..PsiFile?) defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.isApplicable[LocalVariableDescriptor]

'expression' @ [50:20] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.isApplicable[ValueParameterDescriptorImpl]

'analyze' @ [50:31] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'PARTIAL' @ [50:55] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'getType' @ [50:64] ==> @Nullable public abstract fun getType(@NotNull p0: KtExpression): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]

'expression' @ [50:72] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.isApplicable[ValueParameterDescriptorImpl]

'canHaveSubtypes' @ [52:26] ==> public open fun canHaveSubtypes(p0: (KotlinTypeChecker..KotlinTypeChecker?), @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'DEFAULT' @ [52:60] ==> public final val DEFAULT: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaPropertyDescriptor]

'type' @ [52:69] ==> val type: KotlinType defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.isApplicable[LocalVariableDescriptor]

'getInstanceEx' @ [56:49] ==> public open fun getInstanceEx(p0: (Project..Project?)): (DebuggerManagerEx..DebuggerManagerEx?) defined in com.intellij.debugger.DebuggerManagerEx[JavaMethodDescriptor]

'project' @ [56:63] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.surroundExpression[ValueParameterDescriptorImpl]

'context' @ [56:72] ==> public final val DebuggerManagerEx.context: DebuggerContextImpl[MyPropertyDescriptor]

'debuggerContext' @ [57:31] ==> val debuggerContext: DebuggerContextImpl defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.surroundExpression[LocalVariableDescriptor]

'debuggerSession' @ [57:47] ==> public final val DebuggerContextImpl.debuggerSession: DebuggerSession?[MyPropertyDescriptor]

'debuggerSession' @ [58:13] ==> val debuggerSession: DebuggerSession? defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.surroundExpression[LocalVariableDescriptor]

'ProgressWindowWithNotification' @ [59:34] ==> public constructor ProgressWindowWithNotification(p0: Boolean, p1: (Project..Project?)) defined in com.intellij.openapi.progress.util.ProgressWindowWithNotification[JavaClassConstructorDescriptor]

'expression' @ [59:71] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.surroundExpression[ValueParameterDescriptorImpl]

'project' @ [59:82] ==> public final val KtExpression.project: Project[MyPropertyDescriptor]

'SurroundWithCastWorker' @ [60:26] ==> public constructor SurroundWithCastWorker(myEditor: Editor, expression: KtExpression, context: DebuggerContextImpl, indicator: ProgressIndicator) defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker[ClassConstructorDescriptorImpl]

'editor' @ [60:49] ==> value-parameter editor: Editor defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.surroundExpression[ValueParameterDescriptorImpl]

'expression' @ [60:57] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.surroundExpression[ValueParameterDescriptorImpl]

'debuggerContext' @ [60:69] ==> val debuggerContext: DebuggerContextImpl defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.surroundExpression[LocalVariableDescriptor]

'progressWindow' @ [60:86] ==> val progressWindow: ProgressWindowWithNotification defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.surroundExpression[LocalVariableDescriptor]

'progressWindow' @ [61:13] ==> val progressWindow: ProgressWindowWithNotification defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.surroundExpression[LocalVariableDescriptor]

'title' @ [61:28] ==> public final var ProgressWindowWithNotification.title: (String..String?)[MyPropertyDescriptor]

'message' @ [61:51] ==> public open fun message(@NotNull @PropertyKey p0: String, @NotNull vararg p1: (Any..Any?)): (String..String?) defined in com.intellij.debugger.DebuggerBundle[JavaMethodDescriptor]

'debuggerContext' @ [62:13] ==> val debuggerContext: DebuggerContextImpl defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.surroundExpression[LocalVariableDescriptor]

'debugProcess' @ [62:29] ==> public final val DebuggerContextImpl.debugProcess: DebugProcessImpl?[MyPropertyDescriptor]

'managerThread' @ [62:43] ==> public final val DebugProcessImpl.managerThread: (DebuggerManagerThreadImpl..DebuggerManagerThreadImpl?)[MyPropertyDescriptor]

'startProgress' @ [62:58] ==> @Deprecated public open fun startProgress(p0: (DebuggerCommandImpl..DebuggerCommandImpl?), p1: (ProgressWindowWithNotification..ProgressWindowWithNotification?)): Unit defined in com.intellij.debugger.engine.DebuggerManagerThreadImpl[JavaMethodDescriptor]

'worker' @ [62:72] ==> val worker: KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.surroundExpression[LocalVariableDescriptor]

'progressWindow' @ [62:80] ==> val progressWindow: ProgressWindowWithNotification defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.surroundExpression[LocalVariableDescriptor]

'message' @ [68:29] ==> @NotNull public open fun message(@NonNls @PropertyKey p0: (String..String?), vararg p1: (Any..Any?)): String defined in org.jetbrains.kotlin.idea.KotlinBundle[JavaMethodDescriptor]

'KotlinRuntimeTypeEvaluator' @ [76:8] ==> public constructor KotlinRuntimeTypeEvaluator(editor: Editor?, expression: KtExpression, context: DebuggerContextImpl, indicator: ProgressIndicator) defined in org.jetbrains.kotlin.idea.debugger.evaluate.KotlinRuntimeTypeEvaluator[ClassConstructorDescriptorImpl]

'myEditor' @ [76:35] ==> value-parameter myEditor: Editor defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker.<init>[ValueParameterDescriptorImpl]

'expression' @ [76:45] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker.<init>[ValueParameterDescriptorImpl]

'context' @ [76:57] ==> value-parameter context: DebuggerContextImpl defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker.<init>[ValueParameterDescriptorImpl]

'indicator' @ [76:66] ==> value-parameter indicator: ProgressIndicator defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker.<init>[ValueParameterDescriptorImpl]

'type' @ [79:17] ==> value-parameter type: KotlinType? defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker.typeCalculationFinished[ValueParameterDescriptorImpl]

'hold' @ [81:13] ==> public final fun hold(): Unit defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker[JavaMethodDescriptor]

'myEditor' @ [83:27] ==> private final val myEditor: Editor defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker[PropertyDescriptorImpl]

'project' @ [83:36] ==> public final val Editor.project: Project?[MyPropertyDescriptor]

'invokeLater' @ [84:36] ==> public open fun invokeLater(@Nullable p0: Project?, @NotNull p1: Runnable, p2: (ModalityState..ModalityState?)): Unit defined in com.intellij.debugger.DebuggerInvocationUtil[JavaMethodDescriptor]

'project' @ [84:48] ==> val project: Project? defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker.typeCalculationFinished[LocalVariableDescriptor]

'Runnable' @ [84:57] ==> @FunctionalInterface public fun Runnable(function: () -> Unit): Runnable defined in java.lang[SamConstructorDescriptorImpl]

'WriteCommandAction<Any>' @ [85:30] ==> protected/*protected and package*/ constructor WriteCommandAction<T : (Any..Any?)>(@Nullable p0: Project?, @Nullable p1: String?, vararg p2: (PsiFile..PsiFile?)) defined in com.intellij.openapi.command.WriteCommandAction[JavaClassConstructorDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Any

'project' @ [85:54] ==> val project: Project? defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker.typeCalculationFinished[LocalVariableDescriptor]

'message' @ [85:81] ==> public open fun message(@NotNull @PropertyKey p0: String, @NotNull vararg p1: (Any..Any?)): (String..String?) defined in com.intellij.codeInsight.CodeInsightBundle[JavaMethodDescriptor]

'KtPsiFactory' @ [88:47] ==> @JvmOverloads public constructor KtPsiFactory(project: Project, markGenerated: Boolean = ...) defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedClassConstructorDescriptor]

'myElement' @ [88:60] ==> protected/*protected and package*/ final val myElement: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker[JavaPropertyDescriptor]

'project' @ [88:70] ==> public final val PsiElement.project: Project[MyPropertyDescriptor]

'getFqName' @ [90:62] ==> @NotNull public open fun getFqName(@NotNull p0: DeclarationDescriptor): FqNameUnsafe defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'type' @ [90:72] ==> value-parameter type: KotlinType? defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker.typeCalculationFinished[ValueParameterDescriptorImpl]

'constructor' @ [90:77] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'declarationDescriptor' @ [90:89] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'factory' @ [91:50] ==> val factory: KtPsiFactory defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker.typeCalculationFinished.<anonymous>.<no name provided>.run[LocalVariableDescriptor]

'createExpression' @ [91:58] ==> public final fun createExpression(text: String): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'+' @ [91:75] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'fqName' @ [91:89] ==> val fqName: FqNameUnsafe defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker.typeCalculationFinished.<anonymous>.<no name provided>.run[LocalVariableDescriptor]

'asString' @ [91:96] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqNameUnsafe[JavaMethodDescriptor]

'parentCast' @ [92:44] ==> val parentCast: KtParenthesizedExpression defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker.typeCalculationFinished.<anonymous>.<no name provided>.run[LocalVariableDescriptor]

'expression' @ [92:55] ==> public final val KtParenthesizedExpression.expression: KtExpression?[MyPropertyDescriptor]

'cast' @ [93:33] ==> val cast: KtBinaryExpressionWithTypeRHS defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker.typeCalculationFinished.<anonymous>.<no name provided>.run[LocalVariableDescriptor]

'left' @ [93:38] ==> public final val KtBinaryExpressionWithTypeRHS.left: KtExpression[MyPropertyDescriptor]

'replace' @ [93:43] ==> public abstract fun replace(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtExpression[JavaMethodDescriptor]

'myElement' @ [93:51] ==> protected/*protected and package*/ final val myElement: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker[JavaPropertyDescriptor]

'myElement' @ [94:44] ==> protected/*protected and package*/ final val myElement: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker[JavaPropertyDescriptor]

'replace' @ [94:54] ==> public abstract fun replace(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'parentCast' @ [94:62] ==> val parentCast: KtParenthesizedExpression defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker.typeCalculationFinished.<anonymous>.<no name provided>.run[LocalVariableDescriptor]

'ShortenReferences' @ [96:33] ==> public companion object defined in org.jetbrains.kotlin.idea.core.ShortenReferences[FakeCallableDescriptorForObject]

'DEFAULT' @ [96:51] ==> @field:JvmField public final val DEFAULT: ShortenReferences defined in org.jetbrains.kotlin.idea.core.ShortenReferences.Companion[DeserializedPropertyDescriptor]

'process' @ [96:59] ==> @JvmOverloads public final fun process(element: KtElement, elementFilter: (PsiElement) -> ShortenReferences.FilterResult = ...): KtElement defined in org.jetbrains.kotlin.idea.core.ShortenReferences[DeserializedSimpleFunctionDescriptor]

'expr' @ [96:67] ==> val expr: KtExpression defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker.typeCalculationFinished.<anonymous>.<no name provided>.run[LocalVariableDescriptor]

'expr' @ [98:45] ==> val expr: KtExpression defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker.typeCalculationFinished.<anonymous>.<no name provided>.run[LocalVariableDescriptor]

'textRange' @ [98:50] ==> public final val KtExpression.textRange: (TextRange..TextRange?)[MyPropertyDescriptor]

'myEditor' @ [99:33] ==> private final val myEditor: Editor defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker[PropertyDescriptorImpl]

'selectionModel' @ [99:42] ==> public final val Editor.selectionModel: SelectionModel[MyPropertyDescriptor]

'setSelection' @ [99:57] ==> public abstract fun setSelection(p0: Int, p1: Int): Unit defined in com.intellij.openapi.editor.SelectionModel[JavaMethodDescriptor]

'range' @ [99:70] ==> val range: (TextRange..TextRange?) defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker.typeCalculationFinished.<anonymous>.<no name provided>.run[LocalVariableDescriptor]

'startOffset' @ [99:76] ==> public final val TextRange.startOffset: Int[MyPropertyDescriptor]

'range' @ [99:89] ==> val range: (TextRange..TextRange?) defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker.typeCalculationFinished.<anonymous>.<no name provided>.run[LocalVariableDescriptor]

'endOffset' @ [99:95] ==> public final val TextRange.endOffset: Int[MyPropertyDescriptor]

'myEditor' @ [100:33] ==> private final val myEditor: Editor defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker[PropertyDescriptorImpl]

'caretModel' @ [100:42] ==> public final val Editor.caretModel: CaretModel[MyPropertyDescriptor]

'moveToOffset' @ [100:53] ==> public abstract fun moveToOffset(p0: Int): Unit defined in com.intellij.openapi.editor.CaretModel[JavaMethodDescriptor]

'range' @ [100:66] ==> val range: (TextRange..TextRange?) defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker.typeCalculationFinished.<anonymous>.<no name provided>.run[LocalVariableDescriptor]

'endOffset' @ [100:72] ==> public final val TextRange.endOffset: Int[MyPropertyDescriptor]

'myEditor' @ [101:33] ==> private final val myEditor: Editor defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker[PropertyDescriptorImpl]

'scrollingModel' @ [101:42] ==> public final val Editor.scrollingModel: ScrollingModel[MyPropertyDescriptor]

'scrollToCaret' @ [101:57] ==> public abstract fun scrollToCaret(@NotNull p0: ScrollType): Unit defined in com.intellij.openapi.editor.ScrollingModel[JavaMethodDescriptor]

'RELATIVE' @ [101:82] ==> enum entry RELATIVE defined in com.intellij.openapi.editor.ScrollType[FakeCallableDescriptorForObject]

'release' @ [104:33] ==> public final fun release(): Unit defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker[JavaMethodDescriptor]

'execute' @ [107:23] ==> @NotNull public open fun execute(): RunResult<(Any..Any?)> defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker.typeCalculationFinished.<anonymous>.<no name provided>[JavaMethodDescriptor]

'myProgressIndicator' @ [108:16] ==> protected/*protected and package*/ final val myProgressIndicator: (ProgressIndicator..ProgressIndicator?) defined in org.jetbrains.kotlin.idea.codeInsight.surroundWith.expression.KotlinRuntimeTypeCastSurrounder.SurroundWithCastWorker[JavaPropertyDescriptor]

'modalityState' @ [108:36] ==> public final val ProgressIndicator.modalityState: ModalityState[MyPropertyDescriptor]

