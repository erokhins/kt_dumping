'SelfTargetingOffsetIndependentIntention<KtSimpleNameExpression>' @ [27:42] ==> public constructor SelfTargetingOffsetIndependentIntention<TElement : KtElement>(elementType: Class<KtSimpleNameExpression>, text: String, familyName: String = ...) defined in org.jetbrains.kotlin.idea.intentions.SelfTargetingOffsetIndependentIntention[DeserializedClassConstructorDescriptor]
Inferred types:
    <TElement : KtElement> -> KtSimpleNameExpression

'java' @ [27:136] ==> public val <T> KClass<KtSimpleNameExpression>.java: Class<KtSimpleNameExpression> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtSimpleNameExpression

'listOf' @ [29:37] ==> public fun <T> listOf(vararg elements: String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'map' @ [29:90] ==> public inline fun <T, R> Iterable<String>.map(transform: (String) -> String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String
    <R> -> String

'it' @ [29:105] ==> value-parameter it: String defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.FOR_EACH_FQ_NAMES.<anonymous>[ValueParameterDescriptorImpl]

'FOR_EACH_NAME' @ [29:109] ==> private final val FOR_EACH_NAME: String defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention[PropertyDescriptorImpl]

'toSet' @ [29:126] ==> public fun <T> Iterable<String>.toSet(): Set<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'element' @ [33:13] ==> value-parameter element: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.isApplicableTo[ValueParameterDescriptorImpl]

'getReferencedName' @ [33:21] ==> public abstract fun getReferencedName(): String defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[DeserializedSimpleFunctionDescriptor]

'FOR_EACH_NAME' @ [33:44] ==> private final val FOR_EACH_NAME: String defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention[PropertyDescriptorImpl]

'extractData' @ [35:20] ==> private final fun extractData(nameExpr: KtSimpleNameExpression): ConvertForEachToForLoopIntention.Data? defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention[SimpleFunctionDescriptorImpl]

'element' @ [35:32] ==> value-parameter element: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.isApplicableTo[ValueParameterDescriptorImpl]

'data' @ [36:13] ==> val data: ConvertForEachToForLoopIntention.Data defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.isApplicableTo[LocalVariableDescriptor]

'functionLiteral' @ [36:18] ==> public final val functionLiteral: KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.Data[PropertyDescriptorImpl]

'valueParameters' @ [36:34] ==> public final val KtLambdaExpression.valueParameters: (MutableList<(KtParameter..KtParameter?)>..List<(KtParameter..KtParameter?)>)[MyPropertyDescriptor]

'size' @ [36:50] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'data' @ [37:13] ==> val data: ConvertForEachToForLoopIntention.Data defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.isApplicableTo[LocalVariableDescriptor]

'functionLiteral' @ [37:18] ==> public final val functionLiteral: KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.Data[PropertyDescriptorImpl]

'bodyExpression' @ [37:34] ==> public final val KtLambdaExpression.bodyExpression: KtBlockExpression?[MyPropertyDescriptor]

'component1' @ [43:14] ==> public final operator fun component1(): KtExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.Data[SimpleFunctionDescriptorImpl]

'component2' @ [43:35] ==> public final operator fun component2(): KtExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.Data[SimpleFunctionDescriptorImpl]

'component3' @ [43:45] ==> public final operator fun component3(): KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.Data[SimpleFunctionDescriptorImpl]

'extractData' @ [43:64] ==> private final fun extractData(nameExpr: KtSimpleNameExpression): ConvertForEachToForLoopIntention.Data? defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention[SimpleFunctionDescriptorImpl]

'element' @ [43:76] ==> value-parameter element: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.applyTo[ValueParameterDescriptorImpl]

'CommentSaver' @ [45:28] ==> public constructor CommentSaver(originalElement: PsiElement, saveLineBreaks: Boolean = ...) defined in org.jetbrains.kotlin.idea.util.CommentSaver[DeserializedClassConstructorDescriptor]

'expressionToReplace' @ [45:41] ==> val expressionToReplace: KtExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.applyTo[LocalVariableDescriptor]

'generateLoop' @ [47:20] ==> private final fun generateLoop(functionLiteral: KtLambdaExpression, receiver: KtExpression): KtExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention[SimpleFunctionDescriptorImpl]

'functionLiteral' @ [47:33] ==> val functionLiteral: KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.applyTo[LocalVariableDescriptor]

'receiver' @ [47:50] ==> val receiver: KtExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.applyTo[LocalVariableDescriptor]

'expressionToReplace' @ [48:22] ==> val expressionToReplace: KtExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.applyTo[LocalVariableDescriptor]

'replace' @ [48:42] ==> public abstract fun replace(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtExpression[JavaMethodDescriptor]

'loop' @ [48:50] ==> val loop: KtExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.applyTo[LocalVariableDescriptor]

'commentSaver' @ [50:9] ==> val commentSaver: CommentSaver defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.applyTo[LocalVariableDescriptor]

'restore' @ [50:22] ==> public final fun restore(resultElement: PsiElement, forceAdjustIndent: Boolean = ...): Unit defined in org.jetbrains.kotlin.idea.util.CommentSaver[DeserializedSimpleFunctionDescriptor]

'result' @ [50:30] ==> val result: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.applyTo[LocalVariableDescriptor]

'nameExpr' @ [60:22] ==> value-parameter nameExpr: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.extractData[ValueParameterDescriptorImpl]

'parent' @ [60:31] ==> public final val KtSimpleNameExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'when (parent) {
            is KtCallExpression -> parent.parent as? KtDotQualifiedExpression
            is KtBinaryExpression -> parent
            else -> null
        }' @ [61:27] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: {ASTDelegatePsiElement & KtExpression}?, entry1: {ASTDelegatePsiElement & KtExpression}?, entry2: {ASTDelegatePsiElement & KtExpression}?): {ASTDelegatePsiElement & KtExpression}?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> {ASTDelegatePsiElement & KtExpression}?

'parent' @ [61:33] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.extractData[LocalVariableDescriptor]

'parent' @ [62:36] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.extractData[LocalVariableDescriptor]

'parent' @ [62:43] ==> public final val KtCallExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [63:38] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.extractData[LocalVariableDescriptor]

'expression' @ [67:28] ==> val expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.extractData[LocalVariableDescriptor]

'getResolvedCall' @ [67:39] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'expression' @ [67:55] ==> val expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.extractData[LocalVariableDescriptor]

'analyze' @ [67:66] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'!in' @ [68:13] ==> public abstract fun contains(element: String): Boolean defined in kotlin.collections.Set[DeserializedSimpleFunctionDescriptor]

'getFqName' @ [68:29] ==> @NotNull public open fun getFqName(@NotNull p0: DeclarationDescriptor): FqNameUnsafe defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'resolvedCall' @ [68:39] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.extractData[LocalVariableDescriptor]

'resultingDescriptor' @ [68:52] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.resultingDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'toString' @ [68:73] ==> @NotNull public open fun toString(): String defined in org.jetbrains.kotlin.name.FqNameUnsafe[JavaMethodDescriptor]

'FOR_EACH_FQ_NAMES' @ [68:88] ==> private final val FOR_EACH_FQ_NAMES: Set<String> defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention[PropertyDescriptorImpl]

'resolvedCall' @ [70:24] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.extractData[LocalVariableDescriptor]

'call' @ [70:37] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'explicitReceiver' @ [70:42] ==> public final val Call.explicitReceiver: Receiver?[MyPropertyDescriptor]

'resolvedCall' @ [71:24] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.extractData[LocalVariableDescriptor]

'call' @ [71:37] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'valueArguments' @ [71:42] ==> public final val Call.valueArguments: List<(ValueArgument..ValueArgument?)>[MyPropertyDescriptor]

'singleOrNull' @ [71:57] ==> public fun <T> List<(ValueArgument..ValueArgument?)>.singleOrNull(): ValueArgument? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)

'argument' @ [72:31] ==> val argument: ValueArgument defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.extractData[LocalVariableDescriptor]

'getArgumentExpression' @ [72:40] ==> @IfNotParsed public abstract fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.ValueArgument[DeserializedSimpleFunctionDescriptor]

'Data' @ [73:16] ==> public constructor Data(expressionToReplace: KtExpression, receiver: KtExpression, functionLiteral: KtLambdaExpression) defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.Data[ClassConstructorDescriptorImpl]

'expression' @ [73:21] ==> val expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.extractData[LocalVariableDescriptor]

'receiver' @ [73:33] ==> val receiver: ExpressionReceiver defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.extractData[LocalVariableDescriptor]

'expression' @ [73:42] ==> public abstract val expression: KtExpression defined in org.jetbrains.kotlin.resolve.scopes.receivers.ExpressionReceiver[DeserializedPropertyDescriptor]

'functionLiteral' @ [73:54] ==> val functionLiteral: KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.extractData[LocalVariableDescriptor]

'KtPsiFactory' @ [77:23] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'functionLiteral' @ [77:36] ==> value-parameter functionLiteral: KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.generateLoop[ValueParameterDescriptorImpl]

'safeDeparenthesize' @ [78:35] ==> @NotNull public open fun safeDeparenthesize(@NotNull p0: KtExpression): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'receiver' @ [78:54] ==> value-parameter receiver: KtExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.generateLoop[ValueParameterDescriptorImpl]

'functionLiteral' @ [79:20] ==> value-parameter functionLiteral: KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.generateLoop[ValueParameterDescriptorImpl]

'bodyExpression' @ [79:36] ==> public final val KtLambdaExpression.bodyExpression: KtBlockExpression?[MyPropertyDescriptor]

'functionLiteral' @ [80:25] ==> value-parameter functionLiteral: KtLambdaExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.generateLoop[ValueParameterDescriptorImpl]

'valueParameters' @ [80:41] ==> public final val KtLambdaExpression.valueParameters: (MutableList<(KtParameter..KtParameter?)>..List<(KtParameter..KtParameter?)>)[MyPropertyDescriptor]

'singleOrNull' @ [80:57] ==> public fun <T> List<(KtParameter..KtParameter?)>.singleOrNull(): KtParameter? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtParameter..org.jetbrains.kotlin.psi.KtParameter?)

'factory' @ [81:16] ==> val factory: KtPsiFactory defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.generateLoop[LocalVariableDescriptor]

'createExpressionByPattern' @ [81:24] ==> public fun KtPsiFactory.createExpressionByPattern(pattern: String, vararg args: Any, reformat: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'parameter' @ [81:73] ==> val parameter: KtParameter? defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.generateLoop[LocalVariableDescriptor]

'loopRange' @ [81:92] ==> val loopRange: KtExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.generateLoop[LocalVariableDescriptor]

'body' @ [81:103] ==> val body: KtBlockExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertForEachToForLoopIntention.generateLoop[LocalVariableDescriptor]

