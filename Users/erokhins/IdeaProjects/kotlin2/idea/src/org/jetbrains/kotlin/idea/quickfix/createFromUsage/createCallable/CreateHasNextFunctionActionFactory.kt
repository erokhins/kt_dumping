'CreateCallableMemberFromUsageFactory<KtForExpression>' @ [31:45] ==> public constructor CreateCallableMemberFromUsageFactory<E : KtElement>(extensionsSupported: Boolean = ...) defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createCallable.CreateCallableMemberFromUsageFactory[ClassConstructorDescriptorImpl]
Inferred types:
    <E : KtElement> -> KtForExpression

'getParentElementOfType' @ [33:29] ==> @Nullable public open fun <T : (PsiElement..PsiElement?)> getParentElementOfType(p0: (Diagnostic..Diagnostic?), p1: (Class<(KtForExpression..KtForExpression?)>..Class<(KtForExpression..KtForExpression?)>?)): KtForExpression? defined in org.jetbrains.kotlin.idea.core.quickfix.QuickFixUtil[JavaMethodDescriptor]
Inferred types:
    <T : (PsiElement..PsiElement?)> -> KtForExpression

'diagnostic' @ [33:52] ==> value-parameter diagnostic: Diagnostic defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createCallable.CreateHasNextFunctionActionFactory.getElementOfInterest[ValueParameterDescriptorImpl]

'KtForExpression' @ [33:64] ==> public constructor KtForExpression(@NotNull p0: ASTNode) defined in org.jetbrains.kotlin.psi.KtForExpression[JavaClassConstructorDescriptor]

'java' @ [33:87] ==> public val <T> KClass<KtForExpression>.java: Class<KtForExpression> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtForExpression

'cast' @ [38:35] ==> @NotNull public open fun <D : (Diagnostic..Diagnostic?)> cast(@NotNull p0: Diagnostic, @NotNull vararg p1: (DiagnosticFactory<out (DiagnosticWithParameters1<(KtExpression..KtExpression?), (KotlinType..KotlinType?)>..DiagnosticWithParameters1<(KtExpression..KtExpression?), (KotlinType..KotlinType?)>?)>..DiagnosticFactory<out (DiagnosticWithParameters1<(KtExpression..KtExpression?), (KotlinType..KotlinType?)>..DiagnosticWithParameters1<(KtExpression..KtExpression?), (KotlinType..KotlinType?)>?)>?)): DiagnosticWithParameters1<(KtExpression..KtExpression?), (KotlinType..KotlinType?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory[JavaMethodDescriptor]
Inferred types:
    <D : (Diagnostic..Diagnostic?)> -> DiagnosticWithParameters1<(org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?), (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)>

'diagnostic' @ [38:40] ==> value-parameter diagnostic: Diagnostic defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createCallable.CreateHasNextFunctionActionFactory.createCallableInfo[ValueParameterDescriptorImpl]

'HAS_NEXT_MISSING' @ [38:59] ==> public final val HAS_NEXT_MISSING: (DiagnosticFactory1<(KtExpression..KtExpression?), (KotlinType..KotlinType?)>..DiagnosticFactory1<(KtExpression..KtExpression?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'HAS_NEXT_FUNCTION_NONE_APPLICABLE' @ [38:84] ==> public final val HAS_NEXT_FUNCTION_NONE_APPLICABLE: (DiagnosticFactory1<(KtExpression..KtExpression?), (KotlinType..KotlinType?)>..DiagnosticFactory1<(KtExpression..KtExpression?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'TypeInfo' @ [39:25] ==> public fun TypeInfo(theType: KotlinType, variance: Variance): TypeInfo defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.callableBuilder in file CallableInfo.kt[SimpleFunctionDescriptorImpl]

'diagnosticWithParameters' @ [39:34] ==> val diagnosticWithParameters: DiagnosticWithParameters1<(KtExpression..KtExpression?), (KotlinType..KotlinType?)> defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createCallable.CreateHasNextFunctionActionFactory.createCallableInfo[LocalVariableDescriptor]

'a' @ [39:59] ==> public final val <E : (PsiElement..PsiElement?), A : (Any..Any?)> DiagnosticWithParameters1<(KtExpression..KtExpression?), (KotlinType..KotlinType?)>.a: (KotlinType..KotlinType?)[MyPropertyDescriptor]
Inferred types:
    <E : (PsiElement..PsiElement?)> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)
    <A : (Any..Any?)> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)

'IN_VARIANCE' @ [39:71] ==> enum entry IN_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'TypeInfo' @ [40:26] ==> public fun TypeInfo(theType: KotlinType, variance: Variance): TypeInfo defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.callableBuilder in file CallableInfo.kt[SimpleFunctionDescriptorImpl]

'element' @ [40:35] ==> value-parameter element: KtForExpression defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createCallable.CreateHasNextFunctionActionFactory.createCallableInfo[ValueParameterDescriptorImpl]

'builtIns' @ [40:43] ==> public val KtElement.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.idea.project[DeserializedPropertyDescriptor]

'booleanType' @ [40:52] ==> public final val KotlinBuiltIns.booleanType: SimpleType[MyPropertyDescriptor]

'OUT_VARIANCE' @ [40:74] ==> enum entry OUT_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'FunctionInfo' @ [41:16] ==> public constructor FunctionInfo(name: String, receiverTypeInfo: TypeInfo, returnTypeInfo: TypeInfo, possibleContainers: List<KtElement> = ..., parameterInfos: List<ParameterInfo> = ..., typeParameterInfos: List<TypeInfo> = ..., isOperator: Boolean = ..., isInfix: Boolean = ..., isAbstract: Boolean = ...) defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.callableBuilder.FunctionInfo[ClassConstructorDescriptorImpl]

'OperatorNameConventions' @ [41:29] ==> public object OperatorNameConventions defined in org.jetbrains.kotlin.util[FakeCallableDescriptorForObject]

'HAS_NEXT' @ [41:53] ==> @field:JvmField public final val HAS_NEXT: Name defined in org.jetbrains.kotlin.util.OperatorNameConventions[DeserializedPropertyDescriptor]

'asString' @ [41:62] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'ownerType' @ [41:74] ==> val ownerType: TypeInfo defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createCallable.CreateHasNextFunctionActionFactory.createCallableInfo[LocalVariableDescriptor]

'returnType' @ [41:85] ==> val returnType: TypeInfo defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createCallable.CreateHasNextFunctionActionFactory.createCallableInfo[LocalVariableDescriptor]

