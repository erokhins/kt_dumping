'SelfTargetingIntention<KtProperty>' @ [52:44] ==> public constructor SelfTargetingIntention<TElement : PsiElement>(elementType: Class<KtProperty>, text: String, familyName: String = ...) defined in org.jetbrains.kotlin.idea.intentions.SelfTargetingIntention[DeserializedClassConstructorDescriptor]
Inferred types:
    <TElement : PsiElement> -> KtProperty

'java' @ [52:97] ==> public val <T> KClass<KtProperty>.java: Class<KtProperty> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtProperty

'CallableRefactoring<CallableDescriptor>' @ [56:8] ==> public constructor CallableRefactoring<out T : CallableDescriptor>(project: Project, callableDescriptor: CallableDescriptor, commandName: String) defined in org.jetbrains.kotlin.idea.refactoring.CallableRefactoring[ClassConstructorDescriptorImpl]
Inferred types:
    <out T : CallableDescriptor> -> CallableDescriptor

'project' @ [56:48] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.<init>[ValueParameterDescriptorImpl]

'descriptor' @ [56:57] ==> value-parameter descriptor: CallableDescriptor defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.<init>[ValueParameterDescriptorImpl]

'text' @ [56:69] ==> public final var ConvertPropertyToFunctionIntention.text: String[MyPropertyDescriptor]

'getterName' @ [57:46] ==> @NotNull public open fun getterName(@NotNull p0: String): String defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaMethodDescriptor]

'callableDescriptor' @ [57:57] ==> @Suppress public final val callableDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter[PropertyDescriptorImpl]

'name' @ [57:76] ==> public final val CallableDescriptor.name: Name[MyPropertyDescriptor]

'asString' @ [57:81] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'originalProperty' @ [60:28] ==> value-parameter originalProperty: KtProperty defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty[ValueParameterDescriptorImpl]

'copy' @ [60:45] ==> public open fun copy(): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtProperty[JavaMethodDescriptor]

'property' @ [61:26] ==> val property: KtProperty defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty[LocalVariableDescriptor]

'getter' @ [61:35] ==> public final val KtProperty.getter: KtPropertyAccessor?[MyPropertyDescriptor]

'psiFactory' @ [63:34] ==> value-parameter psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty[ValueParameterDescriptorImpl]

'createFunction' @ [63:45] ==> public final fun createFunction(funDecl: String): KtNamedFunction defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'property' @ [65:13] ==> val property: KtProperty defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty[LocalVariableDescriptor]

'valOrVarKeyword' @ [65:22] ==> public final val KtProperty.valOrVarKeyword: PsiElement[MyPropertyDescriptor]

'replace' @ [65:38] ==> public abstract fun replace(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'sampleFunction' @ [65:46] ==> val sampleFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty[LocalVariableDescriptor]

'funKeyword' @ [65:61] ==> public final val KtNamedFunction.funKeyword: PsiElement?[MyPropertyDescriptor]

'property' @ [66:13] ==> val property: KtProperty defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty[LocalVariableDescriptor]

'addAfter' @ [66:22] ==> public open fun addAfter(@NotNull p0: PsiElement, p1: PsiElement?): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtProperty[JavaMethodDescriptor]

'psiFactory' @ [66:31] ==> value-parameter psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty[ValueParameterDescriptorImpl]

'createParameterList' @ [66:42] ==> public final fun createParameterList(text: String): KtParameterList defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'property' @ [66:69] ==> val property: KtProperty defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty[LocalVariableDescriptor]

'nameIdentifier' @ [66:78] ==> public final val KtProperty.nameIdentifier: PsiElement?[MyPropertyDescriptor]

'property' @ [67:17] ==> val property: KtProperty defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty[LocalVariableDescriptor]

'initializer' @ [67:26] ==> public final var KtProperty.initializer: KtExpression?[MyPropertyDescriptor]

'getter' @ [68:21] ==> val getter: KtPropertyAccessor? defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty[LocalVariableDescriptor]

'getter' @ [69:41] ==> val getter: KtPropertyAccessor? defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty[LocalVariableDescriptor]

'equalsToken' @ [69:48] ==> public final val KtPropertyAccessor.equalsToken: PsiElement?[MyPropertyDescriptor]

'getter' @ [69:63] ==> val getter: KtPropertyAccessor? defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty[LocalVariableDescriptor]

'bodyExpression' @ [69:70] ==> public final val KtPropertyAccessor.bodyExpression: KtExpression?[MyPropertyDescriptor]

'siblings' @ [70:31] ==> public fun PsiElement.siblings(forward: Boolean = ..., withItself: Boolean = ...): Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'firstOrNull' @ [71:31] ==> public inline fun <T> Sequence<PsiElement>.firstOrNull(predicate: (PsiElement) -> Boolean): PsiElement? defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'it' @ [71:45] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty.<anonymous>[ValueParameterDescriptorImpl]

'getter' @ [72:21] ==> val getter: KtPropertyAccessor? defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty[LocalVariableDescriptor]

'deleteChildRange' @ [72:28] ==> public open fun deleteChildRange(p0: (PsiElement..PsiElement?), p1: (PsiElement..PsiElement?)): Unit defined in org.jetbrains.kotlin.psi.KtPropertyAccessor[JavaMethodDescriptor]

'getter' @ [72:45] ==> val getter: KtPropertyAccessor? defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty[LocalVariableDescriptor]

'firstChild' @ [72:52] ==> public final val KtPropertyAccessor.firstChild: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'dropGetterTo' @ [72:64] ==> val dropGetterTo: PsiElement? defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty[LocalVariableDescriptor]

'getter' @ [74:44] ==> val getter: KtPropertyAccessor? defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty[LocalVariableDescriptor]

'siblings' @ [75:30] ==> public fun PsiElement.siblings(forward: Boolean = ..., withItself: Boolean = ...): Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'first' @ [76:30] ==> public inline fun <T> Sequence<PsiElement>.first(predicate: (PsiElement) -> Boolean): PsiElement defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'it' @ [76:38] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty.<anonymous>[ValueParameterDescriptorImpl]

'nextSibling' @ [77:30] ==> public final val PsiElement.nextSibling: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'property' @ [78:21] ==> val property: KtProperty defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty[LocalVariableDescriptor]

'deleteChildRange' @ [78:30] ==> public open fun deleteChildRange(p0: (PsiElement..PsiElement?), p1: (PsiElement..PsiElement?)): Unit defined in org.jetbrains.kotlin.psi.KtProperty[JavaMethodDescriptor]

'dropPropertyFrom' @ [78:47] ==> val dropPropertyFrom: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty[LocalVariableDescriptor]

'getter' @ [78:65] ==> val getter: KtPropertyAccessor? defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty[LocalVariableDescriptor]

'prevSibling' @ [78:72] ==> public final val KtPropertyAccessor.prevSibling: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'property' @ [81:13] ==> val property: KtProperty defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty[LocalVariableDescriptor]

'setName' @ [81:22] ==> public open fun setName(@NonNls @NotNull p0: String): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtProperty[JavaMethodDescriptor]

'newName' @ [81:30] ==> private final val newName: String defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter[PropertyDescriptorImpl]

'originalProperty' @ [83:13] ==> value-parameter originalProperty: KtProperty defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty[ValueParameterDescriptorImpl]

'replace' @ [83:30] ==> public open fun replace(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtProperty[JavaMethodDescriptor]

'psiFactory' @ [83:38] ==> value-parameter psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty[ValueParameterDescriptorImpl]

'createFunction' @ [83:49] ==> public final fun createFunction(funDecl: String): KtNamedFunction defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'property' @ [83:64] ==> val property: KtProperty defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.convertProperty[LocalVariableDescriptor]

'text' @ [83:73] ==> public final val KtProperty.text: (String..String?)[MyPropertyDescriptor]

'callableDescriptor' @ [87:32] ==> @Suppress public final val callableDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter[PropertyDescriptorImpl]

'name' @ [87:51] ==> public final val CallableDescriptor.name: Name[MyPropertyDescriptor]

'asString' @ [87:56] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'propertyName' @ [88:31] ==> val propertyName: String defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring[LocalVariableDescriptor]

'newName' @ [88:47] ==> private final val newName: String defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter[PropertyDescriptorImpl]

'getterName' @ [89:37] ==> @NotNull public open fun getterName(@NotNull p0: String): String defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaMethodDescriptor]

'callableDescriptor' @ [89:48] ==> @Suppress public final val callableDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter[PropertyDescriptorImpl]

'name' @ [89:67] ==> public final val CallableDescriptor.name: Name[MyPropertyDescriptor]

'asString' @ [89:72] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'MultiMap' @ [90:29] ==> public constructor MultiMap<K : (Any..Any?), V : (Any..Any?)>() defined in com.intellij.util.containers.MultiMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> PsiElement
    <V : (Any..Any?)> -> String

'getAffectedCallables' @ [91:29] ==> public fun getAffectedCallables(project: Project, descriptorsForChange: Collection<CallableDescriptor>): List<PsiElement> defined in org.jetbrains.kotlin.idea.refactoring in file CallableRefactoring.kt[SimpleFunctionDescriptorImpl]

'project' @ [91:50] ==> public final val project: Project defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter[PropertyDescriptorImpl]

'descriptorsForChange' @ [91:59] ==> value-parameter descriptorsForChange: Collection<CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring[ValueParameterDescriptorImpl]

'ArrayList' @ [92:47] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> KtSimpleNameExpression

'ArrayList' @ [93:32] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> PsiReference

'ArrayList' @ [94:45] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> PsiReferenceExpression

'project' @ [96:13] ==> public final val project: Project defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter[PropertyDescriptorImpl]

'runSynchronouslyWithProgress' @ [96:21] ==> public fun <T : Any> Project.runSynchronouslyWithProgress(progressTitle: String, canBeCanceled: Boolean, action: () -> Unit): Unit? defined in org.jetbrains.kotlin.idea[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> Unit

'runReadAction' @ [97:17] ==> public fun <T> runReadAction(action: () -> Unit): Unit defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Unit

'/' @ [98:40] ==> public final operator fun div(other: Int): Double defined in kotlin.Double[DeserializedSimpleFunctionDescriptor]

'callables' @ [98:44] ==> val callables: List<PsiElement> defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring[LocalVariableDescriptor]

'size' @ [98:54] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'component1' @ [99:27] ==> public final operator fun component1(): Int defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'component2' @ [99:30] ==> public final operator fun component2(): PsiElement defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'callables' @ [99:43] ==> val callables: List<PsiElement> defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring[LocalVariableDescriptor]

'withIndex' @ [99:53] ==> public fun <T> Iterable<PsiElement>.withIndex(): Iterable<IndexedValue<PsiElement>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'getInstance' @ [100:41] ==> @NotNull public open fun getInstance(): ProgressManager defined in com.intellij.openapi.progress.ProgressManager[JavaMethodDescriptor]

'progressIndicator' @ [100:55] ==> public final val ProgressManager.progressIndicator: (ProgressIndicator..ProgressIndicator?)[MyPropertyDescriptor]

'fraction' @ [100:73] ==> public final var ProgressIndicator.fraction: Double[MyPropertyDescriptor]

'*' @ [100:84] ==> public final operator fun times(other: Double): Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'i' @ [100:85] ==> val i: Int defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'progressStep' @ [100:92] ==> val progressStep: Double defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'callable' @ [102:29] ==> val callable: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'!' @ [104:29] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'checkModifiable' @ [104:30] ==> protected final fun checkModifiable(element: PsiElement): Boolean defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter[SimpleFunctionDescriptorImpl]

'callable' @ [104:46] ==> val callable: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'getDescription' @ [105:70] ==> public open fun getDescription(@NotNull p0: PsiElement, p1: Boolean): (String..String?) defined in com.intellij.refactoring.util.RefactoringUIUtil[JavaMethodDescriptor]

'callable' @ [105:85] ==> val callable: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'capitalize' @ [105:101] ==> public fun String.capitalize(): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'conflicts' @ [106:29] ==> val conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring[LocalVariableDescriptor]

'putValue' @ [106:39] ==> public open fun putValue(@Nullable p0: PsiElement?, p1: (String..String?)): Unit defined in com.intellij.util.containers.MultiMap[JavaMethodDescriptor]

'callable' @ [106:48] ==> val callable: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'renderedCallable' @ [106:73] ==> val renderedCallable: String defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'if (callable is KtProperty) {
                            callableDescriptor.getContainingScope()
                                    ?.findFunction(callableDescriptor.name, NoLookupLocation.FROM_IDE) { it.valueParameters.isEmpty() }
                                    ?.let { DescriptorToSourceUtilsIde.getAnyDeclaration(project, it) }
                                    ?.let { reportDeclarationConflict(conflicts, it) { "$it already exists" } }
                        }
                        else if (callable is PsiMethod) {
                            callable.containingClass
                                    ?.findMethodsByName(propertyName, true)
                                    // as is necessary here: see KT-10386
                                    ?.firstOrNull { it.parameterList.parametersCount == 0 && !callables.contains(it.namedUnwrappedElement as PsiElement?) }
                                    ?.let { reportDeclarationConflict(conflicts, it) { "$it already exists" } }
                        }' @ [109:25] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit?, elseBranch: Unit?): Unit?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit?

'callable' @ [109:29] ==> val callable: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'callableDescriptor' @ [110:29] ==> @Suppress public final val callableDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter[PropertyDescriptorImpl]

'getContainingScope' @ [110:48] ==> public fun DeclarationDescriptor.getContainingScope(): LexicalScope? defined in org.jetbrains.kotlin.idea.refactoring in file CallableRefactoring.kt[SimpleFunctionDescriptorImpl]

'findFunction' @ [111:39] ==> public fun HierarchicalScope.findFunction(name: Name, location: LookupLocation, predicate: (FunctionDescriptor) -> Boolean = ...): FunctionDescriptor? defined in org.jetbrains.kotlin.resolve.scopes.utils[DeserializedSimpleFunctionDescriptor]

'callableDescriptor' @ [111:52] ==> @Suppress public final val callableDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter[PropertyDescriptorImpl]

'name' @ [111:71] ==> public final val CallableDescriptor.name: Name[MyPropertyDescriptor]

'FROM_IDE' @ [111:94] ==> enum entry FROM_IDE defined in org.jetbrains.kotlin.incremental.components.NoLookupLocation[FakeCallableDescriptorForObject]

'it' @ [111:106] ==> value-parameter it: FunctionDescriptor defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'valueParameters' @ [111:109] ==> public final val FunctionDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'isEmpty' @ [111:125] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'let' @ [112:39] ==> @InlineOnly public inline fun <T, R> FunctionDescriptor.let(block: (FunctionDescriptor) -> PsiElement?): PsiElement? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FunctionDescriptor
    <R> -> PsiElement?

'DescriptorToSourceUtilsIde' @ [112:45] ==> public object DescriptorToSourceUtilsIde defined in org.jetbrains.kotlin.idea.codeInsight[FakeCallableDescriptorForObject]

'getAnyDeclaration' @ [112:72] ==> public final fun getAnyDeclaration(project: Project, descriptor: DeclarationDescriptor): PsiElement? defined in org.jetbrains.kotlin.idea.codeInsight.DescriptorToSourceUtilsIde[DeserializedSimpleFunctionDescriptor]

'project' @ [112:90] ==> public final val project: Project defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter[PropertyDescriptorImpl]

'it' @ [112:99] ==> value-parameter it: FunctionDescriptor defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'let' @ [113:39] ==> @InlineOnly public inline fun <T, R> PsiElement.let(block: (PsiElement) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement
    <R> -> Unit

'reportDeclarationConflict' @ [113:45] ==> public fun reportDeclarationConflict(conflicts: MultiMap<PsiElement, String>, declaration: PsiElement, message: (renderedDeclaration: String) -> String): Unit defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'conflicts' @ [113:71] ==> val conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring[LocalVariableDescriptor]

'it' @ [113:82] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [113:90] ==> value-parameter it: String defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'callable' @ [115:34] ==> val callable: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'callable' @ [116:29] ==> val callable: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'containingClass' @ [116:38] ==> public final val PsiMethod.containingClass: PsiClass?[MyPropertyDescriptor]

'findMethodsByName' @ [117:39] ==> @NotNull public abstract fun findMethodsByName(@NonNls p0: (String..String?), p1: Boolean): (Array<(PsiMethod..PsiMethod?)>..Array<out (PsiMethod..PsiMethod?)>) defined in com.intellij.psi.PsiClass[JavaMethodDescriptor]

'propertyName' @ [117:57] ==> val propertyName: String defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring[LocalVariableDescriptor]

'firstOrNull' @ [119:39] ==> public inline fun <T> Array<out (PsiMethod..PsiMethod?)>.firstOrNull(predicate: ((PsiMethod..PsiMethod?)) -> Boolean): PsiMethod? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiMethod..com.intellij.psi.PsiMethod?)

'it' @ [119:53] ==> value-parameter it: (PsiMethod..PsiMethod?) defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'parameterList' @ [119:56] ==> public final val PsiMethod.parameterList: PsiParameterList[MyPropertyDescriptor]

'parametersCount' @ [119:70] ==> public final val PsiParameterList.parametersCount: Int[MyPropertyDescriptor]

'!' @ [119:94] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'callables' @ [119:95] ==> val callables: List<PsiElement> defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring[LocalVariableDescriptor]

'contains' @ [119:105] ==> public operator fun <@OnlyInputTypes T> Iterable<PsiElement?>.contains(element: PsiElement?): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <@OnlyInputTypes T> -> PsiElement?

'it' @ [119:114] ==> value-parameter it: (PsiMethod..PsiMethod?) defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'namedUnwrappedElement' @ [119:117] ==> public val PsiElement.namedUnwrappedElement: PsiNamedElement? defined in org.jetbrains.kotlin.asJava[DeserializedPropertyDescriptor]

'let' @ [120:39] ==> @InlineOnly public inline fun <T, R> PsiMethod.let(block: (PsiMethod) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiMethod
    <R> -> Unit

'reportDeclarationConflict' @ [120:45] ==> public fun reportDeclarationConflict(conflicts: MultiMap<PsiElement, String>, declaration: PsiElement, message: (renderedDeclaration: String) -> String): Unit defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'conflicts' @ [120:71] ==> val conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring[LocalVariableDescriptor]

'it' @ [120:82] ==> value-parameter it: PsiMethod defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [120:90] ==> value-parameter it: String defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'search' @ [123:55] ==> @NotNull public open fun search(@NotNull p0: PsiElement): Query<(PsiReference..PsiReference?)> defined in com.intellij.psi.search.searches.ReferencesSearch[JavaMethodDescriptor]

'callable' @ [123:62] ==> val callable: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'usages' @ [124:39] ==> val usages: Query<(PsiReference..PsiReference?)> defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'usage' @ [125:33] ==> val usage: (PsiReference..PsiReference?) defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'if (usage is KtSimpleNameReference) {
                                    val expression = usage.expression
                                    if (expression.getCall(expression.analyze(BodyResolveMode.PARTIAL)) != null
                                        && expression.getStrictParentOfType<KtCallableReferenceExpression>() == null) {
                                        kotlinRefsToReplaceWithCall.add(expression)
                                    }
                                    else if (nameChanged) {
                                        refsToRename.add(usage)
                                    }
                                }
                                else {
                                    val refElement = usage.element
                                    conflicts.putValue(
                                            refElement,
                                            "Unrecognized reference will be skipped: " + StringUtil.htmlEmphasize(refElement.text)
                                    )
                                }' @ [126:33] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any, elseBranch: Any): Any[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any

'usage' @ [126:37] ==> val usage: (PsiReference..PsiReference?) defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'usage' @ [127:54] ==> val usage: (PsiReference..PsiReference?) defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'expression' @ [127:60] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[DeserializedPropertyDescriptor]

'if (expression.getCall(expression.analyze(BodyResolveMode.PARTIAL)) != null
                                        && expression.getStrictParentOfType<KtCallableReferenceExpression>() == null) {
                                        kotlinRefsToReplaceWithCall.add(expression)
                                    }
                                    else if (nameChanged) {
                                        refsToRename.add(usage)
                                    }' @ [128:37] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any, elseBranch: Any): Any[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any

'expression' @ [128:41] ==> val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'getCall' @ [128:52] ==> public fun KtElement.getCall(context: BindingContext): Call? defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'expression' @ [128:60] ==> val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'analyze' @ [128:71] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'PARTIAL' @ [128:95] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'expression' @ [129:44] ==> val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'getStrictParentOfType' @ [129:55] ==> public inline fun <reified T : PsiElement> PsiElement.getStrictParentOfType(): KtCallableReferenceExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtCallableReferenceExpression

'kotlinRefsToReplaceWithCall' @ [130:41] ==> val kotlinRefsToReplaceWithCall: ArrayList<KtSimpleNameExpression> defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring[LocalVariableDescriptor]

'add' @ [130:69] ==> public open fun add(element: KtSimpleNameExpression): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'expression' @ [130:73] ==> val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'nameChanged' @ [132:46] ==> val nameChanged: Boolean defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring[LocalVariableDescriptor]

'refsToRename' @ [133:41] ==> val refsToRename: ArrayList<PsiReference> defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring[LocalVariableDescriptor]

'add' @ [133:54] ==> public open fun add(element: PsiReference): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'usage' @ [133:58] ==> val usage: (PsiReference..PsiReference?) defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'usage' @ [137:54] ==> val usage: (PsiReference..PsiReference?) defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'element' @ [137:60] ==> public final val KtReference.element: KtElement[MyPropertyDescriptor]

'conflicts' @ [138:37] ==> val conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring[LocalVariableDescriptor]

'putValue' @ [138:47] ==> public open fun putValue(@Nullable p0: PsiElement?, p1: (String..String?)): Unit defined in com.intellij.util.containers.MultiMap[JavaMethodDescriptor]

'refElement' @ [139:45] ==> val refElement: KtElement defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'+' @ [140:45] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'htmlEmphasize' @ [140:101] ==> @NotNull @Contract public open fun htmlEmphasize(@NotNull p0: String): String defined in com.intellij.openapi.util.text.StringUtil[JavaMethodDescriptor]

'refElement' @ [140:115] ==> val refElement: KtElement defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'text' @ [140:126] ==> public final val KtElement.text: (String..String?)[MyPropertyDescriptor]

'usage' @ [146:46] ==> val usage: (PsiReference..PsiReference?) defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'element' @ [146:52] ==> public final val PsiReference.element: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'refElement' @ [148:33] ==> val refElement: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'text' @ [148:44] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'endsWith' @ [148:49] ==> public fun String.endsWith(suffix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'getterName' @ [148:58] ==> val getterName: String defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring[LocalVariableDescriptor]

'usage' @ [150:33] ==> val usage: (PsiReference..PsiReference?) defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'usage' @ [151:37] ==> val usage: (PsiReference..PsiReference?) defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'resolve' @ [151:43] ==> @Nullable public abstract fun resolve(): PsiElement? defined in com.intellij.psi.PsiReference[JavaMethodDescriptor]

'usage' @ [151:68] ==> val usage: (PsiReference..PsiReference?) defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'javaRefsToReplaceWithCall' @ [152:37] ==> val javaRefsToReplaceWithCall: ArrayList<PsiReferenceExpression> defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring[LocalVariableDescriptor]

'add' @ [152:63] ==> public open fun add(element: PsiReferenceExpression): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'usage' @ [152:67] ==> val usage: (PsiReference..PsiReference?) defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'conflicts' @ [157:29] ==> val conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring[LocalVariableDescriptor]

'putValue' @ [157:39] ==> public open fun putValue(@Nullable p0: PsiElement?, p1: (String..String?)): Unit defined in com.intellij.util.containers.MultiMap[JavaMethodDescriptor]

'refElement' @ [158:37] ==> val refElement: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'+' @ [159:37] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'htmlEmphasize' @ [159:107] ==> @NotNull @Contract public open fun htmlEmphasize(@NotNull p0: String): String defined in com.intellij.openapi.util.text.StringUtil[JavaMethodDescriptor]

'refElement' @ [159:121] ==> val refElement: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'text' @ [159:132] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'project' @ [166:13] ==> public final val project: Project defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter[PropertyDescriptorImpl]

'checkConflictsInteractively' @ [166:21] ==> public fun Project.checkConflictsInteractively(conflicts: MultiMap<PsiElement, String>, onShowConflicts: () -> Unit = ..., onAccept: () -> Unit): Unit defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'conflicts' @ [166:49] ==> val conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring[LocalVariableDescriptor]

'project' @ [167:17] ==> public final val project: Project defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter[PropertyDescriptorImpl]

'executeWriteCommand' @ [167:25] ==> public fun Project.executeWriteCommand(name: String, command: () -> Unit): Unit defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]

'text' @ [167:45] ==> public final var ConvertPropertyToFunctionIntention.text: String[MyPropertyDescriptor]

'KtPsiFactory' @ [168:44] ==> @JvmOverloads public constructor KtPsiFactory(project: Project, markGenerated: Boolean = ...) defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedClassConstructorDescriptor]

'project' @ [168:57] ==> public final val project: Project defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter[PropertyDescriptorImpl]

'getInstance' @ [169:68] ==> public open fun getInstance(p0: (Project..Project?)): (PsiElementFactory..PsiElementFactory?) defined in com.intellij.psi.PsiElementFactory.SERVICE[JavaMethodDescriptor]

'project' @ [169:80] ==> public final val project: Project defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter[PropertyDescriptorImpl]

'kotlinPsiFactory' @ [170:45] ==> val kotlinPsiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'createExpression' @ [170:62] ==> public final fun createExpression(text: String): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'newName' @ [170:81] ==> private final val newName: String defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter[PropertyDescriptorImpl]

'kotlinRefsToReplaceWithCall' @ [172:21] ==> val kotlinRefsToReplaceWithCall: ArrayList<KtSimpleNameExpression> defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring[LocalVariableDescriptor]

'forEach' @ [172:49] ==> @HidesMembers public inline fun <T> Iterable<KtSimpleNameExpression>.forEach(action: (KtSimpleNameExpression) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtSimpleNameExpression

'it' @ [172:59] ==> value-parameter it: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'replace' @ [172:62] ==> public abstract fun replace(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[JavaMethodDescriptor]

'newKotlinCallExpr' @ [172:70] ==> val newKotlinCallExpr: KtExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'refsToRename' @ [173:21] ==> val refsToRename: ArrayList<PsiReference> defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring[LocalVariableDescriptor]

'forEach' @ [173:34] ==> @HidesMembers public inline fun <T> Iterable<PsiReference>.forEach(action: (PsiReference) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiReference

'it' @ [173:44] ==> value-parameter it: PsiReference defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'handleElementRename' @ [173:47] ==> public abstract fun handleElementRename(p0: (String..String?)): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiReference[JavaMethodDescriptor]

'newName' @ [173:67] ==> private final val newName: String defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter[PropertyDescriptorImpl]

'javaRefsToReplaceWithCall' @ [174:21] ==> val javaRefsToReplaceWithCall: ArrayList<PsiReferenceExpression> defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring[LocalVariableDescriptor]

'forEach' @ [174:47] ==> @HidesMembers public inline fun <T> Iterable<PsiReferenceExpression>.forEach(action: (PsiReferenceExpression) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiReferenceExpression

'it' @ [175:41] ==> value-parameter it: PsiReferenceExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'handleElementRename' @ [175:44] ==> public abstract fun handleElementRename(p0: (String..String?)): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiReferenceExpression[JavaMethodDescriptor]

'newName' @ [175:64] ==> private final val newName: String defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter[PropertyDescriptorImpl]

'getterRef' @ [176:25] ==> val getterRef: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>.<anonymous>[LocalVariableDescriptor]

'replace' @ [176:35] ==> public abstract fun replace(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'javaPsiFactory' @ [176:43] ==> val javaPsiFactory: (PsiElementFactory..PsiElementFactory?) defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'createExpressionFromText' @ [176:58] ==> @NotNull public abstract fun createExpressionFromText(@NotNull p0: String, @Nullable p1: PsiElement?): PsiExpression defined in com.intellij.psi.PsiElementFactory[JavaMethodDescriptor]

'getterRef' @ [176:86] ==> val getterRef: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>.<anonymous>[LocalVariableDescriptor]

'text' @ [176:96] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'callables' @ [178:21] ==> val callables: List<PsiElement> defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring[LocalVariableDescriptor]

'forEach' @ [178:31] ==> @HidesMembers public inline fun <T> Iterable<PsiElement>.forEach(action: (PsiElement) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'when (it) {
                            is KtProperty -> convertProperty(it, kotlinPsiFactory)
                            is PsiMethod -> it.name = newName
                        }' @ [179:25] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'it' @ [179:31] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'convertProperty' @ [180:46] ==> private final fun convertProperty(originalProperty: KtProperty, psiFactory: KtPsiFactory): Unit defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter[SimpleFunctionDescriptorImpl]

'it' @ [180:62] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'kotlinPsiFactory' @ [180:66] ==> val kotlinPsiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'it' @ [181:45] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter.performRefactoring.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [181:48] ==> public final var PsiMethod.name: String[MyPropertyDescriptor]

'newName' @ [181:55] ==> private final val newName: String defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter[PropertyDescriptorImpl]

'element' @ [192:26] ==> value-parameter element: KtProperty defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.isApplicableTo[ValueParameterDescriptorImpl]

'nameIdentifier' @ [192:34] ==> public final val KtProperty.nameIdentifier: PsiElement?[MyPropertyDescriptor]

'!' @ [193:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'identifier' @ [193:14] ==> val identifier: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.isApplicableTo[LocalVariableDescriptor]

'textRange' @ [193:25] ==> public final val PsiElement.textRange: (TextRange..TextRange?)[MyPropertyDescriptor]

'containsOffset' @ [193:35] ==> public open fun containsOffset(p0: Int): Boolean defined in com.intellij.openapi.util.TextRange[JavaMethodDescriptor]

'caretOffset' @ [193:50] ==> value-parameter caretOffset: Int defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.isApplicableTo[ValueParameterDescriptorImpl]

'element' @ [194:16] ==> value-parameter element: KtProperty defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.isApplicableTo[ValueParameterDescriptorImpl]

'delegate' @ [194:24] ==> public final val KtProperty.delegate: KtPropertyDelegate?[MyPropertyDescriptor]

'!' @ [194:44] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'element' @ [194:45] ==> value-parameter element: KtProperty defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.isApplicableTo[ValueParameterDescriptorImpl]

'isVar' @ [194:53] ==> public final val KtProperty.isVar: Boolean[MyPropertyDescriptor]

'!' @ [194:62] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'element' @ [194:63] ==> value-parameter element: KtProperty defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.isApplicableTo[ValueParameterDescriptorImpl]

'isLocal' @ [194:71] ==> public final val KtProperty.isLocal: Boolean[MyPropertyDescriptor]

'element' @ [198:23] ==> value-parameter element: KtProperty defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.applyTo[ValueParameterDescriptorImpl]

'analyze' @ [198:31] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'context' @ [199:26] ==> val context: BindingContext defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.applyTo[LocalVariableDescriptor]

'DECLARATION_TO_DESCRIPTOR' @ [199:49] ==> public final val DECLARATION_TO_DESCRIPTOR: (ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'element' @ [199:76] ==> value-parameter element: KtProperty defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.applyTo[ValueParameterDescriptorImpl]

'Converter' @ [200:9] ==> public constructor Converter(project: Project, descriptor: CallableDescriptor) defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter[ClassConstructorDescriptorImpl]

'element' @ [200:19] ==> value-parameter element: KtProperty defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.applyTo[ValueParameterDescriptorImpl]

'project' @ [200:27] ==> public final val KtProperty.project: Project[MyPropertyDescriptor]

'descriptor' @ [200:36] ==> val descriptor: CallableDescriptor defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.applyTo[LocalVariableDescriptor]

'run' @ [200:48] ==> public final fun run(): Boolean defined in org.jetbrains.kotlin.idea.intentions.ConvertPropertyToFunctionIntention.Converter[SimpleFunctionDescriptorImpl]

