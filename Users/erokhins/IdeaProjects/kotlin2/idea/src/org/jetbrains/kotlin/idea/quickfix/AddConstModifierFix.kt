'AddModifierFix' @ [47:55] ==> public constructor AddModifierFix(element: KtModifierListOwner, modifier: KtModifierKeywordToken) defined in org.jetbrains.kotlin.idea.quickfix.AddModifierFix[ClassConstructorDescriptorImpl]

'property' @ [47:70] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierFix.<init>[ValueParameterDescriptorImpl]

'CONST_KEYWORD' @ [47:89] ==> public final val CONST_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'addConstModifier' @ [49:9] ==> public final fun addConstModifier(property: KtProperty): Unit defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierFix.Companion[SimpleFunctionDescriptorImpl]

'property' @ [49:26] ==> public final val property: KtProperty defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierFix[PropertyDescriptorImpl]

'listOf' @ [53:41] ==> public fun <T> listOf(vararg elements: FqName): List<FqName> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FqName

'FqName' @ [53:48] ==> public constructor FqName(@NotNull p0: String) defined in org.jetbrains.kotlin.name.FqName[JavaClassConstructorDescriptor]

'FqName' @ [53:80] ==> public constructor FqName(@NotNull p0: String) defined in org.jetbrains.kotlin.name.FqName[JavaClassConstructorDescriptor]

'replaceReferencesToGetterByReferenceToField' @ [56:13] ==> public fun replaceReferencesToGetterByReferenceToField(property: KtProperty): Unit defined in org.jetbrains.kotlin.idea.quickfix in file AddConstModifierFix.kt[SimpleFunctionDescriptorImpl]

'property' @ [56:57] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierFix.Companion.addConstModifier[ValueParameterDescriptorImpl]

'property' @ [57:13] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierFix.Companion.addConstModifier[ValueParameterDescriptorImpl]

'addModifier' @ [57:22] ==> public open fun addModifier(@NotNull p0: KtModifierKeywordToken): Unit defined in org.jetbrains.kotlin.psi.KtProperty[JavaMethodDescriptor]

'CONST_KEYWORD' @ [57:43] ==> public final val CONST_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'removeAnnotations' @ [58:13] ==> private final val removeAnnotations: List<FqName> defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierFix.Companion[PropertyDescriptorImpl]

'mapNotNull' @ [58:31] ==> public inline fun <T, R : Any> Iterable<FqName>.mapNotNull(transform: (FqName) -> KtAnnotationEntry?): List<KtAnnotationEntry> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FqName
    <R : Any> -> KtAnnotationEntry

'property' @ [58:44] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierFix.Companion.addConstModifier[ValueParameterDescriptorImpl]

'findAnnotation' @ [58:53] ==> public fun KtAnnotated.findAnnotation(annotationFqName: FqName): KtAnnotationEntry? defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'it' @ [58:68] ==> value-parameter it: FqName defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierFix.Companion.addConstModifier.<anonymous>[ValueParameterDescriptorImpl]

'forEach' @ [58:74] ==> @HidesMembers public inline fun <T> Iterable<KtAnnotationEntry>.forEach(action: (KtAnnotationEntry) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtAnnotationEntry

'delete' @ [58:101] ==> public open fun delete(): Unit defined in org.jetbrains.kotlin.psi.KtAnnotationEntry[JavaMethodDescriptor]

'SelfTargetingIntention<KtProperty>' @ [63:35] ==> public constructor SelfTargetingIntention<TElement : PsiElement>(elementType: Class<KtProperty>, text: String, familyName: String = ...) defined in org.jetbrains.kotlin.idea.intentions.SelfTargetingIntention[DeserializedClassConstructorDescriptor]
Inferred types:
    <TElement : PsiElement> -> KtProperty

'java' @ [63:88] ==> public val <T> KClass<KtProperty>.java: Class<KtProperty> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtProperty

'AddConstModifierFix' @ [65:9] ==> public companion object defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierFix[FakeCallableDescriptorForObject]

'addConstModifier' @ [65:29] ==> public final fun addConstModifier(property: KtProperty): Unit defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierFix.Companion[SimpleFunctionDescriptorImpl]

'element' @ [65:46] ==> value-parameter element: KtProperty defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierIntention.applyTo[ValueParameterDescriptorImpl]

'isApplicableTo' @ [69:16] ==> public final fun isApplicableTo(element: KtProperty): Boolean defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierIntention.Companion[SimpleFunctionDescriptorImpl]

'element' @ [69:31] ==> value-parameter element: KtProperty defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierIntention.isApplicableTo[ValueParameterDescriptorImpl]

'element' @ [74:17] ==> value-parameter element: KtProperty defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierIntention.Companion.isApplicableTo[ValueParameterDescriptorImpl]

'isLocal' @ [74:25] ==> public final val KtProperty.isLocal: Boolean[MyPropertyDescriptor]

'element' @ [74:36] ==> value-parameter element: KtProperty defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierIntention.Companion.isApplicableTo[ValueParameterDescriptorImpl]

'isVar' @ [74:44] ==> public final val KtProperty.isVar: Boolean[MyPropertyDescriptor]

'element' @ [74:53] ==> value-parameter element: KtProperty defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierIntention.Companion.isApplicableTo[ValueParameterDescriptorImpl]

'hasDelegate' @ [74:61] ==> public open fun hasDelegate(): Boolean defined in org.jetbrains.kotlin.psi.KtProperty[JavaMethodDescriptor]

'element' @ [74:78] ==> value-parameter element: KtProperty defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierIntention.Companion.isApplicableTo[ValueParameterDescriptorImpl]

'initializer' @ [74:86] ==> public final var KtProperty.initializer: KtExpression?[MyPropertyDescriptor]

'element' @ [75:20] ==> value-parameter element: KtProperty defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierIntention.Companion.isApplicableTo[ValueParameterDescriptorImpl]

'getter' @ [75:28] ==> public final val KtProperty.getter: KtPropertyAccessor?[MyPropertyDescriptor]

'hasBody' @ [75:36] ==> public open fun hasBody(): Boolean defined in org.jetbrains.kotlin.psi.KtPropertyAccessor[JavaMethodDescriptor]

'element' @ [75:57] ==> value-parameter element: KtProperty defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierIntention.Companion.isApplicableTo[ValueParameterDescriptorImpl]

'receiverTypeReference' @ [75:65] ==> public final val KtProperty.receiverTypeReference: KtTypeReference?[MyPropertyDescriptor]

'element' @ [76:20] ==> value-parameter element: KtProperty defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierIntention.Companion.isApplicableTo[ValueParameterDescriptorImpl]

'hasModifier' @ [76:28] ==> public open fun hasModifier(@NotNull p0: KtModifierKeywordToken): Boolean defined in org.jetbrains.kotlin.psi.KtProperty[JavaMethodDescriptor]

'CONST_KEYWORD' @ [76:49] ==> public final val CONST_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'element' @ [76:67] ==> value-parameter element: KtProperty defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierIntention.Companion.isApplicableTo[ValueParameterDescriptorImpl]

'hasModifier' @ [76:75] ==> public open fun hasModifier(@NotNull p0: KtModifierKeywordToken): Boolean defined in org.jetbrains.kotlin.psi.KtProperty[JavaMethodDescriptor]

'OVERRIDE_KEYWORD' @ [76:96] ==> public final val OVERRIDE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'element' @ [79:38] ==> value-parameter element: KtProperty defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierIntention.Companion.isApplicableTo[ValueParameterDescriptorImpl]

'descriptor' @ [79:46] ==> public val KtDeclaration.descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.search.usagesSearch[DeserializedPropertyDescriptor]

'ConstModifierChecker' @ [80:20] ==> public object ConstModifierChecker : SimpleDeclarationChecker defined in org.jetbrains.kotlin.resolve.checkers[FakeCallableDescriptorForObject]

'canBeConst' @ [80:41] ==> public final fun canBeConst(declaration: KtDeclaration, constModifierPsiElement: PsiElement, descriptor: VariableDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker[DeserializedSimpleFunctionDescriptor]

'element' @ [80:52] ==> value-parameter element: KtProperty defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierIntention.Companion.isApplicableTo[ValueParameterDescriptorImpl]

'element' @ [80:61] ==> value-parameter element: KtProperty defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierIntention.Companion.isApplicableTo[ValueParameterDescriptorImpl]

'propertyDescriptor' @ [80:70] ==> val propertyDescriptor: VariableDescriptor defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierIntention.Companion.isApplicableTo[LocalVariableDescriptor]

'KotlinSingleIntentionActionFactory' @ [86:26] ==> public constructor KotlinSingleIntentionActionFactory() defined in org.jetbrains.kotlin.idea.quickfix.KotlinSingleIntentionActionFactory[ClassConstructorDescriptorImpl]

'diagnostic' @ [88:20] ==> value-parameter diagnostic: Diagnostic defined in org.jetbrains.kotlin.idea.quickfix.ConstFixFactory.createAction[ValueParameterDescriptorImpl]

'psiElement' @ [88:31] ==> public final val Diagnostic.psiElement: PsiElement[MyPropertyDescriptor]

'expr' @ [89:30] ==> val expr: KtReferenceExpression defined in org.jetbrains.kotlin.idea.quickfix.ConstFixFactory.createAction[LocalVariableDescriptor]

'analyze' @ [89:35] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'PARTIAL' @ [89:59] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'bindingContext' @ [90:32] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.quickfix.ConstFixFactory.createAction[LocalVariableDescriptor]

'get' @ [90:47] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(p0: (ReadOnlySlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?), p1: (KtReferenceExpression..KtReferenceExpression?)): DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtReferenceExpression..org.jetbrains.kotlin.psi.KtReferenceExpression?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.descriptors.DeclarationDescriptor..org.jetbrains.kotlin.descriptors.DeclarationDescriptor?)

'REFERENCE_TARGET' @ [90:66] ==> public final val REFERENCE_TARGET: (WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'expr' @ [90:84] ==> val expr: KtReferenceExpression defined in org.jetbrains.kotlin.idea.quickfix.ConstFixFactory.createAction[LocalVariableDescriptor]

'?:' @ [91:27] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtProperty?, right: KtProperty): KtProperty[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtProperty

'targetDescriptor' @ [91:28] ==> val targetDescriptor: VariableDescriptor defined in org.jetbrains.kotlin.idea.quickfix.ConstFixFactory.createAction[LocalVariableDescriptor]

'source' @ [91:45] ==> public final val VariableDescriptor.source: SourceElement[MyPropertyDescriptor]

'psi' @ [91:75] ==> public abstract val psi: PsiElement? defined in org.jetbrains.kotlin.resolve.source.PsiSourceElement[DeserializedPropertyDescriptor]

'ConstModifierChecker' @ [92:13] ==> public object ConstModifierChecker : SimpleDeclarationChecker defined in org.jetbrains.kotlin.resolve.checkers[FakeCallableDescriptorForObject]

'canBeConst' @ [92:34] ==> public final fun canBeConst(declaration: KtDeclaration, constModifierPsiElement: PsiElement, descriptor: VariableDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker[DeserializedSimpleFunctionDescriptor]

'declaration' @ [92:45] ==> val declaration: KtProperty defined in org.jetbrains.kotlin.idea.quickfix.ConstFixFactory.createAction[LocalVariableDescriptor]

'declaration' @ [92:58] ==> val declaration: KtProperty defined in org.jetbrains.kotlin.idea.quickfix.ConstFixFactory.createAction[LocalVariableDescriptor]

'targetDescriptor' @ [92:71] ==> val targetDescriptor: VariableDescriptor defined in org.jetbrains.kotlin.idea.quickfix.ConstFixFactory.createAction[LocalVariableDescriptor]

'AddConstModifierFix' @ [93:20] ==> public constructor AddConstModifierFix(property: KtProperty) defined in org.jetbrains.kotlin.idea.quickfix.AddConstModifierFix[ClassConstructorDescriptorImpl]

'declaration' @ [93:40] ==> val declaration: KtProperty defined in org.jetbrains.kotlin.idea.quickfix.ConstFixFactory.createAction[LocalVariableDescriptor]

'property' @ [100:19] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.idea.quickfix.replaceReferencesToGetterByReferenceToField[ValueParameterDescriptorImpl]

'project' @ [100:28] ==> public final val KtProperty.project: Project[MyPropertyDescriptor]

'LightClassUtil' @ [101:18] ==> public object LightClassUtil defined in org.jetbrains.kotlin.asJava[FakeCallableDescriptorForObject]

'getLightClassPropertyMethods' @ [101:33] ==> public final fun getLightClassPropertyMethods(property: KtProperty): LightClassUtil.PropertyAccessorsPsiMethods defined in org.jetbrains.kotlin.asJava.LightClassUtil[DeserializedSimpleFunctionDescriptor]

'property' @ [101:62] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.idea.quickfix.replaceReferencesToGetterByReferenceToField[ValueParameterDescriptorImpl]

'getter' @ [101:72] ==> public final val getter: PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil.PropertyAccessorsPsiMethods[DeserializedPropertyDescriptor]

'getScopeRestrictedByFileTypes' @ [103:39] ==> @NotNull @Contract public open fun getScopeRestrictedByFileTypes(@NotNull p0: GlobalSearchScope, @NotNull vararg p1: (FileType..FileType?)): GlobalSearchScope defined in com.intellij.psi.search.GlobalSearchScope[JavaMethodDescriptor]

'project' @ [103:69] ==> val project: Project defined in org.jetbrains.kotlin.idea.quickfix.replaceReferencesToGetterByReferenceToField[LocalVariableDescriptor]

'allScope' @ [103:77] ==> public fun Project.allScope(): GlobalSearchScope defined in org.jetbrains.kotlin.idea.search[DeserializedSimpleFunctionDescriptor]

'INSTANCE' @ [103:102] ==> public final val INSTANCE: (JavaFileType..JavaFileType?) defined in com.intellij.ide.highlighter.JavaFileType[JavaPropertyDescriptor]

'if (getter != null)
        ReferencesSearch.search(getter, javaScope).findAll()
    else
        emptyList()' @ [104:24] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (MutableCollection<(PsiReference..PsiReference?)>..Collection<(PsiReference..PsiReference?)>), elseBranch: (MutableCollection<(PsiReference..PsiReference?)>..Collection<(PsiReference..PsiReference?)>)): (MutableCollection<(PsiReference..PsiReference?)>..Collection<(PsiReference..PsiReference?)>)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (kotlin.collections.MutableCollection<(com.intellij.psi.PsiReference..com.intellij.psi.PsiReference?)>..kotlin.collections.Collection<(com.intellij.psi.PsiReference..com.intellij.psi.PsiReference?)>)

'getter' @ [104:28] ==> val getter: PsiMethod? defined in org.jetbrains.kotlin.idea.quickfix.replaceReferencesToGetterByReferenceToField[LocalVariableDescriptor]

'search' @ [105:26] ==> @NotNull public open fun search(@NotNull p0: PsiElement, @NotNull p1: SearchScope): Query<(PsiReference..PsiReference?)> defined in com.intellij.psi.search.searches.ReferencesSearch[JavaMethodDescriptor]

'getter' @ [105:33] ==> val getter: PsiMethod? defined in org.jetbrains.kotlin.idea.quickfix.replaceReferencesToGetterByReferenceToField[LocalVariableDescriptor]

'javaScope' @ [105:41] ==> val javaScope: GlobalSearchScope defined in org.jetbrains.kotlin.idea.quickfix.replaceReferencesToGetterByReferenceToField[LocalVariableDescriptor]

'findAll' @ [105:52] ==> @NotNull public abstract fun findAll(): (MutableCollection<(PsiReference..PsiReference?)>..Collection<(PsiReference..PsiReference?)>) defined in com.intellij.util.Query[JavaMethodDescriptor]

'emptyList' @ [107:9] ==> public fun <T> emptyList(): List<(PsiReference..PsiReference?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiReference..com.intellij.psi.PsiReference?)

'LightClassUtil' @ [109:24] ==> public object LightClassUtil defined in org.jetbrains.kotlin.asJava[FakeCallableDescriptorForObject]

'getLightClassPropertyMethods' @ [109:39] ==> public final fun getLightClassPropertyMethods(property: KtProperty): LightClassUtil.PropertyAccessorsPsiMethods defined in org.jetbrains.kotlin.asJava.LightClassUtil[DeserializedSimpleFunctionDescriptor]

'property' @ [109:68] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.idea.quickfix.replaceReferencesToGetterByReferenceToField[ValueParameterDescriptorImpl]

'backingField' @ [109:78] ==> public final val backingField: PsiField? defined in org.jetbrains.kotlin.asJava.LightClassUtil.PropertyAccessorsPsiMethods[DeserializedPropertyDescriptor]

'backingField' @ [110:9] ==> val backingField: PsiField? defined in org.jetbrains.kotlin.idea.quickfix.replaceReferencesToGetterByReferenceToField[LocalVariableDescriptor]

'getInstance' @ [111:49] ==> public open fun getInstance(p0: (Project..Project?)): (PsiElementFactory..PsiElementFactory?) defined in com.intellij.psi.PsiElementFactory.SERVICE[JavaMethodDescriptor]

'project' @ [111:61] ==> val project: Project defined in org.jetbrains.kotlin.idea.quickfix.replaceReferencesToGetterByReferenceToField[LocalVariableDescriptor]

'backingField' @ [112:27] ==> val backingField: PsiField? defined in org.jetbrains.kotlin.idea.quickfix.replaceReferencesToGetterByReferenceToField[LocalVariableDescriptor]

'containingClass' @ [112:40] ==> public final val PsiField.containingClass: PsiClass?[MyPropertyDescriptor]

'qualifiedName' @ [112:58] ==> public final val PsiClass.qualifiedName: String?[MyPropertyDescriptor]

'backingField' @ [112:80] ==> val backingField: PsiField? defined in org.jetbrains.kotlin.idea.quickfix.replaceReferencesToGetterByReferenceToField[LocalVariableDescriptor]

'name' @ [112:93] ==> public final val PsiField.name: String?[MyPropertyDescriptor]

'getterUsages' @ [114:9] ==> val getterUsages: (MutableCollection<(PsiReference..PsiReference?)>..Collection<(PsiReference..PsiReference?)>) defined in org.jetbrains.kotlin.idea.quickfix.replaceReferencesToGetterByReferenceToField[LocalVariableDescriptor]

'forEach' @ [114:22] ==> @HidesMembers public inline fun <T> Iterable<(PsiReference..PsiReference?)>.forEach(action: ((PsiReference..PsiReference?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiReference..com.intellij.psi.PsiReference?)

'it' @ [115:24] ==> value-parameter it: (PsiReference..PsiReference?) defined in org.jetbrains.kotlin.idea.quickfix.replaceReferencesToGetterByReferenceToField.<anonymous>[ValueParameterDescriptorImpl]

'element' @ [115:27] ==> public final val PsiReference.element: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'getNonStrictParentOfType' @ [115:35] ==> public inline fun <reified T : PsiElement> PsiElement.getNonStrictParentOfType(): PsiMethodCallExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> PsiMethodCallExpression

'call' @ [116:17] ==> val call: PsiMethodCallExpression? defined in org.jetbrains.kotlin.idea.quickfix.replaceReferencesToGetterByReferenceToField.<anonymous>[LocalVariableDescriptor]

'it' @ [116:33] ==> value-parameter it: (PsiReference..PsiReference?) defined in org.jetbrains.kotlin.idea.quickfix.replaceReferencesToGetterByReferenceToField.<anonymous>[ValueParameterDescriptorImpl]

'element' @ [116:36] ==> public final val PsiReference.element: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'call' @ [116:47] ==> val call: PsiMethodCallExpression? defined in org.jetbrains.kotlin.idea.quickfix.replaceReferencesToGetterByReferenceToField.<anonymous>[LocalVariableDescriptor]

'methodExpression' @ [116:52] ==> public final val PsiMethodCallExpression.methodExpression: PsiReferenceExpression[MyPropertyDescriptor]

'factory' @ [117:32] ==> val factory: (PsiElementFactory..PsiElementFactory?) defined in org.jetbrains.kotlin.idea.quickfix.replaceReferencesToGetterByReferenceToField[LocalVariableDescriptor]

'createExpressionFromText' @ [117:40] ==> @NotNull public abstract fun createExpressionFromText(@NotNull p0: String, @Nullable p1: PsiElement?): PsiExpression defined in com.intellij.psi.PsiElementFactory[JavaMethodDescriptor]

'fieldFQName' @ [117:65] ==> val fieldFQName: String defined in org.jetbrains.kotlin.idea.quickfix.replaceReferencesToGetterByReferenceToField[LocalVariableDescriptor]

'it' @ [117:78] ==> value-parameter it: (PsiReference..PsiReference?) defined in org.jetbrains.kotlin.idea.quickfix.replaceReferencesToGetterByReferenceToField.<anonymous>[ValueParameterDescriptorImpl]

'element' @ [117:81] ==> public final val PsiReference.element: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'call' @ [118:17] ==> val call: PsiMethodCallExpression? defined in org.jetbrains.kotlin.idea.quickfix.replaceReferencesToGetterByReferenceToField.<anonymous>[LocalVariableDescriptor]

'replace' @ [118:22] ==> public abstract fun replace(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiMethodCallExpression[JavaMethodDescriptor]

'fieldRef' @ [118:30] ==> val fieldRef: PsiExpression defined in org.jetbrains.kotlin.idea.quickfix.replaceReferencesToGetterByReferenceToField.<anonymous>[LocalVariableDescriptor]

