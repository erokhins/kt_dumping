'getInstance' @ [40:26] ==> @NotNull public open fun getInstance(@NotNull p0: raw (Class<(Any..Any?)>..Class<*>)): Logger defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'KotlinClassWithDelegatedPropertyRenderer' @ [40:38] ==> public constructor KotlinClassWithDelegatedPropertyRenderer(rendererSettings: NodeRendererSettings) defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer[ClassConstructorDescriptorImpl]

'java' @ [40:86] ==> public val <T> KClass<KotlinClassWithDelegatedPropertyRenderer>.java: Class<KotlinClassWithDelegatedPropertyRenderer> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KotlinClassWithDelegatedPropertyRenderer

'referenceType' @ [42:7] ==> value-parameter referenceType: ReferenceType defined in org.jetbrains.kotlin.idea.debugger.render.notPreparedClassMessage[ValueParameterDescriptorImpl]

'referenceType' @ [42:23] ==> value-parameter referenceType: ReferenceType defined in org.jetbrains.kotlin.idea.debugger.render.notPreparedClassMessage[ValueParameterDescriptorImpl]

'isPrepared' @ [42:37] ==> public final val ReferenceType.isPrepared: Boolean[MyPropertyDescriptor]

'referenceType' @ [42:51] ==> value-parameter referenceType: ReferenceType defined in org.jetbrains.kotlin.idea.debugger.render.notPreparedClassMessage[ValueParameterDescriptorImpl]

'sourceName' @ [42:65] ==> public abstract fun sourceName(): (String..String?) defined in com.sun.jdi.ReferenceType[JavaMethodDescriptor]

'ClassRenderer' @ [44:102] ==> public constructor ClassRenderer() defined in com.intellij.debugger.ui.tree.render.ClassRenderer[JavaClassConstructorDescriptor]

'!' @ [46:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'super' @ [46:14] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer[LazyClassReceiverParameterDescriptor]

'isApplicable' @ [46:20] ==> public open fun isApplicable(p0: (Type..Type?)): Boolean defined in com.intellij.debugger.ui.tree.render.ClassRenderer[JavaMethodDescriptor]

'jdiType' @ [46:33] ==> value-parameter jdiType: Type? defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.isApplicable[ValueParameterDescriptorImpl]

'jdiType' @ [48:13] ==> value-parameter jdiType: Type? defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.isApplicable[ValueParameterDescriptorImpl]

'!' @ [50:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'jdiType' @ [50:14] ==> value-parameter jdiType: Type? defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.isApplicable[ValueParameterDescriptorImpl]

'isPrepared' @ [50:22] ==> public final val ReferenceType.isPrepared: Boolean[MyPropertyDescriptor]

'LOG' @ [51:13] ==> private val LOG: Logger defined in org.jetbrains.kotlin.idea.debugger.render in file KotlinClassWithDelegatedPropertyRenderer.kt[PropertyDescriptorImpl]

'info' @ [51:17] ==> public abstract fun info(@NonNls p0: (String..String?)): Unit defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'notPreparedClassMessage' @ [51:22] ==> private fun notPreparedClassMessage(referenceType: ReferenceType): String defined in org.jetbrains.kotlin.idea.debugger.render in file KotlinClassWithDelegatedPropertyRenderer.kt[SimpleFunctionDescriptorImpl]

'jdiType' @ [51:46] ==> value-parameter jdiType: Type? defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.isApplicable[ValueParameterDescriptorImpl]

'jdiType' @ [56:20] ==> value-parameter jdiType: Type? defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.isApplicable[ValueParameterDescriptorImpl]

'allFields' @ [56:28] ==> public abstract fun allFields(): (MutableList<(Field..Field?)>..List<(Field..Field?)>?) defined in com.sun.jdi.ReferenceType[JavaMethodDescriptor]

'any' @ [56:40] ==> public inline fun <T> Iterable<(Field..Field?)>.any(predicate: ((Field..Field?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.sun.jdi.Field..com.sun.jdi.Field?)

'it' @ [56:46] ==> value-parameter it: (Field..Field?) defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.isApplicable.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [56:49] ==> public abstract fun name(): (String..String?) defined in com.sun.jdi.Field[JavaMethodDescriptor]

'endsWith' @ [56:56] ==> public fun String.endsWith(suffix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'DELEGATED_PROPERTY_NAME_SUFFIX' @ [56:72] ==> public const final val DELEGATED_PROPERTY_NAME_SUFFIX: String defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaPropertyDescriptor]

'LOG' @ [59:13] ==> private val LOG: Logger defined in org.jetbrains.kotlin.idea.debugger.render in file KotlinClassWithDelegatedPropertyRenderer.kt[PropertyDescriptorImpl]

'error' @ [59:17] ==> public open fun error(@NonNls p0: (String..String?), @Nullable p1: Throwable?): Unit defined in com.intellij.openapi.diagnostic.Logger[JavaMethodDescriptor]

'notPreparedClassMessage' @ [59:23] ==> private fun notPreparedClassMessage(referenceType: ReferenceType): String defined in org.jetbrains.kotlin.idea.debugger.render in file KotlinClassWithDelegatedPropertyRenderer.kt[SimpleFunctionDescriptorImpl]

'jdiType' @ [59:47] ==> value-parameter jdiType: Type? defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.isApplicable[ValueParameterDescriptorImpl]

'notPrepared' @ [59:57] ==> val notPrepared: ClassNotPreparedException defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.isApplicable[LocalVariableDescriptor]

'calcToStringLabel' @ [68:19] ==> private final fun calcToStringLabel(descriptor: ValueDescriptor, evaluationContext: EvaluationContext, listener: DescriptorLabelListener): String? defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer[SimpleFunctionDescriptorImpl]

'descriptor' @ [68:37] ==> value-parameter descriptor: ValueDescriptor defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.calcLabel[ValueParameterDescriptorImpl]

'evaluationContext' @ [68:49] ==> value-parameter evaluationContext: EvaluationContext defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.calcLabel[ValueParameterDescriptorImpl]

'listener' @ [68:68] ==> value-parameter listener: DescriptorLabelListener defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.calcLabel[ValueParameterDescriptorImpl]

'res' @ [69:13] ==> val res: String? defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.calcLabel[LocalVariableDescriptor]

'res' @ [70:20] ==> val res: String? defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.calcLabel[LocalVariableDescriptor]

'super' @ [73:16] ==> <this> defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer[LazyClassReceiverParameterDescriptor]

'calcLabel' @ [73:22] ==> public open fun calcLabel(p0: (ValueDescriptor..ValueDescriptor?), p1: (EvaluationContext..EvaluationContext?), p2: (DescriptorLabelListener..DescriptorLabelListener?)): (String..String?) defined in com.intellij.debugger.ui.tree.render.ClassRenderer[JavaMethodDescriptor]

'descriptor' @ [73:32] ==> value-parameter descriptor: ValueDescriptor defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.calcLabel[ValueParameterDescriptorImpl]

'evaluationContext' @ [73:44] ==> value-parameter evaluationContext: EvaluationContext defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.calcLabel[ValueParameterDescriptorImpl]

'listener' @ [73:63] ==> value-parameter listener: DescriptorLabelListener defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.calcLabel[ValueParameterDescriptorImpl]

'rendererSettings' @ [78:32] ==> private final val rendererSettings: NodeRendererSettings defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer[PropertyDescriptorImpl]

'toStringRenderer' @ [78:49] ==> public final val NodeRendererSettings.toStringRenderer: (ToStringRenderer..ToStringRenderer?)[MyPropertyDescriptor]

'toStringRenderer' @ [79:13] ==> val toStringRenderer: (ToStringRenderer..ToStringRenderer?) defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.calcToStringLabel[LocalVariableDescriptor]

'isEnabled' @ [79:30] ==> public final var ToStringRenderer.isEnabled: Boolean[MyPropertyDescriptor]

'getInstanceEx' @ [79:61] ==> public open fun getInstanceEx(p0: (Project..Project?)): (DebuggerManagerEx..DebuggerManagerEx?) defined in com.intellij.debugger.DebuggerManagerEx[JavaMethodDescriptor]

'evaluationContext' @ [79:75] ==> value-parameter evaluationContext: EvaluationContext defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.calcToStringLabel[ValueParameterDescriptorImpl]

'project' @ [79:93] ==> public final val EvaluationContext.project: (Project..Project?)[MyPropertyDescriptor]

'context' @ [79:102] ==> public final val DebuggerManagerEx.context: DebuggerContextImpl[MyPropertyDescriptor]

'isEvaluationPossible' @ [79:110] ==> public final val DebuggerContextImpl.isEvaluationPossible: Boolean[MyPropertyDescriptor]

'toStringRenderer' @ [80:17] ==> val toStringRenderer: (ToStringRenderer..ToStringRenderer?) defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.calcToStringLabel[LocalVariableDescriptor]

'isApplicable' @ [80:34] ==> public open fun isApplicable(p0: (Type..Type?)): Boolean defined in com.intellij.debugger.ui.tree.render.ToStringRenderer[JavaMethodDescriptor]

'descriptor' @ [80:47] ==> value-parameter descriptor: ValueDescriptor defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.calcToStringLabel[ValueParameterDescriptorImpl]

'type' @ [80:58] ==> public final val ValueDescriptor.type: Type?[MyPropertyDescriptor]

'toStringRenderer' @ [81:24] ==> val toStringRenderer: (ToStringRenderer..ToStringRenderer?) defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.calcToStringLabel[LocalVariableDescriptor]

'calcLabel' @ [81:41] ==> public open fun calcLabel(p0: (ValueDescriptor..ValueDescriptor?), p1: (EvaluationContext..EvaluationContext?), p2: (DescriptorLabelListener..DescriptorLabelListener?)): (String..String?) defined in com.intellij.debugger.ui.tree.render.ToStringRenderer[JavaMethodDescriptor]

'descriptor' @ [81:51] ==> value-parameter descriptor: ValueDescriptor defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.calcToStringLabel[ValueParameterDescriptorImpl]

'evaluationContext' @ [81:63] ==> value-parameter evaluationContext: EvaluationContext defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.calcToStringLabel[ValueParameterDescriptorImpl]

'listener' @ [81:82] ==> value-parameter listener: DescriptorLabelListener defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.calcToStringLabel[ValueParameterDescriptorImpl]

'assertIsManagerThread' @ [88:35] ==> public open fun assertIsManagerThread(): Unit defined in com.intellij.debugger.engine.DebuggerManagerThreadImpl[JavaMethodDescriptor]

'value' @ [90:13] ==> value-parameter value: Value? defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[ValueParameterDescriptorImpl]

'builder' @ [92:27] ==> value-parameter builder: ChildrenBuilder defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[ValueParameterDescriptorImpl]

'nodeManager' @ [92:35] ==> public final val ChildrenBuilder.nodeManager: (NodeManager..NodeManager?)[MyPropertyDescriptor]

'builder' @ [93:37] ==> value-parameter builder: ChildrenBuilder defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[ValueParameterDescriptorImpl]

'descriptorManager' @ [93:45] ==> public final val ChildrenBuilder.descriptorManager: (NodeDescriptorFactory..NodeDescriptorFactory?)[MyPropertyDescriptor]

'value' @ [95:22] ==> value-parameter value: Value? defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[ValueParameterDescriptorImpl]

'referenceType' @ [95:28] ==> public abstract fun referenceType(): (ReferenceType..ReferenceType?) defined in com.sun.jdi.ObjectReference[JavaMethodDescriptor]

'allFields' @ [95:44] ==> public abstract fun allFields(): (MutableList<(Field..Field?)>..List<(Field..Field?)>?) defined in com.sun.jdi.ReferenceType[JavaMethodDescriptor]

'fields' @ [96:13] ==> val fields: (MutableList<(Field..Field?)>..List<(Field..Field?)>?) defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[LocalVariableDescriptor]

'isEmpty' @ [96:20] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'builder' @ [97:13] ==> value-parameter builder: ChildrenBuilder defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[ValueParameterDescriptorImpl]

'setChildren' @ [97:21] ==> public abstract fun setChildren(p0: (MutableList<(DebuggerTreeNode..DebuggerTreeNode?)>..List<(DebuggerTreeNode..DebuggerTreeNode?)>?)): Unit defined in com.intellij.debugger.ui.tree.render.ChildrenBuilder[JavaMethodDescriptor]

'listOf' @ [97:33] ==> public fun <T> listOf(element: DebuggerTreeNode): List<DebuggerTreeNode> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DebuggerTreeNode

'nodeManager' @ [97:40] ==> val nodeManager: NodeManager defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[LocalVariableDescriptor]

'createMessageNode' @ [97:52] ==> @NotNull public abstract fun createMessageNode(p0: (String..String?)): DebuggerTreeNode defined in com.intellij.debugger.ui.tree.NodeManager[JavaMethodDescriptor]

'CLASS_HAS_NO_FIELDS' @ [97:88] ==> public final val CLASS_HAS_NO_FIELDS: (MessageDescriptor..MessageDescriptor?) defined in com.intellij.debugger.ui.impl.watch.MessageDescriptor[JavaPropertyDescriptor]

'label' @ [97:108] ==> public final var MessageDescriptor.label: (String..String?)[MyPropertyDescriptor]

'ArrayList' @ [101:24] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> DebuggerTreeNode

'fields' @ [102:23] ==> val fields: (MutableList<(Field..Field?)>..List<(Field..Field?)>?) defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[LocalVariableDescriptor]

'!' @ [103:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'shouldDisplay' @ [103:18] ==> protected/*protected and package*/ open fun shouldDisplay(p0: (EvaluationContext..EvaluationContext?), @NotNull p1: ObjectReference, @NotNull p2: Field): Boolean defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer[JavaMethodDescriptor]

'context' @ [103:32] ==> value-parameter context: EvaluationContext defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[ValueParameterDescriptorImpl]

'value' @ [103:41] ==> value-parameter value: Value? defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[ValueParameterDescriptorImpl]

'field' @ [103:48] ==> val field: (Field..Field?) defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[LocalVariableDescriptor]

'nodeDescriptorFactory' @ [107:35] ==> val nodeDescriptorFactory: NodeDescriptorFactory defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[LocalVariableDescriptor]

'getFieldDescriptor' @ [107:57] ==> @NotNull public abstract fun getFieldDescriptor(p0: (NodeDescriptor..NodeDescriptor?), p1: (ObjectReference..ObjectReference?), p2: (Field..Field?)): FieldDescriptor defined in com.intellij.debugger.ui.tree.NodeDescriptorFactory[JavaMethodDescriptor]

'builder' @ [107:76] ==> value-parameter builder: ChildrenBuilder defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[ValueParameterDescriptorImpl]

'parentDescriptor' @ [107:84] ==> public final val ChildrenBuilder.parentDescriptor: (ValueDescriptor..ValueDescriptor?)[MyPropertyDescriptor]

'value' @ [107:102] ==> value-parameter value: Value? defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[ValueParameterDescriptorImpl]

'field' @ [107:109] ==> val field: (Field..Field?) defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[LocalVariableDescriptor]

'if (field.name().endsWith(JvmAbi.DELEGATED_PROPERTY_NAME_SUFFIX)) {
                val shouldRenderDelegatedProperty = KotlinDebuggerSettings.getInstance().DEBUG_RENDER_DELEGATED_PROPERTIES
                if (shouldRenderDelegatedProperty) {
                    children.add(nodeManager.createNode(fieldDescriptor, context))
                }

                val delegatedPropertyDescriptor = DelegatedPropertyFieldDescriptor(
                        context.debugProcess.project!!,
                        value,
                        field,
                        shouldRenderDelegatedProperty)
                children.add(nodeManager.createNode(delegatedPropertyDescriptor, context))
            }
            else {
                children.add(nodeManager.createNode(fieldDescriptor, context))
            }' @ [109:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Boolean, elseBranch: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Boolean

'field' @ [109:17] ==> val field: (Field..Field?) defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[LocalVariableDescriptor]

'name' @ [109:23] ==> public abstract fun name(): (String..String?) defined in com.sun.jdi.Field[JavaMethodDescriptor]

'endsWith' @ [109:30] ==> public fun String.endsWith(suffix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'DELEGATED_PROPERTY_NAME_SUFFIX' @ [109:46] ==> public const final val DELEGATED_PROPERTY_NAME_SUFFIX: String defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaPropertyDescriptor]

'KotlinDebuggerSettings' @ [110:53] ==> public companion object defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings[FakeCallableDescriptorForObject]

'getInstance' @ [110:76] ==> public final fun getInstance(): KotlinDebuggerSettings defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings.Companion[SimpleFunctionDescriptorImpl]

'DEBUG_RENDER_DELEGATED_PROPERTIES' @ [110:90] ==> public final var DEBUG_RENDER_DELEGATED_PROPERTIES: Boolean defined in org.jetbrains.kotlin.idea.debugger.KotlinDebuggerSettings[PropertyDescriptorImpl]

'shouldRenderDelegatedProperty' @ [111:21] ==> val shouldRenderDelegatedProperty: Boolean defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[LocalVariableDescriptor]

'children' @ [112:21] ==> val children: ArrayList<DebuggerTreeNode> defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[LocalVariableDescriptor]

'add' @ [112:30] ==> public open fun add(element: DebuggerTreeNode): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'nodeManager' @ [112:34] ==> val nodeManager: NodeManager defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[LocalVariableDescriptor]

'createNode' @ [112:46] ==> @NotNull public abstract fun createNode(p0: (NodeDescriptor..NodeDescriptor?), p1: (EvaluationContext..EvaluationContext?)): DebuggerTreeNode defined in com.intellij.debugger.ui.tree.NodeManager[JavaMethodDescriptor]

'fieldDescriptor' @ [112:57] ==> val fieldDescriptor: FieldDescriptor defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[LocalVariableDescriptor]

'context' @ [112:74] ==> value-parameter context: EvaluationContext defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[ValueParameterDescriptorImpl]

'DelegatedPropertyFieldDescriptor' @ [115:51] ==> public constructor DelegatedPropertyFieldDescriptor(project: Project, objectRef: ObjectReference, delegate: Field, renderDelegatedProperty: Boolean) defined in org.jetbrains.kotlin.idea.debugger.render.DelegatedPropertyFieldDescriptor[ClassConstructorDescriptorImpl]

'context' @ [116:25] ==> value-parameter context: EvaluationContext defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[ValueParameterDescriptorImpl]

'debugProcess' @ [116:33] ==> public final val EvaluationContext.debugProcess: DebugProcess[MyPropertyDescriptor]

'project' @ [116:46] ==> public final val DebugProcess.project: (Project..Project?)[MyPropertyDescriptor]

'value' @ [117:25] ==> value-parameter value: Value? defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[ValueParameterDescriptorImpl]

'field' @ [118:25] ==> val field: (Field..Field?) defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[LocalVariableDescriptor]

'shouldRenderDelegatedProperty' @ [119:25] ==> val shouldRenderDelegatedProperty: Boolean defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[LocalVariableDescriptor]

'children' @ [120:17] ==> val children: ArrayList<DebuggerTreeNode> defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[LocalVariableDescriptor]

'add' @ [120:26] ==> public open fun add(element: DebuggerTreeNode): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'nodeManager' @ [120:30] ==> val nodeManager: NodeManager defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[LocalVariableDescriptor]

'createNode' @ [120:42] ==> @NotNull public abstract fun createNode(p0: (NodeDescriptor..NodeDescriptor?), p1: (EvaluationContext..EvaluationContext?)): DebuggerTreeNode defined in com.intellij.debugger.ui.tree.NodeManager[JavaMethodDescriptor]

'delegatedPropertyDescriptor' @ [120:53] ==> val delegatedPropertyDescriptor: DelegatedPropertyFieldDescriptor defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[LocalVariableDescriptor]

'context' @ [120:82] ==> value-parameter context: EvaluationContext defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[ValueParameterDescriptorImpl]

'children' @ [123:17] ==> val children: ArrayList<DebuggerTreeNode> defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[LocalVariableDescriptor]

'add' @ [123:26] ==> public open fun add(element: DebuggerTreeNode): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'nodeManager' @ [123:30] ==> val nodeManager: NodeManager defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[LocalVariableDescriptor]

'createNode' @ [123:42] ==> @NotNull public abstract fun createNode(p0: (NodeDescriptor..NodeDescriptor?), p1: (EvaluationContext..EvaluationContext?)): DebuggerTreeNode defined in com.intellij.debugger.ui.tree.NodeManager[JavaMethodDescriptor]

'fieldDescriptor' @ [123:53] ==> val fieldDescriptor: FieldDescriptor defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[LocalVariableDescriptor]

'context' @ [123:70] ==> value-parameter context: EvaluationContext defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[ValueParameterDescriptorImpl]

'!!' @ [127:13] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: XDebuggerSettingsManager?): XDebuggerSettingsManager[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> XDebuggerSettingsManager

'getInstance' @ [127:38] ==> public open fun getInstance(): (XDebuggerSettingsManager..XDebuggerSettingsManager?) defined in com.intellij.xdebugger.settings.XDebuggerSettingsManager[JavaMethodDescriptor]

'dataViewSettings' @ [127:54] ==> public final val XDebuggerSettingsManager.dataViewSettings: XDebuggerSettingsManager.DataViewSettings[MyPropertyDescriptor]

'isSortValues' @ [127:71] ==> public final val XDebuggerSettingsManager.DataViewSettings.isSortValues: Boolean[MyPropertyDescriptor]

'children' @ [128:13] ==> val children: ArrayList<DebuggerTreeNode> defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[LocalVariableDescriptor]

'sortedWith' @ [128:22] ==> public fun <T> Iterable<DebuggerTreeNode>.sortedWith(comparator: Comparator<in DebuggerTreeNode> /* = Comparator<in DebuggerTreeNode> */): List<DebuggerTreeNode> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DebuggerTreeNode

'getNodeComparator' @ [128:49] ==> public open fun getNodeComparator(): (Comparator<(DebuggerTreeNode..DebuggerTreeNode?)>..Comparator<(DebuggerTreeNode..DebuggerTreeNode?)>?) defined in com.intellij.debugger.ui.impl.watch.NodeManagerImpl[JavaMethodDescriptor]

'builder' @ [131:9] ==> value-parameter builder: ChildrenBuilder defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[ValueParameterDescriptorImpl]

'setChildren' @ [131:17] ==> public abstract fun setChildren(p0: (MutableList<(DebuggerTreeNode..DebuggerTreeNode?)>..List<(DebuggerTreeNode..DebuggerTreeNode?)>?)): Unit defined in com.intellij.debugger.ui.tree.render.ChildrenBuilder[JavaMethodDescriptor]

'children' @ [131:29] ==> val children: ArrayList<DebuggerTreeNode> defined in org.jetbrains.kotlin.idea.debugger.render.KotlinClassWithDelegatedPropertyRenderer.buildChildren[LocalVariableDescriptor]

