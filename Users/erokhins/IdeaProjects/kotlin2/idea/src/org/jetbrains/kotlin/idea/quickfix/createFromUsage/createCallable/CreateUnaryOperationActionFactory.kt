'CreateCallableMemberFromUsageFactory<KtUnaryExpression>' @ [28:43] ==> public constructor CreateCallableMemberFromUsageFactory<E : KtElement>(extensionsSupported: Boolean = ...) defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createCallable.CreateCallableMemberFromUsageFactory[ClassConstructorDescriptorImpl]
Inferred types:
    <E : KtElement> -> KtUnaryExpression

'diagnostic' @ [30:16] ==> value-parameter diagnostic: Diagnostic defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createCallable.CreateUnaryOperationActionFactory.getElementOfInterest[ValueParameterDescriptorImpl]

'psiElement' @ [30:27] ==> public final val Diagnostic.psiElement: PsiElement[MyPropertyDescriptor]

'parent' @ [30:38] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'element' @ [34:21] ==> value-parameter element: KtUnaryExpression defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createCallable.CreateUnaryOperationActionFactory.createCallableInfo[ValueParameterDescriptorImpl]

'operationToken' @ [34:29] ==> public final val KtUnaryExpression.operationToken: (IElementType..IElementType?)[MyPropertyDescriptor]

'?:' @ [35:29] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: Name?, right: Name): Name[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> Name

'getNameForOperationSymbol' @ [35:49] ==> @Nullable public open fun getNameForOperationSymbol(@NotNull p0: KtToken, p1: Boolean, p2: Boolean): Name? defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaMethodDescriptor]

'token' @ [35:75] ==> val token: KtToken defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createCallable.CreateUnaryOperationActionFactory.createCallableInfo[LocalVariableDescriptor]

'token' @ [36:22] ==> val token: KtToken defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createCallable.CreateUnaryOperationActionFactory.createCallableInfo[LocalVariableDescriptor]

'INCREMENT_OPERATIONS' @ [36:51] ==> public final val INCREMENT_OPERATIONS: (ImmutableSet<(KtSingleValueToken..KtSingleValueToken?)>..ImmutableSet<(KtSingleValueToken..KtSingleValueToken?)>?) defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaPropertyDescriptor]

'element' @ [38:28] ==> value-parameter element: KtUnaryExpression defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createCallable.CreateUnaryOperationActionFactory.createCallableInfo[ValueParameterDescriptorImpl]

'baseExpression' @ [38:36] ==> public final val KtUnaryExpression.baseExpression: KtExpression?[MyPropertyDescriptor]

'TypeInfo' @ [40:28] ==> public fun TypeInfo(expressionOfType: KtExpression, variance: Variance): TypeInfo defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.callableBuilder in file CallableInfo.kt[SimpleFunctionDescriptorImpl]

'receiverExpr' @ [40:37] ==> val receiverExpr: KtExpression defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createCallable.CreateUnaryOperationActionFactory.createCallableInfo[LocalVariableDescriptor]

'IN_VARIANCE' @ [40:60] ==> enum entry IN_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'if (incDec) TypeInfo.ByReceiverType(Variance.OUT_VARIANCE) else TypeInfo(element, Variance.OUT_VARIANCE)' @ [41:26] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: TypeInfo, elseBranch: TypeInfo): TypeInfo[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> TypeInfo

'incDec' @ [41:30] ==> val incDec: Boolean defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createCallable.CreateUnaryOperationActionFactory.createCallableInfo[LocalVariableDescriptor]

'ByReceiverType' @ [41:47] ==> public constructor ByReceiverType(variance: Variance) defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.callableBuilder.TypeInfo.ByReceiverType[ClassConstructorDescriptorImpl]

'OUT_VARIANCE' @ [41:71] ==> enum entry OUT_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'TypeInfo' @ [41:90] ==> public fun TypeInfo(expressionOfType: KtExpression, variance: Variance): TypeInfo defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.callableBuilder in file CallableInfo.kt[SimpleFunctionDescriptorImpl]

'element' @ [41:99] ==> value-parameter element: KtUnaryExpression defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createCallable.CreateUnaryOperationActionFactory.createCallableInfo[ValueParameterDescriptorImpl]

'OUT_VARIANCE' @ [41:117] ==> enum entry OUT_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'FunctionInfo' @ [42:16] ==> public constructor FunctionInfo(name: String, receiverTypeInfo: TypeInfo, returnTypeInfo: TypeInfo, possibleContainers: List<KtElement> = ..., parameterInfos: List<ParameterInfo> = ..., typeParameterInfos: List<TypeInfo> = ..., isOperator: Boolean = ..., isInfix: Boolean = ..., isAbstract: Boolean = ...) defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.callableBuilder.FunctionInfo[ClassConstructorDescriptorImpl]

'operationName' @ [42:29] ==> val operationName: Name defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createCallable.CreateUnaryOperationActionFactory.createCallableInfo[LocalVariableDescriptor]

'asString' @ [42:43] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'receiverType' @ [42:55] ==> val receiverType: TypeInfo defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createCallable.CreateUnaryOperationActionFactory.createCallableInfo[LocalVariableDescriptor]

'returnType' @ [42:69] ==> val returnType: TypeInfo defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createCallable.CreateUnaryOperationActionFactory.createCallableInfo[LocalVariableDescriptor]

