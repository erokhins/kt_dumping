'AbstractUselessCallInspection' @ [32:40] ==> public constructor AbstractUselessCallInspection() defined in org.jetbrains.kotlin.idea.inspections.collections.AbstractUselessCallInspection[ClassConstructorDescriptorImpl]

'mapOf' @ [33:35] ==> public fun <K, V> mapOf(vararg pairs: Pair<String, AbstractUselessCallInspection.Companion.Conversion>): Map<String, AbstractUselessCallInspection.Companion.Conversion> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> String
    <V> -> Conversion

'to' @ [33:41] ==> public infix fun <A, B> String.to(that: AbstractUselessCallInspection.Companion.Conversion): Pair<String, AbstractUselessCallInspection.Companion.Conversion> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> Conversion

'deleteConversion' @ [33:73] ==> public final val deleteConversion: AbstractUselessCallInspection.Companion.Conversion defined in org.jetbrains.kotlin.idea.inspections.collections.AbstractUselessCallInspection.Companion[PropertyDescriptorImpl]

'to' @ [34:41] ==> public infix fun <A, B> String.to(that: AbstractUselessCallInspection.Companion.Conversion): Pair<String, AbstractUselessCallInspection.Companion.Conversion> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> Conversion

'deleteConversion' @ [34:66] ==> public final val deleteConversion: AbstractUselessCallInspection.Companion.Conversion defined in org.jetbrains.kotlin.idea.inspections.collections.AbstractUselessCallInspection.Companion[PropertyDescriptorImpl]

'to' @ [35:41] ==> public infix fun <A, B> String.to(that: AbstractUselessCallInspection.Companion.Conversion): Pair<String, AbstractUselessCallInspection.Companion.Conversion> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> Conversion

'Conversion' @ [35:72] ==> public constructor Conversion(replacementName: String? = ...) defined in org.jetbrains.kotlin.idea.inspections.collections.AbstractUselessCallInspection.Companion.Conversion[ClassConstructorDescriptorImpl]

'to' @ [36:41] ==> public infix fun <A, B> String.to(that: AbstractUselessCallInspection.Companion.Conversion): Pair<String, AbstractUselessCallInspection.Companion.Conversion> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> Conversion

'Conversion' @ [36:72] ==> public constructor Conversion(replacementName: String? = ...) defined in org.jetbrains.kotlin.idea.inspections.collections.AbstractUselessCallInspection.Companion.Conversion[ClassConstructorDescriptorImpl]

'uselessFqNames' @ [38:33] ==> protected open val uselessFqNames: Map<String, AbstractUselessCallInspection.Companion.Conversion> defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection[PropertyDescriptorImpl]

'keys' @ [38:48] ==> public abstract val keys: Set<String> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'toShortNames' @ [38:53] ==> public final fun Set<String>.toShortNames(): MutableSet<String> defined in org.jetbrains.kotlin.idea.inspections.collections.AbstractUselessCallInspection.Companion[SimpleFunctionDescriptorImpl]

'conversion' @ [46:23] ==> value-parameter conversion: AbstractUselessCallInspection.Companion.Conversion defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[ValueParameterDescriptorImpl]

'replacementName' @ [46:34] ==> public final val replacementName: String? defined in org.jetbrains.kotlin.idea.inspections.collections.AbstractUselessCallInspection.Companion.Conversion[PropertyDescriptorImpl]

'expression' @ [48:30] ==> value-parameter expression: KtQualifiedExpression defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[ValueParameterDescriptorImpl]

'expression' @ [49:27] ==> value-parameter expression: KtQualifiedExpression defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[ValueParameterDescriptorImpl]

'receiverExpression' @ [49:38] ==> public open val receiverExpression: KtExpression defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[DeserializedPropertyDescriptor]

'getType' @ [49:57] ==> public fun KtExpression.getType(context: BindingContext): KotlinType? defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'context' @ [49:65] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[ValueParameterDescriptorImpl]

'let' @ [49:75] ==> @InlineOnly public inline fun <T, R> KotlinType.let(block: (KotlinType) -> Boolean): Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType
    <R> -> Boolean

'isNullableType' @ [49:91] ==> public open fun isNullableType(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'it' @ [49:106] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded.<anonymous>[ValueParameterDescriptorImpl]

'TextRange' @ [50:28] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'expression' @ [50:38] ==> value-parameter expression: KtQualifiedExpression defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[ValueParameterDescriptorImpl]

'operationTokenNode' @ [50:49] ==> public open val operationTokenNode: ASTNode defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[DeserializedPropertyDescriptor]

'startOffset' @ [50:68] ==> public final val ASTNode.startOffset: Int[MyPropertyDescriptor]

'calleeExpression' @ [50:81] ==> value-parameter calleeExpression: KtExpression defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[ValueParameterDescriptorImpl]

'endOffset' @ [50:98] ==> public val PsiElement.endOffset: Int defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'shiftRight' @ [51:18] ==> @NotNull public open fun shiftRight(p0: Int): TextRange defined in com.intellij.openapi.util.TextRange[JavaMethodDescriptor]

'-' @ [51:29] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'expression' @ [51:30] ==> value-parameter expression: KtQualifiedExpression defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[ValueParameterDescriptorImpl]

'startOffset' @ [51:41] ==> public val PsiElement.startOffset: Int defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'if (newName != null && (notNullType || safeExpression != null)) {
            val fixes = listOf(RenameUselessCallFix(newName)) + listOfNotNull(safeExpression?.let {
                IntentionWrapper(ReplaceWithDotCallFix(safeExpression), safeExpression.containingKtFile)
            })
            val descriptor = holder.manager.createProblemDescriptor(
                    expression,
                    defaultRange,
                    "Call on not-null type may be reduced",
                    ProblemHighlightType.GENERIC_ERROR_OR_WARNING,
                    isOnTheFly,
                    *fixes.toTypedArray()
            )
            holder.registerProblem(descriptor)
        }
        else if (notNullType) {
            val descriptor = holder.manager.createProblemDescriptor(
                    expression,
                    defaultRange,
                    "Useless call on not-null type",
                    ProblemHighlightType.LIKE_UNUSED_SYMBOL,
                    isOnTheFly,
                    RemoveUselessCallFix()
            )
            holder.registerProblem(descriptor)
        }
        else if (safeExpression != null) {
            holder.registerProblem(
                    safeExpression.operationTokenNode.psi,
                    "This call is useless with ?.",
                    ProblemHighlightType.GENERIC_ERROR_OR_WARNING,
                    IntentionWrapper(ReplaceWithDotCallFix(safeExpression), safeExpression.containingKtFile)
            )
        }' @ [52:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'newName' @ [52:13] ==> val newName: String? defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[LocalVariableDescriptor]

'notNullType' @ [52:33] ==> val notNullType: Boolean defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[LocalVariableDescriptor]

'safeExpression' @ [52:48] ==> val safeExpression: KtSafeQualifiedExpression? defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[LocalVariableDescriptor]

'listOf' @ [53:25] ==> public fun <T> listOf(element: RenameUselessCallFix): List<RenameUselessCallFix> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> RenameUselessCallFix

'RenameUselessCallFix' @ [53:32] ==> public constructor RenameUselessCallFix(newName: String) defined in org.jetbrains.kotlin.idea.inspections.collections.RenameUselessCallFix[ClassConstructorDescriptorImpl]

'newName' @ [53:53] ==> val newName: String? defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[LocalVariableDescriptor]

'listOfNotNull' @ [53:65] ==> public fun <T : Any> listOfNotNull(element: IntentionWrapper?): List<IntentionWrapper> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> IntentionWrapper

'safeExpression' @ [53:79] ==> val safeExpression: KtSafeQualifiedExpression? defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[LocalVariableDescriptor]

'let' @ [53:95] ==> @InlineOnly public inline fun <T, R> KtSafeQualifiedExpression.let(block: (KtSafeQualifiedExpression) -> IntentionWrapper): IntentionWrapper defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtSafeQualifiedExpression
    <R> -> IntentionWrapper

'IntentionWrapper' @ [54:17] ==> public constructor IntentionWrapper(@NotNull p0: IntentionAction, @NotNull p1: PsiFile) defined in com.intellij.codeInspection.IntentionWrapper[JavaClassConstructorDescriptor]

'ReplaceWithDotCallFix' @ [54:34] ==> public constructor ReplaceWithDotCallFix(expression: KtSafeQualifiedExpression) defined in org.jetbrains.kotlin.idea.quickfix.ReplaceWithDotCallFix[ClassConstructorDescriptorImpl]

'safeExpression' @ [54:56] ==> val safeExpression: KtSafeQualifiedExpression? defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[LocalVariableDescriptor]

'safeExpression' @ [54:73] ==> val safeExpression: KtSafeQualifiedExpression? defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[LocalVariableDescriptor]

'containingKtFile' @ [54:88] ==> public final val KtSafeQualifiedExpression.containingKtFile: KtFile[MyPropertyDescriptor]

'holder' @ [56:30] ==> public final val holder: ProblemsHolder defined in org.jetbrains.kotlin.idea.inspections.collections.AbstractUselessCallInspection.QualifiedExpressionVisitor[PropertyDescriptorImpl]

'manager' @ [56:37] ==> public final val ProblemsHolder.manager: InspectionManager[MyPropertyDescriptor]

'createProblemDescriptor' @ [56:45] ==> @NotNull @Contract public abstract fun createProblemDescriptor(@NotNull p0: PsiElement, @Nullable p1: TextRange?, @NotNull @Nls p2: String, @NotNull p3: ProblemHighlightType, p4: Boolean, vararg p5: (LocalQuickFix..LocalQuickFix?)): ProblemDescriptor defined in com.intellij.codeInspection.InspectionManager[JavaMethodDescriptor]

'expression' @ [57:21] ==> value-parameter expression: KtQualifiedExpression defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[ValueParameterDescriptorImpl]

'defaultRange' @ [58:21] ==> val defaultRange: TextRange defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[LocalVariableDescriptor]

'GENERIC_ERROR_OR_WARNING' @ [60:42] ==> enum entry GENERIC_ERROR_OR_WARNING defined in com.intellij.codeInspection.ProblemHighlightType[FakeCallableDescriptorForObject]

'isOnTheFly' @ [61:21] ==> public final val isOnTheFly: Boolean defined in org.jetbrains.kotlin.idea.inspections.collections.AbstractUselessCallInspection.QualifiedExpressionVisitor[PropertyDescriptorImpl]

'fixes' @ [62:22] ==> val fixes: List<LocalQuickFix> defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[LocalVariableDescriptor]

'toTypedArray' @ [62:28] ==> public inline fun <reified T> Collection<LocalQuickFix>.toTypedArray(): Array<LocalQuickFix> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T> -> LocalQuickFix

'holder' @ [64:13] ==> public final val holder: ProblemsHolder defined in org.jetbrains.kotlin.idea.inspections.collections.AbstractUselessCallInspection.QualifiedExpressionVisitor[PropertyDescriptorImpl]

'registerProblem' @ [64:20] ==> public open fun registerProblem(@NotNull p0: ProblemDescriptor): Unit defined in com.intellij.codeInspection.ProblemsHolder[JavaMethodDescriptor]

'descriptor' @ [64:36] ==> val descriptor: ProblemDescriptor defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[LocalVariableDescriptor]

'if (notNullType) {
            val descriptor = holder.manager.createProblemDescriptor(
                    expression,
                    defaultRange,
                    "Useless call on not-null type",
                    ProblemHighlightType.LIKE_UNUSED_SYMBOL,
                    isOnTheFly,
                    RemoveUselessCallFix()
            )
            holder.registerProblem(descriptor)
        }
        else if (safeExpression != null) {
            holder.registerProblem(
                    safeExpression.operationTokenNode.psi,
                    "This call is useless with ?.",
                    ProblemHighlightType.GENERIC_ERROR_OR_WARNING,
                    IntentionWrapper(ReplaceWithDotCallFix(safeExpression), safeExpression.containingKtFile)
            )
        }' @ [66:14] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'notNullType' @ [66:18] ==> val notNullType: Boolean defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[LocalVariableDescriptor]

'holder' @ [67:30] ==> public final val holder: ProblemsHolder defined in org.jetbrains.kotlin.idea.inspections.collections.AbstractUselessCallInspection.QualifiedExpressionVisitor[PropertyDescriptorImpl]

'manager' @ [67:37] ==> public final val ProblemsHolder.manager: InspectionManager[MyPropertyDescriptor]

'createProblemDescriptor' @ [67:45] ==> @NotNull @Contract public abstract fun createProblemDescriptor(@NotNull p0: PsiElement, @Nullable p1: TextRange?, @NotNull @Nls p2: String, @NotNull p3: ProblemHighlightType, p4: Boolean, vararg p5: (LocalQuickFix..LocalQuickFix?)): ProblemDescriptor defined in com.intellij.codeInspection.InspectionManager[JavaMethodDescriptor]

'expression' @ [68:21] ==> value-parameter expression: KtQualifiedExpression defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[ValueParameterDescriptorImpl]

'defaultRange' @ [69:21] ==> val defaultRange: TextRange defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[LocalVariableDescriptor]

'LIKE_UNUSED_SYMBOL' @ [71:42] ==> enum entry LIKE_UNUSED_SYMBOL defined in com.intellij.codeInspection.ProblemHighlightType[FakeCallableDescriptorForObject]

'isOnTheFly' @ [72:21] ==> public final val isOnTheFly: Boolean defined in org.jetbrains.kotlin.idea.inspections.collections.AbstractUselessCallInspection.QualifiedExpressionVisitor[PropertyDescriptorImpl]

'RemoveUselessCallFix' @ [73:21] ==> public constructor RemoveUselessCallFix() defined in org.jetbrains.kotlin.idea.inspections.collections.RemoveUselessCallFix[ClassConstructorDescriptorImpl]

'holder' @ [75:13] ==> public final val holder: ProblemsHolder defined in org.jetbrains.kotlin.idea.inspections.collections.AbstractUselessCallInspection.QualifiedExpressionVisitor[PropertyDescriptorImpl]

'registerProblem' @ [75:20] ==> public open fun registerProblem(@NotNull p0: ProblemDescriptor): Unit defined in com.intellij.codeInspection.ProblemsHolder[JavaMethodDescriptor]

'descriptor' @ [75:36] ==> val descriptor: ProblemDescriptor defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[LocalVariableDescriptor]

'safeExpression' @ [77:18] ==> val safeExpression: KtSafeQualifiedExpression? defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[LocalVariableDescriptor]

'holder' @ [78:13] ==> public final val holder: ProblemsHolder defined in org.jetbrains.kotlin.idea.inspections.collections.AbstractUselessCallInspection.QualifiedExpressionVisitor[PropertyDescriptorImpl]

'registerProblem' @ [78:20] ==> public open fun registerProblem(@NotNull p0: PsiElement, @NotNull @Nls p1: String, @NotNull p2: ProblemHighlightType, @Nullable vararg p3: (LocalQuickFix..LocalQuickFix?)): Unit defined in com.intellij.codeInspection.ProblemsHolder[JavaMethodDescriptor]

'safeExpression' @ [79:21] ==> val safeExpression: KtSafeQualifiedExpression? defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[LocalVariableDescriptor]

'operationTokenNode' @ [79:36] ==> public open val operationTokenNode: ASTNode defined in org.jetbrains.kotlin.psi.KtSafeQualifiedExpression[DeserializedPropertyDescriptor]

'psi' @ [79:55] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'GENERIC_ERROR_OR_WARNING' @ [81:42] ==> enum entry GENERIC_ERROR_OR_WARNING defined in com.intellij.codeInspection.ProblemHighlightType[FakeCallableDescriptorForObject]

'IntentionWrapper' @ [82:21] ==> public constructor IntentionWrapper(@NotNull p0: IntentionAction, @NotNull p1: PsiFile) defined in com.intellij.codeInspection.IntentionWrapper[JavaClassConstructorDescriptor]

'ReplaceWithDotCallFix' @ [82:38] ==> public constructor ReplaceWithDotCallFix(expression: KtSafeQualifiedExpression) defined in org.jetbrains.kotlin.idea.quickfix.ReplaceWithDotCallFix[ClassConstructorDescriptorImpl]

'safeExpression' @ [82:60] ==> val safeExpression: KtSafeQualifiedExpression? defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[LocalVariableDescriptor]

'safeExpression' @ [82:77] ==> val safeExpression: KtSafeQualifiedExpression? defined in org.jetbrains.kotlin.idea.inspections.collections.UselessCallOnNotNullInspection.suggestConversionIfNeeded[LocalVariableDescriptor]

'containingKtFile' @ [82:92] ==> public final val KtSafeQualifiedExpression.containingKtFile: KtFile[MyPropertyDescriptor]

