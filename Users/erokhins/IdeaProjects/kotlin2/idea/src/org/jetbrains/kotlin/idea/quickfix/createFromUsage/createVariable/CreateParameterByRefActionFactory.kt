'CreateParameterFromUsageFactory<KtSimpleNameExpression>' @ [45:44] ==> public constructor CreateParameterFromUsageFactory<E : KtElement>() defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterFromUsageFactory[ClassConstructorDescriptorImpl]
Inferred types:
    <E : KtElement> -> KtSimpleNameExpression

'?:' @ [47:23] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtNameReferenceExpression?, right: KtNameReferenceExpression): KtNameReferenceExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtNameReferenceExpression

'getParentElementOfType' @ [47:36] ==> @Nullable public open fun <T : (PsiElement..PsiElement?)> getParentElementOfType(p0: (Diagnostic..Diagnostic?), p1: (Class<(KtNameReferenceExpression..KtNameReferenceExpression?)>..Class<(KtNameReferenceExpression..KtNameReferenceExpression?)>?)): KtNameReferenceExpression? defined in org.jetbrains.kotlin.idea.core.quickfix.QuickFixUtil[JavaMethodDescriptor]
Inferred types:
    <T : (PsiElement..PsiElement?)> -> KtNameReferenceExpression

'diagnostic' @ [47:59] ==> value-parameter diagnostic: Diagnostic defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.getElementOfInterest[ValueParameterDescriptorImpl]

'KtNameReferenceExpression' @ [47:71] ==> public companion object defined in org.jetbrains.kotlin.psi.KtNameReferenceExpression[FakeCallableDescriptorForObject]

'java' @ [47:104] ==> public val <T> KClass<KtNameReferenceExpression>.java: Class<KtNameReferenceExpression> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtNameReferenceExpression

'refExpr' @ [48:13] ==> val refExpr: KtNameReferenceExpression defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.getElementOfInterest[LocalVariableDescriptor]

'getQualifiedElement' @ [48:21] ==> public fun KtSimpleNameExpression.getQualifiedElement(): KtElement defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'refExpr' @ [48:46] ==> val refExpr: KtNameReferenceExpression defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.getElementOfInterest[LocalVariableDescriptor]

'refExpr' @ [49:13] ==> val refExpr: KtNameReferenceExpression defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.getElementOfInterest[LocalVariableDescriptor]

'getParentOfTypeAndBranch' @ [49:21] ==> public inline fun <reified T : PsiElement> PsiElement.getParentOfTypeAndBranch(strict: Boolean = ..., noinline branch: KtCallableReferenceExpression.() -> PsiElement?): KtCallableReferenceExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtCallableReferenceExpression

'callableReference' @ [49:79] ==> public final val KtCallableReferenceExpression.callableReference: KtSimpleNameExpression[MyPropertyDescriptor]

'refExpr' @ [50:16] ==> val refExpr: KtNameReferenceExpression defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.getElementOfInterest[LocalVariableDescriptor]

'component1' @ [54:14] ==> public final operator fun component1(): BindingContext defined in org.jetbrains.kotlin.analyzer.AnalysisResult[DeserializedSimpleFunctionDescriptor]

'component2' @ [54:23] ==> public final operator fun component2(): ModuleDescriptor defined in org.jetbrains.kotlin.analyzer.AnalysisResult[DeserializedSimpleFunctionDescriptor]

'?:' @ [54:43] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: AnalysisResult?, right: AnalysisResult): AnalysisResult[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> AnalysisResult

'element' @ [54:44] ==> value-parameter element: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[ValueParameterDescriptorImpl]

'containingFile' @ [54:52] ==> public final val KtSimpleNameExpression.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'analyzeFullyAndGetResult' @ [54:80] ==> public fun KtElement.analyzeFullyAndGetResult(vararg extraFiles: KtFile): AnalysisResult defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'element' @ [56:27] ==> value-parameter element: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[ValueParameterDescriptorImpl]

'getAssignmentByLHS' @ [56:35] ==> public fun KtExpression.getAssignmentByLHS(): KtBinaryExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'element' @ [58:25] ==> value-parameter element: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[ValueParameterDescriptorImpl]

'getExpressionForTypeGuess' @ [58:33] ==> public fun KtExpression.getExpressionForTypeGuess(): KtExpression defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.callableBuilder[SimpleFunctionDescriptorImpl]

'guessTypes' @ [58:61] ==> public fun KtExpression.guessTypes(context: BindingContext, module: ModuleDescriptor, pseudocode: Pseudocode? = ..., coerceUnusedToUnit: Boolean = ..., allowErrorTypes: Boolean = ...): Array<KotlinType> defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.callableBuilder[SimpleFunctionDescriptorImpl]

'context' @ [58:72] ==> val context: BindingContext defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[LocalVariableDescriptor]

'moduleDescriptor' @ [58:81] ==> val moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[LocalVariableDescriptor]

'let' @ [58:99] ==> @InlineOnly public inline fun <T, R> Array<KotlinType>.let(block: (Array<KotlinType>) -> KotlinType): KotlinType defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Array<KotlinType>
    <R> -> KotlinType

'when (it.size) {
                0 -> moduleDescriptor.builtIns.anyType
                1 -> it.first()
                else -> return null
            }' @ [59:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KotlinType, entry1: KotlinType, entry2: KotlinType): KotlinType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KotlinType

'it' @ [59:19] ==> value-parameter it: Array<KotlinType> defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.<anonymous>[ValueParameterDescriptorImpl]

'size' @ [59:22] ==> public final val size: Int defined in kotlin.Array[DeserializedPropertyDescriptor]

'moduleDescriptor' @ [60:22] ==> val moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[LocalVariableDescriptor]

'builtIns' @ [60:39] ==> public abstract val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.descriptors.ModuleDescriptor[DeserializedPropertyDescriptor]

'anyType' @ [60:48] ==> public final val KotlinBuiltIns.anyType: SimpleType[MyPropertyDescriptor]

'it' @ [61:22] ==> value-parameter it: Array<KotlinType> defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.<anonymous>[ValueParameterDescriptorImpl]

'first' @ [61:25] ==> public fun <T> Array<out KotlinType>.first(): KotlinType defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'None' @ [66:51] ==> enum entry None defined in org.jetbrains.kotlin.idea.refactoring.changeSignature.KotlinValVar[FakeCallableDescriptorForObject]

'varExpected' @ [69:17] ==> val varExpected: Boolean defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[LocalVariableDescriptor]

'element' @ [70:20] ==> value-parameter element: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[ValueParameterDescriptorImpl]

'parents' @ [70:28] ==> public val PsiElement.parents: Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'filter' @ [70:36] ==> public fun <T> Sequence<PsiElement>.filter(predicate: (PsiElement) -> Boolean): Sequence<PsiElement> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'it' @ [70:45] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseFunction.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [70:70] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseFunction.<anonymous>[ValueParameterDescriptorImpl]

'firstOrNull' @ [70:101] ==> public fun <T> Sequence<PsiElement>.firstOrNull(): PsiElement? defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'valOrVar' @ [74:13] ==> var valOrVar: KotlinValVar defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[LocalVariableDescriptor]

'if (varExpected) KotlinValVar.Var else KotlinValVar.Val' @ [74:24] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinValVar, elseBranch: KotlinValVar): KotlinValVar[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinValVar

'varExpected' @ [74:28] ==> val varExpected: Boolean defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[LocalVariableDescriptor]

'Var' @ [74:54] ==> enum entry Var defined in org.jetbrains.kotlin.idea.refactoring.changeSignature.KotlinValVar[FakeCallableDescriptorForObject]

'Val' @ [74:76] ==> enum entry Val defined in org.jetbrains.kotlin.idea.refactoring.changeSignature.KotlinValVar[FakeCallableDescriptorForObject]

'it' @ [75:20] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainingClass[ValueParameterDescriptorImpl]

'parents' @ [75:23] ==> public val PsiElement.parents: Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'firstIsInstanceOrNull' @ [75:31] ==> public inline fun <reified T : Any> Sequence<*>.firstIsInstanceOrNull(): KtClassOrObject? defined in org.jetbrains.kotlin.utils.addToStdlib[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : Any> -> KtClassOrObject

'element' @ [80:20] ==> value-parameter element: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[ValueParameterDescriptorImpl]

'parents' @ [80:28] ==> public val PsiElement.parents: Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'filter' @ [81:22] ==> public fun <T> Sequence<PsiElement>.filter(predicate: (PsiElement) -> Boolean): Sequence<PsiElement> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'it' @ [82:25] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [82:50] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [82:82] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [83:25] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [83:46] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [83:78] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[ValueParameterDescriptorImpl]

'firstOrNull' @ [85:22] ==> public fun <T> Sequence<PsiElement>.firstOrNull(): PsiElement? defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'let' @ [86:23] ==> @InlineOnly public inline fun <T, R> PsiElement.let(block: (PsiElement) -> PsiElement?): PsiElement? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement
    <R> -> PsiElement?

'when {
                            (it is KtNamedFunction || it is KtSecondaryConstructor) && varExpected ||
                            it is KtPropertyAccessor -> chooseContainingClass(it)
                            it is KtAnonymousInitializer -> it.parent.parent as? KtClass
                            it is KtSuperTypeListEntry -> {
                                val klass = it.getStrictParentOfType<KtClassOrObject>()
                                if (klass is KtClass && !klass.isInterface() && klass !is KtEnumEntry) klass else null
                            }
                            it is KtClassBody -> {
                                val klass = it.parent as? KtClass
                                when {
                                    klass is KtEnumEntry -> chooseContainingClass(klass)
                                    klass != null && klass.isInterface() -> null
                                    else -> klass
                                }
                            }
                            else -> it
                        }' @ [87:25] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: PsiElement?, entry1: PsiElement?, entry2: PsiElement?, entry3: PsiElement?, entry4: PsiElement?): PsiElement?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> PsiElement?

'it' @ [88:30] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [88:55] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[ValueParameterDescriptorImpl]

'varExpected' @ [88:88] ==> val varExpected: Boolean defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[LocalVariableDescriptor]

'it' @ [89:29] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[ValueParameterDescriptorImpl]

'chooseContainingClass' @ [89:57] ==> local final fun chooseContainingClass(it: PsiElement): KtClass? defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[SimpleFunctionDescriptorImpl]

'it' @ [89:79] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [90:29] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [90:61] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[ValueParameterDescriptorImpl]

'parent' @ [90:64] ==> public final val KtAnonymousInitializer.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [90:71] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'it' @ [91:29] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [92:45] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[ValueParameterDescriptorImpl]

'getStrictParentOfType' @ [92:48] ==> public inline fun <reified T : PsiElement> PsiElement.getStrictParentOfType(): KtClassOrObject? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtClassOrObject

'if (klass is KtClass && !klass.isInterface() && klass !is KtEnumEntry) klass else null' @ [93:33] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtClass?, elseBranch: KtClass?): KtClass?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtClass?

'klass' @ [93:37] ==> val klass: KtClassOrObject? defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[LocalVariableDescriptor]

'!' @ [93:57] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'klass' @ [93:58] ==> val klass: KtClassOrObject? defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[LocalVariableDescriptor]

'isInterface' @ [93:64] ==> public final fun isInterface(): Boolean defined in org.jetbrains.kotlin.psi.KtClass[DeserializedSimpleFunctionDescriptor]

'klass' @ [93:81] ==> val klass: KtClassOrObject? defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[LocalVariableDescriptor]

'klass' @ [93:104] ==> val klass: KtClassOrObject? defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[LocalVariableDescriptor]

'it' @ [95:29] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [96:45] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[ValueParameterDescriptorImpl]

'parent' @ [96:48] ==> public final val KtClassBody.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'when {
                                    klass is KtEnumEntry -> chooseContainingClass(klass)
                                    klass != null && klass.isInterface() -> null
                                    else -> klass
                                }' @ [97:33] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KtClass?, entry1: KtClass?, entry2: KtClass?): KtClass?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KtClass?

'klass' @ [98:37] ==> val klass: KtClass? defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[LocalVariableDescriptor]

'chooseContainingClass' @ [98:61] ==> local final fun chooseContainingClass(it: PsiElement): KtClass? defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[SimpleFunctionDescriptorImpl]

'klass' @ [98:83] ==> val klass: KtClass? defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[LocalVariableDescriptor]

'klass' @ [99:37] ==> val klass: KtClass? defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[LocalVariableDescriptor]

'klass' @ [99:54] ==> val klass: KtClass? defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[LocalVariableDescriptor]

'isInterface' @ [99:60] ==> public final fun isInterface(): Boolean defined in org.jetbrains.kotlin.psi.KtClass[DeserializedSimpleFunctionDescriptor]

'klass' @ [100:45] ==> val klass: KtClass? defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[LocalVariableDescriptor]

'it' @ [103:37] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.chooseContainerPreferringClass.<anonymous>[ValueParameterDescriptorImpl]

'chooseContainerPreferringClass' @ [108:25] ==> local final fun chooseContainerPreferringClass(): PsiElement? defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[SimpleFunctionDescriptorImpl]

'chooseFunction' @ [108:61] ==> local final fun chooseFunction(): PsiElement? defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[SimpleFunctionDescriptorImpl]

'context' @ [110:34] ==> val context: BindingContext defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[LocalVariableDescriptor]

'DECLARATION_TO_DESCRIPTOR' @ [110:57] ==> public final val DECLARATION_TO_DESCRIPTOR: (ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'container' @ [110:84] ==> val container: PsiElement? defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[LocalVariableDescriptor]

'let' @ [110:96] ==> @InlineOnly public inline fun <T, R> DeclarationDescriptor.let(block: (DeclarationDescriptor) -> DeclarationDescriptor?): DeclarationDescriptor? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DeclarationDescriptor
    <R> -> DeclarationDescriptor?

'if (it is ClassDescriptor) it.unsubstitutedPrimaryConstructor else it' @ [111:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: DeclarationDescriptor?, elseBranch: DeclarationDescriptor?): DeclarationDescriptor?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> DeclarationDescriptor?

'it' @ [111:17] ==> value-parameter it: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [111:40] ==> value-parameter it: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.<anonymous>[ValueParameterDescriptorImpl]

'unsubstitutedPrimaryConstructor' @ [111:43] ==> public final val ClassDescriptor.unsubstitutedPrimaryConstructor: ClassConstructorDescriptor?[MyPropertyDescriptor]

'it' @ [111:80] ==> value-parameter it: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData.<anonymous>[ValueParameterDescriptorImpl]

'paramType' @ [114:13] ==> val paramType: KotlinType defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[LocalVariableDescriptor]

'hasTypeParametersToAdd' @ [114:23] ==> public fun KotlinType.hasTypeParametersToAdd(functionDescriptor: FunctionDescriptor, context: BindingContext): Boolean defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable in file CreateParameterByRefActionFactory.kt[SimpleFunctionDescriptorImpl]

'functionDescriptor' @ [114:46] ==> val functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[LocalVariableDescriptor]

'context' @ [114:66] ==> val context: BindingContext defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[LocalVariableDescriptor]

'CreateParameterData' @ [116:16] ==> public constructor CreateParameterData<out E : KtElement>(parameterInfo: KotlinParameterInfo, originalExpression: KtSimpleNameExpression, createSilently: Boolean = ..., onComplete: ((Editor?) -> Unit)? = ...) defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterData[ClassConstructorDescriptorImpl]
Inferred types:
    <out E : KtElement> -> KtSimpleNameExpression

'KotlinParameterInfo' @ [117:17] ==> @JvmOverloads public constructor KotlinParameterInfo(callableDescriptor: CallableDescriptor, originalIndex: Int = ..., name: String, originalTypeInfo: KotlinTypeInfo = ..., defaultValueForParameter: KtExpression? = ..., defaultValueForCall: KtExpression? = ..., valOrVar: KotlinValVar = ..., modifierList: KtModifierList? = ...) defined in org.jetbrains.kotlin.idea.refactoring.changeSignature.KotlinParameterInfo[ClassConstructorDescriptorImpl]

'functionDescriptor' @ [117:58] ==> val functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[LocalVariableDescriptor]

'element' @ [118:44] ==> value-parameter element: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[ValueParameterDescriptorImpl]

'getReferencedName' @ [118:52] ==> public abstract fun getReferencedName(): String defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[DeserializedSimpleFunctionDescriptor]

'KotlinTypeInfo' @ [119:56] ==> public constructor KotlinTypeInfo(isCovariant: Boolean, type: KotlinType? = ..., text: String? = ...) defined in org.jetbrains.kotlin.idea.refactoring.changeSignature.KotlinTypeInfo[ClassConstructorDescriptorImpl]

'paramType' @ [119:78] ==> val paramType: KotlinType defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[LocalVariableDescriptor]

'valOrVar' @ [120:48] ==> var valOrVar: KotlinValVar defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[LocalVariableDescriptor]

'element' @ [121:17] ==> value-parameter element: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[ValueParameterDescriptorImpl]

'extractFixData' @ [125:92] ==> public final fun extractFixData(element: KtSimpleNameExpression): CreateParameterData<KtSimpleNameExpression>? defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory[SimpleFunctionDescriptorImpl]

'element' @ [125:107] ==> value-parameter element: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.CreateParameterByRefActionFactory.extractFixData[ValueParameterDescriptorImpl]

'LinkedHashSet' @ [129:31] ==> public constructor LinkedHashSet<E : (Any..Any?)>(p0: (MutableCollection<out (TypeParameterDescriptor..TypeParameterDescriptor?)>..Collection<(TypeParameterDescriptor..TypeParameterDescriptor?)>?)) defined in java.util.LinkedHashSet[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> TypeParameterDescriptor

'getTypeParameters' @ [129:45] ==> public fun KotlinType.getTypeParameters(): Set<TypeParameterDescriptor> defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.callableBuilder[SimpleFunctionDescriptorImpl]

'typeParametersToAdd' @ [130:5] ==> val typeParametersToAdd: LinkedHashSet<TypeParameterDescriptor> defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.hasTypeParametersToAdd[LocalVariableDescriptor]

'removeAll' @ [130:25] ==> public open fun removeAll(elements: Collection<TypeParameterDescriptor>): Boolean defined in java.util.LinkedHashSet[JavaMethodDescriptor]

'functionDescriptor' @ [130:35] ==> value-parameter functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.hasTypeParametersToAdd[ValueParameterDescriptorImpl]

'typeParameters' @ [130:54] ==> public final val FunctionDescriptor.typeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'typeParametersToAdd' @ [131:9] ==> val typeParametersToAdd: LinkedHashSet<TypeParameterDescriptor> defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.hasTypeParametersToAdd[LocalVariableDescriptor]

'isEmpty' @ [131:29] ==> public open fun isEmpty(): Boolean defined in java.util.LinkedHashSet[JavaMethodDescriptor]

'when (functionDescriptor) {
                is ConstructorDescriptor -> {
                    (functionDescriptor.containingDeclaration as? ClassDescriptorWithResolutionScopes)?.scopeForClassHeaderResolution
                }

                else -> {
                    val function = functionDescriptor.source.getPsi() as? KtFunction
                    function?.bodyExpression?.getResolutionScope(context, function.getResolutionFacade())
                }
            }' @ [134:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: LexicalScope?, entry1: LexicalScope?): LexicalScope?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> LexicalScope?

'functionDescriptor' @ [134:19] ==> value-parameter functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.hasTypeParametersToAdd[ValueParameterDescriptorImpl]

'functionDescriptor' @ [136:22] ==> value-parameter functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.hasTypeParametersToAdd[ValueParameterDescriptorImpl]

'containingDeclaration' @ [136:41] ==> public final val ConstructorDescriptor.containingDeclaration: ClassifierDescriptorWithTypeParameters[MyPropertyDescriptor]

'scopeForClassHeaderResolution' @ [136:105] ==> public final val ClassDescriptorWithResolutionScopes.scopeForClassHeaderResolution: LexicalScope[MyPropertyDescriptor]

'functionDescriptor' @ [140:36] ==> value-parameter functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.hasTypeParametersToAdd[ValueParameterDescriptorImpl]

'source' @ [140:55] ==> public final val FunctionDescriptor.source: SourceElement[MyPropertyDescriptor]

'getPsi' @ [140:62] ==> public fun SourceElement.getPsi(): PsiElement? defined in org.jetbrains.kotlin.resolve.source[DeserializedSimpleFunctionDescriptor]

'function' @ [141:21] ==> val function: KtFunction? defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.hasTypeParametersToAdd[LocalVariableDescriptor]

'bodyExpression' @ [141:31] ==> public final val KtFunction.bodyExpression: KtExpression?[MyPropertyDescriptor]

'getResolutionScope' @ [141:47] ==> public fun PsiElement.getResolutionScope(bindingContext: BindingContext, resolutionFacade: ResolutionFacade): LexicalScope defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'context' @ [141:66] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.hasTypeParametersToAdd[ValueParameterDescriptorImpl]

'function' @ [141:75] ==> val function: KtFunction? defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.hasTypeParametersToAdd[LocalVariableDescriptor]

'getResolutionFacade' @ [141:84] ==> public fun KtElement.getResolutionFacade(): ResolutionFacade defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'typeParametersToAdd' @ [145:12] ==> val typeParametersToAdd: LinkedHashSet<TypeParameterDescriptor> defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.hasTypeParametersToAdd[LocalVariableDescriptor]

'any' @ [145:32] ==> public inline fun <T> Iterable<TypeParameterDescriptor>.any(predicate: (TypeParameterDescriptor) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeParameterDescriptor

'scope' @ [145:38] ==> val scope: LexicalScope defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.hasTypeParametersToAdd[LocalVariableDescriptor]

'findClassifier' @ [145:44] ==> public fun HierarchicalScope.findClassifier(name: Name, location: LookupLocation): ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.scopes.utils[DeserializedSimpleFunctionDescriptor]

'it' @ [145:59] ==> value-parameter it: TypeParameterDescriptor defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.hasTypeParametersToAdd.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [145:62] ==> public final val TypeParameterDescriptor.name: Name[MyPropertyDescriptor]

'FROM_IDE' @ [145:85] ==> enum entry FROM_IDE defined in org.jetbrains.kotlin.incremental.components.NoLookupLocation[FakeCallableDescriptorForObject]

'it' @ [145:98] ==> value-parameter it: TypeParameterDescriptor defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.createVariable.hasTypeParametersToAdd.<anonymous>[ValueParameterDescriptorImpl]

