'SelfTargetingIntention<KtNamedFunction>' @ [63:44] ==> public constructor SelfTargetingIntention<TElement : PsiElement>(elementType: Class<KtNamedFunction>, text: String, familyName: String = ...) defined in org.jetbrains.kotlin.idea.intentions.SelfTargetingIntention[DeserializedClassConstructorDescriptor]
Inferred types:
    <TElement : PsiElement> -> KtNamedFunction

'java' @ [63:107] ==> public val <T> KClass<KtNamedFunction>.java: Class<KtNamedFunction> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtNamedFunction

'getValue' @ [64:61] ==> public final operator fun getValue(thisRef: R, desc: KProperty<*>): T? defined in org.jetbrains.kotlin.psi.UserDataProperty[DeserializedSimpleFunctionDescriptor]

'create' @ [64:82] ==> @NotNull public open fun <T : (Any..Any?)> create(@NotNull @NonNls p0: String): Key<(String..String?)> defined in com.intellij.openapi.util.Key[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> (kotlin.String..kotlin.String?)

'CallableRefactoring<FunctionDescriptor>' @ [70:9] ==> public constructor CallableRefactoring<out T : CallableDescriptor>(project: Project, callableDescriptor: FunctionDescriptor, commandName: String) defined in org.jetbrains.kotlin.idea.refactoring.CallableRefactoring[ClassConstructorDescriptorImpl]
Inferred types:
    <out T : CallableDescriptor> -> FunctionDescriptor

'project' @ [70:49] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.<init>[ValueParameterDescriptorImpl]

'descriptor' @ [70:58] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.<init>[ValueParameterDescriptorImpl]

'text' @ [70:70] ==> public final var ConvertFunctionToPropertyIntention.text: String[MyPropertyDescriptor]

'ArrayList' @ [71:41] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> KtElement

'getValue' @ [73:40] ==> @InlineOnly public operator inline fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> T

'callableDescriptor' @ [74:24] ==> @Suppress public final val callableDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter[PropertyDescriptorImpl]

'name' @ [74:43] ==> public final val FunctionDescriptor.name: Name[MyPropertyDescriptor]

'?:' @ [75:14] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: Name?, right: Name): Name[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> Name

'propertyNameByGetMethodName' @ [75:46] ==> public final fun propertyNameByGetMethodName(methodName: Name): Name? defined in org.jetbrains.kotlin.synthetic.SyntheticJavaPropertyDescriptor.Companion[DeserializedSimpleFunctionDescriptor]

'name' @ [75:74] ==> val name: Name defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.newName.<anonymous>[LocalVariableDescriptor]

'name' @ [75:83] ==> val name: Name defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.newName.<anonymous>[LocalVariableDescriptor]

'asString' @ [75:89] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'CallableBuilder' @ [79:47] ==> public constructor CallableBuilder(target: KtPsiFactory.CallableBuilder.Target) defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedClassConstructorDescriptor]

'READ_ONLY_PROPERTY' @ [79:63] ==> enum entry READ_ONLY_PROPERTY defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder.Target[FakeCallableDescriptorForObject]

'apply' @ [79:83] ==> @InlineOnly public inline fun <T> KtPsiFactory.CallableBuilder.apply(block: KtPsiFactory.CallableBuilder.() -> Unit): KtPsiFactory.CallableBuilder defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> CallableBuilder

'modifier' @ [81:17] ==> public final fun modifier(modifier: String): KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedSimpleFunctionDescriptor]

'originalFunction' @ [81:26] ==> value-parameter originalFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.convertFunction[ValueParameterDescriptorImpl]

'text' @ [81:43] ==> public final val KtNamedFunction.text: (String..String?)[MyPropertyDescriptor]

'substring' @ [81:48] ==> @InlineOnly public inline fun String.substring(startIndex: Int, endIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'originalFunction' @ [81:61] ==> value-parameter originalFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.convertFunction[ValueParameterDescriptorImpl]

'funKeyword' @ [81:78] ==> public final val KtNamedFunction.funKeyword: PsiElement?[MyPropertyDescriptor]

'getStartOffsetIn' @ [81:91] ==> public fun PsiElement.getStartOffsetIn(ancestor: PsiElement): Int defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'originalFunction' @ [81:108] ==> value-parameter originalFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.convertFunction[ValueParameterDescriptorImpl]

'typeParams' @ [82:17] ==> public final fun typeParams(values: Collection<String> = ...): KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedSimpleFunctionDescriptor]

'originalFunction' @ [82:28] ==> value-parameter originalFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.convertFunction[ValueParameterDescriptorImpl]

'typeParameters' @ [82:45] ==> public final val KtNamedFunction.typeParameters: (MutableList<(KtTypeParameter..KtTypeParameter?)>..List<(KtTypeParameter..KtTypeParameter?)>)[MyPropertyDescriptor]

'map' @ [82:60] ==> public inline fun <T, R> Iterable<(KtTypeParameter..KtTypeParameter?)>.map(transform: ((KtTypeParameter..KtTypeParameter?)) -> (String..String?)): List<(String..String?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtTypeParameter..org.jetbrains.kotlin.psi.KtTypeParameter?)
    <R> -> (kotlin.String..kotlin.String?)

'it' @ [82:66] ==> value-parameter it: (KtTypeParameter..KtTypeParameter?) defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.convertFunction.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'text' @ [82:69] ==> public final val KtTypeParameter.text: (String..String?)[MyPropertyDescriptor]

'originalFunction' @ [83:17] ==> value-parameter originalFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.convertFunction[ValueParameterDescriptorImpl]

'receiverTypeReference' @ [83:34] ==> public final val KtNamedFunction.receiverTypeReference: KtTypeReference?[MyPropertyDescriptor]

'let' @ [83:57] ==> @InlineOnly public inline fun <T, R> KtTypeReference.let(block: (KtTypeReference) -> KtPsiFactory.CallableBuilder): KtPsiFactory.CallableBuilder defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtTypeReference
    <R> -> CallableBuilder

'receiver' @ [83:63] ==> public final fun receiver(receiverType: String): KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedSimpleFunctionDescriptor]

'it' @ [83:72] ==> value-parameter it: KtTypeReference defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.convertFunction.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'text' @ [83:75] ==> public final val KtTypeReference.text: (String..String?)[MyPropertyDescriptor]

'name' @ [84:17] ==> public final fun name(name: String = ...): KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedSimpleFunctionDescriptor]

'newName' @ [84:22] ==> private final val newName: String defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter[PropertyDescriptorImpl]

'originalFunction' @ [85:17] ==> value-parameter originalFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.convertFunction[ValueParameterDescriptorImpl]

'getReturnTypeReference' @ [85:34] ==> internal fun KtNamedDeclaration.getReturnTypeReference(): KtTypeReference? defined in org.jetbrains.kotlin.idea.quickfix.createFromUsage.callableBuilder in file CallableBuilder.kt[SimpleFunctionDescriptorImpl]

'let' @ [85:60] ==> @InlineOnly public inline fun <T, R> KtTypeReference.let(block: (KtTypeReference) -> KtPsiFactory.CallableBuilder): KtPsiFactory.CallableBuilder defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtTypeReference
    <R> -> CallableBuilder

'returnType' @ [85:66] ==> public final fun returnType(type: String): KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedSimpleFunctionDescriptor]

'it' @ [85:77] ==> value-parameter it: KtTypeReference defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.convertFunction.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'text' @ [85:80] ==> public final val KtTypeReference.text: (String..String?)[MyPropertyDescriptor]

'typeConstraints' @ [86:17] ==> public final fun typeConstraints(values: Collection<String>): KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedSimpleFunctionDescriptor]

'originalFunction' @ [86:33] ==> value-parameter originalFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.convertFunction[ValueParameterDescriptorImpl]

'typeConstraints' @ [86:50] ==> public final val KtNamedFunction.typeConstraints: (MutableList<(KtTypeConstraint..KtTypeConstraint?)>..List<(KtTypeConstraint..KtTypeConstraint?)>)[MyPropertyDescriptor]

'map' @ [86:66] ==> public inline fun <T, R> Iterable<(KtTypeConstraint..KtTypeConstraint?)>.map(transform: ((KtTypeConstraint..KtTypeConstraint?)) -> (String..String?)): List<(String..String?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtTypeConstraint..org.jetbrains.kotlin.psi.KtTypeConstraint?)
    <R> -> (kotlin.String..kotlin.String?)

'it' @ [86:72] ==> value-parameter it: (KtTypeConstraint..KtTypeConstraint?) defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.convertFunction.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'text' @ [86:75] ==> public final val KtTypeConstraint.text: (String..String?)[MyPropertyDescriptor]

'if (originalFunction.equalsToken != null) {
                    getterExpression(originalFunction.bodyExpression!!.text, breakLine = originalFunction.typeReference != null)
                }
                else {
                    (originalFunction.bodyExpression as? KtBlockExpression)?.let { body ->
                        transform {
                            append("\nget() ")
                            append(body.text)
                        }
                    }
                }' @ [88:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any?, elseBranch: Any?): Any?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any?

'originalFunction' @ [88:21] ==> value-parameter originalFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.convertFunction[ValueParameterDescriptorImpl]

'equalsToken' @ [88:38] ==> public final val KtNamedFunction.equalsToken: PsiElement?[MyPropertyDescriptor]

'getterExpression' @ [89:21] ==> public final fun getterExpression(expression: String, breakLine: Boolean = ...): KtPsiFactory.CallableBuilder defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedSimpleFunctionDescriptor]

'originalFunction' @ [89:38] ==> value-parameter originalFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.convertFunction[ValueParameterDescriptorImpl]

'bodyExpression' @ [89:55] ==> public final val KtNamedFunction.bodyExpression: KtExpression?[MyPropertyDescriptor]

'text' @ [89:72] ==> public final val KtExpression.text: (String..String?)[MyPropertyDescriptor]

'originalFunction' @ [89:90] ==> value-parameter originalFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.convertFunction[ValueParameterDescriptorImpl]

'typeReference' @ [89:107] ==> public final var KtNamedFunction.typeReference: KtTypeReference?[MyPropertyDescriptor]

'originalFunction' @ [92:22] ==> value-parameter originalFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.convertFunction[ValueParameterDescriptorImpl]

'bodyExpression' @ [92:39] ==> public final val KtNamedFunction.bodyExpression: KtExpression?[MyPropertyDescriptor]

'let' @ [92:78] ==> @InlineOnly public inline fun <T, R> KtBlockExpression.let(block: (KtBlockExpression) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtBlockExpression
    <R> -> Unit

'transform' @ [93:25] ==> public final fun transform(f: StringBuilder /* = StringBuilder */.() -> Unit): Unit defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedSimpleFunctionDescriptor]

'append' @ [94:29] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'append' @ [95:29] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'body' @ [95:36] ==> value-parameter body: KtBlockExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.convertFunction.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'text' @ [95:41] ==> public final val KtBlockExpression.text: (String..String?)[MyPropertyDescriptor]

'asString' @ [99:15] ==> public final fun asString(): String defined in org.jetbrains.kotlin.psi.KtPsiFactory.CallableBuilder[DeserializedSimpleFunctionDescriptor]

'originalFunction' @ [101:28] ==> value-parameter originalFunction: KtNamedFunction defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.convertFunction[ValueParameterDescriptorImpl]

'replaced' @ [101:45] ==> public inline fun <reified T : PsiElement> PsiElement.replaced(newElement: KtProperty): KtProperty defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtProperty

'psiFactory' @ [101:54] ==> value-parameter psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.convertFunction[ValueParameterDescriptorImpl]

'createDeclaration' @ [101:65] ==> public final fun <TDeclaration : KtDeclaration> createDeclaration(text: String): KtProperty defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <TDeclaration : KtDeclaration> -> KtProperty

'propertyString' @ [101:95] ==> val propertyString: String defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.convertFunction[LocalVariableDescriptor]

'editor' @ [103:13] ==> private final val editor: Editor? defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter[PropertyDescriptorImpl]

'caretModel' @ [103:21] ==> public final val Editor.caretModel: CaretModel[MyPropertyDescriptor]

'moveToOffset' @ [103:33] ==> public abstract fun moveToOffset(p0: Int): Unit defined in com.intellij.openapi.editor.CaretModel[JavaMethodDescriptor]

'replaced' @ [103:46] ==> val replaced: KtProperty defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.convertFunction[LocalVariableDescriptor]

'nameIdentifier' @ [103:55] ==> public final val KtProperty.nameIdentifier: PsiElement?[MyPropertyDescriptor]

'endOffset' @ [103:72] ==> public val PsiElement.endOffset: Int defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedPropertyDescriptor]

'MultiMap' @ [107:29] ==> public constructor MultiMap<K : (Any..Any?), V : (Any..Any?)>() defined in com.intellij.util.containers.MultiMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> PsiElement
    <V : (Any..Any?)> -> String

'getterName' @ [108:37] ==> @NotNull public open fun getterName(@NotNull p0: String): String defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaMethodDescriptor]

'callableDescriptor' @ [108:48] ==> @Suppress public final val callableDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter[PropertyDescriptorImpl]

'name' @ [108:67] ==> public final val FunctionDescriptor.name: Name[MyPropertyDescriptor]

'asString' @ [108:72] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'getAffectedCallables' @ [109:29] ==> public fun getAffectedCallables(project: Project, descriptorsForChange: Collection<CallableDescriptor>): List<PsiElement> defined in org.jetbrains.kotlin.idea.refactoring in file CallableRefactoring.kt[SimpleFunctionDescriptorImpl]

'project' @ [109:50] ==> public final val project: Project defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter[PropertyDescriptorImpl]

'descriptorsForChange' @ [109:59] ==> value-parameter descriptorsForChange: Collection<CallableDescriptor> defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[ValueParameterDescriptorImpl]

'ArrayList' @ [110:31] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> KtCallElement

'ArrayList' @ [111:38] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> PsiReference

'ArrayList' @ [112:31] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> PsiReference

'callables' @ [113:30] ==> val callables: List<PsiElement> defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'callable' @ [114:21] ==> val callable: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'!' @ [116:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'checkModifiable' @ [116:22] ==> protected final fun checkModifiable(element: PsiElement): Boolean defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter[SimpleFunctionDescriptorImpl]

'callable' @ [116:38] ==> val callable: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'reportDeclarationConflict' @ [117:21] ==> public fun reportDeclarationConflict(conflicts: MultiMap<PsiElement, String>, declaration: PsiElement, message: (renderedDeclaration: String) -> String): Unit defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'conflicts' @ [117:47] ==> val conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'callable' @ [117:58] ==> val callable: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'it' @ [117:85] ==> value-parameter it: String defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring.<anonymous>[ValueParameterDescriptorImpl]

'callable' @ [120:21] ==> val callable: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'callable' @ [121:25] ==> val callable: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'typeReference' @ [121:34] ==> public final var KtNamedFunction.typeReference: KtTypeReference?[MyPropertyDescriptor]

'callable' @ [122:50] ==> val callable: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'resolveToDescriptor' @ [122:59] ==> public fun KtDeclaration.resolveToDescriptor(bodyResolveMode: BodyResolveMode = ...): DeclarationDescriptor defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'PARTIAL' @ [122:95] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'functionDescriptor' @ [123:36] ==> val functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'returnType' @ [123:55] ==> public final val FunctionDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'when {
                                               type == null || type.isError -> null
                                               type.constructor.isDenotable -> type
                                               else -> type.supertypes().firstOrNull { it.constructor.isDenotable }
                                           }' @ [124:44] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KotlinType?, entry1: KotlinType?, entry2: KotlinType?): KotlinType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KotlinType?

'type' @ [125:48] ==> val type: KotlinType? defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'type' @ [125:64] ==> val type: KotlinType? defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'isError' @ [125:69] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types[DeserializedPropertyDescriptor]

'type' @ [126:48] ==> val type: KotlinType? defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'constructor' @ [126:53] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'isDenotable' @ [126:65] ==> public final val TypeConstructor.isDenotable: Boolean[MyPropertyDescriptor]

'type' @ [126:80] ==> val type: KotlinType? defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'type' @ [127:56] ==> val type: KotlinType? defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'supertypes' @ [127:61] ==> public fun KotlinType.supertypes(): Collection<KotlinType> defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'firstOrNull' @ [127:74] ==> public inline fun <T> Iterable<KotlinType>.firstOrNull(predicate: (KotlinType) -> Boolean): KotlinType? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'it' @ [127:88] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring.<anonymous>[ValueParameterDescriptorImpl]

'constructor' @ [127:91] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'isDenotable' @ [127:103] ==> public final val TypeConstructor.isDenotable: Boolean[MyPropertyDescriptor]

'functionDescriptor' @ [128:49] ==> val functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'builtIns' @ [128:68] ==> public val DeclarationDescriptor.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'nullableAnyType' @ [128:77] ==> public final val KotlinBuiltIns.nullableAnyType: SimpleType[MyPropertyDescriptor]

'callable' @ [129:25] ==> val callable: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'typeFqNameToAdd' @ [129:34] ==> private final var KtNamedFunction.typeFqNameToAdd: String? defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention[PropertyDescriptorImpl]

'IdeDescriptorRenderers' @ [129:52] ==> public object IdeDescriptorRenderers defined in org.jetbrains.kotlin.idea.util[FakeCallableDescriptorForObject]

'SOURCE_CODE' @ [129:75] ==> @field:JvmField public final val SOURCE_CODE: DescriptorRenderer defined in org.jetbrains.kotlin.idea.util.IdeDescriptorRenderers[DeserializedPropertyDescriptor]

'renderType' @ [129:87] ==> public abstract fun renderType(type: KotlinType): String defined in org.jetbrains.kotlin.renderer.DescriptorRenderer[DeserializedSimpleFunctionDescriptor]

'typeToInsert' @ [129:98] ==> val typeToInsert: KotlinType defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'callableDescriptor' @ [132:21] ==> @Suppress public final val callableDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter[PropertyDescriptorImpl]

'getContainingScope' @ [132:40] ==> public fun DeclarationDescriptor.getContainingScope(): LexicalScope? defined in org.jetbrains.kotlin.idea.refactoring in file CallableRefactoring.kt[SimpleFunctionDescriptorImpl]

'findVariable' @ [133:31] ==> public fun HierarchicalScope.findVariable(name: Name, location: LookupLocation, predicate: (VariableDescriptor) -> Boolean = ...): VariableDescriptor? defined in org.jetbrains.kotlin.resolve.scopes.utils[DeserializedSimpleFunctionDescriptor]

'callableDescriptor' @ [133:44] ==> @Suppress public final val callableDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter[PropertyDescriptorImpl]

'name' @ [133:63] ==> public final val FunctionDescriptor.name: Name[MyPropertyDescriptor]

'FROM_IDE' @ [133:86] ==> enum entry FROM_IDE defined in org.jetbrains.kotlin.incremental.components.NoLookupLocation[FakeCallableDescriptorForObject]

'let' @ [134:31] ==> @InlineOnly public inline fun <T, R> VariableDescriptor.let(block: (VariableDescriptor) -> PsiElement?): PsiElement? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> VariableDescriptor
    <R> -> PsiElement?

'DescriptorToSourceUtilsIde' @ [134:37] ==> public object DescriptorToSourceUtilsIde defined in org.jetbrains.kotlin.idea.codeInsight[FakeCallableDescriptorForObject]

'getAnyDeclaration' @ [134:64] ==> public final fun getAnyDeclaration(project: Project, descriptor: DeclarationDescriptor): PsiElement? defined in org.jetbrains.kotlin.idea.codeInsight.DescriptorToSourceUtilsIde[DeserializedSimpleFunctionDescriptor]

'project' @ [134:82] ==> public final val project: Project defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter[PropertyDescriptorImpl]

'it' @ [134:91] ==> value-parameter it: VariableDescriptor defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring.<anonymous>[ValueParameterDescriptorImpl]

'let' @ [135:31] ==> @InlineOnly public inline fun <T, R> PsiElement.let(block: (PsiElement) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement
    <R> -> Unit

'reportDeclarationConflict' @ [135:37] ==> public fun reportDeclarationConflict(conflicts: MultiMap<PsiElement, String>, declaration: PsiElement, message: (renderedDeclaration: String) -> String): Unit defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'conflicts' @ [135:63] ==> val conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'it' @ [135:74] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [135:82] ==> value-parameter it: String defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'callable' @ [138:21] ==> val callable: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'callable' @ [139:21] ==> val callable: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'containingClass' @ [139:30] ==> public final val PsiMethod.containingClass: PsiClass?[MyPropertyDescriptor]

'findMethodsByName' @ [140:31] ==> @NotNull public abstract fun findMethodsByName(@NonNls p0: (String..String?), p1: Boolean): (Array<(PsiMethod..PsiMethod?)>..Array<out (PsiMethod..PsiMethod?)>) defined in com.intellij.psi.PsiClass[JavaMethodDescriptor]

'getterName' @ [140:49] ==> val getterName: String defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'firstOrNull' @ [142:31] ==> public inline fun <T> Array<out (PsiMethod..PsiMethod?)>.firstOrNull(predicate: ((PsiMethod..PsiMethod?)) -> Boolean): PsiMethod? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiMethod..com.intellij.psi.PsiMethod?)

'it' @ [142:45] ==> value-parameter it: (PsiMethod..PsiMethod?) defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring.<anonymous>[ValueParameterDescriptorImpl]

'parameterList' @ [142:48] ==> public final val PsiMethod.parameterList: PsiParameterList[MyPropertyDescriptor]

'parametersCount' @ [142:62] ==> public final val PsiParameterList.parametersCount: Int[MyPropertyDescriptor]

'!' @ [142:86] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'callables' @ [142:87] ==> val callables: List<PsiElement> defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'contains' @ [142:97] ==> public operator fun <@OnlyInputTypes T> Iterable<PsiElement?>.contains(element: PsiElement?): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <@OnlyInputTypes T> -> PsiElement?

'it' @ [142:106] ==> value-parameter it: (PsiMethod..PsiMethod?) defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring.<anonymous>[ValueParameterDescriptorImpl]

'namedUnwrappedElement' @ [142:109] ==> public val PsiElement.namedUnwrappedElement: PsiNamedElement? defined in org.jetbrains.kotlin.asJava[DeserializedPropertyDescriptor]

'let' @ [143:31] ==> @InlineOnly public inline fun <T, R> PsiMethod.let(block: (PsiMethod) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiMethod
    <R> -> Unit

'reportDeclarationConflict' @ [143:37] ==> public fun reportDeclarationConflict(conflicts: MultiMap<PsiElement, String>, declaration: PsiElement, message: (renderedDeclaration: String) -> String): Unit defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'conflicts' @ [143:63] ==> val conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'it' @ [143:74] ==> value-parameter it: PsiMethod defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [143:82] ==> value-parameter it: String defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'search' @ [146:47] ==> @NotNull public open fun search(@NotNull p0: PsiElement): Query<(PsiReference..PsiReference?)> defined in com.intellij.psi.search.searches.ReferencesSearch[JavaMethodDescriptor]

'callable' @ [146:54] ==> val callable: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'usages' @ [147:31] ==> val usages: Query<(PsiReference..PsiReference?)> defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'if (usage is KtSimpleNameReference) {
                        val expression = usage.expression
                        val callElement = expression.getParentOfTypeAndBranch<KtCallElement> { calleeExpression }
                        if (callElement != null && expression.getStrictParentOfType<KtCallableReferenceExpression>() == null) {
                            if (callElement.typeArguments.isNotEmpty()) {
                                conflicts.putValue(
                                        callElement,
                                        "Type arguments will be lost after conversion: ${StringUtil.htmlEmphasize(callElement.text)}"
                                )
                            }

                            if (callElement.valueArguments.isNotEmpty()) {
                                conflicts.putValue(
                                        callElement,
                                        "Call with arguments will be skipped: ${StringUtil.htmlEmphasize(callElement.text)}"
                                )
                                continue
                            }

                            kotlinCalls.add(callElement)
                        }
                        else {
                            kotlinRefsToRename.add(usage)
                        }
                    }
                    else {
                        foreignRefs.add(usage)
                    }' @ [148:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Boolean, elseBranch: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Boolean

'usage' @ [148:25] ==> val usage: (PsiReference..PsiReference?) defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'usage' @ [149:42] ==> val usage: (PsiReference..PsiReference?) defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'expression' @ [149:48] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.references.KtSimpleNameReference[DeserializedPropertyDescriptor]

'expression' @ [150:43] ==> val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'getParentOfTypeAndBranch' @ [150:54] ==> public inline fun <reified T : PsiElement> PsiElement.getParentOfTypeAndBranch(strict: Boolean = ..., noinline branch: KtCallElement.() -> PsiElement?): KtCallElement? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtCallElement

'calleeExpression' @ [150:96] ==> public final val KtCallElement.calleeExpression: KtExpression?[MyPropertyDescriptor]

'if (callElement != null && expression.getStrictParentOfType<KtCallableReferenceExpression>() == null) {
                            if (callElement.typeArguments.isNotEmpty()) {
                                conflicts.putValue(
                                        callElement,
                                        "Type arguments will be lost after conversion: ${StringUtil.htmlEmphasize(callElement.text)}"
                                )
                            }

                            if (callElement.valueArguments.isNotEmpty()) {
                                conflicts.putValue(
                                        callElement,
                                        "Call with arguments will be skipped: ${StringUtil.htmlEmphasize(callElement.text)}"
                                )
                                continue
                            }

                            kotlinCalls.add(callElement)
                        }
                        else {
                            kotlinRefsToRename.add(usage)
                        }' @ [151:25] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Boolean, elseBranch: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Boolean

'callElement' @ [151:29] ==> val callElement: KtCallElement? defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'expression' @ [151:52] ==> val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'getStrictParentOfType' @ [151:63] ==> public inline fun <reified T : PsiElement> PsiElement.getStrictParentOfType(): KtCallableReferenceExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtCallableReferenceExpression

'callElement' @ [152:33] ==> val callElement: KtCallElement? defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'typeArguments' @ [152:45] ==> public final val KtCallElement.typeArguments: (MutableList<(KtTypeProjection..KtTypeProjection?)>..List<(KtTypeProjection..KtTypeProjection?)>)[MyPropertyDescriptor]

'isNotEmpty' @ [152:59] ==> @InlineOnly public inline fun <T> Collection<(KtTypeProjection..KtTypeProjection?)>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtTypeProjection..org.jetbrains.kotlin.psi.KtTypeProjection?)

'conflicts' @ [153:33] ==> val conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'putValue' @ [153:43] ==> public open fun putValue(@Nullable p0: PsiElement?, p1: (String..String?)): Unit defined in com.intellij.util.containers.MultiMap[JavaMethodDescriptor]

'callElement' @ [154:41] ==> val callElement: KtCallElement? defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'htmlEmphasize' @ [155:101] ==> @NotNull @Contract public open fun htmlEmphasize(@NotNull p0: String): String defined in com.intellij.openapi.util.text.StringUtil[JavaMethodDescriptor]

'callElement' @ [155:115] ==> val callElement: KtCallElement? defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'text' @ [155:127] ==> public final val KtCallElement.text: (String..String?)[MyPropertyDescriptor]

'callElement' @ [159:33] ==> val callElement: KtCallElement? defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'valueArguments' @ [159:45] ==> public final val KtCallElement.valueArguments: (MutableList<out (ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>)[MyPropertyDescriptor]

'isNotEmpty' @ [159:60] ==> @InlineOnly public inline fun <T> Collection<(ValueArgument..ValueArgument?)>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)

'conflicts' @ [160:33] ==> val conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'putValue' @ [160:43] ==> public open fun putValue(@Nullable p0: PsiElement?, p1: (String..String?)): Unit defined in com.intellij.util.containers.MultiMap[JavaMethodDescriptor]

'callElement' @ [161:41] ==> val callElement: KtCallElement? defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'htmlEmphasize' @ [162:92] ==> @NotNull @Contract public open fun htmlEmphasize(@NotNull p0: String): String defined in com.intellij.openapi.util.text.StringUtil[JavaMethodDescriptor]

'callElement' @ [162:106] ==> val callElement: KtCallElement? defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'text' @ [162:118] ==> public final val KtCallElement.text: (String..String?)[MyPropertyDescriptor]

'kotlinCalls' @ [167:29] ==> val kotlinCalls: ArrayList<KtCallElement> defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'add' @ [167:41] ==> public open fun add(element: KtCallElement): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'callElement' @ [167:45] ==> val callElement: KtCallElement? defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'kotlinRefsToRename' @ [170:29] ==> val kotlinRefsToRename: ArrayList<PsiReference> defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'add' @ [170:48] ==> public open fun add(element: PsiReference): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'usage' @ [170:52] ==> val usage: (PsiReference..PsiReference?) defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'foreignRefs' @ [174:25] ==> val foreignRefs: ArrayList<PsiReference> defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'add' @ [174:37] ==> public open fun add(element: PsiReference): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'usage' @ [174:41] ==> val usage: (PsiReference..PsiReference?) defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'project' @ [179:13] ==> public final val project: Project defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter[PropertyDescriptorImpl]

'checkConflictsInteractively' @ [179:21] ==> public fun Project.checkConflictsInteractively(conflicts: MultiMap<PsiElement, String>, onShowConflicts: () -> Unit = ..., onAccept: () -> Unit): Unit defined in org.jetbrains.kotlin.idea.refactoring in file kotlinRefactoringUtil.kt[SimpleFunctionDescriptorImpl]

'conflicts' @ [179:49] ==> val conflicts: MultiMap<PsiElement, String> defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'project' @ [180:17] ==> public final val project: Project defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter[PropertyDescriptorImpl]

'executeWriteCommand' @ [180:25] ==> public fun Project.executeWriteCommand(name: String, command: () -> Unit): Unit defined in org.jetbrains.kotlin.idea.util.application[DeserializedSimpleFunctionDescriptor]

'text' @ [180:45] ==> public final var ConvertFunctionToPropertyIntention.text: String[MyPropertyDescriptor]

'KtPsiFactory' @ [181:38] ==> @JvmOverloads public constructor KtPsiFactory(project: Project, markGenerated: Boolean = ...) defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedClassConstructorDescriptor]

'project' @ [181:51] ==> public final val project: Project defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter[PropertyDescriptorImpl]

'getterName' @ [182:48] ==> @NotNull public open fun getterName(@NotNull p0: String): String defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaMethodDescriptor]

'newName' @ [182:59] ==> private final val newName: String defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter[PropertyDescriptorImpl]

'psiFactory' @ [183:38] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'createExpression' @ [183:49] ==> public final fun createExpression(text: String): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'newName' @ [183:66] ==> private final val newName: String defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter[PropertyDescriptorImpl]

'kotlinCalls' @ [185:21] ==> val kotlinCalls: ArrayList<KtCallElement> defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'forEach' @ [185:33] ==> @HidesMembers public inline fun <T> Iterable<KtCallElement>.forEach(action: (KtCallElement) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtCallElement

'it' @ [185:43] ==> value-parameter it: KtCallElement defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'replace' @ [185:46] ==> public abstract fun replace(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtCallElement[JavaMethodDescriptor]

'newRefExpr' @ [185:54] ==> val newRefExpr: KtExpression defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'kotlinRefsToRename' @ [186:21] ==> val kotlinRefsToRename: ArrayList<PsiReference> defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'forEach' @ [186:40] ==> @HidesMembers public inline fun <T> Iterable<PsiReference>.forEach(action: (PsiReference) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiReference

'it' @ [186:50] ==> value-parameter it: PsiReference defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'handleElementRename' @ [186:53] ==> public abstract fun handleElementRename(p0: (String..String?)): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiReference[JavaMethodDescriptor]

'newName' @ [186:73] ==> private final val newName: String defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter[PropertyDescriptorImpl]

'foreignRefs' @ [187:21] ==> val foreignRefs: ArrayList<PsiReference> defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'forEach' @ [187:33] ==> @HidesMembers public inline fun <T> Iterable<PsiReference>.forEach(action: (PsiReference) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiReference

'it' @ [187:43] ==> value-parameter it: PsiReference defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'handleElementRename' @ [187:46] ==> public abstract fun handleElementRename(p0: (String..String?)): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiReference[JavaMethodDescriptor]

'newGetterName' @ [187:66] ==> val newGetterName: String defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'callables' @ [188:21] ==> val callables: List<PsiElement> defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring[LocalVariableDescriptor]

'forEach' @ [188:31] ==> @HidesMembers public inline fun <T> Iterable<PsiElement>.forEach(action: (PsiElement) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'when (it) {
                            is KtNamedFunction -> convertFunction(it, psiFactory)
                            is PsiMethod -> it.name = newGetterName
                        }' @ [189:25] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'it' @ [189:31] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'convertFunction' @ [190:51] ==> private final fun convertFunction(originalFunction: KtNamedFunction, psiFactory: KtPsiFactory): Unit defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter[SimpleFunctionDescriptorImpl]

'it' @ [190:67] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'psiFactory' @ [190:71] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'it' @ [191:45] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [191:48] ==> public final var PsiMethod.name: String[MyPropertyDescriptor]

'newGetterName' @ [191:55] ==> val newGetterName: String defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter.performRefactoring.<anonymous>.<anonymous>[LocalVariableDescriptor]

'ShortenReferences' @ [195:21] ==> public companion object defined in org.jetbrains.kotlin.idea.core.ShortenReferences[FakeCallableDescriptorForObject]

'DEFAULT' @ [195:39] ==> @field:JvmField public final val DEFAULT: ShortenReferences defined in org.jetbrains.kotlin.idea.core.ShortenReferences.Companion[DeserializedPropertyDescriptor]

'process' @ [195:47] ==> @JvmOverloads public final fun process(elements: Iterable<KtElement>, elementFilter: (PsiElement) -> ShortenReferences.FilterResult = ...): Collection<KtElement> defined in org.jetbrains.kotlin.idea.core.ShortenReferences[DeserializedSimpleFunctionDescriptor]

'elementsToShorten' @ [195:55] ==> private final val elementsToShorten: ArrayList<KtElement> defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter[PropertyDescriptorImpl]

'element' @ [204:26] ==> value-parameter element: KtNamedFunction defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.isApplicableTo[ValueParameterDescriptorImpl]

'nameIdentifier' @ [204:34] ==> public final val KtNamedFunction.nameIdentifier: PsiElement?[MyPropertyDescriptor]

'!' @ [205:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'identifier' @ [205:14] ==> val identifier: PsiElement defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.isApplicableTo[LocalVariableDescriptor]

'textRange' @ [205:25] ==> public final val PsiElement.textRange: (TextRange..TextRange?)[MyPropertyDescriptor]

'containsOffset' @ [205:35] ==> public open fun containsOffset(p0: Int): Boolean defined in com.intellij.openapi.util.TextRange[JavaMethodDescriptor]

'caretOffset' @ [205:50] ==> value-parameter caretOffset: Int defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.isApplicableTo[ValueParameterDescriptorImpl]

'element' @ [207:13] ==> value-parameter element: KtNamedFunction defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.isApplicableTo[ValueParameterDescriptorImpl]

'valueParameters' @ [207:21] ==> public final val KtNamedFunction.valueParameters: (MutableList<(KtParameter..KtParameter?)>..List<(KtParameter..KtParameter?)>)[MyPropertyDescriptor]

'isNotEmpty' @ [207:37] ==> @InlineOnly public inline fun <T> Collection<(KtParameter..KtParameter?)>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtParameter..org.jetbrains.kotlin.psi.KtParameter?)

'element' @ [207:53] ==> value-parameter element: KtNamedFunction defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.isApplicableTo[ValueParameterDescriptorImpl]

'isLocal' @ [207:61] ==> public final val KtNamedFunction.isLocal: Boolean[MyPropertyDescriptor]

'element' @ [209:20] ==> value-parameter element: KtNamedFunction defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.isApplicableTo[ValueParameterDescriptorImpl]

'name' @ [209:28] ==> public final val KtNamedFunction.name: String?[MyPropertyDescriptor]

'name' @ [210:13] ==> val name: String defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.isApplicableTo[LocalVariableDescriptor]

'name' @ [210:33] ==> val name: String defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.isApplicableTo[LocalVariableDescriptor]

'in' @ [210:55] ==> public abstract fun contains(@Nullable element: Name?): Boolean defined in com.google.common.collect.ImmutableSet[JavaMethodDescriptor]

'identifier' @ [210:60] ==> @NotNull public open fun identifier(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'name' @ [210:71] ==> val name: String defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.isApplicableTo[LocalVariableDescriptor]

'UNARY_OPERATION_NAMES' @ [210:100] ==> public final val UNARY_OPERATION_NAMES: (ImmutableBiMap<(KtSingleValueToken..KtSingleValueToken?), (Name..Name?)>..ImmutableBiMap<(KtSingleValueToken..KtSingleValueToken?), (Name..Name?)>?) defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaPropertyDescriptor]

'inverse' @ [210:122] ==> public abstract fun inverse(): (ImmutableBiMap<(Name..Name?), (KtSingleValueToken..KtSingleValueToken?)>..ImmutableBiMap<(Name..Name?), (KtSingleValueToken..KtSingleValueToken?)>?) defined in com.google.common.collect.ImmutableBiMap[JavaMethodDescriptor]

'keys' @ [210:132] ==> public open val keys: ImmutableSet<(Name..Name?)> defined in com.google.common.collect.ImmutableBiMap[JavaPropertyDescriptor]

'element' @ [214:26] ==> value-parameter element: KtNamedFunction defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.isApplicableTo[ValueParameterDescriptorImpl]

'analyze' @ [214:34] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'PARTIAL' @ [214:58] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'DECLARATION_TO_DESCRIPTOR' @ [214:82] ==> public final val DECLARATION_TO_DESCRIPTOR: (ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'element' @ [214:109] ==> value-parameter element: KtNamedFunction defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.isApplicableTo[ValueParameterDescriptorImpl]

'descriptor' @ [216:26] ==> val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.isApplicableTo[LocalVariableDescriptor]

'returnType' @ [216:37] ==> public final val FunctionDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'!' @ [217:16] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isUnit' @ [217:32] ==> public open fun isUnit(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'returnType' @ [217:39] ==> val returnType: KotlinType defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.isApplicableTo[LocalVariableDescriptor]

'!' @ [217:54] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isNothing' @ [217:70] ==> public open fun isNothing(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'returnType' @ [217:80] ==> val returnType: KotlinType defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.isApplicableTo[LocalVariableDescriptor]

'element' @ [221:23] ==> value-parameter element: KtNamedFunction defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.applyTo[ValueParameterDescriptorImpl]

'analyze' @ [221:31] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'PARTIAL' @ [221:55] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.lazy.BodyResolveMode[FakeCallableDescriptorForObject]

'context' @ [222:26] ==> val context: BindingContext defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.applyTo[LocalVariableDescriptor]

'DECLARATION_TO_DESCRIPTOR' @ [222:49] ==> public final val DECLARATION_TO_DESCRIPTOR: (ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'element' @ [222:76] ==> value-parameter element: KtNamedFunction defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.applyTo[ValueParameterDescriptorImpl]

'Converter' @ [223:9] ==> public constructor Converter(project: Project, editor: Editor?, descriptor: FunctionDescriptor) defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter[ClassConstructorDescriptorImpl]

'element' @ [223:19] ==> value-parameter element: KtNamedFunction defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.applyTo[ValueParameterDescriptorImpl]

'project' @ [223:27] ==> public final val KtNamedFunction.project: Project[MyPropertyDescriptor]

'editor' @ [223:36] ==> value-parameter editor: Editor? defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.applyTo[ValueParameterDescriptorImpl]

'descriptor' @ [223:44] ==> val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.applyTo[LocalVariableDescriptor]

'run' @ [223:56] ==> public final fun run(): Boolean defined in org.jetbrains.kotlin.idea.intentions.ConvertFunctionToPropertyIntention.Converter[SimpleFunctionDescriptorImpl]

