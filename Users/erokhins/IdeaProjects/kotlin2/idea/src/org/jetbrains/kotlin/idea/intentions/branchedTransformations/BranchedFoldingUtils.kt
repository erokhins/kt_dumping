'expression' @ [33:17] ==> value-parameter expression: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableBranchedAssignment.checkAssignment[ValueParameterDescriptorImpl]

'operationToken' @ [33:28] ==> public final val KtBinaryExpression.operationToken: IElementType[MyPropertyDescriptor]

'ALL_ASSIGNMENTS' @ [33:56] ==> public final val ALL_ASSIGNMENTS: (TokenSet..TokenSet?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'expression' @ [35:24] ==> value-parameter expression: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableBranchedAssignment.checkAssignment[ValueParameterDescriptorImpl]

'left' @ [35:35] ==> public final val KtBinaryExpression.left: KtExpression?[MyPropertyDescriptor]

'expression' @ [36:17] ==> value-parameter expression: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableBranchedAssignment.checkAssignment[ValueParameterDescriptorImpl]

'right' @ [36:28] ==> public final val KtBinaryExpression.right: KtExpression?[MyPropertyDescriptor]

'expression' @ [38:26] ==> value-parameter expression: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableBranchedAssignment.checkAssignment[ValueParameterDescriptorImpl]

'parent' @ [38:37] ==> public final val KtBinaryExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [39:17] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableBranchedAssignment.checkAssignment[LocalVariableDescriptor]

'!' @ [40:24] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'checkVariableDeclarationInBlock' @ [40:35] ==> public open fun checkVariableDeclarationInBlock(@NotNull p0: KtBlockExpression, @NotNull p1: String): Boolean defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'parent' @ [40:67] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableBranchedAssignment.checkAssignment[LocalVariableDescriptor]

'left' @ [40:75] ==> val left: KtNameReferenceExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableBranchedAssignment.checkAssignment[LocalVariableDescriptor]

'text' @ [40:80] ==> public final val KtNameReferenceExpression.text: (String..String?)[MyPropertyDescriptor]

'branch' @ [45:17] ==> value-parameter branch: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableBranchedAssignment[ValueParameterDescriptorImpl]

'lastBlockStatementOrThis' @ [45:25] ==> public fun KtExpression.lastBlockStatementOrThis(): KtExpression defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'takeIf' @ [45:77] ==> @InlineOnly @SinceKotlin public inline fun <T> KtBinaryExpression.takeIf(predicate: (KtBinaryExpression) -> Boolean): KtBinaryExpression? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtBinaryExpression

'checkAssignment' @ [45:86] ==> local final fun checkAssignment(expression: KtBinaryExpression): Boolean defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableBranchedAssignment[SimpleFunctionDescriptorImpl]

'branch' @ [49:14] ==> value-parameter branch: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableBranchedReturn[ValueParameterDescriptorImpl]

'lastBlockStatementOrThis' @ [49:22] ==> public fun KtExpression.lastBlockStatementOrThis(): KtExpression defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'takeIf' @ [49:74] ==> @InlineOnly @SinceKotlin public inline fun <T> KtReturnExpression.takeIf(predicate: (KtReturnExpression) -> Boolean): KtReturnExpression? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtReturnExpression

'it' @ [50:17] ==> value-parameter it: KtReturnExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableBranchedReturn.<anonymous>[ValueParameterDescriptorImpl]

'returnedExpression' @ [50:20] ==> public final val KtReturnExpression.returnedExpression: KtExpression?[MyPropertyDescriptor]

'it' @ [51:17] ==> value-parameter it: KtReturnExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableBranchedReturn.<anonymous>[ValueParameterDescriptorImpl]

'returnedExpression' @ [51:20] ==> public final val KtReturnExpression.returnedExpression: KtExpression?[MyPropertyDescriptor]

'it' @ [52:17] ==> value-parameter it: KtReturnExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableBranchedReturn.<anonymous>[ValueParameterDescriptorImpl]

'getTargetLabel' @ [52:20] ==> public final fun getTargetLabel(): KtSimpleNameExpression? defined in org.jetbrains.kotlin.psi.KtReturnExpression[DeserializedSimpleFunctionDescriptor]

'a1' @ [56:13] ==> value-parameter a1: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.checkAssignmentsMatch[ValueParameterDescriptorImpl]

'left' @ [56:16] ==> public final val KtBinaryExpression.left: KtExpression?[MyPropertyDescriptor]

'text' @ [56:22] ==> public final val KtExpression.text: (String..String?)[MyPropertyDescriptor]

'a2' @ [56:30] ==> value-parameter a2: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.checkAssignmentsMatch[ValueParameterDescriptorImpl]

'left' @ [56:33] ==> public final val KtBinaryExpression.left: KtExpression?[MyPropertyDescriptor]

'text' @ [56:39] ==> public final val KtExpression.text: (String..String?)[MyPropertyDescriptor]

'a1' @ [56:47] ==> value-parameter a1: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.checkAssignmentsMatch[ValueParameterDescriptorImpl]

'operationToken' @ [56:50] ==> public final val KtBinaryExpression.operationToken: IElementType[MyPropertyDescriptor]

'a2' @ [56:68] ==> value-parameter a2: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.checkAssignmentsMatch[ValueParameterDescriptorImpl]

'operationToken' @ [56:71] ==> public final val KtBinaryExpression.operationToken: IElementType[MyPropertyDescriptor]

'expression' @ [59:9] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber[ValueParameterDescriptorImpl]

'-' @ [59:30] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'linkedSetOf' @ [60:27] ==> @SinceKotlin @InlineOnly public inline fun <T> linkedSetOf(): LinkedHashSet<KtBinaryExpression> /* = LinkedHashSet<KtBinaryExpression> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtBinaryExpression

'when (e) {
            is KtWhenExpression -> {
                val entries = e.entries
                !e.hasMissingCases() &&
                entries.isNotEmpty() &&
                entries.all { entry ->
                    val assignment = getFoldableBranchedAssignment(entry.expression)?.run { assignments.add(this) }
                    assignment != null || collectAssignmentsAndCheck(entry.expression?.lastBlockStatementOrThis())
                }
            }
            is KtIfExpression -> {
                val branches = e.branches
                branches.size > 1 &&
                (branches.lastOrNull()?.getStrictParentOfType<KtIfExpression>()?.`else` != null) &&
                branches.all { branch ->
                    val assignment = getFoldableBranchedAssignment(branch)?.run { assignments.add(this) }
                    assignment != null || collectAssignmentsAndCheck(branch?.lastBlockStatementOrThis())
                }
            }
            is KtTryExpression -> {
                e.tryBlockAndCatchBodies().all {
                    val assignment = getFoldableBranchedAssignment(it)?.run { assignments.add(this) }
                    assignment != null || collectAssignmentsAndCheck(it?.lastBlockStatementOrThis())
                }
            }
            is KtCallExpression -> {
                e.analyze().getType(e)?.isNothing() ?: false
            }
            is KtBreakExpression, is KtContinueExpression,
            is KtThrowExpression, is KtReturnExpression -> true
            else -> false
        }' @ [61:69] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean, entry2: Boolean, entry3: Boolean, entry4: Boolean, entry5: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'e' @ [61:75] ==> value-parameter e: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.collectAssignmentsAndCheck[ValueParameterDescriptorImpl]

'e' @ [63:31] ==> value-parameter e: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.collectAssignmentsAndCheck[ValueParameterDescriptorImpl]

'entries' @ [63:33] ==> public final val KtWhenExpression.entries: (MutableList<(KtWhenEntry..KtWhenEntry?)>..List<(KtWhenEntry..KtWhenEntry?)>)[MyPropertyDescriptor]

'!' @ [64:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'e' @ [64:18] ==> value-parameter e: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.collectAssignmentsAndCheck[ValueParameterDescriptorImpl]

'hasMissingCases' @ [64:20] ==> private final fun KtWhenExpression.hasMissingCases(): Boolean defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'entries' @ [65:17] ==> val entries: (MutableList<(KtWhenEntry..KtWhenEntry?)>..List<(KtWhenEntry..KtWhenEntry?)>) defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.collectAssignmentsAndCheck[LocalVariableDescriptor]

'isNotEmpty' @ [65:25] ==> @InlineOnly public inline fun <T> Collection<(KtWhenEntry..KtWhenEntry?)>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtWhenEntry..org.jetbrains.kotlin.psi.KtWhenEntry?)

'entries' @ [66:17] ==> val entries: (MutableList<(KtWhenEntry..KtWhenEntry?)>..List<(KtWhenEntry..KtWhenEntry?)>) defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.collectAssignmentsAndCheck[LocalVariableDescriptor]

'all' @ [66:25] ==> public inline fun <T> Iterable<(KtWhenEntry..KtWhenEntry?)>.all(predicate: ((KtWhenEntry..KtWhenEntry?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtWhenEntry..org.jetbrains.kotlin.psi.KtWhenEntry?)

'getFoldableBranchedAssignment' @ [67:38] ==> private final fun getFoldableBranchedAssignment(branch: KtExpression?): KtBinaryExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'entry' @ [67:68] ==> value-parameter entry: (KtWhenEntry..KtWhenEntry?) defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.collectAssignmentsAndCheck.<anonymous>[ValueParameterDescriptorImpl]

'expression' @ [67:74] ==> public final val KtWhenEntry.expression: KtExpression?[MyPropertyDescriptor]

'run' @ [67:87] ==> @InlineOnly public inline fun <T, R> KtBinaryExpression.run(block: KtBinaryExpression.() -> Boolean): Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtBinaryExpression
    <R> -> Boolean

'assignments' @ [67:93] ==> val assignments: LinkedHashSet<KtBinaryExpression> /* = LinkedHashSet<KtBinaryExpression> */ defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber[LocalVariableDescriptor]

'add' @ [67:105] ==> public open fun add(element: KtBinaryExpression): Boolean defined in java.util.LinkedHashSet[JavaMethodDescriptor]

'this' @ [67:109] ==> <this> defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.collectAssignmentsAndCheck.<anonymous>.<anonymous>[ReceiverParameterDescriptorImpl]

'assignment' @ [68:21] ==> val assignment: Boolean? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.collectAssignmentsAndCheck.<anonymous>[LocalVariableDescriptor]

'collectAssignmentsAndCheck' @ [68:43] ==> local final fun collectAssignmentsAndCheck(e: KtExpression?): Boolean defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber[SimpleFunctionDescriptorImpl]

'entry' @ [68:70] ==> value-parameter entry: (KtWhenEntry..KtWhenEntry?) defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.collectAssignmentsAndCheck.<anonymous>[ValueParameterDescriptorImpl]

'expression' @ [68:76] ==> public final val KtWhenEntry.expression: KtExpression?[MyPropertyDescriptor]

'lastBlockStatementOrThis' @ [68:88] ==> public fun KtExpression.lastBlockStatementOrThis(): KtExpression defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'e' @ [72:32] ==> value-parameter e: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.collectAssignmentsAndCheck[ValueParameterDescriptorImpl]

'branches' @ [72:34] ==> public val KtIfExpression.branches: List<KtExpression?> defined in org.jetbrains.kotlin.idea.intentions in file Utils.kt[PropertyDescriptorImpl]

'branches' @ [73:17] ==> val branches: List<KtExpression?> defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.collectAssignmentsAndCheck[LocalVariableDescriptor]

'size' @ [73:26] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'branches' @ [74:18] ==> val branches: List<KtExpression?> defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.collectAssignmentsAndCheck[LocalVariableDescriptor]

'lastOrNull' @ [74:27] ==> public fun <T> List<KtExpression?>.lastOrNull(): KtExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression?

'getStrictParentOfType' @ [74:41] ==> public inline fun <reified T : PsiElement> PsiElement.getStrictParentOfType(): KtIfExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtIfExpression

'`else`' @ [74:82] ==> public final val KtIfExpression.`else`: KtExpression?[MyPropertyDescriptor]

'branches' @ [75:17] ==> val branches: List<KtExpression?> defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.collectAssignmentsAndCheck[LocalVariableDescriptor]

'all' @ [75:26] ==> public inline fun <T> Iterable<KtExpression?>.all(predicate: (KtExpression?) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression?

'getFoldableBranchedAssignment' @ [76:38] ==> private final fun getFoldableBranchedAssignment(branch: KtExpression?): KtBinaryExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'branch' @ [76:68] ==> value-parameter branch: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.collectAssignmentsAndCheck.<anonymous>[ValueParameterDescriptorImpl]

'run' @ [76:77] ==> @InlineOnly public inline fun <T, R> KtBinaryExpression.run(block: KtBinaryExpression.() -> Boolean): Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtBinaryExpression
    <R> -> Boolean

'assignments' @ [76:83] ==> val assignments: LinkedHashSet<KtBinaryExpression> /* = LinkedHashSet<KtBinaryExpression> */ defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber[LocalVariableDescriptor]

'add' @ [76:95] ==> public open fun add(element: KtBinaryExpression): Boolean defined in java.util.LinkedHashSet[JavaMethodDescriptor]

'this' @ [76:99] ==> <this> defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.collectAssignmentsAndCheck.<anonymous>.<anonymous>[ReceiverParameterDescriptorImpl]

'assignment' @ [77:21] ==> val assignment: Boolean? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.collectAssignmentsAndCheck.<anonymous>[LocalVariableDescriptor]

'collectAssignmentsAndCheck' @ [77:43] ==> local final fun collectAssignmentsAndCheck(e: KtExpression?): Boolean defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber[SimpleFunctionDescriptorImpl]

'branch' @ [77:70] ==> value-parameter branch: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.collectAssignmentsAndCheck.<anonymous>[ValueParameterDescriptorImpl]

'lastBlockStatementOrThis' @ [77:78] ==> public fun KtExpression.lastBlockStatementOrThis(): KtExpression defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'e' @ [81:17] ==> value-parameter e: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.collectAssignmentsAndCheck[ValueParameterDescriptorImpl]

'tryBlockAndCatchBodies' @ [81:19] ==> private final fun KtTryExpression.tryBlockAndCatchBodies(): List<KtExpression?> defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'all' @ [81:44] ==> public inline fun <T> Iterable<KtExpression?>.all(predicate: (KtExpression?) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression?

'getFoldableBranchedAssignment' @ [82:38] ==> private final fun getFoldableBranchedAssignment(branch: KtExpression?): KtBinaryExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'it' @ [82:68] ==> value-parameter it: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.collectAssignmentsAndCheck.<anonymous>[ValueParameterDescriptorImpl]

'run' @ [82:73] ==> @InlineOnly public inline fun <T, R> KtBinaryExpression.run(block: KtBinaryExpression.() -> Boolean): Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtBinaryExpression
    <R> -> Boolean

'assignments' @ [82:79] ==> val assignments: LinkedHashSet<KtBinaryExpression> /* = LinkedHashSet<KtBinaryExpression> */ defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber[LocalVariableDescriptor]

'add' @ [82:91] ==> public open fun add(element: KtBinaryExpression): Boolean defined in java.util.LinkedHashSet[JavaMethodDescriptor]

'this' @ [82:95] ==> <this> defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.collectAssignmentsAndCheck.<anonymous>.<anonymous>[ReceiverParameterDescriptorImpl]

'assignment' @ [83:21] ==> val assignment: Boolean? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.collectAssignmentsAndCheck.<anonymous>[LocalVariableDescriptor]

'collectAssignmentsAndCheck' @ [83:43] ==> local final fun collectAssignmentsAndCheck(e: KtExpression?): Boolean defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber[SimpleFunctionDescriptorImpl]

'it' @ [83:70] ==> value-parameter it: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.collectAssignmentsAndCheck.<anonymous>[ValueParameterDescriptorImpl]

'lastBlockStatementOrThis' @ [83:74] ==> public fun KtExpression.lastBlockStatementOrThis(): KtExpression defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'e' @ [87:17] ==> value-parameter e: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.collectAssignmentsAndCheck[ValueParameterDescriptorImpl]

'analyze' @ [87:19] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'getType' @ [87:29] ==> @Nullable public abstract fun getType(@NotNull p0: KtExpression): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]

'e' @ [87:37] ==> value-parameter e: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.collectAssignmentsAndCheck[ValueParameterDescriptorImpl]

'isNothing' @ [87:41] ==> public fun KotlinType.isNothing(): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'!' @ [93:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'collectAssignmentsAndCheck' @ [93:14] ==> local final fun collectAssignmentsAndCheck(e: KtExpression?): Boolean defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber[SimpleFunctionDescriptorImpl]

'expression' @ [93:41] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber[ValueParameterDescriptorImpl]

'-' @ [93:61] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'assignments' @ [94:31] ==> val assignments: LinkedHashSet<KtBinaryExpression> /* = LinkedHashSet<KtBinaryExpression> */ defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber[LocalVariableDescriptor]

'firstOrNull' @ [94:43] ==> public fun <T> Iterable<KtBinaryExpression>.firstOrNull(): KtBinaryExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtBinaryExpression

'assignments' @ [95:13] ==> val assignments: LinkedHashSet<KtBinaryExpression> /* = LinkedHashSet<KtBinaryExpression> */ defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber[LocalVariableDescriptor]

'any' @ [95:25] ==> public inline fun <T> Iterable<KtBinaryExpression>.any(predicate: (KtBinaryExpression) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtBinaryExpression

'!' @ [95:31] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'BranchedFoldingUtils' @ [95:32] ==> public object BranchedFoldingUtils defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations in file BranchedFoldingUtils.kt[FakeCallableDescriptorForObject]

'checkAssignmentsMatch' @ [95:53] ==> private final fun checkAssignmentsMatch(a1: KtBinaryExpression, a2: KtBinaryExpression): Boolean defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'it' @ [95:75] ==> value-parameter it: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.<anonymous>[ValueParameterDescriptorImpl]

'firstAssignment' @ [95:79] ==> val firstAssignment: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber[LocalVariableDescriptor]

'-' @ [96:20] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'expression' @ [98:13] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber[ValueParameterDescriptorImpl]

'anyDescendantOfType' @ [98:24] ==> public inline fun <reified T : PsiElement> PsiElement.anyDescendantOfType(noinline predicate: (KtBinaryExpression) -> Boolean = ...): Boolean defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtBinaryExpression

'if (it.operationToken in KtTokens.ALL_ASSIGNMENTS)
                        if (it.getNonStrictParentOfType<KtFinallySection>() != null)
                            BranchedFoldingUtils.checkAssignmentsMatch(it, firstAssignment)
                        else
                            it !in assignments
                    else
                        false' @ [100:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Boolean, elseBranch: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Boolean

'it' @ [100:25] ==> value-parameter it: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.<anonymous>[ValueParameterDescriptorImpl]

'operationToken' @ [100:28] ==> public final val KtBinaryExpression.operationToken: IElementType[MyPropertyDescriptor]

'ALL_ASSIGNMENTS' @ [100:55] ==> public final val ALL_ASSIGNMENTS: (TokenSet..TokenSet?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'if (it.getNonStrictParentOfType<KtFinallySection>() != null)
                            BranchedFoldingUtils.checkAssignmentsMatch(it, firstAssignment)
                        else
                            it !in assignments' @ [101:25] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Boolean, elseBranch: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Boolean

'it' @ [101:29] ==> value-parameter it: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.<anonymous>[ValueParameterDescriptorImpl]

'getNonStrictParentOfType' @ [101:32] ==> public inline fun <reified T : PsiElement> PsiElement.getNonStrictParentOfType(): KtFinallySection? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtFinallySection

'checkAssignmentsMatch' @ [102:50] ==> private final fun checkAssignmentsMatch(a1: KtBinaryExpression, a2: KtBinaryExpression): Boolean defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'it' @ [102:72] ==> value-parameter it: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.<anonymous>[ValueParameterDescriptorImpl]

'firstAssignment' @ [102:76] ==> val firstAssignment: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber[LocalVariableDescriptor]

'it' @ [104:29] ==> value-parameter it: KtBinaryExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber.<anonymous>[ValueParameterDescriptorImpl]

'assignments' @ [104:36] ==> val assignments: LinkedHashSet<KtBinaryExpression> /* = LinkedHashSet<KtBinaryExpression> */ defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber[LocalVariableDescriptor]

'-' @ [109:20] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'assignments' @ [111:16] ==> val assignments: LinkedHashSet<KtBinaryExpression> /* = LinkedHashSet<KtBinaryExpression> */ defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableAssignmentNumber[LocalVariableDescriptor]

'size' @ [111:28] ==> public open val size: Int defined in java.util.LinkedHashSet[JavaPropertyDescriptor]

'branches' @ [115:13] ==> value-parameter branches: List<KtExpression?> defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns[ValueParameterDescriptorImpl]

'fold' @ [115:22] ==> public inline fun <T, R> Iterable<KtExpression?>.fold(initial: MutableList<KtReturnExpression>?, operation: (acc: MutableList<KtReturnExpression>?, KtExpression?) -> MutableList<KtReturnExpression>?): MutableList<KtReturnExpression>? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression?
    <R> -> MutableList<KtReturnExpression>?

'mutableListOf' @ [115:76] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableListOf(): MutableList<KtReturnExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtReturnExpression

'prevList' @ [116:21] ==> value-parameter prevList: MutableList<KtReturnExpression>? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns.<anonymous>[ValueParameterDescriptorImpl]

'getFoldableBranchedReturn' @ [117:46] ==> public final fun getFoldableBranchedReturn(branch: KtExpression?): KtReturnExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'branch' @ [117:72] ==> value-parameter branch: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns.<anonymous>[ValueParameterDescriptorImpl]

'if (foldableBranchedReturn != null) {
                    prevList.add(foldableBranchedReturn)
                }
                else {
                    val currReturns = getFoldableReturns(branch?.lastBlockStatementOrThis()) ?: return@fold null
                    prevList += currReturns
                }' @ [118:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any, elseBranch: Any): Any[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any

'foldableBranchedReturn' @ [118:21] ==> val foldableBranchedReturn: KtReturnExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns.<anonymous>[LocalVariableDescriptor]

'prevList' @ [119:21] ==> value-parameter prevList: MutableList<KtReturnExpression>? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns.<anonymous>[ValueParameterDescriptorImpl]

'add' @ [119:30] ==> public abstract fun add(element: KtReturnExpression): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'foldableBranchedReturn' @ [119:34] ==> val foldableBranchedReturn: KtReturnExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns.<anonymous>[LocalVariableDescriptor]

'getFoldableReturns' @ [122:39] ==> internal final fun getFoldableReturns(expression: KtExpression?): List<KtReturnExpression>? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'branch' @ [122:58] ==> value-parameter branch: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns.<anonymous>[ValueParameterDescriptorImpl]

'lastBlockStatementOrThis' @ [122:66] ==> public fun KtExpression.lastBlockStatementOrThis(): KtExpression defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'prevList' @ [123:21] ==> value-parameter prevList: MutableList<KtReturnExpression>? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns.<anonymous>[ValueParameterDescriptorImpl]

'currReturns' @ [123:33] ==> val currReturns: List<KtReturnExpression> defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns.<anonymous>[LocalVariableDescriptor]

'prevList' @ [125:17] ==> value-parameter prevList: MutableList<KtReturnExpression>? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns.<anonymous>[ValueParameterDescriptorImpl]

'when (expression) {
        is KtWhenExpression -> {
            val entries = expression.entries
            when {
                expression.hasMissingCases() -> null
                entries.isEmpty() -> null
                else -> getFoldableReturns(entries.map { it.expression })
            }
        }
        is KtIfExpression -> {
            val branches = expression.branches
            when {
                branches.isEmpty() -> null
                branches.lastOrNull()?.getStrictParentOfType<KtIfExpression>()?.`else` == null -> null
                else -> getFoldableReturns(branches)
            }
        }
        is KtTryExpression -> {
            if (expression.finallyBlock?.finalExpression?.let { getFoldableReturns(listOf(it)) }?.isNotEmpty() == true)
                null
            else
                getFoldableReturns(expression.tryBlockAndCatchBodies())
        }
        is KtCallExpression -> {
            if (expression.analyze().getType(expression)?.isNothing() == true) emptyList() else null
        }
        is KtBreakExpression, is KtContinueExpression, is KtThrowExpression -> emptyList()
        else -> null
    }' @ [128:93] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: List<KtReturnExpression>?, entry1: List<KtReturnExpression>?, entry2: List<KtReturnExpression>?, entry3: List<KtReturnExpression>?, entry4: List<KtReturnExpression>?, entry5: List<KtReturnExpression>?): List<KtReturnExpression>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> List<KtReturnExpression>?

'expression' @ [128:99] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns[ValueParameterDescriptorImpl]

'expression' @ [130:27] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns[ValueParameterDescriptorImpl]

'entries' @ [130:38] ==> public final val KtWhenExpression.entries: (MutableList<(KtWhenEntry..KtWhenEntry?)>..List<(KtWhenEntry..KtWhenEntry?)>)[MyPropertyDescriptor]

'when {
                expression.hasMissingCases() -> null
                entries.isEmpty() -> null
                else -> getFoldableReturns(entries.map { it.expression })
            }' @ [131:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: List<KtReturnExpression>?, entry1: List<KtReturnExpression>?, entry2: List<KtReturnExpression>?): List<KtReturnExpression>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> List<KtReturnExpression>?

'expression' @ [132:17] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns[ValueParameterDescriptorImpl]

'hasMissingCases' @ [132:28] ==> private final fun KtWhenExpression.hasMissingCases(): Boolean defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'entries' @ [133:17] ==> val entries: (MutableList<(KtWhenEntry..KtWhenEntry?)>..List<(KtWhenEntry..KtWhenEntry?)>) defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns[LocalVariableDescriptor]

'isEmpty' @ [133:25] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'getFoldableReturns' @ [134:25] ==> private final fun getFoldableReturns(branches: List<KtExpression?>): List<KtReturnExpression>? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'entries' @ [134:44] ==> val entries: (MutableList<(KtWhenEntry..KtWhenEntry?)>..List<(KtWhenEntry..KtWhenEntry?)>) defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns[LocalVariableDescriptor]

'map' @ [134:52] ==> public inline fun <T, R> Iterable<(KtWhenEntry..KtWhenEntry?)>.map(transform: ((KtWhenEntry..KtWhenEntry?)) -> KtExpression?): List<KtExpression?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtWhenEntry..org.jetbrains.kotlin.psi.KtWhenEntry?)
    <R> -> KtExpression?

'it' @ [134:58] ==> value-parameter it: (KtWhenEntry..KtWhenEntry?) defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns.<anonymous>[ValueParameterDescriptorImpl]

'expression' @ [134:61] ==> public final val KtWhenEntry.expression: KtExpression?[MyPropertyDescriptor]

'expression' @ [138:28] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns[ValueParameterDescriptorImpl]

'branches' @ [138:39] ==> public val KtIfExpression.branches: List<KtExpression?> defined in org.jetbrains.kotlin.idea.intentions in file Utils.kt[PropertyDescriptorImpl]

'when {
                branches.isEmpty() -> null
                branches.lastOrNull()?.getStrictParentOfType<KtIfExpression>()?.`else` == null -> null
                else -> getFoldableReturns(branches)
            }' @ [139:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: List<KtReturnExpression>?, entry1: List<KtReturnExpression>?, entry2: List<KtReturnExpression>?): List<KtReturnExpression>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> List<KtReturnExpression>?

'branches' @ [140:17] ==> val branches: List<KtExpression?> defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns[LocalVariableDescriptor]

'isEmpty' @ [140:26] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'branches' @ [141:17] ==> val branches: List<KtExpression?> defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns[LocalVariableDescriptor]

'lastOrNull' @ [141:26] ==> public fun <T> List<KtExpression?>.lastOrNull(): KtExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression?

'getStrictParentOfType' @ [141:40] ==> public inline fun <reified T : PsiElement> PsiElement.getStrictParentOfType(): KtIfExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtIfExpression

'`else`' @ [141:81] ==> public final val KtIfExpression.`else`: KtExpression?[MyPropertyDescriptor]

'getFoldableReturns' @ [142:25] ==> private final fun getFoldableReturns(branches: List<KtExpression?>): List<KtReturnExpression>? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'branches' @ [142:44] ==> val branches: List<KtExpression?> defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns[LocalVariableDescriptor]

'if (expression.finallyBlock?.finalExpression?.let { getFoldableReturns(listOf(it)) }?.isNotEmpty() == true)
                null
            else
                getFoldableReturns(expression.tryBlockAndCatchBodies())' @ [146:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<KtReturnExpression>?, elseBranch: List<KtReturnExpression>?): List<KtReturnExpression>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<KtReturnExpression>?

'expression' @ [146:17] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns[ValueParameterDescriptorImpl]

'finallyBlock' @ [146:28] ==> public final val KtTryExpression.finallyBlock: KtFinallySection?[MyPropertyDescriptor]

'finalExpression' @ [146:42] ==> public final val KtFinallySection.finalExpression: (KtBlockExpression..KtBlockExpression?)[MyPropertyDescriptor]

'let' @ [146:59] ==> @InlineOnly public inline fun <T, R> KtBlockExpression.let(block: (KtBlockExpression) -> List<KtReturnExpression>?): List<KtReturnExpression>? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtBlockExpression
    <R> -> List<KtReturnExpression>?

'getFoldableReturns' @ [146:65] ==> private final fun getFoldableReturns(branches: List<KtExpression?>): List<KtReturnExpression>? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'listOf' @ [146:84] ==> public fun <T> listOf(element: KtBlockExpression): List<KtBlockExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtBlockExpression

'it' @ [146:91] ==> value-parameter it: KtBlockExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns.<anonymous>[ValueParameterDescriptorImpl]

'isNotEmpty' @ [146:99] ==> @InlineOnly public inline fun <T> Collection<KtReturnExpression>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtReturnExpression

'getFoldableReturns' @ [149:17] ==> private final fun getFoldableReturns(branches: List<KtExpression?>): List<KtReturnExpression>? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'expression' @ [149:36] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns[ValueParameterDescriptorImpl]

'tryBlockAndCatchBodies' @ [149:47] ==> private final fun KtTryExpression.tryBlockAndCatchBodies(): List<KtExpression?> defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'if (expression.analyze().getType(expression)?.isNothing() == true) emptyList() else null' @ [152:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<KtReturnExpression>?, elseBranch: List<KtReturnExpression>?): List<KtReturnExpression>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<KtReturnExpression>?

'expression' @ [152:17] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns[ValueParameterDescriptorImpl]

'analyze' @ [152:28] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'getType' @ [152:38] ==> @Nullable public abstract fun getType(@NotNull p0: KtExpression): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]

'expression' @ [152:46] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturns[ValueParameterDescriptorImpl]

'isNothing' @ [152:59] ==> public fun KotlinType.isNothing(): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'emptyList' @ [152:80] ==> public fun <T> emptyList(): List<KtReturnExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtReturnExpression

'emptyList' @ [154:80] ==> public fun <T> emptyList(): List<KtReturnExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtReturnExpression

'getFoldableReturns' @ [158:70] ==> internal final fun getFoldableReturns(expression: KtExpression?): List<KtReturnExpression>? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'expression' @ [158:89] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.getFoldableReturnNumber[ValueParameterDescriptorImpl]

'size' @ [158:102] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'-' @ [158:110] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'getFoldableReturnNumber' @ [160:63] ==> private final fun getFoldableReturnNumber(expression: KtExpression?): Int defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'expression' @ [160:87] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.canFoldToReturn[ValueParameterDescriptorImpl]

'lhs' @ [166:17] ==> var lhs: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment[LocalVariableDescriptor]

'op' @ [166:32] ==> var op: String? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment[LocalVariableDescriptor]

'lhs' @ [167:17] ==> var lhs: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment[LocalVariableDescriptor]

'left' @ [167:23] ==> public final val KtBinaryExpression.left: KtExpression?[MyPropertyDescriptor]

'copy' @ [167:30] ==> public abstract fun copy(): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtExpression[JavaMethodDescriptor]

'op' @ [168:17] ==> var op: String? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment[LocalVariableDescriptor]

'operationReference' @ [168:22] ==> public final val KtBinaryExpression.operationReference: KtOperationReferenceExpression[MyPropertyDescriptor]

'text' @ [168:41] ==> public final val KtOperationReferenceExpression.text: (String..String?)[MyPropertyDescriptor]

'replace' @ [170:13] ==> public open fun replace(newElement: PsiElement): PsiElement defined in org.jetbrains.kotlin.psi.KtBinaryExpression[DeserializedSimpleFunctionDescriptor]

'right' @ [170:21] ==> public final val KtBinaryExpression.right: KtExpression?[MyPropertyDescriptor]

'when (e) {
                is KtWhenExpression -> e.entries.forEach { entry ->
                    getFoldableBranchedAssignment(entry.expression)?.replaceWithRHS() ?: lift(entry.expression?.lastBlockStatementOrThis())
                }
                is KtIfExpression -> e.branches.forEach { branch ->
                    getFoldableBranchedAssignment(branch)?.replaceWithRHS() ?: lift(branch?.lastBlockStatementOrThis())
                }
                is KtTryExpression -> e.tryBlockAndCatchBodies().forEach {
                    getFoldableBranchedAssignment(it)?.replaceWithRHS() ?: lift(it?.lastBlockStatementOrThis())
                }
            }' @ [173:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'e' @ [173:19] ==> value-parameter e: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment.lift[ValueParameterDescriptorImpl]

'e' @ [174:40] ==> value-parameter e: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment.lift[ValueParameterDescriptorImpl]

'entries' @ [174:42] ==> public final val KtWhenExpression.entries: (MutableList<(KtWhenEntry..KtWhenEntry?)>..List<(KtWhenEntry..KtWhenEntry?)>)[MyPropertyDescriptor]

'forEach' @ [174:50] ==> @HidesMembers public inline fun <T> Iterable<(KtWhenEntry..KtWhenEntry?)>.forEach(action: ((KtWhenEntry..KtWhenEntry?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtWhenEntry..org.jetbrains.kotlin.psi.KtWhenEntry?)

'getFoldableBranchedAssignment' @ [175:21] ==> private final fun getFoldableBranchedAssignment(branch: KtExpression?): KtBinaryExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'entry' @ [175:51] ==> value-parameter entry: (KtWhenEntry..KtWhenEntry?) defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment.lift.<anonymous>[ValueParameterDescriptorImpl]

'expression' @ [175:57] ==> public final val KtWhenEntry.expression: KtExpression?[MyPropertyDescriptor]

'replaceWithRHS' @ [175:70] ==> local final fun KtBinaryExpression.replaceWithRHS(): Unit defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment[SimpleFunctionDescriptorImpl]

'lift' @ [175:90] ==> local final fun lift(e: KtExpression?): Unit defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment[SimpleFunctionDescriptorImpl]

'entry' @ [175:95] ==> value-parameter entry: (KtWhenEntry..KtWhenEntry?) defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment.lift.<anonymous>[ValueParameterDescriptorImpl]

'expression' @ [175:101] ==> public final val KtWhenEntry.expression: KtExpression?[MyPropertyDescriptor]

'lastBlockStatementOrThis' @ [175:113] ==> public fun KtExpression.lastBlockStatementOrThis(): KtExpression defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'e' @ [177:38] ==> value-parameter e: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment.lift[ValueParameterDescriptorImpl]

'branches' @ [177:40] ==> public val KtIfExpression.branches: List<KtExpression?> defined in org.jetbrains.kotlin.idea.intentions in file Utils.kt[PropertyDescriptorImpl]

'forEach' @ [177:49] ==> @HidesMembers public inline fun <T> Iterable<KtExpression?>.forEach(action: (KtExpression?) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression?

'getFoldableBranchedAssignment' @ [178:21] ==> private final fun getFoldableBranchedAssignment(branch: KtExpression?): KtBinaryExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'branch' @ [178:51] ==> value-parameter branch: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment.lift.<anonymous>[ValueParameterDescriptorImpl]

'replaceWithRHS' @ [178:60] ==> local final fun KtBinaryExpression.replaceWithRHS(): Unit defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment[SimpleFunctionDescriptorImpl]

'lift' @ [178:80] ==> local final fun lift(e: KtExpression?): Unit defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment[SimpleFunctionDescriptorImpl]

'branch' @ [178:85] ==> value-parameter branch: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment.lift.<anonymous>[ValueParameterDescriptorImpl]

'lastBlockStatementOrThis' @ [178:93] ==> public fun KtExpression.lastBlockStatementOrThis(): KtExpression defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'e' @ [180:39] ==> value-parameter e: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment.lift[ValueParameterDescriptorImpl]

'tryBlockAndCatchBodies' @ [180:41] ==> private final fun KtTryExpression.tryBlockAndCatchBodies(): List<KtExpression?> defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'forEach' @ [180:66] ==> @HidesMembers public inline fun <T> Iterable<KtExpression?>.forEach(action: (KtExpression?) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression?

'getFoldableBranchedAssignment' @ [181:21] ==> private final fun getFoldableBranchedAssignment(branch: KtExpression?): KtBinaryExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'it' @ [181:51] ==> value-parameter it: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment.lift.<anonymous>[ValueParameterDescriptorImpl]

'replaceWithRHS' @ [181:56] ==> local final fun KtBinaryExpression.replaceWithRHS(): Unit defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment[SimpleFunctionDescriptorImpl]

'lift' @ [181:76] ==> local final fun lift(e: KtExpression?): Unit defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment[SimpleFunctionDescriptorImpl]

'it' @ [181:81] ==> value-parameter it: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment.lift.<anonymous>[ValueParameterDescriptorImpl]

'lastBlockStatementOrThis' @ [181:85] ==> public fun KtExpression.lastBlockStatementOrThis(): KtExpression defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'lift' @ [185:9] ==> local final fun lift(e: KtExpression?): Unit defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment[SimpleFunctionDescriptorImpl]

'expression' @ [185:14] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment[ValueParameterDescriptorImpl]

'expression' @ [186:9] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment[ValueParameterDescriptorImpl]

'replace' @ [186:20] ==> public abstract fun replace(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtExpression[JavaMethodDescriptor]

'KtPsiFactory' @ [186:28] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'expression' @ [186:41] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment[ValueParameterDescriptorImpl]

'createExpressionByPattern' @ [186:53] ==> public fun KtPsiFactory.createExpressionByPattern(pattern: String, vararg args: Any, reformat: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'lhs' @ [186:91] ==> var lhs: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment[LocalVariableDescriptor]

'op' @ [186:98] ==> var op: String? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment[LocalVariableDescriptor]

'expression' @ [186:104] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToAssignment[ValueParameterDescriptorImpl]

'replace' @ [191:13] ==> public open fun replace(newElement: PsiElement): PsiElement defined in org.jetbrains.kotlin.psi.KtReturnExpression[DeserializedSimpleFunctionDescriptor]

'returnedExpression' @ [191:21] ==> public final val KtReturnExpression.returnedExpression: KtExpression?[MyPropertyDescriptor]

'when (e) {
                is KtWhenExpression -> e.entries.forEach { entry ->
                    getFoldableBranchedReturn(entry.expression)?.replaceWithReturned()
                    ?: lift(entry.expression?.lastBlockStatementOrThis())
                }
                is KtIfExpression -> e.branches.forEach { branch ->
                    getFoldableBranchedReturn(branch)?.replaceWithReturned() ?:
                    lift(branch?.lastBlockStatementOrThis())
                }
                is KtTryExpression -> e.tryBlockAndCatchBodies().forEach {
                    getFoldableBranchedReturn(it)?.replaceWithReturned() ?:
                    lift(it?.lastBlockStatementOrThis())
                }
            }' @ [194:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'e' @ [194:19] ==> value-parameter e: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToReturn.lift[ValueParameterDescriptorImpl]

'e' @ [195:40] ==> value-parameter e: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToReturn.lift[ValueParameterDescriptorImpl]

'entries' @ [195:42] ==> public final val KtWhenExpression.entries: (MutableList<(KtWhenEntry..KtWhenEntry?)>..List<(KtWhenEntry..KtWhenEntry?)>)[MyPropertyDescriptor]

'forEach' @ [195:50] ==> @HidesMembers public inline fun <T> Iterable<(KtWhenEntry..KtWhenEntry?)>.forEach(action: ((KtWhenEntry..KtWhenEntry?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtWhenEntry..org.jetbrains.kotlin.psi.KtWhenEntry?)

'getFoldableBranchedReturn' @ [196:21] ==> public final fun getFoldableBranchedReturn(branch: KtExpression?): KtReturnExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'entry' @ [196:47] ==> value-parameter entry: (KtWhenEntry..KtWhenEntry?) defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToReturn.lift.<anonymous>[ValueParameterDescriptorImpl]

'expression' @ [196:53] ==> public final val KtWhenEntry.expression: KtExpression?[MyPropertyDescriptor]

'replaceWithReturned' @ [196:66] ==> local final fun KtReturnExpression.replaceWithReturned(): Unit defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToReturn[SimpleFunctionDescriptorImpl]

'lift' @ [197:24] ==> local final fun lift(e: KtExpression?): Unit defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToReturn[SimpleFunctionDescriptorImpl]

'entry' @ [197:29] ==> value-parameter entry: (KtWhenEntry..KtWhenEntry?) defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToReturn.lift.<anonymous>[ValueParameterDescriptorImpl]

'expression' @ [197:35] ==> public final val KtWhenEntry.expression: KtExpression?[MyPropertyDescriptor]

'lastBlockStatementOrThis' @ [197:47] ==> public fun KtExpression.lastBlockStatementOrThis(): KtExpression defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'e' @ [199:38] ==> value-parameter e: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToReturn.lift[ValueParameterDescriptorImpl]

'branches' @ [199:40] ==> public val KtIfExpression.branches: List<KtExpression?> defined in org.jetbrains.kotlin.idea.intentions in file Utils.kt[PropertyDescriptorImpl]

'forEach' @ [199:49] ==> @HidesMembers public inline fun <T> Iterable<KtExpression?>.forEach(action: (KtExpression?) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression?

'getFoldableBranchedReturn' @ [200:21] ==> public final fun getFoldableBranchedReturn(branch: KtExpression?): KtReturnExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'branch' @ [200:47] ==> value-parameter branch: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToReturn.lift.<anonymous>[ValueParameterDescriptorImpl]

'replaceWithReturned' @ [200:56] ==> local final fun KtReturnExpression.replaceWithReturned(): Unit defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToReturn[SimpleFunctionDescriptorImpl]

'lift' @ [201:21] ==> local final fun lift(e: KtExpression?): Unit defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToReturn[SimpleFunctionDescriptorImpl]

'branch' @ [201:26] ==> value-parameter branch: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToReturn.lift.<anonymous>[ValueParameterDescriptorImpl]

'lastBlockStatementOrThis' @ [201:34] ==> public fun KtExpression.lastBlockStatementOrThis(): KtExpression defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'e' @ [203:39] ==> value-parameter e: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToReturn.lift[ValueParameterDescriptorImpl]

'tryBlockAndCatchBodies' @ [203:41] ==> private final fun KtTryExpression.tryBlockAndCatchBodies(): List<KtExpression?> defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'forEach' @ [203:66] ==> @HidesMembers public inline fun <T> Iterable<KtExpression?>.forEach(action: (KtExpression?) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression?

'getFoldableBranchedReturn' @ [204:21] ==> public final fun getFoldableBranchedReturn(branch: KtExpression?): KtReturnExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils[SimpleFunctionDescriptorImpl]

'it' @ [204:47] ==> value-parameter it: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToReturn.lift.<anonymous>[ValueParameterDescriptorImpl]

'replaceWithReturned' @ [204:52] ==> local final fun KtReturnExpression.replaceWithReturned(): Unit defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToReturn[SimpleFunctionDescriptorImpl]

'lift' @ [205:21] ==> local final fun lift(e: KtExpression?): Unit defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToReturn[SimpleFunctionDescriptorImpl]

'it' @ [205:26] ==> value-parameter it: KtExpression? defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToReturn.lift.<anonymous>[ValueParameterDescriptorImpl]

'lastBlockStatementOrThis' @ [205:30] ==> public fun KtExpression.lastBlockStatementOrThis(): KtExpression defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'lift' @ [209:9] ==> local final fun lift(e: KtExpression?): Unit defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToReturn[SimpleFunctionDescriptorImpl]

'expression' @ [209:14] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToReturn[ValueParameterDescriptorImpl]

'expression' @ [210:9] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToReturn[ValueParameterDescriptorImpl]

'replace' @ [210:20] ==> public abstract fun replace(@NotNull p0: PsiElement): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtExpression[JavaMethodDescriptor]

'KtPsiFactory' @ [210:28] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'expression' @ [210:41] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToReturn[ValueParameterDescriptorImpl]

'createExpressionByPattern' @ [210:53] ==> public fun KtPsiFactory.createExpressionByPattern(pattern: String, vararg args: Any, reformat: Boolean = ...): KtExpression defined in org.jetbrains.kotlin.psi[DeserializedSimpleFunctionDescriptor]

'expression' @ [210:92] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.foldToReturn[ValueParameterDescriptorImpl]

'listOf' @ [213:81] ==> public fun <T> listOf(element: KtBlockExpression): List<KtBlockExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtBlockExpression

'tryBlock' @ [213:88] ==> public final val KtTryExpression.tryBlock: KtBlockExpression[MyPropertyDescriptor]

'catchClauses' @ [213:100] ==> public final val KtTryExpression.catchClauses: (MutableList<(KtCatchClause..KtCatchClause?)>..List<(KtCatchClause..KtCatchClause?)>)[MyPropertyDescriptor]

'map' @ [213:113] ==> public inline fun <T, R> Iterable<(KtCatchClause..KtCatchClause?)>.map(transform: ((KtCatchClause..KtCatchClause?)) -> KtExpression?): List<KtExpression?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtCatchClause..org.jetbrains.kotlin.psi.KtCatchClause?)
    <R> -> KtExpression?

'it' @ [213:119] ==> value-parameter it: (KtCatchClause..KtCatchClause?) defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.tryBlockAndCatchBodies.<anonymous>[ValueParameterDescriptorImpl]

'catchBody' @ [213:122] ==> public final val KtCatchClause.catchBody: KtExpression?[MyPropertyDescriptor]

'!' @ [216:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'checkWhenExpressionHasSingleElse' @ [216:24] ==> public open fun checkWhenExpressionHasSingleElse(@NotNull p0: KtWhenExpression): Boolean defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'this' @ [216:57] ==> <this> defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.hasMissingCases[ReceiverParameterDescriptorImpl]

'WhenChecker' @ [216:66] ==> public object WhenChecker defined in org.jetbrains.kotlin.cfg[FakeCallableDescriptorForObject]

'getMissingCases' @ [216:78] ==> public final fun getMissingCases(expression: KtWhenExpression, context: BindingContext): List<WhenMissingCase> defined in org.jetbrains.kotlin.cfg.WhenChecker[DeserializedSimpleFunctionDescriptor]

'this' @ [216:94] ==> <this> defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.hasMissingCases[ReceiverParameterDescriptorImpl]

'this' @ [216:100] ==> <this> defined in org.jetbrains.kotlin.idea.intentions.branchedTransformations.BranchedFoldingUtils.hasMissingCases[ReceiverParameterDescriptorImpl]

'analyze' @ [216:105] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'isNotEmpty' @ [216:116] ==> @InlineOnly public inline fun <T> Collection<WhenMissingCase>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> WhenMissingCase

