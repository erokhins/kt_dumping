'AbstractKotlinInspection' @ [43:43] ==> public constructor AbstractKotlinInspection() defined in org.jetbrains.kotlin.idea.inspections.AbstractKotlinInspection[DeserializedClassConstructorDescriptor]

'KtVisitorVoid' @ [47:25] ==> public constructor KtVisitorVoid() defined in org.jetbrains.kotlin.psi.KtVisitorVoid[JavaClassConstructorDescriptor]

'callableDeclaration' @ [49:45] ==> value-parameter callableDeclaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check[ValueParameterDescriptorImpl]

'receiverTypeReference' @ [49:65] ==> public final val KtCallableDeclaration.receiverTypeReference: KtTypeReference?[MyPropertyDescriptor]

'receiverTypeReference' @ [50:21] ==> val receiverTypeReference: KtTypeReference? defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check[LocalVariableDescriptor]

'receiverTypeReference' @ [50:54] ==> val receiverTypeReference: KtTypeReference? defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check[LocalVariableDescriptor]

'textRange' @ [50:76] ==> public final val KtTypeReference.textRange: (TextRange..TextRange?)[MyPropertyDescriptor]

'isEmpty' @ [50:86] ==> public final val TextRange.isEmpty: Boolean[MyPropertyDescriptor]

'callableDeclaration' @ [51:21] ==> value-parameter callableDeclaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check[ValueParameterDescriptorImpl]

'isOverridable' @ [51:41] ==> public fun KtDeclaration.isOverridable(): Boolean defined in org.jetbrains.kotlin.idea.core[DeserializedSimpleFunctionDescriptor]

'callableDeclaration' @ [51:60] ==> value-parameter callableDeclaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check[ValueParameterDescriptorImpl]

'hasModifier' @ [51:80] ==> public abstract fun hasModifier(@NotNull p0: KtModifierKeywordToken): Boolean defined in org.jetbrains.kotlin.psi.KtCallableDeclaration[JavaMethodDescriptor]

'OVERRIDE_KEYWORD' @ [51:101] ==> public final val OVERRIDE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'callableDeclaration' @ [53:21] ==> value-parameter callableDeclaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check[ValueParameterDescriptorImpl]

'callableDeclaration' @ [53:58] ==> value-parameter callableDeclaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check[ValueParameterDescriptorImpl]

'accessors' @ [53:78] ==> public final val KtProperty.accessors: (MutableList<(KtPropertyAccessor..KtPropertyAccessor?)>..List<(KtPropertyAccessor..KtPropertyAccessor?)>)[MyPropertyDescriptor]

'isEmpty' @ [53:88] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'callableDeclaration' @ [54:21] ==> value-parameter callableDeclaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check[ValueParameterDescriptorImpl]

'!' @ [54:63] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'callableDeclaration' @ [54:64] ==> value-parameter callableDeclaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check[ValueParameterDescriptorImpl]

'hasBody' @ [54:84] ==> public open fun hasBody(): Boolean defined in org.jetbrains.kotlin.psi.KtNamedFunction[JavaMethodDescriptor]

'callableDeclaration' @ [56:32] ==> value-parameter callableDeclaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check[ValueParameterDescriptorImpl]

'descriptor' @ [56:52] ==> public val KtDeclaration.descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.search.usagesSearch[DeserializedPropertyDescriptor]

'callable' @ [58:21] ==> val callable: DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check[LocalVariableDescriptor]

'MainFunctionDetector' @ [58:41] ==> public companion object defined in org.jetbrains.kotlin.idea.MainFunctionDetector[FakeCallableDescriptorForObject]

'isMain' @ [58:62] ==> public final fun isMain(descriptor: DeclarationDescriptor, checkJvmStaticAnnotation: Boolean = ...): Boolean defined in org.jetbrains.kotlin.idea.MainFunctionDetector.Companion[DeserializedSimpleFunctionDescriptor]

'callable' @ [58:69] ==> val callable: DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check[LocalVariableDescriptor]

'callableDeclaration' @ [61:17] ==> value-parameter callableDeclaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check[ValueParameterDescriptorImpl]

'acceptChildren' @ [61:37] ==> public abstract fun acceptChildren(@NotNull p0: PsiElementVisitor): Unit defined in org.jetbrains.kotlin.psi.KtCallableDeclaration[JavaMethodDescriptor]

'KtVisitorVoid' @ [61:61] ==> public constructor KtVisitorVoid() defined in org.jetbrains.kotlin.psi.KtVisitorVoid[JavaClassConstructorDescriptor]

'used' @ [63:29] ==> var used: Boolean defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check[LocalVariableDescriptor]

'element' @ [64:25] ==> value-parameter element: KtElement defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check.<no name provided>.visitKtElement[ValueParameterDescriptorImpl]

'acceptChildren' @ [64:33] ==> public abstract fun acceptChildren(@NotNull p0: PsiElementVisitor): Unit defined in org.jetbrains.kotlin.psi.KtElement[JavaMethodDescriptor]

'this' @ [64:48] ==> <this> defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check.<no name provided>[LazyClassReceiverParameterDescriptor]

'element' @ [66:46] ==> value-parameter element: KtElement defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check.<no name provided>.visitKtElement[ValueParameterDescriptorImpl]

'analyze' @ [66:54] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'element' @ [67:44] ==> value-parameter element: KtElement defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check.<no name provided>.visitKtElement[ValueParameterDescriptorImpl]

'getResolvedCall' @ [67:52] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [67:68] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check.<no name provided>.visitKtElement[LocalVariableDescriptor]

'if (isUsageOfReceiver(resolvedCall, bindingContext)) {
                            used = true
                        } else if (resolvedCall is VariableAsFunctionResolvedCall
                                   && isUsageOfReceiver(resolvedCall.variableCall, bindingContext)) {
                            used = true
                        }' @ [69:25] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'isUsageOfReceiver' @ [69:29] ==> private final fun isUsageOfReceiver(resolvedCall: ResolvedCall<*>, bindingContext: BindingContext): Boolean defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check.<no name provided>[SimpleFunctionDescriptorImpl]

'resolvedCall' @ [69:47] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check.<no name provided>.visitKtElement[LocalVariableDescriptor]

'bindingContext' @ [69:61] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check.<no name provided>.visitKtElement[LocalVariableDescriptor]

'used' @ [70:29] ==> var used: Boolean defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check[LocalVariableDescriptor]

'resolvedCall' @ [71:36] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check.<no name provided>.visitKtElement[LocalVariableDescriptor]

'isUsageOfReceiver' @ [72:39] ==> private final fun isUsageOfReceiver(resolvedCall: ResolvedCall<*>, bindingContext: BindingContext): Boolean defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check.<no name provided>[SimpleFunctionDescriptorImpl]

'resolvedCall' @ [72:57] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check.<no name provided>.visitKtElement[LocalVariableDescriptor]

'variableCall' @ [72:70] ==> public abstract val variableCall: ResolvedCall<VariableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.model.VariableAsFunctionResolvedCall[DeserializedPropertyDescriptor]

'bindingContext' @ [72:84] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check.<no name provided>.visitKtElement[LocalVariableDescriptor]

'used' @ [73:29] ==> var used: Boolean defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check[LocalVariableDescriptor]

'resolvedCall' @ [79:29] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check.<no name provided>.isUsageOfReceiver[ValueParameterDescriptorImpl]

'dispatchReceiver' @ [79:42] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.dispatchReceiver: ReceiverValue?[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(*)

'getThisReceiverOwner' @ [79:59] ==> public fun ReceiverValue?.getThisReceiverOwner(bindingContext: BindingContext): DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [79:80] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check.<no name provided>.isUsageOfReceiver[ValueParameterDescriptorImpl]

'callable' @ [79:99] ==> val callable: DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check[LocalVariableDescriptor]

'resolvedCall' @ [80:29] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check.<no name provided>.isUsageOfReceiver[ValueParameterDescriptorImpl]

'extensionReceiver' @ [80:42] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.extensionReceiver: ReceiverValue?[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(*)

'getThisReceiverOwner' @ [80:60] ==> public fun ReceiverValue?.getThisReceiverOwner(bindingContext: BindingContext): DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [80:81] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check.<no name provided>.isUsageOfReceiver[ValueParameterDescriptorImpl]

'callable' @ [80:100] ==> val callable: DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check[LocalVariableDescriptor]

'==' @ [84:29] ==> public open fun equals(other: Any?): Boolean defined in org.jetbrains.kotlin.descriptors.DeclarationDescriptor[DeserializedSimpleFunctionDescriptor]

'resolvedCall' @ [84:30] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check.<no name provided>.isUsageOfReceiver[ValueParameterDescriptorImpl]

'candidateDescriptor' @ [84:43] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.candidateDescriptor: (CallableDescriptor..CallableDescriptor?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(*)

'containingDeclaration' @ [84:97] ==> public final val ReceiverParameterDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'callable' @ [84:122] ==> val callable: DeclarationDescriptor? defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check[LocalVariableDescriptor]

'!' @ [91:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'used' @ [91:22] ==> var used: Boolean defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check[LocalVariableDescriptor]

'holder' @ [92:21] ==> value-parameter holder: ProblemsHolder defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor[ValueParameterDescriptorImpl]

'registerProblem' @ [92:28] ==> public open fun registerProblem(@NotNull p0: PsiElement, @NotNull @Nls p1: String, @NotNull p2: ProblemHighlightType, @Nullable vararg p3: (LocalQuickFix..LocalQuickFix?)): Unit defined in com.intellij.codeInspection.ProblemsHolder[JavaMethodDescriptor]

'receiverTypeReference' @ [93:29] ==> val receiverTypeReference: KtTypeReference? defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check[LocalVariableDescriptor]

'message' @ [94:42] ==> @NotNull public open fun message(@NonNls @PropertyKey p0: (String..String?), vararg p1: (Any..Any?)): String defined in org.jetbrains.kotlin.idea.KotlinBundle[JavaMethodDescriptor]

'LIKE_UNUSED_SYMBOL' @ [95:50] ==> enum entry LIKE_UNUSED_SYMBOL defined in com.intellij.codeInspection.ProblemHighlightType[FakeCallableDescriptorForObject]

'MyQuickFix' @ [96:29] ==> public constructor MyQuickFix(declaration: KtCallableDeclaration) defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.MyQuickFix[ClassConstructorDescriptorImpl]

'callableDeclaration' @ [96:40] ==> value-parameter callableDeclaration: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.check[ValueParameterDescriptorImpl]

'check' @ [102:17] ==> private final fun check(callableDeclaration: KtCallableDeclaration): Unit defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>[SimpleFunctionDescriptorImpl]

'function' @ [102:23] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.visitNamedFunction[ValueParameterDescriptorImpl]

'check' @ [106:17] ==> private final fun check(callableDeclaration: KtCallableDeclaration): Unit defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>[SimpleFunctionDescriptorImpl]

'property' @ [106:23] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.buildVisitor.<no name provided>.visitProperty[ValueParameterDescriptorImpl]

'message' @ [113:33] ==> @NotNull public open fun message(@NonNls @PropertyKey p0: (String..String?), vararg p1: (Any..Any?)): String defined in org.jetbrains.kotlin.idea.KotlinBundle[JavaMethodDescriptor]

'originalDescriptor' @ [118:82] ==> value-parameter originalDescriptor: KotlinMethodDescriptor defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.MyQuickFix.configureChangeSignature.<no name provided>.configure[ValueParameterDescriptorImpl]

'modify' @ [118:101] ==> public fun KotlinMethodDescriptor.modify(action: (KotlinMutableMethodDescriptor) -> Unit): KotlinMethodDescriptor defined in org.jetbrains.kotlin.idea.refactoring.changeSignature in file KotlinChangeSignature.kt[SimpleFunctionDescriptorImpl]

'it' @ [118:110] ==> value-parameter it: KotlinMutableMethodDescriptor defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.MyQuickFix.configureChangeSignature.<no name provided>.configure.<anonymous>[ValueParameterDescriptorImpl]

'removeParameter' @ [118:113] ==> public final fun removeParameter(index: Int): Unit defined in org.jetbrains.kotlin.idea.refactoring.changeSignature.KotlinMutableMethodDescriptor[SimpleFunctionDescriptorImpl]

'descriptor' @ [122:27] ==> value-parameter descriptor: ProblemDescriptor defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.MyQuickFix.applyFix[ValueParameterDescriptorImpl]

'psiElement' @ [122:38] ==> public final val ProblemDescriptor.psiElement: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'!' @ [123:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'getInstance' @ [123:42] ==> public open fun getInstance(): (FileModificationService..FileModificationService?) defined in com.intellij.codeInsight.FileModificationService[JavaMethodDescriptor]

'preparePsiElementForWrite' @ [123:56] ==> public open fun preparePsiElementForWrite(@Nullable p0: PsiElement?): Boolean defined in com.intellij.codeInsight.FileModificationService[JavaMethodDescriptor]

'element' @ [123:82] ==> val element: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.MyQuickFix.applyFix[LocalVariableDescriptor]

'element' @ [125:28] ==> val element: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.MyQuickFix.applyFix[LocalVariableDescriptor]

'parent' @ [125:36] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'function' @ [126:38] ==> val function: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.MyQuickFix.applyFix[LocalVariableDescriptor]

'analyze' @ [126:47] ==> @JvmOverloads public fun KtElement.analyze(bodyResolveMode: BodyResolveMode = ...): BindingContext defined in org.jetbrains.kotlin.idea.caches.resolve[DeserializedSimpleFunctionDescriptor]

'DECLARATION_TO_DESCRIPTOR' @ [126:72] ==> public final val DECLARATION_TO_DESCRIPTOR: (ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'function' @ [126:99] ==> val function: KtCallableDeclaration defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.MyQuickFix.applyFix[LocalVariableDescriptor]

'runChangeSignature' @ [127:13] ==> public fun runChangeSignature(project: Project, callableDescriptor: CallableDescriptor, configuration: KotlinChangeSignatureConfiguration, defaultValueContext: PsiElement, commandName: String? = ...): Boolean defined in org.jetbrains.kotlin.idea.refactoring.changeSignature in file KotlinChangeSignature.kt[SimpleFunctionDescriptorImpl]

'project' @ [127:32] ==> value-parameter project: Project defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.MyQuickFix.applyFix[ValueParameterDescriptorImpl]

'callableDescriptor' @ [127:41] ==> val callableDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.MyQuickFix.applyFix[LocalVariableDescriptor]

'configureChangeSignature' @ [127:61] ==> private final fun configureChangeSignature(): <no name provided> defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.MyQuickFix[SimpleFunctionDescriptorImpl]

'element' @ [127:89] ==> val element: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.inspections.UnusedReceiverParameterInspection.MyQuickFix.applyFix[LocalVariableDescriptor]

'name' @ [127:98] ==> public final val UnusedReceiverParameterInspection.MyQuickFix.name: String[MyPropertyDescriptor]

'name' @ [130:48] ==> public final val UnusedReceiverParameterInspection.MyQuickFix.name: String[MyPropertyDescriptor]

