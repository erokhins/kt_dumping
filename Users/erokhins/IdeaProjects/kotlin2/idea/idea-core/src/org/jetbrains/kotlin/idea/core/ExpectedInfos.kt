'ItemOptions' @ [53:23] ==> public constructor ItemOptions(starPrefix: Boolean) defined in org.jetbrains.kotlin.idea.core.ItemOptions[ClassConstructorDescriptorImpl]

'ItemOptions' @ [54:27] ==> public constructor ItemOptions(starPrefix: Boolean) defined in org.jetbrains.kotlin.idea.core.ItemOptions[ClassConstructorDescriptorImpl]

'listOfNotNull' @ [65:17] ==> public fun <T : Any> listOfNotNull(element: FuzzyType?): List<FuzzyType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> FuzzyType

'fuzzyType' @ [65:31] ==> public open val fuzzyType: FuzzyType? defined in org.jetbrains.kotlin.idea.core.ByTypeFilter[PropertyDescriptorImpl]

'EMPTY' @ [68:87] ==> public final val EMPTY: (TypeSubstitutor..TypeSubstitutor?) defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaPropertyDescriptor]

'descriptorType' @ [77:67] ==> value-parameter descriptorType: FuzzyType defined in org.jetbrains.kotlin.idea.core.ByExpectedTypeFilter.matchingSubstitutor[ValueParameterDescriptorImpl]

'checkIsSubtypeOf' @ [77:82] ==> public final fun checkIsSubtypeOf(otherType: FuzzyType): TypeSubstitutor? defined in org.jetbrains.kotlin.idea.util.FuzzyType[DeserializedSimpleFunctionDescriptor]

'fuzzyType' @ [77:99] ==> public open val fuzzyType: FuzzyType defined in org.jetbrains.kotlin.idea.core.ByExpectedTypeFilter[PropertyDescriptorImpl]

'other' @ [79:40] ==> value-parameter other: Any? defined in org.jetbrains.kotlin.idea.core.ByExpectedTypeFilter.equals[ValueParameterDescriptorImpl]

'fuzzyType' @ [79:73] ==> public open val fuzzyType: FuzzyType defined in org.jetbrains.kotlin.idea.core.ByExpectedTypeFilter[PropertyDescriptorImpl]

'other' @ [79:86] ==> value-parameter other: Any? defined in org.jetbrains.kotlin.idea.core.ByExpectedTypeFilter.equals[ValueParameterDescriptorImpl]

'fuzzyType' @ [79:92] ==> public open val fuzzyType: FuzzyType defined in org.jetbrains.kotlin.idea.core.ByExpectedTypeFilter[PropertyDescriptorImpl]

'fuzzyType' @ [81:31] ==> public open val fuzzyType: FuzzyType defined in org.jetbrains.kotlin.idea.core.ByExpectedTypeFilter[PropertyDescriptorImpl]

'hashCode' @ [81:41] ==> public open fun hashCode(): Int defined in org.jetbrains.kotlin.idea.util.FuzzyType[DeserializedSimpleFunctionDescriptor]

'ItemOptions' @ [89:40] ==> public companion object defined in org.jetbrains.kotlin.idea.core.ItemOptions[FakeCallableDescriptorForObject]

'DEFAULT' @ [89:52] ==> public final val DEFAULT: ItemOptions defined in org.jetbrains.kotlin.idea.core.ItemOptions.Companion[PropertyDescriptorImpl]

'ItemOptions' @ [95:102] ==> public companion object defined in org.jetbrains.kotlin.idea.core.ItemOptions[FakeCallableDescriptorForObject]

'DEFAULT' @ [95:114] ==> public final val DEFAULT: ItemOptions defined in org.jetbrains.kotlin.idea.core.ItemOptions.Companion[PropertyDescriptorImpl]

'this' @ [96:11] ==> public constructor ExpectedInfo(filter: ByTypeFilter, expectedName: String?, tail: Tail?, itemOptions: ItemOptions = ..., additionalData: ExpectedInfo.AdditionalData? = ...) defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[ClassConstructorDescriptorImpl]

'ByExpectedTypeFilter' @ [96:16] ==> public constructor ByExpectedTypeFilter(fuzzyType: FuzzyType) defined in org.jetbrains.kotlin.idea.core.ByExpectedTypeFilter[ClassConstructorDescriptorImpl]

'fuzzyType' @ [96:37] ==> value-parameter fuzzyType: FuzzyType defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.<init>[ValueParameterDescriptorImpl]

'expectedName' @ [96:49] ==> value-parameter expectedName: String? defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.<init>[ValueParameterDescriptorImpl]

'tail' @ [96:63] ==> value-parameter tail: Tail? defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.<init>[ValueParameterDescriptorImpl]

'itemOptions' @ [96:69] ==> value-parameter itemOptions: ItemOptions = ... defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.<init>[ValueParameterDescriptorImpl]

'additionalData' @ [96:82] ==> value-parameter additionalData: ExpectedInfo.AdditionalData? = ... defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.<init>[ValueParameterDescriptorImpl]

'ItemOptions' @ [98:98] ==> public companion object defined in org.jetbrains.kotlin.idea.core.ItemOptions[FakeCallableDescriptorForObject]

'DEFAULT' @ [98:110] ==> public final val DEFAULT: ItemOptions defined in org.jetbrains.kotlin.idea.core.ItemOptions.Companion[PropertyDescriptorImpl]

'this' @ [99:11] ==> public constructor ExpectedInfo(fuzzyType: FuzzyType, expectedName: String?, tail: Tail?, itemOptions: ItemOptions = ..., additionalData: ExpectedInfo.AdditionalData? = ...) defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[ClassConstructorDescriptorImpl]

'type' @ [99:16] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.<init>[ValueParameterDescriptorImpl]

'toFuzzyType' @ [99:21] ==> public fun KotlinType.toFuzzyType(freeParameters: Collection<TypeParameterDescriptor>): FuzzyType defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'emptyList' @ [99:33] ==> public fun <T> emptyList(): List<TypeParameterDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeParameterDescriptor

'expectedName' @ [99:47] ==> value-parameter expectedName: String? defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.<init>[ValueParameterDescriptorImpl]

'tail' @ [99:61] ==> value-parameter tail: Tail? defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.<init>[ValueParameterDescriptorImpl]

'itemOptions' @ [99:67] ==> value-parameter itemOptions: ItemOptions = ... defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.<init>[ValueParameterDescriptorImpl]

'additionalData' @ [99:80] ==> value-parameter additionalData: ExpectedInfo.AdditionalData? = ... defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.<init>[ValueParameterDescriptorImpl]

'filter' @ [101:76] ==> public final val filter: ByTypeFilter defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[PropertyDescriptorImpl]

'matchingSubstitutor' @ [101:83] ==> public abstract fun matchingSubstitutor(descriptorType: FuzzyType): TypeSubstitutor? defined in org.jetbrains.kotlin.idea.core.ByTypeFilter[SimpleFunctionDescriptorImpl]

'descriptorType' @ [101:103] ==> value-parameter descriptorType: FuzzyType defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.matchingSubstitutor[ValueParameterDescriptorImpl]

'matchingSubstitutor' @ [103:77] ==> public final fun matchingSubstitutor(descriptorType: FuzzyType): TypeSubstitutor? defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[SimpleFunctionDescriptorImpl]

'descriptorType' @ [103:97] ==> value-parameter descriptorType: KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.matchingSubstitutor[ValueParameterDescriptorImpl]

'toFuzzyType' @ [103:112] ==> public fun KotlinType.toFuzzyType(freeParameters: Collection<TypeParameterDescriptor>): FuzzyType defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'emptyList' @ [103:124] ==> public fun <T> emptyList(): List<TypeParameterDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeParameterDescriptor

'ItemOptions' @ [106:148] ==> public companion object defined in org.jetbrains.kotlin.idea.core.ItemOptions[FakeCallableDescriptorForObject]

'DEFAULT' @ [106:160] ==> public final val DEFAULT: ItemOptions defined in org.jetbrains.kotlin.idea.core.ItemOptions.Companion[PropertyDescriptorImpl]

'ExpectedInfo' @ [107:20] ==> public constructor ExpectedInfo(fuzzyType: FuzzyType, expectedName: String?, tail: Tail?, itemOptions: ItemOptions = ..., additionalData: ExpectedInfo.AdditionalData? = ...) defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[ClassConstructorDescriptorImpl]

'type' @ [107:33] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.Companion.createForArgument[ValueParameterDescriptorImpl]

'toFuzzyType' @ [107:38] ==> public fun KotlinType.toFuzzyType(freeParameters: Collection<TypeParameterDescriptor>): FuzzyType defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'argumentData' @ [107:50] ==> value-parameter argumentData: ArgumentPositionData defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.Companion.createForArgument[ValueParameterDescriptorImpl]

'function' @ [107:63] ==> public final val function: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ArgumentPositionData[PropertyDescriptorImpl]

'typeParameters' @ [107:72] ==> public final val FunctionDescriptor.typeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'expectedName' @ [107:89] ==> value-parameter expectedName: String? defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.Companion.createForArgument[ValueParameterDescriptorImpl]

'tail' @ [107:103] ==> value-parameter tail: Tail? defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.Companion.createForArgument[ValueParameterDescriptorImpl]

'itemOptions' @ [107:109] ==> value-parameter itemOptions: ItemOptions = ... defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.Companion.createForArgument[ValueParameterDescriptorImpl]

'argumentData' @ [107:122] ==> value-parameter argumentData: ArgumentPositionData defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.Companion.createForArgument[ValueParameterDescriptorImpl]

'ExpectedInfo' @ [111:20] ==> public constructor ExpectedInfo(filter: ByTypeFilter, expectedName: String?, tail: Tail?, itemOptions: ItemOptions = ..., additionalData: ExpectedInfo.AdditionalData? = ...) defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[ClassConstructorDescriptorImpl]

'None' @ [111:46] ==> public object None : ByTypeFilter defined in org.jetbrains.kotlin.idea.core.ByTypeFilter[FakeCallableDescriptorForObject]

'ItemOptions' @ [111:73] ==> public companion object defined in org.jetbrains.kotlin.idea.core.ItemOptions[FakeCallableDescriptorForObject]

'DEFAULT' @ [111:85] ==> public final val DEFAULT: ItemOptions defined in org.jetbrains.kotlin.idea.core.ItemOptions.Companion[PropertyDescriptorImpl]

'argumentData' @ [111:94] ==> value-parameter argumentData: ArgumentPositionData defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.Companion.createForNamedArgumentExpected[ValueParameterDescriptorImpl]

'if (type != null) ByExpectedTypeFilter(type.toFuzzyType(emptyList())) else ByTypeFilter.All' @ [115:26] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: ByTypeFilter, elseBranch: ByTypeFilter): ByTypeFilter[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> ByTypeFilter

'type' @ [115:30] ==> value-parameter type: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.Companion.createForReturnValue[ValueParameterDescriptorImpl]

'ByExpectedTypeFilter' @ [115:44] ==> public constructor ByExpectedTypeFilter(fuzzyType: FuzzyType) defined in org.jetbrains.kotlin.idea.core.ByExpectedTypeFilter[ClassConstructorDescriptorImpl]

'type' @ [115:65] ==> value-parameter type: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.Companion.createForReturnValue[ValueParameterDescriptorImpl]

'toFuzzyType' @ [115:70] ==> public fun KotlinType.toFuzzyType(freeParameters: Collection<TypeParameterDescriptor>): FuzzyType defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'emptyList' @ [115:82] ==> public fun <T> emptyList(): List<TypeParameterDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeParameterDescriptor

'All' @ [115:114] ==> public object All : ByTypeFilter defined in org.jetbrains.kotlin.idea.core.ByTypeFilter[FakeCallableDescriptorForObject]

'ExpectedInfo' @ [116:20] ==> public constructor ExpectedInfo(filter: ByTypeFilter, expectedName: String?, tail: Tail?, itemOptions: ItemOptions = ..., additionalData: ExpectedInfo.AdditionalData? = ...) defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[ClassConstructorDescriptorImpl]

'filter' @ [116:33] ==> val filter: ByTypeFilter defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.Companion.createForReturnValue[LocalVariableDescriptor]

'callable' @ [116:41] ==> value-parameter callable: CallableDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.Companion.createForReturnValue[ValueParameterDescriptorImpl]

'name' @ [116:50] ==> public final val CallableDescriptor.name: Name[MyPropertyDescriptor]

'asString' @ [116:55] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'ReturnValueAdditionalData' @ [116:90] ==> public constructor ReturnValueAdditionalData(callable: CallableDescriptor) defined in org.jetbrains.kotlin.idea.core.ReturnValueAdditionalData[ClassConstructorDescriptorImpl]

'callable' @ [116:116] ==> value-parameter callable: CallableDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.Companion.createForReturnValue[ValueParameterDescriptorImpl]

'filter' @ [122:13] ==> public final val filter: ByTypeFilter defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[PropertyDescriptorImpl]

'fuzzyType' @ [122:20] ==> public open val fuzzyType: FuzzyType? defined in org.jetbrains.kotlin.idea.core.ByTypeFilter[PropertyDescriptorImpl]

'filter' @ [125:13] ==> public final val filter: ByTypeFilter defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[PropertyDescriptorImpl]

'multipleFuzzyTypes' @ [125:20] ==> public open val multipleFuzzyTypes: Collection<FuzzyType> defined in org.jetbrains.kotlin.idea.core.ByTypeFilter[PropertyDescriptorImpl]

'ArgumentPositionData' @ [134:9] ==> private constructor ArgumentPositionData(function: FunctionDescriptor, callType: Call.CallType) defined in org.jetbrains.kotlin.idea.core.ArgumentPositionData[ClassConstructorDescriptorImpl]

'function' @ [134:30] ==> value-parameter function: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ArgumentPositionData.Positional.<init>[ValueParameterDescriptorImpl]

'callType' @ [134:40] ==> value-parameter callType: Call.CallType defined in org.jetbrains.kotlin.idea.core.ArgumentPositionData.Positional.<init>[ValueParameterDescriptorImpl]

'ArgumentPositionData' @ [136:98] ==> private constructor ArgumentPositionData(function: FunctionDescriptor, callType: Call.CallType) defined in org.jetbrains.kotlin.idea.core.ArgumentPositionData[ClassConstructorDescriptorImpl]

'function' @ [136:119] ==> value-parameter function: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ArgumentPositionData.Named.<init>[ValueParameterDescriptorImpl]

'callType' @ [136:129] ==> value-parameter callType: Call.CallType defined in org.jetbrains.kotlin.idea.core.ArgumentPositionData.Named.<init>[ValueParameterDescriptorImpl]

'calculateForArgument' @ [157:29] ==> private final fun calculateForArgument(expressionWithType: KtExpression): Collection<ExpectedInfo>? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'expressionWithType' @ [157:50] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculate[ValueParameterDescriptorImpl]

'calculateForFunctionLiteralArgument' @ [158:32] ==> private final fun calculateForFunctionLiteralArgument(expressionWithType: KtExpression): Collection<ExpectedInfo>? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'expressionWithType' @ [158:68] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculate[ValueParameterDescriptorImpl]

'calculateForIndexingArgument' @ [159:32] ==> private final fun calculateForIndexingArgument(expressionWithType: KtExpression): Collection<ExpectedInfo>? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'expressionWithType' @ [159:61] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculate[ValueParameterDescriptorImpl]

'calculateForEqAndAssignment' @ [160:32] ==> private final fun calculateForEqAndAssignment(expressionWithType: KtExpression): Collection<ExpectedInfo>? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'expressionWithType' @ [160:60] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculate[ValueParameterDescriptorImpl]

'calculateForIf' @ [161:32] ==> private final fun calculateForIf(expressionWithType: KtExpression): Collection<ExpectedInfo>? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'expressionWithType' @ [161:47] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculate[ValueParameterDescriptorImpl]

'calculateForElvis' @ [162:32] ==> private final fun calculateForElvis(expressionWithType: KtExpression): Collection<ExpectedInfo>? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'expressionWithType' @ [162:50] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculate[ValueParameterDescriptorImpl]

'calculateForBlockExpression' @ [163:32] ==> private final fun calculateForBlockExpression(expressionWithType: KtExpression): Collection<ExpectedInfo>? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'expressionWithType' @ [163:60] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculate[ValueParameterDescriptorImpl]

'calculateForWhenEntryValue' @ [164:32] ==> private final fun calculateForWhenEntryValue(expressionWithType: KtExpression): Collection<ExpectedInfo>? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'expressionWithType' @ [164:59] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculate[ValueParameterDescriptorImpl]

'calculateForExclOperand' @ [165:32] ==> private final fun calculateForExclOperand(expressionWithType: KtExpression): Collection<ExpectedInfo>? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'expressionWithType' @ [165:56] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculate[ValueParameterDescriptorImpl]

'calculateForInitializer' @ [166:32] ==> private final fun calculateForInitializer(expressionWithType: KtExpression): Collection<ExpectedInfo>? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'expressionWithType' @ [166:56] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculate[ValueParameterDescriptorImpl]

'calculateForExpressionBody' @ [167:32] ==> private final fun calculateForExpressionBody(expressionWithType: KtExpression): Collection<ExpectedInfo>? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'expressionWithType' @ [167:59] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculate[ValueParameterDescriptorImpl]

'calculateForReturn' @ [168:32] ==> private final fun calculateForReturn(expressionWithType: KtExpression): Collection<ExpectedInfo>? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'expressionWithType' @ [168:51] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculate[ValueParameterDescriptorImpl]

'calculateForLoopRange' @ [169:32] ==> private final fun calculateForLoopRange(expressionWithType: KtExpression): Collection<ExpectedInfo>? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'expressionWithType' @ [169:54] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculate[ValueParameterDescriptorImpl]

'calculateForInOperatorArgument' @ [170:32] ==> private final fun calculateForInOperatorArgument(expressionWithType: KtExpression): Collection<ExpectedInfo>? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'expressionWithType' @ [170:63] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculate[ValueParameterDescriptorImpl]

'calculateForPropertyDelegate' @ [171:32] ==> private final fun calculateForPropertyDelegate(expressionWithType: KtExpression): Collection<ExpectedInfo>? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'expressionWithType' @ [171:61] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculate[ValueParameterDescriptorImpl]

'getFromBindingContext' @ [172:32] ==> private final fun getFromBindingContext(expressionWithType: KtExpression): Collection<ExpectedInfo>? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'expressionWithType' @ [172:54] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculate[ValueParameterDescriptorImpl]

'emptyList' @ [173:39] ==> public fun <T> emptyList(): List<ExpectedInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo

'expectedInfos' @ [174:16] ==> val expectedInfos: Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculate[LocalVariableDescriptor]

'filterNot' @ [174:30] ==> public inline fun <T> Iterable<ExpectedInfo>.filterNot(predicate: (ExpectedInfo) -> Boolean): List<ExpectedInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo

'it' @ [174:42] ==> value-parameter it: ExpectedInfo defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculate.<anonymous>[ValueParameterDescriptorImpl]

'fuzzyType' @ [174:45] ==> public val ExpectedInfo.fuzzyType: FuzzyType? defined in org.jetbrains.kotlin.idea.core in file ExpectedInfos.kt[PropertyDescriptorImpl]

'type' @ [174:56] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.idea.util.FuzzyType[DeserializedPropertyDescriptor]

'isError' @ [174:62] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types[DeserializedPropertyDescriptor]

'expressionWithType' @ [178:24] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'parent' @ [178:43] ==> public final val KtExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'argument' @ [179:28] ==> val argument: KtValueArgument defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'parent' @ [179:37] ==> public final val KtValueArgument.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'argumentList' @ [180:27] ==> val argumentList: KtValueArgumentList defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'parent' @ [180:40] ==> public final val KtValueArgumentList.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'calculateForArgument' @ [181:16] ==> private final fun calculateForArgument(callElement: KtCallElement, argument: ValueArgument): Collection<ExpectedInfo>? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'callElement' @ [181:37] ==> val callElement: KtCallElement defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'argument' @ [181:50] ==> val argument: KtValueArgument defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'expressionWithType' @ [185:39] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'parent' @ [185:58] ==> public final val KtExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'functionLiteralArgument' @ [186:30] ==> val functionLiteralArgument: KtLambdaArgument? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForFunctionLiteralArgument[LocalVariableDescriptor]

'parent' @ [186:55] ==> public final val KtLambdaArgument.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'callExpression' @ [187:31] ==> val callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForFunctionLiteralArgument[LocalVariableDescriptor]

'lambdaArguments' @ [187:46] ==> public final val KtCallExpression.lambdaArguments: (MutableList<(KtLambdaArgument..KtLambdaArgument?)>..List<(KtLambdaArgument..KtLambdaArgument?)>)[MyPropertyDescriptor]

'firstOrNull' @ [187:62] ==> public fun <T> List<(KtLambdaArgument..KtLambdaArgument?)>.firstOrNull(): KtLambdaArgument? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtLambdaArgument..org.jetbrains.kotlin.psi.KtLambdaArgument?)

'literalArgument' @ [188:13] ==> val literalArgument: KtLambdaArgument defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForFunctionLiteralArgument[LocalVariableDescriptor]

'getArgumentExpression' @ [188:29] ==> public open fun getArgumentExpression(): KtExpression defined in org.jetbrains.kotlin.psi.KtLambdaArgument[DeserializedSimpleFunctionDescriptor]

'expressionWithType' @ [188:56] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'calculateForArgument' @ [189:16] ==> private final fun calculateForArgument(callElement: KtCallElement, argument: ValueArgument): Collection<ExpectedInfo>? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'callExpression' @ [189:37] ==> val callExpression: KtCallExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForFunctionLiteralArgument[LocalVariableDescriptor]

'literalArgument' @ [189:53] ==> val literalArgument: KtLambdaArgument defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForFunctionLiteralArgument[LocalVariableDescriptor]

'expressionWithType' @ [193:29] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIndexingArgument[ValueParameterDescriptorImpl]

'parent' @ [193:48] ==> public final val KtExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'containerNode' @ [194:37] ==> val containerNode: KtContainerNode defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIndexingArgument[LocalVariableDescriptor]

'parent' @ [194:51] ==> public final val KtContainerNode.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'containerNode' @ [195:13] ==> val containerNode: KtContainerNode defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIndexingArgument[LocalVariableDescriptor]

'arrayAccessExpression' @ [195:30] ==> val arrayAccessExpression: KtArrayAccessExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIndexingArgument[LocalVariableDescriptor]

'indicesNode' @ [195:52] ==> public final val KtArrayAccessExpression.indicesNode: KtContainerNode[MyPropertyDescriptor]

'arrayAccessExpression' @ [196:20] ==> val arrayAccessExpression: KtArrayAccessExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIndexingArgument[LocalVariableDescriptor]

'getCall' @ [196:42] ==> public fun KtElement.getCall(context: BindingContext): Call? defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [196:50] ==> private final val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'call' @ [197:24] ==> val call: Call defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIndexingArgument[LocalVariableDescriptor]

'valueArguments' @ [197:29] ==> public final val Call.valueArguments: List<(ValueArgument..ValueArgument?)>[MyPropertyDescriptor]

'firstOrNull' @ [197:44] ==> public inline fun <T> Iterable<(ValueArgument..ValueArgument?)>.firstOrNull(predicate: ((ValueArgument..ValueArgument?)) -> Boolean): ValueArgument? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)

'it' @ [197:58] ==> value-parameter it: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIndexingArgument.<anonymous>[ValueParameterDescriptorImpl]

'getArgumentExpression' @ [197:61] ==> @IfNotParsed public abstract fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.ValueArgument[DeserializedSimpleFunctionDescriptor]

'expressionWithType' @ [197:88] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIndexingArgument[ValueParameterDescriptorImpl]

'calculateForArgument' @ [198:16] ==> public final fun calculateForArgument(call: Call, argument: ValueArgument): Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'call' @ [198:37] ==> val call: Call defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIndexingArgument[LocalVariableDescriptor]

'argument' @ [198:43] ==> val argument: ValueArgument defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIndexingArgument[LocalVariableDescriptor]

'callElement' @ [202:20] ==> value-parameter callElement: KtCallElement defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'getCall' @ [202:32] ==> public fun KtElement.getCall(context: BindingContext): Call? defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [202:40] ==> private final val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'call' @ [204:13] ==> val call: Call defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'callElement' @ [204:18] ==> public final val Call.callElement: KtElement[MyPropertyDescriptor]

'callElement' @ [204:33] ==> value-parameter callElement: KtCallElement defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'calculateForArgument' @ [205:16] ==> public final fun calculateForArgument(call: Call, argument: ValueArgument): Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'call' @ [205:37] ==> val call: Call defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'argument' @ [205:43] ==> value-parameter argument: ValueArgument defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'calculateForArgument' @ [209:23] ==> private final fun calculateForArgument(call: Call, callExpectedType: KotlinType, argument: ValueArgument): Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'call' @ [209:44] ==> value-parameter call: Call defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'NO_EXPECTED_TYPE' @ [209:60] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'argument' @ [209:78] ==> value-parameter argument: ValueArgument defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'info' @ [212:24] ==> value-parameter info: ExpectedInfo defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument.makesSenseToUseOuterCallExpectedType[ValueParameterDescriptorImpl]

'additionalData' @ [212:29] ==> public final val additionalData: ExpectedInfo.AdditionalData? defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[PropertyDescriptorImpl]

'info' @ [213:20] ==> value-parameter info: ExpectedInfo defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument.makesSenseToUseOuterCallExpectedType[ValueParameterDescriptorImpl]

'fuzzyType' @ [213:25] ==> public val ExpectedInfo.fuzzyType: FuzzyType? defined in org.jetbrains.kotlin.idea.core in file ExpectedInfos.kt[PropertyDescriptorImpl]

'info' @ [214:23] ==> value-parameter info: ExpectedInfo defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument.makesSenseToUseOuterCallExpectedType[ValueParameterDescriptorImpl]

'fuzzyType' @ [214:28] ==> public val ExpectedInfo.fuzzyType: FuzzyType? defined in org.jetbrains.kotlin.idea.core in file ExpectedInfos.kt[PropertyDescriptorImpl]

'freeParameters' @ [214:40] ==> public final val freeParameters: Set<TypeParameterDescriptor> defined in org.jetbrains.kotlin.idea.util.FuzzyType[DeserializedPropertyDescriptor]

'isNotEmpty' @ [214:55] ==> @InlineOnly public inline fun <T> Collection<TypeParameterDescriptor>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeParameterDescriptor

'data' @ [215:23] ==> val data: ArgumentPositionData defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument.makesSenseToUseOuterCallExpectedType[LocalVariableDescriptor]

'function' @ [215:28] ==> public final val function: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ArgumentPositionData[PropertyDescriptorImpl]

'fuzzyReturnType' @ [215:37] ==> public fun CallableDescriptor.fuzzyReturnType(): FuzzyType? defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'freeParameters' @ [215:56] ==> public final val freeParameters: Set<TypeParameterDescriptor> defined in org.jetbrains.kotlin.idea.util.FuzzyType[DeserializedPropertyDescriptor]

'isNotEmpty' @ [215:72] ==> @InlineOnly public inline fun <T> Collection<TypeParameterDescriptor>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeParameterDescriptor

'useOuterCallsExpectedTypeCount' @ [218:13] ==> private final val useOuterCallsExpectedTypeCount: Int defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'results' @ [218:51] ==> val results: Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'any' @ [218:59] ==> public inline fun <T> Iterable<ExpectedInfo>.any(predicate: (ExpectedInfo) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo

'?:' @ [219:34] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtExpression?, right: KtExpression): KtExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtExpression

'call' @ [219:35] ==> value-parameter call: Call defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'callElement' @ [219:40] ==> public final val Call.callElement: KtElement[MyPropertyDescriptor]

'getQualifiedExpressionForSelectorOrThis' @ [219:71] ==> public fun KtExpression.getQualifiedExpressionForSelectorOrThis(): KtExpression defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'results' @ [219:123] ==> val results: Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'ExpectedInfos' @ [220:38] ==> public constructor ExpectedInfos(bindingContext: BindingContext, resolutionFacade: ResolutionFacade, indicesHelper: KotlinIndicesHelper?, useHeuristicSignatures: Boolean = ..., useOuterCallsExpectedTypeCount: Int = ...) defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[ClassConstructorDescriptorImpl]

'bindingContext' @ [220:52] ==> private final val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'resolutionFacade' @ [220:68] ==> private final val resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'indicesHelper' @ [220:86] ==> private final val indicesHelper: KotlinIndicesHelper? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'useHeuristicSignatures' @ [220:101] ==> private final val useHeuristicSignatures: Boolean defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'useOuterCallsExpectedTypeCount' @ [220:125] ==> private final val useOuterCallsExpectedTypeCount: Int defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'calculate' @ [221:22] ==> public final fun calculate(expressionWithType: KtExpression): Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'callExpression' @ [221:32] ==> val callExpression: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'mapNotNull' @ [222:22] ==> public inline fun <T, R : Any> Iterable<ExpectedInfo>.mapNotNull(transform: (ExpectedInfo) -> FuzzyType?): List<FuzzyType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo
    <R : Any> -> FuzzyType

'it' @ [222:35] ==> value-parameter it: ExpectedInfo defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument.<anonymous>[ValueParameterDescriptorImpl]

'fuzzyType' @ [222:38] ==> public val ExpectedInfo.fuzzyType: FuzzyType? defined in org.jetbrains.kotlin.idea.core in file ExpectedInfos.kt[PropertyDescriptorImpl]

'expectedFuzzyTypes' @ [223:17] ==> val expectedFuzzyTypes: List<FuzzyType> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'isEmpty' @ [223:36] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'expectedFuzzyTypes' @ [223:49] ==> val expectedFuzzyTypes: List<FuzzyType> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'any' @ [223:68] ==> public inline fun <T> Iterable<FuzzyType>.any(predicate: (FuzzyType) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FuzzyType

'it' @ [223:74] ==> value-parameter it: FuzzyType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument.<anonymous>[ValueParameterDescriptorImpl]

'freeParameters' @ [223:77] ==> public final val freeParameters: Set<TypeParameterDescriptor> defined in org.jetbrains.kotlin.idea.util.FuzzyType[DeserializedPropertyDescriptor]

'isNotEmpty' @ [223:92] ==> @InlineOnly public inline fun <T> Collection<TypeParameterDescriptor>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeParameterDescriptor

'results' @ [223:115] ==> val results: Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'expectedFuzzyTypes' @ [225:20] ==> val expectedFuzzyTypes: List<FuzzyType> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'map' @ [226:22] ==> public inline fun <T, R> Iterable<FuzzyType>.map(transform: (FuzzyType) -> KotlinType): List<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FuzzyType
    <R> -> KotlinType

'it' @ [226:28] ==> value-parameter it: FuzzyType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [226:31] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.idea.util.FuzzyType[DeserializedPropertyDescriptor]

'toSet' @ [227:22] ==> public fun <T> Iterable<KotlinType>.toSet(): Set<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'flatMap' @ [228:22] ==> public inline fun <T, R> Iterable<KotlinType>.flatMap(transform: (KotlinType) -> Iterable<ExpectedInfo>): List<ExpectedInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType
    <R> -> ExpectedInfo

'calculateForArgument' @ [228:32] ==> private final fun calculateForArgument(call: Call, callExpectedType: KotlinType, argument: ValueArgument): Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'call' @ [228:53] ==> value-parameter call: Call defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'it' @ [228:59] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument.<anonymous>[ValueParameterDescriptorImpl]

'argument' @ [228:63] ==> value-parameter argument: ValueArgument defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'results' @ [231:16] ==> val results: Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'call' @ [236:13] ==> value-parameter call: Call defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'calculateForArgument' @ [237:20] ==> private final fun calculateForArgument(call: Call, callExpectedType: KotlinType, argument: ValueArgument): Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'call' @ [237:41] ==> value-parameter call: Call defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'outerCall' @ [237:46] ==> public final val CallTransformer.CallForImplicitInvoke.outerCall: Call[MyPropertyDescriptor]

'callExpectedType' @ [237:57] ==> value-parameter callExpectedType: KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'argument' @ [237:75] ==> value-parameter argument: ValueArgument defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'call' @ [239:29] ==> value-parameter call: Call defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'valueArguments' @ [239:34] ==> public final val Call.valueArguments: List<(ValueArgument..ValueArgument?)>[MyPropertyDescriptor]

'indexOf' @ [239:49] ==> public abstract fun indexOf(element: (ValueArgument..ValueArgument?)): Int defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'argument' @ [239:57] ==> value-parameter argument: ValueArgument defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'assert' @ [240:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'argumentIndex' @ [240:16] ==> val argumentIndex: Int defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'argument' @ [241:40] ==> value-parameter argument: ValueArgument defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'argument' @ [241:51] ==> value-parameter argument: ValueArgument defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'asElement' @ [241:60] ==> public abstract fun asElement(): KtElement defined in org.jetbrains.kotlin.psi.ValueArgument[DeserializedSimpleFunctionDescriptor]

'text' @ [241:72] ==> public final val KtElement.text: (String..String?)[MyPropertyDescriptor]

'call' @ [241:106] ==> value-parameter call: Call defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'call' @ [241:134] ==> value-parameter call: Call defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'callElement' @ [241:139] ==> public final val Call.callElement: KtElement[MyPropertyDescriptor]

'text' @ [241:151] ==> public final val KtElement.text: (String..String?)[MyPropertyDescriptor]

'DelegatingCall' @ [245:38] ==> public constructor DelegatingCall(@NotNull p0: Call) defined in org.jetbrains.kotlin.resolve.calls.util.DelegatingCall[JavaClassConstructorDescriptor]

'call' @ [245:53] ==> value-parameter call: Call defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'call' @ [246:29] ==> value-parameter call: Call defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'valueArguments' @ [246:34] ==> public final val Call.valueArguments: List<(ValueArgument..ValueArgument?)>[MyPropertyDescriptor]

'subList' @ [246:49] ==> public abstract fun subList(fromIndex: Int, toIndex: Int): List<(ValueArgument..ValueArgument?)> defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'argumentIndex' @ [246:60] ==> val argumentIndex: Int defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'arguments' @ [248:48] ==> public final val arguments: List<(ValueArgument..ValueArgument?)> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument.<no name provided>[PropertyDescriptorImpl]

'emptyList' @ [249:58] ==> public fun <T> emptyList(): List<LambdaArgument> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> LambdaArgument

'truncatedCall' @ [253:26] ==> val truncatedCall: <no name provided> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'resolveCandidates' @ [253:40] ==> public fun Call.resolveCandidates(bindingContext: BindingContext, resolutionFacade: ResolutionFacade, expectedType: KotlinType = ..., filterOutWrongReceiver: Boolean = ..., filterOutByVisibility: Boolean = ...): Collection<ResolvedCall<FunctionDescriptor>> defined in org.jetbrains.kotlin.idea.core[SimpleFunctionDescriptorImpl]

'bindingContext' @ [253:58] ==> private final val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'resolutionFacade' @ [253:74] ==> private final val resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'callExpectedType' @ [253:92] ==> value-parameter callExpectedType: KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'ArrayList' @ [255:29] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> ExpectedInfo

'candidates' @ [257:27] ==> val candidates: Collection<ResolvedCall<FunctionDescriptor>> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'expectedInfos' @ [258:13] ==> val expectedInfos: ArrayList<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'addExpectedInfoForCandidate' @ [258:27] ==> private final fun MutableCollection<ExpectedInfo>.addExpectedInfoForCandidate(candidate: ResolvedCall<FunctionDescriptor>, call: Call, argument: ValueArgument, argumentIndex: Int, checkPrevArgumentsMatched: Boolean): Unit defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'candidate' @ [258:55] ==> val candidate: ResolvedCall<FunctionDescriptor> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'call' @ [258:66] ==> value-parameter call: Call defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'argument' @ [258:72] ==> value-parameter argument: ValueArgument defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'argumentIndex' @ [258:82] ==> val argumentIndex: Int defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'expectedInfos' @ [261:13] ==> val expectedInfos: ArrayList<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'isEmpty' @ [261:27] ==> public open fun isEmpty(): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'candidates' @ [262:31] ==> val candidates: Collection<ResolvedCall<FunctionDescriptor>> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'expectedInfos' @ [263:17] ==> val expectedInfos: ArrayList<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'addExpectedInfoForCandidate' @ [263:31] ==> private final fun MutableCollection<ExpectedInfo>.addExpectedInfoForCandidate(candidate: ResolvedCall<FunctionDescriptor>, call: Call, argument: ValueArgument, argumentIndex: Int, checkPrevArgumentsMatched: Boolean): Unit defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'candidate' @ [263:59] ==> val candidate: ResolvedCall<FunctionDescriptor> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'call' @ [263:70] ==> value-parameter call: Call defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'argument' @ [263:76] ==> value-parameter argument: ValueArgument defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[ValueParameterDescriptorImpl]

'argumentIndex' @ [263:86] ==> val argumentIndex: Int defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'expectedInfos' @ [267:16] ==> val expectedInfos: ArrayList<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForArgument[LocalVariableDescriptor]

'!' @ [278:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'candidate' @ [278:14] ==> value-parameter candidate: ResolvedCall<FunctionDescriptor> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[ValueParameterDescriptorImpl]

'allArgumentsMapped' @ [278:24] ==> public fun <D : CallableDescriptor> ResolvedCall<FunctionDescriptor>.allArgumentsMapped(): Boolean defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <D : CallableDescriptor> -> FunctionDescriptor

'checkPrevArgumentsMatched' @ [281:13] ==> value-parameter checkPrevArgumentsMatched: Boolean defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[ValueParameterDescriptorImpl]

'!' @ [281:42] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'candidate' @ [281:43] ==> value-parameter candidate: ResolvedCall<FunctionDescriptor> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[ValueParameterDescriptorImpl]

'allArgumentsMatched' @ [281:53] ==> private final fun <D : CallableDescriptor> ResolvedCall<FunctionDescriptor>.allArgumentsMatched(): Boolean defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]
Inferred types:
    <D : CallableDescriptor> -> FunctionDescriptor

'candidate' @ [283:26] ==> value-parameter candidate: ResolvedCall<FunctionDescriptor> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[ValueParameterDescriptorImpl]

'resultingDescriptor' @ [283:36] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<FunctionDescriptor>.resultingDescriptor: FunctionDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'descriptor' @ [284:13] ==> var descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'valueParameters' @ [284:24] ==> public final val FunctionDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'isEmpty' @ [284:40] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'call' @ [286:35] ==> value-parameter call: Call defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[ValueParameterDescriptorImpl]

'mapArgumentsToParameters' @ [286:40] ==> public fun Call.mapArgumentsToParameters(targetDescriptor: CallableDescriptor): Map<ValueArgument, ValueParameterDescriptor> defined in org.jetbrains.kotlin.idea.core[SimpleFunctionDescriptorImpl]

'descriptor' @ [286:65] ==> var descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'argumentToParameter' @ [287:25] ==> val argumentToParameter: Map<ValueArgument, ValueParameterDescriptor> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'argument' @ [287:45] ==> value-parameter argument: ValueArgument defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[ValueParameterDescriptorImpl]

'parameter' @ [288:29] ==> var parameter: ValueParameterDescriptor? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'type' @ [288:40] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'parameterType' @ [290:13] ==> var parameterType: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'parameterType' @ [290:38] ==> var parameterType: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'containsError' @ [290:52] ==> public fun KotlinType.containsError(): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'descriptor' @ [291:37] ==> var descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'original' @ [291:48] ==> public final val FunctionDescriptor.original: FunctionDescriptor[MyPropertyDescriptor]

'valueParameters' @ [291:57] ==> public final val FunctionDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'parameter' @ [291:73] ==> var parameter: ValueParameterDescriptor? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'index' @ [291:85] ==> public abstract val index: Int defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'parameter' @ [292:13] ==> var parameter: ValueParameterDescriptor? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'originalParameter' @ [292:25] ==> val originalParameter: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'descriptor' @ [293:13] ==> var descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'descriptor' @ [293:26] ==> var descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'original' @ [293:37] ==> public final val FunctionDescriptor.original: FunctionDescriptor[MyPropertyDescriptor]

'parameterType' @ [294:13] ==> var parameterType: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'fixSubstitutedType' @ [294:29] ==> private final fun fixSubstitutedType(substitutedType: KotlinType, originalType: KotlinType): KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'parameterType' @ [294:48] ==> var parameterType: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'originalParameter' @ [294:63] ==> val originalParameter: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'type' @ [294:81] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'argument' @ [297:28] ==> value-parameter argument: ValueArgument defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[ValueParameterDescriptorImpl]

'getArgumentName' @ [297:37] ==> public abstract fun getArgumentName(): ValueArgumentName? defined in org.jetbrains.kotlin.psi.ValueArgument[DeserializedSimpleFunctionDescriptor]

'asName' @ [297:56] ==> public abstract val asName: Name defined in org.jetbrains.kotlin.psi.ValueArgumentName[DeserializedPropertyDescriptor]

'argument' @ [298:41] ==> value-parameter argument: ValueArgument defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[ValueParameterDescriptorImpl]

'call' @ [300:24] ==> value-parameter call: Call defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[ValueParameterDescriptorImpl]

'callType' @ [300:29] ==> public final val Call.callType: Call.CallType[MyPropertyDescriptor]

'callType' @ [301:29] ==> val callType: Call.CallType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'ARRAY_GET_METHOD' @ [301:55] ==> enum entry ARRAY_GET_METHOD defined in org.jetbrains.kotlin.psi.Call.CallType[FakeCallableDescriptorForObject]

'callType' @ [301:75] ==> val callType: Call.CallType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'ARRAY_SET_METHOD' @ [301:101] ==> enum entry ARRAY_SET_METHOD defined in org.jetbrains.kotlin.psi.Call.CallType[FakeCallableDescriptorForObject]

'if (isArrayAccess) Tail.RBRACKET else Tail.RPARENTH' @ [302:28] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Tail, elseBranch: Tail): Tail[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Tail

'isArrayAccess' @ [302:32] ==> val isArrayAccess: Boolean defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'RBRACKET' @ [302:52] ==> enum entry RBRACKET defined in org.jetbrains.kotlin.idea.core.Tail[FakeCallableDescriptorForObject]

'RPARENTH' @ [302:71] ==> enum entry RPARENTH defined in org.jetbrains.kotlin.idea.core.Tail[FakeCallableDescriptorForObject]

'if (argumentName != null) {
            ArgumentPositionData.Named(descriptor, callType, argumentName)
        }
        else {
            val namedArgumentCandidates = if (!isFunctionLiteralArgument && !isArrayAccess && descriptor.hasStableParameterNames()) {
                val usedParameters = argumentToParameter.filter { it.key != argument }.map { it.value }.toSet()
                descriptor.valueParameters.filter { it !in usedParameters }
            }
            else {
                emptyList()
            }
            ArgumentPositionData.Positional(descriptor, callType, argumentIndex, isFunctionLiteralArgument, namedArgumentCandidates)
        }' @ [304:36] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: ArgumentPositionData, elseBranch: ArgumentPositionData): ArgumentPositionData[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> ArgumentPositionData

'argumentName' @ [304:40] ==> val argumentName: Name? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'Named' @ [305:34] ==> public constructor Named(function: FunctionDescriptor, callType: Call.CallType, argumentName: Name) defined in org.jetbrains.kotlin.idea.core.ArgumentPositionData.Named[ClassConstructorDescriptorImpl]

'descriptor' @ [305:40] ==> var descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'callType' @ [305:52] ==> val callType: Call.CallType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'argumentName' @ [305:62] ==> val argumentName: Name? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'if (!isFunctionLiteralArgument && !isArrayAccess && descriptor.hasStableParameterNames()) {
                val usedParameters = argumentToParameter.filter { it.key != argument }.map { it.value }.toSet()
                descriptor.valueParameters.filter { it !in usedParameters }
            }
            else {
                emptyList()
            }' @ [308:43] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<(ValueParameterDescriptor..ValueParameterDescriptor?)>, elseBranch: List<(ValueParameterDescriptor..ValueParameterDescriptor?)>): List<(ValueParameterDescriptor..ValueParameterDescriptor?)>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<(org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)>

'!' @ [308:47] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isFunctionLiteralArgument' @ [308:48] ==> val isFunctionLiteralArgument: Boolean defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'!' @ [308:77] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isArrayAccess' @ [308:78] ==> val isArrayAccess: Boolean defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'descriptor' @ [308:95] ==> var descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'hasStableParameterNames' @ [308:106] ==> public abstract fun hasStableParameterNames(): Boolean defined in org.jetbrains.kotlin.descriptors.FunctionDescriptor[JavaMethodDescriptor]

'argumentToParameter' @ [309:38] ==> val argumentToParameter: Map<ValueArgument, ValueParameterDescriptor> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'filter' @ [309:58] ==> public inline fun <K, V> Map<out ValueArgument, ValueParameterDescriptor>.filter(predicate: (Map.Entry<ValueArgument, ValueParameterDescriptor>) -> Boolean): Map<ValueArgument, ValueParameterDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> ValueArgument
    <V> -> ValueParameterDescriptor

'it' @ [309:67] ==> value-parameter it: Map.Entry<ValueArgument, ValueParameterDescriptor> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate.<anonymous>[ValueParameterDescriptorImpl]

'key' @ [309:70] ==> public abstract val key: ValueArgument defined in kotlin.collections.Map.Entry[DeserializedPropertyDescriptor]

'argument' @ [309:77] ==> value-parameter argument: ValueArgument defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[ValueParameterDescriptorImpl]

'map' @ [309:88] ==> public inline fun <K, V, R> Map<out ValueArgument, ValueParameterDescriptor>.map(transform: (Map.Entry<ValueArgument, ValueParameterDescriptor>) -> ValueParameterDescriptor): List<ValueParameterDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> ValueArgument
    <V> -> ValueParameterDescriptor
    <R> -> ValueParameterDescriptor

'it' @ [309:94] ==> value-parameter it: Map.Entry<ValueArgument, ValueParameterDescriptor> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [309:97] ==> public abstract val value: ValueParameterDescriptor defined in kotlin.collections.Map.Entry[DeserializedPropertyDescriptor]

'toSet' @ [309:105] ==> public fun <T> Iterable<ValueParameterDescriptor>.toSet(): Set<ValueParameterDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ValueParameterDescriptor

'descriptor' @ [310:17] ==> var descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'valueParameters' @ [310:28] ==> public final val FunctionDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'filter' @ [310:44] ==> public inline fun <T> Iterable<(ValueParameterDescriptor..ValueParameterDescriptor?)>.filter(predicate: ((ValueParameterDescriptor..ValueParameterDescriptor?)) -> Boolean): List<(ValueParameterDescriptor..ValueParameterDescriptor?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)

'it' @ [310:53] ==> value-parameter it: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate.<anonymous>[ValueParameterDescriptorImpl]

'usedParameters' @ [310:60] ==> val usedParameters: Set<ValueParameterDescriptor> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'emptyList' @ [313:17] ==> public fun <T> emptyList(): List<(ValueParameterDescriptor..ValueParameterDescriptor?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)

'Positional' @ [315:34] ==> public constructor Positional(function: FunctionDescriptor, callType: Call.CallType, argumentIndex: Int, isFunctionLiteralArgument: Boolean, namedArgumentCandidates: Collection<ParameterDescriptor>) defined in org.jetbrains.kotlin.idea.core.ArgumentPositionData.Positional[ClassConstructorDescriptorImpl]

'descriptor' @ [315:45] ==> var descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'callType' @ [315:57] ==> val callType: Call.CallType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'argumentIndex' @ [315:67] ==> value-parameter argumentIndex: Int defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[ValueParameterDescriptorImpl]

'isFunctionLiteralArgument' @ [315:82] ==> val isFunctionLiteralArgument: Boolean defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'namedArgumentCandidates' @ [315:109] ==> val namedArgumentCandidates: List<(ValueParameterDescriptor..ValueParameterDescriptor?)> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'descriptor' @ [318:26] ==> var descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'valueParameters' @ [318:37] ==> public final val FunctionDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'callType' @ [319:13] ==> val callType: Call.CallType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'ARRAY_SET_METHOD' @ [319:39] ==> enum entry ARRAY_SET_METHOD defined in org.jetbrains.kotlin.psi.Call.CallType[FakeCallableDescriptorForObject]

'parameter' @ [320:17] ==> var parameter: ValueParameterDescriptor? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'parameters' @ [320:30] ==> var parameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>) defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'last' @ [320:41] ==> public fun <T> List<(ValueParameterDescriptor..ValueParameterDescriptor?)>.last(): (ValueParameterDescriptor..ValueParameterDescriptor?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)

'parameter' @ [321:17] ==> var parameter: ValueParameterDescriptor? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'parameterType' @ [322:17] ==> var parameterType: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'parameters' @ [324:13] ==> var parameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>) defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'parameters' @ [324:26] ==> var parameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>) defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'dropLast' @ [324:37] ==> public fun <T> List<(ValueParameterDescriptor..ValueParameterDescriptor?)>.dropLast(n: Int): List<(ValueParameterDescriptor..ValueParameterDescriptor?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)

'parameter' @ [327:13] ==> var parameter: ValueParameterDescriptor? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'argumentPositionData' @ [328:17] ==> val argumentPositionData: ArgumentPositionData defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'argumentPositionData' @ [328:76] ==> val argumentPositionData: ArgumentPositionData defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'namedArgumentCandidates' @ [328:97] ==> public final val namedArgumentCandidates: Collection<ParameterDescriptor> defined in org.jetbrains.kotlin.idea.core.ArgumentPositionData.Positional[PropertyDescriptorImpl]

'isNotEmpty' @ [328:121] ==> @InlineOnly public inline fun <T> Collection<ParameterDescriptor>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ParameterDescriptor

'add' @ [329:17] ==> public abstract fun add(element: ExpectedInfo): Boolean defined in kotlin.collections.MutableCollection[DeserializedSimpleFunctionDescriptor]

'ExpectedInfo' @ [329:21] ==> public companion object defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[FakeCallableDescriptorForObject]

'createForNamedArgumentExpected' @ [329:34] ==> public final fun createForNamedArgumentExpected(argumentData: ArgumentPositionData): ExpectedInfo defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.Companion[SimpleFunctionDescriptorImpl]

'argumentPositionData' @ [329:65] ==> val argumentPositionData: ArgumentPositionData defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'parameterType' @ [333:9] ==> var parameterType: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'if (descriptor.hasSynthesizedParameterNames()) null else parameter.name.asString()' @ [335:28] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String?, elseBranch: String?): String?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String?

'descriptor' @ [335:32] ==> var descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'hasSynthesizedParameterNames' @ [335:43] ==> public abstract fun hasSynthesizedParameterNames(): Boolean defined in org.jetbrains.kotlin.descriptors.FunctionDescriptor[JavaMethodDescriptor]

'parameter' @ [335:85] ==> var parameter: ValueParameterDescriptor? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'name' @ [335:95] ==> public final val ValueParameterDescriptor.name: Name[MyPropertyDescriptor]

'asString' @ [335:100] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'parameter' @ [338:17] ==> value-parameter parameter: ValueParameterDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate.needCommaForParameter[ValueParameterDescriptorImpl]

'hasDefaultValue' @ [338:27] ==> public fun ValueParameterDescriptor.hasDefaultValue(): Boolean defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedSimpleFunctionDescriptor]

'parameter' @ [339:17] ==> value-parameter parameter: ValueParameterDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate.needCommaForParameter[ValueParameterDescriptorImpl]

'varargElementType' @ [339:27] ==> public abstract val varargElementType: KotlinType? defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'!' @ [341:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isArrayAccess' @ [341:18] ==> val isArrayAccess: Boolean defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'parameter' @ [341:35] ==> value-parameter parameter: ValueParameterDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate.needCommaForParameter[ValueParameterDescriptorImpl]

'parameters' @ [341:48] ==> var parameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>) defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'last' @ [341:59] ==> public fun <T> List<(ValueParameterDescriptor..ValueParameterDescriptor?)>.last(): (ValueParameterDescriptor..ValueParameterDescriptor?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)

'parameter' @ [341:69] ==> value-parameter parameter: ValueParameterDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate.needCommaForParameter[ValueParameterDescriptorImpl]

'type' @ [341:79] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'isFunctionType' @ [341:84] ==> public val KotlinType.isFunctionType: Boolean defined in org.jetbrains.kotlin.builtins[DeserializedPropertyDescriptor]

'if (argumentName == null) {
            when {
                parameter == parameters.last() -> rparenthTail
                parameters.dropWhile { it != parameter }.drop(1).any(::needCommaForParameter) -> Tail.COMMA
                else -> null
            }
        }
        else {
            namedArgumentTail(argumentToParameter, argumentName, descriptor)
        }' @ [345:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Tail?, elseBranch: Tail?): Tail?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Tail?

'argumentName' @ [345:24] ==> val argumentName: Name? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'when {
                parameter == parameters.last() -> rparenthTail
                parameters.dropWhile { it != parameter }.drop(1).any(::needCommaForParameter) -> Tail.COMMA
                else -> null
            }' @ [346:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Tail?, entry1: Tail?, entry2: Tail?): Tail?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Tail?

'parameter' @ [347:17] ==> var parameter: ValueParameterDescriptor? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'parameters' @ [347:30] ==> var parameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>) defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'last' @ [347:41] ==> public fun <T> List<(ValueParameterDescriptor..ValueParameterDescriptor?)>.last(): (ValueParameterDescriptor..ValueParameterDescriptor?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)

'rparenthTail' @ [347:51] ==> val rparenthTail: Tail defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'parameters' @ [348:17] ==> var parameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>) defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'dropWhile' @ [348:28] ==> public inline fun <T> Iterable<(ValueParameterDescriptor..ValueParameterDescriptor?)>.dropWhile(predicate: ((ValueParameterDescriptor..ValueParameterDescriptor?)) -> Boolean): List<(ValueParameterDescriptor..ValueParameterDescriptor?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)

'it' @ [348:40] ==> value-parameter it: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate.<anonymous>[ValueParameterDescriptorImpl]

'parameter' @ [348:46] ==> var parameter: ValueParameterDescriptor? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'drop' @ [348:58] ==> public fun <T> Iterable<(ValueParameterDescriptor..ValueParameterDescriptor?)>.drop(n: Int): List<(ValueParameterDescriptor..ValueParameterDescriptor?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)

'any' @ [348:66] ==> public inline fun <T> Iterable<(ValueParameterDescriptor..ValueParameterDescriptor?)>.any(predicate: ((ValueParameterDescriptor..ValueParameterDescriptor?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)

'COMMA' @ [348:103] ==> enum entry COMMA defined in org.jetbrains.kotlin.idea.core.Tail[FakeCallableDescriptorForObject]

'namedArgumentTail' @ [353:13] ==> private final fun namedArgumentTail(argumentToParameter: Map<ValueArgument, ValueParameterDescriptor>, argumentName: Name, descriptor: FunctionDescriptor): Tail? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'argumentToParameter' @ [353:31] ==> val argumentToParameter: Map<ValueArgument, ValueParameterDescriptor> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'argumentName' @ [353:52] ==> val argumentName: Name? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'descriptor' @ [353:66] ==> var descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'argument' @ [356:30] ==> value-parameter argument: ValueArgument defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[ValueParameterDescriptorImpl]

'getSpreadElement' @ [356:39] ==> public abstract fun getSpreadElement(): LeafPsiElement? defined in org.jetbrains.kotlin.psi.ValueArgument[DeserializedSimpleFunctionDescriptor]

'parameter' @ [358:33] ==> var parameter: ValueParameterDescriptor? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'varargElementType' @ [358:43] ==> public abstract val varargElementType: KotlinType? defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'if (varargElementType != null) {
            if (isFunctionLiteralArgument) return

            val varargTail = if (argumentName == null && tail == rparenthTail)
                null /* even if it's the last parameter, there can be more arguments for the same parameter */
            else
                tail

            if (!alreadyHasStar) {
                add(ExpectedInfo.createForArgument(varargElementType, expectedName?.unpluralize(), varargTail, argumentPositionData))
            }

            val starOptions = if (!alreadyHasStar) ItemOptions.STAR_PREFIX else ItemOptions.DEFAULT
            add(ExpectedInfo.createForArgument(parameterType, expectedName, varargTail, argumentPositionData, starOptions))
        }
        else {
            if (alreadyHasStar) return

            if (isFunctionLiteralArgument) {
                if (parameterType.isFunctionType) {
                    add(ExpectedInfo.createForArgument(parameterType, expectedName, null, argumentPositionData))
                }
            }
            else {
                add(ExpectedInfo.createForArgument(parameterType, expectedName, tail, argumentPositionData))
            }
        }' @ [359:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any, elseBranch: Any): Any[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any

'varargElementType' @ [359:13] ==> val varargElementType: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'isFunctionLiteralArgument' @ [360:17] ==> val isFunctionLiteralArgument: Boolean defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'if (argumentName == null && tail == rparenthTail)
                null /* even if it's the last parameter, there can be more arguments for the same parameter */
            else
                tail' @ [362:30] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Tail?, elseBranch: Tail?): Tail?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Tail?

'argumentName' @ [362:34] ==> val argumentName: Name? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'tail' @ [362:58] ==> val tail: Tail? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'rparenthTail' @ [362:66] ==> val rparenthTail: Tail defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'tail' @ [365:17] ==> val tail: Tail? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'!' @ [367:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'alreadyHasStar' @ [367:18] ==> val alreadyHasStar: Boolean defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'add' @ [368:17] ==> public abstract fun add(element: ExpectedInfo): Boolean defined in kotlin.collections.MutableCollection[DeserializedSimpleFunctionDescriptor]

'ExpectedInfo' @ [368:21] ==> public companion object defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[FakeCallableDescriptorForObject]

'createForArgument' @ [368:34] ==> public final fun createForArgument(type: KotlinType, expectedName: String?, tail: Tail?, argumentData: ArgumentPositionData, itemOptions: ItemOptions = ...): ExpectedInfo defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.Companion[SimpleFunctionDescriptorImpl]

'varargElementType' @ [368:52] ==> val varargElementType: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'expectedName' @ [368:71] ==> val expectedName: String? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'unpluralize' @ [368:85] ==> private final fun String.unpluralize(): String? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'varargTail' @ [368:100] ==> val varargTail: Tail? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'argumentPositionData' @ [368:112] ==> val argumentPositionData: ArgumentPositionData defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'if (!alreadyHasStar) ItemOptions.STAR_PREFIX else ItemOptions.DEFAULT' @ [371:31] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: ItemOptions, elseBranch: ItemOptions): ItemOptions[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> ItemOptions

'!' @ [371:35] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'alreadyHasStar' @ [371:36] ==> val alreadyHasStar: Boolean defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'ItemOptions' @ [371:52] ==> public companion object defined in org.jetbrains.kotlin.idea.core.ItemOptions[FakeCallableDescriptorForObject]

'STAR_PREFIX' @ [371:64] ==> public final val STAR_PREFIX: ItemOptions defined in org.jetbrains.kotlin.idea.core.ItemOptions.Companion[PropertyDescriptorImpl]

'ItemOptions' @ [371:81] ==> public companion object defined in org.jetbrains.kotlin.idea.core.ItemOptions[FakeCallableDescriptorForObject]

'DEFAULT' @ [371:93] ==> public final val DEFAULT: ItemOptions defined in org.jetbrains.kotlin.idea.core.ItemOptions.Companion[PropertyDescriptorImpl]

'add' @ [372:13] ==> public abstract fun add(element: ExpectedInfo): Boolean defined in kotlin.collections.MutableCollection[DeserializedSimpleFunctionDescriptor]

'ExpectedInfo' @ [372:17] ==> public companion object defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[FakeCallableDescriptorForObject]

'createForArgument' @ [372:30] ==> public final fun createForArgument(type: KotlinType, expectedName: String?, tail: Tail?, argumentData: ArgumentPositionData, itemOptions: ItemOptions = ...): ExpectedInfo defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.Companion[SimpleFunctionDescriptorImpl]

'parameterType' @ [372:48] ==> var parameterType: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'expectedName' @ [372:63] ==> val expectedName: String? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'varargTail' @ [372:77] ==> val varargTail: Tail? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'argumentPositionData' @ [372:89] ==> val argumentPositionData: ArgumentPositionData defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'starOptions' @ [372:111] ==> val starOptions: ItemOptions defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'alreadyHasStar' @ [375:17] ==> val alreadyHasStar: Boolean defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'if (isFunctionLiteralArgument) {
                if (parameterType.isFunctionType) {
                    add(ExpectedInfo.createForArgument(parameterType, expectedName, null, argumentPositionData))
                }
            }
            else {
                add(ExpectedInfo.createForArgument(parameterType, expectedName, tail, argumentPositionData))
            }' @ [377:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any, elseBranch: Any): Any[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any

'isFunctionLiteralArgument' @ [377:17] ==> val isFunctionLiteralArgument: Boolean defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'parameterType' @ [378:21] ==> var parameterType: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'isFunctionType' @ [378:35] ==> public val KotlinType.isFunctionType: Boolean defined in org.jetbrains.kotlin.builtins[DeserializedPropertyDescriptor]

'add' @ [379:21] ==> public abstract fun add(element: ExpectedInfo): Boolean defined in kotlin.collections.MutableCollection[DeserializedSimpleFunctionDescriptor]

'ExpectedInfo' @ [379:25] ==> public companion object defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[FakeCallableDescriptorForObject]

'createForArgument' @ [379:38] ==> public final fun createForArgument(type: KotlinType, expectedName: String?, tail: Tail?, argumentData: ArgumentPositionData, itemOptions: ItemOptions = ...): ExpectedInfo defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.Companion[SimpleFunctionDescriptorImpl]

'parameterType' @ [379:56] ==> var parameterType: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'expectedName' @ [379:71] ==> val expectedName: String? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'argumentPositionData' @ [379:91] ==> val argumentPositionData: ArgumentPositionData defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'add' @ [383:17] ==> public abstract fun add(element: ExpectedInfo): Boolean defined in kotlin.collections.MutableCollection[DeserializedSimpleFunctionDescriptor]

'ExpectedInfo' @ [383:21] ==> public companion object defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[FakeCallableDescriptorForObject]

'createForArgument' @ [383:34] ==> public final fun createForArgument(type: KotlinType, expectedName: String?, tail: Tail?, argumentData: ArgumentPositionData, itemOptions: ItemOptions = ...): ExpectedInfo defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.Companion[SimpleFunctionDescriptorImpl]

'parameterType' @ [383:52] ==> var parameterType: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'expectedName' @ [383:67] ==> val expectedName: String? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'tail' @ [383:81] ==> val tail: Tail? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'argumentPositionData' @ [383:87] ==> val argumentPositionData: ArgumentPositionData defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.addExpectedInfoForCandidate[LocalVariableDescriptor]

'substitutedType' @ [389:13] ==> value-parameter substitutedType: KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.fixSubstitutedType[ValueParameterDescriptorImpl]

'isError' @ [389:29] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types[DeserializedPropertyDescriptor]

'originalType' @ [389:45] ==> value-parameter originalType: KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.fixSubstitutedType[ValueParameterDescriptorImpl]

'substitutedType' @ [390:13] ==> value-parameter substitutedType: KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.fixSubstitutedType[ValueParameterDescriptorImpl]

'arguments' @ [390:29] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'size' @ [390:39] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'originalType' @ [390:47] ==> value-parameter originalType: KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.fixSubstitutedType[ValueParameterDescriptorImpl]

'arguments' @ [390:60] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'size' @ [390:70] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'originalType' @ [390:83] ==> value-parameter originalType: KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.fixSubstitutedType[ValueParameterDescriptorImpl]

'substitutedType' @ [391:32] ==> value-parameter substitutedType: KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.fixSubstitutedType[ValueParameterDescriptorImpl]

'arguments' @ [391:48] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'zip' @ [391:58] ==> public infix fun <T, R> Iterable<TypeProjection>.zip(other: Iterable<TypeProjection>): List<Pair<TypeProjection, TypeProjection>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection
    <R> -> TypeProjection

'originalType' @ [391:62] ==> value-parameter originalType: KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.fixSubstitutedType[ValueParameterDescriptorImpl]

'arguments' @ [391:75] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'map' @ [391:86] ==> public inline fun <T, R> Iterable<Pair<TypeProjection, TypeProjection>>.map(transform: (Pair<TypeProjection, TypeProjection>) -> TypeProjection): List<TypeProjection> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<TypeProjection, TypeProjection>
    <R> -> TypeProjection

'component1' @ [391:93] ==> public final operator fun component1(): TypeProjection defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [391:103] ==> public final operator fun component2(): TypeProjection defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'if (argument.type.containsError()) originalArgument else argument' @ [392:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: TypeProjection, elseBranch: TypeProjection): TypeProjection[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> TypeProjection

'argument' @ [392:17] ==> val argument: TypeProjection defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.fixSubstitutedType.<anonymous>[LocalVariableDescriptor]

'type' @ [392:26] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'containsError' @ [392:31] ==> public fun KotlinType.containsError(): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'originalArgument' @ [392:48] ==> val originalArgument: TypeProjection defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.fixSubstitutedType.<anonymous>[LocalVariableDescriptor]

'argument' @ [392:70] ==> val argument: TypeProjection defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.fixSubstitutedType.<anonymous>[LocalVariableDescriptor]

'substitutedType' @ [394:16] ==> value-parameter substitutedType: KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.fixSubstitutedType[ValueParameterDescriptorImpl]

'replace' @ [394:32] ==> @JvmOverloads public fun KotlinType.replace(newArguments: List<TypeProjection> = ..., newAnnotations: Annotations = ...): KotlinType defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'newTypeArguments' @ [394:40] ==> val newTypeArguments: List<TypeProjection> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.fixSubstitutedType[LocalVariableDescriptor]

'call' @ [398:15] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<D>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> D

'valueArguments' @ [398:20] ==> public final val Call.valueArguments: List<(ValueArgument..ValueArgument?)>[MyPropertyDescriptor]

'none' @ [398:35] ==> public inline fun <T> Iterable<(ValueArgument..ValueArgument?)>.none(predicate: ((ValueArgument..ValueArgument?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)

'getArgumentMapping' @ [398:54] ==> @NotNull public abstract fun getArgumentMapping(@NotNull p0: ValueArgument): ArgumentMapping defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCall[JavaMethodDescriptor]

'argument' @ [398:73] ==> value-parameter argument: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.allArgumentsMatched.<anonymous>[ValueParameterDescriptorImpl]

'isError' @ [398:83] ==> public abstract fun isError(): Boolean defined in org.jetbrains.kotlin.resolve.calls.model.ArgumentMapping[DeserializedSimpleFunctionDescriptor]

'!' @ [398:96] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'argument' @ [398:97] ==> value-parameter argument: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.allArgumentsMatched.<anonymous>[ValueParameterDescriptorImpl]

'hasError' @ [398:106] ==> private final fun ValueArgument.hasError(): Boolean defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'getArgumentExpression' @ [401:15] ==> @IfNotParsed public abstract fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.ValueArgument[DeserializedSimpleFunctionDescriptor]

'let' @ [401:40] ==> @InlineOnly public inline fun <T, R> KtExpression.let(block: (KtExpression) -> KotlinType?): KotlinType? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression
    <R> -> KotlinType?

'bindingContext' @ [401:46] ==> private final val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'getType' @ [401:61] ==> @Nullable public abstract fun getType(@NotNull p0: KtExpression): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]

'it' @ [401:69] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.hasError.<anonymous>[ValueParameterDescriptorImpl]

'isError' @ [401:76] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types[DeserializedPropertyDescriptor]

'argumentToParameter' @ [404:35] ==> value-parameter argumentToParameter: Map<ValueArgument, ValueParameterDescriptor> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.namedArgumentTail[ValueParameterDescriptorImpl]

'values' @ [404:55] ==> public abstract val values: Collection<ValueParameterDescriptor> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'map' @ [404:62] ==> public inline fun <T, R> Iterable<ValueParameterDescriptor>.map(transform: (ValueParameterDescriptor) -> Name): List<Name> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ValueParameterDescriptor
    <R> -> Name

'it' @ [404:68] ==> value-parameter it: ValueParameterDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.namedArgumentTail.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [404:71] ==> public final val ValueParameterDescriptor.name: Name[MyPropertyDescriptor]

'listOf' @ [404:80] ==> public fun <T> listOf(element: Name): List<Name> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Name

'argumentName' @ [404:87] ==> value-parameter argumentName: Name defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.namedArgumentTail[ValueParameterDescriptorImpl]

'toSet' @ [404:102] ==> public fun <T> Iterable<Name>.toSet(): Set<Name> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Name

'descriptor' @ [405:33] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.namedArgumentTail[ValueParameterDescriptorImpl]

'valueParameters' @ [405:44] ==> public final val FunctionDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'filter' @ [405:60] ==> public inline fun <T> Iterable<(ValueParameterDescriptor..ValueParameterDescriptor?)>.filter(predicate: ((ValueParameterDescriptor..ValueParameterDescriptor?)) -> Boolean): List<(ValueParameterDescriptor..ValueParameterDescriptor?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)

'it' @ [405:69] ==> value-parameter it: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.namedArgumentTail.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [405:72] ==> public final val ValueParameterDescriptor.name: Name[MyPropertyDescriptor]

'usedParameterNames' @ [405:81] ==> val usedParameterNames: Set<Name> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.namedArgumentTail[LocalVariableDescriptor]

'when {
            notUsedParameters.isEmpty() -> Tail.RPARENTH // named arguments no supported for []
            notUsedParameters.all { it.hasDefaultValue() } -> null
            else -> Tail.COMMA
        }' @ [406:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Tail?, entry1: Tail?, entry2: Tail?): Tail?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Tail?

'notUsedParameters' @ [407:13] ==> val notUsedParameters: List<(ValueParameterDescriptor..ValueParameterDescriptor?)> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.namedArgumentTail[LocalVariableDescriptor]

'isEmpty' @ [407:31] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'RPARENTH' @ [407:49] ==> enum entry RPARENTH defined in org.jetbrains.kotlin.idea.core.Tail[FakeCallableDescriptorForObject]

'notUsedParameters' @ [408:13] ==> val notUsedParameters: List<(ValueParameterDescriptor..ValueParameterDescriptor?)> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.namedArgumentTail[LocalVariableDescriptor]

'all' @ [408:31] ==> public inline fun <T> Iterable<(ValueParameterDescriptor..ValueParameterDescriptor?)>.all(predicate: ((ValueParameterDescriptor..ValueParameterDescriptor?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)

'it' @ [408:37] ==> value-parameter it: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.namedArgumentTail.<anonymous>[ValueParameterDescriptorImpl]

'hasDefaultValue' @ [408:40] ==> public fun ValueParameterDescriptor.hasDefaultValue(): Boolean defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedSimpleFunctionDescriptor]

'COMMA' @ [409:26] ==> enum entry COMMA defined in org.jetbrains.kotlin.idea.core.Tail[FakeCallableDescriptorForObject]

'expressionWithType' @ [414:32] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForEqAndAssignment[ValueParameterDescriptorImpl]

'parent' @ [414:51] ==> public final val KtExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'binaryExpression' @ [415:13] ==> val binaryExpression: KtBinaryExpression? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForEqAndAssignment[LocalVariableDescriptor]

'binaryExpression' @ [416:34] ==> val binaryExpression: KtBinaryExpression? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForEqAndAssignment[LocalVariableDescriptor]

'operationToken' @ [416:51] ==> public final val KtBinaryExpression.operationToken: IElementType[MyPropertyDescriptor]

'operationToken' @ [417:17] ==> val operationToken: IElementType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForEqAndAssignment[LocalVariableDescriptor]

'EQ' @ [417:44] ==> public final val EQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'operationToken' @ [417:50] ==> val operationToken: IElementType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForEqAndAssignment[LocalVariableDescriptor]

'COMPARISON_TOKENS' @ [417:68] ==> public val COMPARISON_TOKENS: Set<(KtSingleValueToken..KtSingleValueToken?)> defined in org.jetbrains.kotlin.idea.core in file ExpectedInfos.kt[PropertyDescriptorImpl]

'if (expressionWithType == binaryExpression.right) binaryExpression.left else binaryExpression.right' @ [418:36] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtExpression?, elseBranch: KtExpression?): KtExpression?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtExpression?

'expressionWithType' @ [418:40] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForEqAndAssignment[ValueParameterDescriptorImpl]

'binaryExpression' @ [418:62] ==> val binaryExpression: KtBinaryExpression? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForEqAndAssignment[LocalVariableDescriptor]

'right' @ [418:79] ==> public final val KtBinaryExpression.right: KtExpression?[MyPropertyDescriptor]

'binaryExpression' @ [418:86] ==> val binaryExpression: KtBinaryExpression? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForEqAndAssignment[LocalVariableDescriptor]

'left' @ [418:103] ==> public final val KtBinaryExpression.left: KtExpression?[MyPropertyDescriptor]

'binaryExpression' @ [418:113] ==> val binaryExpression: KtBinaryExpression? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForEqAndAssignment[LocalVariableDescriptor]

'right' @ [418:130] ==> public final val KtBinaryExpression.right: KtExpression?[MyPropertyDescriptor]

'otherOperand' @ [419:21] ==> val otherOperand: KtExpression? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForEqAndAssignment[LocalVariableDescriptor]

'bindingContext' @ [420:40] ==> private final val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'getType' @ [420:55] ==> @Nullable public abstract fun getType(@NotNull p0: KtExpression): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]

'otherOperand' @ [420:63] ==> val otherOperand: KtExpression? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForEqAndAssignment[LocalVariableDescriptor]

'expectedNameFromExpression' @ [422:40] ==> private final fun expectedNameFromExpression(expression: KtExpression?): String? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'otherOperand' @ [422:67] ==> val otherOperand: KtExpression? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForEqAndAssignment[LocalVariableDescriptor]

'expectedType' @ [424:25] ==> var expectedType: KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForEqAndAssignment[LocalVariableDescriptor]

'isNullableNothing' @ [424:38] ==> public fun KotlinType.isNullableNothing(): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'listOf' @ [425:32] ==> public fun <T> listOf(element: ExpectedInfo): List<ExpectedInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo

'ExpectedInfo' @ [425:39] ==> public constructor ExpectedInfo(filter: ByTypeFilter, expectedName: String?, tail: Tail?, itemOptions: ItemOptions = ..., additionalData: ExpectedInfo.AdditionalData? = ...) defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[ClassConstructorDescriptorImpl]

'NullableTypesFilter' @ [425:52] ==> private object NullableTypesFilter : ByTypeFilter defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[FakeCallableDescriptorForObject]

'expectedName' @ [425:73] ==> val expectedName: String? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForEqAndAssignment[LocalVariableDescriptor]

'operationToken' @ [429:25] ==> val operationToken: IElementType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForEqAndAssignment[LocalVariableDescriptor]

'COMPARISON_TOKENS' @ [429:43] ==> public val COMPARISON_TOKENS: Set<(KtSingleValueToken..KtSingleValueToken?)> defined in org.jetbrains.kotlin.idea.core in file ExpectedInfos.kt[PropertyDescriptorImpl]

'additionalData' @ [431:25] ==> var additionalData: ExpectedInfo.AdditionalData? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForEqAndAssignment[LocalVariableDescriptor]

'ComparisonOperandAdditionalData' @ [431:42] ==> public constructor ComparisonOperandAdditionalData(suppressNullLiteral: Boolean) defined in org.jetbrains.kotlin.idea.core.ComparisonOperandAdditionalData[ClassConstructorDescriptorImpl]

'expectedType' @ [431:96] ==> var expectedType: KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForEqAndAssignment[LocalVariableDescriptor]

'nullability' @ [431:109] ==> public fun KotlinType.nullability(): TypeNullability defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'NOT_NULL' @ [431:142] ==> enum entry NOT_NULL defined in org.jetbrains.kotlin.types.typeUtil.TypeNullability[FakeCallableDescriptorForObject]

'expectedType' @ [432:25] ==> var expectedType: KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForEqAndAssignment[LocalVariableDescriptor]

'expectedType' @ [432:40] ==> var expectedType: KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForEqAndAssignment[LocalVariableDescriptor]

'makeNullable' @ [432:53] ==> public fun KotlinType.makeNullable(): KotlinType defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'listOf' @ [435:28] ==> public fun <T> listOf(element: ExpectedInfo): List<ExpectedInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo

'ExpectedInfo' @ [435:35] ==> public constructor ExpectedInfo(type: KotlinType, expectedName: String?, tail: Tail?, itemOptions: ItemOptions = ..., additionalData: ExpectedInfo.AdditionalData? = ...) defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[ClassConstructorDescriptorImpl]

'expectedType' @ [435:48] ==> var expectedType: KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForEqAndAssignment[LocalVariableDescriptor]

'expectedName' @ [435:62] ==> val expectedName: String? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForEqAndAssignment[LocalVariableDescriptor]

'additionalData' @ [435:99] ==> var additionalData: ExpectedInfo.AdditionalData? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForEqAndAssignment[LocalVariableDescriptor]

'if (descriptorType.type.nullability() != TypeNullability.NOT_NULL) TypeSubstitutor.EMPTY else null' @ [444:19] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: TypeSubstitutor?, elseBranch: TypeSubstitutor?): TypeSubstitutor?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> TypeSubstitutor?

'descriptorType' @ [444:23] ==> value-parameter descriptorType: FuzzyType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.NullableTypesFilter.matchingSubstitutor[ValueParameterDescriptorImpl]

'type' @ [444:38] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.idea.util.FuzzyType[DeserializedPropertyDescriptor]

'nullability' @ [444:43] ==> public fun KotlinType.nullability(): TypeNullability defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'NOT_NULL' @ [444:76] ==> enum entry NOT_NULL defined in org.jetbrains.kotlin.types.typeUtil.TypeNullability[FakeCallableDescriptorForObject]

'EMPTY' @ [444:102] ==> public final val EMPTY: (TypeSubstitutor..TypeSubstitutor?) defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaPropertyDescriptor]

'?:' @ [448:28] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtIfExpression?, right: KtIfExpression): KtIfExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtIfExpression

'expressionWithType' @ [448:29] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIf[ValueParameterDescriptorImpl]

'parent' @ [448:48] ==> public final val KtExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [448:77] ==> public final val KtContainerNode.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'when (expressionWithType) {
            ifExpression.condition -> return listOf(ExpectedInfo(resolutionFacade.moduleDescriptor.builtIns.booleanType, null, Tail.RPARENTH, additionalData = IfConditionAdditionalData))

            ifExpression.then -> return calculate(ifExpression).map { ExpectedInfo(it.filter, it.expectedName, Tail.ELSE) }

            ifExpression.`else` -> {
                val ifExpectedInfos = calculate(ifExpression)
                val thenType = ifExpression.then?.let { bindingContext.getType(it) }

                if (ifExpectedInfos.any { it.fuzzyType != null }) {
                    val filteredInfo = if (thenType != null && !thenType.isError)
                        ifExpectedInfos.filter { it.matchingSubstitutor(thenType) != null }
                    else
                        ifExpectedInfos
                    return filteredInfo.copyWithNoAdditionalData()
                }
                else if (thenType != null) {
                    return listOf(ExpectedInfo(thenType, null, null))
                }
            }
        }' @ [449:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'expressionWithType' @ [449:15] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIf[ValueParameterDescriptorImpl]

'ifExpression' @ [450:13] ==> val ifExpression: KtIfExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIf[LocalVariableDescriptor]

'condition' @ [450:26] ==> public final val KtIfExpression.condition: KtExpression?[MyPropertyDescriptor]

'listOf' @ [450:46] ==> public fun <T> listOf(element: ExpectedInfo): List<ExpectedInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo

'ExpectedInfo' @ [450:53] ==> public constructor ExpectedInfo(type: KotlinType, expectedName: String?, tail: Tail?, itemOptions: ItemOptions = ..., additionalData: ExpectedInfo.AdditionalData? = ...) defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[ClassConstructorDescriptorImpl]

'resolutionFacade' @ [450:66] ==> private final val resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'moduleDescriptor' @ [450:83] ==> public abstract val moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.idea.resolve.ResolutionFacade[DeserializedPropertyDescriptor]

'builtIns' @ [450:100] ==> public abstract val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.descriptors.ModuleDescriptor[DeserializedPropertyDescriptor]

'booleanType' @ [450:109] ==> public final val KotlinBuiltIns.booleanType: SimpleType[MyPropertyDescriptor]

'RPARENTH' @ [450:133] ==> enum entry RPARENTH defined in org.jetbrains.kotlin.idea.core.Tail[FakeCallableDescriptorForObject]

'IfConditionAdditionalData' @ [450:160] ==> public object IfConditionAdditionalData : ExpectedInfo.AdditionalData defined in org.jetbrains.kotlin.idea.core in file ExpectedInfos.kt[FakeCallableDescriptorForObject]

'ifExpression' @ [452:13] ==> val ifExpression: KtIfExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIf[LocalVariableDescriptor]

'then' @ [452:26] ==> public final val KtIfExpression.then: KtExpression?[MyPropertyDescriptor]

'calculate' @ [452:41] ==> public final fun calculate(expressionWithType: KtExpression): Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'ifExpression' @ [452:51] ==> val ifExpression: KtIfExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIf[LocalVariableDescriptor]

'map' @ [452:65] ==> public inline fun <T, R> Iterable<ExpectedInfo>.map(transform: (ExpectedInfo) -> ExpectedInfo): List<ExpectedInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo
    <R> -> ExpectedInfo

'ExpectedInfo' @ [452:71] ==> public constructor ExpectedInfo(filter: ByTypeFilter, expectedName: String?, tail: Tail?, itemOptions: ItemOptions = ..., additionalData: ExpectedInfo.AdditionalData? = ...) defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[ClassConstructorDescriptorImpl]

'it' @ [452:84] ==> value-parameter it: ExpectedInfo defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIf.<anonymous>[ValueParameterDescriptorImpl]

'filter' @ [452:87] ==> public final val filter: ByTypeFilter defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[PropertyDescriptorImpl]

'it' @ [452:95] ==> value-parameter it: ExpectedInfo defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIf.<anonymous>[ValueParameterDescriptorImpl]

'expectedName' @ [452:98] ==> public final val expectedName: String? defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[PropertyDescriptorImpl]

'ELSE' @ [452:117] ==> enum entry ELSE defined in org.jetbrains.kotlin.idea.core.Tail[FakeCallableDescriptorForObject]

'ifExpression' @ [454:13] ==> val ifExpression: KtIfExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIf[LocalVariableDescriptor]

'`else`' @ [454:26] ==> public final val KtIfExpression.`else`: KtExpression?[MyPropertyDescriptor]

'calculate' @ [455:39] ==> public final fun calculate(expressionWithType: KtExpression): Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'ifExpression' @ [455:49] ==> val ifExpression: KtIfExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIf[LocalVariableDescriptor]

'ifExpression' @ [456:32] ==> val ifExpression: KtIfExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIf[LocalVariableDescriptor]

'then' @ [456:45] ==> public final val KtIfExpression.then: KtExpression?[MyPropertyDescriptor]

'let' @ [456:51] ==> @InlineOnly public inline fun <T, R> KtExpression.let(block: (KtExpression) -> KotlinType?): KotlinType? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression
    <R> -> KotlinType?

'bindingContext' @ [456:57] ==> private final val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'getType' @ [456:72] ==> @Nullable public abstract fun getType(@NotNull p0: KtExpression): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]

'it' @ [456:80] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIf.<anonymous>[ValueParameterDescriptorImpl]

'if (ifExpectedInfos.any { it.fuzzyType != null }) {
                    val filteredInfo = if (thenType != null && !thenType.isError)
                        ifExpectedInfos.filter { it.matchingSubstitutor(thenType) != null }
                    else
                        ifExpectedInfos
                    return filteredInfo.copyWithNoAdditionalData()
                }
                else if (thenType != null) {
                    return listOf(ExpectedInfo(thenType, null, null))
                }' @ [458:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'ifExpectedInfos' @ [458:21] ==> val ifExpectedInfos: Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIf[LocalVariableDescriptor]

'any' @ [458:37] ==> public inline fun <T> Iterable<ExpectedInfo>.any(predicate: (ExpectedInfo) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo

'it' @ [458:43] ==> value-parameter it: ExpectedInfo defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIf.<anonymous>[ValueParameterDescriptorImpl]

'fuzzyType' @ [458:46] ==> public val ExpectedInfo.fuzzyType: FuzzyType? defined in org.jetbrains.kotlin.idea.core in file ExpectedInfos.kt[PropertyDescriptorImpl]

'if (thenType != null && !thenType.isError)
                        ifExpectedInfos.filter { it.matchingSubstitutor(thenType) != null }
                    else
                        ifExpectedInfos' @ [459:40] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Collection<ExpectedInfo>, elseBranch: Collection<ExpectedInfo>): Collection<ExpectedInfo>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Collection<ExpectedInfo>

'thenType' @ [459:44] ==> val thenType: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIf[LocalVariableDescriptor]

'!' @ [459:64] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'thenType' @ [459:65] ==> val thenType: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIf[LocalVariableDescriptor]

'isError' @ [459:74] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types[DeserializedPropertyDescriptor]

'ifExpectedInfos' @ [460:25] ==> val ifExpectedInfos: Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIf[LocalVariableDescriptor]

'filter' @ [460:41] ==> public inline fun <T> Iterable<ExpectedInfo>.filter(predicate: (ExpectedInfo) -> Boolean): List<ExpectedInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo

'it' @ [460:50] ==> value-parameter it: ExpectedInfo defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIf.<anonymous>[ValueParameterDescriptorImpl]

'matchingSubstitutor' @ [460:53] ==> public final fun matchingSubstitutor(descriptorType: KotlinType): TypeSubstitutor? defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[SimpleFunctionDescriptorImpl]

'thenType' @ [460:73] ==> val thenType: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIf[LocalVariableDescriptor]

'ifExpectedInfos' @ [462:25] ==> val ifExpectedInfos: Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIf[LocalVariableDescriptor]

'filteredInfo' @ [463:28] ==> val filteredInfo: Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIf[LocalVariableDescriptor]

'copyWithNoAdditionalData' @ [463:41] ==> private final fun Collection<ExpectedInfo>.copyWithNoAdditionalData(): List<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'thenType' @ [465:26] ==> val thenType: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIf[LocalVariableDescriptor]

'listOf' @ [466:28] ==> public fun <T> listOf(element: ExpectedInfo): List<ExpectedInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo

'ExpectedInfo' @ [466:35] ==> public constructor ExpectedInfo(type: KotlinType, expectedName: String?, tail: Tail?, itemOptions: ItemOptions = ..., additionalData: ExpectedInfo.AdditionalData? = ...) defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[ClassConstructorDescriptorImpl]

'thenType' @ [466:48] ==> val thenType: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForIf[LocalVariableDescriptor]

'expressionWithType' @ [475:32] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForElvis[ValueParameterDescriptorImpl]

'parent' @ [475:51] ==> public final val KtExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'binaryExpression' @ [476:13] ==> val binaryExpression: KtBinaryExpression? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForElvis[LocalVariableDescriptor]

'binaryExpression' @ [477:34] ==> val binaryExpression: KtBinaryExpression? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForElvis[LocalVariableDescriptor]

'operationToken' @ [477:51] ==> public final val KtBinaryExpression.operationToken: IElementType[MyPropertyDescriptor]

'operationToken' @ [478:17] ==> val operationToken: IElementType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForElvis[LocalVariableDescriptor]

'ELVIS' @ [478:44] ==> public final val ELVIS: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'expressionWithType' @ [478:53] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForElvis[ValueParameterDescriptorImpl]

'binaryExpression' @ [478:75] ==> val binaryExpression: KtBinaryExpression? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForElvis[LocalVariableDescriptor]

'right' @ [478:92] ==> public final val KtBinaryExpression.right: KtExpression?[MyPropertyDescriptor]

'binaryExpression' @ [479:38] ==> val binaryExpression: KtBinaryExpression? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForElvis[LocalVariableDescriptor]

'left' @ [479:55] ==> public final val KtBinaryExpression.left: KtExpression?[MyPropertyDescriptor]

'bindingContext' @ [480:32] ==> private final val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'getType' @ [480:47] ==> @Nullable public abstract fun getType(@NotNull p0: KtExpression): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]

'leftExpression' @ [480:55] ==> val leftExpression: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForElvis[LocalVariableDescriptor]

'leftType' @ [481:43] ==> val leftType: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForElvis[LocalVariableDescriptor]

'makeNotNullable' @ [481:53] ==> public fun KotlinType.makeNotNullable(): KotlinType defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'calculate' @ [482:37] ==> public final fun calculate(expressionWithType: KtExpression): Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'binaryExpression' @ [482:47] ==> val binaryExpression: KtBinaryExpression? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForElvis[LocalVariableDescriptor]

'if (expectedInfos.any { it.fuzzyType != null }) {
                    val filteredInfo = if (leftTypeNotNullable != null)
                        expectedInfos.filter { it.matchingSubstitutor(leftTypeNotNullable) != null }
                    else
                        expectedInfos
                    return filteredInfo.copyWithNoAdditionalData()
                }
                else if (leftTypeNotNullable != null) {
                    return listOf(ExpectedInfo(leftTypeNotNullable, null, null))
                }' @ [483:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'expectedInfos' @ [483:21] ==> val expectedInfos: Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForElvis[LocalVariableDescriptor]

'any' @ [483:35] ==> public inline fun <T> Iterable<ExpectedInfo>.any(predicate: (ExpectedInfo) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo

'it' @ [483:41] ==> value-parameter it: ExpectedInfo defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForElvis.<anonymous>[ValueParameterDescriptorImpl]

'fuzzyType' @ [483:44] ==> public val ExpectedInfo.fuzzyType: FuzzyType? defined in org.jetbrains.kotlin.idea.core in file ExpectedInfos.kt[PropertyDescriptorImpl]

'if (leftTypeNotNullable != null)
                        expectedInfos.filter { it.matchingSubstitutor(leftTypeNotNullable) != null }
                    else
                        expectedInfos' @ [484:40] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Collection<ExpectedInfo>, elseBranch: Collection<ExpectedInfo>): Collection<ExpectedInfo>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Collection<ExpectedInfo>

'leftTypeNotNullable' @ [484:44] ==> val leftTypeNotNullable: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForElvis[LocalVariableDescriptor]

'expectedInfos' @ [485:25] ==> val expectedInfos: Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForElvis[LocalVariableDescriptor]

'filter' @ [485:39] ==> public inline fun <T> Iterable<ExpectedInfo>.filter(predicate: (ExpectedInfo) -> Boolean): List<ExpectedInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo

'it' @ [485:48] ==> value-parameter it: ExpectedInfo defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForElvis.<anonymous>[ValueParameterDescriptorImpl]

'matchingSubstitutor' @ [485:51] ==> public final fun matchingSubstitutor(descriptorType: KotlinType): TypeSubstitutor? defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[SimpleFunctionDescriptorImpl]

'leftTypeNotNullable' @ [485:71] ==> val leftTypeNotNullable: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForElvis[LocalVariableDescriptor]

'expectedInfos' @ [487:25] ==> val expectedInfos: Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForElvis[LocalVariableDescriptor]

'filteredInfo' @ [488:28] ==> val filteredInfo: Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForElvis[LocalVariableDescriptor]

'copyWithNoAdditionalData' @ [488:41] ==> private final fun Collection<ExpectedInfo>.copyWithNoAdditionalData(): List<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'leftTypeNotNullable' @ [490:26] ==> val leftTypeNotNullable: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForElvis[LocalVariableDescriptor]

'listOf' @ [491:28] ==> public fun <T> listOf(element: ExpectedInfo): List<ExpectedInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo

'ExpectedInfo' @ [491:35] ==> public constructor ExpectedInfo(type: KotlinType, expectedName: String?, tail: Tail?, itemOptions: ItemOptions = ..., additionalData: ExpectedInfo.AdditionalData? = ...) defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[ClassConstructorDescriptorImpl]

'leftTypeNotNullable' @ [491:48] ==> val leftTypeNotNullable: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForElvis[LocalVariableDescriptor]

'expressionWithType' @ [499:21] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForBlockExpression[ValueParameterDescriptorImpl]

'parent' @ [499:40] ==> public final val KtExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'expressionWithType' @ [500:13] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForBlockExpression[ValueParameterDescriptorImpl]

'block' @ [500:35] ==> val block: KtBlockExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForBlockExpression[LocalVariableDescriptor]

'statements' @ [500:41] ==> public final val KtBlockExpression.statements: List<(KtExpression..KtExpression?)>[MyPropertyDescriptor]

'last' @ [500:52] ==> public fun <T> List<(KtExpression..KtExpression?)>.last(): (KtExpression..KtExpression?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)

'block' @ [502:31] ==> val block: KtBlockExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForBlockExpression[LocalVariableDescriptor]

'parent' @ [502:37] ==> public final val KtBlockExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'if (functionLiteral != null) {
            val literalExpression = functionLiteral.parent as KtLambdaExpression
            calculate(literalExpression)
                    .mapNotNull { it.fuzzyType }
                    .filter { it.type.isFunctionType }
                    .map {
                        val returnType = it.type.getReturnTypeFromFunctionType()
                        ExpectedInfo(returnType.toFuzzyType(it.freeParameters), null, Tail.RBRACE)
                    }
        }
        else {
            calculate(block).map { ExpectedInfo(it.filter, it.expectedName, null) }
        }' @ [503:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Collection<ExpectedInfo>?, elseBranch: Collection<ExpectedInfo>?): Collection<ExpectedInfo>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Collection<ExpectedInfo>?

'functionLiteral' @ [503:20] ==> val functionLiteral: KtFunctionLiteral? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForBlockExpression[LocalVariableDescriptor]

'functionLiteral' @ [504:37] ==> val functionLiteral: KtFunctionLiteral? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForBlockExpression[LocalVariableDescriptor]

'parent' @ [504:53] ==> public final val KtFunctionLiteral.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'calculate' @ [505:13] ==> public final fun calculate(expressionWithType: KtExpression): Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'literalExpression' @ [505:23] ==> val literalExpression: KtLambdaExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForBlockExpression[LocalVariableDescriptor]

'mapNotNull' @ [506:22] ==> public inline fun <T, R : Any> Iterable<ExpectedInfo>.mapNotNull(transform: (ExpectedInfo) -> FuzzyType?): List<FuzzyType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo
    <R : Any> -> FuzzyType

'it' @ [506:35] ==> value-parameter it: ExpectedInfo defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForBlockExpression.<anonymous>[ValueParameterDescriptorImpl]

'fuzzyType' @ [506:38] ==> public val ExpectedInfo.fuzzyType: FuzzyType? defined in org.jetbrains.kotlin.idea.core in file ExpectedInfos.kt[PropertyDescriptorImpl]

'filter' @ [507:22] ==> public inline fun <T> Iterable<FuzzyType>.filter(predicate: (FuzzyType) -> Boolean): List<FuzzyType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FuzzyType

'it' @ [507:31] ==> value-parameter it: FuzzyType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForBlockExpression.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [507:34] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.idea.util.FuzzyType[DeserializedPropertyDescriptor]

'isFunctionType' @ [507:39] ==> public val KotlinType.isFunctionType: Boolean defined in org.jetbrains.kotlin.builtins[DeserializedPropertyDescriptor]

'map' @ [508:22] ==> public inline fun <T, R> Iterable<FuzzyType>.map(transform: (FuzzyType) -> ExpectedInfo): List<ExpectedInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FuzzyType
    <R> -> ExpectedInfo

'it' @ [509:42] ==> value-parameter it: FuzzyType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForBlockExpression.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [509:45] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.idea.util.FuzzyType[DeserializedPropertyDescriptor]

'getReturnTypeFromFunctionType' @ [509:50] ==> public fun KotlinType.getReturnTypeFromFunctionType(): KotlinType defined in org.jetbrains.kotlin.builtins[DeserializedSimpleFunctionDescriptor]

'ExpectedInfo' @ [510:25] ==> public constructor ExpectedInfo(fuzzyType: FuzzyType, expectedName: String?, tail: Tail?, itemOptions: ItemOptions = ..., additionalData: ExpectedInfo.AdditionalData? = ...) defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[ClassConstructorDescriptorImpl]

'returnType' @ [510:38] ==> val returnType: KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForBlockExpression.<anonymous>[LocalVariableDescriptor]

'toFuzzyType' @ [510:49] ==> public fun KotlinType.toFuzzyType(freeParameters: Collection<TypeParameterDescriptor>): FuzzyType defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'it' @ [510:61] ==> value-parameter it: FuzzyType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForBlockExpression.<anonymous>[ValueParameterDescriptorImpl]

'freeParameters' @ [510:64] ==> public final val freeParameters: Set<TypeParameterDescriptor> defined in org.jetbrains.kotlin.idea.util.FuzzyType[DeserializedPropertyDescriptor]

'RBRACE' @ [510:92] ==> enum entry RBRACE defined in org.jetbrains.kotlin.idea.core.Tail[FakeCallableDescriptorForObject]

'calculate' @ [514:13] ==> public final fun calculate(expressionWithType: KtExpression): Collection<ExpectedInfo> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'block' @ [514:23] ==> val block: KtBlockExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForBlockExpression[LocalVariableDescriptor]

'map' @ [514:30] ==> public inline fun <T, R> Iterable<ExpectedInfo>.map(transform: (ExpectedInfo) -> ExpectedInfo): List<ExpectedInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo
    <R> -> ExpectedInfo

'ExpectedInfo' @ [514:36] ==> public constructor ExpectedInfo(filter: ByTypeFilter, expectedName: String?, tail: Tail?, itemOptions: ItemOptions = ..., additionalData: ExpectedInfo.AdditionalData? = ...) defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[ClassConstructorDescriptorImpl]

'it' @ [514:49] ==> value-parameter it: ExpectedInfo defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForBlockExpression.<anonymous>[ValueParameterDescriptorImpl]

'filter' @ [514:52] ==> public final val filter: ByTypeFilter defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[PropertyDescriptorImpl]

'it' @ [514:60] ==> value-parameter it: ExpectedInfo defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForBlockExpression.<anonymous>[ValueParameterDescriptorImpl]

'expectedName' @ [514:63] ==> public final val expectedName: String? defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[PropertyDescriptorImpl]

'expressionWithType' @ [519:25] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForWhenEntryValue[ValueParameterDescriptorImpl]

'parent' @ [519:44] ==> public final val KtExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'condition' @ [520:21] ==> val condition: KtWhenConditionWithExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForWhenEntryValue[LocalVariableDescriptor]

'parent' @ [520:31] ==> public final val KtWhenConditionWithExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'entry' @ [521:30] ==> val entry: KtWhenEntry defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForWhenEntryValue[LocalVariableDescriptor]

'parent' @ [521:36] ==> public final val KtWhenEntry.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'whenExpression' @ [522:23] ==> val whenExpression: KtWhenExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForWhenEntryValue[LocalVariableDescriptor]

'subjectExpression' @ [522:38] ==> public final val KtWhenExpression.subjectExpression: KtExpression?[MyPropertyDescriptor]

'if (subject != null) {
            val subjectType = bindingContext.getType(subject) ?: return null
            return listOf(ExpectedInfo(subjectType, null, null, additionalData = WhenEntryAdditionalData(whenWithSubject = true)))
        }
        else {
            return listOf(ExpectedInfo(resolutionFacade.moduleDescriptor.builtIns.booleanType, null, null, additionalData = WhenEntryAdditionalData(whenWithSubject = false)))
        }' @ [523:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nothing, elseBranch: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nothing

'subject' @ [523:13] ==> val subject: KtExpression? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForWhenEntryValue[LocalVariableDescriptor]

'bindingContext' @ [524:31] ==> private final val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'getType' @ [524:46] ==> @Nullable public abstract fun getType(@NotNull p0: KtExpression): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]

'subject' @ [524:54] ==> val subject: KtExpression? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForWhenEntryValue[LocalVariableDescriptor]

'listOf' @ [525:20] ==> public fun <T> listOf(element: ExpectedInfo): List<ExpectedInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo

'ExpectedInfo' @ [525:27] ==> public constructor ExpectedInfo(type: KotlinType, expectedName: String?, tail: Tail?, itemOptions: ItemOptions = ..., additionalData: ExpectedInfo.AdditionalData? = ...) defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[ClassConstructorDescriptorImpl]

'subjectType' @ [525:40] ==> val subjectType: KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForWhenEntryValue[LocalVariableDescriptor]

'WhenEntryAdditionalData' @ [525:82] ==> public constructor WhenEntryAdditionalData(whenWithSubject: Boolean) defined in org.jetbrains.kotlin.idea.core.WhenEntryAdditionalData[ClassConstructorDescriptorImpl]

'listOf' @ [528:20] ==> public fun <T> listOf(element: ExpectedInfo): List<ExpectedInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo

'ExpectedInfo' @ [528:27] ==> public constructor ExpectedInfo(type: KotlinType, expectedName: String?, tail: Tail?, itemOptions: ItemOptions = ..., additionalData: ExpectedInfo.AdditionalData? = ...) defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[ClassConstructorDescriptorImpl]

'resolutionFacade' @ [528:40] ==> private final val resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'moduleDescriptor' @ [528:57] ==> public abstract val moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.idea.resolve.ResolutionFacade[DeserializedPropertyDescriptor]

'builtIns' @ [528:74] ==> public abstract val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.descriptors.ModuleDescriptor[DeserializedPropertyDescriptor]

'booleanType' @ [528:83] ==> public final val KotlinBuiltIns.booleanType: SimpleType[MyPropertyDescriptor]

'WhenEntryAdditionalData' @ [528:125] ==> public constructor WhenEntryAdditionalData(whenWithSubject: Boolean) defined in org.jetbrains.kotlin.idea.core.WhenEntryAdditionalData[ClassConstructorDescriptorImpl]

'expressionWithType' @ [533:32] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForExclOperand[ValueParameterDescriptorImpl]

'parent' @ [533:51] ==> public final val KtExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'prefixExpression' @ [534:13] ==> val prefixExpression: KtPrefixExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForExclOperand[LocalVariableDescriptor]

'operationToken' @ [534:30] ==> public final val KtPrefixExpression.operationToken: (IElementType..IElementType?)[MyPropertyDescriptor]

'EXCL' @ [534:57] ==> public final val EXCL: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'listOf' @ [535:16] ==> public fun <T> listOf(element: ExpectedInfo): List<ExpectedInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo

'ExpectedInfo' @ [535:23] ==> public constructor ExpectedInfo(type: KotlinType, expectedName: String?, tail: Tail?, itemOptions: ItemOptions = ..., additionalData: ExpectedInfo.AdditionalData? = ...) defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[ClassConstructorDescriptorImpl]

'resolutionFacade' @ [535:36] ==> private final val resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'moduleDescriptor' @ [535:53] ==> public abstract val moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.idea.resolve.ResolutionFacade[DeserializedPropertyDescriptor]

'builtIns' @ [535:70] ==> public abstract val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.descriptors.ModuleDescriptor[DeserializedPropertyDescriptor]

'booleanType' @ [535:79] ==> public final val KotlinBuiltIns.booleanType: SimpleType[MyPropertyDescriptor]

'expressionWithType' @ [539:24] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInitializer[ValueParameterDescriptorImpl]

'parent' @ [539:43] ==> public final val KtExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'expressionWithType' @ [540:13] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInitializer[ValueParameterDescriptorImpl]

'property' @ [540:35] ==> val property: KtProperty defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInitializer[LocalVariableDescriptor]

'initializer' @ [540:44] ==> public final var KtProperty.initializer: KtExpression?[MyPropertyDescriptor]

'bindingContext' @ [541:34] ==> private final val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'DECLARATION_TO_DESCRIPTOR' @ [541:64] ==> public final val DECLARATION_TO_DESCRIPTOR: (ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'property' @ [541:91] ==> val property: KtProperty defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInitializer[LocalVariableDescriptor]

'propertyDescriptor' @ [542:28] ==> val propertyDescriptor: VariableDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInitializer[LocalVariableDescriptor]

'name' @ [542:47] ==> public final val VariableDescriptor.name: Name[MyPropertyDescriptor]

'asString' @ [542:52] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'returnTypeToUse' @ [543:31] ==> private final fun returnTypeToUse(descriptor: CallableDescriptor, hasExplicitReturnType: Boolean): KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'propertyDescriptor' @ [543:47] ==> val propertyDescriptor: VariableDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInitializer[LocalVariableDescriptor]

'property' @ [543:91] ==> val property: KtProperty defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInitializer[LocalVariableDescriptor]

'typeReference' @ [543:100] ==> public final var KtProperty.typeReference: KtTypeReference?[MyPropertyDescriptor]

'if (returnTypeToUse != null)
            ExpectedInfo(returnTypeToUse, expectedName, null)
        else
            ExpectedInfo(ByTypeFilter.All, expectedName, null)' @ [544:28] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: ExpectedInfo, elseBranch: ExpectedInfo): ExpectedInfo[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> ExpectedInfo

'returnTypeToUse' @ [544:32] ==> val returnTypeToUse: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInitializer[LocalVariableDescriptor]

'ExpectedInfo' @ [545:13] ==> public constructor ExpectedInfo(type: KotlinType, expectedName: String?, tail: Tail?, itemOptions: ItemOptions = ..., additionalData: ExpectedInfo.AdditionalData? = ...) defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[ClassConstructorDescriptorImpl]

'returnTypeToUse' @ [545:26] ==> val returnTypeToUse: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInitializer[LocalVariableDescriptor]

'expectedName' @ [545:43] ==> val expectedName: String defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInitializer[LocalVariableDescriptor]

'ExpectedInfo' @ [547:13] ==> public constructor ExpectedInfo(filter: ByTypeFilter, expectedName: String?, tail: Tail?, itemOptions: ItemOptions = ..., additionalData: ExpectedInfo.AdditionalData? = ...) defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[ClassConstructorDescriptorImpl]

'All' @ [547:39] ==> public object All : ByTypeFilter defined in org.jetbrains.kotlin.idea.core.ByTypeFilter[FakeCallableDescriptorForObject]

'expectedName' @ [547:44] ==> val expectedName: String defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInitializer[LocalVariableDescriptor]

'listOf' @ [548:16] ==> public fun <T> listOf(element: ExpectedInfo): List<ExpectedInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo

'expectedInfo' @ [548:23] ==> val expectedInfo: ExpectedInfo defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInitializer[LocalVariableDescriptor]

'expressionWithType' @ [552:27] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForExpressionBody[ValueParameterDescriptorImpl]

'parent' @ [552:46] ==> public final val KtExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'expressionWithType' @ [553:13] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForExpressionBody[ValueParameterDescriptorImpl]

'declaration' @ [553:35] ==> val declaration: KtDeclarationWithBody defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForExpressionBody[LocalVariableDescriptor]

'bodyExpression' @ [553:47] ==> public final val KtDeclarationWithBody.bodyExpression: KtExpression?[MyPropertyDescriptor]

'declaration' @ [553:65] ==> val declaration: KtDeclarationWithBody defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForExpressionBody[LocalVariableDescriptor]

'hasBlockBody' @ [553:77] ==> public abstract fun hasBlockBody(): Boolean defined in org.jetbrains.kotlin.psi.KtDeclarationWithBody[JavaMethodDescriptor]

'bindingContext' @ [554:26] ==> private final val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'DECLARATION_TO_DESCRIPTOR' @ [554:56] ==> public final val DECLARATION_TO_DESCRIPTOR: (ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'declaration' @ [554:83] ==> val declaration: KtDeclarationWithBody defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForExpressionBody[LocalVariableDescriptor]

'listOfNotNull' @ [555:16] ==> public fun <T : Any> listOfNotNull(element: ExpectedInfo?): List<ExpectedInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> ExpectedInfo

'functionReturnValueExpectedInfo' @ [555:30] ==> private final fun functionReturnValueExpectedInfo(descriptor: FunctionDescriptor, hasExplicitReturnType: Boolean): ExpectedInfo? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'descriptor' @ [555:62] ==> val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForExpressionBody[LocalVariableDescriptor]

'declaration' @ [555:98] ==> val declaration: KtDeclarationWithBody defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForExpressionBody[LocalVariableDescriptor]

'hasDeclaredReturnType' @ [555:110] ==> public abstract fun hasDeclaredReturnType(): Boolean defined in org.jetbrains.kotlin.psi.KtDeclarationWithBody[JavaMethodDescriptor]

'expressionWithType' @ [559:32] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForReturn[ValueParameterDescriptorImpl]

'parent' @ [559:51] ==> public final val KtExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'returnExpression' @ [560:26] ==> val returnExpression: KtReturnExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForReturn[LocalVariableDescriptor]

'getTargetFunctionDescriptor' @ [560:43] ==> public fun KtReturnExpression.getTargetFunctionDescriptor(context: BindingContext): FunctionDescriptor? defined in org.jetbrains.kotlin.resolve.bindingContextUtil[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [560:71] ==> private final val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'listOfNotNull' @ [561:16] ==> public fun <T : Any> listOfNotNull(element: ExpectedInfo?): List<ExpectedInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> ExpectedInfo

'functionReturnValueExpectedInfo' @ [561:30] ==> private final fun functionReturnValueExpectedInfo(descriptor: FunctionDescriptor, hasExplicitReturnType: Boolean): ExpectedInfo? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'descriptor' @ [561:62] ==> val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForReturn[LocalVariableDescriptor]

'when (descriptor) {
            is SimpleFunctionDescriptor -> {
                ExpectedInfo.createForReturnValue(returnTypeToUse(descriptor, hasExplicitReturnType), descriptor)
            }

            is PropertyGetterDescriptor -> {
                val property = descriptor.correspondingProperty
                ExpectedInfo.createForReturnValue(returnTypeToUse(property, hasExplicitReturnType), property)
            }

            else -> null
        }' @ [565:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: ExpectedInfo?, entry1: ExpectedInfo?, entry2: ExpectedInfo?): ExpectedInfo?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> ExpectedInfo?

'descriptor' @ [565:22] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.functionReturnValueExpectedInfo[ValueParameterDescriptorImpl]

'ExpectedInfo' @ [567:17] ==> public companion object defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[FakeCallableDescriptorForObject]

'createForReturnValue' @ [567:30] ==> public final fun createForReturnValue(type: KotlinType?, callable: CallableDescriptor): ExpectedInfo defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.Companion[SimpleFunctionDescriptorImpl]

'returnTypeToUse' @ [567:51] ==> private final fun returnTypeToUse(descriptor: CallableDescriptor, hasExplicitReturnType: Boolean): KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'descriptor' @ [567:67] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.functionReturnValueExpectedInfo[ValueParameterDescriptorImpl]

'hasExplicitReturnType' @ [567:79] ==> value-parameter hasExplicitReturnType: Boolean defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.functionReturnValueExpectedInfo[ValueParameterDescriptorImpl]

'descriptor' @ [567:103] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.functionReturnValueExpectedInfo[ValueParameterDescriptorImpl]

'descriptor' @ [571:32] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.functionReturnValueExpectedInfo[ValueParameterDescriptorImpl]

'correspondingProperty' @ [571:43] ==> public final val PropertyGetterDescriptor.correspondingProperty: PropertyDescriptor[MyPropertyDescriptor]

'ExpectedInfo' @ [572:17] ==> public companion object defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[FakeCallableDescriptorForObject]

'createForReturnValue' @ [572:30] ==> public final fun createForReturnValue(type: KotlinType?, callable: CallableDescriptor): ExpectedInfo defined in org.jetbrains.kotlin.idea.core.ExpectedInfo.Companion[SimpleFunctionDescriptorImpl]

'returnTypeToUse' @ [572:51] ==> private final fun returnTypeToUse(descriptor: CallableDescriptor, hasExplicitReturnType: Boolean): KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'property' @ [572:67] ==> val property: PropertyDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.functionReturnValueExpectedInfo[LocalVariableDescriptor]

'hasExplicitReturnType' @ [572:77] ==> value-parameter hasExplicitReturnType: Boolean defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.functionReturnValueExpectedInfo[ValueParameterDescriptorImpl]

'property' @ [572:101] ==> val property: PropertyDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.functionReturnValueExpectedInfo[LocalVariableDescriptor]

'if (hasExplicitReturnType)
            descriptor.returnType
        else
            descriptor.overriddenDescriptors.singleOrNull()?.returnType' @ [580:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType?, elseBranch: KotlinType?): KotlinType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType?

'hasExplicitReturnType' @ [580:20] ==> value-parameter hasExplicitReturnType: Boolean defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.returnTypeToUse[ValueParameterDescriptorImpl]

'descriptor' @ [581:13] ==> value-parameter descriptor: CallableDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.returnTypeToUse[ValueParameterDescriptorImpl]

'returnType' @ [581:24] ==> public final val CallableDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'descriptor' @ [583:13] ==> value-parameter descriptor: CallableDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.returnTypeToUse[ValueParameterDescriptorImpl]

'overriddenDescriptors' @ [583:24] ==> public final val CallableDescriptor.overriddenDescriptors: (MutableCollection<out (CallableDescriptor..CallableDescriptor?)>..Collection<(CallableDescriptor..CallableDescriptor?)>)[MyPropertyDescriptor]

'singleOrNull' @ [583:46] ==> public fun <T> Iterable<(CallableDescriptor..CallableDescriptor?)>.singleOrNull(): CallableDescriptor? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'returnType' @ [583:62] ==> public final val CallableDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'?:' @ [587:29] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtForExpression?, right: KtForExpression): KtForExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtForExpression

'expressionWithType' @ [587:30] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForLoopRange[ValueParameterDescriptorImpl]

'parent' @ [587:49] ==> public final val KtExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [588:39] ==> public final val KtContainerNode.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'expressionWithType' @ [589:13] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForLoopRange[ValueParameterDescriptorImpl]

'forExpression' @ [589:35] ==> val forExpression: KtForExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForLoopRange[LocalVariableDescriptor]

'loopRange' @ [589:49] ==> public final val KtForExpression.loopRange: KtExpression?[MyPropertyDescriptor]

'forExpression' @ [591:23] ==> val forExpression: KtForExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForLoopRange[LocalVariableDescriptor]

'loopParameter' @ [591:37] ==> public final val KtForExpression.loopParameter: KtParameter?[MyPropertyDescriptor]

'if (loopVar?.typeReference != null)
            (bindingContext[BindingContext.DECLARATION_TO_DESCRIPTOR, loopVar] as VariableDescriptor).type.takeUnless { it.isError }
        else
            null' @ [592:27] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType?, elseBranch: KotlinType?): KotlinType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType?

'loopVar' @ [592:31] ==> val loopVar: KtParameter? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForLoopRange[LocalVariableDescriptor]

'typeReference' @ [592:40] ==> public final var KtParameter.typeReference: KtTypeReference?[MyPropertyDescriptor]

'bindingContext' @ [593:14] ==> private final val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'DECLARATION_TO_DESCRIPTOR' @ [593:44] ==> public final val DECLARATION_TO_DESCRIPTOR: (ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'loopVar' @ [593:71] ==> val loopVar: KtParameter? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForLoopRange[LocalVariableDescriptor]

'type' @ [593:103] ==> public final val VariableDescriptor.type: KotlinType[MyPropertyDescriptor]

'takeUnless' @ [593:108] ==> @InlineOnly @SinceKotlin public inline fun <T> KotlinType.takeUnless(predicate: (KotlinType) -> Boolean): KotlinType? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'it' @ [593:121] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForLoopRange.<anonymous>[ValueParameterDescriptorImpl]

'isError' @ [593:124] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types[DeserializedPropertyDescriptor]

'expressionWithType' @ [597:21] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForLoopRange[ValueParameterDescriptorImpl]

'getResolutionScope' @ [597:40] ==> public fun PsiElement.getResolutionScope(bindingContext: BindingContext, resolutionFacade: ResolutionFacade): LexicalScope defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [597:59] ==> private final val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'resolutionFacade' @ [597:75] ==> private final val resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'resolutionFacade' @ [598:32] ==> private final val resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'ideService' @ [598:49] ==> public inline fun <reified T : Any> ResolutionFacade.ideService(): IterableTypesDetection defined in org.jetbrains.kotlin.idea.resolve[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : Any> -> IterableTypesDetection

'createDetector' @ [598:86] ==> public final fun createDetector(scope: LexicalScope): IterableTypesDetector defined in org.jetbrains.kotlin.idea.core.IterableTypesDetection[SimpleFunctionDescriptorImpl]

'scope' @ [598:101] ==> val scope: LexicalScope defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForLoopRange[LocalVariableDescriptor]

'if (iterableDetector.isIterable(descriptorType, loopVarType)) TypeSubstitutor.EMPTY else null' @ [602:24] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: TypeSubstitutor?, elseBranch: TypeSubstitutor?): TypeSubstitutor?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> TypeSubstitutor?

'iterableDetector' @ [602:28] ==> val iterableDetector: IterableTypesDetector defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForLoopRange[LocalVariableDescriptor]

'isIterable' @ [602:45] ==> public abstract fun isIterable(type: FuzzyType, loopVarType: KotlinType? = ...): Boolean defined in org.jetbrains.kotlin.idea.core.IterableTypesDetector[SimpleFunctionDescriptorImpl]

'descriptorType' @ [602:56] ==> value-parameter descriptorType: FuzzyType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForLoopRange.<no name provided>.matchingSubstitutor[ValueParameterDescriptorImpl]

'loopVarType' @ [602:72] ==> val loopVarType: KotlinType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForLoopRange[LocalVariableDescriptor]

'EMPTY' @ [602:102] ==> public final val EMPTY: (TypeSubstitutor..TypeSubstitutor?) defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaPropertyDescriptor]

'listOf' @ [605:16] ==> public fun <T> listOf(element: ExpectedInfo): List<ExpectedInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo

'ExpectedInfo' @ [605:23] ==> public constructor ExpectedInfo(filter: ByTypeFilter, expectedName: String?, tail: Tail?, itemOptions: ItemOptions = ..., additionalData: ExpectedInfo.AdditionalData? = ...) defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[ClassConstructorDescriptorImpl]

'byTypeFilter' @ [605:36] ==> val byTypeFilter: <no name provided> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForLoopRange[LocalVariableDescriptor]

'RPARENTH' @ [605:61] ==> enum entry RPARENTH defined in org.jetbrains.kotlin.idea.core.Tail[FakeCallableDescriptorForObject]

'expressionWithType' @ [609:32] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInOperatorArgument[ValueParameterDescriptorImpl]

'parent' @ [609:51] ==> public final val KtExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'binaryExpression' @ [610:30] ==> val binaryExpression: KtBinaryExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInOperatorArgument[LocalVariableDescriptor]

'operationToken' @ [610:47] ==> public final val KtBinaryExpression.operationToken: IElementType[MyPropertyDescriptor]

'operationToken' @ [611:13] ==> val operationToken: IElementType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInOperatorArgument[LocalVariableDescriptor]

'IN_KEYWORD' @ [611:40] ==> public final val IN_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'operationToken' @ [611:54] ==> val operationToken: IElementType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInOperatorArgument[LocalVariableDescriptor]

'NOT_IN' @ [611:81] ==> public final val NOT_IN: (KtKeywordToken..KtKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'expressionWithType' @ [611:91] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInOperatorArgument[ValueParameterDescriptorImpl]

'binaryExpression' @ [611:113] ==> val binaryExpression: KtBinaryExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInOperatorArgument[LocalVariableDescriptor]

'right' @ [611:130] ==> public final val KtBinaryExpression.right: KtExpression?[MyPropertyDescriptor]

'binaryExpression' @ [613:31] ==> val binaryExpression: KtBinaryExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInOperatorArgument[LocalVariableDescriptor]

'left' @ [613:48] ==> public final val KtBinaryExpression.left: KtExpression?[MyPropertyDescriptor]

'let' @ [613:54] ==> @InlineOnly public inline fun <T, R> KtExpression.let(block: (KtExpression) -> KotlinType?): KotlinType? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression
    <R> -> KotlinType?

'bindingContext' @ [613:60] ==> private final val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'getType' @ [613:75] ==> @Nullable public abstract fun getType(@NotNull p0: KtExpression): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]

'it' @ [613:83] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInOperatorArgument.<anonymous>[ValueParameterDescriptorImpl]

'expressionWithType' @ [614:21] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInOperatorArgument[ValueParameterDescriptorImpl]

'getResolutionScope' @ [614:40] ==> public fun PsiElement.getResolutionScope(bindingContext: BindingContext, resolutionFacade: ResolutionFacade): LexicalScope defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [614:59] ==> private final val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'resolutionFacade' @ [614:75] ==> private final val resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'TypesWithContainsDetector' @ [615:24] ==> public constructor TypesWithContainsDetector(scope: LexicalScope, indicesHelper: KotlinIndicesHelper?, argumentType: KotlinType) defined in org.jetbrains.kotlin.idea.core.TypesWithContainsDetector[ClassConstructorDescriptorImpl]

'scope' @ [615:50] ==> val scope: LexicalScope defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInOperatorArgument[LocalVariableDescriptor]

'indicesHelper' @ [615:57] ==> private final val indicesHelper: KotlinIndicesHelper? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'leftOperandType' @ [615:72] ==> val leftOperandType: KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInOperatorArgument[LocalVariableDescriptor]

'detector' @ [619:24] ==> val detector: TypesWithContainsDetector defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInOperatorArgument[LocalVariableDescriptor]

'findOperator' @ [619:33] ==> public final fun findOperator(type: FuzzyType): Pair<FunctionDescriptor, TypeSubstitutor>? defined in org.jetbrains.kotlin.idea.core.TypesWithContainsDetector[SimpleFunctionDescriptorImpl]

'descriptorType' @ [619:46] ==> value-parameter descriptorType: FuzzyType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInOperatorArgument.<no name provided>.matchingSubstitutor[ValueParameterDescriptorImpl]

'second' @ [619:63] ==> public final val second: TypeSubstitutor defined in kotlin.Pair[DeserializedPropertyDescriptor]

'listOf' @ [622:16] ==> public fun <T> listOf(element: ExpectedInfo): List<ExpectedInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo

'ExpectedInfo' @ [622:23] ==> public constructor ExpectedInfo(filter: ByTypeFilter, expectedName: String?, tail: Tail?, itemOptions: ItemOptions = ..., additionalData: ExpectedInfo.AdditionalData? = ...) defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[ClassConstructorDescriptorImpl]

'byTypeFilter' @ [622:36] ==> val byTypeFilter: <no name provided> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForInOperatorArgument[LocalVariableDescriptor]

'expressionWithType' @ [626:24] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate[ValueParameterDescriptorImpl]

'parent' @ [626:43] ==> public final val KtExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'delegate' @ [627:35] ==> val delegate: KtPropertyDelegate defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate[LocalVariableDescriptor]

'parent' @ [627:44] ==> public final val KtPropertyDelegate.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'bindingContext' @ [628:24] ==> private final val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'DECLARATION_TO_DESCRIPTOR' @ [628:54] ==> public final val DECLARATION_TO_DESCRIPTOR: (ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'propertyDeclaration' @ [628:81] ==> val propertyDeclaration: KtProperty defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate[LocalVariableDescriptor]

'expressionWithType' @ [630:21] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate[ValueParameterDescriptorImpl]

'getResolutionScope' @ [630:40] ==> public fun PsiElement.getResolutionScope(bindingContext: BindingContext, resolutionFacade: ResolutionFacade): LexicalScope defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [630:59] ==> private final val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'resolutionFacade' @ [630:75] ==> private final val resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'property' @ [631:33] ==> val property: PropertyDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate[LocalVariableDescriptor]

'fuzzyExtensionReceiverType' @ [631:42] ==> public fun CallableDescriptor.fuzzyExtensionReceiverType(): FuzzyType? defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'property' @ [632:32] ==> val property: PropertyDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate[LocalVariableDescriptor]

'dispatchReceiverParameter' @ [632:41] ==> public final val PropertyDescriptor.dispatchReceiverParameter: ReceiverParameterDescriptor?[MyPropertyDescriptor]

'type' @ [632:68] ==> public final val ReceiverParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'toFuzzyType' @ [632:74] ==> public fun KotlinType.toFuzzyType(freeParameters: Collection<TypeParameterDescriptor>): FuzzyType defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'emptyList' @ [632:86] ==> public fun <T> emptyList(): List<TypeParameterDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeParameterDescriptor

'property' @ [633:32] ==> val property: PropertyDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate[LocalVariableDescriptor]

'builtIns' @ [633:41] ==> public val DeclarationDescriptor.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'nullableNothingType' @ [633:50] ==> public final val KotlinBuiltIns.nullableNothingType: SimpleType[MyPropertyDescriptor]

'toFuzzyType' @ [633:70] ==> public fun KotlinType.toFuzzyType(freeParameters: Collection<TypeParameterDescriptor>): FuzzyType defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'emptyList' @ [633:82] ==> public fun <T> emptyList(): List<TypeParameterDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeParameterDescriptor

'property' @ [635:36] ==> val property: PropertyDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate[LocalVariableDescriptor]

'fuzzyReturnType' @ [635:45] ==> public fun CallableDescriptor.fuzzyReturnType(): FuzzyType? defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'takeIf' @ [635:64] ==> @InlineOnly @SinceKotlin public inline fun <T> FuzzyType.takeIf(predicate: (FuzzyType) -> Boolean): FuzzyType? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FuzzyType

'propertyDeclaration' @ [635:73] ==> val propertyDeclaration: KtProperty defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate[LocalVariableDescriptor]

'typeReference' @ [635:93] ==> public final var KtProperty.typeReference: KtTypeReference?[MyPropertyDescriptor]

'property' @ [636:39] ==> val property: PropertyDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate[LocalVariableDescriptor]

'overriddenDescriptors' @ [636:48] ==> public final var PropertyDescriptor.overriddenDescriptors: (MutableCollection<out (PropertyDescriptor..PropertyDescriptor?)>..Collection<(PropertyDescriptor..PropertyDescriptor?)>)[MyPropertyDescriptor]

'singleOrNull' @ [636:70] ==> public fun <T> Iterable<(PropertyDescriptor..PropertyDescriptor?)>.singleOrNull(): PropertyDescriptor? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.PropertyDescriptor..org.jetbrains.kotlin.descriptors.PropertyDescriptor?)

'fuzzyReturnType' @ [636:86] ==> public fun CallableDescriptor.fuzzyReturnType(): FuzzyType? defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'TypesWithGetValueDetector' @ [637:36] ==> public constructor TypesWithGetValueDetector(scope: LexicalScope, indicesHelper: KotlinIndicesHelper?, propertyOwnerType: FuzzyType, propertyType: FuzzyType?) defined in org.jetbrains.kotlin.idea.core.TypesWithGetValueDetector[ClassConstructorDescriptorImpl]

'scope' @ [637:62] ==> val scope: LexicalScope defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate[LocalVariableDescriptor]

'indicesHelper' @ [637:69] ==> private final val indicesHelper: KotlinIndicesHelper? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'propertyOwnerType' @ [637:84] ==> val propertyOwnerType: FuzzyType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate[LocalVariableDescriptor]

'explicitPropertyType' @ [637:103] ==> val explicitPropertyType: FuzzyType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate[LocalVariableDescriptor]

'if (property.isVar) TypesWithSetValueDetector(scope, indicesHelper, propertyOwnerType) else null' @ [638:36] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: TypesWithSetValueDetector?, elseBranch: TypesWithSetValueDetector?): TypesWithSetValueDetector?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> TypesWithSetValueDetector?

'property' @ [638:40] ==> val property: PropertyDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate[LocalVariableDescriptor]

'isVar' @ [638:49] ==> public final val PropertyDescriptor.isVar: Boolean[MyPropertyDescriptor]

'TypesWithSetValueDetector' @ [638:56] ==> public constructor TypesWithSetValueDetector(scope: LexicalScope, indicesHelper: KotlinIndicesHelper?, propertyOwnerType: FuzzyType) defined in org.jetbrains.kotlin.idea.core.TypesWithSetValueDetector[ClassConstructorDescriptorImpl]

'scope' @ [638:82] ==> val scope: LexicalScope defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate[LocalVariableDescriptor]

'indicesHelper' @ [638:89] ==> private final val indicesHelper: KotlinIndicesHelper? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'propertyOwnerType' @ [638:104] ==> val propertyOwnerType: FuzzyType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate[LocalVariableDescriptor]

'component1' @ [642:22] ==> public final operator fun component1(): FunctionDescriptor defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [642:40] ==> public final operator fun component2(): TypeSubstitutor defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'typesWithGetDetector' @ [642:66] ==> val typesWithGetDetector: TypesWithGetValueDetector defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate[LocalVariableDescriptor]

'findOperator' @ [642:87] ==> public final fun findOperator(type: FuzzyType): Pair<FunctionDescriptor, TypeSubstitutor>? defined in org.jetbrains.kotlin.idea.core.TypesWithGetValueDetector[SimpleFunctionDescriptorImpl]

'descriptorType' @ [642:100] ==> value-parameter descriptorType: FuzzyType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.matchingSubstitutor[ValueParameterDescriptorImpl]

'typesWithSetDetector' @ [644:21] ==> val typesWithSetDetector: TypesWithSetValueDetector? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate[LocalVariableDescriptor]

'getOperatorSubstitutor' @ [644:58] ==> val getOperatorSubstitutor: TypeSubstitutor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.matchingSubstitutor[LocalVariableDescriptor]

'getOperatorSubstitutor' @ [646:39] ==> val getOperatorSubstitutor: TypeSubstitutor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.matchingSubstitutor[LocalVariableDescriptor]

'substitute' @ [646:62] ==> @Nullable public open fun substitute(@NotNull p0: KotlinType, @NotNull p1: Variance): KotlinType? defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'descriptorType' @ [646:73] ==> value-parameter descriptorType: FuzzyType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.matchingSubstitutor[ValueParameterDescriptorImpl]

'type' @ [646:88] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.idea.util.FuzzyType[DeserializedPropertyDescriptor]

'INVARIANT' @ [646:103] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'toFuzzyType' @ [646:116] ==> public fun KotlinType.toFuzzyType(freeParameters: Collection<TypeParameterDescriptor>): FuzzyType defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'descriptorType' @ [646:128] ==> value-parameter descriptorType: FuzzyType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.matchingSubstitutor[ValueParameterDescriptorImpl]

'freeParameters' @ [646:143] ==> public final val freeParameters: Set<TypeParameterDescriptor> defined in org.jetbrains.kotlin.idea.util.FuzzyType[DeserializedPropertyDescriptor]

'component1' @ [648:22] ==> public final operator fun component1(): FunctionDescriptor defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [648:40] ==> public final operator fun component2(): TypeSubstitutor defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'typesWithSetDetector' @ [648:66] ==> val typesWithSetDetector: TypesWithSetValueDetector? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate[LocalVariableDescriptor]

'findOperator' @ [648:87] ==> public final fun findOperator(type: FuzzyType): Pair<FunctionDescriptor, TypeSubstitutor>? defined in org.jetbrains.kotlin.idea.core.TypesWithSetValueDetector[SimpleFunctionDescriptorImpl]

'substitutedType' @ [648:100] ==> val substitutedType: FuzzyType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.matchingSubstitutor[LocalVariableDescriptor]

'explicitPropertyType' @ [649:36] ==> val explicitPropertyType: FuzzyType? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate[LocalVariableDescriptor]

'getValueOperator' @ [649:60] ==> val getValueOperator: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.matchingSubstitutor[LocalVariableDescriptor]

'fuzzyReturnType' @ [649:77] ==> public fun CallableDescriptor.fuzzyReturnType(): FuzzyType? defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'setValueOperator' @ [650:36] ==> val setValueOperator: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.matchingSubstitutor[LocalVariableDescriptor]

'valueParameters' @ [650:53] ==> public final val FunctionDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'last' @ [650:69] ==> public fun <T> List<(ValueParameterDescriptor..ValueParameterDescriptor?)>.last(): (ValueParameterDescriptor..ValueParameterDescriptor?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)

'type' @ [650:76] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'toFuzzyType' @ [650:81] ==> public fun KotlinType.toFuzzyType(freeParameters: Collection<TypeParameterDescriptor>): FuzzyType defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'setValueOperator' @ [650:93] ==> val setValueOperator: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.matchingSubstitutor[LocalVariableDescriptor]

'typeParameters' @ [650:110] ==> public final val FunctionDescriptor.typeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'setParamType' @ [651:47] ==> val setParamType: FuzzyType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.matchingSubstitutor[LocalVariableDescriptor]

'checkIsSuperTypeOf' @ [651:60] ==> public final fun checkIsSuperTypeOf(otherType: FuzzyType): TypeSubstitutor? defined in org.jetbrains.kotlin.idea.util.FuzzyType[DeserializedSimpleFunctionDescriptor]

'propertyType' @ [651:79] ==> val propertyType: FuzzyType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.matchingSubstitutor[LocalVariableDescriptor]

'getOperatorSubstitutor' @ [652:24] ==> val getOperatorSubstitutor: TypeSubstitutor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.matchingSubstitutor[LocalVariableDescriptor]

'combineIfNoConflicts' @ [653:26] ==> public fun TypeSubstitutor.combineIfNoConflicts(other: TypeSubstitutor, freeParameters: Collection<TypeParameterDescriptor>): TypeSubstitutor? defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'setOperatorSubstitutor' @ [653:47] ==> val setOperatorSubstitutor: TypeSubstitutor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.matchingSubstitutor[LocalVariableDescriptor]

'descriptorType' @ [653:71] ==> value-parameter descriptorType: FuzzyType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.matchingSubstitutor[ValueParameterDescriptorImpl]

'freeParameters' @ [653:86] ==> public final val freeParameters: Set<TypeParameterDescriptor> defined in org.jetbrains.kotlin.idea.util.FuzzyType[DeserializedPropertyDescriptor]

'combineIfNoConflicts' @ [654:27] ==> public fun TypeSubstitutor.combineIfNoConflicts(other: TypeSubstitutor, freeParameters: Collection<TypeParameterDescriptor>): TypeSubstitutor? defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'setParamTypeSubstitutor' @ [654:48] ==> val setParamTypeSubstitutor: TypeSubstitutor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.matchingSubstitutor[LocalVariableDescriptor]

'descriptorType' @ [654:73] ==> value-parameter descriptorType: FuzzyType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.matchingSubstitutor[ValueParameterDescriptorImpl]

'freeParameters' @ [654:88] ==> public final val freeParameters: Set<TypeParameterDescriptor> defined in org.jetbrains.kotlin.idea.util.FuzzyType[DeserializedPropertyDescriptor]

'lazy' @ [657:71] ==> public fun <T> lazy(initializer: () -> ArrayList<FuzzyType>): Lazy<ArrayList<FuzzyType>> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ArrayList<FuzzyType>

'ArrayList' @ [658:30] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> FuzzyType

'typesWithGetDetector' @ [660:41] ==> val typesWithGetDetector: TypesWithGetValueDetector defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate[LocalVariableDescriptor]

'classesWithMemberOperators' @ [660:62] ==> public final val classesWithMemberOperators: Collection<ClassDescriptor> defined in org.jetbrains.kotlin.idea.core.TypesWithGetValueDetector[PropertyDescriptorImpl]

'classDescriptor' @ [661:32] ==> val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.multipleFuzzyTypes.<anonymous>[LocalVariableDescriptor]

'defaultType' @ [661:48] ==> public final val ClassDescriptor.defaultType: SimpleType[MyPropertyDescriptor]

'classDescriptor' @ [662:42] ==> val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.multipleFuzzyTypes.<anonymous>[LocalVariableDescriptor]

'declaredTypeParameters' @ [662:58] ==> public final val ClassDescriptor.declaredTypeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'matchingSubstitutor' @ [663:39] ==> public open fun matchingSubstitutor(descriptorType: FuzzyType): TypeSubstitutor? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>[SimpleFunctionDescriptorImpl]

'type' @ [663:59] ==> val type: SimpleType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.multipleFuzzyTypes.<anonymous>[LocalVariableDescriptor]

'toFuzzyType' @ [663:64] ==> public fun KotlinType.toFuzzyType(freeParameters: Collection<TypeParameterDescriptor>): FuzzyType defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'typeParameters' @ [663:76] ==> val typeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.multipleFuzzyTypes.<anonymous>[LocalVariableDescriptor]

'result' @ [664:21] ==> val result: ArrayList<FuzzyType> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.multipleFuzzyTypes.<anonymous>[LocalVariableDescriptor]

'add' @ [664:28] ==> public open fun add(element: FuzzyType): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'substitutor' @ [664:32] ==> val substitutor: TypeSubstitutor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.multipleFuzzyTypes.<anonymous>[LocalVariableDescriptor]

'substitute' @ [664:44] ==> @Nullable public open fun substitute(@NotNull p0: KotlinType, @NotNull p1: Variance): KotlinType? defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'type' @ [664:55] ==> val type: SimpleType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.multipleFuzzyTypes.<anonymous>[LocalVariableDescriptor]

'INVARIANT' @ [664:70] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'toFuzzyType' @ [664:83] ==> public fun KotlinType.toFuzzyType(freeParameters: Collection<TypeParameterDescriptor>): FuzzyType defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'typeParameters' @ [664:95] ==> val typeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.multipleFuzzyTypes.<anonymous>[LocalVariableDescriptor]

'typesWithGetDetector' @ [667:43] ==> val typesWithGetDetector: TypesWithGetValueDetector defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate[LocalVariableDescriptor]

'extensionOperators' @ [667:64] ==> public final val extensionOperators: Collection<FunctionDescriptor> defined in org.jetbrains.kotlin.idea.core.TypesWithGetValueDetector[PropertyDescriptorImpl]

'extensionOperator' @ [668:40] ==> val extensionOperator: FunctionDescriptor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.multipleFuzzyTypes.<anonymous>[LocalVariableDescriptor]

'fuzzyExtensionReceiverType' @ [668:58] ==> public fun CallableDescriptor.fuzzyExtensionReceiverType(): FuzzyType? defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'matchingSubstitutor' @ [669:39] ==> public open fun matchingSubstitutor(descriptorType: FuzzyType): TypeSubstitutor? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>[SimpleFunctionDescriptorImpl]

'receiverType' @ [669:59] ==> val receiverType: FuzzyType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.multipleFuzzyTypes.<anonymous>[LocalVariableDescriptor]

'result' @ [670:21] ==> val result: ArrayList<FuzzyType> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.multipleFuzzyTypes.<anonymous>[LocalVariableDescriptor]

'add' @ [670:28] ==> public open fun add(element: FuzzyType): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'substitutor' @ [670:32] ==> val substitutor: TypeSubstitutor defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.multipleFuzzyTypes.<anonymous>[LocalVariableDescriptor]

'substitute' @ [670:44] ==> @Nullable public open fun substitute(@NotNull p0: KotlinType, @NotNull p1: Variance): KotlinType? defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'receiverType' @ [670:55] ==> val receiverType: FuzzyType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.multipleFuzzyTypes.<anonymous>[LocalVariableDescriptor]

'type' @ [670:68] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.idea.util.FuzzyType[DeserializedPropertyDescriptor]

'INVARIANT' @ [670:83] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'toFuzzyType' @ [670:96] ==> public fun KotlinType.toFuzzyType(freeParameters: Collection<TypeParameterDescriptor>): FuzzyType defined in org.jetbrains.kotlin.idea.util[DeserializedSimpleFunctionDescriptor]

'receiverType' @ [670:108] ==> val receiverType: FuzzyType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.multipleFuzzyTypes.<anonymous>[LocalVariableDescriptor]

'freeParameters' @ [670:121] ==> public final val freeParameters: Set<TypeParameterDescriptor> defined in org.jetbrains.kotlin.idea.util.FuzzyType[DeserializedPropertyDescriptor]

'result' @ [673:17] ==> val result: ArrayList<FuzzyType> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate.<no name provided>.multipleFuzzyTypes.<anonymous>[LocalVariableDescriptor]

'listOf' @ [676:16] ==> public fun <T> listOf(element: ExpectedInfo): List<ExpectedInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo

'ExpectedInfo' @ [676:23] ==> public constructor ExpectedInfo(filter: ByTypeFilter, expectedName: String?, tail: Tail?, itemOptions: ItemOptions = ..., additionalData: ExpectedInfo.AdditionalData? = ...) defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[ClassConstructorDescriptorImpl]

'byTypeFilter' @ [676:36] ==> val byTypeFilter: <no name provided> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.calculateForPropertyDelegate[LocalVariableDescriptor]

'PropertyDelegateAdditionalData' @ [676:79] ==> public object PropertyDelegateAdditionalData : ExpectedInfo.AdditionalData defined in org.jetbrains.kotlin.idea.core in file ExpectedInfos.kt[FakeCallableDescriptorForObject]

'bindingContext' @ [680:28] ==> private final val bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[PropertyDescriptorImpl]

'EXPECTED_EXPRESSION_TYPE' @ [680:58] ==> public final val EXPECTED_EXPRESSION_TYPE: (WritableSlice<(KtExpression..KtExpression?), (KotlinType..KotlinType?)>..WritableSlice<(KtExpression..KtExpression?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'expressionWithType' @ [680:84] ==> value-parameter expressionWithType: KtExpression defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.getFromBindingContext[ValueParameterDescriptorImpl]

'listOf' @ [681:16] ==> public fun <T> listOf(element: ExpectedInfo): List<ExpectedInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo

'ExpectedInfo' @ [681:23] ==> public constructor ExpectedInfo(type: KotlinType, expectedName: String?, tail: Tail?, itemOptions: ItemOptions = ..., additionalData: ExpectedInfo.AdditionalData? = ...) defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[ClassConstructorDescriptorImpl]

'expectedType' @ [681:36] ==> val expectedType: KotlinType defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.getFromBindingContext[LocalVariableDescriptor]

'when (expression) {
            is KtSimpleNameExpression -> expression.getReferencedName()
            is KtQualifiedExpression -> expectedNameFromExpression(expression.selectorExpression)
            is KtCallExpression -> expectedNameFromExpression(expression.calleeExpression)
            is KtArrayAccessExpression -> expectedNameFromExpression(expression.arrayExpression)?.unpluralize()
            else -> null
        }' @ [685:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: String?, entry1: String?, entry2: String?, entry3: String?, entry4: String?): String?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> String?

'expression' @ [685:22] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.expectedNameFromExpression[ValueParameterDescriptorImpl]

'expression' @ [686:42] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.expectedNameFromExpression[ValueParameterDescriptorImpl]

'getReferencedName' @ [686:53] ==> public abstract fun getReferencedName(): String defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[DeserializedSimpleFunctionDescriptor]

'expectedNameFromExpression' @ [687:41] ==> private final fun expectedNameFromExpression(expression: KtExpression?): String? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'expression' @ [687:68] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.expectedNameFromExpression[ValueParameterDescriptorImpl]

'selectorExpression' @ [687:79] ==> public open val selectorExpression: KtExpression? defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[DeserializedPropertyDescriptor]

'expectedNameFromExpression' @ [688:36] ==> private final fun expectedNameFromExpression(expression: KtExpression?): String? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'expression' @ [688:63] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.expectedNameFromExpression[ValueParameterDescriptorImpl]

'calleeExpression' @ [688:74] ==> public final val KtCallExpression.calleeExpression: KtExpression?[MyPropertyDescriptor]

'expectedNameFromExpression' @ [689:43] ==> private final fun expectedNameFromExpression(expression: KtExpression?): String? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'expression' @ [689:70] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.expectedNameFromExpression[ValueParameterDescriptorImpl]

'arrayExpression' @ [689:81] ==> public final val KtArrayAccessExpression.arrayExpression: KtExpression?[MyPropertyDescriptor]

'unpluralize' @ [689:99] ==> private final fun String.unpluralize(): String? defined in org.jetbrains.kotlin.idea.core.ExpectedInfos[SimpleFunctionDescriptorImpl]

'unpluralize' @ [695:26] ==> @Nullable @Contract public open fun unpluralize(@NotNull p0: String): String? defined in com.intellij.openapi.util.text.StringUtil[JavaMethodDescriptor]

'this' @ [695:38] ==> <this> defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.unpluralize[ReceiverParameterDescriptorImpl]

'map' @ [697:71] ==> public inline fun <T, R> Iterable<ExpectedInfo>.map(transform: (ExpectedInfo) -> ExpectedInfo): List<ExpectedInfo> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpectedInfo
    <R> -> ExpectedInfo

'it' @ [697:77] ==> value-parameter it: ExpectedInfo defined in org.jetbrains.kotlin.idea.core.ExpectedInfos.copyWithNoAdditionalData.<anonymous>[ValueParameterDescriptorImpl]

'copy' @ [697:80] ==> public final fun copy(filter: ByTypeFilter = ..., expectedName: String? = ..., tail: Tail? = ..., itemOptions: ItemOptions = ..., additionalData: ExpectedInfo.AdditionalData? = ...): ExpectedInfo defined in org.jetbrains.kotlin.idea.core.ExpectedInfo[SimpleFunctionDescriptorImpl]

'ItemOptions' @ [697:122] ==> public companion object defined in org.jetbrains.kotlin.idea.core.ItemOptions[FakeCallableDescriptorForObject]

'DEFAULT' @ [697:134] ==> public final val DEFAULT: ItemOptions defined in org.jetbrains.kotlin.idea.core.ItemOptions.Companion[PropertyDescriptorImpl]

'setOf' @ [700:25] ==> public fun <T> setOf(vararg elements: (KtSingleValueToken..KtSingleValueToken?)): Set<(KtSingleValueToken..KtSingleValueToken?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.lexer.KtSingleValueToken..org.jetbrains.kotlin.lexer.KtSingleValueToken?)

'EQEQ' @ [700:40] ==> public final val EQEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'EXCLEQ' @ [700:55] ==> public final val EXCLEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'EQEQEQ' @ [700:72] ==> public final val EQEQEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'EXCLEQEQEQ' @ [700:89] ==> public final val EXCLEQEQEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

