'JvmOverloads' @ [39:1] ==> public constructor JvmOverloads() defined in kotlin.jvm.JvmOverloads[DeserializedClassConstructorDescriptor]

'this' @ [41:43] ==> <this> defined in org.jetbrains.kotlin.idea.analysis.computeTypeInfoInContext[ReceiverParameterDescriptorImpl]

'BindingTraceContext' @ [42:31] ==> public constructor BindingTraceContext() defined in org.jetbrains.kotlin.resolve.BindingTraceContext[JavaClassConstructorDescriptor]

'DataFlowInfo' @ [43:38] ==> public companion object defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo[FakeCallableDescriptorForObject]

'EMPTY' @ [43:51] ==> public final val EMPTY: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo.Companion[DeserializedPropertyDescriptor]

'NO_EXPECTED_TYPE' @ [44:46] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'INDEPENDENT' @ [46:66] ==> enum entry INDEPENDENT defined in org.jetbrains.kotlin.resolve.calls.context.ContextDependency[FakeCallableDescriptorForObject]

'contextExpression' @ [47:62] ==> value-parameter contextExpression: KtExpression = ... defined in org.jetbrains.kotlin.idea.analysis.computeTypeInfoInContext[ValueParameterDescriptorImpl]

'getResolutionFacade' @ [47:80] ==> public fun KtElement.getResolutionFacade(): ResolutionFacade defined in org.jetbrains.kotlin.idea.caches.resolve in file resolutionApi.kt[SimpleFunctionDescriptorImpl]

'frontendService' @ [47:102] ==> public inline fun <reified T : Any> ResolutionFacade.frontendService(): ExpressionTypingServices defined in org.jetbrains.kotlin.idea.resolve[SimpleFunctionDescriptorImpl]
Inferred types:
    <reified T : Any> -> ExpressionTypingServices

'PreliminaryDeclarationVisitor' @ [49:5] ==> public companion object defined in org.jetbrains.kotlin.types.expressions.PreliminaryDeclarationVisitor[FakeCallableDescriptorForObject]

'createForExpression' @ [49:35] ==> public final fun createForExpression(expression: KtExpression, trace: BindingTrace, languageVersionSettings: LanguageVersionSettings): Unit defined in org.jetbrains.kotlin.types.expressions.PreliminaryDeclarationVisitor.Companion[DeserializedSimpleFunctionDescriptor]

'this' @ [49:55] ==> <this> defined in org.jetbrains.kotlin.idea.analysis.computeTypeInfoInContext[ReceiverParameterDescriptorImpl]

'trace' @ [49:61] ==> value-parameter trace: BindingTrace = ... defined in org.jetbrains.kotlin.idea.analysis.computeTypeInfoInContext[ValueParameterDescriptorImpl]

'expressionTypingServices' @ [49:68] ==> value-parameter expressionTypingServices: ExpressionTypingServices = ... defined in org.jetbrains.kotlin.idea.analysis.computeTypeInfoInContext[ValueParameterDescriptorImpl]

'languageVersionSettings' @ [49:93] ==> public final val ExpressionTypingServices.languageVersionSettings: LanguageVersionSettings[MyPropertyDescriptor]

'expressionTypingServices' @ [50:13] ==> value-parameter expressionTypingServices: ExpressionTypingServices = ... defined in org.jetbrains.kotlin.idea.analysis.computeTypeInfoInContext[ValueParameterDescriptorImpl]

'getTypeInfo' @ [50:38] ==> @NotNull public open fun getTypeInfo(@NotNull p0: LexicalScope, @NotNull p1: KtExpression, @NotNull p2: KotlinType, @NotNull p3: DataFlowInfo, @NotNull p4: BindingTrace, p5: Boolean, @NotNull p6: KtExpression, @NotNull p7: ContextDependency): KotlinTypeInfo defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingServices[JavaMethodDescriptor]

'scope' @ [50:50] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.idea.analysis.computeTypeInfoInContext[ValueParameterDescriptorImpl]

'this' @ [50:57] ==> <this> defined in org.jetbrains.kotlin.idea.analysis.computeTypeInfoInContext[ReceiverParameterDescriptorImpl]

'expectedType' @ [50:63] ==> value-parameter expectedType: KotlinType = ... defined in org.jetbrains.kotlin.idea.analysis.computeTypeInfoInContext[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [50:77] ==> value-parameter dataFlowInfo: DataFlowInfo = ... defined in org.jetbrains.kotlin.idea.analysis.computeTypeInfoInContext[ValueParameterDescriptorImpl]

'trace' @ [50:91] ==> value-parameter trace: BindingTrace = ... defined in org.jetbrains.kotlin.idea.analysis.computeTypeInfoInContext[ValueParameterDescriptorImpl]

'isStatement' @ [50:98] ==> value-parameter isStatement: Boolean = ... defined in org.jetbrains.kotlin.idea.analysis.computeTypeInfoInContext[ValueParameterDescriptorImpl]

'contextExpression' @ [50:111] ==> value-parameter contextExpression: KtExpression = ... defined in org.jetbrains.kotlin.idea.analysis.computeTypeInfoInContext[ValueParameterDescriptorImpl]

'contextDependency' @ [50:130] ==> value-parameter contextDependency: ContextDependency = ... defined in org.jetbrains.kotlin.idea.analysis.computeTypeInfoInContext[ValueParameterDescriptorImpl]

'JvmOverloads' @ [53:1] ==> public constructor JvmOverloads() defined in kotlin.jvm.JvmOverloads[DeserializedClassConstructorDescriptor]

'this' @ [55:43] ==> <this> defined in org.jetbrains.kotlin.idea.analysis.analyzeInContext[ReceiverParameterDescriptorImpl]

'BindingTraceContext' @ [56:31] ==> public constructor BindingTraceContext() defined in org.jetbrains.kotlin.resolve.BindingTraceContext[JavaClassConstructorDescriptor]

'DataFlowInfo' @ [57:38] ==> public companion object defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo[FakeCallableDescriptorForObject]

'EMPTY' @ [57:51] ==> public final val EMPTY: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo.Companion[DeserializedPropertyDescriptor]

'NO_EXPECTED_TYPE' @ [58:46] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'INDEPENDENT' @ [60:66] ==> enum entry INDEPENDENT defined in org.jetbrains.kotlin.resolve.calls.context.ContextDependency[FakeCallableDescriptorForObject]

'contextExpression' @ [61:62] ==> value-parameter contextExpression: KtExpression = ... defined in org.jetbrains.kotlin.idea.analysis.analyzeInContext[ValueParameterDescriptorImpl]

'getResolutionFacade' @ [61:80] ==> public fun KtElement.getResolutionFacade(): ResolutionFacade defined in org.jetbrains.kotlin.idea.caches.resolve in file resolutionApi.kt[SimpleFunctionDescriptorImpl]

'frontendService' @ [61:102] ==> public inline fun <reified T : Any> ResolutionFacade.frontendService(): ExpressionTypingServices defined in org.jetbrains.kotlin.idea.resolve[SimpleFunctionDescriptorImpl]
Inferred types:
    <reified T : Any> -> ExpressionTypingServices

'computeTypeInfoInContext' @ [63:5] ==> @JvmOverloads public fun KtExpression.computeTypeInfoInContext(scope: LexicalScope, contextExpression: KtExpression = ..., trace: BindingTrace = ..., dataFlowInfo: DataFlowInfo = ..., expectedType: KotlinType = ..., isStatement: Boolean = ..., contextDependency: ContextDependency = ..., expressionTypingServices: ExpressionTypingServices = ...): KotlinTypeInfo defined in org.jetbrains.kotlin.idea.analysis in file AnalyzerUtil.kt[SimpleFunctionDescriptorImpl]

'scope' @ [63:30] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.idea.analysis.analyzeInContext[ValueParameterDescriptorImpl]

'contextExpression' @ [63:37] ==> value-parameter contextExpression: KtExpression = ... defined in org.jetbrains.kotlin.idea.analysis.analyzeInContext[ValueParameterDescriptorImpl]

'trace' @ [63:56] ==> value-parameter trace: BindingTrace = ... defined in org.jetbrains.kotlin.idea.analysis.analyzeInContext[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [63:63] ==> value-parameter dataFlowInfo: DataFlowInfo = ... defined in org.jetbrains.kotlin.idea.analysis.analyzeInContext[ValueParameterDescriptorImpl]

'expectedType' @ [63:77] ==> value-parameter expectedType: KotlinType = ... defined in org.jetbrains.kotlin.idea.analysis.analyzeInContext[ValueParameterDescriptorImpl]

'isStatement' @ [63:91] ==> value-parameter isStatement: Boolean = ... defined in org.jetbrains.kotlin.idea.analysis.analyzeInContext[ValueParameterDescriptorImpl]

'contextDependency' @ [63:104] ==> value-parameter contextDependency: ContextDependency = ... defined in org.jetbrains.kotlin.idea.analysis.analyzeInContext[ValueParameterDescriptorImpl]

'expressionTypingServices' @ [63:123] ==> value-parameter expressionTypingServices: ExpressionTypingServices = ... defined in org.jetbrains.kotlin.idea.analysis.analyzeInContext[ValueParameterDescriptorImpl]

'trace' @ [64:12] ==> value-parameter trace: BindingTrace = ... defined in org.jetbrains.kotlin.idea.analysis.analyzeInContext[ValueParameterDescriptorImpl]

'bindingContext' @ [64:18] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'JvmOverloads' @ [67:1] ==> public constructor JvmOverloads() defined in kotlin.jvm.JvmOverloads[DeserializedClassConstructorDescriptor]

'this' @ [69:43] ==> <this> defined in org.jetbrains.kotlin.idea.analysis.computeTypeInContext[ReceiverParameterDescriptorImpl]

'BindingTraceContext' @ [70:31] ==> public constructor BindingTraceContext() defined in org.jetbrains.kotlin.resolve.BindingTraceContext[JavaClassConstructorDescriptor]

'DataFlowInfo' @ [71:38] ==> public companion object defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo[FakeCallableDescriptorForObject]

'EMPTY' @ [71:51] ==> public final val EMPTY: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo.Companion[DeserializedPropertyDescriptor]

'NO_EXPECTED_TYPE' @ [72:46] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'computeTypeInfoInContext' @ [74:12] ==> @JvmOverloads public fun KtExpression.computeTypeInfoInContext(scope: LexicalScope, contextExpression: KtExpression = ..., trace: BindingTrace = ..., dataFlowInfo: DataFlowInfo = ..., expectedType: KotlinType = ..., isStatement: Boolean = ..., contextDependency: ContextDependency = ..., expressionTypingServices: ExpressionTypingServices = ...): KotlinTypeInfo defined in org.jetbrains.kotlin.idea.analysis in file AnalyzerUtil.kt[SimpleFunctionDescriptorImpl]

'scope' @ [74:37] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.idea.analysis.computeTypeInContext[ValueParameterDescriptorImpl]

'contextExpression' @ [74:44] ==> value-parameter contextExpression: KtExpression = ... defined in org.jetbrains.kotlin.idea.analysis.computeTypeInContext[ValueParameterDescriptorImpl]

'trace' @ [74:63] ==> value-parameter trace: BindingTrace = ... defined in org.jetbrains.kotlin.idea.analysis.computeTypeInContext[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [74:70] ==> value-parameter dataFlowInfo: DataFlowInfo = ... defined in org.jetbrains.kotlin.idea.analysis.computeTypeInContext[ValueParameterDescriptorImpl]

'expectedType' @ [74:84] ==> value-parameter expectedType: KotlinType = ... defined in org.jetbrains.kotlin.idea.analysis.computeTypeInContext[ValueParameterDescriptorImpl]

'type' @ [74:98] ==> public final val type: KotlinType? defined in org.jetbrains.kotlin.types.expressions.KotlinTypeInfo[DeserializedPropertyDescriptor]

'JvmOverloads' @ [77:1] ==> public constructor JvmOverloads() defined in kotlin.jvm.JvmOverloads[DeserializedClassConstructorDescriptor]

'DelegatingBindingTrace' @ [81:31] ==> public constructor DelegatingBindingTrace(parentContext: BindingContext, name: String, withParentDiagnostics: Boolean = ..., filter: BindingTraceFilter = ..., allowSliceRewrite: Boolean = ...) defined in org.jetbrains.kotlin.resolve.DelegatingBindingTrace[DeserializedClassConstructorDescriptor]

'bindingContext' @ [81:54] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.analysis.analyzeAsReplacement[ValueParameterDescriptorImpl]

'INDEPENDENT' @ [82:66] ==> enum entry INDEPENDENT defined in org.jetbrains.kotlin.resolve.calls.context.ContextDependency[FakeCallableDescriptorForObject]

'analyzeInContext' @ [84:12] ==> @JvmOverloads public fun KtExpression.analyzeInContext(scope: LexicalScope, contextExpression: KtExpression = ..., trace: BindingTrace = ..., dataFlowInfo: DataFlowInfo = ..., expectedType: KotlinType = ..., isStatement: Boolean = ..., contextDependency: ContextDependency = ..., expressionTypingServices: ExpressionTypingServices = ...): BindingContext defined in org.jetbrains.kotlin.idea.analysis in file AnalyzerUtil.kt[SimpleFunctionDescriptorImpl]

'scope' @ [84:29] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.idea.analysis.analyzeAsReplacement[ValueParameterDescriptorImpl]

'expressionToBeReplaced' @ [85:29] ==> value-parameter expressionToBeReplaced: KtExpression defined in org.jetbrains.kotlin.idea.analysis.analyzeAsReplacement[ValueParameterDescriptorImpl]

'bindingContext' @ [86:44] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.analysis.analyzeAsReplacement[ValueParameterDescriptorImpl]

'getDataFlowInfoBefore' @ [86:59] ==> public fun BindingContext.getDataFlowInfoBefore(position: PsiElement): DataFlowInfo defined in org.jetbrains.kotlin.resolve.bindingContextUtil[DeserializedSimpleFunctionDescriptor]

'expressionToBeReplaced' @ [86:81] ==> value-parameter expressionToBeReplaced: KtExpression defined in org.jetbrains.kotlin.idea.analysis.analyzeAsReplacement[ValueParameterDescriptorImpl]

'bindingContext' @ [87:44] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.analysis.analyzeAsReplacement[ValueParameterDescriptorImpl]

'EXPECTED_EXPRESSION_TYPE' @ [87:74] ==> public final val EXPECTED_EXPRESSION_TYPE: (WritableSlice<(KtExpression..KtExpression?), (KotlinType..KotlinType?)>..WritableSlice<(KtExpression..KtExpression?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'expressionToBeReplaced' @ [87:100] ==> value-parameter expressionToBeReplaced: KtExpression defined in org.jetbrains.kotlin.idea.analysis.analyzeAsReplacement[ValueParameterDescriptorImpl]

'NO_EXPECTED_TYPE' @ [87:137] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'expressionToBeReplaced' @ [88:43] ==> value-parameter expressionToBeReplaced: KtExpression defined in org.jetbrains.kotlin.idea.analysis.analyzeAsReplacement[ValueParameterDescriptorImpl]

'isUsedAsStatement' @ [88:66] ==> public fun KtExpression.isUsedAsStatement(context: BindingContext): Boolean defined in org.jetbrains.kotlin.resolve.bindingContextUtil[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [88:84] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.analysis.analyzeAsReplacement[ValueParameterDescriptorImpl]

'trace' @ [89:37] ==> value-parameter trace: BindingTrace = ... defined in org.jetbrains.kotlin.idea.analysis.analyzeAsReplacement[ValueParameterDescriptorImpl]

'contextDependency' @ [90:49] ==> value-parameter contextDependency: ContextDependency = ... defined in org.jetbrains.kotlin.idea.analysis.analyzeAsReplacement[ValueParameterDescriptorImpl]

'JvmOverloads' @ [93:1] ==> public constructor JvmOverloads() defined in kotlin.jvm.JvmOverloads[DeserializedClassConstructorDescriptor]

'expressionToBeReplaced' @ [96:46] ==> value-parameter expressionToBeReplaced: KtExpression defined in org.jetbrains.kotlin.idea.analysis.analyzeAsReplacement[ValueParameterDescriptorImpl]

'getResolutionFacade' @ [96:69] ==> public fun KtElement.getResolutionFacade(): ResolutionFacade defined in org.jetbrains.kotlin.idea.caches.resolve in file resolutionApi.kt[SimpleFunctionDescriptorImpl]

'DelegatingBindingTrace' @ [97:31] ==> public constructor DelegatingBindingTrace(parentContext: BindingContext, name: String, withParentDiagnostics: Boolean = ..., filter: BindingTraceFilter = ..., allowSliceRewrite: Boolean = ...) defined in org.jetbrains.kotlin.resolve.DelegatingBindingTrace[DeserializedClassConstructorDescriptor]

'bindingContext' @ [97:54] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.analysis.analyzeAsReplacement[ValueParameterDescriptorImpl]

'INDEPENDENT' @ [98:66] ==> enum entry INDEPENDENT defined in org.jetbrains.kotlin.resolve.calls.context.ContextDependency[FakeCallableDescriptorForObject]

'expressionToBeReplaced' @ [100:17] ==> value-parameter expressionToBeReplaced: KtExpression defined in org.jetbrains.kotlin.idea.analysis.analyzeAsReplacement[ValueParameterDescriptorImpl]

'getResolutionScope' @ [100:40] ==> public fun PsiElement.getResolutionScope(bindingContext: BindingContext, resolutionFacade: ResolutionFacade): LexicalScope defined in org.jetbrains.kotlin.idea.util in file scopeUtils.kt[SimpleFunctionDescriptorImpl]

'bindingContext' @ [100:59] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.analysis.analyzeAsReplacement[ValueParameterDescriptorImpl]

'resolutionFacade' @ [100:75] ==> value-parameter resolutionFacade: ResolutionFacade = ... defined in org.jetbrains.kotlin.idea.analysis.analyzeAsReplacement[ValueParameterDescriptorImpl]

'analyzeAsReplacement' @ [101:12] ==> @JvmOverloads public fun KtExpression.analyzeAsReplacement(expressionToBeReplaced: KtExpression, bindingContext: BindingContext, scope: LexicalScope, trace: BindingTrace = ..., contextDependency: ContextDependency = ...): BindingContext defined in org.jetbrains.kotlin.idea.analysis in file AnalyzerUtil.kt[SimpleFunctionDescriptorImpl]

'expressionToBeReplaced' @ [101:33] ==> value-parameter expressionToBeReplaced: KtExpression defined in org.jetbrains.kotlin.idea.analysis.analyzeAsReplacement[ValueParameterDescriptorImpl]

'bindingContext' @ [101:57] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.analysis.analyzeAsReplacement[ValueParameterDescriptorImpl]

'scope' @ [101:73] ==> val scope: LexicalScope defined in org.jetbrains.kotlin.idea.analysis.analyzeAsReplacement[LocalVariableDescriptor]

'trace' @ [101:80] ==> value-parameter trace: BindingTrace = ... defined in org.jetbrains.kotlin.idea.analysis.analyzeAsReplacement[ValueParameterDescriptorImpl]

'contextDependency' @ [101:87] ==> value-parameter contextDependency: ContextDependency = ... defined in org.jetbrains.kotlin.idea.analysis.analyzeAsReplacement[ValueParameterDescriptorImpl]

