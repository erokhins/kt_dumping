'?:' @ [26:27] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KotlinType?, right: KotlinType): KotlinType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KotlinType

'findCorrespondingSupertype' @ [26:49] ==> @Nullable public open fun findCorrespondingSupertype(@NotNull p0: KotlinType, @NotNull p1: KotlinType): KotlinType? defined in org.jetbrains.kotlin.types.checker.TypeCheckingProcedure[JavaMethodDescriptor]

'derivedType' @ [26:76] ==> value-parameter derivedType: KotlinType defined in org.jetbrains.kotlin.types.substitutions.getTypeSubstitution[ValueParameterDescriptorImpl]

'baseType' @ [26:89] ==> value-parameter baseType: KotlinType defined in org.jetbrains.kotlin.types.substitutions.getTypeSubstitution[ValueParameterDescriptorImpl]

'LinkedHashMap' @ [28:24] ==> public constructor LinkedHashMap<K : (Any..Any?), V : (Any..Any?)>(p0: Int) defined in java.util.LinkedHashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> TypeConstructor
    <V : (Any..Any?)> -> TypeProjection

'substitutedType' @ [28:71] ==> val substitutedType: KotlinType defined in org.jetbrains.kotlin.types.substitutions.getTypeSubstitution[LocalVariableDescriptor]

'arguments' @ [28:87] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'size' @ [28:97] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'component1' @ [29:11] ==> public final operator fun component1(): (TypeParameterDescriptor..TypeParameterDescriptor?) defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [29:18] ==> public final operator fun component2(): TypeProjection defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'baseType' @ [29:26] ==> value-parameter baseType: KotlinType defined in org.jetbrains.kotlin.types.substitutions.getTypeSubstitution[ValueParameterDescriptorImpl]

'constructor' @ [29:35] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'parameters' @ [29:47] ==> public final val TypeConstructor.parameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'zip' @ [29:58] ==> public infix fun <T, R> Iterable<(TypeParameterDescriptor..TypeParameterDescriptor?)>.zip(other: Iterable<TypeProjection>): List<Pair<(TypeParameterDescriptor..TypeParameterDescriptor?), TypeProjection>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)
    <R> -> TypeProjection

'substitutedType' @ [29:62] ==> val substitutedType: KotlinType defined in org.jetbrains.kotlin.types.substitutions.getTypeSubstitution[LocalVariableDescriptor]

'arguments' @ [29:78] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'substitution' @ [30:9] ==> val substitution: LinkedHashMap<TypeConstructor, TypeProjection> defined in org.jetbrains.kotlin.types.substitutions.getTypeSubstitution[LocalVariableDescriptor]

'param' @ [30:22] ==> val param: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.types.substitutions.getTypeSubstitution[LocalVariableDescriptor]

'typeConstructor' @ [30:28] ==> public final val TypeParameterDescriptor.typeConstructor: TypeConstructor[MyPropertyDescriptor]

'arg' @ [30:47] ==> val arg: TypeProjection defined in org.jetbrains.kotlin.types.substitutions.getTypeSubstitution[LocalVariableDescriptor]

'substitution' @ [33:12] ==> val substitution: LinkedHashMap<TypeConstructor, TypeProjection> defined in org.jetbrains.kotlin.types.substitutions.getTypeSubstitution[LocalVariableDescriptor]

'baseCallable' @ [40:21] ==> value-parameter baseCallable: CallableDescriptor defined in org.jetbrains.kotlin.types.substitutions.getCallableSubstitution[ValueParameterDescriptorImpl]

'containingDeclaration' @ [40:34] ==> public final val CallableDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'derivedCallable' @ [41:24] ==> value-parameter derivedCallable: CallableDescriptor defined in org.jetbrains.kotlin.types.substitutions.getCallableSubstitution[ValueParameterDescriptorImpl]

'containingDeclaration' @ [41:40] ==> public final val CallableDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'getTypeSubstitution' @ [42:24] ==> public fun getTypeSubstitution(baseType: KotlinType, derivedType: KotlinType): LinkedHashMap<TypeConstructor, TypeProjection>? defined in org.jetbrains.kotlin.types.substitutions[SimpleFunctionDescriptorImpl]

'baseClass' @ [42:44] ==> val baseClass: ClassDescriptor defined in org.jetbrains.kotlin.types.substitutions.getCallableSubstitution[LocalVariableDescriptor]

'defaultType' @ [42:54] ==> public final val ClassDescriptor.defaultType: SimpleType[MyPropertyDescriptor]

'derivedClass' @ [42:67] ==> val derivedClass: ClassDescriptor defined in org.jetbrains.kotlin.types.substitutions.getCallableSubstitution[LocalVariableDescriptor]

'defaultType' @ [42:80] ==> public final val ClassDescriptor.defaultType: SimpleType[MyPropertyDescriptor]

'component1' @ [44:11] ==> public final operator fun component1(): (TypeParameterDescriptor..TypeParameterDescriptor?) defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [44:22] ==> public final operator fun component2(): (TypeParameterDescriptor..TypeParameterDescriptor?) defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'baseCallable' @ [44:39] ==> value-parameter baseCallable: CallableDescriptor defined in org.jetbrains.kotlin.types.substitutions.getCallableSubstitution[ValueParameterDescriptorImpl]

'typeParameters' @ [44:52] ==> public final val CallableDescriptor.typeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'zip' @ [44:67] ==> public infix fun <T, R> Iterable<(TypeParameterDescriptor..TypeParameterDescriptor?)>.zip(other: Iterable<(TypeParameterDescriptor..TypeParameterDescriptor?)>): List<Pair<(TypeParameterDescriptor..TypeParameterDescriptor?), (TypeParameterDescriptor..TypeParameterDescriptor?)>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)
    <R> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)

'derivedCallable' @ [44:71] ==> value-parameter derivedCallable: CallableDescriptor defined in org.jetbrains.kotlin.types.substitutions.getCallableSubstitution[ValueParameterDescriptorImpl]

'typeParameters' @ [44:87] ==> public final val CallableDescriptor.typeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'substitution' @ [45:9] ==> val substitution: LinkedHashMap<TypeConstructor, TypeProjection> defined in org.jetbrains.kotlin.types.substitutions.getCallableSubstitution[LocalVariableDescriptor]

'baseParam' @ [45:22] ==> val baseParam: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.types.substitutions.getCallableSubstitution[LocalVariableDescriptor]

'typeConstructor' @ [45:32] ==> public final val TypeParameterDescriptor.typeConstructor: TypeConstructor[MyPropertyDescriptor]

'TypeProjectionImpl' @ [45:51] ==> public constructor TypeProjectionImpl(@NotNull p0: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'derivedParam' @ [45:70] ==> val derivedParam: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.types.substitutions.getCallableSubstitution[LocalVariableDescriptor]

'defaultType' @ [45:83] ==> public final val TypeParameterDescriptor.defaultType: SimpleType[MyPropertyDescriptor]

'substitution' @ [48:12] ==> val substitution: LinkedHashMap<TypeConstructor, TypeProjection> defined in org.jetbrains.kotlin.types.substitutions.getCallableSubstitution[LocalVariableDescriptor]

'getCallableSubstitution' @ [55:12] ==> public fun getCallableSubstitution(baseCallable: CallableDescriptor, derivedCallable: CallableDescriptor): MutableMap<TypeConstructor, TypeProjection>? defined in org.jetbrains.kotlin.types.substitutions[SimpleFunctionDescriptorImpl]

'baseCallable' @ [55:36] ==> value-parameter baseCallable: CallableDescriptor defined in org.jetbrains.kotlin.types.substitutions.getCallableSubstitutor[ValueParameterDescriptorImpl]

'derivedCallable' @ [55:50] ==> value-parameter derivedCallable: CallableDescriptor defined in org.jetbrains.kotlin.types.substitutions.getCallableSubstitutor[ValueParameterDescriptorImpl]

'let' @ [55:68] ==> @InlineOnly public inline fun <T, R> MutableMap<TypeConstructor, TypeProjection>.let(block: (MutableMap<TypeConstructor, TypeProjection>) -> TypeSubstitutor): TypeSubstitutor defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> MutableMap<TypeConstructor, TypeProjection>
    <R> -> TypeSubstitutor

'create' @ [55:90] ==> @NotNull public open fun create(@NotNull p0: (MutableMap<(TypeConstructor..TypeConstructor?), (TypeProjection..TypeProjection?)>..Map<(TypeConstructor..TypeConstructor?), (TypeProjection..TypeProjection?)>)): TypeSubstitutor defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'it' @ [55:97] ==> value-parameter it: MutableMap<TypeConstructor, TypeProjection> defined in org.jetbrains.kotlin.types.substitutions.getCallableSubstitutor.<anonymous>[ValueParameterDescriptorImpl]

'getTypeSubstitution' @ [59:12] ==> public fun getTypeSubstitution(baseType: KotlinType, derivedType: KotlinType): LinkedHashMap<TypeConstructor, TypeProjection>? defined in org.jetbrains.kotlin.types.substitutions[SimpleFunctionDescriptorImpl]

'baseType' @ [59:32] ==> value-parameter baseType: KotlinType defined in org.jetbrains.kotlin.types.substitutions.getTypeSubstitutor[ValueParameterDescriptorImpl]

'derivedType' @ [59:42] ==> value-parameter derivedType: KotlinType defined in org.jetbrains.kotlin.types.substitutions.getTypeSubstitutor[ValueParameterDescriptorImpl]

'let' @ [59:56] ==> @InlineOnly public inline fun <T, R> LinkedHashMap<TypeConstructor, TypeProjection>.let(block: (LinkedHashMap<TypeConstructor, TypeProjection>) -> TypeSubstitutor): TypeSubstitutor defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> LinkedHashMap<TypeConstructor, TypeProjection>
    <R> -> TypeSubstitutor

'create' @ [59:78] ==> @NotNull public open fun create(@NotNull p0: (MutableMap<(TypeConstructor..TypeConstructor?), (TypeProjection..TypeProjection?)>..Map<(TypeConstructor..TypeConstructor?), (TypeProjection..TypeProjection?)>)): TypeSubstitutor defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'it' @ [59:85] ==> value-parameter it: LinkedHashMap<TypeConstructor, TypeProjection> defined in org.jetbrains.kotlin.types.substitutions.getTypeSubstitutor.<anonymous>[ValueParameterDescriptorImpl]

