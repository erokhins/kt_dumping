'CallType<Nothing?>' @ [50:22] ==> private constructor CallType<TReceiver : KtElement?>(descriptorKindFilter: DescriptorKindFilter) defined in org.jetbrains.kotlin.idea.util.CallType[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> Nothing?

'ALL' @ [50:62] ==> @field:JvmField public final val ALL: DescriptorKindFilter defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter.Companion[DeserializedPropertyDescriptor]

'CallType<Nothing?>' @ [52:22] ==> private constructor CallType<TReceiver : KtElement?>(descriptorKindFilter: DescriptorKindFilter) defined in org.jetbrains.kotlin.idea.util.CallType[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> Nothing?

'ALL' @ [52:62] ==> @field:JvmField public final val ALL: DescriptorKindFilter defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter.Companion[DeserializedPropertyDescriptor]

'CallType<KtExpression>' @ [54:18] ==> private constructor CallType<TReceiver : KtElement?>(descriptorKindFilter: DescriptorKindFilter) defined in org.jetbrains.kotlin.idea.util.CallType[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> KtExpression

'ALL' @ [54:62] ==> @field:JvmField public final val ALL: DescriptorKindFilter defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter.Companion[DeserializedPropertyDescriptor]

'CallType<KtExpression>' @ [56:19] ==> private constructor CallType<TReceiver : KtElement?>(descriptorKindFilter: DescriptorKindFilter) defined in org.jetbrains.kotlin.idea.util.CallType[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> KtExpression

'ALL' @ [56:63] ==> @field:JvmField public final val ALL: DescriptorKindFilter defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter.Companion[DeserializedPropertyDescriptor]

'CallType<KtSuperExpression>' @ [58:28] ==> private constructor CallType<TReceiver : KtElement?>(descriptorKindFilter: DescriptorKindFilter) defined in org.jetbrains.kotlin.idea.util.CallType[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> KtSuperExpression

'DescriptorKindFilter' @ [58:56] ==> public companion object defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter[FakeCallableDescriptorForObject]

'CALLABLES' @ [58:77] ==> @field:JvmField public final val CALLABLES: DescriptorKindFilter defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter.Companion[DeserializedPropertyDescriptor]

'Extensions' @ [58:117] ==> public object Extensions : DescriptorKindExclude defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindExclude[FakeCallableDescriptorForObject]

'AbstractMembersExclude' @ [58:136] ==> private object AbstractMembersExclude : DescriptorKindExclude defined in org.jetbrains.kotlin.idea.util.CallType[FakeCallableDescriptorForObject]

'CallType<KtExpression>' @ [60:20] ==> private constructor CallType<TReceiver : KtElement?>(descriptorKindFilter: DescriptorKindFilter) defined in org.jetbrains.kotlin.idea.util.CallType[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> KtExpression

'DescriptorKindFilter' @ [60:43] ==> public companion object defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter[FakeCallableDescriptorForObject]

'FUNCTIONS' @ [60:64] ==> @field:JvmField public final val FUNCTIONS: DescriptorKindFilter defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter.Companion[DeserializedPropertyDescriptor]

'NonInfixExclude' @ [60:82] ==> private object NonInfixExclude : DescriptorKindExclude defined in org.jetbrains.kotlin.idea.util.CallType[FakeCallableDescriptorForObject]

'CallType<KtExpression>' @ [62:23] ==> private constructor CallType<TReceiver : KtElement?>(descriptorKindFilter: DescriptorKindFilter) defined in org.jetbrains.kotlin.idea.util.CallType[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> KtExpression

'DescriptorKindFilter' @ [62:46] ==> public companion object defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter[FakeCallableDescriptorForObject]

'FUNCTIONS' @ [62:67] ==> @field:JvmField public final val FUNCTIONS: DescriptorKindFilter defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter.Companion[DeserializedPropertyDescriptor]

'NonOperatorExclude' @ [62:85] ==> private object NonOperatorExclude : DescriptorKindExclude defined in org.jetbrains.kotlin.idea.util.CallType[FakeCallableDescriptorForObject]

'CallType<KtExpression?>' @ [64:33] ==> private constructor CallType<TReceiver : KtElement?>(descriptorKindFilter: DescriptorKindFilter) defined in org.jetbrains.kotlin.idea.util.CallType[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> KtExpression?

'DescriptorKindFilter' @ [64:57] ==> public companion object defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter[FakeCallableDescriptorForObject]

'CALLABLES' @ [64:78] ==> @field:JvmField public final val CALLABLES: DescriptorKindFilter defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter.Companion[DeserializedPropertyDescriptor]

'CallableReferenceExclude' @ [64:96] ==> private object CallableReferenceExclude : DescriptorKindExclude defined in org.jetbrains.kotlin.idea.util.CallType[FakeCallableDescriptorForObject]

'CallType<KtExpression?>' @ [66:31] ==> private constructor CallType<TReceiver : KtElement?>(descriptorKindFilter: DescriptorKindFilter) defined in org.jetbrains.kotlin.idea.util.CallType[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> KtExpression?

'ALL' @ [66:76] ==> @field:JvmField public final val ALL: DescriptorKindFilter defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter.Companion[DeserializedPropertyDescriptor]

'CallType<KtExpression?>' @ [68:32] ==> private constructor CallType<TReceiver : KtElement?>(descriptorKindFilter: DescriptorKindFilter) defined in org.jetbrains.kotlin.idea.util.CallType[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> KtExpression?

'PACKAGES' @ [68:77] ==> @field:JvmField public final val PACKAGES: DescriptorKindFilter defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter.Companion[DeserializedPropertyDescriptor]

'CallType<KtExpression?>' @ [70:19] ==> private constructor CallType<TReceiver : KtElement?>(descriptorKindFilter: DescriptorKindFilter) defined in org.jetbrains.kotlin.idea.util.CallType[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> KtExpression?

'DescriptorKindFilter' @ [70:43] ==> public constructor DescriptorKindFilter(kindMask: Int, excludes: List<DescriptorKindExclude> = ...) defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter[DeserializedClassConstructorDescriptor]

'DescriptorKindFilter' @ [70:64] ==> public companion object defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter[FakeCallableDescriptorForObject]

'CLASSIFIERS_MASK' @ [70:85] ==> public final val CLASSIFIERS_MASK: Int defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter.Companion[DeserializedPropertyDescriptor]

'PACKAGES_MASK' @ [70:126] ==> public final val PACKAGES_MASK: Int defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter.Companion[DeserializedPropertyDescriptor]

'EnumEntry' @ [70:171] ==> public object EnumEntry : DescriptorKindExclude defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindExclude[FakeCallableDescriptorForObject]

'CallType<KtExpression?>' @ [72:23] ==> private constructor CallType<TReceiver : KtElement?>(descriptorKindFilter: DescriptorKindFilter) defined in org.jetbrains.kotlin.idea.util.CallType[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> KtExpression?

'DescriptorKindFilter' @ [72:47] ==> public companion object defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter[FakeCallableDescriptorForObject]

'FUNCTIONS' @ [72:68] ==> @field:JvmField public final val FUNCTIONS: DescriptorKindFilter defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter.Companion[DeserializedPropertyDescriptor]

'NonOperatorExclude' @ [72:86] ==> private object NonOperatorExclude : DescriptorKindExclude defined in org.jetbrains.kotlin.idea.util.CallType[FakeCallableDescriptorForObject]

'CallType<KtExpression?>' @ [74:25] ==> private constructor CallType<TReceiver : KtElement?>(descriptorKindFilter: DescriptorKindFilter) defined in org.jetbrains.kotlin.idea.util.CallType[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> KtExpression?

'DescriptorKindFilter' @ [74:49] ==> public constructor DescriptorKindFilter(kindMask: Int, excludes: List<DescriptorKindExclude> = ...) defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter[DeserializedClassConstructorDescriptor]

'DescriptorKindFilter' @ [74:70] ==> public companion object defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter[FakeCallableDescriptorForObject]

'CLASSIFIERS_MASK' @ [74:91] ==> public final val CLASSIFIERS_MASK: Int defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter.Companion[DeserializedPropertyDescriptor]

'PACKAGES_MASK' @ [74:132] ==> public final val PACKAGES_MASK: Int defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter.Companion[DeserializedPropertyDescriptor]

'NonAnnotationClassifierExclude' @ [74:155] ==> private object NonAnnotationClassifierExclude : DescriptorKindExclude defined in org.jetbrains.kotlin.idea.util.CallType[FakeCallableDescriptorForObject]

'DescriptorKindExclude' @ [76:38] ==> public constructor DescriptorKindExclude() defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindExclude[DeserializedClassConstructorDescriptor]

'!' @ [78:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'descriptor' @ [78:19] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.util.CallType.NonInfixExclude.excludes[ValueParameterDescriptorImpl]

'descriptor' @ [78:61] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.util.CallType.NonInfixExclude.excludes[ValueParameterDescriptorImpl]

'isInfix' @ [78:72] ==> public final val SimpleFunctionDescriptor.isInfix: Boolean[MyPropertyDescriptor]

'DescriptorKindExclude' @ [84:41] ==> public constructor DescriptorKindExclude() defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindExclude[DeserializedClassConstructorDescriptor]

'!' @ [86:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'descriptor' @ [86:19] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.util.CallType.NonOperatorExclude.excludes[ValueParameterDescriptorImpl]

'descriptor' @ [86:61] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.util.CallType.NonOperatorExclude.excludes[ValueParameterDescriptorImpl]

'isOperator' @ [86:72] ==> public final val SimpleFunctionDescriptor.isOperator: Boolean[MyPropertyDescriptor]

'DescriptorKindExclude' @ [92:47] ==> public constructor DescriptorKindExclude() defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindExclude[DeserializedClassConstructorDescriptor]

'descriptor' @ [94:19] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.util.CallType.CallableReferenceExclude.excludes[ValueParameterDescriptorImpl]

'descriptor' @ [94:62] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.util.CallType.CallableReferenceExclude.excludes[ValueParameterDescriptorImpl]

'kind' @ [94:73] ==> public final val CallableMemberDescriptor.kind: CallableMemberDescriptor.Kind[MyPropertyDescriptor]

'SYNTHESIZED' @ [94:111] ==> enum entry SYNTHESIZED defined in org.jetbrains.kotlin.descriptors.CallableMemberDescriptor.Kind[FakeCallableDescriptorForObject]

'DescriptorKindExclude' @ [100:53] ==> public constructor DescriptorKindExclude() defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindExclude[DeserializedClassConstructorDescriptor]

'descriptor' @ [102:17] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.util.CallType.NonAnnotationClassifierExclude.excludes[ValueParameterDescriptorImpl]

'descriptor' @ [103:20] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.util.CallType.NonAnnotationClassifierExclude.excludes[ValueParameterDescriptorImpl]

'descriptor' @ [103:54] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.util.CallType.NonAnnotationClassifierExclude.excludes[ValueParameterDescriptorImpl]

'kind' @ [103:65] ==> public final val ClassDescriptor.kind: ClassKind[MyPropertyDescriptor]

'ANNOTATION_CLASS' @ [103:83] ==> enum entry ANNOTATION_CLASS defined in org.jetbrains.kotlin.descriptors.ClassKind[FakeCallableDescriptorForObject]

'DescriptorKindExclude' @ [109:45] ==> public constructor DescriptorKindExclude() defined in org.jetbrains.kotlin.resolve.scopes.DescriptorKindExclude[DeserializedClassConstructorDescriptor]

'descriptor' @ [111:19] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.util.CallType.AbstractMembersExclude.excludes[ValueParameterDescriptorImpl]

'descriptor' @ [111:61] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.idea.util.CallType.AbstractMembersExclude.excludes[ValueParameterDescriptorImpl]

'modality' @ [111:72] ==> public final val CallableMemberDescriptor.modality: Modality[MyPropertyDescriptor]

'ABSTRACT' @ [111:93] ==> enum entry ABSTRACT defined in org.jetbrains.kotlin.descriptors.Modality[FakeCallableDescriptorForObject]

'CallTypeAndReceiver<Nothing?, CallType.UNKNOWN>' @ [122:22] ==> private constructor CallTypeAndReceiver<TReceiver : KtElement?, out TCallType : CallType<Nothing?>>(callType: CallType.UNKNOWN, receiver: Nothing?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> Nothing?
    <out TCallType : CallType<TReceiver>> -> UNKNOWN

'UNKNOWN' @ [122:79] ==> public object UNKNOWN : CallType<Nothing?> defined in org.jetbrains.kotlin.idea.util.CallType[FakeCallableDescriptorForObject]

'CallTypeAndReceiver<Nothing?, CallType.DEFAULT>' @ [123:22] ==> private constructor CallTypeAndReceiver<TReceiver : KtElement?, out TCallType : CallType<Nothing?>>(callType: CallType.DEFAULT, receiver: Nothing?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> Nothing?
    <out TCallType : CallType<TReceiver>> -> DEFAULT

'DEFAULT' @ [123:79] ==> public object DEFAULT : CallType<Nothing?> defined in org.jetbrains.kotlin.idea.util.CallType[FakeCallableDescriptorForObject]

'CallTypeAndReceiver<KtExpression, CallType.DOT>' @ [124:41] ==> private constructor CallTypeAndReceiver<TReceiver : KtElement?, out TCallType : CallType<KtExpression>>(callType: CallType.DOT, receiver: KtExpression) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> KtExpression
    <out TCallType : CallType<TReceiver>> -> DOT

'DOT' @ [124:98] ==> public object DOT : CallType<KtExpression> defined in org.jetbrains.kotlin.idea.util.CallType[FakeCallableDescriptorForObject]

'receiver' @ [124:103] ==> value-parameter receiver: KtExpression defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.DOT.<init>[ValueParameterDescriptorImpl]

'CallTypeAndReceiver<KtExpression, CallType.SAFE>' @ [125:42] ==> private constructor CallTypeAndReceiver<TReceiver : KtElement?, out TCallType : CallType<KtExpression>>(callType: CallType.SAFE, receiver: KtExpression) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> KtExpression
    <out TCallType : CallType<TReceiver>> -> SAFE

'SAFE' @ [125:100] ==> public object SAFE : CallType<KtExpression> defined in org.jetbrains.kotlin.idea.util.CallType[FakeCallableDescriptorForObject]

'receiver' @ [125:106] ==> value-parameter receiver: KtExpression defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.SAFE.<init>[ValueParameterDescriptorImpl]

'CallTypeAndReceiver<KtSuperExpression, CallType.SUPER_MEMBERS>' @ [126:56] ==> private constructor CallTypeAndReceiver<TReceiver : KtElement?, out TCallType : CallType<KtSuperExpression>>(callType: CallType.SUPER_MEMBERS, receiver: KtSuperExpression) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> KtSuperExpression
    <out TCallType : CallType<TReceiver>> -> SUPER_MEMBERS

'SUPER_MEMBERS' @ [126:128] ==> public object SUPER_MEMBERS : CallType<KtSuperExpression> defined in org.jetbrains.kotlin.idea.util.CallType[FakeCallableDescriptorForObject]

'receiver' @ [126:143] ==> value-parameter receiver: KtSuperExpression defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.SUPER_MEMBERS.<init>[ValueParameterDescriptorImpl]

'CallTypeAndReceiver<KtExpression, CallType.INFIX>' @ [127:43] ==> private constructor CallTypeAndReceiver<TReceiver : KtElement?, out TCallType : CallType<KtExpression>>(callType: CallType.INFIX, receiver: KtExpression) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> KtExpression
    <out TCallType : CallType<TReceiver>> -> INFIX

'INFIX' @ [127:102] ==> public object INFIX : CallType<KtExpression> defined in org.jetbrains.kotlin.idea.util.CallType[FakeCallableDescriptorForObject]

'receiver' @ [127:109] ==> value-parameter receiver: KtExpression defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.INFIX.<init>[ValueParameterDescriptorImpl]

'CallTypeAndReceiver<KtExpression, CallType.OPERATOR>' @ [128:46] ==> private constructor CallTypeAndReceiver<TReceiver : KtElement?, out TCallType : CallType<KtExpression>>(callType: CallType.OPERATOR, receiver: KtExpression) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> KtExpression
    <out TCallType : CallType<TReceiver>> -> OPERATOR

'OPERATOR' @ [128:108] ==> public object OPERATOR : CallType<KtExpression> defined in org.jetbrains.kotlin.idea.util.CallType[FakeCallableDescriptorForObject]

'receiver' @ [128:118] ==> value-parameter receiver: KtExpression defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.OPERATOR.<init>[ValueParameterDescriptorImpl]

'CallTypeAndReceiver<KtExpression?, CallType.CALLABLE_REFERENCE>' @ [129:57] ==> private constructor CallTypeAndReceiver<TReceiver : KtElement?, out TCallType : CallType<KtExpression?>>(callType: CallType.CALLABLE_REFERENCE, receiver: KtExpression?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> KtExpression?
    <out TCallType : CallType<TReceiver>> -> CALLABLE_REFERENCE

'CALLABLE_REFERENCE' @ [129:130] ==> public object CALLABLE_REFERENCE : CallType<KtExpression?> defined in org.jetbrains.kotlin.idea.util.CallType[FakeCallableDescriptorForObject]

'receiver' @ [129:150] ==> value-parameter receiver: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.CALLABLE_REFERENCE.<init>[ValueParameterDescriptorImpl]

'CallTypeAndReceiver<KtExpression?, CallType.IMPORT_DIRECTIVE>' @ [130:55] ==> private constructor CallTypeAndReceiver<TReceiver : KtElement?, out TCallType : CallType<KtExpression?>>(callType: CallType.IMPORT_DIRECTIVE, receiver: KtExpression?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> KtExpression?
    <out TCallType : CallType<TReceiver>> -> IMPORT_DIRECTIVE

'IMPORT_DIRECTIVE' @ [130:126] ==> public object IMPORT_DIRECTIVE : CallType<KtExpression?> defined in org.jetbrains.kotlin.idea.util.CallType[FakeCallableDescriptorForObject]

'receiver' @ [130:144] ==> value-parameter receiver: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.IMPORT_DIRECTIVE.<init>[ValueParameterDescriptorImpl]

'CallTypeAndReceiver<KtExpression?, CallType.PACKAGE_DIRECTIVE>' @ [131:56] ==> private constructor CallTypeAndReceiver<TReceiver : KtElement?, out TCallType : CallType<KtExpression?>>(callType: CallType.PACKAGE_DIRECTIVE, receiver: KtExpression?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> KtExpression?
    <out TCallType : CallType<TReceiver>> -> PACKAGE_DIRECTIVE

'PACKAGE_DIRECTIVE' @ [131:128] ==> public object PACKAGE_DIRECTIVE : CallType<KtExpression?> defined in org.jetbrains.kotlin.idea.util.CallType[FakeCallableDescriptorForObject]

'receiver' @ [131:147] ==> value-parameter receiver: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.PACKAGE_DIRECTIVE.<init>[ValueParameterDescriptorImpl]

'CallTypeAndReceiver<KtExpression?, CallType.TYPE>' @ [132:43] ==> private constructor CallTypeAndReceiver<TReceiver : KtElement?, out TCallType : CallType<KtExpression?>>(callType: CallType.TYPE, receiver: KtExpression?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> KtExpression?
    <out TCallType : CallType<TReceiver>> -> TYPE

'TYPE' @ [132:102] ==> public object TYPE : CallType<KtExpression?> defined in org.jetbrains.kotlin.idea.util.CallType[FakeCallableDescriptorForObject]

'receiver' @ [132:108] ==> value-parameter receiver: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.TYPE.<init>[ValueParameterDescriptorImpl]

'CallTypeAndReceiver<KtExpression?, CallType.DELEGATE>' @ [133:47] ==> private constructor CallTypeAndReceiver<TReceiver : KtElement?, out TCallType : CallType<KtExpression?>>(callType: CallType.DELEGATE, receiver: KtExpression?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> KtExpression?
    <out TCallType : CallType<TReceiver>> -> DELEGATE

'DELEGATE' @ [133:110] ==> public object DELEGATE : CallType<KtExpression?> defined in org.jetbrains.kotlin.idea.util.CallType[FakeCallableDescriptorForObject]

'receiver' @ [133:120] ==> value-parameter receiver: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.DELEGATE.<init>[ValueParameterDescriptorImpl]

'CallTypeAndReceiver<KtExpression?, CallType.ANNOTATION>' @ [134:49] ==> private constructor CallTypeAndReceiver<TReceiver : KtElement?, out TCallType : CallType<KtExpression?>>(callType: CallType.ANNOTATION, receiver: KtExpression?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver[ClassConstructorDescriptorImpl]
Inferred types:
    <TReceiver : KtElement?> -> KtExpression?
    <out TCallType : CallType<TReceiver>> -> ANNOTATION

'ANNOTATION' @ [134:114] ==> public object ANNOTATION : CallType<KtExpression?> defined in org.jetbrains.kotlin.idea.util.CallType[FakeCallableDescriptorForObject]

'receiver' @ [134:126] ==> value-parameter receiver: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.ANNOTATION.<init>[ValueParameterDescriptorImpl]

'expression' @ [138:26] ==> value-parameter expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[ValueParameterDescriptorImpl]

'parent' @ [138:37] ==> public final val KtSimpleNameExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [139:17] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'expression' @ [139:60] ==> value-parameter expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[ValueParameterDescriptorImpl]

'parent' @ [139:74] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'callableReference' @ [139:81] ==> public final val KtCallableReferenceExpression.callableReference: KtSimpleNameExpression[MyPropertyDescriptor]

'CallTypeAndReceiver' @ [140:24] ==> public companion object defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver[FakeCallableDescriptorForObject]

'CALLABLE_REFERENCE' @ [140:44] ==> public constructor CALLABLE_REFERENCE(receiver: KtExpression?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.CALLABLE_REFERENCE[ClassConstructorDescriptorImpl]

'parent' @ [140:63] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'receiverExpression' @ [140:70] ==> public final val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.psi.KtCallableReferenceExpression[DeserializedPropertyDescriptor]

'expression' @ [143:38] ==> value-parameter expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[ValueParameterDescriptorImpl]

'getReceiverExpression' @ [143:49] ==> public fun KtSimpleNameExpression.getReceiverExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'expression' @ [145:17] ==> value-parameter expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[ValueParameterDescriptorImpl]

'isImportDirectiveExpression' @ [145:28] ==> public fun KtSimpleNameExpression.isImportDirectiveExpression(): Boolean defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'CallTypeAndReceiver' @ [146:24] ==> public companion object defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver[FakeCallableDescriptorForObject]

'IMPORT_DIRECTIVE' @ [146:44] ==> public constructor IMPORT_DIRECTIVE(receiver: KtExpression?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.IMPORT_DIRECTIVE[ClassConstructorDescriptorImpl]

'receiverExpression' @ [146:61] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'expression' @ [149:17] ==> value-parameter expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[ValueParameterDescriptorImpl]

'isPackageDirectiveExpression' @ [149:28] ==> public fun KtSimpleNameExpression.isPackageDirectiveExpression(): Boolean defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]

'CallTypeAndReceiver' @ [150:24] ==> public companion object defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver[FakeCallableDescriptorForObject]

'PACKAGE_DIRECTIVE' @ [150:44] ==> public constructor PACKAGE_DIRECTIVE(receiver: KtExpression?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.PACKAGE_DIRECTIVE[ClassConstructorDescriptorImpl]

'receiverExpression' @ [150:62] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'parent' @ [153:17] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'parent' @ [154:42] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'parent' @ [154:49] ==> public final val KtUserType.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [154:78] ==> public final val KtTypeReference.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'constructorCallee' @ [155:21] ==> val constructorCallee: KtConstructorCalleeExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'constructorCallee' @ [155:50] ==> val constructorCallee: KtConstructorCalleeExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'parent' @ [155:68] ==> public final val KtConstructorCalleeExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'CallTypeAndReceiver' @ [156:28] ==> public companion object defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver[FakeCallableDescriptorForObject]

'ANNOTATION' @ [156:48] ==> public constructor ANNOTATION(receiver: KtExpression?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.ANNOTATION[ClassConstructorDescriptorImpl]

'receiverExpression' @ [156:59] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'CallTypeAndReceiver' @ [159:24] ==> public companion object defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver[FakeCallableDescriptorForObject]

'TYPE' @ [159:44] ==> public constructor TYPE(receiver: KtExpression?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.TYPE[ClassConstructorDescriptorImpl]

'receiverExpression' @ [159:49] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'when (expression) {
                is KtOperationReferenceExpression -> {
                    if (receiverExpression == null) {
                        return UNKNOWN // incomplete code
                    }
                    return when (parent) {
                        is KtBinaryExpression -> {
                            if (parent.operationToken == KtTokens.IDENTIFIER)
                                CallTypeAndReceiver.INFIX(receiverExpression)
                            else
                                CallTypeAndReceiver.OPERATOR(receiverExpression)
                        }

                        is KtUnaryExpression -> CallTypeAndReceiver.OPERATOR(receiverExpression)

                        else -> error("Unknown parent for JetOperationReferenceExpression: $parent with text '${parent.text}'")
                    }
                }

                is KtNameReferenceExpression -> {
                    if (receiverExpression == null) {
                        return CallTypeAndReceiver.DEFAULT
                    }

                    if (receiverExpression is KtSuperExpression) {
                        return CallTypeAndReceiver.SUPER_MEMBERS(receiverExpression)
                    }

                    return when (parent) {
                        is KtCallExpression -> {
                            if ((parent.parent as KtQualifiedExpression).operationSign == KtTokens.SAFE_ACCESS)
                                CallTypeAndReceiver.SAFE(receiverExpression)
                            else
                                CallTypeAndReceiver.DOT(receiverExpression)
                        }

                        is KtQualifiedExpression -> {
                            if (parent.operationSign == KtTokens.SAFE_ACCESS)
                                CallTypeAndReceiver.SAFE(receiverExpression)
                            else
                                CallTypeAndReceiver.DOT(receiverExpression)
                        }

                        else -> error("Unknown parent for JetNameReferenceExpression with receiver: $parent")
                    }
                }

                else -> return UNKNOWN
            }' @ [162:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Nothing, entry1: Nothing, entry2: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Nothing

'expression' @ [162:19] ==> value-parameter expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[ValueParameterDescriptorImpl]

'receiverExpression' @ [164:25] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'UNKNOWN' @ [165:32] ==> public object UNKNOWN : CallTypeAndReceiver<Nothing?, CallType.UNKNOWN> defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver[FakeCallableDescriptorForObject]

'when (parent) {
                        is KtBinaryExpression -> {
                            if (parent.operationToken == KtTokens.IDENTIFIER)
                                CallTypeAndReceiver.INFIX(receiverExpression)
                            else
                                CallTypeAndReceiver.OPERATOR(receiverExpression)
                        }

                        is KtUnaryExpression -> CallTypeAndReceiver.OPERATOR(receiverExpression)

                        else -> error("Unknown parent for JetOperationReferenceExpression: $parent with text '${parent.text}'")
                    }' @ [167:28] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: CallTypeAndReceiver<*, *>, entry1: CallTypeAndReceiver<*, *>, entry2: CallTypeAndReceiver<*, *>): CallTypeAndReceiver<*, *>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> CallTypeAndReceiver<*, *>

'parent' @ [167:34] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'if (parent.operationToken == KtTokens.IDENTIFIER)
                                CallTypeAndReceiver.INFIX(receiverExpression)
                            else
                                CallTypeAndReceiver.OPERATOR(receiverExpression)' @ [169:29] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: CallTypeAndReceiver<KtExpression, *>, elseBranch: CallTypeAndReceiver<KtExpression, *>): CallTypeAndReceiver<KtExpression, *>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> CallTypeAndReceiver<KtExpression, *>

'parent' @ [169:33] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'operationToken' @ [169:40] ==> public final val KtBinaryExpression.operationToken: IElementType[MyPropertyDescriptor]

'IDENTIFIER' @ [169:67] ==> public final val IDENTIFIER: (KtToken..KtToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'INFIX' @ [170:53] ==> public constructor INFIX(receiver: KtExpression) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.INFIX[ClassConstructorDescriptorImpl]

'receiverExpression' @ [170:59] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'OPERATOR' @ [172:53] ==> public constructor OPERATOR(receiver: KtExpression) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.OPERATOR[ClassConstructorDescriptorImpl]

'receiverExpression' @ [172:62] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'OPERATOR' @ [175:69] ==> public constructor OPERATOR(receiver: KtExpression) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.OPERATOR[ClassConstructorDescriptorImpl]

'receiverExpression' @ [175:78] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'error' @ [177:33] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'parent' @ [177:93] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'parent' @ [177:113] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'text' @ [177:120] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'receiverExpression' @ [182:25] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'CallTypeAndReceiver' @ [183:32] ==> public companion object defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver[FakeCallableDescriptorForObject]

'DEFAULT' @ [183:52] ==> public object DEFAULT : CallTypeAndReceiver<Nothing?, CallType.DEFAULT> defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver[FakeCallableDescriptorForObject]

'receiverExpression' @ [186:25] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'CallTypeAndReceiver' @ [187:32] ==> public companion object defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver[FakeCallableDescriptorForObject]

'SUPER_MEMBERS' @ [187:52] ==> public constructor SUPER_MEMBERS(receiver: KtSuperExpression) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.SUPER_MEMBERS[ClassConstructorDescriptorImpl]

'receiverExpression' @ [187:66] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'when (parent) {
                        is KtCallExpression -> {
                            if ((parent.parent as KtQualifiedExpression).operationSign == KtTokens.SAFE_ACCESS)
                                CallTypeAndReceiver.SAFE(receiverExpression)
                            else
                                CallTypeAndReceiver.DOT(receiverExpression)
                        }

                        is KtQualifiedExpression -> {
                            if (parent.operationSign == KtTokens.SAFE_ACCESS)
                                CallTypeAndReceiver.SAFE(receiverExpression)
                            else
                                CallTypeAndReceiver.DOT(receiverExpression)
                        }

                        else -> error("Unknown parent for JetNameReferenceExpression with receiver: $parent")
                    }' @ [190:28] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: CallTypeAndReceiver<*, *>, entry1: CallTypeAndReceiver<*, *>, entry2: CallTypeAndReceiver<*, *>): CallTypeAndReceiver<*, *>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> CallTypeAndReceiver<*, *>

'parent' @ [190:34] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'if ((parent.parent as KtQualifiedExpression).operationSign == KtTokens.SAFE_ACCESS)
                                CallTypeAndReceiver.SAFE(receiverExpression)
                            else
                                CallTypeAndReceiver.DOT(receiverExpression)' @ [192:29] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: CallTypeAndReceiver<KtExpression, *>, elseBranch: CallTypeAndReceiver<KtExpression, *>): CallTypeAndReceiver<KtExpression, *>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> CallTypeAndReceiver<KtExpression, *>

'==' @ [192:33] ==> public open fun equals(other: Any?): Boolean defined in org.jetbrains.kotlin.lexer.KtSingleValueToken[DeserializedSimpleFunctionDescriptor]

'parent' @ [192:34] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'parent' @ [192:41] ==> public final val KtCallExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'operationSign' @ [192:74] ==> public open val operationSign: KtSingleValueToken defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[DeserializedPropertyDescriptor]

'SAFE_ACCESS' @ [192:100] ==> public final val SAFE_ACCESS: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'SAFE' @ [193:53] ==> public constructor SAFE(receiver: KtExpression) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.SAFE[ClassConstructorDescriptorImpl]

'receiverExpression' @ [193:58] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'DOT' @ [195:53] ==> public constructor DOT(receiver: KtExpression) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.DOT[ClassConstructorDescriptorImpl]

'receiverExpression' @ [195:57] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'if (parent.operationSign == KtTokens.SAFE_ACCESS)
                                CallTypeAndReceiver.SAFE(receiverExpression)
                            else
                                CallTypeAndReceiver.DOT(receiverExpression)' @ [199:29] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: CallTypeAndReceiver<KtExpression, *>, elseBranch: CallTypeAndReceiver<KtExpression, *>): CallTypeAndReceiver<KtExpression, *>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> CallTypeAndReceiver<KtExpression, *>

'parent' @ [199:33] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'operationSign' @ [199:40] ==> public open val operationSign: KtSingleValueToken defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[DeserializedPropertyDescriptor]

'SAFE_ACCESS' @ [199:66] ==> public final val SAFE_ACCESS: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'SAFE' @ [200:53] ==> public constructor SAFE(receiver: KtExpression) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.SAFE[ClassConstructorDescriptorImpl]

'receiverExpression' @ [200:58] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'DOT' @ [202:53] ==> public constructor DOT(receiver: KtExpression) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.DOT[ClassConstructorDescriptorImpl]

'receiverExpression' @ [202:57] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'error' @ [205:33] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'parent' @ [205:102] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.Companion.detect[LocalVariableDescriptor]

'UNKNOWN' @ [209:32] ==> public object UNKNOWN : CallTypeAndReceiver<Nothing?, CallType.UNKNOWN> defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver[FakeCallableDescriptorForObject]

'receiverTypesWithIndex' @ [224:12] ==> public fun CallTypeAndReceiver<*, *>.receiverTypesWithIndex(bindingContext: BindingContext, contextElement: PsiElement, moduleDescriptor: ModuleDescriptor, resolutionFacade: ResolutionFacade, stableSmartCastsOnly: Boolean, withImplicitReceiversWhenExplicitPresent: Boolean = ...): Collection<ReceiverType>? defined in org.jetbrains.kotlin.idea.util in file CallType.kt[SimpleFunctionDescriptorImpl]

'bindingContext' @ [224:35] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.util.receiverTypes[ValueParameterDescriptorImpl]

'contextElement' @ [224:51] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.util.receiverTypes[ValueParameterDescriptorImpl]

'moduleDescriptor' @ [224:67] ==> value-parameter moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.idea.util.receiverTypes[ValueParameterDescriptorImpl]

'resolutionFacade' @ [224:85] ==> value-parameter resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.util.receiverTypes[ValueParameterDescriptorImpl]

'stableSmartCastsOnly' @ [224:103] ==> value-parameter stableSmartCastsOnly: Boolean defined in org.jetbrains.kotlin.idea.util.receiverTypes[ValueParameterDescriptorImpl]

'map' @ [224:126] ==> public inline fun <T, R> Iterable<ReceiverType>.map(transform: (ReceiverType) -> KotlinType): List<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ReceiverType
    <R> -> KotlinType

'it' @ [224:132] ==> value-parameter it: ReceiverType defined in org.jetbrains.kotlin.idea.util.receiverTypes.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [224:135] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.idea.util.ReceiverType[PropertyDescriptorImpl]

'when (this) {
        is CallTypeAndReceiver.CALLABLE_REFERENCE -> {
            if (receiver != null) {
                val lhs = bindingContext[BindingContext.DOUBLE_COLON_LHS, receiver] ?: return emptyList()
                when (lhs) {
                    is DoubleColonLHS.Type -> return listOf(ReceiverType(lhs.type, 0))

                    is DoubleColonLHS.Expression -> {
                        val receiverValue = ExpressionReceiver.create(receiver, lhs.type, bindingContext)
                        return receiverValueTypes(receiverValue, lhs.dataFlowInfo, bindingContext, moduleDescriptor, stableSmartCastsOnly)
                                .map { ReceiverType(it, 0) }
                    }
                }
                Unit // inline
            }
            else {
                return emptyList()
            }
        }

        is CallTypeAndReceiver.DEFAULT -> receiverExpression = null

        is CallTypeAndReceiver.DOT -> receiverExpression = receiver
        is CallTypeAndReceiver.SAFE -> receiverExpression = receiver
        is CallTypeAndReceiver.INFIX -> receiverExpression = receiver
        is CallTypeAndReceiver.OPERATOR -> receiverExpression = receiver
        is CallTypeAndReceiver.DELEGATE -> receiverExpression = receiver

        is CallTypeAndReceiver.SUPER_MEMBERS -> {
            val qualifier = receiver.superTypeQualifier
            return if (qualifier != null) {
                listOfNotNull(bindingContext.getType(receiver)).map { ReceiverType(it, 0) }
            }
            else {
                val resolutionScope = contextElement.getResolutionScope(bindingContext, resolutionFacade)
                val classDescriptor = resolutionScope.ownerDescriptor.parentsWithSelf.firstIsInstanceOrNull<ClassDescriptor>() ?: return emptyList()
                classDescriptor.typeConstructor.supertypesWithAny().map { ReceiverType(it, 0) }
            }
        }

        is CallTypeAndReceiver.IMPORT_DIRECTIVE,
        is CallTypeAndReceiver.PACKAGE_DIRECTIVE,
        is CallTypeAndReceiver.TYPE,
        is CallTypeAndReceiver.ANNOTATION,
        is CallTypeAndReceiver.UNKNOWN ->
            return null
    }' @ [236:5] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit, entry3: Unit, entry4: Unit, entry5: Unit, entry6: Unit, entry7: Unit, entry8: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'this' @ [236:11] ==> <this> defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[ReceiverParameterDescriptorImpl]

'if (receiver != null) {
                val lhs = bindingContext[BindingContext.DOUBLE_COLON_LHS, receiver] ?: return emptyList()
                when (lhs) {
                    is DoubleColonLHS.Type -> return listOf(ReceiverType(lhs.type, 0))

                    is DoubleColonLHS.Expression -> {
                        val receiverValue = ExpressionReceiver.create(receiver, lhs.type, bindingContext)
                        return receiverValueTypes(receiverValue, lhs.dataFlowInfo, bindingContext, moduleDescriptor, stableSmartCastsOnly)
                                .map { ReceiverType(it, 0) }
                    }
                }
                Unit // inline
            }
            else {
                return emptyList()
            }' @ [238:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'receiver' @ [238:17] ==> public final val receiver: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.CALLABLE_REFERENCE[PropertyDescriptorImpl]

'bindingContext' @ [239:27] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[ValueParameterDescriptorImpl]

'DOUBLE_COLON_LHS' @ [239:57] ==> public final val DOUBLE_COLON_LHS: (WritableSlice<(KtExpression..KtExpression?), (DoubleColonLHS..DoubleColonLHS?)>..WritableSlice<(KtExpression..KtExpression?), (DoubleColonLHS..DoubleColonLHS?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'receiver' @ [239:75] ==> public final val receiver: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.CALLABLE_REFERENCE[PropertyDescriptorImpl]

'emptyList' @ [239:95] ==> public fun <T> emptyList(): List<ReceiverType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ReceiverType

'when (lhs) {
                    is DoubleColonLHS.Type -> return listOf(ReceiverType(lhs.type, 0))

                    is DoubleColonLHS.Expression -> {
                        val receiverValue = ExpressionReceiver.create(receiver, lhs.type, bindingContext)
                        return receiverValueTypes(receiverValue, lhs.dataFlowInfo, bindingContext, moduleDescriptor, stableSmartCastsOnly)
                                .map { ReceiverType(it, 0) }
                    }
                }' @ [240:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Nothing, entry1: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Nothing

'lhs' @ [240:23] ==> val lhs: DoubleColonLHS defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'listOf' @ [241:54] ==> public fun <T> listOf(element: ReceiverType): List<ReceiverType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ReceiverType

'ReceiverType' @ [241:61] ==> public constructor ReceiverType(type: KotlinType, receiverIndex: Int, implicit: Boolean = ...) defined in org.jetbrains.kotlin.idea.util.ReceiverType[ClassConstructorDescriptorImpl]

'lhs' @ [241:74] ==> val lhs: DoubleColonLHS defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'type' @ [241:78] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.types.expressions.DoubleColonLHS[DeserializedPropertyDescriptor]

'ExpressionReceiver' @ [244:45] ==> public companion object defined in org.jetbrains.kotlin.resolve.scopes.receivers.ExpressionReceiver[FakeCallableDescriptorForObject]

'create' @ [244:64] ==> public final fun create(expression: KtExpression, type: KotlinType, bindingContext: BindingContext): ExpressionReceiver defined in org.jetbrains.kotlin.resolve.scopes.receivers.ExpressionReceiver.Companion[DeserializedSimpleFunctionDescriptor]

'receiver' @ [244:71] ==> public final val receiver: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.CALLABLE_REFERENCE[PropertyDescriptorImpl]

'lhs' @ [244:81] ==> val lhs: DoubleColonLHS defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'type' @ [244:85] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.types.expressions.DoubleColonLHS[DeserializedPropertyDescriptor]

'bindingContext' @ [244:91] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[ValueParameterDescriptorImpl]

'receiverValueTypes' @ [245:32] ==> private fun receiverValueTypes(receiverValue: ReceiverValue, dataFlowInfo: DataFlowInfo, bindingContext: BindingContext, moduleDescriptor: ModuleDescriptor, stableSmartCastsOnly: Boolean): List<KotlinType> defined in org.jetbrains.kotlin.idea.util in file CallType.kt[SimpleFunctionDescriptorImpl]

'receiverValue' @ [245:51] ==> val receiverValue: ExpressionReceiver defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'lhs' @ [245:66] ==> val lhs: DoubleColonLHS defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'dataFlowInfo' @ [245:70] ==> public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.types.expressions.DoubleColonLHS.Expression[DeserializedPropertyDescriptor]

'bindingContext' @ [245:84] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[ValueParameterDescriptorImpl]

'moduleDescriptor' @ [245:100] ==> value-parameter moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[ValueParameterDescriptorImpl]

'stableSmartCastsOnly' @ [245:118] ==> value-parameter stableSmartCastsOnly: Boolean defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[ValueParameterDescriptorImpl]

'map' @ [246:34] ==> public inline fun <T, R> Iterable<KotlinType>.map(transform: (KotlinType) -> ReceiverType): List<ReceiverType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType
    <R> -> ReceiverType

'ReceiverType' @ [246:40] ==> public constructor ReceiverType(type: KotlinType, receiverIndex: Int, implicit: Boolean = ...) defined in org.jetbrains.kotlin.idea.util.ReceiverType[ClassConstructorDescriptorImpl]

'it' @ [246:53] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex.<anonymous>[ValueParameterDescriptorImpl]

'Unit' @ [249:17] ==> public object Unit defined in kotlin[FakeCallableDescriptorForObject]

'emptyList' @ [252:24] ==> public fun <T> emptyList(): List<ReceiverType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ReceiverType

'receiverExpression' @ [256:43] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'receiverExpression' @ [258:39] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'receiver' @ [258:60] ==> public final val receiver: KtExpression defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.DOT[PropertyDescriptorImpl]

'receiverExpression' @ [259:40] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'receiver' @ [259:61] ==> public final val receiver: KtExpression defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.SAFE[PropertyDescriptorImpl]

'receiverExpression' @ [260:41] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'receiver' @ [260:62] ==> public final val receiver: KtExpression defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.INFIX[PropertyDescriptorImpl]

'receiverExpression' @ [261:44] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'receiver' @ [261:65] ==> public final val receiver: KtExpression defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.OPERATOR[PropertyDescriptorImpl]

'receiverExpression' @ [262:44] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'receiver' @ [262:65] ==> public final val receiver: KtExpression? defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.DELEGATE[PropertyDescriptorImpl]

'receiver' @ [265:29] ==> public final val receiver: KtSuperExpression defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.SUPER_MEMBERS[PropertyDescriptorImpl]

'superTypeQualifier' @ [265:38] ==> public final val KtSuperExpression.superTypeQualifier: KtTypeReference?[MyPropertyDescriptor]

'if (qualifier != null) {
                listOfNotNull(bindingContext.getType(receiver)).map { ReceiverType(it, 0) }
            }
            else {
                val resolutionScope = contextElement.getResolutionScope(bindingContext, resolutionFacade)
                val classDescriptor = resolutionScope.ownerDescriptor.parentsWithSelf.firstIsInstanceOrNull<ClassDescriptor>() ?: return emptyList()
                classDescriptor.typeConstructor.supertypesWithAny().map { ReceiverType(it, 0) }
            }' @ [266:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Collection<ReceiverType>?, elseBranch: Collection<ReceiverType>?): Collection<ReceiverType>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Collection<ReceiverType>?

'qualifier' @ [266:24] ==> val qualifier: KtTypeReference? defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'listOfNotNull' @ [267:17] ==> public fun <T : Any> listOfNotNull(element: KotlinType?): List<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> KotlinType

'bindingContext' @ [267:31] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[ValueParameterDescriptorImpl]

'getType' @ [267:46] ==> @Nullable public abstract fun getType(@NotNull p0: KtExpression): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]

'receiver' @ [267:54] ==> public final val receiver: KtSuperExpression defined in org.jetbrains.kotlin.idea.util.CallTypeAndReceiver.SUPER_MEMBERS[PropertyDescriptorImpl]

'map' @ [267:65] ==> public inline fun <T, R> Iterable<KotlinType>.map(transform: (KotlinType) -> ReceiverType): List<ReceiverType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType
    <R> -> ReceiverType

'ReceiverType' @ [267:71] ==> public constructor ReceiverType(type: KotlinType, receiverIndex: Int, implicit: Boolean = ...) defined in org.jetbrains.kotlin.idea.util.ReceiverType[ClassConstructorDescriptorImpl]

'it' @ [267:84] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex.<anonymous>[ValueParameterDescriptorImpl]

'contextElement' @ [270:39] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[ValueParameterDescriptorImpl]

'getResolutionScope' @ [270:54] ==> public fun PsiElement.getResolutionScope(bindingContext: BindingContext, resolutionFacade: ResolutionFacade): LexicalScope defined in org.jetbrains.kotlin.idea.util in file scopeUtils.kt[SimpleFunctionDescriptorImpl]

'bindingContext' @ [270:73] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[ValueParameterDescriptorImpl]

'resolutionFacade' @ [270:89] ==> value-parameter resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[ValueParameterDescriptorImpl]

'resolutionScope' @ [271:39] ==> val resolutionScope: LexicalScope defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'ownerDescriptor' @ [271:55] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'parentsWithSelf' @ [271:71] ==> public val DeclarationDescriptor.parentsWithSelf: Sequence<DeclarationDescriptor> defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'firstIsInstanceOrNull' @ [271:87] ==> public inline fun <reified T : Any> Sequence<*>.firstIsInstanceOrNull(): ClassDescriptor? defined in org.jetbrains.kotlin.utils.addToStdlib[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : Any> -> ClassDescriptor

'emptyList' @ [271:138] ==> public fun <T> emptyList(): List<ReceiverType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ReceiverType

'classDescriptor' @ [272:17] ==> val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'typeConstructor' @ [272:33] ==> public final val ClassDescriptor.typeConstructor: TypeConstructor[MyPropertyDescriptor]

'supertypesWithAny' @ [272:49] ==> public fun TypeConstructor.supertypesWithAny(): Collection<KotlinType> defined in org.jetbrains.kotlin.util in file descriptorUtils.kt[SimpleFunctionDescriptorImpl]

'map' @ [272:69] ==> public inline fun <T, R> Iterable<KotlinType>.map(transform: (KotlinType) -> ReceiverType): List<ReceiverType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType
    <R> -> ReceiverType

'ReceiverType' @ [272:75] ==> public constructor ReceiverType(type: KotlinType, receiverIndex: Int, implicit: Boolean = ...) defined in org.jetbrains.kotlin.idea.util.ReceiverType[ClassConstructorDescriptorImpl]

'it' @ [272:88] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex.<anonymous>[ValueParameterDescriptorImpl]

'contextElement' @ [284:27] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[ValueParameterDescriptorImpl]

'getResolutionScope' @ [284:42] ==> public fun PsiElement.getResolutionScope(bindingContext: BindingContext, resolutionFacade: ResolutionFacade): LexicalScope defined in org.jetbrains.kotlin.idea.util in file scopeUtils.kt[SimpleFunctionDescriptorImpl]

'bindingContext' @ [284:61] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[ValueParameterDescriptorImpl]

'resolutionFacade' @ [284:77] ==> value-parameter resolutionFacade: ResolutionFacade defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[ValueParameterDescriptorImpl]

'receiverExpression' @ [286:30] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'let' @ [286:50] ==> @InlineOnly public inline fun <T, R> KtExpression.let(block: (KtExpression) -> ExpressionReceiver): ExpressionReceiver defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression
    <R> -> ExpressionReceiver

'bindingContext' @ [288:17] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[ValueParameterDescriptorImpl]

'getType' @ [288:32] ==> @Nullable public abstract fun getType(@NotNull p0: KtExpression): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]

'receiverExpression' @ [288:40] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'bindingContext' @ [289:18] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[ValueParameterDescriptorImpl]

'get' @ [289:33] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(p0: (ReadOnlySlice<(KtExpression..KtExpression?), (Qualifier..Qualifier?)>..ReadOnlySlice<(KtExpression..KtExpression?), (Qualifier..Qualifier?)>?), p1: (KtExpression..KtExpression?)): Qualifier? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.resolve.scopes.receivers.Qualifier..org.jetbrains.kotlin.resolve.scopes.receivers.Qualifier?)

'QUALIFIER' @ [289:52] ==> public final val QUALIFIER: (WritableSlice<(KtExpression..KtExpression?), (Qualifier..Qualifier?)>..WritableSlice<(KtExpression..KtExpression?), (Qualifier..Qualifier?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'receiverExpression' @ [289:63] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'descriptor' @ [289:104] ==> public open val descriptor: ClassDescriptor defined in org.jetbrains.kotlin.resolve.scopes.receivers.ClassQualifier[DeserializedPropertyDescriptor]

'classValueType' @ [289:116] ==> public val ClassDescriptor.classValueType: KotlinType? defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'bindingContext' @ [290:18] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[ValueParameterDescriptorImpl]

'get' @ [290:33] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(p0: (ReadOnlySlice<(KtExpression..KtExpression?), (Qualifier..Qualifier?)>..ReadOnlySlice<(KtExpression..KtExpression?), (Qualifier..Qualifier?)>?), p1: (KtExpression..KtExpression?)): Qualifier? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.resolve.scopes.receivers.Qualifier..org.jetbrains.kotlin.resolve.scopes.receivers.Qualifier?)

'QUALIFIER' @ [290:52] ==> public final val QUALIFIER: (WritableSlice<(KtExpression..KtExpression?), (Qualifier..Qualifier?)>..WritableSlice<(KtExpression..KtExpression?), (Qualifier..Qualifier?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'receiverExpression' @ [290:63] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'classDescriptor' @ [290:108] ==> public final val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.resolve.scopes.receivers.TypeAliasQualifier[DeserializedPropertyDescriptor]

'classValueType' @ [290:125] ==> public val ClassDescriptor.classValueType: KotlinType? defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'emptyList' @ [291:24] ==> public fun <T> emptyList(): List<ReceiverType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ReceiverType

'ExpressionReceiver' @ [292:9] ==> public companion object defined in org.jetbrains.kotlin.resolve.scopes.receivers.ExpressionReceiver[FakeCallableDescriptorForObject]

'create' @ [292:28] ==> public final fun create(expression: KtExpression, type: KotlinType, bindingContext: BindingContext): ExpressionReceiver defined in org.jetbrains.kotlin.resolve.scopes.receivers.ExpressionReceiver.Companion[DeserializedSimpleFunctionDescriptor]

'receiverExpression' @ [292:35] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'receiverType' @ [292:55] ==> val receiverType: KotlinType defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex.<anonymous>[LocalVariableDescriptor]

'bindingContext' @ [292:69] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[ValueParameterDescriptorImpl]

'resolutionScope' @ [295:34] ==> val resolutionScope: LexicalScope defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'getImplicitReceiversWithInstance' @ [295:50] ==> public fun LexicalScope.getImplicitReceiversWithInstance(): Collection<ReceiverParameterDescriptor> defined in org.jetbrains.kotlin.idea.util in file implicitReceiversUtils.kt[SimpleFunctionDescriptorImpl]

'map' @ [295:85] ==> public inline fun <T, R> Iterable<ReceiverParameterDescriptor>.map(transform: (ReceiverParameterDescriptor) -> ReceiverValue): List<ReceiverValue> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ReceiverParameterDescriptor
    <R> -> ReceiverValue

'it' @ [295:91] ==> value-parameter it: ReceiverParameterDescriptor defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [295:94] ==> public final val ReceiverParameterDescriptor.value: ReceiverValue[MyPropertyDescriptor]

'bindingContext' @ [297:24] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[ValueParameterDescriptorImpl]

'getDataFlowInfoBefore' @ [297:39] ==> public fun BindingContext.getDataFlowInfoBefore(position: PsiElement): DataFlowInfo defined in org.jetbrains.kotlin.resolve.bindingContextUtil[DeserializedSimpleFunctionDescriptor]

'contextElement' @ [297:61] ==> value-parameter contextElement: PsiElement defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[ValueParameterDescriptorImpl]

'ArrayList' @ [299:18] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> ReceiverType

'receiverValueTypes' @ [304:21] ==> private fun receiverValueTypes(receiverValue: ReceiverValue, dataFlowInfo: DataFlowInfo, bindingContext: BindingContext, moduleDescriptor: ModuleDescriptor, stableSmartCastsOnly: Boolean): List<KotlinType> defined in org.jetbrains.kotlin.idea.util in file CallType.kt[SimpleFunctionDescriptorImpl]

'receiverValue' @ [304:40] ==> value-parameter receiverValue: ReceiverValue defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex.addReceiverType[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [304:55] ==> val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'bindingContext' @ [304:69] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[ValueParameterDescriptorImpl]

'moduleDescriptor' @ [304:85] ==> value-parameter moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[ValueParameterDescriptorImpl]

'stableSmartCastsOnly' @ [304:103] ==> value-parameter stableSmartCastsOnly: Boolean defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[ValueParameterDescriptorImpl]

'types' @ [305:9] ==> val types: List<KotlinType> defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex.addReceiverType[LocalVariableDescriptor]

'mapTo' @ [305:15] ==> public inline fun <T, R, C : MutableCollection<in ReceiverType>> Iterable<KotlinType>.mapTo(destination: ArrayList<ReceiverType>, transform: (KotlinType) -> ReceiverType): ArrayList<ReceiverType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType
    <R> -> ReceiverType
    <C : MutableCollection<in R>> -> ArrayList<ReceiverType>

'result' @ [305:21] ==> val result: ArrayList<ReceiverType> defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'ReceiverType' @ [305:31] ==> public constructor ReceiverType(type: KotlinType, receiverIndex: Int, implicit: Boolean = ...) defined in org.jetbrains.kotlin.idea.util.ReceiverType[ClassConstructorDescriptorImpl]

'it' @ [305:44] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex.addReceiverType.<anonymous>[ValueParameterDescriptorImpl]

'receiverIndex' @ [305:48] ==> var receiverIndex: Int defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'implicit' @ [305:63] ==> value-parameter implicit: Boolean defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex.addReceiverType[ValueParameterDescriptorImpl]

'receiverIndex' @ [306:9] ==> var receiverIndex: Int defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'withImplicitReceiversWhenExplicitPresent' @ [308:9] ==> value-parameter withImplicitReceiversWhenExplicitPresent: Boolean = ... defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[ValueParameterDescriptorImpl]

'expressionReceiver' @ [308:53] ==> val expressionReceiver: ExpressionReceiver? defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'implicitReceiverValues' @ [309:9] ==> val implicitReceiverValues: List<ReceiverValue> defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'forEach' @ [309:32] ==> @HidesMembers public inline fun <T> Iterable<ReceiverValue>.forEach(action: (ReceiverValue) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ReceiverValue

'addReceiverType' @ [309:42] ==> local final fun addReceiverType(receiverValue: ReceiverValue, implicit: Boolean): Unit defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[SimpleFunctionDescriptorImpl]

'it' @ [309:58] ==> value-parameter it: ReceiverValue defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex.<anonymous>[ValueParameterDescriptorImpl]

'expressionReceiver' @ [311:9] ==> val expressionReceiver: ExpressionReceiver? defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'addReceiverType' @ [312:9] ==> local final fun addReceiverType(receiverValue: ReceiverValue, implicit: Boolean): Unit defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[SimpleFunctionDescriptorImpl]

'expressionReceiver' @ [312:25] ==> val expressionReceiver: ExpressionReceiver? defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'result' @ [314:12] ==> val result: ArrayList<ReceiverType> defined in org.jetbrains.kotlin.idea.util.receiverTypesWithIndex[LocalVariableDescriptor]

'DataFlowValueFactory' @ [324:25] ==> public object DataFlowValueFactory defined in org.jetbrains.kotlin.resolve.calls.smartcasts[FakeCallableDescriptorForObject]

'createDataFlowValue' @ [324:46] ==> @JvmStatic public final fun createDataFlowValue(receiverValue: ReceiverValue, bindingContext: BindingContext, containingDeclarationOrModule: DeclarationDescriptor): DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValueFactory[DeserializedSimpleFunctionDescriptor]

'receiverValue' @ [324:66] ==> value-parameter receiverValue: ReceiverValue defined in org.jetbrains.kotlin.idea.util.receiverValueTypes[ValueParameterDescriptorImpl]

'bindingContext' @ [324:81] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.util.receiverValueTypes[ValueParameterDescriptorImpl]

'moduleDescriptor' @ [324:97] ==> value-parameter moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.idea.util.receiverValueTypes[ValueParameterDescriptorImpl]

'if (dataFlowValue.isStable || !stableSmartCastsOnly) { // we don't include smart cast receiver types for "unstable" receiver value to mark members grayed
        SmartCastManager().getSmartCastVariantsWithLessSpecificExcluded(receiverValue, bindingContext, moduleDescriptor, dataFlowInfo)
    }
    else {
        listOf(receiverValue.type)
    }' @ [325:12] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<KotlinType>, elseBranch: List<KotlinType>): List<KotlinType>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<KotlinType>

'dataFlowValue' @ [325:16] ==> val dataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.idea.util.receiverValueTypes[LocalVariableDescriptor]

'isStable' @ [325:30] ==> public final val isStable: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[DeserializedPropertyDescriptor]

'!' @ [325:42] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'stableSmartCastsOnly' @ [325:43] ==> value-parameter stableSmartCastsOnly: Boolean defined in org.jetbrains.kotlin.idea.util.receiverValueTypes[ValueParameterDescriptorImpl]

'SmartCastManager' @ [326:9] ==> public constructor SmartCastManager() defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager[DeserializedClassConstructorDescriptor]

'getSmartCastVariantsWithLessSpecificExcluded' @ [326:28] ==> public fun SmartCastManager.getSmartCastVariantsWithLessSpecificExcluded(receiverToCast: ReceiverValue, bindingContext: BindingContext, containingDeclarationOrModule: DeclarationDescriptor, dataFlowInfo: DataFlowInfo): List<KotlinType> defined in org.jetbrains.kotlin.idea.util in file Utils.kt[SimpleFunctionDescriptorImpl]

'receiverValue' @ [326:73] ==> value-parameter receiverValue: ReceiverValue defined in org.jetbrains.kotlin.idea.util.receiverValueTypes[ValueParameterDescriptorImpl]

'bindingContext' @ [326:88] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.idea.util.receiverValueTypes[ValueParameterDescriptorImpl]

'moduleDescriptor' @ [326:104] ==> value-parameter moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.idea.util.receiverValueTypes[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [326:122] ==> value-parameter dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.idea.util.receiverValueTypes[ValueParameterDescriptorImpl]

'listOf' @ [329:9] ==> public fun <T> listOf(element: KotlinType): List<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'receiverValue' @ [329:16] ==> value-parameter receiverValue: ReceiverValue defined in org.jetbrains.kotlin.idea.util.receiverValueTypes[ValueParameterDescriptorImpl]

'type' @ [329:30] ==> public final val ReceiverValue.type: KotlinType[MyPropertyDescriptor]

'LinkedHashMap' @ [335:28] ==> public constructor LinkedHashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.LinkedHashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> FqName
    <V : (Any..Any?)> -> MutableList<ReceiverType>

'this' @ [337:5] ==> <this> defined in org.jetbrains.kotlin.idea.util.shadowedByDslMarkers[ReceiverParameterDescriptorImpl]

'mapNotNull' @ [338:14] ==> public inline fun <T, R : Any> Iterable<ReceiverType>.mapNotNull(transform: (ReceiverType) -> Pair<ReceiverType, Set<FqName>>?): List<Pair<ReceiverType, Set<FqName>>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ReceiverType
    <R : Any> -> Pair<ReceiverType, Set<FqName>>

'receiver' @ [339:34] ==> value-parameter receiver: ReceiverType defined in org.jetbrains.kotlin.idea.util.shadowedByDslMarkers.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [339:43] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.idea.util.ReceiverType[PropertyDescriptorImpl]

'extractDslMarkerFqNames' @ [339:48] ==> public final fun KotlinType.extractDslMarkerFqNames(): Set<FqName> defined in org.jetbrains.kotlin.resolve.calls.checkers.DslScopeViolationCallChecker[FunctionImportedFromObject]

'receiver' @ [340:18] ==> value-parameter receiver: ReceiverType defined in org.jetbrains.kotlin.idea.util.shadowedByDslMarkers.<anonymous>[ValueParameterDescriptorImpl]

'dslMarkers' @ [340:30] ==> val dslMarkers: Set<FqName> defined in org.jetbrains.kotlin.idea.util.shadowedByDslMarkers.<anonymous>[LocalVariableDescriptor]

'takeIf' @ [340:42] ==> @InlineOnly @SinceKotlin public inline fun <T> Pair<ReceiverType, Set<FqName>>.takeIf(predicate: (Pair<ReceiverType, Set<FqName>>) -> Boolean): Pair<ReceiverType, Set<FqName>>? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<ReceiverType, Set<FqName>>

'dslMarkers' @ [340:51] ==> val dslMarkers: Set<FqName> defined in org.jetbrains.kotlin.idea.util.shadowedByDslMarkers.<anonymous>[LocalVariableDescriptor]

'isNotEmpty' @ [340:62] ==> @InlineOnly public inline fun <T> Collection<FqName>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FqName

'forEach' @ [342:14] ==> @HidesMembers public inline fun <T> Iterable<Pair<ReceiverType, Set<FqName>>>.forEach(action: (Pair<ReceiverType, Set<FqName>>) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<ReceiverType, Set<FqName>>

'component1' @ [342:25] ==> public final operator fun component1(): ReceiverType defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [342:28] ==> public final operator fun component2(): Set<FqName> defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'dslMarkers' @ [342:43] ==> val dslMarkers: Set<FqName> defined in org.jetbrains.kotlin.idea.util.shadowedByDslMarkers.<anonymous>[LocalVariableDescriptor]

'forEach' @ [342:54] ==> @HidesMembers public inline fun <T> Iterable<FqName>.forEach(action: (FqName) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FqName

'typesByDslScopes' @ [342:64] ==> val typesByDslScopes: LinkedHashMap<FqName, MutableList<ReceiverType>> defined in org.jetbrains.kotlin.idea.util.shadowedByDslMarkers[LocalVariableDescriptor]

'getOrPut' @ [342:81] ==> public inline fun <K, V> MutableMap<FqName, MutableList<ReceiverType>>.getOrPut(key: FqName, defaultValue: () -> MutableList<ReceiverType>): MutableList<ReceiverType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> FqName
    <V> -> MutableList<ReceiverType>

'it' @ [342:90] ==> value-parameter it: FqName defined in org.jetbrains.kotlin.idea.util.shadowedByDslMarkers.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'mutableListOf' @ [342:96] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableListOf(): MutableList<ReceiverType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ReceiverType

'v' @ [342:118] ==> val v: ReceiverType defined in org.jetbrains.kotlin.idea.util.shadowedByDslMarkers.<anonymous>[LocalVariableDescriptor]

'mutableSetOf' @ [344:32] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableSetOf(): MutableSet<ReceiverType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ReceiverType

'typesByDslScopes' @ [345:5] ==> val typesByDslScopes: LinkedHashMap<FqName, MutableList<ReceiverType>> defined in org.jetbrains.kotlin.idea.util.shadowedByDslMarkers[LocalVariableDescriptor]

'flatMapTo' @ [345:22] ==> public inline fun <K, V, R, C : MutableCollection<in ReceiverType>> Map<out FqName, MutableList<ReceiverType>>.flatMapTo(destination: MutableSet<ReceiverType>, transform: (Map.Entry<FqName, MutableList<ReceiverType>>) -> Iterable<ReceiverType>): MutableSet<ReceiverType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> FqName
    <V> -> MutableList<ReceiverType>
    <R> -> ReceiverType
    <C : MutableCollection<in R>> -> MutableSet<ReceiverType>

'shadowedDslReceivers' @ [345:32] ==> val shadowedDslReceivers: MutableSet<ReceiverType> defined in org.jetbrains.kotlin.idea.util.shadowedByDslMarkers[LocalVariableDescriptor]

'component1' @ [345:57] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<FqName, MutableList<ReceiverType>>.component1(): FqName defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> FqName
    <V> -> MutableList<ReceiverType>

'component2' @ [345:60] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<FqName, MutableList<ReceiverType>>.component2(): MutableList<ReceiverType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> FqName
    <V> -> MutableList<ReceiverType>

'v' @ [345:66] ==> val v: MutableList<ReceiverType> defined in org.jetbrains.kotlin.idea.util.shadowedByDslMarkers.<anonymous>[LocalVariableDescriptor]

'asSequence' @ [345:68] ==> public fun <T> Iterable<ReceiverType>.asSequence(): Sequence<ReceiverType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ReceiverType

'drop' @ [345:81] ==> public fun <T> Sequence<ReceiverType>.drop(n: Int): Sequence<ReceiverType> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ReceiverType

'asIterable' @ [345:89] ==> public fun <T> Sequence<ReceiverType>.asIterable(): Iterable<ReceiverType> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ReceiverType

'shadowedDslReceivers' @ [347:12] ==> val shadowedDslReceivers: MutableSet<ReceiverType> defined in org.jetbrains.kotlin.idea.util.shadowedByDslMarkers[LocalVariableDescriptor]

