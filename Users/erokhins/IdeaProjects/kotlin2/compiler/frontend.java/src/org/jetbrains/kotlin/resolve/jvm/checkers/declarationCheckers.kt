'isInline' @ [44:24] ==> public open fun isInline(@Nullable p0: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.resolve.inline.InlineUtil[JavaMethodDescriptor]

'descriptor' @ [44:33] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.LocalFunInlineChecker.check[ValueParameterDescriptorImpl]

'declaration' @ [45:13] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.LocalFunInlineChecker.check[ValueParameterDescriptorImpl]

'descriptor' @ [46:13] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.LocalFunInlineChecker.check[ValueParameterDescriptorImpl]

'descriptor' @ [47:13] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.LocalFunInlineChecker.check[ValueParameterDescriptorImpl]

'visibility' @ [47:24] ==> public final val FunctionDescriptor.visibility: Visibility[MyPropertyDescriptor]

'LOCAL' @ [47:51] ==> @NotNull public final val LOCAL: Visibility defined in org.jetbrains.kotlin.descriptors.Visibilities[JavaPropertyDescriptor]

'diagnosticHolder' @ [48:13] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.LocalFunInlineChecker.check[ValueParameterDescriptorImpl]

'report' @ [48:30] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'NOT_YET_SUPPORTED_IN_INLINE' @ [48:44] ==> public final val NOT_YET_SUPPORTED_IN_INLINE: (DiagnosticFactory2<(KtElement..KtElement?), (KtNamedDeclaration..KtNamedDeclaration?), (DeclarationDescriptor..DeclarationDescriptor?)>..DiagnosticFactory2<(KtElement..KtElement?), (KtNamedDeclaration..KtNamedDeclaration?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [48:72] ==> @NotNull public open fun on(@NotNull p0: KtElement, @NotNull p1: KtNamedDeclaration, @NotNull p2: DeclarationDescriptor): ParametrizedDiagnostic<(KtElement..KtElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'declaration' @ [48:75] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.LocalFunInlineChecker.check[ValueParameterDescriptorImpl]

'declaration' @ [48:88] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.LocalFunInlineChecker.check[ValueParameterDescriptorImpl]

'descriptor' @ [48:101] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.LocalFunInlineChecker.check[ValueParameterDescriptorImpl]

'descriptor' @ [61:13] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.check[ValueParameterDescriptorImpl]

'hasJvmStaticAnnotation' @ [61:24] ==> public fun DeclarationDescriptor.hasJvmStaticAnnotation(): Boolean defined in org.jetbrains.kotlin.resolve.annotations[DeserializedSimpleFunctionDescriptor]

'declaration' @ [62:17] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.check[ValueParameterDescriptorImpl]

'declaration' @ [63:17] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.check[ValueParameterDescriptorImpl]

'declaration' @ [64:17] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.check[ValueParameterDescriptorImpl]

'declaration' @ [65:17] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.check[ValueParameterDescriptorImpl]

'checkDeclaration' @ [66:17] ==> private final fun checkDeclaration(declaration: KtDeclaration, descriptor: DeclarationDescriptor, diagnosticHolder: DiagnosticSink): Unit defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker[SimpleFunctionDescriptorImpl]

'declaration' @ [66:34] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.check[ValueParameterDescriptorImpl]

'descriptor' @ [66:47] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.check[ValueParameterDescriptorImpl]

'diagnosticHolder' @ [66:59] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.check[ValueParameterDescriptorImpl]

'descriptor' @ [76:25] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'containingDeclaration' @ [76:36] ==> public final val DeclarationDescriptor.containingDeclaration: DeclarationDescriptor?[MyPropertyDescriptor]

'container' @ [77:28] ==> val container: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.checkDeclaration[LocalVariableDescriptor]

'isNonCompanionObject' @ [77:65] ==> public open fun isNonCompanionObject(@NotNull p0: DeclarationDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'container' @ [77:86] ==> val container: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.checkDeclaration[LocalVariableDescriptor]

'container' @ [79:17] ==> val container: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.checkDeclaration[LocalVariableDescriptor]

'isCompanionObject' @ [79:54] ==> public open fun isCompanionObject(@Nullable p0: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'container' @ [79:72] ==> val container: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.checkDeclaration[LocalVariableDescriptor]

'isClassOrEnumClass' @ [80:33] ==> public open fun isClassOrEnumClass(@Nullable p0: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'container' @ [80:52] ==> val container: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.checkDeclaration[LocalVariableDescriptor]

'containingDeclaration' @ [80:62] ==> public final val DeclarationDescriptor.containingDeclaration: DeclarationDescriptor?[MyPropertyDescriptor]

'!' @ [82:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'insideObject' @ [82:14] ==> val insideObject: Boolean defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.checkDeclaration[LocalVariableDescriptor]

'!' @ [82:30] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'insideCompanionObjectInClass' @ [82:31] ==> val insideCompanionObjectInClass: Boolean defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.checkDeclaration[LocalVariableDescriptor]

'diagnosticHolder' @ [83:13] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'report' @ [83:30] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'JVM_STATIC_NOT_IN_OBJECT' @ [83:47] ==> public final val JVM_STATIC_NOT_IN_OBJECT: (DiagnosticFactory0<(KtDeclaration..KtDeclaration?)>..DiagnosticFactory0<(KtDeclaration..KtDeclaration?)>?) defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm[JavaPropertyDescriptor]

'on' @ [83:72] ==> @NotNull public open fun on(@NotNull p0: KtDeclaration): SimpleDiagnostic<(KtDeclaration..KtDeclaration?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'declaration' @ [83:75] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'when(declaration) {
            is KtPropertyAccessor -> declaration.getParent() as KtProperty
            else -> declaration
        }' @ [86:32] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KtDeclaration, entry1: KtDeclaration): KtDeclaration[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KtDeclaration

'declaration' @ [86:37] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'declaration' @ [87:38] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'getParent' @ [87:50] ==> @Contract public abstract fun getParent(): (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.psi.KtDeclaration[JavaMethodDescriptor]

'declaration' @ [88:21] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'insideObject' @ [91:13] ==> val insideObject: Boolean defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.checkDeclaration[LocalVariableDescriptor]

'checkDeclaration' @ [91:29] ==> val checkDeclaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.checkDeclaration[LocalVariableDescriptor]

'modifierList' @ [91:46] ==> public final val KtDeclaration.modifierList: KtModifierList?[MyPropertyDescriptor]

'hasModifier' @ [91:60] ==> public open fun hasModifier(@NotNull p0: KtModifierKeywordToken): Boolean defined in org.jetbrains.kotlin.psi.KtModifierList[JavaMethodDescriptor]

'OVERRIDE_KEYWORD' @ [91:81] ==> public final val OVERRIDE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'diagnosticHolder' @ [92:13] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'report' @ [92:30] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'OVERRIDE_CANNOT_BE_STATIC' @ [92:47] ==> public final val OVERRIDE_CANNOT_BE_STATIC: (DiagnosticFactory0<(KtDeclaration..KtDeclaration?)>..DiagnosticFactory0<(KtDeclaration..KtDeclaration?)>?) defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm[JavaPropertyDescriptor]

'on' @ [92:73] ==> @NotNull public open fun on(@NotNull p0: KtDeclaration): SimpleDiagnostic<(KtDeclaration..KtDeclaration?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'declaration' @ [92:76] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'descriptor' @ [95:13] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'descriptor' @ [95:50] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'isConst' @ [95:61] ==> public final val PropertyDescriptor.isConst: Boolean[MyPropertyDescriptor]

'descriptor' @ [95:72] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'hasJvmFieldAnnotation' @ [95:83] ==> public fun DeclarationDescriptor.hasJvmFieldAnnotation(): Boolean defined in org.jetbrains.kotlin.resolve.jvm.annotations in file annotationUtil.kt[SimpleFunctionDescriptorImpl]

'diagnosticHolder' @ [96:13] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'report' @ [96:30] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'JVM_STATIC_ON_CONST_OR_JVM_FIELD' @ [96:47] ==> public final val JVM_STATIC_ON_CONST_OR_JVM_FIELD: (DiagnosticFactory0<(KtDeclaration..KtDeclaration?)>..DiagnosticFactory0<(KtDeclaration..KtDeclaration?)>?) defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm[JavaPropertyDescriptor]

'on' @ [96:80] ==> @NotNull public open fun on(@NotNull p0: KtDeclaration): SimpleDiagnostic<(KtDeclaration..KtDeclaration?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'declaration' @ [96:83] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.PlatformStaticAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'getJvmNameAnnotation' @ [108:54] ==> @Nullable public open fun getJvmNameAnnotation(@NotNull p0: Annotated): AnnotationDescriptor? defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'descriptor' @ [108:75] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker.check[ValueParameterDescriptorImpl]

'platformNameAnnotation' @ [109:13] ==> val platformNameAnnotation: AnnotationDescriptor? defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker.check[LocalVariableDescriptor]

'checkDeclaration' @ [110:13] ==> private final fun checkDeclaration(descriptor: DeclarationDescriptor, annotation: AnnotationDescriptor, diagnosticHolder: DiagnosticSink): Unit defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker[SimpleFunctionDescriptorImpl]

'descriptor' @ [110:30] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker.check[ValueParameterDescriptorImpl]

'platformNameAnnotation' @ [110:42] ==> val platformNameAnnotation: AnnotationDescriptor? defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker.check[LocalVariableDescriptor]

'diagnosticHolder' @ [110:66] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker.check[ValueParameterDescriptorImpl]

'?:' @ [117:31] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtAnnotationEntry?, right: KtAnnotationEntry): KtAnnotationEntry[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtAnnotationEntry

'getSourceFromAnnotation' @ [117:55] ==> @JvmStatic public final fun getSourceFromAnnotation(descriptor: AnnotationDescriptor): KtAnnotationEntry? defined in org.jetbrains.kotlin.resolve.DescriptorToSourceUtils[DeserializedSimpleFunctionDescriptor]

'annotation' @ [117:79] ==> value-parameter annotation: AnnotationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'descriptor' @ [119:13] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'!' @ [119:49] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isRenamableFunction' @ [119:50] ==> private final fun isRenamableFunction(descriptor: FunctionDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker[SimpleFunctionDescriptorImpl]

'descriptor' @ [119:70] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'diagnosticHolder' @ [120:13] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'report' @ [120:30] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'INAPPLICABLE_JVM_NAME' @ [120:47] ==> public final val INAPPLICABLE_JVM_NAME: (DiagnosticFactory0<(PsiElement..PsiElement?)>..DiagnosticFactory0<(PsiElement..PsiElement?)>?) defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm[JavaPropertyDescriptor]

'on' @ [120:69] ==> @NotNull public open fun on(@NotNull p0: PsiElement): SimpleDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'annotationEntry' @ [120:72] ==> val annotationEntry: KtAnnotationEntry defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker.checkDeclaration[LocalVariableDescriptor]

'getJvmName' @ [123:37] ==> @Nullable public open fun getJvmName(@NotNull p0: Annotated): String? defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'descriptor' @ [123:48] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'value' @ [124:13] ==> val value: String? defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker.checkDeclaration[LocalVariableDescriptor]

'!' @ [124:30] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isValidIdentifier' @ [124:36] ==> public open fun isValidIdentifier(@NotNull p0: String): Boolean defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'value' @ [124:54] ==> val value: String? defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker.checkDeclaration[LocalVariableDescriptor]

'diagnosticHolder' @ [125:13] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'report' @ [125:30] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'ILLEGAL_JVM_NAME' @ [125:47] ==> public final val ILLEGAL_JVM_NAME: (DiagnosticFactory0<(KtAnnotationEntry..KtAnnotationEntry?)>..DiagnosticFactory0<(KtAnnotationEntry..KtAnnotationEntry?)>?) defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm[JavaPropertyDescriptor]

'on' @ [125:64] ==> @NotNull public open fun on(@NotNull p0: KtAnnotationEntry): SimpleDiagnostic<(KtAnnotationEntry..KtAnnotationEntry?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'annotationEntry' @ [125:67] ==> val annotationEntry: KtAnnotationEntry defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker.checkDeclaration[LocalVariableDescriptor]

'descriptor' @ [128:13] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'descriptor' @ [129:44] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'isOverride' @ [130:33] ==> public open fun isOverride(@NotNull p0: CallableMemberDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'callableMemberDescriptor' @ [130:44] ==> val callableMemberDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker.checkDeclaration[LocalVariableDescriptor]

'callableMemberDescriptor' @ [130:73] ==> val callableMemberDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker.checkDeclaration[LocalVariableDescriptor]

'isOverridable' @ [130:98] ==> public val CallableMemberDescriptor.isOverridable: Boolean defined in org.jetbrains.kotlin.descriptors[DeserializedPropertyDescriptor]

'diagnosticHolder' @ [131:17] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'report' @ [131:34] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'INAPPLICABLE_JVM_NAME' @ [131:51] ==> public final val INAPPLICABLE_JVM_NAME: (DiagnosticFactory0<(PsiElement..PsiElement?)>..DiagnosticFactory0<(PsiElement..PsiElement?)>?) defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm[JavaPropertyDescriptor]

'on' @ [131:73] ==> @NotNull public open fun on(@NotNull p0: PsiElement): SimpleDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'annotationEntry' @ [131:76] ==> val annotationEntry: KtAnnotationEntry defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker.checkDeclaration[LocalVariableDescriptor]

'descriptor' @ [137:36] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker.isRenamableFunction[ValueParameterDescriptorImpl]

'containingDeclaration' @ [137:47] ==> public final val FunctionDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'containingDescriptor' @ [139:16] ==> val containingDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker.isRenamableFunction[LocalVariableDescriptor]

'containingDescriptor' @ [139:69] ==> val containingDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmNameAnnotationChecker.isRenamableFunction[LocalVariableDescriptor]

'getVolatileAnnotation' @ [150:50] ==> @Nullable public open fun getVolatileAnnotation(@NotNull p0: Annotated): AnnotationDescriptor? defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'descriptor' @ [150:72] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.VolatileAnnotationChecker.check[ValueParameterDescriptorImpl]

'volatileAnnotation' @ [151:13] ==> val volatileAnnotation: AnnotationDescriptor? defined in org.jetbrains.kotlin.resolve.jvm.checkers.VolatileAnnotationChecker.check[LocalVariableDescriptor]

'descriptor' @ [152:17] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.VolatileAnnotationChecker.check[ValueParameterDescriptorImpl]

'!' @ [152:53] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'descriptor' @ [152:54] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.VolatileAnnotationChecker.check[ValueParameterDescriptorImpl]

'isVar' @ [152:65] ==> public final val PropertyDescriptor.isVar: Boolean[MyPropertyDescriptor]

'?:' @ [153:39] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtAnnotationEntry?, right: KtAnnotationEntry): KtAnnotationEntry[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtAnnotationEntry

'getSourceFromAnnotation' @ [153:63] ==> @JvmStatic public final fun getSourceFromAnnotation(descriptor: AnnotationDescriptor): KtAnnotationEntry? defined in org.jetbrains.kotlin.resolve.DescriptorToSourceUtils[DeserializedSimpleFunctionDescriptor]

'volatileAnnotation' @ [153:87] ==> val volatileAnnotation: AnnotationDescriptor? defined in org.jetbrains.kotlin.resolve.jvm.checkers.VolatileAnnotationChecker.check[LocalVariableDescriptor]

'diagnosticHolder' @ [154:17] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.VolatileAnnotationChecker.check[ValueParameterDescriptorImpl]

'report' @ [154:34] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'VOLATILE_ON_VALUE' @ [154:51] ==> public final val VOLATILE_ON_VALUE: (DiagnosticFactory0<(KtAnnotationEntry..KtAnnotationEntry?)>..DiagnosticFactory0<(KtAnnotationEntry..KtAnnotationEntry?)>?) defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm[JavaPropertyDescriptor]

'on' @ [154:69] ==> @NotNull public open fun on(@NotNull p0: KtAnnotationEntry): SimpleDiagnostic<(KtAnnotationEntry..KtAnnotationEntry?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'annotationEntry' @ [154:72] ==> val annotationEntry: KtAnnotationEntry defined in org.jetbrains.kotlin.resolve.jvm.checkers.VolatileAnnotationChecker.check[LocalVariableDescriptor]

'declaration' @ [156:17] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.VolatileAnnotationChecker.check[ValueParameterDescriptorImpl]

'declaration' @ [156:46] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.VolatileAnnotationChecker.check[ValueParameterDescriptorImpl]

'hasDelegate' @ [156:58] ==> public open fun hasDelegate(): Boolean defined in org.jetbrains.kotlin.psi.KtProperty[JavaMethodDescriptor]

'?:' @ [157:39] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtAnnotationEntry?, right: KtAnnotationEntry): KtAnnotationEntry[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtAnnotationEntry

'getSourceFromAnnotation' @ [157:63] ==> @JvmStatic public final fun getSourceFromAnnotation(descriptor: AnnotationDescriptor): KtAnnotationEntry? defined in org.jetbrains.kotlin.resolve.DescriptorToSourceUtils[DeserializedSimpleFunctionDescriptor]

'volatileAnnotation' @ [157:87] ==> val volatileAnnotation: AnnotationDescriptor? defined in org.jetbrains.kotlin.resolve.jvm.checkers.VolatileAnnotationChecker.check[LocalVariableDescriptor]

'diagnosticHolder' @ [158:17] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.VolatileAnnotationChecker.check[ValueParameterDescriptorImpl]

'report' @ [158:34] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'VOLATILE_ON_DELEGATE' @ [158:51] ==> public final val VOLATILE_ON_DELEGATE: (DiagnosticFactory0<(KtAnnotationEntry..KtAnnotationEntry?)>..DiagnosticFactory0<(KtAnnotationEntry..KtAnnotationEntry?)>?) defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm[JavaPropertyDescriptor]

'on' @ [158:72] ==> @NotNull public open fun on(@NotNull p0: KtAnnotationEntry): SimpleDiagnostic<(KtAnnotationEntry..KtAnnotationEntry?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'annotationEntry' @ [158:75] ==> val annotationEntry: KtAnnotationEntry defined in org.jetbrains.kotlin.resolve.jvm.checkers.VolatileAnnotationChecker.check[LocalVariableDescriptor]

'getSynchronizedAnnotation' @ [171:54] ==> @Nullable public open fun getSynchronizedAnnotation(@NotNull p0: Annotated): AnnotationDescriptor? defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'descriptor' @ [171:80] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.SynchronizedAnnotationChecker.check[ValueParameterDescriptorImpl]

'synchronizedAnnotation' @ [172:13] ==> val synchronizedAnnotation: AnnotationDescriptor? defined in org.jetbrains.kotlin.resolve.jvm.checkers.SynchronizedAnnotationChecker.check[LocalVariableDescriptor]

'descriptor' @ [172:47] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.SynchronizedAnnotationChecker.check[ValueParameterDescriptorImpl]

'descriptor' @ [172:83] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.SynchronizedAnnotationChecker.check[ValueParameterDescriptorImpl]

'modality' @ [172:94] ==> public final val FunctionDescriptor.modality: Modality[MyPropertyDescriptor]

'ABSTRACT' @ [172:115] ==> enum entry ABSTRACT defined in org.jetbrains.kotlin.descriptors.Modality[FakeCallableDescriptorForObject]

'?:' @ [173:35] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtAnnotationEntry?, right: KtAnnotationEntry): KtAnnotationEntry[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtAnnotationEntry

'getSourceFromAnnotation' @ [173:59] ==> @JvmStatic public final fun getSourceFromAnnotation(descriptor: AnnotationDescriptor): KtAnnotationEntry? defined in org.jetbrains.kotlin.resolve.DescriptorToSourceUtils[DeserializedSimpleFunctionDescriptor]

'synchronizedAnnotation' @ [173:83] ==> val synchronizedAnnotation: AnnotationDescriptor? defined in org.jetbrains.kotlin.resolve.jvm.checkers.SynchronizedAnnotationChecker.check[LocalVariableDescriptor]

'diagnosticHolder' @ [174:13] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.SynchronizedAnnotationChecker.check[ValueParameterDescriptorImpl]

'report' @ [174:30] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'SYNCHRONIZED_ON_ABSTRACT' @ [174:47] ==> public final val SYNCHRONIZED_ON_ABSTRACT: (DiagnosticFactory0<(KtAnnotationEntry..KtAnnotationEntry?)>..DiagnosticFactory0<(KtAnnotationEntry..KtAnnotationEntry?)>?) defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm[JavaPropertyDescriptor]

'on' @ [174:72] ==> @NotNull public open fun on(@NotNull p0: KtAnnotationEntry): SimpleDiagnostic<(KtAnnotationEntry..KtAnnotationEntry?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'annotationEntry' @ [174:75] ==> val annotationEntry: KtAnnotationEntry defined in org.jetbrains.kotlin.resolve.jvm.checkers.SynchronizedAnnotationChecker.check[LocalVariableDescriptor]

'descriptor' @ [186:9] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.check[ValueParameterDescriptorImpl]

'findJvmOverloadsAnnotation' @ [186:20] ==> public fun DeclarationDescriptor.findJvmOverloadsAnnotation(): AnnotationDescriptor? defined in org.jetbrains.kotlin.resolve.jvm.annotations in file annotationUtil.kt[SimpleFunctionDescriptorImpl]

'let' @ [186:50] ==> @InlineOnly public inline fun <T, R> AnnotationDescriptor.let(block: (AnnotationDescriptor) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> AnnotationDescriptor
    <R> -> Unit

'DescriptorToSourceUtils' @ [187:35] ==> public object DescriptorToSourceUtils defined in org.jetbrains.kotlin.resolve[FakeCallableDescriptorForObject]

'getSourceFromAnnotation' @ [187:59] ==> @JvmStatic public final fun getSourceFromAnnotation(descriptor: AnnotationDescriptor): KtAnnotationEntry? defined in org.jetbrains.kotlin.resolve.DescriptorToSourceUtils[DeserializedSimpleFunctionDescriptor]

'annotation' @ [187:83] ==> value-parameter annotation: AnnotationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.check.<anonymous>[ValueParameterDescriptorImpl]

'annotationEntry' @ [188:17] ==> val annotationEntry: KtAnnotationEntry? defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.check.<anonymous>[LocalVariableDescriptor]

'checkDeclaration' @ [189:17] ==> private final fun checkDeclaration(annotationEntry: KtAnnotationEntry, descriptor: DeclarationDescriptor, diagnosticHolder: DiagnosticSink): Unit defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker[SimpleFunctionDescriptorImpl]

'annotationEntry' @ [189:34] ==> val annotationEntry: KtAnnotationEntry? defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.check.<anonymous>[LocalVariableDescriptor]

'descriptor' @ [189:51] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.check[ValueParameterDescriptorImpl]

'diagnosticHolder' @ [189:63] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.check[ValueParameterDescriptorImpl]

'descriptor' @ [195:13] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'if ((descriptor.containingDeclaration as? ClassDescriptor)?.kind == ClassKind.INTERFACE) {
            diagnosticHolder.report(ErrorsJvm.OVERLOADS_INTERFACE.on(annotationEntry))
        }
        else if (descriptor is FunctionDescriptor && descriptor.modality == Modality.ABSTRACT) {
            diagnosticHolder.report(ErrorsJvm.OVERLOADS_ABSTRACT.on(annotationEntry))
        }
        else if (DescriptorUtils.isLocal(descriptor)) {
            diagnosticHolder.report(ErrorsJvm.OVERLOADS_LOCAL.on(annotationEntry))
        }
        else if (!descriptor.visibility.isPublicAPI && descriptor.visibility != Visibilities.INTERNAL) {
            diagnosticHolder.report(ErrorsJvm.OVERLOADS_PRIVATE.on(annotationEntry))
        }
        else if (descriptor.valueParameters.none { it.declaresDefaultValue() }) {
            diagnosticHolder.report(ErrorsJvm.OVERLOADS_WITHOUT_DEFAULT_ARGUMENTS.on(annotationEntry))
        }' @ [198:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'==' @ [198:13] ==> public final fun equals(other: Any?): Boolean defined in org.jetbrains.kotlin.descriptors.ClassKind[DeserializedSimpleFunctionDescriptor]

'descriptor' @ [198:14] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'containingDeclaration' @ [198:25] ==> public final val CallableDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'kind' @ [198:69] ==> public final val ClassDescriptor.kind: ClassKind[MyPropertyDescriptor]

'INTERFACE' @ [198:87] ==> enum entry INTERFACE defined in org.jetbrains.kotlin.descriptors.ClassKind[FakeCallableDescriptorForObject]

'diagnosticHolder' @ [199:13] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'report' @ [199:30] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'OVERLOADS_INTERFACE' @ [199:47] ==> public final val OVERLOADS_INTERFACE: (DiagnosticFactory0<(KtAnnotationEntry..KtAnnotationEntry?)>..DiagnosticFactory0<(KtAnnotationEntry..KtAnnotationEntry?)>?) defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm[JavaPropertyDescriptor]

'on' @ [199:67] ==> @NotNull public open fun on(@NotNull p0: KtAnnotationEntry): SimpleDiagnostic<(KtAnnotationEntry..KtAnnotationEntry?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'annotationEntry' @ [199:70] ==> value-parameter annotationEntry: KtAnnotationEntry defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'if (descriptor is FunctionDescriptor && descriptor.modality == Modality.ABSTRACT) {
            diagnosticHolder.report(ErrorsJvm.OVERLOADS_ABSTRACT.on(annotationEntry))
        }
        else if (DescriptorUtils.isLocal(descriptor)) {
            diagnosticHolder.report(ErrorsJvm.OVERLOADS_LOCAL.on(annotationEntry))
        }
        else if (!descriptor.visibility.isPublicAPI && descriptor.visibility != Visibilities.INTERNAL) {
            diagnosticHolder.report(ErrorsJvm.OVERLOADS_PRIVATE.on(annotationEntry))
        }
        else if (descriptor.valueParameters.none { it.declaresDefaultValue() }) {
            diagnosticHolder.report(ErrorsJvm.OVERLOADS_WITHOUT_DEFAULT_ARGUMENTS.on(annotationEntry))
        }' @ [201:14] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'descriptor' @ [201:18] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'descriptor' @ [201:54] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'modality' @ [201:65] ==> public final val FunctionDescriptor.modality: Modality[MyPropertyDescriptor]

'ABSTRACT' @ [201:86] ==> enum entry ABSTRACT defined in org.jetbrains.kotlin.descriptors.Modality[FakeCallableDescriptorForObject]

'diagnosticHolder' @ [202:13] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'report' @ [202:30] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'OVERLOADS_ABSTRACT' @ [202:47] ==> public final val OVERLOADS_ABSTRACT: (DiagnosticFactory0<(KtAnnotationEntry..KtAnnotationEntry?)>..DiagnosticFactory0<(KtAnnotationEntry..KtAnnotationEntry?)>?) defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm[JavaPropertyDescriptor]

'on' @ [202:66] ==> @NotNull public open fun on(@NotNull p0: KtAnnotationEntry): SimpleDiagnostic<(KtAnnotationEntry..KtAnnotationEntry?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'annotationEntry' @ [202:69] ==> value-parameter annotationEntry: KtAnnotationEntry defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'if (DescriptorUtils.isLocal(descriptor)) {
            diagnosticHolder.report(ErrorsJvm.OVERLOADS_LOCAL.on(annotationEntry))
        }
        else if (!descriptor.visibility.isPublicAPI && descriptor.visibility != Visibilities.INTERNAL) {
            diagnosticHolder.report(ErrorsJvm.OVERLOADS_PRIVATE.on(annotationEntry))
        }
        else if (descriptor.valueParameters.none { it.declaresDefaultValue() }) {
            diagnosticHolder.report(ErrorsJvm.OVERLOADS_WITHOUT_DEFAULT_ARGUMENTS.on(annotationEntry))
        }' @ [204:14] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'isLocal' @ [204:34] ==> public open fun isLocal(@NotNull p0: DeclarationDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'descriptor' @ [204:42] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'diagnosticHolder' @ [205:13] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'report' @ [205:30] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'OVERLOADS_LOCAL' @ [205:47] ==> public final val OVERLOADS_LOCAL: (DiagnosticFactory0<(KtAnnotationEntry..KtAnnotationEntry?)>..DiagnosticFactory0<(KtAnnotationEntry..KtAnnotationEntry?)>?) defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm[JavaPropertyDescriptor]

'on' @ [205:63] ==> @NotNull public open fun on(@NotNull p0: KtAnnotationEntry): SimpleDiagnostic<(KtAnnotationEntry..KtAnnotationEntry?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'annotationEntry' @ [205:66] ==> value-parameter annotationEntry: KtAnnotationEntry defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'if (!descriptor.visibility.isPublicAPI && descriptor.visibility != Visibilities.INTERNAL) {
            diagnosticHolder.report(ErrorsJvm.OVERLOADS_PRIVATE.on(annotationEntry))
        }
        else if (descriptor.valueParameters.none { it.declaresDefaultValue() }) {
            diagnosticHolder.report(ErrorsJvm.OVERLOADS_WITHOUT_DEFAULT_ARGUMENTS.on(annotationEntry))
        }' @ [207:14] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'!' @ [207:18] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'descriptor' @ [207:19] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'visibility' @ [207:30] ==> public final val CallableDescriptor.visibility: Visibility[MyPropertyDescriptor]

'isPublicAPI' @ [207:41] ==> public final val isPublicAPI: Boolean defined in org.jetbrains.kotlin.descriptors.Visibility[DeserializedPropertyDescriptor]

'descriptor' @ [207:56] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'visibility' @ [207:67] ==> public final val CallableDescriptor.visibility: Visibility[MyPropertyDescriptor]

'INTERNAL' @ [207:94] ==> @NotNull public final val INTERNAL: Visibility defined in org.jetbrains.kotlin.descriptors.Visibilities[JavaPropertyDescriptor]

'diagnosticHolder' @ [208:13] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'report' @ [208:30] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'OVERLOADS_PRIVATE' @ [208:47] ==> public final val OVERLOADS_PRIVATE: (DiagnosticFactory0<(KtAnnotationEntry..KtAnnotationEntry?)>..DiagnosticFactory0<(KtAnnotationEntry..KtAnnotationEntry?)>?) defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm[JavaPropertyDescriptor]

'on' @ [208:65] ==> @NotNull public open fun on(@NotNull p0: KtAnnotationEntry): SimpleDiagnostic<(KtAnnotationEntry..KtAnnotationEntry?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'annotationEntry' @ [208:68] ==> value-parameter annotationEntry: KtAnnotationEntry defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'descriptor' @ [210:18] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'valueParameters' @ [210:29] ==> public final val CallableDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'none' @ [210:45] ==> public inline fun <T> Iterable<(ValueParameterDescriptor..ValueParameterDescriptor?)>.none(predicate: ((ValueParameterDescriptor..ValueParameterDescriptor?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)

'it' @ [210:52] ==> value-parameter it: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.checkDeclaration.<anonymous>[ValueParameterDescriptorImpl]

'declaresDefaultValue' @ [210:55] ==> public abstract fun declaresDefaultValue(): Boolean defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedSimpleFunctionDescriptor]

'diagnosticHolder' @ [211:13] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'report' @ [211:30] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'OVERLOADS_WITHOUT_DEFAULT_ARGUMENTS' @ [211:47] ==> public final val OVERLOADS_WITHOUT_DEFAULT_ARGUMENTS: (DiagnosticFactory0<(KtAnnotationEntry..KtAnnotationEntry?)>..DiagnosticFactory0<(KtAnnotationEntry..KtAnnotationEntry?)>?) defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm[JavaPropertyDescriptor]

'on' @ [211:83] ==> @NotNull public open fun on(@NotNull p0: KtAnnotationEntry): SimpleDiagnostic<(KtAnnotationEntry..KtAnnotationEntry?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'annotationEntry' @ [211:86] ==> value-parameter annotationEntry: KtAnnotationEntry defined in org.jetbrains.kotlin.resolve.jvm.checkers.OverloadsAnnotationChecker.checkDeclaration[ValueParameterDescriptorImpl]

'?:' @ [223:30] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>?, right: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>?): List<(TypeParameterDescriptor..TypeParameterDescriptor?)>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> List<(org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)>?

'descriptor' @ [223:31] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.TypeParameterBoundIsNotArrayChecker.check[ValueParameterDescriptorImpl]

'typeParameters' @ [223:67] ==> public final val CallableDescriptor.typeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'descriptor' @ [224:34] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.TypeParameterBoundIsNotArrayChecker.check[ValueParameterDescriptorImpl]

'declaredTypeParameters' @ [224:67] ==> public final val ClassDescriptor.declaredTypeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'typeParameters' @ [227:31] ==> val typeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.resolve.jvm.checkers.TypeParameterBoundIsNotArrayChecker.check[LocalVariableDescriptor]

'typeParameter' @ [228:17] ==> val typeParameter: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.resolve.jvm.checkers.TypeParameterBoundIsNotArrayChecker.check[LocalVariableDescriptor]

'upperBounds' @ [228:31] ==> public final val TypeParameterDescriptor.upperBounds: (MutableList<(KotlinType..KotlinType?)>..List<(KotlinType..KotlinType?)>)[MyPropertyDescriptor]

'any' @ [228:43] ==> public inline fun <T> Iterable<(KotlinType..KotlinType?)>.any(predicate: ((KotlinType..KotlinType?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)

'isArray' @ [228:64] ==> public open fun isArray(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'it' @ [228:72] ==> value-parameter it: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.resolve.jvm.checkers.TypeParameterBoundIsNotArrayChecker.check.<anonymous>[ValueParameterDescriptorImpl]

'isPrimitiveArray' @ [228:94] ==> public open fun isPrimitiveArray(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'it' @ [228:111] ==> value-parameter it: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.resolve.jvm.checkers.TypeParameterBoundIsNotArrayChecker.check.<anonymous>[ValueParameterDescriptorImpl]

'?:' @ [229:31] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: PsiElement?, right: PsiElement): PsiElement[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> PsiElement

'descriptorToDeclaration' @ [229:55] ==> @JvmStatic public final fun descriptorToDeclaration(descriptor: DeclarationDescriptor): PsiElement? defined in org.jetbrains.kotlin.resolve.DescriptorToSourceUtils[DeserializedSimpleFunctionDescriptor]

'typeParameter' @ [229:79] ==> val typeParameter: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.resolve.jvm.checkers.TypeParameterBoundIsNotArrayChecker.check[LocalVariableDescriptor]

'declaration' @ [229:97] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.TypeParameterBoundIsNotArrayChecker.check[ValueParameterDescriptorImpl]

'diagnosticHolder' @ [230:17] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.TypeParameterBoundIsNotArrayChecker.check[ValueParameterDescriptorImpl]

'report' @ [230:34] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'UPPER_BOUND_CANNOT_BE_ARRAY' @ [230:51] ==> public final val UPPER_BOUND_CANNOT_BE_ARRAY: (DiagnosticFactory0<(PsiElement..PsiElement?)>..DiagnosticFactory0<(PsiElement..PsiElement?)>?) defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm[JavaPropertyDescriptor]

'on' @ [230:79] ==> @NotNull public open fun on(@NotNull p0: PsiElement): SimpleDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'element' @ [230:82] ==> val element: PsiElement defined in org.jetbrains.kotlin.resolve.jvm.checkers.TypeParameterBoundIsNotArrayChecker.check[LocalVariableDescriptor]

