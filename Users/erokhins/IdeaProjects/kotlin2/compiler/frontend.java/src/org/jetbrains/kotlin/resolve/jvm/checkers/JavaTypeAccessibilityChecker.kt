'c' @ [42:13] ==> value-parameter c: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.checkType[ValueParameterDescriptorImpl]

'isDebuggerContext' @ [42:15] ==> public final val isDebuggerContext: Boolean defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'findInaccessibleJavaClasses' @ [44:35] ==> private final fun findInaccessibleJavaClasses(type: KotlinType, c: ResolutionContext<*>): Collection<ClassDescriptor> defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker[SimpleFunctionDescriptorImpl]

'expressionType' @ [44:63] ==> value-parameter expressionType: KotlinType defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.checkType[ValueParameterDescriptorImpl]

'c' @ [44:79] ==> value-parameter c: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.checkType[ValueParameterDescriptorImpl]

'inaccessibleClasses' @ [45:13] ==> val inaccessibleClasses: Collection<ClassDescriptor> defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.checkType[LocalVariableDescriptor]

'isNotEmpty' @ [45:33] ==> @InlineOnly public inline fun <T> Collection<ClassDescriptor>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ClassDescriptor

'c' @ [46:13] ==> value-parameter c: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.checkType[ValueParameterDescriptorImpl]

'trace' @ [46:15] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'report' @ [46:21] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'INACCESSIBLE_TYPE' @ [46:35] ==> public final val INACCESSIBLE_TYPE: (DiagnosticFactory2<(KtExpression..KtExpression?), (KotlinType..KotlinType?), (MutableCollection<(ClassDescriptor..ClassDescriptor?)>..Collection<(ClassDescriptor..ClassDescriptor?)>?)>..DiagnosticFactory2<(KtExpression..KtExpression?), (KotlinType..KotlinType?), (MutableCollection<(ClassDescriptor..ClassDescriptor?)>..Collection<(ClassDescriptor..ClassDescriptor?)>?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [46:53] ==> @NotNull public open fun on(@NotNull p0: KtExpression, @NotNull p1: KotlinType, @NotNull p2: (MutableCollection<(ClassDescriptor..ClassDescriptor?)>..Collection<(ClassDescriptor..ClassDescriptor?)>)): ParametrizedDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'expression' @ [46:56] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.checkType[ValueParameterDescriptorImpl]

'expressionType' @ [46:68] ==> value-parameter expressionType: KotlinType defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.checkType[ValueParameterDescriptorImpl]

'inaccessibleClasses' @ [46:84] ==> val inaccessibleClasses: Collection<ClassDescriptor> defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.checkType[LocalVariableDescriptor]

'expressionTypeWithSmartCast' @ [50:13] ==> value-parameter expressionTypeWithSmartCast: KotlinType defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.checkType[ValueParameterDescriptorImpl]

'expressionType' @ [50:44] ==> value-parameter expressionType: KotlinType defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.checkType[ValueParameterDescriptorImpl]

'findInaccessibleJavaClasses' @ [51:52] ==> private final fun findInaccessibleJavaClasses(type: KotlinType, c: ResolutionContext<*>): Collection<ClassDescriptor> defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker[SimpleFunctionDescriptorImpl]

'expressionTypeWithSmartCast' @ [51:80] ==> value-parameter expressionTypeWithSmartCast: KotlinType defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.checkType[ValueParameterDescriptorImpl]

'c' @ [51:109] ==> value-parameter c: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.checkType[ValueParameterDescriptorImpl]

'inaccessibleClassesWithSmartCast' @ [52:17] ==> val inaccessibleClassesWithSmartCast: Collection<ClassDescriptor> defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.checkType[LocalVariableDescriptor]

'isNotEmpty' @ [52:50] ==> @InlineOnly public inline fun <T> Collection<ClassDescriptor>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ClassDescriptor

'c' @ [53:17] ==> value-parameter c: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.checkType[ValueParameterDescriptorImpl]

'trace' @ [53:19] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'report' @ [53:25] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'INACCESSIBLE_TYPE' @ [53:39] ==> public final val INACCESSIBLE_TYPE: (DiagnosticFactory2<(KtExpression..KtExpression?), (KotlinType..KotlinType?), (MutableCollection<(ClassDescriptor..ClassDescriptor?)>..Collection<(ClassDescriptor..ClassDescriptor?)>?)>..DiagnosticFactory2<(KtExpression..KtExpression?), (KotlinType..KotlinType?), (MutableCollection<(ClassDescriptor..ClassDescriptor?)>..Collection<(ClassDescriptor..ClassDescriptor?)>?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [53:57] ==> @NotNull public open fun on(@NotNull p0: KtExpression, @NotNull p1: KotlinType, @NotNull p2: (MutableCollection<(ClassDescriptor..ClassDescriptor?)>..Collection<(ClassDescriptor..ClassDescriptor?)>)): ParametrizedDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'expression' @ [53:60] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.checkType[ValueParameterDescriptorImpl]

'expressionType' @ [53:72] ==> value-parameter expressionType: KotlinType defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.checkType[ValueParameterDescriptorImpl]

'inaccessibleClassesWithSmartCast' @ [53:88] ==> val inaccessibleClassesWithSmartCast: Collection<ClassDescriptor> defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.checkType[LocalVariableDescriptor]

'c' @ [59:26] ==> value-parameter c: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.findInaccessibleJavaClasses[ValueParameterDescriptorImpl]

'scope' @ [59:28] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'ownerDescriptor' @ [59:34] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'LinkedHashSet' @ [60:39] ==> public final fun <E> <init>(): LinkedHashSet<ClassDescriptor> /* = LinkedHashSet<ClassDescriptor> */ defined in kotlin.collections.LinkedHashSet[TypeAliasConstructorDescriptorImpl]
Inferred types:
    <E> -> ClassDescriptor

'findInaccessibleJavaClassesRec' @ [61:9] ==> private final fun findInaccessibleJavaClassesRec(type: KotlinType, scopeOwner: DeclarationDescriptor, inaccessibleClasses: MutableCollection<ClassDescriptor>): Unit defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker[SimpleFunctionDescriptorImpl]

'type' @ [61:40] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.findInaccessibleJavaClasses[ValueParameterDescriptorImpl]

'scopeOwner' @ [61:46] ==> val scopeOwner: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.findInaccessibleJavaClasses[LocalVariableDescriptor]

'inaccessibleJavaClasses' @ [61:58] ==> val inaccessibleJavaClasses: LinkedHashSet<ClassDescriptor> /* = LinkedHashSet<ClassDescriptor> */ defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.findInaccessibleJavaClasses[LocalVariableDescriptor]

'inaccessibleJavaClasses' @ [62:16] ==> val inaccessibleJavaClasses: LinkedHashSet<ClassDescriptor> /* = LinkedHashSet<ClassDescriptor> */ defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.findInaccessibleJavaClasses[LocalVariableDescriptor]

'type' @ [70:37] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.findInaccessibleJavaClassesRec[ValueParameterDescriptorImpl]

'constructor' @ [70:42] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'declarationDescriptor' @ [70:54] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'declarationDescriptor' @ [72:13] ==> val declarationDescriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.findInaccessibleJavaClassesRec[LocalVariableDescriptor]

'!' @ [73:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isVisibleIgnoringReceiver' @ [73:31] ==> public open fun isVisibleIgnoringReceiver(@NotNull p0: DeclarationDescriptorWithVisibility, @NotNull p1: DeclarationDescriptor): Boolean defined in org.jetbrains.kotlin.descriptors.Visibilities[JavaMethodDescriptor]

'declarationDescriptor' @ [73:57] ==> val declarationDescriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.findInaccessibleJavaClassesRec[LocalVariableDescriptor]

'scopeOwner' @ [73:80] ==> value-parameter scopeOwner: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.findInaccessibleJavaClassesRec[ValueParameterDescriptorImpl]

'inaccessibleClasses' @ [74:17] ==> value-parameter inaccessibleClasses: MutableCollection<ClassDescriptor> defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.findInaccessibleJavaClassesRec[ValueParameterDescriptorImpl]

'add' @ [74:37] ==> public abstract fun add(element: ClassDescriptor): Boolean defined in kotlin.collections.MutableCollection[DeserializedSimpleFunctionDescriptor]

'declarationDescriptor' @ [74:41] ==> val declarationDescriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.findInaccessibleJavaClassesRec[LocalVariableDescriptor]

'type' @ [78:32] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.findInaccessibleJavaClassesRec[ValueParameterDescriptorImpl]

'arguments' @ [78:37] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'typeProjection' @ [79:17] ==> val typeProjection: TypeProjection defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.findInaccessibleJavaClassesRec[LocalVariableDescriptor]

'isStarProjection' @ [79:32] ==> public final val TypeProjection.isStarProjection: Boolean[MyPropertyDescriptor]

'findInaccessibleJavaClassesRec' @ [80:13] ==> private final fun findInaccessibleJavaClassesRec(type: KotlinType, scopeOwner: DeclarationDescriptor, inaccessibleClasses: MutableCollection<ClassDescriptor>): Unit defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker[SimpleFunctionDescriptorImpl]

'typeProjection' @ [80:44] ==> val typeProjection: TypeProjection defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.findInaccessibleJavaClassesRec[LocalVariableDescriptor]

'type' @ [80:59] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'scopeOwner' @ [80:65] ==> value-parameter scopeOwner: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.findInaccessibleJavaClassesRec[ValueParameterDescriptorImpl]

'inaccessibleClasses' @ [80:77] ==> value-parameter inaccessibleClasses: MutableCollection<ClassDescriptor> defined in org.jetbrains.kotlin.resolve.jvm.checkers.JavaTypeAccessibilityChecker.findInaccessibleJavaClassesRec[ValueParameterDescriptorImpl]

