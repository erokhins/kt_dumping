'setOf' @ [27:25] ==> public fun <T> setOf(vararg elements: Char): Set<Char> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Char

'identifier' @ [30:13] ==> value-parameter identifier: PsiElement? defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkIdentifier[ValueParameterDescriptorImpl]

'reportIfNeeded' @ [32:9] ==> private final fun reportIfNeeded(name: String, element: PsiElement, diagnosticHolder: DiagnosticSink): Unit defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker[SimpleFunctionDescriptorImpl]

'identifier' @ [32:24] ==> value-parameter identifier: PsiElement? defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkIdentifier[ValueParameterDescriptorImpl]

'text' @ [32:35] ==> public final val PsiElement.text: (String..String?)[MyPropertyDescriptor]

'identifier' @ [32:41] ==> value-parameter identifier: PsiElement? defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkIdentifier[ValueParameterDescriptorImpl]

'diagnosticHolder' @ [32:53] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkIdentifier[ValueParameterDescriptorImpl]

'declaration' @ [36:13] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkDeclaration[ValueParameterDescriptorImpl]

'declaration' @ [37:13] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkDeclaration[ValueParameterDescriptorImpl]

'entries' @ [37:25] ==> public final val KtDestructuringDeclaration.entries: (MutableList<(KtDestructuringDeclarationEntry..KtDestructuringDeclarationEntry?)>..List<(KtDestructuringDeclarationEntry..KtDestructuringDeclarationEntry?)>)[MyPropertyDescriptor]

'forEach' @ [37:33] ==> @HidesMembers public inline fun <T> Iterable<(KtDestructuringDeclarationEntry..KtDestructuringDeclarationEntry?)>.forEach(action: ((KtDestructuringDeclarationEntry..KtDestructuringDeclarationEntry?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtDestructuringDeclarationEntry..org.jetbrains.kotlin.psi.KtDestructuringDeclarationEntry?)

'checkNamed' @ [37:43] ==> private final fun checkNamed(declaration: KtNamedDeclaration, diagnosticHolder: DiagnosticSink): Unit defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker[SimpleFunctionDescriptorImpl]

'it' @ [37:54] ==> value-parameter it: (KtDestructuringDeclarationEntry..KtDestructuringDeclarationEntry?) defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkDeclaration.<anonymous>[ValueParameterDescriptorImpl]

'diagnosticHolder' @ [37:58] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkDeclaration[ValueParameterDescriptorImpl]

'declaration' @ [39:13] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkDeclaration[ValueParameterDescriptorImpl]

'declaration' @ [40:13] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkDeclaration[ValueParameterDescriptorImpl]

'valueParameters' @ [40:25] ==> public final val KtCallableDeclaration.valueParameters: (MutableList<(KtParameter..KtParameter?)>..List<(KtParameter..KtParameter?)>)[MyPropertyDescriptor]

'forEach' @ [40:41] ==> @HidesMembers public inline fun <T> Iterable<(KtParameter..KtParameter?)>.forEach(action: ((KtParameter..KtParameter?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtParameter..org.jetbrains.kotlin.psi.KtParameter?)

'checkNamed' @ [40:51] ==> private final fun checkNamed(declaration: KtNamedDeclaration, diagnosticHolder: DiagnosticSink): Unit defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker[SimpleFunctionDescriptorImpl]

'it' @ [40:62] ==> value-parameter it: (KtParameter..KtParameter?) defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkDeclaration.<anonymous>[ValueParameterDescriptorImpl]

'diagnosticHolder' @ [40:66] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkDeclaration[ValueParameterDescriptorImpl]

'declaration' @ [42:13] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkDeclaration[ValueParameterDescriptorImpl]

'declaration' @ [43:13] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkDeclaration[ValueParameterDescriptorImpl]

'typeParameters' @ [43:25] ==> public final val KtTypeParameterListOwner.typeParameters: (MutableList<(KtTypeParameter..KtTypeParameter?)>..List<(KtTypeParameter..KtTypeParameter?)>)[MyPropertyDescriptor]

'forEach' @ [43:40] ==> @HidesMembers public inline fun <T> Iterable<(KtTypeParameter..KtTypeParameter?)>.forEach(action: ((KtTypeParameter..KtTypeParameter?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtTypeParameter..org.jetbrains.kotlin.psi.KtTypeParameter?)

'checkNamed' @ [43:50] ==> private final fun checkNamed(declaration: KtNamedDeclaration, diagnosticHolder: DiagnosticSink): Unit defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker[SimpleFunctionDescriptorImpl]

'it' @ [43:61] ==> value-parameter it: (KtTypeParameter..KtTypeParameter?) defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkDeclaration.<anonymous>[ValueParameterDescriptorImpl]

'diagnosticHolder' @ [43:65] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkDeclaration[ValueParameterDescriptorImpl]

'declaration' @ [45:13] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkDeclaration[ValueParameterDescriptorImpl]

'checkNamed' @ [46:13] ==> private final fun checkNamed(declaration: KtNamedDeclaration, diagnosticHolder: DiagnosticSink): Unit defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker[SimpleFunctionDescriptorImpl]

'declaration' @ [46:24] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkDeclaration[ValueParameterDescriptorImpl]

'diagnosticHolder' @ [46:37] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkDeclaration[ValueParameterDescriptorImpl]

'declaration' @ [51:20] ==> value-parameter declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkNamed[ValueParameterDescriptorImpl]

'name' @ [51:32] ==> public final val KtNamedDeclaration.name: String?[MyPropertyDescriptor]

'declaration' @ [53:23] ==> value-parameter declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkNamed[ValueParameterDescriptorImpl]

'nameIdentifier' @ [53:35] ==> public final val KtNamedDeclaration.nameIdentifier: PsiElement?[MyPropertyDescriptor]

'declaration' @ [53:53] ==> value-parameter declaration: KtNamedDeclaration defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkNamed[ValueParameterDescriptorImpl]

'reportIfNeeded' @ [54:9] ==> private final fun reportIfNeeded(name: String, element: PsiElement, diagnosticHolder: DiagnosticSink): Unit defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker[SimpleFunctionDescriptorImpl]

'name' @ [54:24] ==> val name: String defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkNamed[LocalVariableDescriptor]

'element' @ [54:30] ==> val element: PsiElement defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkNamed[LocalVariableDescriptor]

'diagnosticHolder' @ [54:39] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.checkNamed[ValueParameterDescriptorImpl]

'unquoteIdentifier' @ [58:30] ==> @NotNull public open fun unquoteIdentifier(@NotNull p0: String): String defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'name' @ [58:48] ==> value-parameter name: String defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.reportIfNeeded[ValueParameterDescriptorImpl]

'if (text.isEmpty()) {
            diagnosticHolder.report(Errors.INVALID_CHARACTERS.on(element, "should not be empty"))
        }
        else if (text.any { it in CHARS }) {
            diagnosticHolder.report(Errors.INVALID_CHARACTERS.on(element, "contains illegal characters: ${CHARS.intersect(text.toSet()).joinToString("")}"))
        }' @ [59:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'text' @ [59:13] ==> val text: String defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.reportIfNeeded[LocalVariableDescriptor]

'isEmpty' @ [59:18] ==> @InlineOnly public inline fun CharSequence.isEmpty(): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'diagnosticHolder' @ [60:13] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.reportIfNeeded[ValueParameterDescriptorImpl]

'report' @ [60:30] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'INVALID_CHARACTERS' @ [60:44] ==> public final val INVALID_CHARACTERS: (DiagnosticFactory1<(PsiElement..PsiElement?), (String..String?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (String..String?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [60:63] ==> @NotNull public open fun on(@NotNull p0: PsiElement, @NotNull p1: String): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory1[JavaMethodDescriptor]

'element' @ [60:66] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.reportIfNeeded[ValueParameterDescriptorImpl]

'text' @ [62:18] ==> val text: String defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.reportIfNeeded[LocalVariableDescriptor]

'any' @ [62:23] ==> public inline fun CharSequence.any(predicate: (Char) -> Boolean): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'it' @ [62:29] ==> value-parameter it: Char defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.reportIfNeeded.<anonymous>[ValueParameterDescriptorImpl]

'CHARS' @ [62:35] ==> private final val CHARS: Set<Char> defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker[PropertyDescriptorImpl]

'diagnosticHolder' @ [63:13] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.reportIfNeeded[ValueParameterDescriptorImpl]

'report' @ [63:30] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'INVALID_CHARACTERS' @ [63:44] ==> public final val INVALID_CHARACTERS: (DiagnosticFactory1<(PsiElement..PsiElement?), (String..String?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (String..String?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [63:63] ==> @NotNull public open fun on(@NotNull p0: PsiElement, @NotNull p1: String): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory1[JavaMethodDescriptor]

'element' @ [63:66] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.reportIfNeeded[ValueParameterDescriptorImpl]

'CHARS' @ [63:107] ==> private final val CHARS: Set<Char> defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker[PropertyDescriptorImpl]

'intersect' @ [63:113] ==> public infix fun <T> Iterable<Char>.intersect(other: Iterable<Char>): Set<Char> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Char

'text' @ [63:123] ==> val text: String defined in org.jetbrains.kotlin.resolve.jvm.checkers.JvmSimpleNameBacktickChecker.reportIfNeeded[LocalVariableDescriptor]

'toSet' @ [63:128] ==> public fun CharSequence.toSet(): Set<Char> defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'joinToString' @ [63:137] ==> public fun <T> Iterable<Char>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((Char) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Char

