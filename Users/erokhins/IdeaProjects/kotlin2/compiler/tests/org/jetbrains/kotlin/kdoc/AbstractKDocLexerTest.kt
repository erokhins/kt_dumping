'TestCase' @ [27:40] ==> public constructor TestCase() defined in junit.framework.TestCase[JavaClassConstructorDescriptor]

'File' @ [29:20] ==> public constructor File(p0: (String..String?)) defined in java.io.File[JavaClassConstructorDescriptor]

'fileName' @ [29:25] ==> value-parameter fileName: String defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.doTest[ValueParameterDescriptorImpl]

'readText' @ [29:35] ==> public fun File.readText(charset: Charset = ...): String defined in kotlin.io[DeserializedSimpleFunctionDescriptor]

'printTokens' @ [30:27] ==> public final fun printTokens(text: CharSequence, start: Int, lexer: Lexer): String defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest[SimpleFunctionDescriptorImpl]

'convertLineSeparators' @ [30:50] ==> @NotNull @Contract public open fun convertLineSeparators(@NotNull p0: String): String defined in com.intellij.openapi.util.text.StringUtil[JavaMethodDescriptor]

'text' @ [30:72] ==> val text: String defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.doTest[LocalVariableDescriptor]

'KDocLexer' @ [30:82] ==> public constructor KDocLexer() defined in org.jetbrains.kotlin.kdoc.lexer.KDocLexer[JavaClassConstructorDescriptor]

'assertSameLinesWithFile' @ [31:26] ==> public open fun assertSameLinesWithFile(p0: (String..String?), p1: (String..String?)): Unit defined in org.jetbrains.kotlin.test.testFramework.KtUsefulTestCase[JavaMethodDescriptor]

'fileName' @ [31:50] ==> value-parameter fileName: String defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.doTest[ValueParameterDescriptorImpl]

'replaceAfterLast' @ [31:59] ==> public fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'lexerResult' @ [31:89] ==> val lexerResult: String defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.doTest[LocalVariableDescriptor]

'lexer' @ [35:9] ==> value-parameter lexer: Lexer defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.printTokens[ValueParameterDescriptorImpl]

'start' @ [35:15] ==> public final fun start(@NotNull p0: CharSequence, p1: Int, p2: Int): Unit defined in com.intellij.lexer.Lexer[JavaMethodDescriptor]

'text' @ [35:21] ==> value-parameter text: CharSequence defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.printTokens[ValueParameterDescriptorImpl]

'start' @ [35:27] ==> value-parameter start: Int defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.printTokens[ValueParameterDescriptorImpl]

'text' @ [35:34] ==> value-parameter text: CharSequence defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.printTokens[ValueParameterDescriptorImpl]

'length' @ [35:39] ==> public abstract val length: Int defined in kotlin.CharSequence[DeserializedPropertyDescriptor]

'lexer' @ [38:29] ==> value-parameter lexer: Lexer defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.printTokens[ValueParameterDescriptorImpl]

'tokenType' @ [38:35] ==> public final val Lexer.tokenType: IElementType?[MyPropertyDescriptor]

'getTokenText' @ [39:29] ==> private final fun getTokenText(lexer: Lexer): String defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest[SimpleFunctionDescriptorImpl]

'lexer' @ [39:42] ==> value-parameter lexer: Lexer defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.printTokens[ValueParameterDescriptorImpl]

'tokenType' @ [40:33] ==> val tokenType: IElementType defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.printTokens[LocalVariableDescriptor]

'toString' @ [40:43] ==> public open fun toString(): String defined in com.intellij.psi.tree.IElementType[JavaMethodDescriptor]

'tokenTypeName' @ [41:26] ==> val tokenTypeName: String defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.printTokens[LocalVariableDescriptor]

'tokenText' @ [41:43] ==> val tokenText: String defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.printTokens[LocalVariableDescriptor]

'result' @ [42:13] ==> var result: String defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.printTokens[LocalVariableDescriptor]

'line' @ [42:23] ==> val line: String defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.printTokens[LocalVariableDescriptor]

'lexer' @ [43:13] ==> value-parameter lexer: Lexer defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.printTokens[ValueParameterDescriptorImpl]

'advance' @ [43:19] ==> public abstract fun advance(): Unit defined in com.intellij.lexer.Lexer[JavaMethodDescriptor]

'result' @ [45:16] ==> var result: String defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.printTokens[LocalVariableDescriptor]

'lexer' @ [49:25] ==> value-parameter lexer: Lexer defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.getTokenText[ValueParameterDescriptorImpl]

'tokenType' @ [49:31] ==> public final val Lexer.tokenType: IElementType?[MyPropertyDescriptor]

'tokenType' @ [50:13] ==> val tokenType: IElementType? defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.getTokenText[LocalVariableDescriptor]

'tokenType' @ [51:20] ==> val tokenType: IElementType? defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.getTokenText[LocalVariableDescriptor]

'value' @ [51:30] ==> public final val TokenWrapper.value: String[MyPropertyDescriptor]

'lexer' @ [54:20] ==> value-parameter lexer: Lexer defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.getTokenText[ValueParameterDescriptorImpl]

'bufferSequence' @ [54:26] ==> public final val Lexer.bufferSequence: CharSequence[MyPropertyDescriptor]

'subSequence' @ [54:41] ==> public abstract fun subSequence(startIndex: Int, endIndex: Int): CharSequence defined in kotlin.CharSequence[DeserializedSimpleFunctionDescriptor]

'lexer' @ [54:53] ==> value-parameter lexer: Lexer defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.getTokenText[ValueParameterDescriptorImpl]

'tokenStart' @ [54:59] ==> public final val Lexer.tokenStart: Int[MyPropertyDescriptor]

'lexer' @ [54:71] ==> value-parameter lexer: Lexer defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.getTokenText[ValueParameterDescriptorImpl]

'tokenEnd' @ [54:77] ==> public final val Lexer.tokenEnd: Int[MyPropertyDescriptor]

'toString' @ [54:87] ==> public open fun toString(): String defined in kotlin.CharSequence[DeserializedSimpleFunctionDescriptor]

'text' @ [55:9] ==> var text: String defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.getTokenText[LocalVariableDescriptor]

'replace' @ [55:27] ==> @NotNull @Contract public open fun replace(@NonNls @NotNull p0: String, @NonNls @NotNull p1: String, @NonNls @NotNull p2: String): String defined in com.intellij.openapi.util.text.StringUtil[JavaMethodDescriptor]

'text' @ [55:35] ==> var text: String defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.getTokenText[LocalVariableDescriptor]

'text' @ [56:16] ==> var text: String defined in org.jetbrains.kotlin.kdoc.AbstractKDocLexerTest.getTokenText[LocalVariableDescriptor]

