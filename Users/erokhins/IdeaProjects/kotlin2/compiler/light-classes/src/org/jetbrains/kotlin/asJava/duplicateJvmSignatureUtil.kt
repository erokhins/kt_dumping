'file' @ [38:23] ==> value-parameter file: KtFile defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics.getDiagnosticsForFileFacade[ValueParameterDescriptorImpl]

'project' @ [38:28] ==> public final val KtFile.project: Project[MyPropertyDescriptor]

'KtLightClassForFacade' @ [39:21] ==> public companion object Factory defined in org.jetbrains.kotlin.asJava.classes.KtLightClassForFacade[FakeCallableDescriptorForObject]

'getInstance' @ [39:59] ==> public final fun getInstance(project: Project): KtLightClassForFacade.FacadeStubCache defined in org.jetbrains.kotlin.asJava.classes.KtLightClassForFacade.FacadeStubCache.Companion[SimpleFunctionDescriptorImpl]

'project' @ [39:71] ==> val project: Project defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics.getDiagnosticsForFileFacade[LocalVariableDescriptor]

'NoResolveFileClassesProvider' @ [40:28] ==> public object NoResolveFileClassesProvider : JvmFileClassesProvider defined in org.jetbrains.kotlin.fileClasses[FakeCallableDescriptorForObject]

'getFileClassInfo' @ [40:57] ==> public open fun getFileClassInfo(file: KtFile): JvmFileClassInfo defined in org.jetbrains.kotlin.fileClasses.NoResolveFileClassesProvider[DeserializedSimpleFunctionDescriptor]

'file' @ [40:74] ==> value-parameter file: KtFile defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics.getDiagnosticsForFileFacade[ValueParameterDescriptorImpl]

'facadeClassFqName' @ [40:80] ==> public abstract val facadeClassFqName: FqName defined in org.jetbrains.kotlin.fileClasses.JvmFileClassInfo[DeserializedPropertyDescriptor]

'cache' @ [41:16] ==> val cache: KtLightClassForFacade.FacadeStubCache defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics.getDiagnosticsForFileFacade[LocalVariableDescriptor]

'facadeFqName' @ [41:22] ==> val facadeFqName: FqName defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics.getDiagnosticsForFileFacade[LocalVariableDescriptor]

'moduleScope' @ [41:36] ==> value-parameter moduleScope: GlobalSearchScope defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics[ValueParameterDescriptorImpl]

'value' @ [41:49] ==> public final val <T : (Any..Any?)> CachedValue<LightClassDataHolder.ForFacade>.value: (LightClassDataHolder.ForFacade..LightClassDataHolder.ForFacade?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> ForFacade

'extraDiagnostics' @ [41:56] ==> public abstract val extraDiagnostics: Diagnostics defined in org.jetbrains.kotlin.asJava.builder.LightClassDataHolder.ForFacade[PropertyDescriptorImpl]

'KtLightClassForSourceDeclaration' @ [45:36] ==> public companion object defined in org.jetbrains.kotlin.asJava.classes.KtLightClassForSourceDeclaration[FakeCallableDescriptorForObject]

'getLightClassDataHolder' @ [45:69] ==> public final fun getLightClassDataHolder(classOrObject: KtClassOrObject): LightClassDataHolder.ForClass defined in org.jetbrains.kotlin.asJava.classes.KtLightClassForSourceDeclaration.Companion[SimpleFunctionDescriptorImpl]

'ktClassOrObject' @ [45:93] ==> value-parameter ktClassOrObject: KtClassOrObject defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics.getDiagnosticsForClass[ValueParameterDescriptorImpl]

'lightClassDataHolder' @ [46:13] ==> val lightClassDataHolder: LightClassDataHolder.ForClass defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics.getDiagnosticsForClass[LocalVariableDescriptor]

'Diagnostics' @ [47:20] ==> public companion object defined in org.jetbrains.kotlin.resolve.diagnostics.Diagnostics[FakeCallableDescriptorForObject]

'EMPTY' @ [47:32] ==> public final val EMPTY: Diagnostics defined in org.jetbrains.kotlin.resolve.diagnostics.Diagnostics.Companion[DeserializedPropertyDescriptor]

'lightClassDataHolder' @ [49:16] ==> val lightClassDataHolder: LightClassDataHolder.ForClass defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics.getDiagnosticsForClass[LocalVariableDescriptor]

'extraDiagnostics' @ [49:37] ==> public abstract val extraDiagnostics: Diagnostics defined in org.jetbrains.kotlin.asJava.builder.LightClassDataHolder.ForClass[PropertyDescriptorImpl]

'?:' @ [54:13] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: Boolean?, right: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> Boolean

'element' @ [54:14] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics[ValueParameterDescriptorImpl]

'containingFile' @ [54:22] ==> public final val PsiElement.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'isScript' @ [54:50] ==> public final val KtFile.isScript: Boolean[MyPropertyDescriptor]

'element' @ [56:22] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics[ValueParameterDescriptorImpl]

'parent' @ [56:30] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'element' @ [57:13] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics[ValueParameterDescriptorImpl]

'parent' @ [58:13] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics.doGetDiagnostics[LocalVariableDescriptor]

'parent' @ [58:22] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics.doGetDiagnostics[LocalVariableDescriptor]

'parent' @ [58:30] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'element' @ [60:13] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics[ValueParameterDescriptorImpl]

'element' @ [60:39] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics[ValueParameterDescriptorImpl]

'hasValOrVar' @ [60:47] ==> public open fun hasValOrVar(): Boolean defined in org.jetbrains.kotlin.psi.KtParameter[JavaMethodDescriptor]

'parent' @ [62:32] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics.doGetDiagnostics[LocalVariableDescriptor]

'parent' @ [62:40] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [62:48] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parentClass' @ [63:17] ==> val parentClass: KtClass? defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics.doGetDiagnostics[LocalVariableDescriptor]

'getDiagnosticsForClass' @ [64:24] ==> local final fun getDiagnosticsForClass(ktClassOrObject: KtClassOrObject): Diagnostics defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics[SimpleFunctionDescriptorImpl]

'parentClass' @ [64:47] ==> val parentClass: KtClass? defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics.doGetDiagnostics[LocalVariableDescriptor]

'element' @ [67:13] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics[ValueParameterDescriptorImpl]

'getDiagnosticsForClass' @ [68:20] ==> local final fun getDiagnosticsForClass(ktClassOrObject: KtClassOrObject): Diagnostics defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics[SimpleFunctionDescriptorImpl]

'element' @ [68:43] ==> value-parameter element: PsiElement defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics[ValueParameterDescriptorImpl]

'when (parent) {
            is KtFile -> {
                return getDiagnosticsForFileFacade(parent)
            }
            is KtClassBody -> {
                val parentsParent = parent.getParent()

                if (parentsParent is KtClassOrObject) {
                    return getDiagnosticsForClass(parentsParent)
                }
            }
        }' @ [71:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'parent' @ [71:15] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics.doGetDiagnostics[LocalVariableDescriptor]

'getDiagnosticsForFileFacade' @ [73:24] ==> local final fun getDiagnosticsForFileFacade(file: KtFile): Diagnostics? defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics[SimpleFunctionDescriptorImpl]

'parent' @ [73:52] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics.doGetDiagnostics[LocalVariableDescriptor]

'parent' @ [76:37] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics.doGetDiagnostics[LocalVariableDescriptor]

'getParent' @ [76:44] ==> @Contract public abstract fun getParent(): (PsiElement..PsiElement?) defined in com.intellij.psi.PsiElement[JavaMethodDescriptor]

'parentsParent' @ [78:21] ==> val parentsParent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics.doGetDiagnostics[LocalVariableDescriptor]

'getDiagnosticsForClass' @ [79:28] ==> local final fun getDiagnosticsForClass(ktClassOrObject: KtClassOrObject): Diagnostics defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics[SimpleFunctionDescriptorImpl]

'parentsParent' @ [79:51] ==> val parentsParent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics.doGetDiagnostics[LocalVariableDescriptor]

'doGetDiagnostics' @ [86:18] ==> local final fun doGetDiagnostics(): Diagnostics? defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics[SimpleFunctionDescriptorImpl]

'result' @ [87:9] ==> val result: Diagnostics? defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics[LocalVariableDescriptor]

'FilteredJvmDiagnostics' @ [89:12] ==> public constructor FilteredJvmDiagnostics(jvmDiagnostics: Diagnostics, otherDiagnostics: Diagnostics) defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics[ClassConstructorDescriptorImpl]

'result' @ [89:35] ==> val result: Diagnostics? defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics[LocalVariableDescriptor]

'otherDiagnostics' @ [89:43] ==> value-parameter otherDiagnostics: Diagnostics defined in org.jetbrains.kotlin.asJava.getJvmSignatureDiagnostics[ValueParameterDescriptorImpl]

'jvmDiagnostics' @ [92:115] ==> value-parameter jvmDiagnostics: Diagnostics defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.<init>[ValueParameterDescriptorImpl]

'setOf' @ [95:30] ==> public fun <T> setOf(vararg elements: DiagnosticFactory<*>): Set<DiagnosticFactory<*>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DiagnosticFactory<*>

'CONFLICTING_OVERLOADS' @ [96:17] ==> public final val CONFLICTING_OVERLOADS: (DiagnosticFactory1<(PsiElement..PsiElement?), (MutableCollection<(DeclarationDescriptor..DeclarationDescriptor?)>..Collection<(DeclarationDescriptor..DeclarationDescriptor?)>?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (MutableCollection<(DeclarationDescriptor..DeclarationDescriptor?)>..Collection<(DeclarationDescriptor..DeclarationDescriptor?)>?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'REDECLARATION' @ [96:40] ==> public final val REDECLARATION: (DiagnosticFactory1<(PsiElement..PsiElement?), (MutableCollection<(DeclarationDescriptor..DeclarationDescriptor?)>..Collection<(DeclarationDescriptor..DeclarationDescriptor?)>?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (MutableCollection<(DeclarationDescriptor..DeclarationDescriptor?)>..Collection<(DeclarationDescriptor..DeclarationDescriptor?)>?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'NOTHING_TO_OVERRIDE' @ [96:55] ==> public final val NOTHING_TO_OVERRIDE: (DiagnosticFactory1<(KtModifierListOwner..KtModifierListOwner?), (CallableMemberDescriptor..CallableMemberDescriptor?)>..DiagnosticFactory1<(KtModifierListOwner..KtModifierListOwner?), (CallableMemberDescriptor..CallableMemberDescriptor?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'MANY_IMPL_MEMBER_NOT_IMPLEMENTED' @ [96:76] ==> public final val MANY_IMPL_MEMBER_NOT_IMPLEMENTED: (DiagnosticFactory2<(KtClassOrObject..KtClassOrObject?), (KtClassOrObject..KtClassOrObject?), (CallableMemberDescriptor..CallableMemberDescriptor?)>..DiagnosticFactory2<(KtClassOrObject..KtClassOrObject?), (KtClassOrObject..KtClassOrObject?), (CallableMemberDescriptor..CallableMemberDescriptor?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'otherDiagnostics' @ [97:16] ==> public final val otherDiagnostics: Diagnostics defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics[PropertyDescriptorImpl]

'forElement' @ [97:33] ==> public abstract fun forElement(psiElement: PsiElement): Collection<Diagnostic> defined in org.jetbrains.kotlin.resolve.diagnostics.Diagnostics[DeserializedSimpleFunctionDescriptor]

'psiElement' @ [97:44] ==> value-parameter psiElement: PsiElement defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.alreadyReported[ValueParameterDescriptorImpl]

'any' @ [97:56] ==> public inline fun <T> Iterable<Diagnostic>.any(predicate: (Diagnostic) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Diagnostic

'it' @ [97:62] ==> value-parameter it: Diagnostic defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.alreadyReported.<anonymous>[ValueParameterDescriptorImpl]

'factory' @ [97:65] ==> public final val Diagnostic.factory: DiagnosticFactory<*>[MyPropertyDescriptor]

'higherPriority' @ [97:76] ==> val higherPriority: Set<DiagnosticFactory<*>> defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.alreadyReported[LocalVariableDescriptor]

'psiElement' @ [98:20] ==> value-parameter psiElement: PsiElement defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.alreadyReported[ValueParameterDescriptorImpl]

'alreadyReported' @ [98:56] ==> private final fun alreadyReported(psiElement: PsiElement): Boolean defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics[SimpleFunctionDescriptorImpl]

'psiElement' @ [98:72] ==> value-parameter psiElement: PsiElement defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.alreadyReported[ValueParameterDescriptorImpl]

'parent' @ [98:83] ==> public final val KtPropertyAccessor.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'setOf' @ [102:38] ==> public fun <T> setOf(vararg elements: (DiagnosticFactory1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>?)): Set<(DiagnosticFactory1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.diagnostics.DiagnosticFactory1<(com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?), (org.jetbrains.kotlin.resolve.jvm.diagnostics.ConflictingJvmDeclarationsData..org.jetbrains.kotlin.resolve.jvm.diagnostics.ConflictingJvmDeclarationsData?)>..org.jetbrains.kotlin.diagnostics.DiagnosticFactory1<(com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?), (org.jetbrains.kotlin.resolve.jvm.diagnostics.ConflictingJvmDeclarationsData..org.jetbrains.kotlin.resolve.jvm.diagnostics.ConflictingJvmDeclarationsData?)>?)

'CONFLICTING_JVM_DECLARATIONS' @ [102:44] ==> public final val CONFLICTING_JVM_DECLARATIONS: (DiagnosticFactory1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>?) defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm[JavaPropertyDescriptor]

'ACCIDENTAL_OVERRIDE' @ [102:74] ==> public final val ACCIDENTAL_OVERRIDE: (DiagnosticFactory1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>?) defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm[JavaPropertyDescriptor]

'CONFLICTING_INHERITED_JVM_DECLARATIONS' @ [102:95] ==> public final val CONFLICTING_INHERITED_JVM_DECLARATIONS: (DiagnosticFactory1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>?) defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm[JavaPropertyDescriptor]

'cast' @ [103:33] ==> @NotNull public open fun <D : (Diagnostic..Diagnostic?)> cast(@NotNull p0: Diagnostic, @NotNull p1: (MutableCollection<out (DiagnosticFactory<out (DiagnosticWithParameters1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>..DiagnosticWithParameters1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>?)>..DiagnosticFactory<out (DiagnosticWithParameters1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>..DiagnosticWithParameters1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>?)>?)>..Collection<(DiagnosticFactory<out (DiagnosticWithParameters1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>..DiagnosticWithParameters1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>?)>..DiagnosticFactory<out (DiagnosticWithParameters1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>..DiagnosticWithParameters1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>?)>?)>)): DiagnosticWithParameters1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory[JavaMethodDescriptor]
Inferred types:
    <D : (Diagnostic..Diagnostic?)> -> (org.jetbrains.kotlin.diagnostics.DiagnosticWithParameters1<(com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?), (org.jetbrains.kotlin.resolve.jvm.diagnostics.ConflictingJvmDeclarationsData..org.jetbrains.kotlin.resolve.jvm.diagnostics.ConflictingJvmDeclarationsData?)>..org.jetbrains.kotlin.diagnostics.DiagnosticWithParameters1<(com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?), (org.jetbrains.kotlin.resolve.jvm.diagnostics.ConflictingJvmDeclarationsData..org.jetbrains.kotlin.resolve.jvm.diagnostics.ConflictingJvmDeclarationsData?)>?)

'this' @ [103:38] ==> <this> defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement.data[ReceiverParameterDescriptorImpl]

'jvmDiagnosticFactories' @ [103:44] ==> val jvmDiagnosticFactories: Set<(DiagnosticFactory1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>?)> defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement[LocalVariableDescriptor]

'a' @ [103:68] ==> public final val <E : (PsiElement..PsiElement?), A : (Any..Any?)> DiagnosticWithParameters1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>.a: ConflictingJvmDeclarationsData[MyPropertyDescriptor]
Inferred types:
    <E : (PsiElement..PsiElement?)> -> (com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)
    <A : (Any..Any?)> -> (org.jetbrains.kotlin.resolve.jvm.diagnostics.ConflictingJvmDeclarationsData..org.jetbrains.kotlin.resolve.jvm.diagnostics.ConflictingJvmDeclarationsData?)

'component1' @ [104:14] ==> public final operator fun component1(): List<Diagnostic> defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [104:27] ==> public final operator fun component2(): List<Diagnostic> defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'jvmDiagnostics' @ [104:36] ==> public final val jvmDiagnostics: Diagnostics defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics[PropertyDescriptorImpl]

'forElement' @ [104:51] ==> public abstract fun forElement(psiElement: PsiElement): Collection<Diagnostic> defined in org.jetbrains.kotlin.resolve.diagnostics.Diagnostics[DeserializedSimpleFunctionDescriptor]

'psiElement' @ [104:62] ==> value-parameter psiElement: PsiElement defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement[ValueParameterDescriptorImpl]

'partition' @ [104:74] ==> public inline fun <T> Iterable<Diagnostic>.partition(predicate: (Diagnostic) -> Boolean): Pair<List<Diagnostic>, List<Diagnostic>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Diagnostic

'it' @ [104:86] ==> value-parameter it: Diagnostic defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement.<anonymous>[ValueParameterDescriptorImpl]

'factory' @ [104:89] ==> public final val Diagnostic.factory: DiagnosticFactory<*>[MyPropertyDescriptor]

'jvmDiagnosticFactories' @ [104:100] ==> val jvmDiagnosticFactories: Set<(DiagnosticFactory1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>?)> defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement[LocalVariableDescriptor]

'alreadyReported' @ [105:13] ==> private final fun alreadyReported(psiElement: PsiElement): Boolean defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics[SimpleFunctionDescriptorImpl]

'psiElement' @ [105:29] ==> value-parameter psiElement: PsiElement defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement[ValueParameterDescriptorImpl]

'other' @ [107:20] ==> val other: List<Diagnostic> defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement[LocalVariableDescriptor]

'arrayListOf' @ [110:24] ==> @SinceKotlin @InlineOnly public inline fun <T> arrayListOf(): ArrayList<Diagnostic> /* = ArrayList<Diagnostic> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Diagnostic

'conflicting' @ [111:9] ==> val conflicting: List<Diagnostic> defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement[LocalVariableDescriptor]

'groupBy' @ [111:21] ==> public inline fun <T, K> Iterable<Diagnostic>.groupBy(keySelector: (Diagnostic) -> String): Map<String, List<Diagnostic>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Diagnostic
    <K> -> String

'it' @ [112:13] ==> value-parameter it: Diagnostic defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement.<anonymous>[ValueParameterDescriptorImpl]

'data' @ [112:16] ==> local final fun Diagnostic.data(): ConflictingJvmDeclarationsData defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement[SimpleFunctionDescriptorImpl]

'signature' @ [112:23] ==> public final val signature: RawSignature defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ConflictingJvmDeclarationsData[DeserializedPropertyDescriptor]

'name' @ [112:33] ==> public final val name: String defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.RawSignature[DeserializedPropertyDescriptor]

'forEach' @ [113:11] ==> @HidesMembers public inline fun <K, V> Map<out String, List<Diagnostic>>.forEach(action: (Map.Entry<String, List<Diagnostic>>) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> String
    <V> -> List<Diagnostic>

'it' @ [114:31] ==> value-parameter it: Map.Entry<String, List<Diagnostic>> defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [114:34] ==> public abstract val value: List<Diagnostic> defined in kotlin.collections.Map.Entry[DeserializedPropertyDescriptor]

'if (diagnostics.size <= 1) {
                filtered.addAll(diagnostics)
            }
            else {
                filtered.addAll(
                        diagnostics.filter {
                            me ->
                            diagnostics.none {
                                other ->
                                me != other && (
                                        // in case of implementation copied from a super trait there will be both diagnostics on the same signature
                                        other.factory == ErrorsJvm.CONFLICTING_JVM_DECLARATIONS && (me.factory == ACCIDENTAL_OVERRIDE ||
                                                                                                    me.factory == CONFLICTING_INHERITED_JVM_DECLARATIONS)
                                        // there are paris of corresponding signatures that frequently clash simultaneously: multifile class & part, trait and trait-impl
                                        || other.data().higherThan(me.data())
                                        )
                            }
                        }
                )
            }' @ [115:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Boolean, elseBranch: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Boolean

'diagnostics' @ [115:17] ==> val diagnostics: List<Diagnostic> defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement.<anonymous>[LocalVariableDescriptor]

'size' @ [115:29] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'filtered' @ [116:17] ==> val filtered: ArrayList<Diagnostic> /* = ArrayList<Diagnostic> */ defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement[LocalVariableDescriptor]

'addAll' @ [116:26] ==> public open fun addAll(elements: Collection<Diagnostic>): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'diagnostics' @ [116:33] ==> val diagnostics: List<Diagnostic> defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement.<anonymous>[LocalVariableDescriptor]

'filtered' @ [119:17] ==> val filtered: ArrayList<Diagnostic> /* = ArrayList<Diagnostic> */ defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement[LocalVariableDescriptor]

'addAll' @ [119:26] ==> public open fun addAll(elements: Collection<Diagnostic>): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'diagnostics' @ [120:25] ==> val diagnostics: List<Diagnostic> defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement.<anonymous>[LocalVariableDescriptor]

'filter' @ [120:37] ==> public inline fun <T> Iterable<Diagnostic>.filter(predicate: (Diagnostic) -> Boolean): List<Diagnostic> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Diagnostic

'diagnostics' @ [122:29] ==> val diagnostics: List<Diagnostic> defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement.<anonymous>[LocalVariableDescriptor]

'none' @ [122:41] ==> public inline fun <T> Iterable<Diagnostic>.none(predicate: (Diagnostic) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Diagnostic

'me' @ [124:33] ==> value-parameter me: Diagnostic defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'other' @ [124:39] ==> value-parameter other: Diagnostic defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'other' @ [126:41] ==> value-parameter other: Diagnostic defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'factory' @ [126:47] ==> public final val Diagnostic.factory: DiagnosticFactory<*>[MyPropertyDescriptor]

'CONFLICTING_JVM_DECLARATIONS' @ [126:68] ==> public final val CONFLICTING_JVM_DECLARATIONS: (DiagnosticFactory1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>?) defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm[JavaPropertyDescriptor]

'me' @ [126:101] ==> value-parameter me: Diagnostic defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'factory' @ [126:104] ==> public final val Diagnostic.factory: DiagnosticFactory<*>[MyPropertyDescriptor]

'ACCIDENTAL_OVERRIDE' @ [126:115] ==> public final val ACCIDENTAL_OVERRIDE: (DiagnosticFactory1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>?) defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm[JavaPropertyDescriptor]

'me' @ [127:101] ==> value-parameter me: Diagnostic defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'factory' @ [127:104] ==> public final val Diagnostic.factory: DiagnosticFactory<*>[MyPropertyDescriptor]

'CONFLICTING_INHERITED_JVM_DECLARATIONS' @ [127:115] ==> public final val CONFLICTING_INHERITED_JVM_DECLARATIONS: (DiagnosticFactory1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (ConflictingJvmDeclarationsData..ConflictingJvmDeclarationsData?)>?) defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm[JavaPropertyDescriptor]

'other' @ [129:44] ==> value-parameter other: Diagnostic defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'data' @ [129:50] ==> local final fun Diagnostic.data(): ConflictingJvmDeclarationsData defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement[SimpleFunctionDescriptorImpl]

'higherThan' @ [129:57] ==> private infix fun ConflictingJvmDeclarationsData.higherThan(other: ConflictingJvmDeclarationsData): Boolean defined in org.jetbrains.kotlin.asJava in file duplicateJvmSignatureUtil.kt[SimpleFunctionDescriptorImpl]

'me' @ [129:68] ==> value-parameter me: Diagnostic defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'data' @ [129:71] ==> local final fun Diagnostic.data(): ConflictingJvmDeclarationsData defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement[SimpleFunctionDescriptorImpl]

'filtered' @ [137:16] ==> val filtered: ArrayList<Diagnostic> /* = ArrayList<Diagnostic> */ defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement[LocalVariableDescriptor]

'other' @ [137:27] ==> val other: List<Diagnostic> defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.forElement[LocalVariableDescriptor]

'jvmDiagnostics' @ [141:16] ==> public final val jvmDiagnostics: Diagnostics defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics[PropertyDescriptorImpl]

'all' @ [141:31] ==> public abstract fun all(): Collection<Diagnostic> defined in org.jetbrains.kotlin.resolve.diagnostics.Diagnostics[DeserializedSimpleFunctionDescriptor]

'map' @ [142:14] ==> public inline fun <T, R> Iterable<Diagnostic>.map(transform: (Diagnostic) -> PsiElement): List<PsiElement> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Diagnostic
    <R> -> PsiElement

'it' @ [142:20] ==> value-parameter it: Diagnostic defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.all.<anonymous>[ValueParameterDescriptorImpl]

'psiElement' @ [142:23] ==> public final val Diagnostic.psiElement: PsiElement[MyPropertyDescriptor]

'toSet' @ [143:14] ==> public fun <T> Iterable<PsiElement>.toSet(): Set<PsiElement> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement

'flatMap' @ [144:14] ==> public inline fun <T, R> Iterable<PsiElement>.flatMap(transform: (PsiElement) -> Iterable<Diagnostic>): List<Diagnostic> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement
    <R> -> Diagnostic

'forElement' @ [144:24] ==> public open fun forElement(psiElement: PsiElement): Collection<Diagnostic> defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics[SimpleFunctionDescriptorImpl]

'it' @ [144:35] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.asJava.FilteredJvmDiagnostics.all.<anonymous>[ValueParameterDescriptorImpl]

'when (other.classOrigin.originKind) {
        INTERFACE_DEFAULT_IMPL -> this.classOrigin.originKind != INTERFACE_DEFAULT_IMPL
        MULTIFILE_CLASS_PART -> this.classOrigin.originKind == MULTIFILE_CLASS
        else -> false
    }' @ [149:12] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean, entry2: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'other' @ [149:18] ==> value-parameter other: ConflictingJvmDeclarationsData defined in org.jetbrains.kotlin.asJava.higherThan[ValueParameterDescriptorImpl]

'classOrigin' @ [149:24] ==> public final val classOrigin: JvmDeclarationOrigin defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ConflictingJvmDeclarationsData[DeserializedPropertyDescriptor]

'originKind' @ [149:36] ==> public final val originKind: JvmDeclarationOriginKind defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOrigin[DeserializedPropertyDescriptor]

'INTERFACE_DEFAULT_IMPL' @ [150:9] ==> enum entry INTERFACE_DEFAULT_IMPL defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOriginKind[FakeCallableDescriptorForObject]

'this' @ [150:35] ==> <this> defined in org.jetbrains.kotlin.asJava.higherThan[ReceiverParameterDescriptorImpl]

'classOrigin' @ [150:40] ==> public final val classOrigin: JvmDeclarationOrigin defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ConflictingJvmDeclarationsData[DeserializedPropertyDescriptor]

'originKind' @ [150:52] ==> public final val originKind: JvmDeclarationOriginKind defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOrigin[DeserializedPropertyDescriptor]

'INTERFACE_DEFAULT_IMPL' @ [150:66] ==> enum entry INTERFACE_DEFAULT_IMPL defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOriginKind[FakeCallableDescriptorForObject]

'MULTIFILE_CLASS_PART' @ [151:9] ==> enum entry MULTIFILE_CLASS_PART defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOriginKind[FakeCallableDescriptorForObject]

'this' @ [151:33] ==> <this> defined in org.jetbrains.kotlin.asJava.higherThan[ReceiverParameterDescriptorImpl]

'classOrigin' @ [151:38] ==> public final val classOrigin: JvmDeclarationOrigin defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.ConflictingJvmDeclarationsData[DeserializedPropertyDescriptor]

'originKind' @ [151:50] ==> public final val originKind: JvmDeclarationOriginKind defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOrigin[DeserializedPropertyDescriptor]

'MULTIFILE_CLASS' @ [151:64] ==> enum entry MULTIFILE_CLASS defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOriginKind[FakeCallableDescriptorForObject]

