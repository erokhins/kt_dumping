'stub' @ [36:13] ==> value-parameter stub: StubElement<*> defined in org.jetbrains.kotlin.asJava.LightClassUtil.findClass[ValueParameterDescriptorImpl]

'invoke' @ [36:40] ==> public abstract operator fun invoke(p1: PsiClassStub<*>): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'stub' @ [36:50] ==> value-parameter stub: StubElement<*> defined in org.jetbrains.kotlin.asJava.LightClassUtil.findClass[ValueParameterDescriptorImpl]

'stub' @ [37:20] ==> value-parameter stub: StubElement<*> defined in org.jetbrains.kotlin.asJava.LightClassUtil.findClass[ValueParameterDescriptorImpl]

'psi' @ [37:25] ==> public final val <T : (PsiClass..PsiClass?)> PsiClassStub<out (PsiClass..PsiClass?)>.psi: (PsiClass..PsiClass?)[MyPropertyDescriptor]
Inferred types:
    <T : (PsiClass..PsiClass?)> -> (com.intellij.psi.PsiClass..com.intellij.psi.PsiClass?)

'stub' @ [40:13] ==> value-parameter stub: StubElement<*> defined in org.jetbrains.kotlin.asJava.LightClassUtil.findClass[ValueParameterDescriptorImpl]

'stub' @ [40:40] ==> value-parameter stub: StubElement<*> defined in org.jetbrains.kotlin.asJava.LightClassUtil.findClass[ValueParameterDescriptorImpl]

'stub' @ [41:27] ==> value-parameter stub: StubElement<*> defined in org.jetbrains.kotlin.asJava.LightClassUtil.findClass[ValueParameterDescriptorImpl]

'childrenStubs' @ [41:32] ==> public final val <T : (PsiElement..PsiElement?)> StubElement<out (PsiElement..PsiElement?)>.childrenStubs: (MutableList<raw (StubElement<(PsiElement..PsiElement?)>..StubElement<*>?)>..List<raw (StubElement<(PsiElement..PsiElement?)>..StubElement<*>?)>)[MyPropertyDescriptor]
Inferred types:
    <T : (PsiElement..PsiElement?)> -> (com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)

'findClass' @ [42:30] ==> public final fun findClass(stub: StubElement<*>, predicate: (PsiClassStub<*>) -> Boolean): PsiClass? defined in org.jetbrains.kotlin.asJava.LightClassUtil[SimpleFunctionDescriptorImpl]

'child' @ [42:40] ==> val child: raw (StubElement<(PsiElement..PsiElement?)>..StubElement<*>?) defined in org.jetbrains.kotlin.asJava.LightClassUtil.findClass[LocalVariableDescriptor]

'predicate' @ [42:47] ==> value-parameter predicate: (PsiClassStub<*>) -> Boolean defined in org.jetbrains.kotlin.asJava.LightClassUtil.findClass[ValueParameterDescriptorImpl]

'answer' @ [43:21] ==> val answer: PsiClass? defined in org.jetbrains.kotlin.asJava.LightClassUtil.findClass[LocalVariableDescriptor]

'answer' @ [43:44] ==> val answer: PsiClass? defined in org.jetbrains.kotlin.asJava.LightClassUtil.findClass[LocalVariableDescriptor]

'getLightClassAccessorMethods' @ [50:13] ==> public final fun getLightClassAccessorMethods(accessor: KtPropertyAccessor): List<PsiMethod> defined in org.jetbrains.kotlin.asJava.LightClassUtil[SimpleFunctionDescriptorImpl]

'accessor' @ [50:42] ==> value-parameter accessor: KtPropertyAccessor defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassAccessorMethod[ValueParameterDescriptorImpl]

'firstOrNull' @ [50:52] ==> public fun <T> List<PsiMethod>.firstOrNull(): PsiMethod? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiMethod

'accessor' @ [53:24] ==> value-parameter accessor: KtPropertyAccessor defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassAccessorMethods[ValueParameterDescriptorImpl]

'getNonStrictParentOfType' @ [53:33] ==> public inline fun <reified T : PsiElement> PsiElement.getNonStrictParentOfType(): KtProperty? defined in org.jetbrains.kotlin.psi.psiUtil[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : PsiElement> -> KtProperty

'emptyList' @ [53:82] ==> public fun <T> emptyList(): List<PsiMethod> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiMethod

'getPsiMethodWrappers' @ [54:24] ==> private final fun getPsiMethodWrappers(declaration: KtDeclaration): Sequence<PsiMethod> defined in org.jetbrains.kotlin.asJava.LightClassUtil[SimpleFunctionDescriptorImpl]

'property' @ [54:45] ==> val property: KtProperty defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassAccessorMethods[LocalVariableDescriptor]

'wrappers' @ [55:16] ==> val wrappers: Sequence<PsiMethod> defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassAccessorMethods[LocalVariableDescriptor]

'filter' @ [55:25] ==> public fun <T> Sequence<PsiMethod>.filter(predicate: (PsiMethod) -> Boolean): Sequence<PsiMethod> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiMethod

'accessor' @ [56:14] ==> value-parameter accessor: KtPropertyAccessor defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassAccessorMethods[ValueParameterDescriptorImpl]

'isGetter' @ [56:23] ==> public final val KtPropertyAccessor.isGetter: Boolean[MyPropertyDescriptor]

'!' @ [56:35] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isSetterName' @ [56:43] ==> public open fun isSetterName(@NotNull p0: String): Boolean defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaMethodDescriptor]

'wrapper' @ [56:56] ==> value-parameter wrapper: PsiMethod defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassAccessorMethods.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [56:64] ==> public final var PsiMethod.name: String[MyPropertyDescriptor]

'accessor' @ [57:14] ==> value-parameter accessor: KtPropertyAccessor defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassAccessorMethods[ValueParameterDescriptorImpl]

'isSetter' @ [57:23] ==> public final val KtPropertyAccessor.isSetter: Boolean[MyPropertyDescriptor]

'isSetterName' @ [57:42] ==> public open fun isSetterName(@NotNull p0: String): Boolean defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaMethodDescriptor]

'wrapper' @ [57:55] ==> value-parameter wrapper: PsiMethod defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassAccessorMethods.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [57:63] ==> public final var PsiMethod.name: String[MyPropertyDescriptor]

'toList' @ [58:11] ==> public fun <T> Sequence<PsiMethod>.toList(): List<PsiMethod> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiMethod

'getWrappingClass' @ [62:29] ==> private final fun getWrappingClass(declaration: KtDeclaration): PsiClass? defined in org.jetbrains.kotlin.asJava.LightClassUtil[SimpleFunctionDescriptorImpl]

'companionObject' @ [62:46] ==> value-parameter companionObject: KtClassOrObject defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightFieldForCompanionObject[ValueParameterDescriptorImpl]

'outerPsiClass' @ [63:13] ==> val outerPsiClass: PsiClass? defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightFieldForCompanionObject[LocalVariableDescriptor]

'outerPsiClass' @ [64:35] ==> val outerPsiClass: PsiClass? defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightFieldForCompanionObject[LocalVariableDescriptor]

'fields' @ [64:49] ==> public final val PsiClass.fields: (Array<(PsiField..PsiField?)>..Array<out (PsiField..PsiField?)>)[MyPropertyDescriptor]

'fieldOfParent' @ [65:22] ==> val fieldOfParent: (PsiField..PsiField?) defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightFieldForCompanionObject[LocalVariableDescriptor]

'fieldOfParent' @ [65:64] ==> val fieldOfParent: (PsiField..PsiField?) defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightFieldForCompanionObject[LocalVariableDescriptor]

'kotlinOrigin' @ [65:78] ==> public abstract val kotlinOrigin: KtElement? defined in org.jetbrains.kotlin.asJava.elements.KtLightElement[PropertyDescriptorImpl]

'companionObject' @ [65:95] ==> value-parameter companionObject: KtClassOrObject defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightFieldForCompanionObject[ValueParameterDescriptorImpl]

'originalElement' @ [65:111] ==> public final val KtClassOrObject.originalElement: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'fieldOfParent' @ [66:28] ==> val fieldOfParent: (PsiField..PsiField?) defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightFieldForCompanionObject[LocalVariableDescriptor]

'property' @ [74:22] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassPropertyMethods[ValueParameterDescriptorImpl]

'getter' @ [74:31] ==> public final val KtProperty.getter: KtPropertyAccessor?[MyPropertyDescriptor]

'property' @ [75:22] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassPropertyMethods[ValueParameterDescriptorImpl]

'setter' @ [75:31] ==> public final val KtProperty.setter: KtPropertyAccessor?[MyPropertyDescriptor]

'if (getter != null) getLightClassAccessorMethod(getter) else null' @ [77:29] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: PsiMethod?, elseBranch: PsiMethod?): PsiMethod?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> PsiMethod?

'getter' @ [77:33] ==> val getter: KtPropertyAccessor? defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassPropertyMethods[LocalVariableDescriptor]

'getLightClassAccessorMethod' @ [77:49] ==> public final fun getLightClassAccessorMethod(accessor: KtPropertyAccessor): PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil[SimpleFunctionDescriptorImpl]

'getter' @ [77:77] ==> val getter: KtPropertyAccessor? defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassPropertyMethods[LocalVariableDescriptor]

'if (setter != null) getLightClassAccessorMethod(setter) else null' @ [78:29] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: PsiMethod?, elseBranch: PsiMethod?): PsiMethod?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> PsiMethod?

'setter' @ [78:33] ==> val setter: KtPropertyAccessor? defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassPropertyMethods[LocalVariableDescriptor]

'getLightClassAccessorMethod' @ [78:49] ==> public final fun getLightClassAccessorMethod(accessor: KtPropertyAccessor): PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil[SimpleFunctionDescriptorImpl]

'setter' @ [78:77] ==> val setter: KtPropertyAccessor? defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassPropertyMethods[LocalVariableDescriptor]

'extractPropertyAccessors' @ [80:16] ==> private final fun extractPropertyAccessors(ktDeclaration: KtDeclaration, specialGetter: PsiMethod?, specialSetter: PsiMethod?): LightClassUtil.PropertyAccessorsPsiMethods defined in org.jetbrains.kotlin.asJava.LightClassUtil[SimpleFunctionDescriptorImpl]

'property' @ [80:41] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassPropertyMethods[ValueParameterDescriptorImpl]

'getterWrapper' @ [80:51] ==> val getterWrapper: PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassPropertyMethods[LocalVariableDescriptor]

'setterWrapper' @ [80:66] ==> val setterWrapper: PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassPropertyMethods[LocalVariableDescriptor]

'getWrappingClass' @ [84:34] ==> private final fun getWrappingClass(declaration: KtDeclaration): PsiClass? defined in org.jetbrains.kotlin.asJava.LightClassUtil[SimpleFunctionDescriptorImpl]

'declaration' @ [84:51] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassBackingField[ValueParameterDescriptorImpl]

'psiClass' @ [86:13] ==> var psiClass: PsiClass defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassBackingField[LocalVariableDescriptor]

'psiClass' @ [87:26] ==> var psiClass: PsiClass defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassBackingField[LocalVariableDescriptor]

'kotlinOrigin' @ [87:35] ==> public abstract val kotlinOrigin: KtClassOrObject? defined in org.jetbrains.kotlin.asJava.classes.KtLightClass[PropertyDescriptorImpl]

'origin' @ [88:17] ==> val origin: KtClassOrObject? defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassBackingField[LocalVariableDescriptor]

'origin' @ [88:50] ==> val origin: KtClassOrObject? defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassBackingField[LocalVariableDescriptor]

'isCompanion' @ [88:57] ==> public final fun isCompanion(): Boolean defined in org.jetbrains.kotlin.psi.KtObjectDeclaration[DeserializedSimpleFunctionDescriptor]

'getParentOfType' @ [89:51] ==> @Nullable @Contract public open fun <T : (PsiElement..PsiElement?)> getParentOfType(@Nullable p0: PsiElement?, @NotNull p1: Class<(KtClass..KtClass?)>): KtClass? defined in com.intellij.psi.util.PsiTreeUtil[JavaMethodDescriptor]
Inferred types:
    <T : (PsiElement..PsiElement?)> -> KtClass

'origin' @ [89:67] ==> val origin: KtClassOrObject? defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassBackingField[LocalVariableDescriptor]

'java' @ [89:90] ==> public val <T> KClass<KtClass>.java: Class<KtClass> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtClass

'containingClass' @ [90:21] ==> val containingClass: KtClass? defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassBackingField[LocalVariableDescriptor]

'containingClass' @ [91:48] ==> val containingClass: KtClass? defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassBackingField[LocalVariableDescriptor]

'toLightClass' @ [91:64] ==> public fun KtClassOrObject.toLightClass(): KtLightClass? defined in org.jetbrains.kotlin.asJava in file lightClassUtils.kt[SimpleFunctionDescriptorImpl]

'containingLightClass' @ [92:25] ==> val containingLightClass: KtLightClass? defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassBackingField[LocalVariableDescriptor]

'psiClass' @ [93:25] ==> var psiClass: PsiClass defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassBackingField[LocalVariableDescriptor]

'containingLightClass' @ [93:36] ==> val containingLightClass: KtLightClass? defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassBackingField[LocalVariableDescriptor]

'psiClass' @ [99:23] ==> var psiClass: PsiClass defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassBackingField[LocalVariableDescriptor]

'fields' @ [99:32] ==> public final val PsiClass.fields: (Array<(PsiField..PsiField?)>..Array<out (PsiField..PsiField?)>)[MyPropertyDescriptor]

'field' @ [100:17] ==> val field: (PsiField..PsiField?) defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassBackingField[LocalVariableDescriptor]

'field' @ [100:42] ==> val field: (PsiField..PsiField?) defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassBackingField[LocalVariableDescriptor]

'kotlinOrigin' @ [100:48] ==> public abstract val kotlinOrigin: KtDeclaration? defined in org.jetbrains.kotlin.asJava.elements.KtLightField[PropertyDescriptorImpl]

'declaration' @ [100:65] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassBackingField[ValueParameterDescriptorImpl]

'field' @ [101:24] ==> val field: (PsiField..PsiField?) defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassBackingField[LocalVariableDescriptor]

'extractPropertyAccessors' @ [108:16] ==> private final fun extractPropertyAccessors(ktDeclaration: KtDeclaration, specialGetter: PsiMethod?, specialSetter: PsiMethod?): LightClassUtil.PropertyAccessorsPsiMethods defined in org.jetbrains.kotlin.asJava.LightClassUtil[SimpleFunctionDescriptorImpl]

'parameter' @ [108:41] ==> value-parameter parameter: KtParameter defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassPropertyMethods[ValueParameterDescriptorImpl]

'getPsiMethodWrapper' @ [112:16] ==> private final fun getPsiMethodWrapper(declaration: KtDeclaration): PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil[SimpleFunctionDescriptorImpl]

'function' @ [112:36] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassMethod[ValueParameterDescriptorImpl]

'getPsiMethodWrapper' @ [119:16] ==> private final fun getPsiMethodWrapper(declaration: KtDeclaration): PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil[SimpleFunctionDescriptorImpl]

'parameter' @ [119:36] ==> value-parameter parameter: KtParameter defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassMethod[ValueParameterDescriptorImpl]

'getPsiMethodWrappers' @ [123:16] ==> private final fun getPsiMethodWrappers(declaration: KtDeclaration): Sequence<PsiMethod> defined in org.jetbrains.kotlin.asJava.LightClassUtil[SimpleFunctionDescriptorImpl]

'function' @ [123:37] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.asJava.LightClassUtil.getLightClassMethods[ValueParameterDescriptorImpl]

'toList' @ [123:47] ==> public fun <T> Sequence<PsiMethod>.toList(): List<PsiMethod> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiMethod

'getPsiMethodWrappers' @ [127:16] ==> private final fun getPsiMethodWrappers(declaration: KtDeclaration): Sequence<PsiMethod> defined in org.jetbrains.kotlin.asJava.LightClassUtil[SimpleFunctionDescriptorImpl]

'declaration' @ [127:37] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.asJava.LightClassUtil.getPsiMethodWrapper[ValueParameterDescriptorImpl]

'firstOrNull' @ [127:50] ==> public fun <T> Sequence<PsiMethod>.firstOrNull(): PsiMethod? defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiMethod

'getWrappingClasses' @ [131:16] ==> private final fun getWrappingClasses(declaration: KtDeclaration): Sequence<PsiClass> defined in org.jetbrains.kotlin.asJava.LightClassUtil[SimpleFunctionDescriptorImpl]

'declaration' @ [131:35] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.asJava.LightClassUtil.getPsiMethodWrappers[ValueParameterDescriptorImpl]

'flatMap' @ [131:48] ==> public fun <T, R> Sequence<PsiClass>.flatMap(transform: (PsiClass) -> Sequence<(PsiMethod..PsiMethod?)>): Sequence<(PsiMethod..PsiMethod?)> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiClass
    <R> -> (com.intellij.psi.PsiMethod..com.intellij.psi.PsiMethod?)

'it' @ [131:58] ==> value-parameter it: PsiClass defined in org.jetbrains.kotlin.asJava.LightClassUtil.getPsiMethodWrappers.<anonymous>[ValueParameterDescriptorImpl]

'methods' @ [131:61] ==> public final val PsiClass.methods: (Array<(PsiMethod..PsiMethod?)>..Array<out (PsiMethod..PsiMethod?)>)[MyPropertyDescriptor]

'asSequence' @ [131:69] ==> public fun <T> Array<out (PsiMethod..PsiMethod?)>.asSequence(): Sequence<(PsiMethod..PsiMethod?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiMethod..com.intellij.psi.PsiMethod?)

'filter' @ [132:18] ==> public fun <T> Sequence<(PsiMethod..PsiMethod?)>.filter(predicate: ((PsiMethod..PsiMethod?)) -> Boolean): Sequence<(PsiMethod..PsiMethod?)> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiMethod..com.intellij.psi.PsiMethod?)

'method' @ [132:37] ==> value-parameter method: (PsiMethod..PsiMethod?) defined in org.jetbrains.kotlin.asJava.LightClassUtil.getPsiMethodWrappers.<anonymous>[ValueParameterDescriptorImpl]

'method' @ [132:64] ==> value-parameter method: (PsiMethod..PsiMethod?) defined in org.jetbrains.kotlin.asJava.LightClassUtil.getPsiMethodWrappers.<anonymous>[ValueParameterDescriptorImpl]

'kotlinOrigin' @ [132:71] ==> public abstract val kotlinOrigin: KtDeclaration? defined in org.jetbrains.kotlin.asJava.elements.KtLightMethod[PropertyDescriptorImpl]

'declaration' @ [132:88] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.asJava.LightClassUtil.getPsiMethodWrappers[ValueParameterDescriptorImpl]

'declaration' @ [136:27] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.asJava.LightClassUtil.getWrappingClass[ValueParameterDescriptorImpl]

'declaration' @ [137:13] ==> var declaration: KtDeclaration defined in org.jetbrains.kotlin.asJava.LightClassUtil.getWrappingClass[LocalVariableDescriptor]

'getClassIfParameterIsProperty' @ [138:46] ==> @Nullable public open fun getClassIfParameterIsProperty(@NotNull p0: KtParameter): KtClassOrObject? defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'declaration' @ [138:76] ==> var declaration: KtDeclaration defined in org.jetbrains.kotlin.asJava.LightClassUtil.getWrappingClass[LocalVariableDescriptor]

'constructorClass' @ [139:17] ==> val constructorClass: KtClassOrObject? defined in org.jetbrains.kotlin.asJava.LightClassUtil.getWrappingClass[LocalVariableDescriptor]

'constructorClass' @ [140:24] ==> val constructorClass: KtClassOrObject? defined in org.jetbrains.kotlin.asJava.LightClassUtil.getWrappingClass[LocalVariableDescriptor]

'toLightClass' @ [140:41] ==> public fun KtClassOrObject.toLightClass(): KtLightClass? defined in org.jetbrains.kotlin.asJava in file lightClassUtils.kt[SimpleFunctionDescriptorImpl]

'declaration' @ [144:13] ==> var declaration: KtDeclaration defined in org.jetbrains.kotlin.asJava.LightClassUtil.getWrappingClass[LocalVariableDescriptor]

'declaration' @ [145:13] ==> var declaration: KtDeclaration defined in org.jetbrains.kotlin.asJava.LightClassUtil.getWrappingClass[LocalVariableDescriptor]

'declaration' @ [145:27] ==> var declaration: KtDeclaration defined in org.jetbrains.kotlin.asJava.LightClassUtil.getWrappingClass[LocalVariableDescriptor]

'property' @ [145:39] ==> public final val KtPropertyAccessor.property: KtProperty[MyPropertyDescriptor]

'declaration' @ [148:13] ==> var declaration: KtDeclaration defined in org.jetbrains.kotlin.asJava.LightClassUtil.getWrappingClass[LocalVariableDescriptor]

'declaration' @ [149:20] ==> var declaration: KtDeclaration defined in org.jetbrains.kotlin.asJava.LightClassUtil.getWrappingClass[LocalVariableDescriptor]

'getContainingClassOrObject' @ [149:32] ==> public abstract fun getContainingClassOrObject(): KtClassOrObject defined in org.jetbrains.kotlin.psi.KtConstructor[DeserializedSimpleFunctionDescriptor]

'toLightClass' @ [149:61] ==> public fun KtClassOrObject.toLightClass(): KtLightClass? defined in org.jetbrains.kotlin.asJava in file lightClassUtils.kt[SimpleFunctionDescriptorImpl]

'declaration' @ [152:22] ==> var declaration: KtDeclaration defined in org.jetbrains.kotlin.asJava.LightClassUtil.getWrappingClass[LocalVariableDescriptor]

'parent' @ [152:34] ==> public final val KtDeclaration.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'if (parent is KtFile) {
            // top-level declaration
            return findFileFacade(parent)
        }
        else if (parent is KtClassBody) {
            assert(parent.parent is KtClassOrObject)
            return (parent.parent as KtClassOrObject).toLightClass()
        }' @ [154:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'parent' @ [154:13] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.asJava.LightClassUtil.getWrappingClass[LocalVariableDescriptor]

'findFileFacade' @ [156:20] ==> private final fun findFileFacade(ktFile: KtFile): PsiClass? defined in org.jetbrains.kotlin.asJava.LightClassUtil[SimpleFunctionDescriptorImpl]

'parent' @ [156:35] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.asJava.LightClassUtil.getWrappingClass[LocalVariableDescriptor]

'parent' @ [158:18] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.asJava.LightClassUtil.getWrappingClass[LocalVariableDescriptor]

'assert' @ [159:13] ==> @InlineOnly public inline fun assert(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'parent' @ [159:20] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.asJava.LightClassUtil.getWrappingClass[LocalVariableDescriptor]

'parent' @ [159:27] ==> public final val KtClassBody.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [160:21] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.asJava.LightClassUtil.getWrappingClass[LocalVariableDescriptor]

'parent' @ [160:28] ==> public final val KtClassBody.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'toLightClass' @ [160:55] ==> public fun KtClassOrObject.toLightClass(): KtLightClass? defined in org.jetbrains.kotlin.asJava in file lightClassUtils.kt[SimpleFunctionDescriptorImpl]

'ktFile' @ [167:22] ==> value-parameter ktFile: KtFile defined in org.jetbrains.kotlin.asJava.LightClassUtil.findFileFacade[ValueParameterDescriptorImpl]

'javaFileFacadeFqName' @ [167:29] ==> public val KtFile.javaFileFacadeFqName: FqName defined in org.jetbrains.kotlin.fileClasses[DeserializedPropertyDescriptor]

'ktFile' @ [168:23] ==> value-parameter ktFile: KtFile defined in org.jetbrains.kotlin.asJava.LightClassUtil.findFileFacade[ValueParameterDescriptorImpl]

'project' @ [168:30] ==> public final val KtFile.project: Project[MyPropertyDescriptor]

'getInstance' @ [169:59] ==> @NotNull public open fun getInstance(@NotNull project: Project): JavaElementFinder defined in org.jetbrains.kotlin.asJava.finder.JavaElementFinder[JavaMethodDescriptor]

'project' @ [169:71] ==> val project: Project defined in org.jetbrains.kotlin.asJava.LightClassUtil.findFileFacade[LocalVariableDescriptor]

'findClasses' @ [169:80] ==> @NotNull @Override public open fun findClasses(@NotNull qualifiedNameString: String, @NotNull scope: GlobalSearchScope): (Array<(PsiClass..PsiClass?)>..Array<out (PsiClass..PsiClass?)>) defined in org.jetbrains.kotlin.asJava.finder.JavaElementFinder[JavaMethodDescriptor]

'fqName' @ [169:92] ==> val fqName: FqName defined in org.jetbrains.kotlin.asJava.LightClassUtil.findFileFacade[LocalVariableDescriptor]

'asString' @ [169:99] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'allScope' @ [169:129] ==> @NotNull public open fun allScope(@NotNull p0: Project): GlobalSearchScope defined in com.intellij.psi.search.GlobalSearchScope[JavaMethodDescriptor]

'project' @ [169:138] ==> val project: Project defined in org.jetbrains.kotlin.asJava.LightClassUtil.findFileFacade[LocalVariableDescriptor]

'classesWithMatchingFqName' @ [170:16] ==> val classesWithMatchingFqName: (Array<(PsiClass..PsiClass?)>..Array<out (PsiClass..PsiClass?)>) defined in org.jetbrains.kotlin.asJava.LightClassUtil.findFileFacade[LocalVariableDescriptor]

'singleOrNull' @ [170:42] ==> public fun <T> Array<out (PsiClass..PsiClass?)>.singleOrNull(): PsiClass? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiClass..com.intellij.psi.PsiClass?)

'classesWithMatchingFqName' @ [171:16] ==> val classesWithMatchingFqName: (Array<(PsiClass..PsiClass?)>..Array<out (PsiClass..PsiClass?)>) defined in org.jetbrains.kotlin.asJava.LightClassUtil.findFileFacade[LocalVariableDescriptor]

'find' @ [171:42] ==> @InlineOnly public inline fun <T> Array<out (PsiClass..PsiClass?)>.find(predicate: ((PsiClass..PsiClass?)) -> Boolean): PsiClass? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.intellij.psi.PsiClass..com.intellij.psi.PsiClass?)

'it' @ [173:20] ==> value-parameter it: (PsiClass..PsiClass?) defined in org.jetbrains.kotlin.asJava.LightClassUtil.findFileFacade.<anonymous>[ValueParameterDescriptorImpl]

'containingFile' @ [173:23] ==> public final val PsiClass.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'virtualFile' @ [173:39] ==> public final val PsiFile.virtualFile: (VirtualFile..VirtualFile?)[MyPropertyDescriptor]

'ktFile' @ [173:54] ==> value-parameter ktFile: KtFile defined in org.jetbrains.kotlin.asJava.LightClassUtil.findFileFacade[ValueParameterDescriptorImpl]

'virtualFile' @ [173:61] ==> public final val KtFile.virtualFile: (VirtualFile..VirtualFile?)[MyPropertyDescriptor]

'getWrappingClass' @ [178:28] ==> private final fun getWrappingClass(declaration: KtDeclaration): PsiClass? defined in org.jetbrains.kotlin.asJava.LightClassUtil[SimpleFunctionDescriptorImpl]

'declaration' @ [178:45] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.asJava.LightClassUtil.getWrappingClasses[ValueParameterDescriptorImpl]

'emptySequence' @ [178:68] ==> public fun <T> emptySequence(): Sequence<PsiClass> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiClass

'wrapperClass' @ [179:35] ==> val wrapperClass: PsiClass defined in org.jetbrains.kotlin.asJava.LightClassUtil.getWrappingClasses[LocalVariableDescriptor]

'kotlinOrigin' @ [179:65] ==> public abstract val kotlinOrigin: KtClassOrObject? defined in org.jetbrains.kotlin.asJava.classes.KtLightClass[PropertyDescriptorImpl]

'wrapperClassOrigin' @ [180:13] ==> val wrapperClassOrigin: KtClassOrObject? defined in org.jetbrains.kotlin.asJava.LightClassUtil.getWrappingClasses[LocalVariableDescriptor]

'wrapperClassOrigin' @ [180:58] ==> val wrapperClassOrigin: KtClassOrObject? defined in org.jetbrains.kotlin.asJava.LightClassUtil.getWrappingClasses[LocalVariableDescriptor]

'isCompanion' @ [180:77] ==> public final fun isCompanion(): Boolean defined in org.jetbrains.kotlin.psi.KtObjectDeclaration[DeserializedSimpleFunctionDescriptor]

'wrapperClass' @ [180:94] ==> val wrapperClass: PsiClass defined in org.jetbrains.kotlin.asJava.LightClassUtil.getWrappingClasses[LocalVariableDescriptor]

'parent' @ [180:107] ==> public final val KtLightClass.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'sequenceOf' @ [181:20] ==> public fun <T> sequenceOf(vararg elements: PsiClass): Sequence<PsiClass> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiClass

'wrapperClass' @ [181:31] ==> val wrapperClass: PsiClass defined in org.jetbrains.kotlin.asJava.LightClassUtil.getWrappingClasses[LocalVariableDescriptor]

'wrapperClass' @ [181:45] ==> val wrapperClass: PsiClass defined in org.jetbrains.kotlin.asJava.LightClassUtil.getWrappingClasses[LocalVariableDescriptor]

'parent' @ [181:58] ==> public final val KtLightClass.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'sequenceOf' @ [183:16] ==> public fun <T> sequenceOf(vararg elements: KtLightClass): Sequence<KtLightClass> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtLightClass

'wrapperClass' @ [183:27] ==> val wrapperClass: PsiClass defined in org.jetbrains.kotlin.asJava.LightClassUtil.getWrappingClasses[LocalVariableDescriptor]

'==' @ [188:16] ==> public open fun equals(other: Any?): Boolean defined in org.jetbrains.kotlin.psi.KtCallableDeclaration[DeserializedSimpleFunctionDescriptor]

'getParentOfType' @ [188:28] ==> @SafeVarargs @Nullable @Contract public open fun <T : (PsiElement..PsiElement?)> getParentOfType(@Nullable p0: PsiElement?, @NotNull vararg p1: (Class<out (KtCallableDeclaration..KtCallableDeclaration?)>..Class<out (KtCallableDeclaration..KtCallableDeclaration?)>?)): KtCallableDeclaration? defined in com.intellij.psi.util.PsiTreeUtil[JavaMethodDescriptor]
Inferred types:
    <T : (PsiElement..PsiElement?)> -> KtCallableDeclaration

'declaration' @ [188:44] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.asJava.LightClassUtil.canGenerateLightClass[ValueParameterDescriptorImpl]

'java' @ [188:75] ==> public val <T> KClass<KtFunction>.java: Class<KtFunction> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtFunction

'java' @ [188:99] ==> public val <T> KClass<KtProperty>.java: Class<KtProperty> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtProperty

'specialGetter' @ [194:29] ==> value-parameter specialGetter: PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil.extractPropertyAccessors[ValueParameterDescriptorImpl]

'specialSetter' @ [195:29] ==> value-parameter specialSetter: PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil.extractPropertyAccessors[ValueParameterDescriptorImpl]

'arrayListOf' @ [196:35] ==> @SinceKotlin @InlineOnly public inline fun <T> arrayListOf(): ArrayList<PsiMethod> /* = ArrayList<PsiMethod> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiMethod

'getPsiMethodWrappers' @ [198:25] ==> private final fun getPsiMethodWrappers(declaration: KtDeclaration): Sequence<PsiMethod> defined in org.jetbrains.kotlin.asJava.LightClassUtil[SimpleFunctionDescriptorImpl]

'ktDeclaration' @ [198:46] ==> value-parameter ktDeclaration: KtDeclaration defined in org.jetbrains.kotlin.asJava.LightClassUtil.extractPropertyAccessors[ValueParameterDescriptorImpl]

'wrapper' @ [199:17] ==> val wrapper: PsiMethod defined in org.jetbrains.kotlin.asJava.LightClassUtil.extractPropertyAccessors[LocalVariableDescriptor]

'if (wrapper.isSetter) {
                if (setterWrapper == null || setterWrapper === specialSetter) {
                    setterWrapper = wrapper
                }
                else {
                    additionalAccessors.add(wrapper)
                }
            }
            else {
                if (getterWrapper == null || getterWrapper === specialGetter) {
                    getterWrapper = wrapper
                }
                else {
                    additionalAccessors.add(wrapper)
                }
            }' @ [201:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any, elseBranch: Any): Any[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any

'wrapper' @ [201:17] ==> val wrapper: PsiMethod defined in org.jetbrains.kotlin.asJava.LightClassUtil.extractPropertyAccessors[LocalVariableDescriptor]

'isSetter' @ [201:25] ==> public val KtLightMethod.isSetter: Boolean defined in org.jetbrains.kotlin.asJava.elements in file KtLightMethodImpl.kt[PropertyDescriptorImpl]

'if (setterWrapper == null || setterWrapper === specialSetter) {
                    setterWrapper = wrapper
                }
                else {
                    additionalAccessors.add(wrapper)
                }' @ [202:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any, elseBranch: Any): Any[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any

'setterWrapper' @ [202:21] ==> var setterWrapper: PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil.extractPropertyAccessors[LocalVariableDescriptor]

'setterWrapper' @ [202:46] ==> var setterWrapper: PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil.extractPropertyAccessors[LocalVariableDescriptor]

'specialSetter' @ [202:64] ==> value-parameter specialSetter: PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil.extractPropertyAccessors[ValueParameterDescriptorImpl]

'setterWrapper' @ [203:21] ==> var setterWrapper: PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil.extractPropertyAccessors[LocalVariableDescriptor]

'wrapper' @ [203:37] ==> val wrapper: PsiMethod defined in org.jetbrains.kotlin.asJava.LightClassUtil.extractPropertyAccessors[LocalVariableDescriptor]

'additionalAccessors' @ [206:21] ==> val additionalAccessors: ArrayList<PsiMethod> /* = ArrayList<PsiMethod> */ defined in org.jetbrains.kotlin.asJava.LightClassUtil.extractPropertyAccessors[LocalVariableDescriptor]

'add' @ [206:41] ==> public open fun add(element: PsiMethod): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'wrapper' @ [206:45] ==> val wrapper: PsiMethod defined in org.jetbrains.kotlin.asJava.LightClassUtil.extractPropertyAccessors[LocalVariableDescriptor]

'if (getterWrapper == null || getterWrapper === specialGetter) {
                    getterWrapper = wrapper
                }
                else {
                    additionalAccessors.add(wrapper)
                }' @ [210:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any, elseBranch: Any): Any[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any

'getterWrapper' @ [210:21] ==> var getterWrapper: PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil.extractPropertyAccessors[LocalVariableDescriptor]

'getterWrapper' @ [210:46] ==> var getterWrapper: PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil.extractPropertyAccessors[LocalVariableDescriptor]

'specialGetter' @ [210:64] ==> value-parameter specialGetter: PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil.extractPropertyAccessors[ValueParameterDescriptorImpl]

'getterWrapper' @ [211:21] ==> var getterWrapper: PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil.extractPropertyAccessors[LocalVariableDescriptor]

'wrapper' @ [211:37] ==> val wrapper: PsiMethod defined in org.jetbrains.kotlin.asJava.LightClassUtil.extractPropertyAccessors[LocalVariableDescriptor]

'additionalAccessors' @ [214:21] ==> val additionalAccessors: ArrayList<PsiMethod> /* = ArrayList<PsiMethod> */ defined in org.jetbrains.kotlin.asJava.LightClassUtil.extractPropertyAccessors[LocalVariableDescriptor]

'add' @ [214:41] ==> public open fun add(element: PsiMethod): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'wrapper' @ [214:45] ==> val wrapper: PsiMethod defined in org.jetbrains.kotlin.asJava.LightClassUtil.extractPropertyAccessors[LocalVariableDescriptor]

'getLightClassBackingField' @ [219:28] ==> public final fun getLightClassBackingField(declaration: KtDeclaration): PsiField? defined in org.jetbrains.kotlin.asJava.LightClassUtil[SimpleFunctionDescriptorImpl]

'ktDeclaration' @ [219:54] ==> value-parameter ktDeclaration: KtDeclaration defined in org.jetbrains.kotlin.asJava.LightClassUtil.extractPropertyAccessors[ValueParameterDescriptorImpl]

'PropertyAccessorsPsiMethods' @ [220:16] ==> public constructor PropertyAccessorsPsiMethods(getter: PsiMethod?, setter: PsiMethod?, backingField: PsiField?, additionalAccessors: List<PsiMethod>) defined in org.jetbrains.kotlin.asJava.LightClassUtil.PropertyAccessorsPsiMethods[ClassConstructorDescriptorImpl]

'getterWrapper' @ [220:44] ==> var getterWrapper: PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil.extractPropertyAccessors[LocalVariableDescriptor]

'setterWrapper' @ [220:59] ==> var setterWrapper: PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil.extractPropertyAccessors[LocalVariableDescriptor]

'backingField' @ [220:74] ==> val backingField: PsiField? defined in org.jetbrains.kotlin.asJava.LightClassUtil.extractPropertyAccessors[LocalVariableDescriptor]

'additionalAccessors' @ [220:88] ==> val additionalAccessors: ArrayList<PsiMethod> /* = ArrayList<PsiMethod> */ defined in org.jetbrains.kotlin.asJava.LightClassUtil.extractPropertyAccessors[LocalVariableDescriptor]

'KotlinLightTypeParameterListBuilder' @ [226:23] ==> public constructor KotlinLightTypeParameterListBuilder(manager: PsiManager) defined in org.jetbrains.kotlin.asJava.elements.KotlinLightTypeParameterListBuilder[ClassConstructorDescriptorImpl]

'owner' @ [226:59] ==> value-parameter owner: PsiTypeParameterListOwner defined in org.jetbrains.kotlin.asJava.LightClassUtil.buildLightTypeParameterList[ValueParameterDescriptorImpl]

'manager' @ [226:65] ==> public final val PsiTypeParameterListOwner.manager: (PsiManager..PsiManager?)[MyPropertyDescriptor]

'declaration' @ [227:13] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.asJava.LightClassUtil.buildLightTypeParameterList[ValueParameterDescriptorImpl]

'declaration' @ [228:30] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.asJava.LightClassUtil.buildLightTypeParameterList[ValueParameterDescriptorImpl]

'typeParameters' @ [228:42] ==> public final val KtTypeParameterListOwner.typeParameters: (MutableList<(KtTypeParameter..KtTypeParameter?)>..List<(KtTypeParameter..KtTypeParameter?)>)[MyPropertyDescriptor]

'parameters' @ [229:23] ==> val parameters: (MutableList<(KtTypeParameter..KtTypeParameter?)>..List<(KtTypeParameter..KtTypeParameter?)>) defined in org.jetbrains.kotlin.asJava.LightClassUtil.buildLightTypeParameterList[LocalVariableDescriptor]

'indices' @ [229:34] ==> public val Collection<*>.indices: IntRange defined in kotlin.collections[DeserializedPropertyDescriptor]

'parameters' @ [230:40] ==> val parameters: (MutableList<(KtTypeParameter..KtTypeParameter?)>..List<(KtTypeParameter..KtTypeParameter?)>) defined in org.jetbrains.kotlin.asJava.LightClassUtil.buildLightTypeParameterList[LocalVariableDescriptor]

'get' @ [230:51] ==> public abstract fun get(index: Int): (KtTypeParameter..KtTypeParameter?) defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'i' @ [230:55] ==> val i: Int defined in org.jetbrains.kotlin.asJava.LightClassUtil.buildLightTypeParameterList[LocalVariableDescriptor]

'jetTypeParameter' @ [231:28] ==> val jetTypeParameter: (KtTypeParameter..KtTypeParameter?) defined in org.jetbrains.kotlin.asJava.LightClassUtil.buildLightTypeParameterList[LocalVariableDescriptor]

'name' @ [231:45] ==> public final val KtTypeParameter.name: String?[MyPropertyDescriptor]

'name' @ [232:32] ==> val name: String? defined in org.jetbrains.kotlin.asJava.LightClassUtil.buildLightTypeParameterList[LocalVariableDescriptor]

'builder' @ [233:17] ==> val builder: KotlinLightTypeParameterListBuilder defined in org.jetbrains.kotlin.asJava.LightClassUtil.buildLightTypeParameterList[LocalVariableDescriptor]

'addParameter' @ [233:25] ==> public open fun addParameter(p0: (PsiTypeParameter..PsiTypeParameter?)): Unit defined in org.jetbrains.kotlin.asJava.elements.KotlinLightTypeParameterListBuilder[JavaMethodDescriptor]

'KtLightTypeParameter' @ [233:38] ==> public constructor KtLightTypeParameter(@NotNull owner: PsiTypeParameterListOwner, index: Int, @NotNull name: String) defined in org.jetbrains.kotlin.asJava.elements.KtLightTypeParameter[JavaClassConstructorDescriptor]

'owner' @ [233:59] ==> value-parameter owner: PsiTypeParameterListOwner defined in org.jetbrains.kotlin.asJava.LightClassUtil.buildLightTypeParameterList[ValueParameterDescriptorImpl]

'i' @ [233:66] ==> val i: Int defined in org.jetbrains.kotlin.asJava.LightClassUtil.buildLightTypeParameterList[LocalVariableDescriptor]

'safeName' @ [233:69] ==> val safeName: String defined in org.jetbrains.kotlin.asJava.LightClassUtil.buildLightTypeParameterList[LocalVariableDescriptor]

'builder' @ [236:16] ==> val builder: KotlinLightTypeParameterListBuilder defined in org.jetbrains.kotlin.asJava.LightClassUtil.buildLightTypeParameterList[LocalVariableDescriptor]

'allMethods' @ [247:13] ==> private final val allMethods: List<PsiMethod> defined in org.jetbrains.kotlin.asJava.LightClassUtil.PropertyAccessorsPsiMethods[PropertyDescriptorImpl]

'arrayListOf' @ [247:26] ==> @SinceKotlin @InlineOnly public inline fun <T> arrayListOf(): ArrayList<PsiMethod> /* = ArrayList<PsiMethod> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiMethod

'arrayOf' @ [248:13] ==> public inline fun <reified @PureReifiable T> arrayOf(vararg elements: PsiMethod?): Array<PsiMethod?> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified @PureReifiable T> -> PsiMethod?

'getter' @ [248:21] ==> public final val getter: PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil.PropertyAccessorsPsiMethods[PropertyDescriptorImpl]

'setter' @ [248:29] ==> public final val setter: PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil.PropertyAccessorsPsiMethods[PropertyDescriptorImpl]

'filterNotNullTo' @ [248:37] ==> public fun <C : MutableCollection<in PsiMethod>, T : Any> Array<out PsiMethod?>.filterNotNullTo(destination: ArrayList<PsiMethod> /* = ArrayList<PsiMethod> */): ArrayList<PsiMethod> /* = ArrayList<PsiMethod> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <C : MutableCollection<in T>> -> ArrayList<PsiMethod>
    <T : Any> -> PsiMethod

'allMethods' @ [248:53] ==> private final val allMethods: List<PsiMethod> defined in org.jetbrains.kotlin.asJava.LightClassUtil.PropertyAccessorsPsiMethods[PropertyDescriptorImpl]

'additionalAccessors' @ [249:13] ==> value-parameter additionalAccessors: List<PsiMethod> defined in org.jetbrains.kotlin.asJava.LightClassUtil.PropertyAccessorsPsiMethods.<init>[ValueParameterDescriptorImpl]

'filterIsInstanceTo' @ [249:33] ==> public inline fun <reified R, C : MutableCollection<in PsiMethod>> Iterable<*>.filterIsInstanceTo(destination: MutableList<PsiMethod>): MutableList<PsiMethod> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified R> -> PsiMethod
    <C : MutableCollection<in R>> -> MutableList<PsiMethod>

'allMethods' @ [249:87] ==> private final val allMethods: List<PsiMethod> defined in org.jetbrains.kotlin.asJava.LightClassUtil.PropertyAccessorsPsiMethods[PropertyDescriptorImpl]

'allDeclarations' @ [251:13] ==> public final val allDeclarations: List<PsiNamedElement> defined in org.jetbrains.kotlin.asJava.LightClassUtil.PropertyAccessorsPsiMethods[PropertyDescriptorImpl]

'arrayListOf' @ [251:31] ==> @SinceKotlin @InlineOnly public inline fun <T> arrayListOf(): ArrayList<PsiNamedElement> /* = ArrayList<PsiNamedElement> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiNamedElement

'arrayOf' @ [252:13] ==> public inline fun <reified @PureReifiable T> arrayOf(vararg elements: PsiNamedElement?): Array<PsiNamedElement?> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified @PureReifiable T> -> PsiNamedElement?

'getter' @ [252:39] ==> public final val getter: PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil.PropertyAccessorsPsiMethods[PropertyDescriptorImpl]

'setter' @ [252:47] ==> public final val setter: PsiMethod? defined in org.jetbrains.kotlin.asJava.LightClassUtil.PropertyAccessorsPsiMethods[PropertyDescriptorImpl]

'backingField' @ [252:55] ==> public final val backingField: PsiField? defined in org.jetbrains.kotlin.asJava.LightClassUtil.PropertyAccessorsPsiMethods[PropertyDescriptorImpl]

'filterNotNullTo' @ [252:69] ==> public fun <C : MutableCollection<in PsiNamedElement>, T : Any> Array<out PsiNamedElement?>.filterNotNullTo(destination: ArrayList<PsiNamedElement> /* = ArrayList<PsiNamedElement> */): ArrayList<PsiNamedElement> /* = ArrayList<PsiNamedElement> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <C : MutableCollection<in T>> -> ArrayList<PsiNamedElement>
    <T : Any> -> PsiNamedElement

'allDeclarations' @ [252:85] ==> public final val allDeclarations: List<PsiNamedElement> defined in org.jetbrains.kotlin.asJava.LightClassUtil.PropertyAccessorsPsiMethods[PropertyDescriptorImpl]

'allDeclarations' @ [253:13] ==> public final val allDeclarations: List<PsiNamedElement> defined in org.jetbrains.kotlin.asJava.LightClassUtil.PropertyAccessorsPsiMethods[PropertyDescriptorImpl]

'addAll' @ [253:29] ==> public open fun addAll(elements: Collection<PsiNamedElement>): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'additionalAccessors' @ [253:36] ==> value-parameter additionalAccessors: List<PsiMethod> defined in org.jetbrains.kotlin.asJava.LightClassUtil.PropertyAccessorsPsiMethods.<init>[ValueParameterDescriptorImpl]

'allMethods' @ [256:56] ==> private final val allMethods: List<PsiMethod> defined in org.jetbrains.kotlin.asJava.LightClassUtil.PropertyAccessorsPsiMethods[PropertyDescriptorImpl]

'iterator' @ [256:67] ==> public abstract fun iterator(): Iterator<PsiMethod> defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'when (this) {
        is KtProperty -> LightClassUtil.getLightClassPropertyMethods(this)
        is KtParameter -> LightClassUtil.getLightClassPropertyMethods(this)
        else -> throw IllegalStateException("Unexpected property type: ${this}")
    }' @ [261:12] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: LightClassUtil.PropertyAccessorsPsiMethods, entry1: LightClassUtil.PropertyAccessorsPsiMethods, entry2: LightClassUtil.PropertyAccessorsPsiMethods): LightClassUtil.PropertyAccessorsPsiMethods[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> PropertyAccessorsPsiMethods

'this' @ [261:18] ==> <this> defined in org.jetbrains.kotlin.asJava.getAccessorLightMethods[ReceiverParameterDescriptorImpl]

'LightClassUtil' @ [262:26] ==> public object LightClassUtil defined in org.jetbrains.kotlin.asJava in file LightClassUtil.kt[FakeCallableDescriptorForObject]

'getLightClassPropertyMethods' @ [262:41] ==> public final fun getLightClassPropertyMethods(property: KtProperty): LightClassUtil.PropertyAccessorsPsiMethods defined in org.jetbrains.kotlin.asJava.LightClassUtil[SimpleFunctionDescriptorImpl]

'this' @ [262:70] ==> <this> defined in org.jetbrains.kotlin.asJava.getAccessorLightMethods[ReceiverParameterDescriptorImpl]

'LightClassUtil' @ [263:27] ==> public object LightClassUtil defined in org.jetbrains.kotlin.asJava in file LightClassUtil.kt[FakeCallableDescriptorForObject]

'getLightClassPropertyMethods' @ [263:42] ==> public final fun getLightClassPropertyMethods(parameter: KtParameter): LightClassUtil.PropertyAccessorsPsiMethods defined in org.jetbrains.kotlin.asJava.LightClassUtil[SimpleFunctionDescriptorImpl]

'this' @ [263:71] ==> <this> defined in org.jetbrains.kotlin.asJava.getAccessorLightMethods[ReceiverParameterDescriptorImpl]

'IllegalStateException' @ [264:23] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'this' @ [264:74] ==> <this> defined in org.jetbrains.kotlin.asJava.getAccessorLightMethods[ReceiverParameterDescriptorImpl]

