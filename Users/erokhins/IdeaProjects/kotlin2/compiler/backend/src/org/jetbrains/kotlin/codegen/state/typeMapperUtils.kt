'function' @ [30:27] ==> value-parameter function: CallableMemberDescriptor defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[ValueParameterDescriptorImpl]

'containingDeclaration' @ [30:36] ==> public final val CallableMemberDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'function' @ [31:38] ==> value-parameter function: CallableMemberDescriptor defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[ValueParameterDescriptorImpl]

'typeParameters' @ [31:47] ==> public final val CallableMemberDescriptor.typeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'map' @ [31:62] ==> public inline fun <T, R> Iterable<(TypeParameterDescriptor..TypeParameterDescriptor?)>.map(transform: ((TypeParameterDescriptor..TypeParameterDescriptor?)) -> String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)
    <R> -> String

'it' @ [31:68] ==> value-parameter it: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [31:71] ==> public final val TypeParameterDescriptor.name: Name[MyPropertyDescriptor]

'asString' @ [31:76] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'classDescriptor' @ [32:35] ==> val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[LocalVariableDescriptor]

'declaredTypeParameters' @ [32:51] ==> public final val ClassDescriptor.declaredTypeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'interfaceTypeParameters' @ [33:36] ==> val interfaceTypeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[LocalVariableDescriptor]

'filter' @ [33:60] ==> public inline fun <T> Iterable<(TypeParameterDescriptor..TypeParameterDescriptor?)>.filter(predicate: ((TypeParameterDescriptor..TypeParameterDescriptor?)) -> Boolean): List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)

'it' @ [33:69] ==> value-parameter it: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [33:72] ==> public final val TypeParameterDescriptor.name: Name[MyPropertyDescriptor]

'asString' @ [33:77] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'functionTypeParameterNames' @ [33:91] ==> val functionTypeParameterNames: List<String> defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[LocalVariableDescriptor]

'conflictedTypeParameters' @ [35:9] ==> val conflictedTypeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[LocalVariableDescriptor]

'isEmpty' @ [35:34] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'ReceiverTypeAndTypeParameters' @ [36:16] ==> public constructor ReceiverTypeAndTypeParameters(receiverType: KotlinType, typeParameters: List<TypeParameterDescriptor>) defined in org.jetbrains.kotlin.codegen.state.ReceiverTypeAndTypeParameters[ClassConstructorDescriptorImpl]

'classDescriptor' @ [36:46] ==> val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[LocalVariableDescriptor]

'defaultType' @ [36:62] ==> public final val ClassDescriptor.defaultType: SimpleType[MyPropertyDescriptor]

'interfaceTypeParameters' @ [36:75] ==> val interfaceTypeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[LocalVariableDescriptor]

'functionTypeParameterNames' @ [38:26] ==> val functionTypeParameterNames: List<String> defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[LocalVariableDescriptor]

'interfaceTypeParameters' @ [38:55] ==> val interfaceTypeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[LocalVariableDescriptor]

'map' @ [38:79] ==> public inline fun <T, R> Iterable<(TypeParameterDescriptor..TypeParameterDescriptor?)>.map(transform: ((TypeParameterDescriptor..TypeParameterDescriptor?)) -> String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)
    <R> -> String

'it' @ [38:85] ==> value-parameter it: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [38:88] ==> public final val TypeParameterDescriptor.name: Name[MyPropertyDescriptor]

'asString' @ [38:93] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'toMutableSet' @ [38:107] ==> public fun <T> Iterable<String>.toMutableSet(): MutableSet<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'conflictedTypeParameters' @ [40:45] ==> val conflictedTypeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[LocalVariableDescriptor]

'associateBy' @ [40:70] ==> public inline fun <T, K, V> Iterable<(TypeParameterDescriptor..TypeParameterDescriptor?)>.associateBy(keySelector: ((TypeParameterDescriptor..TypeParameterDescriptor?)) -> (TypeParameterDescriptor..TypeParameterDescriptor?), valueTransform: ((TypeParameterDescriptor..TypeParameterDescriptor?)) -> TypeParameterDescriptorImpl): Map<(TypeParameterDescriptor..TypeParameterDescriptor?), TypeParameterDescriptorImpl> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)
    <K> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)
    <V> -> TypeParameterDescriptorImpl

'it' @ [40:85] ==> value-parameter it: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod.<anonymous>[ValueParameterDescriptorImpl]

'typeParameter' @ [43:29] ==> value-parameter typeParameter: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [43:43] ==> public final val TypeParameterDescriptor.name: Name[MyPropertyDescriptor]

'asString' @ [43:48] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'newNamePrefix' @ [44:23] ==> val newNamePrefix: String defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod.<anonymous>[LocalVariableDescriptor]

'generateSequence' @ [44:39] ==> @LowPriorityInOverloadResolution public fun <T : Any> generateSequence(seed: Int?, nextFunction: (Int) -> Int?): Sequence<Int> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> Int

'x' @ [44:66] ==> value-parameter x: Int defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'first' @ [44:74] ==> public inline fun <T> Sequence<Int>.first(predicate: (Int) -> Boolean): Int defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Int

'!in' @ [45:22] ==> public abstract fun contains(element: String): Boolean defined in kotlin.collections.MutableSet[DeserializedSimpleFunctionDescriptor]

'newNamePrefix' @ [45:23] ==> val newNamePrefix: String defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod.<anonymous>[LocalVariableDescriptor]

'index' @ [45:39] ==> value-parameter index: Int defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'existingNames' @ [45:50] ==> val existingNames: MutableSet<String> defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[LocalVariableDescriptor]

'existingNames' @ [48:9] ==> val existingNames: MutableSet<String> defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[LocalVariableDescriptor]

'add' @ [48:23] ==> public abstract fun add(element: String): Boolean defined in kotlin.collections.MutableSet[DeserializedSimpleFunctionDescriptor]

'newName' @ [48:27] ==> val newName: String defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod.<anonymous>[LocalVariableDescriptor]

'function' @ [49:9] ==> value-parameter function: CallableMemberDescriptor defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[ValueParameterDescriptorImpl]

'createTypeParameterWithNewName' @ [49:18] ==> public fun CallableMemberDescriptor.createTypeParameterWithNewName(descriptor: TypeParameterDescriptor, newName: String): TypeParameterDescriptorImpl defined in org.jetbrains.kotlin.codegen.state in file typeMapperUtils.kt[SimpleFunctionDescriptorImpl]

'typeParameter' @ [49:49] ==> value-parameter typeParameter: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod.<anonymous>[ValueParameterDescriptorImpl]

'newName' @ [49:64] ==> val newName: String defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod.<anonymous>[LocalVariableDescriptor]

'TypeConstructorSubstitution' @ [52:24] ==> public companion object defined in org.jetbrains.kotlin.types.TypeConstructorSubstitution[FakeCallableDescriptorForObject]

'createByParametersMap' @ [52:52] ==> @JvmStatic public final fun createByParametersMap(map: Map<TypeParameterDescriptor, TypeProjection>): TypeConstructorSubstitution defined in org.jetbrains.kotlin.types.TypeConstructorSubstitution.Companion[DeserializedSimpleFunctionDescriptor]

'mappingForInterfaceTypeParameters' @ [52:74] ==> val mappingForInterfaceTypeParameters: Map<(TypeParameterDescriptor..TypeParameterDescriptor?), TypeParameterDescriptorImpl> defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[LocalVariableDescriptor]

'mapValues' @ [52:108] ==> public inline fun <K, V, R> Map<out TypeParameterDescriptor, TypeParameterDescriptorImpl>.mapValues(transform: (Map.Entry<TypeParameterDescriptor, TypeParameterDescriptorImpl>) -> TypeProjection): Map<TypeParameterDescriptor, TypeProjection> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> TypeParameterDescriptor
    <V> -> TypeParameterDescriptorImpl
    <R> -> TypeProjection

'it' @ [53:9] ==> value-parameter it: Map.Entry<(TypeParameterDescriptor..TypeParameterDescriptor?), TypeParameterDescriptorImpl> defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [53:12] ==> public abstract val value: TypeParameterDescriptorImpl defined in kotlin.collections.Map.Entry[DeserializedPropertyDescriptor]

'defaultType' @ [53:18] ==> public final val TypeParameterDescriptorImpl.defaultType: SimpleType[MyPropertyDescriptor]

'asTypeProjection' @ [53:30] ==> public fun KotlinType.asTypeProjection(): TypeProjection defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'create' @ [56:39] ==> @NotNull public open fun create(@NotNull p0: TypeSubstitution): TypeSubstitutor defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'substitution' @ [56:46] ==> val substitution: TypeConstructorSubstitution defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[LocalVariableDescriptor]

'interfaceTypeParameters' @ [58:36] ==> val interfaceTypeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[LocalVariableDescriptor]

'map' @ [58:60] ==> public inline fun <T, R> Iterable<(TypeParameterDescriptor..TypeParameterDescriptor?)>.map(transform: ((TypeParameterDescriptor..TypeParameterDescriptor?)) -> (TypeParameterDescriptor..TypeParameterDescriptor?)): List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)
    <R> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)

'mappingForInterfaceTypeParameters' @ [59:9] ==> val mappingForInterfaceTypeParameters: Map<(TypeParameterDescriptor..TypeParameterDescriptor?), TypeParameterDescriptorImpl> defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[LocalVariableDescriptor]

'typeParameter' @ [59:43] ==> value-parameter typeParameter: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod.<anonymous>[ValueParameterDescriptorImpl]

'typeParameter' @ [59:61] ==> value-parameter typeParameter: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod.<anonymous>[ValueParameterDescriptorImpl]

'mutableListOf' @ [61:32] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableListOf(): MutableList<TypeParameterDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeParameterDescriptor

'substituteTypeParameters' @ [62:27] ==> @NotNull public open fun substituteTypeParameters(@ReadOnly @NotNull p0: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>, @NotNull p1: TypeSubstitution, @NotNull p2: DeclarationDescriptor, @NotNull @Mutable p3: MutableList<(TypeParameterDescriptor..TypeParameterDescriptor?)>): TypeSubstitutor defined in org.jetbrains.kotlin.types.DescriptorSubstitutor[JavaMethodDescriptor]

'additionalTypeParameters' @ [62:52] ==> val additionalTypeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[LocalVariableDescriptor]

'substitution' @ [62:78] ==> val substitution: TypeConstructorSubstitution defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[LocalVariableDescriptor]

'classDescriptor' @ [62:92] ==> val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[LocalVariableDescriptor]

'resultTypeParameters' @ [62:109] ==> var resultTypeParameters: MutableList<TypeParameterDescriptor> defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[LocalVariableDescriptor]

'ReceiverTypeAndTypeParameters' @ [64:12] ==> public constructor ReceiverTypeAndTypeParameters(receiverType: KotlinType, typeParameters: List<TypeParameterDescriptor>) defined in org.jetbrains.kotlin.codegen.state.ReceiverTypeAndTypeParameters[ClassConstructorDescriptorImpl]

'substitutor' @ [64:42] ==> val substitutor: TypeSubstitutor defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[LocalVariableDescriptor]

'substitute' @ [64:54] ==> @Nullable public open fun substitute(@NotNull p0: KotlinType, @NotNull p1: Variance): KotlinType? defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'classDescriptor' @ [64:65] ==> val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[LocalVariableDescriptor]

'defaultType' @ [64:81] ==> public final val ClassDescriptor.defaultType: SimpleType[MyPropertyDescriptor]

'INVARIANT' @ [64:103] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'resultTypeParameters' @ [64:117] ==> var resultTypeParameters: MutableList<TypeParameterDescriptor> defined in org.jetbrains.kotlin.codegen.state.patchTypeParametersForDefaultImplMethod[LocalVariableDescriptor]

'createForFurtherModification' @ [68:53] ==> public open fun createForFurtherModification(@NotNull p0: DeclarationDescriptor, @NotNull p1: Annotations, p2: Boolean, @NotNull p3: Variance, @NotNull p4: Name, p5: Int, @NotNull p6: SourceElement): (TypeParameterDescriptorImpl..TypeParameterDescriptorImpl?) defined in org.jetbrains.kotlin.descriptors.impl.TypeParameterDescriptorImpl[JavaMethodDescriptor]

'this' @ [69:13] ==> <this> defined in org.jetbrains.kotlin.codegen.state.createTypeParameterWithNewName[ReceiverParameterDescriptorImpl]

'descriptor' @ [70:13] ==> value-parameter descriptor: TypeParameterDescriptor defined in org.jetbrains.kotlin.codegen.state.createTypeParameterWithNewName[ValueParameterDescriptorImpl]

'annotations' @ [70:24] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.descriptors.TypeParameterDescriptor[DeserializedPropertyDescriptor]

'descriptor' @ [71:13] ==> value-parameter descriptor: TypeParameterDescriptor defined in org.jetbrains.kotlin.codegen.state.createTypeParameterWithNewName[ValueParameterDescriptorImpl]

'isReified' @ [71:24] ==> public final val TypeParameterDescriptor.isReified: Boolean[MyPropertyDescriptor]

'descriptor' @ [72:13] ==> value-parameter descriptor: TypeParameterDescriptor defined in org.jetbrains.kotlin.codegen.state.createTypeParameterWithNewName[ValueParameterDescriptorImpl]

'variance' @ [72:24] ==> public final val TypeParameterDescriptor.variance: Variance[MyPropertyDescriptor]

'identifier' @ [73:18] ==> @NotNull public open fun identifier(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'newName' @ [73:29] ==> value-parameter newName: String defined in org.jetbrains.kotlin.codegen.state.createTypeParameterWithNewName[ValueParameterDescriptorImpl]

'descriptor' @ [74:13] ==> value-parameter descriptor: TypeParameterDescriptor defined in org.jetbrains.kotlin.codegen.state.createTypeParameterWithNewName[ValueParameterDescriptorImpl]

'index' @ [74:24] ==> public final val TypeParameterDescriptor.index: Int[MyPropertyDescriptor]

'descriptor' @ [75:13] ==> value-parameter descriptor: TypeParameterDescriptor defined in org.jetbrains.kotlin.codegen.state.createTypeParameterWithNewName[ValueParameterDescriptorImpl]

'source' @ [75:24] ==> public final val TypeParameterDescriptor.source: SourceElement[MyPropertyDescriptor]

'descriptor' @ [76:5] ==> value-parameter descriptor: TypeParameterDescriptor defined in org.jetbrains.kotlin.codegen.state.createTypeParameterWithNewName[ValueParameterDescriptorImpl]

'upperBounds' @ [76:16] ==> public final val TypeParameterDescriptor.upperBounds: (MutableList<(KotlinType..KotlinType?)>..List<(KotlinType..KotlinType?)>)[MyPropertyDescriptor]

'forEach' @ [76:28] ==> @HidesMembers public inline fun <T> Iterable<(KotlinType..KotlinType?)>.forEach(action: ((KotlinType..KotlinType?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)

'newDescriptor' @ [77:9] ==> val newDescriptor: (TypeParameterDescriptorImpl..TypeParameterDescriptorImpl?) defined in org.jetbrains.kotlin.codegen.state.createTypeParameterWithNewName[LocalVariableDescriptor]

'addUpperBound' @ [77:23] ==> public open fun addUpperBound(@NotNull p0: KotlinType): Unit defined in org.jetbrains.kotlin.descriptors.impl.TypeParameterDescriptorImpl[JavaMethodDescriptor]

'it' @ [77:37] ==> value-parameter it: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.codegen.state.createTypeParameterWithNewName.<anonymous>[ValueParameterDescriptorImpl]

'newDescriptor' @ [79:5] ==> val newDescriptor: (TypeParameterDescriptorImpl..TypeParameterDescriptorImpl?) defined in org.jetbrains.kotlin.codegen.state.createTypeParameterWithNewName[LocalVariableDescriptor]

'setInitialized' @ [79:19] ==> public open fun setInitialized(): Unit defined in org.jetbrains.kotlin.descriptors.impl.TypeParameterDescriptorImpl[JavaMethodDescriptor]

'newDescriptor' @ [80:12] ==> val newDescriptor: (TypeParameterDescriptorImpl..TypeParameterDescriptorImpl?) defined in org.jetbrains.kotlin.codegen.state.createTypeParameterWithNewName[LocalVariableDescriptor]

'arguments' @ [84:24] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'map' @ [84:34] ==> public inline fun <T, R> Iterable<TypeProjection>.map(transform: (TypeProjection) -> TypeProjectionImpl): List<TypeProjectionImpl> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection
    <R> -> TypeProjectionImpl

'TypeProjectionImpl' @ [84:40] ==> public constructor TypeProjectionImpl(@NotNull p0: Variance, @NotNull p1: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'INVARIANT' @ [84:68] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'it' @ [84:79] ==> value-parameter it: TypeProjection defined in org.jetbrains.kotlin.codegen.state.removeExternalProjections.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [84:82] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'replace' @ [85:12] ==> @JvmOverloads public fun KotlinType.replace(newArguments: List<TypeProjection> = ..., newAnnotations: Annotations = ...): KotlinType defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'newArguments' @ [85:20] ==> val newArguments: List<TypeProjectionImpl> defined in org.jetbrains.kotlin.codegen.state.removeExternalProjections[LocalVariableDescriptor]

