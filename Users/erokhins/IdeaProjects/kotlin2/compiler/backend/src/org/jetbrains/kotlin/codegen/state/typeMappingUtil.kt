'JvmName' @ [17:1] ==> public constructor JvmName(name: String) defined in kotlin.jvm.JvmName[DeserializedClassConstructorDescriptor]

'isAnyOrNullableAny' @ [37:24] ==> public open fun isAnyOrNullableAny(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'this' @ [37:43] ==> <this> defined in org.jetbrains.kotlin.codegen.state.isMostPreciseContravariantArgument[ReceiverParameterDescriptorImpl]

'!' @ [39:60] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'canHaveSubtypesIgnoringNullability' @ [39:61] ==> private fun KotlinType.canHaveSubtypesIgnoringNullability(): Boolean defined in org.jetbrains.kotlin.codegen.state in file typeMappingUtil.kt[SimpleFunctionDescriptorImpl]

'constructor' @ [42:23] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'constructor' @ [43:22] ==> val constructor: TypeConstructor defined in org.jetbrains.kotlin.codegen.state.canHaveSubtypesIgnoringNullability[LocalVariableDescriptor]

'declarationDescriptor' @ [43:34] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'when (descriptor) {
        is TypeParameterDescriptor -> return true
        is ClassDescriptor -> if (!descriptor.isFinalClass) return true
    }' @ [45:5] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'descriptor' @ [45:11] ==> val descriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.codegen.state.canHaveSubtypesIgnoringNullability[LocalVariableDescriptor]

'!' @ [47:35] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'descriptor' @ [47:36] ==> val descriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.codegen.state.canHaveSubtypesIgnoringNullability[LocalVariableDescriptor]

'isFinalClass' @ [47:47] ==> public val ClassDescriptor.isFinalClass: Boolean defined in org.jetbrains.kotlin.descriptors[DeserializedPropertyDescriptor]

'component1' @ [50:11] ==> public final operator fun component1(): (TypeParameterDescriptor..TypeParameterDescriptor?) defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [50:22] ==> public final operator fun component2(): TypeProjection defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'constructor' @ [50:35] ==> val constructor: TypeConstructor defined in org.jetbrains.kotlin.codegen.state.canHaveSubtypesIgnoringNullability[LocalVariableDescriptor]

'parameters' @ [50:47] ==> public final val TypeConstructor.parameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'zip' @ [50:58] ==> public infix fun <T, R> Iterable<(TypeParameterDescriptor..TypeParameterDescriptor?)>.zip(other: Iterable<TypeProjection>): List<Pair<(TypeParameterDescriptor..TypeParameterDescriptor?), TypeProjection>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)
    <R> -> TypeProjection

'arguments' @ [50:62] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'argument' @ [51:13] ==> val argument: TypeProjection defined in org.jetbrains.kotlin.codegen.state.canHaveSubtypesIgnoringNullability[LocalVariableDescriptor]

'isStarProjection' @ [51:22] ==> public final val TypeProjection.isStarProjection: Boolean[MyPropertyDescriptor]

'argument' @ [52:30] ==> val argument: TypeProjection defined in org.jetbrains.kotlin.codegen.state.canHaveSubtypesIgnoringNullability[LocalVariableDescriptor]

'projectionKind' @ [52:39] ==> public final val TypeProjection.projectionKind: Variance[MyPropertyDescriptor]

'argument' @ [53:20] ==> val argument: TypeProjection defined in org.jetbrains.kotlin.codegen.state.canHaveSubtypesIgnoringNullability[LocalVariableDescriptor]

'type' @ [53:29] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'getEffectiveVariance' @ [55:33] ==> public fun getEffectiveVariance(parameterVariance: Variance, projectionKind: Variance): Variance defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'parameter' @ [55:54] ==> val parameter: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.codegen.state.canHaveSubtypesIgnoringNullability[LocalVariableDescriptor]

'variance' @ [55:64] ==> public final val TypeParameterDescriptor.variance: Variance[MyPropertyDescriptor]

'projectionKind' @ [55:74] ==> val projectionKind: Variance defined in org.jetbrains.kotlin.codegen.state.canHaveSubtypesIgnoringNullability[LocalVariableDescriptor]

'effectiveVariance' @ [56:13] ==> val effectiveVariance: Variance defined in org.jetbrains.kotlin.codegen.state.canHaveSubtypesIgnoringNullability[LocalVariableDescriptor]

'OUT_VARIANCE' @ [56:43] ==> enum entry OUT_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'!' @ [56:59] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'type' @ [56:60] ==> val type: KotlinType defined in org.jetbrains.kotlin.codegen.state.canHaveSubtypesIgnoringNullability[LocalVariableDescriptor]

'isMostPreciseCovariantArgument' @ [56:65] ==> public fun KotlinType.isMostPreciseCovariantArgument(): Boolean defined in org.jetbrains.kotlin.codegen.state in file typeMappingUtil.kt[SimpleFunctionDescriptorImpl]

'effectiveVariance' @ [57:13] ==> val effectiveVariance: Variance defined in org.jetbrains.kotlin.codegen.state.canHaveSubtypesIgnoringNullability[LocalVariableDescriptor]

'IN_VARIANCE' @ [57:43] ==> enum entry IN_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'!' @ [57:58] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'type' @ [57:59] ==> val type: KotlinType defined in org.jetbrains.kotlin.codegen.state.canHaveSubtypesIgnoringNullability[LocalVariableDescriptor]

'isMostPreciseContravariantArgument' @ [57:64] ==> public fun KotlinType.isMostPreciseContravariantArgument(parameter: TypeParameterDescriptor): Boolean defined in org.jetbrains.kotlin.codegen.state in file typeMappingUtil.kt[SimpleFunctionDescriptorImpl]

'parameter' @ [57:99] ==> val parameter: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.codegen.state.canHaveSubtypesIgnoringNullability[LocalVariableDescriptor]

'this' @ [65:13] ==> <this> defined in org.jetbrains.kotlin.codegen.state.isMethodWithDeclarationSiteWildcards[ReceiverParameterDescriptorImpl]

'original' @ [66:16] ==> public final val CallableMemberDescriptor.original: CallableMemberDescriptor[MyPropertyDescriptor]

'firstOverridden' @ [66:25] ==> public fun CallableMemberDescriptor.firstOverridden(useOriginal: Boolean = ..., predicate: (CallableMemberDescriptor) -> Boolean): CallableMemberDescriptor? defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedSimpleFunctionDescriptor]

'METHODS_WITH_DECLARATION_SITE_WILDCARDS' @ [67:13] ==> private val METHODS_WITH_DECLARATION_SITE_WILDCARDS: Set<FqName> defined in org.jetbrains.kotlin.codegen.state in file typeMappingUtil.kt[PropertyDescriptorImpl]

'contains' @ [67:53] ==> public operator fun <@OnlyInputTypes T> Iterable<FqName?>.contains(element: FqName?): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <@OnlyInputTypes T> -> FqName?

'it' @ [67:62] ==> value-parameter it: CallableMemberDescriptor defined in org.jetbrains.kotlin.codegen.state.<get-isMethodWithDeclarationSiteWildcards>.<anonymous>[ValueParameterDescriptorImpl]

'propertyIfAccessor' @ [67:65] ==> public val CallableMemberDescriptor.propertyIfAccessor: CallableMemberDescriptor defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'fqNameOrNull' @ [67:84] ==> public fun CallableDescriptor.fqNameOrNull(): FqName? defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedSimpleFunctionDescriptor]

'child' @ [71:50] ==> @NotNull public open fun child(@NotNull p0: Name): FqName defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'identifier' @ [71:61] ==> @NotNull public open fun identifier(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'name' @ [71:72] ==> value-parameter name: String defined in org.jetbrains.kotlin.codegen.state.child[ValueParameterDescriptorImpl]

'setOf' @ [72:55] ==> public fun <T> setOf(vararg elements: FqName): Set<FqName> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FqName

'BUILTIN_NAMES' @ [73:9] ==> public final val FQ_NAMES: (KotlinBuiltIns.FqNames..KotlinBuiltIns.FqNames?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaPropertyDescriptor]

'mutableCollection' @ [73:23] ==> public final val mutableCollection: (FqName..FqName?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns.FqNames[JavaPropertyDescriptor]

'child' @ [73:41] ==> private fun FqName.child(name: String): FqName defined in org.jetbrains.kotlin.codegen.state in file typeMappingUtil.kt[SimpleFunctionDescriptorImpl]

'BUILTIN_NAMES' @ [74:9] ==> public final val FQ_NAMES: (KotlinBuiltIns.FqNames..KotlinBuiltIns.FqNames?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaPropertyDescriptor]

'mutableList' @ [74:23] ==> public final val mutableList: (FqName..FqName?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns.FqNames[JavaPropertyDescriptor]

'child' @ [74:35] ==> private fun FqName.child(name: String): FqName defined in org.jetbrains.kotlin.codegen.state in file typeMappingUtil.kt[SimpleFunctionDescriptorImpl]

'BUILTIN_NAMES' @ [75:9] ==> public final val FQ_NAMES: (KotlinBuiltIns.FqNames..KotlinBuiltIns.FqNames?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaPropertyDescriptor]

'mutableMap' @ [75:23] ==> public final val mutableMap: (FqName..FqName?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns.FqNames[JavaPropertyDescriptor]

'child' @ [75:34] ==> private fun FqName.child(name: String): FqName defined in org.jetbrains.kotlin.codegen.state in file typeMappingUtil.kt[SimpleFunctionDescriptorImpl]

'type' @ [79:5] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.codegen.state.updateArgumentModeFromAnnotations[ValueParameterDescriptorImpl]

'suppressWildcardsMode' @ [79:10] ==> private fun KotlinType.suppressWildcardsMode(): Boolean? defined in org.jetbrains.kotlin.codegen.state in file typeMappingUtil.kt[SimpleFunctionDescriptorImpl]

'let' @ [79:35] ==> @InlineOnly public inline fun <T, R> Boolean.let(block: (Boolean) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Boolean
    <R> -> Nothing

'TypeMappingMode' @ [80:16] ==> public companion object defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode[FakeCallableDescriptorForObject]

'createWithConstantDeclarationSiteWildcardsMode' @ [80:32] ==> @JvmStatic public final fun createWithConstantDeclarationSiteWildcardsMode(skipDeclarationSiteWildcards: Boolean, isForAnnotationParameter: Boolean, fallbackMode: TypeMappingMode? = ...): TypeMappingMode defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion[DeserializedSimpleFunctionDescriptor]

'it' @ [81:48] ==> value-parameter it: Boolean defined in org.jetbrains.kotlin.codegen.state.updateArgumentModeFromAnnotations.<anonymous>[ValueParameterDescriptorImpl]

'isForAnnotationParameter' @ [81:79] ==> public final val isForAnnotationParameter: Boolean defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode[DeserializedPropertyDescriptor]

'type' @ [84:9] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.codegen.state.updateArgumentModeFromAnnotations[ValueParameterDescriptorImpl]

'annotations' @ [84:14] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'hasAnnotation' @ [84:26] ==> public open fun hasAnnotation(fqName: FqName): Boolean defined in org.jetbrains.kotlin.descriptors.annotations.Annotations[DeserializedSimpleFunctionDescriptor]

'JVM_WILDCARD_ANNOTATION_FQ_NAME' @ [84:40] ==> private val JVM_WILDCARD_ANNOTATION_FQ_NAME: FqName defined in org.jetbrains.kotlin.codegen.state in file typeMappingUtil.kt[PropertyDescriptorImpl]

'TypeMappingMode' @ [85:16] ==> public companion object defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode[FakeCallableDescriptorForObject]

'createWithConstantDeclarationSiteWildcardsMode' @ [85:32] ==> @JvmStatic public final fun createWithConstantDeclarationSiteWildcardsMode(skipDeclarationSiteWildcards: Boolean, isForAnnotationParameter: Boolean, fallbackMode: TypeMappingMode? = ...): TypeMappingMode defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion[DeserializedSimpleFunctionDescriptor]

'isForAnnotationParameter' @ [86:82] ==> public final val isForAnnotationParameter: Boolean defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode[DeserializedPropertyDescriptor]

'this' @ [86:123] ==> <this> defined in org.jetbrains.kotlin.codegen.state.updateArgumentModeFromAnnotations[ReceiverParameterDescriptorImpl]

'this' @ [89:12] ==> <this> defined in org.jetbrains.kotlin.codegen.state.updateArgumentModeFromAnnotations[ReceiverParameterDescriptorImpl]

'outerType' @ [97:10] ==> value-parameter outerType: KotlinType defined in org.jetbrains.kotlin.codegen.state.extractTypeMappingModeFromAnnotation[ValueParameterDescriptorImpl]

'suppressWildcardsMode' @ [97:20] ==> private fun KotlinType.suppressWildcardsMode(): Boolean? defined in org.jetbrains.kotlin.codegen.state in file typeMappingUtil.kt[SimpleFunctionDescriptorImpl]

'callableDescriptor' @ [97:47] ==> value-parameter callableDescriptor: CallableDescriptor? defined in org.jetbrains.kotlin.codegen.state.extractTypeMappingModeFromAnnotation[ValueParameterDescriptorImpl]

'suppressWildcardsMode' @ [97:67] ==> private fun DeclarationDescriptor.suppressWildcardsMode(): Boolean? defined in org.jetbrains.kotlin.codegen.state in file typeMappingUtil.kt[SimpleFunctionDescriptorImpl]

'let' @ [97:93] ==> @InlineOnly public inline fun <T, R> Boolean.let(block: (Boolean) -> TypeMappingMode?): TypeMappingMode? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Boolean
    <R> -> TypeMappingMode?

'if (outerType.arguments.isNotEmpty())
                TypeMappingMode.createWithConstantDeclarationSiteWildcardsMode(
                        skipDeclarationSiteWildcards = it, isForAnnotationParameter = isForAnnotationParameter)
            else
                TypeMappingMode.DEFAULT' @ [98:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: TypeMappingMode?, elseBranch: TypeMappingMode?): TypeMappingMode?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> TypeMappingMode?

'outerType' @ [98:17] ==> value-parameter outerType: KotlinType defined in org.jetbrains.kotlin.codegen.state.extractTypeMappingModeFromAnnotation[ValueParameterDescriptorImpl]

'arguments' @ [98:27] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'isNotEmpty' @ [98:37] ==> @InlineOnly public inline fun <T> Collection<TypeProjection>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection

'createWithConstantDeclarationSiteWildcardsMode' @ [99:33] ==> @JvmStatic public final fun createWithConstantDeclarationSiteWildcardsMode(skipDeclarationSiteWildcards: Boolean, isForAnnotationParameter: Boolean, fallbackMode: TypeMappingMode? = ...): TypeMappingMode defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion[DeserializedSimpleFunctionDescriptor]

'it' @ [100:56] ==> value-parameter it: Boolean defined in org.jetbrains.kotlin.codegen.state.extractTypeMappingModeFromAnnotation.<anonymous>[ValueParameterDescriptorImpl]

'isForAnnotationParameter' @ [100:87] ==> value-parameter isForAnnotationParameter: Boolean defined in org.jetbrains.kotlin.codegen.state.extractTypeMappingModeFromAnnotation[ValueParameterDescriptorImpl]

'DEFAULT' @ [102:33] ==> @field:JvmField public final val DEFAULT: TypeMappingMode defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion[DeserializedPropertyDescriptor]

'parentsWithSelf' @ [106:9] ==> public val DeclarationDescriptor.parentsWithSelf: Sequence<DeclarationDescriptor> defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'mapNotNull' @ [106:25] ==> public fun <T, R : Any> Sequence<DeclarationDescriptor>.mapNotNull(transform: (DeclarationDescriptor) -> AnnotationDescriptor?): Sequence<AnnotationDescriptor> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DeclarationDescriptor
    <R : Any> -> AnnotationDescriptor

'it' @ [107:13] ==> value-parameter it: DeclarationDescriptor defined in org.jetbrains.kotlin.codegen.state.suppressWildcardsMode.<anonymous>[ValueParameterDescriptorImpl]

'annotations' @ [107:16] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.descriptors.DeclarationDescriptor[DeserializedPropertyDescriptor]

'findAnnotation' @ [107:28] ==> public open fun findAnnotation(fqName: FqName): AnnotationDescriptor? defined in org.jetbrains.kotlin.descriptors.annotations.Annotations[DeserializedSimpleFunctionDescriptor]

'JVM_SUPPRESS_WILDCARDS_ANNOTATION_FQ_NAME' @ [107:43] ==> private val JVM_SUPPRESS_WILDCARDS_ANNOTATION_FQ_NAME: FqName defined in org.jetbrains.kotlin.codegen.state in file typeMappingUtil.kt[PropertyDescriptorImpl]

'firstOrNull' @ [108:11] ==> public fun <T> Sequence<AnnotationDescriptor>.firstOrNull(): AnnotationDescriptor? defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> AnnotationDescriptor

'suppressWildcardsMode' @ [108:25] ==> private fun AnnotationDescriptor?.suppressWildcardsMode(): Boolean? defined in org.jetbrains.kotlin.codegen.state in file typeMappingUtil.kt[SimpleFunctionDescriptorImpl]

'annotations' @ [111:9] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'findAnnotation' @ [111:21] ==> public open fun findAnnotation(fqName: FqName): AnnotationDescriptor? defined in org.jetbrains.kotlin.descriptors.annotations.Annotations[DeserializedSimpleFunctionDescriptor]

'JVM_SUPPRESS_WILDCARDS_ANNOTATION_FQ_NAME' @ [111:36] ==> private val JVM_SUPPRESS_WILDCARDS_ANNOTATION_FQ_NAME: FqName defined in org.jetbrains.kotlin.codegen.state in file typeMappingUtil.kt[PropertyDescriptorImpl]

'suppressWildcardsMode' @ [111:79] ==> private fun AnnotationDescriptor?.suppressWildcardsMode(): Boolean? defined in org.jetbrains.kotlin.codegen.state in file typeMappingUtil.kt[SimpleFunctionDescriptorImpl]

'?:' @ [114:12] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: Boolean?, right: Boolean?): Boolean?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> Boolean?

'this' @ [114:13] ==> <this> defined in org.jetbrains.kotlin.codegen.state.suppressWildcardsMode[ReceiverParameterDescriptorImpl]

'allValueArguments' @ [114:34] ==> public abstract val allValueArguments: Map<Name, ConstantValue<*>> defined in org.jetbrains.kotlin.descriptors.annotations.AnnotationDescriptor[DeserializedPropertyDescriptor]

'values' @ [114:52] ==> public abstract val values: Collection<ConstantValue<*>> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'firstOrNull' @ [114:59] ==> public fun <T> Iterable<ConstantValue<*>>.firstOrNull(): ConstantValue<*>? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ConstantValue<*>

'value' @ [114:74] ==> public open val value: Any? defined in org.jetbrains.kotlin.resolve.constants.ConstantValue[DeserializedPropertyDescriptor]

'FqName' @ [117:57] ==> public constructor FqName(@NotNull p0: String) defined in org.jetbrains.kotlin.name.FqName[JavaClassConstructorDescriptor]

'FqName' @ [118:47] ==> public constructor FqName(@NotNull p0: String) defined in org.jetbrains.kotlin.name.FqName[JavaClassConstructorDescriptor]

