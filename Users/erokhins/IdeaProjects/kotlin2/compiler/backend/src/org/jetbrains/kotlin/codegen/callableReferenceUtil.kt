'operation' @ [28:20] ==> public open fun operation(type: (Type..Type?), lambda: (((InstructionAdapter..InstructionAdapter?)) -> (Unit..Unit?)..(((InstructionAdapter..InstructionAdapter?)) -> (Unit..Unit?))?)): (StackValue..StackValue?) defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'expectedReceiverType' @ [28:30] ==> value-parameter expectedReceiverType: Type defined in org.jetbrains.kotlin.codegen.capturedBoundReferenceReceiver[ValueParameterDescriptorImpl]

'iv' @ [29:13] ==> value-parameter iv: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.capturedBoundReferenceReceiver.<anonymous>[ValueParameterDescriptorImpl]

'load' @ [29:16] ==> public open fun load(p0: Int, p1: (Type..Type?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'ownerType' @ [29:24] ==> value-parameter ownerType: Type defined in org.jetbrains.kotlin.codegen.capturedBoundReferenceReceiver[ValueParameterDescriptorImpl]

'iv' @ [30:13] ==> value-parameter iv: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.capturedBoundReferenceReceiver.<anonymous>[ValueParameterDescriptorImpl]

'getfield' @ [30:16] ==> public open fun getfield(p0: (String..String?), p1: (String..String?), p2: (String..String?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'ownerType' @ [31:21] ==> value-parameter ownerType: Type defined in org.jetbrains.kotlin.codegen.capturedBoundReferenceReceiver[ValueParameterDescriptorImpl]

'internalName' @ [31:31] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'if (isInliningStrategy) AsmUtil.CAPTURED_RECEIVER_FIELD else AsmUtil.BOUND_REFERENCE_RECEIVER' @ [33:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'isInliningStrategy' @ [33:25] ==> value-parameter isInliningStrategy: Boolean defined in org.jetbrains.kotlin.codegen.capturedBoundReferenceReceiver[ValueParameterDescriptorImpl]

'CAPTURED_RECEIVER_FIELD' @ [33:53] ==> public const final val CAPTURED_RECEIVER_FIELD: String defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaPropertyDescriptor]

'BOUND_REFERENCE_RECEIVER' @ [33:90] ==> public const final val BOUND_REFERENCE_RECEIVER: String defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaPropertyDescriptor]

'OBJECT_TYPE' @ [34:30] ==> public final val OBJECT_TYPE: (Type..Type?) defined in org.jetbrains.kotlin.resolve.jvm.AsmTypes[JavaPropertyDescriptor]

'descriptor' @ [34:42] ==> public final val Type.descriptor: (String..String?)[MyPropertyDescriptor]

'coerce' @ [36:24] ==> public open fun coerce(@NotNull fromType: Type, @NotNull toType: Type, @NotNull v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'OBJECT_TYPE' @ [36:40] ==> public final val OBJECT_TYPE: (Type..Type?) defined in org.jetbrains.kotlin.resolve.jvm.AsmTypes[JavaPropertyDescriptor]

'expectedReceiverType' @ [36:53] ==> value-parameter expectedReceiverType: Type defined in org.jetbrains.kotlin.codegen.capturedBoundReferenceReceiver[ValueParameterDescriptorImpl]

'iv' @ [36:75] ==> value-parameter iv: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.capturedBoundReferenceReceiver.<anonymous>[ValueParameterDescriptorImpl]

'this' @ [40:9] ==> <this> defined in org.jetbrains.kotlin.codegen.isSyntheticClassForCallableReference[ReceiverParameterDescriptorImpl]

'this' @ [41:10] ==> <this> defined in org.jetbrains.kotlin.codegen.isSyntheticClassForCallableReference[ReceiverParameterDescriptorImpl]

'source' @ [41:15] ==> public final val SyntheticClassDescriptorForLambda.source: SourceElement[MyPropertyDescriptor]

'psi' @ [41:48] ==> public open val psi: KtElement defined in org.jetbrains.kotlin.resolve.source.KotlinSourceElement[DeserializedPropertyDescriptor]

'closureClass' @ [44:9] ==> public final val CalculatedClosure.closureClass: ClassDescriptor[MyPropertyDescriptor]

'isSyntheticClassForCallableReference' @ [44:22] ==> public fun ClassDescriptor.isSyntheticClassForCallableReference(): Boolean defined in org.jetbrains.kotlin.codegen in file callableReferenceUtil.kt[SimpleFunctionDescriptorImpl]

'isForCallableReference' @ [47:9] ==> public fun CalculatedClosure.isForCallableReference(): Boolean defined in org.jetbrains.kotlin.codegen in file callableReferenceUtil.kt[SimpleFunctionDescriptorImpl]

'captureReceiverType' @ [47:37] ==> public final val CalculatedClosure.captureReceiverType: KotlinType?[MyPropertyDescriptor]

'load' @ [50:5] ==> public open fun load(p0: Int, p1: (Type..Type?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'index' @ [50:10] ==> value-parameter index: Int defined in org.jetbrains.kotlin.codegen.loadBoundReferenceReceiverParameter[ValueParameterDescriptorImpl]

'type' @ [50:17] ==> value-parameter type: Type defined in org.jetbrains.kotlin.codegen.loadBoundReferenceReceiverParameter[ValueParameterDescriptorImpl]

'coerce' @ [51:16] ==> public open fun coerce(@NotNull fromType: Type, @NotNull toType: Type, @NotNull v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'type' @ [51:23] ==> value-parameter type: Type defined in org.jetbrains.kotlin.codegen.loadBoundReferenceReceiverParameter[ValueParameterDescriptorImpl]

'OBJECT_TYPE' @ [51:38] ==> public final val OBJECT_TYPE: (Type..Type?) defined in org.jetbrains.kotlin.resolve.jvm.AsmTypes[JavaPropertyDescriptor]

'this' @ [51:51] ==> <this> defined in org.jetbrains.kotlin.codegen.loadBoundReferenceReceiverParameter[ReceiverParameterDescriptorImpl]

'isForBoundCallableReference' @ [55:9] ==> public fun CalculatedClosure.isForBoundCallableReference(): Boolean defined in org.jetbrains.kotlin.codegen in file callableReferenceUtil.kt[SimpleFunctionDescriptorImpl]

'fieldInfo' @ [56:9] ==> value-parameter fieldInfo: FieldInfo defined in org.jetbrains.kotlin.codegen.isBoundReferenceReceiverField[ValueParameterDescriptorImpl]

'fieldName' @ [56:19] ==> public final val FieldInfo.fieldName: String[MyPropertyDescriptor]

'CAPTURED_RECEIVER_FIELD' @ [56:40] ==> public const final val CAPTURED_RECEIVER_FIELD: String defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaPropertyDescriptor]

'-' @ [60:48] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'args' @ [62:23] ==> value-parameter args: List<FieldInfo> defined in org.jetbrains.kotlin.codegen.generateClosureFieldsInitializationFromParameters[ValueParameterDescriptorImpl]

'closure' @ [63:13] ==> value-parameter closure: CalculatedClosure defined in org.jetbrains.kotlin.codegen.generateClosureFieldsInitializationFromParameters[ValueParameterDescriptorImpl]

'isBoundReferenceReceiverField' @ [63:21] ==> public fun CalculatedClosure.isBoundReferenceReceiverField(fieldInfo: FieldInfo): Boolean defined in org.jetbrains.kotlin.codegen in file callableReferenceUtil.kt[SimpleFunctionDescriptorImpl]

'fieldInfo' @ [63:51] ==> val fieldInfo: FieldInfo defined in org.jetbrains.kotlin.codegen.generateClosureFieldsInitializationFromParameters[LocalVariableDescriptor]

'boundReferenceReceiverParameterIndex' @ [64:13] ==> var boundReferenceReceiverParameterIndex: Int defined in org.jetbrains.kotlin.codegen.generateClosureFieldsInitializationFromParameters[LocalVariableDescriptor]

'k' @ [64:52] ==> var k: Int defined in org.jetbrains.kotlin.codegen.generateClosureFieldsInitializationFromParameters[LocalVariableDescriptor]

'boundReferenceReceiverType' @ [65:13] ==> var boundReferenceReceiverType: Type? defined in org.jetbrains.kotlin.codegen.generateClosureFieldsInitializationFromParameters[LocalVariableDescriptor]

'fieldInfo' @ [65:42] ==> val fieldInfo: FieldInfo defined in org.jetbrains.kotlin.codegen.generateClosureFieldsInitializationFromParameters[LocalVariableDescriptor]

'fieldType' @ [65:52] ==> public final val FieldInfo.fieldType: Type[MyPropertyDescriptor]

'k' @ [66:13] ==> var k: Int defined in org.jetbrains.kotlin.codegen.generateClosureFieldsInitializationFromParameters[LocalVariableDescriptor]

'fieldInfo' @ [66:18] ==> val fieldInfo: FieldInfo defined in org.jetbrains.kotlin.codegen.generateClosureFieldsInitializationFromParameters[LocalVariableDescriptor]

'fieldType' @ [66:28] ==> public final val FieldInfo.fieldType: Type[MyPropertyDescriptor]

'size' @ [66:38] ==> public final val Type.size: Int[MyPropertyDescriptor]

'k' @ [69:9] ==> var k: Int defined in org.jetbrains.kotlin.codegen.generateClosureFieldsInitializationFromParameters[LocalVariableDescriptor]

'genAssignInstanceFieldFromParam' @ [69:21] ==> public open fun genAssignInstanceFieldFromParam(info: (FieldInfo..FieldInfo?), index: Int, iv: (InstructionAdapter..InstructionAdapter?)): Int defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaMethodDescriptor]

'fieldInfo' @ [69:53] ==> val fieldInfo: FieldInfo defined in org.jetbrains.kotlin.codegen.generateClosureFieldsInitializationFromParameters[LocalVariableDescriptor]

'k' @ [69:64] ==> var k: Int defined in org.jetbrains.kotlin.codegen.generateClosureFieldsInitializationFromParameters[LocalVariableDescriptor]

'this' @ [69:67] ==> <this> defined in org.jetbrains.kotlin.codegen.generateClosureFieldsInitializationFromParameters[ReceiverParameterDescriptorImpl]

'when {
        boundReferenceReceiverType != null ->
            Pair(boundReferenceReceiverParameterIndex, boundReferenceReceiverType)
        else ->
            null
    }' @ [72:12] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Pair<Int, Type>?, entry1: Pair<Int, Type>?): Pair<Int, Type>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Pair<Int, Type>?

'boundReferenceReceiverType' @ [73:9] ==> var boundReferenceReceiverType: Type? defined in org.jetbrains.kotlin.codegen.generateClosureFieldsInitializationFromParameters[LocalVariableDescriptor]

'Pair' @ [74:13] ==> public constructor Pair<out A, out B>(first: Int, second: Type) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> Int
    <out B> -> Type

'boundReferenceReceiverParameterIndex' @ [74:18] ==> var boundReferenceReceiverParameterIndex: Int defined in org.jetbrains.kotlin.codegen.generateClosureFieldsInitializationFromParameters[LocalVariableDescriptor]

'boundReferenceReceiverType' @ [74:56] ==> var boundReferenceReceiverType: Type? defined in org.jetbrains.kotlin.codegen.generateClosureFieldsInitializationFromParameters[LocalVariableDescriptor]

