'state' @ [33:30] ==> private final val state: GenerationState defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator[PropertyDescriptorImpl]

'typeMapper' @ [33:36] ==> public final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.state.GenerationState[PropertyDescriptorImpl]

'parentBodyCodegen' @ [36:9] ==> value-parameter parentBodyCodegen: ImplementationBodyCodegen defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.<init>[ValueParameterDescriptorImpl]

'getContext' @ [36:27] ==> @NotNull public open fun getContext(): FieldOwnerContext<*> defined in org.jetbrains.kotlin.codegen.ImplementationBodyCodegen[JavaMethodDescriptor]

'accessibleDescriptor' @ [36:40] ==> @SuppressWarnings @NotNull public open fun <D : (CallableMemberDescriptor..CallableMemberDescriptor?)> accessibleDescriptor(@NotNull descriptor: CallableMemberDescriptor, @Nullable superCallTarget: ClassDescriptor?): CallableMemberDescriptor defined in org.jetbrains.kotlin.codegen.context.FieldOwnerContext[JavaMethodDescriptor]
Inferred types:
    <D : (CallableMemberDescriptor..CallableMemberDescriptor?)> -> CallableMemberDescriptor

'getDirectMember' @ [36:76] ==> @NotNull public open fun getDirectMember(@NotNull descriptor: CallableMemberDescriptor): CallableMemberDescriptor defined in org.jetbrains.kotlin.codegen.JvmCodegenUtil[JavaMethodDescriptor]

'descriptor' @ [36:92] ==> private final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator[PropertyDescriptorImpl]

'createStaticFunctionDescriptor' @ [40:40] ==> @JvmStatic public final fun createStaticFunctionDescriptor(descriptor: FunctionDescriptor): FunctionDescriptor defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.Companion[SimpleFunctionDescriptorImpl]

'descriptor' @ [40:71] ==> private final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator[PropertyDescriptorImpl]

'declarationOrigin' @ [42:29] ==> private final val declarationOrigin: JvmDeclarationOrigin defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator[PropertyDescriptorImpl]

'element' @ [42:47] ==> public final val element: PsiElement? defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOrigin[DeserializedPropertyDescriptor]

'codegen' @ [43:9] ==> value-parameter codegen: ImplementationBodyCodegen defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke[ValueParameterDescriptorImpl]

'functionCodegen' @ [43:17] ==> public final val functionCodegen: (FunctionCodegen..FunctionCodegen?) defined in org.jetbrains.kotlin.codegen.ImplementationBodyCodegen[JavaPropertyDescriptor]

'generateMethod' @ [43:33] ==> public open fun generateMethod(@NotNull origin: JvmDeclarationOrigin, @NotNull descriptor: FunctionDescriptor, @NotNull strategy: FunctionGenerationStrategy): Unit defined in org.jetbrains.kotlin.codegen.FunctionCodegen[JavaMethodDescriptor]

'Synthetic' @ [44:17] ==> public fun Synthetic(element: PsiElement?, descriptor: CallableMemberDescriptor): JvmDeclarationOrigin defined in org.jetbrains.kotlin.resolve.jvm.diagnostics[DeserializedSimpleFunctionDescriptor]

'originElement' @ [44:27] ==> val originElement: PsiElement? defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke[LocalVariableDescriptor]

'staticFunctionDescriptor' @ [44:42] ==> val staticFunctionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke[LocalVariableDescriptor]

'staticFunctionDescriptor' @ [45:17] ==> val staticFunctionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke[LocalVariableDescriptor]

'FunctionGenerationStrategy.CodegenBased' @ [46:26] ==> public constructor CodegenBased(@NotNull state: GenerationState) defined in org.jetbrains.kotlin.codegen.FunctionGenerationStrategy.CodegenBased[JavaClassConstructorDescriptor]

'state' @ [46:66] ==> private final val state: GenerationState defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator[PropertyDescriptorImpl]

'codegen' @ [48:34] ==> value-parameter codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke.<no name provided>.doGenerateBody[ValueParameterDescriptorImpl]

'v' @ [48:42] ==> public final val v: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'descriptor' @ [49:47] ==> private final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator[PropertyDescriptorImpl]

'containingDeclaration' @ [49:58] ==> public final val FunctionDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'singleton' @ [50:57] ==> @NotNull public open fun singleton(@NotNull classDescriptor: ClassDescriptor, @NotNull typeMapper: KotlinTypeMapper): StackValue.Field defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'classDescriptor' @ [50:67] ==> val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'typeMapper' @ [50:84] ==> private final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator[PropertyDescriptorImpl]

'singletonValue' @ [51:25] ==> val singletonValue: StackValue.Field defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'put' @ [51:40] ==> public open fun put(@NotNull type: Type, @NotNull v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.StackValue.Field[JavaMethodDescriptor]

'singletonValue' @ [51:44] ==> val singletonValue: StackValue.Field defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'type' @ [51:59] ==> @NotNull public final val type: Type defined in org.jetbrains.kotlin.codegen.StackValue.Field[JavaPropertyDescriptor]

'iv' @ [51:65] ==> val iv: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'signature' @ [53:41] ==> value-parameter signature: JvmMethodSignature defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke.<no name provided>.doGenerateBody[ValueParameterDescriptorImpl]

'asmMethod' @ [53:51] ==> public final val JvmMethodSignature.asmMethod: Method[MyPropertyDescriptor]

'asmMethod' @ [54:43] ==> val asmMethod: Method defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'argumentTypes' @ [54:53] ==> public final val Method.argumentTypes: (Array<(Type..Type?)>..Array<out (Type..Type?)>?)[MyPropertyDescriptor]

'iv' @ [55:29] ==> val iv: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'load' @ [55:32] ==> public open fun load(p0: Int, p1: (Type..Type?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'index' @ [55:37] ==> var index: Int defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'paramType' @ [55:44] ==> val paramType: (Type..Type?) defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'index' @ [56:29] ==> var index: Int defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'paramType' @ [56:38] ==> val paramType: (Type..Type?) defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'size' @ [56:48] ==> public final val Type.size: Int[MyPropertyDescriptor]

'if (descriptor is PropertyAccessorDescriptor) {
                            val propertyValue = codegen.intermediateValueForProperty(descriptor.correspondingProperty, false, null, StackValue.none())
                            if (descriptor is PropertyGetterDescriptor) {
                                propertyValue.put(signature.returnType, iv)
                            }
                            else {
                                propertyValue.store(StackValue.onStack(propertyValue.type), iv, true)
                            }
                        }
                        else {
                            val syntheticOrOriginalMethod = typeMapper.mapToCallableMethod(
                                    codegen.context.accessibleDescriptor(descriptor, /* superCallTarget = */ null),
                                    false
                            )
                            syntheticOrOriginalMethod.genInvokeInstruction(iv)
                        }' @ [58:25] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'descriptor' @ [58:29] ==> private final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator[PropertyDescriptorImpl]

'codegen' @ [59:49] ==> value-parameter codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke.<no name provided>.doGenerateBody[ValueParameterDescriptorImpl]

'intermediateValueForProperty' @ [59:57] ==> @NotNull public open fun intermediateValueForProperty(@NotNull propertyDescriptor: PropertyDescriptor, forceField: Boolean, @Nullable superCallTarget: ClassDescriptor?, @NotNull receiver: StackValue): StackValue.Property defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'descriptor' @ [59:86] ==> private final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator[PropertyDescriptorImpl]

'correspondingProperty' @ [59:97] ==> public final val PropertyAccessorDescriptor.correspondingProperty: PropertyDescriptor[MyPropertyDescriptor]

'none' @ [59:144] ==> public open fun none(): (StackValue..StackValue?) defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'if (descriptor is PropertyGetterDescriptor) {
                                propertyValue.put(signature.returnType, iv)
                            }
                            else {
                                propertyValue.store(StackValue.onStack(propertyValue.type), iv, true)
                            }' @ [60:29] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'descriptor' @ [60:33] ==> private final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator[PropertyDescriptorImpl]

'propertyValue' @ [61:33] ==> val propertyValue: StackValue.Property defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'put' @ [61:47] ==> public open fun put(@NotNull type: Type, @NotNull v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.StackValue.Property[JavaMethodDescriptor]

'signature' @ [61:51] ==> value-parameter signature: JvmMethodSignature defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke.<no name provided>.doGenerateBody[ValueParameterDescriptorImpl]

'returnType' @ [61:61] ==> public final val JvmMethodSignature.returnType: Type[MyPropertyDescriptor]

'iv' @ [61:73] ==> val iv: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'propertyValue' @ [64:33] ==> val propertyValue: StackValue.Property defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'store' @ [64:47] ==> @Override public open fun store(@NotNull rightSide: StackValue, @NotNull v: InstructionAdapter, skipReceiver: Boolean): Unit defined in org.jetbrains.kotlin.codegen.StackValue.Property[JavaMethodDescriptor]

'onStack' @ [64:64] ==> @NotNull public open fun onStack(@NotNull type: Type): StackValue defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'propertyValue' @ [64:72] ==> val propertyValue: StackValue.Property defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'type' @ [64:86] ==> @NotNull public final val type: Type defined in org.jetbrains.kotlin.codegen.StackValue.Property[JavaPropertyDescriptor]

'iv' @ [64:93] ==> val iv: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'typeMapper' @ [68:61] ==> private final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator[PropertyDescriptorImpl]

'mapToCallableMethod' @ [68:72] ==> @NotNull public open fun mapToCallableMethod(@NotNull descriptor: FunctionDescriptor, superCall: Boolean): CallableMethod defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'codegen' @ [69:37] ==> value-parameter codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke.<no name provided>.doGenerateBody[ValueParameterDescriptorImpl]

'context' @ [69:45] ==> public final val context: (MethodContext..MethodContext?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'accessibleDescriptor' @ [69:53] ==> @SuppressWarnings @NotNull public open fun <D : (CallableMemberDescriptor..CallableMemberDescriptor?)> accessibleDescriptor(@NotNull descriptor: FunctionDescriptor, @Nullable superCallTarget: ClassDescriptor?): FunctionDescriptor defined in org.jetbrains.kotlin.codegen.context.MethodContext[JavaMethodDescriptor]
Inferred types:
    <D : (CallableMemberDescriptor..CallableMemberDescriptor?)> -> FunctionDescriptor

'descriptor' @ [69:74] ==> private final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator[PropertyDescriptorImpl]

'syntheticOrOriginalMethod' @ [72:29] ==> val syntheticOrOriginalMethod: CallableMethod defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'genInvokeInstruction' @ [72:55] ==> public open fun genInvokeInstruction(v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.CallableMethod[SimpleFunctionDescriptorImpl]

'iv' @ [72:76] ==> val iv: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'iv' @ [74:25] ==> val iv: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'areturn' @ [74:28] ==> public open fun areturn(p0: (Type..Type?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'asmMethod' @ [74:36] ==> val asmMethod: Method defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'returnType' @ [74:46] ==> public final val Method.returnType: (Type..Type?)[MyPropertyDescriptor]

'originElement' @ [79:13] ==> val originElement: PsiElement? defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke[LocalVariableDescriptor]

'codegen' @ [80:13] ==> value-parameter codegen: ImplementationBodyCodegen defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke[ValueParameterDescriptorImpl]

'functionCodegen' @ [80:21] ==> public final val functionCodegen: (FunctionCodegen..FunctionCodegen?) defined in org.jetbrains.kotlin.codegen.ImplementationBodyCodegen[JavaPropertyDescriptor]

'generateOverloadsWithDefaultValues' @ [80:37] ==> public open fun generateOverloadsWithDefaultValues(@Nullable function: KtNamedFunction?, @NotNull functionDescriptor: FunctionDescriptor, @NotNull delegateFunctionDescriptor: FunctionDescriptor): Unit defined in org.jetbrains.kotlin.codegen.FunctionCodegen[JavaMethodDescriptor]

'originElement' @ [80:72] ==> val originElement: PsiElement? defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke[LocalVariableDescriptor]

'staticFunctionDescriptor' @ [80:87] ==> val staticFunctionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.invoke[LocalVariableDescriptor]

'descriptor' @ [80:113] ==> private final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator[PropertyDescriptorImpl]

'JvmStatic' @ [85:9] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'if (descriptor is PropertyAccessorDescriptor) descriptor.correspondingProperty else descriptor' @ [87:36] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: CallableMemberDescriptor, elseBranch: CallableMemberDescriptor): CallableMemberDescriptor[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> CallableMemberDescriptor

'descriptor' @ [87:40] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.Companion.createStaticFunctionDescriptor[ValueParameterDescriptorImpl]

'descriptor' @ [87:82] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.Companion.createStaticFunctionDescriptor[ValueParameterDescriptorImpl]

'correspondingProperty' @ [87:93] ==> public final val PropertyAccessorDescriptor.correspondingProperty: PropertyDescriptor[MyPropertyDescriptor]

'descriptor' @ [87:120] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.Companion.createStaticFunctionDescriptor[ValueParameterDescriptorImpl]

'CodegenUtil' @ [88:26] ==> public object CodegenUtil defined in org.jetbrains.kotlin.backend.common[FakeCallableDescriptorForObject]

'copyFunctions' @ [88:38] ==> public final fun copyFunctions(inheritedMember: CallableMemberDescriptor, traitMember: CallableMemberDescriptor, newOwner: DeclarationDescriptor, modality: Modality, visibility: Visibility, kind: CallableMemberDescriptor.Kind, copyOverrides: Boolean): Map<FunctionDescriptor, FunctionDescriptor> defined in org.jetbrains.kotlin.backend.common.CodegenUtil[DeserializedSimpleFunctionDescriptor]

'memberDescriptor' @ [89:21] ==> val memberDescriptor: CallableMemberDescriptor defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.Companion.createStaticFunctionDescriptor[LocalVariableDescriptor]

'memberDescriptor' @ [90:21] ==> val memberDescriptor: CallableMemberDescriptor defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.Companion.createStaticFunctionDescriptor[LocalVariableDescriptor]

'descriptor' @ [91:21] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.Companion.createStaticFunctionDescriptor[ValueParameterDescriptorImpl]

'containingDeclaration' @ [91:32] ==> public final val FunctionDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'containingDeclaration' @ [91:54] ==> public final val DeclarationDescriptor.containingDeclaration: DeclarationDescriptor?[MyPropertyDescriptor]

'descriptor' @ [92:21] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.Companion.createStaticFunctionDescriptor[ValueParameterDescriptorImpl]

'modality' @ [92:32] ==> public final val FunctionDescriptor.modality: Modality[MyPropertyDescriptor]

'descriptor' @ [93:21] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.Companion.createStaticFunctionDescriptor[ValueParameterDescriptorImpl]

'visibility' @ [93:32] ==> public final val FunctionDescriptor.visibility: Visibility[MyPropertyDescriptor]

'SYNTHESIZED' @ [94:51] ==> enum entry SYNTHESIZED defined in org.jetbrains.kotlin.descriptors.CallableMemberDescriptor.Kind[FakeCallableDescriptorForObject]

'copies' @ [97:20] ==> val copies: Map<FunctionDescriptor, FunctionDescriptor> defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.Companion.createStaticFunctionDescriptor[LocalVariableDescriptor]

'descriptor' @ [97:27] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.JvmStaticInCompanionObjectGenerator.Companion.createStaticFunctionDescriptor[ValueParameterDescriptorImpl]

