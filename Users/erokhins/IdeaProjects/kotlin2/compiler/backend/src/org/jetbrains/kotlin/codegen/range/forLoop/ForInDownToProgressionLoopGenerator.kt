'AbstractForInRangeWithGivenBoundsLoopGenerator' @ [30:5] ==> public constructor AbstractForInRangeWithGivenBoundsLoopGenerator(codegen: ExpressionCodegen, forExpression: KtForExpression, step: Int = ...) defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForInRangeWithGivenBoundsLoopGenerator[ClassConstructorDescriptorImpl]

'codegen' @ [30:52] ==> value-parameter codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.ForInDownToProgressionLoopGenerator.<init>[ValueParameterDescriptorImpl]

'forExpression' @ [30:61] ==> value-parameter forExpression: KtForExpression defined in org.jetbrains.kotlin.codegen.range.forLoop.ForInDownToProgressionLoopGenerator.<init>[ValueParameterDescriptorImpl]

'-' @ [30:76] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'loopRangeCall' @ [31:39] ==> value-parameter loopRangeCall: ResolvedCall<*> defined in org.jetbrains.kotlin.codegen.range.forLoop.ForInDownToProgressionLoopGenerator.<init>[ValueParameterDescriptorImpl]

'extensionReceiver' @ [31:53] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.extensionReceiver: ReceiverValue?[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'!!' @ [32:36] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: KtExpression?): KtExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> KtExpression

'getSingleArgumentExpression' @ [32:54] ==> @Nullable public open fun getSingleArgumentExpression(@NotNull resolvedCall: ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>): KtExpression? defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'loopRangeCall' @ [32:82] ==> value-parameter loopRangeCall: ResolvedCall<*> defined in org.jetbrains.kotlin.codegen.range.forLoop.ForInDownToProgressionLoopGenerator.<init>[ValueParameterDescriptorImpl]

'codegen' @ [34:47] ==> protected final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.ForInDownToProgressionLoopGenerator[PropertyDescriptorImpl]

'generateReceiverValue' @ [34:55] ==> @NotNull public open fun generateReceiverValue(@Nullable receiverValue: ReceiverValue?, isSuper: Boolean): StackValue defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'from' @ [34:77] ==> private final val from: ReceiverValue defined in org.jetbrains.kotlin.codegen.range.forLoop.ForInDownToProgressionLoopGenerator[PropertyDescriptorImpl]

'codegen' @ [36:45] ==> protected final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.ForInDownToProgressionLoopGenerator[PropertyDescriptorImpl]

'gen' @ [36:53] ==> public open fun gen(expr: (KtElement..KtElement?)): (StackValue..StackValue?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'to' @ [36:57] ==> private final val to: KtExpression defined in org.jetbrains.kotlin.codegen.range.forLoop.ForInDownToProgressionLoopGenerator[PropertyDescriptorImpl]

