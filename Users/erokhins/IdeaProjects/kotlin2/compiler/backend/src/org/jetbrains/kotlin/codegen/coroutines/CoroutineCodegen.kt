'ClosureCodegen' @ [61:5] ==> public constructor ClosureCodegen(@NotNull state: GenerationState, @NotNull element: KtElement, @Nullable samType: SamType?, @NotNull context: ClosureContext, @Nullable functionReferenceTarget: FunctionDescriptor?, @NotNull strategy: FunctionGenerationStrategy, @NotNull parentCodegen: MemberCodegen<*>, @NotNull classBuilder: ClassBuilder) defined in org.jetbrains.kotlin.codegen.ClosureCodegen[JavaClassConstructorDescriptor]

'outerExpressionCodegen' @ [62:9] ==> value-parameter outerExpressionCodegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.<init>[ValueParameterDescriptorImpl]

'state' @ [62:32] ==> public final val ExpressionCodegen.state: GenerationState[MyPropertyDescriptor]

'element' @ [63:9] ==> value-parameter element: KtElement defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.<init>[ValueParameterDescriptorImpl]

'closureContext' @ [63:24] ==> value-parameter closureContext: ClosureContext defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.<init>[ValueParameterDescriptorImpl]

'FailingFunctionGenerationStrategy' @ [64:9] ==> private object FailingFunctionGenerationStrategy : FunctionGenerationStrategy defined in org.jetbrains.kotlin.codegen.coroutines in file CoroutineCodegen.kt[FakeCallableDescriptorForObject]

'outerExpressionCodegen' @ [65:9] ==> value-parameter outerExpressionCodegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.<init>[ValueParameterDescriptorImpl]

'parentCodegen' @ [65:32] ==> public final val ExpressionCodegen.parentCodegen: MemberCodegen<*>[MyPropertyDescriptor]

'classBuilder' @ [65:47] ==> value-parameter classBuilder: ClassBuilder defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.<init>[ValueParameterDescriptorImpl]

'closureContext' @ [67:37] ==> value-parameter closureContext: ClosureContext defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.<init>[ValueParameterDescriptorImpl]

'contextDescriptor' @ [67:52] ==> public final val ClosureContext.contextDescriptor: ClassDescriptor[MyPropertyDescriptor]

'create' @ [70:42] ==> @NotNull public open fun create(@NotNull p0: DeclarationDescriptor, @NotNull p1: Annotations, @NotNull p2: Name, @NotNull p3: CallableMemberDescriptor.Kind, @NotNull p4: SourceElement): SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.descriptors.impl.SimpleFunctionDescriptorImpl[JavaMethodDescriptor]

'classDescriptor' @ [71:21] ==> protected final val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen[PropertyDescriptorImpl]

'EMPTY' @ [71:50] ==> public final val EMPTY: Annotations defined in org.jetbrains.kotlin.descriptors.annotations.Annotations.Companion[DeserializedPropertyDescriptor]

'identifier' @ [71:62] ==> @NotNull public open fun identifier(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'DO_RESUME_METHOD_NAME' @ [71:73] ==> public const val DO_RESUME_METHOD_NAME: String defined in org.jetbrains.kotlin.codegen.coroutines in file coroutineCodegenUtil.kt[PropertyDescriptorImpl]

'DECLARATION' @ [71:127] ==> enum entry DECLARATION defined in org.jetbrains.kotlin.descriptors.CallableMemberDescriptor.Kind[FakeCallableDescriptorForObject]

'funDescriptor' @ [72:21] ==> protected/*protected and package*/ final val funDescriptor: (FunctionDescriptor..FunctionDescriptor?) defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen[JavaPropertyDescriptor]

'source' @ [72:35] ==> public final val FunctionDescriptor.source: SourceElement[MyPropertyDescriptor]

'apply' @ [73:15] ==> @InlineOnly public inline fun <T> SimpleFunctionDescriptorImpl.apply(block: (SimpleFunctionDescriptorImpl).() -> Unit): SimpleFunctionDescriptorImpl defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SimpleFunctionDescriptorImpl

'initialize' @ [74:17] ==> @NotNull public open fun initialize(@Nullable p0: KotlinType?, @Nullable p1: ReceiverParameterDescriptor?, @NotNull p2: (MutableList<out (TypeParameterDescriptor..TypeParameterDescriptor?)>..List<(TypeParameterDescriptor..TypeParameterDescriptor?)>), @NotNull p3: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>), @Nullable p4: KotlinType?, @Nullable p5: Modality?, @NotNull p6: Visibility, @Nullable p7: (MutableMap<out (FunctionDescriptor.UserDataKey<*>..FunctionDescriptor.UserDataKey<*>?), *>?..Map<out (FunctionDescriptor.UserDataKey<*>..FunctionDescriptor.UserDataKey<*>?), *>?)): SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.descriptors.impl.SimpleFunctionDescriptorImpl[JavaMethodDescriptor]

'classDescriptor' @ [76:23] ==> protected final val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen[PropertyDescriptorImpl]

'thisAsReceiverParameter' @ [76:39] ==> public final val ClassDescriptor.thisAsReceiverParameter: ReceiverParameterDescriptor[MyPropertyDescriptor]

'emptyList' @ [77:23] ==> public fun <T> emptyList(): List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)

'listOf' @ [78:23] ==> public fun <T> listOf(vararg elements: ValueParameterDescriptorImpl): List<ValueParameterDescriptorImpl> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ValueParameterDescriptorImpl

'createValueParameterForDoResume' @ [79:31] ==> private final fun FunctionDescriptor.createValueParameterForDoResume(name: Name, type: KotlinType, index: Int): ValueParameterDescriptorImpl defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen[SimpleFunctionDescriptorImpl]

'identifier' @ [79:68] ==> @NotNull public open fun identifier(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'builtIns' @ [79:88] ==> public val DeclarationDescriptor.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'nullableAnyType' @ [79:97] ==> public final val KotlinBuiltIns.nullableAnyType: SimpleType[MyPropertyDescriptor]

'createValueParameterForDoResume' @ [80:31] ==> private final fun FunctionDescriptor.createValueParameterForDoResume(name: Name, type: KotlinType, index: Int): ValueParameterDescriptorImpl defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen[SimpleFunctionDescriptorImpl]

'identifier' @ [80:68] ==> @NotNull public open fun identifier(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'builtIns' @ [80:93] ==> public val DeclarationDescriptor.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'throwable' @ [80:102] ==> public final val KotlinBuiltIns.throwable: ClassDescriptor[MyPropertyDescriptor]

'defaultType' @ [80:112] ==> public final val ClassDescriptor.defaultType: SimpleType[MyPropertyDescriptor]

'makeNullable' @ [80:124] ==> public fun KotlinType.makeNullable(): KotlinType defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'builtIns' @ [82:23] ==> public val DeclarationDescriptor.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'nullableAnyType' @ [82:32] ==> public final val KotlinBuiltIns.nullableAnyType: SimpleType[MyPropertyDescriptor]

'FINAL' @ [83:32] ==> enum entry FINAL defined in org.jetbrains.kotlin.descriptors.Modality[FakeCallableDescriptorForObject]

'PUBLIC' @ [84:36] ==> @NotNull public final val PUBLIC: Visibility defined in org.jetbrains.kotlin.descriptors.Visibilities[JavaPropertyDescriptor]

'userDataForDoResume' @ [85:23] ==> value-parameter userDataForDoResume: Map<out FunctionDescriptor.UserDataKey<*>, *>? = ... defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.<init>[ValueParameterDescriptorImpl]

'ValueParameterDescriptorImpl' @ [90:13] ==> public constructor ValueParameterDescriptorImpl(containingDeclaration: CallableDescriptor, original: ValueParameterDescriptor?, index: Int, annotations: Annotations, name: Name, outType: KotlinType, declaresDefaultValue: Boolean, isCrossinline: Boolean, isNoinline: Boolean, varargElementType: KotlinType?, source: SourceElement) defined in org.jetbrains.kotlin.descriptors.impl.ValueParameterDescriptorImpl[DeserializedClassConstructorDescriptor]

'this' @ [91:21] ==> <this> defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.createValueParameterForDoResume[ReceiverParameterDescriptorImpl]

'index' @ [91:33] ==> value-parameter index: Int defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.createValueParameterForDoResume[ValueParameterDescriptorImpl]

'EMPTY' @ [91:52] ==> public final val EMPTY: Annotations defined in org.jetbrains.kotlin.descriptors.annotations.Annotations.Companion[DeserializedPropertyDescriptor]

'name' @ [91:59] ==> value-parameter name: Name defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.createValueParameterForDoResume[ValueParameterDescriptorImpl]

'type' @ [92:21] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.createValueParameterForDoResume[ValueParameterDescriptorImpl]

'NO_SOURCE' @ [95:41] ==> public final val NO_SOURCE: (SourceElement..SourceElement?) defined in org.jetbrains.kotlin.descriptors.SourceElement[JavaPropertyDescriptor]

'calculateConstructorParameters' @ [99:20] ==> @NotNull public open fun calculateConstructorParameters(@NotNull typeMapper: KotlinTypeMapper, @NotNull closure: CalculatedClosure, @NotNull ownerType: Type): (MutableList<(FieldInfo..FieldInfo?)>..List<(FieldInfo..FieldInfo?)>) defined in org.jetbrains.kotlin.codegen.ClosureCodegen[JavaMethodDescriptor]

'typeMapper' @ [99:51] ==> public final val typeMapper: (KotlinTypeMapper..KotlinTypeMapper?) defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen[JavaPropertyDescriptor]

'closure' @ [99:63] ==> protected/*protected and package*/ final val closure: (CalculatedClosure..CalculatedClosure?) defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen[JavaPropertyDescriptor]

'asmType' @ [99:72] ==> protected/*protected and package*/ final val asmType: (Type..Type?) defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen[JavaPropertyDescriptor]

'args' @ [100:24] ==> val args: (MutableList<(FieldInfo..FieldInfo?)>..List<(FieldInfo..FieldInfo?)>) defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.generateConstructor[LocalVariableDescriptor]

'map' @ [100:29] ==> public inline fun <T, R> Iterable<(FieldInfo..FieldInfo?)>.map(transform: ((FieldInfo..FieldInfo?)) -> Type): List<Type> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.codegen.FieldInfo..org.jetbrains.kotlin.codegen.FieldInfo?)
    <R> -> Type

'it' @ [100:35] ==> value-parameter it: (FieldInfo..FieldInfo?) defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.generateConstructor.<anonymous>[ValueParameterDescriptorImpl]

'fieldType' @ [100:38] ==> public final val FieldInfo.fieldType: Type[MyPropertyDescriptor]

'plus' @ [100:50] ==> public operator fun <T> Collection<Type>.plus(element: Type): List<Type> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Type

'CONTINUATION_ASM_TYPE' @ [100:55] ==> @JvmField public val CONTINUATION_ASM_TYPE: Type defined in org.jetbrains.kotlin.codegen.coroutines in file coroutineCodegenUtil.kt[PropertyDescriptorImpl]

'toTypedArray' @ [100:78] ==> public inline fun <reified T> Collection<Type>.toTypedArray(): Array<Type> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T> -> Type

'Method' @ [102:27] ==> public constructor Method(p0: (String..String?), p1: (Type..Type?), p2: (Array<(Type..Type?)>..Array<out (Type..Type?)>?)) defined in org.jetbrains.org.objectweb.asm.commons.Method[JavaClassConstructorDescriptor]

'VOID_TYPE' @ [102:49] ==> public final val VOID_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'argTypes' @ [102:60] ==> val argTypes: Array<Type> defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.generateConstructor[LocalVariableDescriptor]

'v' @ [103:18] ==> public final val v: (ClassBuilder..ClassBuilder?) defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen[JavaPropertyDescriptor]

'newMethod' @ [103:20] ==> @NotNull public abstract fun newMethod(@NotNull origin: JvmDeclarationOrigin, access: Int, @NotNull name: String, @NotNull desc: String, @Nullable signature: String?, @Nullable exceptions: (Array<(String..String?)>?..Array<out (String..String?)>?)): MethodVisitor defined in org.jetbrains.kotlin.codegen.ClassBuilder[JavaMethodDescriptor]

'OtherOrigin' @ [104:17] ==> @JvmOverloads public fun OtherOrigin(element: PsiElement?, descriptor: DeclarationDescriptor? = ...): JvmDeclarationOrigin defined in org.jetbrains.kotlin.resolve.jvm.diagnostics[DeserializedSimpleFunctionDescriptor]

'element' @ [104:29] ==> protected/*protected and package*/ final val element: (KtElement..KtElement?) defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen[JavaPropertyDescriptor]

'funDescriptor' @ [104:38] ==> protected/*protected and package*/ final val funDescriptor: (FunctionDescriptor..FunctionDescriptor?) defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen[JavaPropertyDescriptor]

'visibilityFlag' @ [104:54] ==> protected/*protected and package*/ final val visibilityFlag: Int defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen[JavaPropertyDescriptor]

'constructor' @ [104:80] ==> val constructor: Method defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.generateConstructor[LocalVariableDescriptor]

'descriptor' @ [104:92] ==> public final val Method.descriptor: (String..String?)[MyPropertyDescriptor]

'EMPTY_STRING_ARRAY' @ [105:27] ==> public final val EMPTY_STRING_ARRAY: (Array<(String..String?)>..Array<out (String..String?)>?) defined in com.intellij.util.ArrayUtil[JavaPropertyDescriptor]

'state' @ [108:13] ==> public final val state: (GenerationState..GenerationState?) defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen[JavaPropertyDescriptor]

'classBuilderMode' @ [108:19] ==> public final val classBuilderMode: ClassBuilderMode defined in org.jetbrains.kotlin.codegen.state.GenerationState[PropertyDescriptorImpl]

'generateBodies' @ [108:36] ==> public final val generateBodies: Boolean defined in org.jetbrains.kotlin.codegen.ClassBuilderMode[JavaPropertyDescriptor]

'mv' @ [109:13] ==> val mv: MethodVisitor defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.generateConstructor[LocalVariableDescriptor]

'visitCode' @ [109:16] ==> public open fun visitCode(): Unit defined in org.jetbrains.org.objectweb.asm.MethodVisitor[JavaMethodDescriptor]

'InstructionAdapter' @ [110:22] ==> public constructor InstructionAdapter(p0: (MethodVisitor..MethodVisitor?)) defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaClassConstructorDescriptor]

'mv' @ [110:41] ==> val mv: MethodVisitor defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.generateConstructor[LocalVariableDescriptor]

'iv' @ [112:13] ==> val iv: InstructionAdapter defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.generateConstructor[LocalVariableDescriptor]

'generateClosureFieldsInitializationFromParameters' @ [112:16] ==> public fun InstructionAdapter.generateClosureFieldsInitializationFromParameters(closure: CalculatedClosure, args: List<FieldInfo>): Pair<Int, Type>? defined in org.jetbrains.kotlin.codegen in file callableReferenceUtil.kt[SimpleFunctionDescriptorImpl]

'closure' @ [112:66] ==> protected/*protected and package*/ final val closure: (CalculatedClosure..CalculatedClosure?) defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen[JavaPropertyDescriptor]

'args' @ [112:75] ==> val args: (MutableList<(FieldInfo..FieldInfo?)>..List<(FieldInfo..FieldInfo?)>) defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.generateConstructor[LocalVariableDescriptor]

'iv' @ [114:13] ==> val iv: InstructionAdapter defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.generateConstructor[LocalVariableDescriptor]

'load' @ [114:16] ==> public open fun load(p0: Int, p1: (Type..Type?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'OBJECT_TYPE' @ [114:33] ==> public final val OBJECT_TYPE: (Type..Type?) defined in org.jetbrains.kotlin.resolve.jvm.AsmTypes[JavaPropertyDescriptor]

'iv' @ [115:13] ==> val iv: InstructionAdapter defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.generateConstructor[LocalVariableDescriptor]

'iconst' @ [115:16] ==> public open fun iconst(p0: Int): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'if (passArityToSuperClass) calculateArity() else 0' @ [115:23] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Int, elseBranch: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Int

'passArityToSuperClass' @ [115:27] ==> protected abstract val passArityToSuperClass: Boolean defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen[PropertyDescriptorImpl]

'calculateArity' @ [115:50] ==> protected/*protected and package*/ open fun calculateArity(): Int defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen[JavaMethodDescriptor]

'iv' @ [116:13] ==> val iv: InstructionAdapter defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.generateConstructor[LocalVariableDescriptor]

'load' @ [116:16] ==> public open fun load(p0: Int, p1: (Type..Type?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'argTypes' @ [116:21] ==> val argTypes: Array<Type> defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.generateConstructor[LocalVariableDescriptor]

'map' @ [116:30] ==> public inline fun <T, R> Array<out Type>.map(transform: (Type) -> Int): List<Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Type
    <R> -> Int

'it' @ [116:36] ==> value-parameter it: Type defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.generateConstructor.<anonymous>[ValueParameterDescriptorImpl]

'size' @ [116:39] ==> public final val Type.size: Int[MyPropertyDescriptor]

'sum' @ [116:46] ==> @JvmName public fun Iterable<Int>.sum(): Int defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]

'OBJECT_TYPE' @ [116:62] ==> public final val OBJECT_TYPE: (Type..Type?) defined in org.jetbrains.kotlin.resolve.jvm.AsmTypes[JavaPropertyDescriptor]

'getMethodDescriptor' @ [118:56] ==> public open fun getMethodDescriptor(p0: (Type..Type?), vararg p1: (Type..Type?)): (String..String?) defined in org.jetbrains.org.objectweb.asm.Type[JavaMethodDescriptor]

'VOID_TYPE' @ [119:26] ==> public final val VOID_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'INT_TYPE' @ [120:26] ==> public final val INT_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'CONTINUATION_ASM_TYPE' @ [121:21] ==> @JvmField public val CONTINUATION_ASM_TYPE: Type defined in org.jetbrains.kotlin.codegen.coroutines in file coroutineCodegenUtil.kt[PropertyDescriptorImpl]

'iv' @ [123:13] ==> val iv: InstructionAdapter defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.generateConstructor[LocalVariableDescriptor]

'invokespecial' @ [123:16] ==> public open fun invokespecial(p0: (String..String?), p1: (String..String?), p2: (String..String?), p3: Boolean): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'superClassAsmType' @ [123:30] ==> protected/*protected and package*/ final var superClassAsmType: (Type..Type?) defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen[JavaPropertyDescriptor]

'internalName' @ [123:48] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'superClassConstructorDescriptor' @ [123:72] ==> val superClassConstructorDescriptor: (String..String?) defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.generateConstructor[LocalVariableDescriptor]

'iv' @ [125:13] ==> val iv: InstructionAdapter defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.generateConstructor[LocalVariableDescriptor]

'visitInsn' @ [125:16] ==> public open fun visitInsn(p0: Int): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'RETURN' @ [125:34] ==> public const final val RETURN: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'endVisit' @ [127:29] ==> public open fun endVisit(mv: (MethodVisitor..MethodVisitor?), @Nullable description: String?, @NotNull method: KtElement): Unit defined in org.jetbrains.kotlin.codegen.FunctionCodegen[JavaMethodDescriptor]

'iv' @ [127:38] ==> val iv: InstructionAdapter defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.generateConstructor[LocalVariableDescriptor]

'element' @ [127:57] ==> protected/*protected and package*/ final val element: (KtElement..KtElement?) defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen[JavaPropertyDescriptor]

'constructor' @ [130:16] ==> val constructor: Method defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen.generateConstructor[LocalVariableDescriptor]

'AbstractCoroutineCodegen' @ [142:5] ==> public constructor AbstractCoroutineCodegen(outerExpressionCodegen: ExpressionCodegen, element: KtElement, closureContext: ClosureContext, classBuilder: ClassBuilder, userDataForDoResume: Map<out FunctionDescriptor.UserDataKey<*>, *>? = ...) defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen[ClassConstructorDescriptorImpl]

'outerExpressionCodegen' @ [143:9] ==> value-parameter outerExpressionCodegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.<init>[ValueParameterDescriptorImpl]

'element' @ [143:33] ==> value-parameter element: KtElement defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.<init>[ValueParameterDescriptorImpl]

'closureContext' @ [143:42] ==> value-parameter closureContext: ClosureContext defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.<init>[ValueParameterDescriptorImpl]

'classBuilder' @ [143:58] ==> value-parameter classBuilder: ClassBuilder defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.<init>[ValueParameterDescriptorImpl]

'mapOf' @ [144:31] ==> public fun <K, V> mapOf(pair: Pair<FunctionDescriptor.UserDataKey<FunctionDescriptor>, FunctionDescriptor>): Map<FunctionDescriptor.UserDataKey<FunctionDescriptor>, FunctionDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> UserDataKey<FunctionDescriptor>
    <V> -> FunctionDescriptor

'INITIAL_SUSPEND_DESCRIPTOR_FOR_DO_RESUME' @ [144:37] ==> @JvmField public val INITIAL_SUSPEND_DESCRIPTOR_FOR_DO_RESUME: FunctionDescriptor.UserDataKey<FunctionDescriptor> defined in org.jetbrains.kotlin.codegen.coroutines in file coroutineCodegenUtil.kt[PropertyDescriptorImpl]

'originalSuspendFunctionDescriptor' @ [144:81] ==> value-parameter originalSuspendFunctionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.<init>[ValueParameterDescriptorImpl]

'funDescriptor' @ [146:28] ==> protected/*protected and package*/ final val funDescriptor: (FunctionDescriptor..FunctionDescriptor?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'builtIns' @ [146:42] ==> public val DeclarationDescriptor.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'funDescriptor' @ [151:9] ==> protected/*protected and package*/ final val funDescriptor: (FunctionDescriptor..FunctionDescriptor?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'createCustomCopy' @ [151:23] ==> public fun <D : FunctionDescriptor> (FunctionDescriptor..FunctionDescriptor?).createCustomCopy(copySettings: FunctionDescriptorCopyBuilderToFunctionDescriptorCopyBuilder /* = FunctionDescriptor.CopyBuilder<out FunctionDescriptor>.(FunctionDescriptor) -> FunctionDescriptor.CopyBuilder<out FunctionDescriptor> */): (FunctionDescriptor..FunctionDescriptor?) defined in org.jetbrains.kotlin.codegen.coroutines[SimpleFunctionDescriptorImpl]
Inferred types:
    <D : FunctionDescriptor> -> (org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)

'setName' @ [152:13] ==> @NotNull public abstract fun setName(@NotNull p0: Name): FunctionDescriptor.CopyBuilder<out (FunctionDescriptor..FunctionDescriptor?)> defined in org.jetbrains.kotlin.descriptors.FunctionDescriptor.CopyBuilder[JavaMethodDescriptor]

'identifier' @ [152:26] ==> @NotNull public open fun identifier(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'SUSPEND_FUNCTION_CREATE_METHOD_NAME' @ [152:37] ==> public const val SUSPEND_FUNCTION_CREATE_METHOD_NAME: String defined in org.jetbrains.kotlin.codegen.coroutines in file coroutineCodegenUtil.kt[PropertyDescriptorImpl]

'setReturnType' @ [153:13] ==> @NotNull public abstract fun setReturnType(@NotNull p0: KotlinType): FunctionDescriptor.CopyBuilder<out (FunctionDescriptor..FunctionDescriptor?)> defined in org.jetbrains.kotlin.descriptors.FunctionDescriptor.CopyBuilder[JavaMethodDescriptor]

'funDescriptor' @ [154:21] ==> protected/*protected and package*/ final val funDescriptor: (FunctionDescriptor..FunctionDescriptor?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'module' @ [154:35] ==> public val DeclarationDescriptor.module: ModuleDescriptor defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'getContinuationOfTypeOrAny' @ [154:42] ==> public fun ModuleDescriptor.getContinuationOfTypeOrAny(kotlinType: KotlinType): SimpleType defined in org.jetbrains.kotlin.codegen.coroutines in file coroutineCodegenUtil.kt[SimpleFunctionDescriptorImpl]

'builtIns' @ [154:69] ==> private final val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[PropertyDescriptorImpl]

'unitType' @ [154:78] ==> public final val KotlinBuiltIns.unitType: SimpleType[MyPropertyDescriptor]

'putUserData' @ [157:13] ==> @NotNull public abstract fun <V : (Any..Any?)> putUserData(@NotNull p0: FunctionDescriptor.UserDataKey<(FunctionDescriptor..FunctionDescriptor?)>, p1: (FunctionDescriptor..FunctionDescriptor?)): FunctionDescriptor.CopyBuilder<out (FunctionDescriptor..FunctionDescriptor?)> defined in org.jetbrains.kotlin.descriptors.FunctionDescriptor.CopyBuilder[JavaMethodDescriptor]
Inferred types:
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)

'INITIAL_DESCRIPTOR_FOR_SUSPEND_FUNCTION' @ [157:25] ==> @JvmField public val INITIAL_DESCRIPTOR_FOR_SUSPEND_FUNCTION: FunctionDescriptor.UserDataKey<FunctionDescriptor> defined in org.jetbrains.kotlin.codegen.coroutines in file coroutineCodegenUtil.kt[PropertyDescriptorImpl]

'setVisibility' @ [158:13] ==> @NotNull public abstract fun setVisibility(@NotNull p0: Visibility): FunctionDescriptor.CopyBuilder<out (FunctionDescriptor..FunctionDescriptor?)> defined in org.jetbrains.kotlin.descriptors.FunctionDescriptor.CopyBuilder[JavaMethodDescriptor]

'PUBLIC' @ [158:40] ==> @NotNull public final val PUBLIC: Visibility defined in org.jetbrains.kotlin.descriptors.Visibilities[JavaPropertyDescriptor]

'allFunctionParameters' @ [162:27] ==> private final fun allFunctionParameters(): List<(ParameterDescriptor..ParameterDescriptor?)> defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[SimpleFunctionDescriptorImpl]

'parameter' @ [163:29] ==> val parameter: (ParameterDescriptor..ParameterDescriptor?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateClosureBody[LocalVariableDescriptor]

'getFieldInfoForCoroutineLambdaParameter' @ [163:39] ==> private final fun ParameterDescriptor.getFieldInfoForCoroutineLambdaParameter(): FieldInfo defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[SimpleFunctionDescriptorImpl]

'v' @ [164:13] ==> public final val v: (ClassBuilder..ClassBuilder?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'newField' @ [164:15] ==> @NotNull public abstract fun newField(@NotNull origin: JvmDeclarationOrigin, access: Int, @NotNull name: String, @NotNull desc: String, @Nullable signature: String?, @Nullable value: Any?): FieldVisitor defined in org.jetbrains.kotlin.codegen.ClassBuilder[JavaMethodDescriptor]

'OtherOrigin' @ [165:21] ==> public fun OtherOrigin(descriptor: DeclarationDescriptor): JvmDeclarationOrigin defined in org.jetbrains.kotlin.resolve.jvm.diagnostics[DeserializedSimpleFunctionDescriptor]

'parameter' @ [165:33] ==> val parameter: (ParameterDescriptor..ParameterDescriptor?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateClosureBody[LocalVariableDescriptor]

'ACC_PRIVATE' @ [166:29] ==> public const final val ACC_PRIVATE: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'fieldInfo' @ [167:21] ==> val fieldInfo: FieldInfo defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateClosureBody[LocalVariableDescriptor]

'fieldName' @ [167:31] ==> public final val FieldInfo.fieldName: String[MyPropertyDescriptor]

'fieldInfo' @ [168:21] ==> val fieldInfo: FieldInfo defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateClosureBody[LocalVariableDescriptor]

'fieldType' @ [168:31] ==> public final val FieldInfo.fieldType: Type[MyPropertyDescriptor]

'descriptor' @ [168:41] ==> public final val Type.descriptor: (String..String?)[MyPropertyDescriptor]

'generateDoResume' @ [172:9] ==> private final fun generateDoResume(): Unit defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[SimpleFunctionDescriptorImpl]

'super' @ [176:9] ==> <this> defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[LazyClassReceiverParameterDescriptor]

'generateBody' @ [176:15] ==> @Override protected/*protected and package*/ open fun generateBody(): Unit defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen[JavaMethodDescriptor]

'functionCodegen' @ [179:9] ==> public final val functionCodegen: (FunctionCodegen..FunctionCodegen?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'generateMethod' @ [179:25] ==> public open fun generateMethod(@NotNull origin: JvmDeclarationOrigin, @NotNull descriptor: FunctionDescriptor, @NotNull strategy: FunctionGenerationStrategy): Unit defined in org.jetbrains.kotlin.codegen.FunctionCodegen[JavaMethodDescriptor]

'NO_ORIGIN' @ [179:61] ==> @field:JvmField public final val NO_ORIGIN: JvmDeclarationOrigin defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOrigin.Companion[DeserializedPropertyDescriptor]

'createCoroutineDescriptor' @ [179:72] ==> private final val createCoroutineDescriptor: (FunctionDescriptor..FunctionDescriptor?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[PropertyDescriptorImpl]

'FunctionGenerationStrategy.CodegenBased' @ [180:49] ==> public constructor CodegenBased(@NotNull state: GenerationState) defined in org.jetbrains.kotlin.codegen.FunctionGenerationStrategy.CodegenBased[JavaClassConstructorDescriptor]

'state' @ [180:89] ==> public final val state: (GenerationState..GenerationState?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'generateCreateCoroutineMethod' @ [182:48] ==> private final fun generateCreateCoroutineMethod(codegen: ExpressionCodegen): Unit defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[SimpleFunctionDescriptorImpl]

'codegen' @ [182:78] ==> value-parameter codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateBody.<no name provided>.doGenerateBody[ValueParameterDescriptorImpl]

'functionCodegen' @ [187:9] ==> public final val functionCodegen: (FunctionCodegen..FunctionCodegen?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'generateMethod' @ [187:25] ==> public open fun generateMethod(@NotNull origin: JvmDeclarationOrigin, @NotNull descriptor: FunctionDescriptor, @NotNull strategy: FunctionGenerationStrategy): Unit defined in org.jetbrains.kotlin.codegen.FunctionCodegen[JavaMethodDescriptor]

'NO_ORIGIN' @ [187:61] ==> @field:JvmField public final val NO_ORIGIN: JvmDeclarationOrigin defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOrigin.Companion[DeserializedPropertyDescriptor]

'funDescriptor' @ [187:72] ==> protected/*protected and package*/ final val funDescriptor: (FunctionDescriptor..FunctionDescriptor?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'FunctionGenerationStrategy.CodegenBased' @ [188:49] ==> public constructor CodegenBased(@NotNull state: GenerationState) defined in org.jetbrains.kotlin.codegen.FunctionGenerationStrategy.CodegenBased[JavaClassConstructorDescriptor]

'state' @ [188:89] ==> public final val state: (GenerationState..GenerationState?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'codegen' @ [190:48] ==> value-parameter codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateBody.<no name provided>.doGenerateBody[ValueParameterDescriptorImpl]

'v' @ [190:56] ==> public final val v: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'generateInvokeMethod' @ [190:58] ==> private final fun InstructionAdapter.generateInvokeMethod(signature: JvmMethodSignature): Unit defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[SimpleFunctionDescriptorImpl]

'signature' @ [190:79] ==> value-parameter signature: JvmMethodSignature defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateBody.<no name provided>.doGenerateBody[ValueParameterDescriptorImpl]

'allFunctionParameters' @ [194:13] ==> private final fun allFunctionParameters(): List<(ParameterDescriptor..ParameterDescriptor?)> defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[SimpleFunctionDescriptorImpl]

'size' @ [194:37] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'typeMapper' @ [195:28] ==> public final val typeMapper: (KotlinTypeMapper..KotlinTypeMapper?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'mapSignatureSkipGeneric' @ [195:39] ==> @NotNull public open fun mapSignatureSkipGeneric(@NotNull f: FunctionDescriptor): JvmMethodSignature defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'createCoroutineDescriptor' @ [195:63] ==> private final val createCoroutineDescriptor: (FunctionDescriptor..FunctionDescriptor?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[PropertyDescriptorImpl]

'asmMethod' @ [195:90] ==> public final val JvmMethodSignature.asmMethod: Method[MyPropertyDescriptor]

'+' @ [197:36] ==> public operator fun <T> Collection<(Type..Type?)>.plus(element: (Type..Type?)): List<(Type..Type?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.org.objectweb.asm.Type..org.jetbrains.org.objectweb.asm.Type?)

'until' @ [197:37] ==> public infix fun Int.until(to: Int): IntRange defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor]

'delegate' @ [197:45] ==> val delegate: Method defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateBody[LocalVariableDescriptor]

'argumentTypes' @ [197:54] ==> public final val Method.argumentTypes: (Array<(Type..Type?)>..Array<out (Type..Type?)>?)[MyPropertyDescriptor]

'size' @ [197:68] ==> public final val size: Int defined in kotlin.Array[DeserializedPropertyDescriptor]

'map' @ [197:74] ==> public inline fun <T, R> Iterable<Int>.map(transform: (Int) -> (Type..Type?)): List<(Type..Type?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Int
    <R> -> (org.jetbrains.org.objectweb.asm.Type..org.jetbrains.org.objectweb.asm.Type?)

'OBJECT_TYPE' @ [197:89] ==> public final val OBJECT_TYPE: (Type..Type?) defined in org.jetbrains.kotlin.resolve.jvm.AsmTypes[JavaPropertyDescriptor]

'delegate' @ [197:105] ==> val delegate: Method defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateBody[LocalVariableDescriptor]

'argumentTypes' @ [197:114] ==> public final val Method.argumentTypes: (Array<(Type..Type?)>..Array<out (Type..Type?)>?)[MyPropertyDescriptor]

'last' @ [197:128] ==> public fun <T> Array<out (Type..Type?)>.last(): (Type..Type?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.org.objectweb.asm.Type..org.jetbrains.org.objectweb.asm.Type?)

'Method' @ [198:26] ==> public constructor Method(p0: (String..String?), p1: (Type..Type?), p2: (Array<(Type..Type?)>..Array<out (Type..Type?)>?)) defined in org.jetbrains.org.objectweb.asm.commons.Method[JavaClassConstructorDescriptor]

'delegate' @ [198:33] ==> val delegate: Method defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateBody[LocalVariableDescriptor]

'name' @ [198:42] ==> public final val Method.name: (String..String?)[MyPropertyDescriptor]

'delegate' @ [198:48] ==> val delegate: Method defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateBody[LocalVariableDescriptor]

'returnType' @ [198:57] ==> public final val Method.returnType: (Type..Type?)[MyPropertyDescriptor]

'bridgeParameters' @ [198:69] ==> val bridgeParameters: List<(Type..Type?)> defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateBody[LocalVariableDescriptor]

'toTypedArray' @ [198:86] ==> public inline fun <reified T> Collection<(Type..Type?)>.toTypedArray(): Array<(Type..Type?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T> -> (org.jetbrains.org.objectweb.asm.Type..org.jetbrains.org.objectweb.asm.Type?)

'generateBridge' @ [200:13] ==> protected/*protected and package*/ open fun generateBridge(@NotNull bridge: Method, @NotNull delegate: Method): Unit defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaMethodDescriptor]

'bridge' @ [200:28] ==> val bridge: Method defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateBody[LocalVariableDescriptor]

'delegate' @ [200:36] ==> val delegate: Method defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateBody[LocalVariableDescriptor]

'load' @ [206:9] ==> public open fun load(p0: Int, p1: (Type..Type?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'OBJECT_TYPE' @ [206:26] ==> public final val OBJECT_TYPE: (Type..Type?) defined in org.jetbrains.kotlin.resolve.jvm.AsmTypes[JavaPropertyDescriptor]

'signature' @ [207:30] ==> value-parameter signature: JvmMethodSignature defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateInvokeMethod[ValueParameterDescriptorImpl]

'valueParameters' @ [207:40] ==> public final val JvmMethodSignature.valueParameters: (MutableList<(JvmMethodParameterSignature..JvmMethodParameterSignature?)>..List<(JvmMethodParameterSignature..JvmMethodParameterSignature?)>)[MyPropertyDescriptor]

'map' @ [207:56] ==> public inline fun <T, R> Iterable<(JvmMethodParameterSignature..JvmMethodParameterSignature?)>.map(transform: ((JvmMethodParameterSignature..JvmMethodParameterSignature?)) -> Type): List<Type> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.resolve.jvm.jvmSignature.JvmMethodParameterSignature..org.jetbrains.kotlin.resolve.jvm.jvmSignature.JvmMethodParameterSignature?)
    <R> -> Type

'it' @ [207:62] ==> value-parameter it: (JvmMethodParameterSignature..JvmMethodParameterSignature?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateInvokeMethod.<anonymous>[ValueParameterDescriptorImpl]

'asmType' @ [207:65] ==> public final val JvmMethodParameterSignature.asmType: Type[MyPropertyDescriptor]

'parameterTypes' @ [208:9] ==> val parameterTypes: List<Type> defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateInvokeMethod[LocalVariableDescriptor]

'withVariableIndices' @ [208:24] ==> public fun Collection<Type>.withVariableIndices(): List<Pair<Int, Type>> defined in org.jetbrains.kotlin.codegen in file codegenUtil.kt[SimpleFunctionDescriptorImpl]

'forEach' @ [208:46] ==> @HidesMembers public inline fun <T> Iterable<Pair<Int, Type>>.forEach(action: (Pair<Int, Type>) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<Int, Type>

'component1' @ [209:14] ==> public final operator fun component1(): Int defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [209:21] ==> public final operator fun component2(): Type defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'load' @ [209:30] ==> public open fun load(p0: Int, p1: (Type..Type?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'index' @ [209:35] ==> val index: Int defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateInvokeMethod.<anonymous>[LocalVariableDescriptor]

'type' @ [209:46] ==> val type: Type defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateInvokeMethod.<anonymous>[LocalVariableDescriptor]

'invokevirtual' @ [213:9] ==> public open fun invokevirtual(p0: (String..String?), p1: (String..String?), p2: (String..String?), p3: Boolean): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'v' @ [214:17] ==> public final val v: (ClassBuilder..ClassBuilder?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'thisName' @ [214:19] ==> public final val ClassBuilder.thisName: String[MyPropertyDescriptor]

'createCoroutineDescriptor' @ [215:17] ==> private final val createCoroutineDescriptor: (FunctionDescriptor..FunctionDescriptor?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[PropertyDescriptorImpl]

'name' @ [215:43] ==> public final val FunctionDescriptor.name: Name[MyPropertyDescriptor]

'identifier' @ [215:48] ==> public final val Name.identifier: String[MyPropertyDescriptor]

'getMethodDescriptor' @ [216:22] ==> public open fun getMethodDescriptor(p0: (Type..Type?), vararg p1: (Type..Type?)): (String..String?) defined in org.jetbrains.org.objectweb.asm.Type[JavaMethodDescriptor]

'CONTINUATION_ASM_TYPE' @ [217:25] ==> @JvmField public val CONTINUATION_ASM_TYPE: Type defined in org.jetbrains.kotlin.codegen.coroutines in file coroutineCodegenUtil.kt[PropertyDescriptorImpl]

'parameterTypes' @ [218:26] ==> val parameterTypes: List<Type> defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateInvokeMethod[LocalVariableDescriptor]

'toTypedArray' @ [218:41] ==> public inline fun <reified T> Collection<Type>.toTypedArray(): Array<Type> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T> -> Type

'checkcast' @ [222:9] ==> public open fun checkcast(p0: (Type..Type?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'getObjectType' @ [222:24] ==> public open fun getObjectType(p0: (String..String?)): (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaMethodDescriptor]

'v' @ [222:38] ==> public final val v: (ClassBuilder..ClassBuilder?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'thisName' @ [222:40] ==> public final val ClassBuilder.thisName: String[MyPropertyDescriptor]

'invokeDoResumeWithUnit' @ [225:9] ==> public fun InstructionAdapter.invokeDoResumeWithUnit(thisName: String): Unit defined in org.jetbrains.kotlin.codegen.coroutines in file coroutineCodegenUtil.kt[SimpleFunctionDescriptorImpl]

'v' @ [225:32] ==> public final val v: (ClassBuilder..ClassBuilder?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'thisName' @ [225:34] ==> public final val ClassBuilder.thisName: String[MyPropertyDescriptor]

'areturn' @ [226:9] ==> public open fun areturn(p0: (Type..Type?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'OBJECT_TYPE' @ [226:26] ==> public final val OBJECT_TYPE: (Type..Type?) defined in org.jetbrains.kotlin.resolve.jvm.AsmTypes[JavaPropertyDescriptor]

'constructorToUseFromInvoke' @ [232:9] ==> private final lateinit var constructorToUseFromInvoke: Method defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[PropertyDescriptorImpl]

'super' @ [232:38] ==> <this> defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[LazyClassReceiverParameterDescriptor]

'generateConstructor' @ [232:44] ==> protected open fun generateConstructor(): Method defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen[SimpleFunctionDescriptorImpl]

'constructorToUseFromInvoke' @ [233:16] ==> private final lateinit var constructorToUseFromInvoke: Method defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[PropertyDescriptorImpl]

'closureContext' @ [237:31] ==> private final val closureContext: ClosureContext defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[PropertyDescriptorImpl]

'contextDescriptor' @ [237:46] ==> public final val ClosureContext.contextDescriptor: ClassDescriptor[MyPropertyDescriptor]

'typeMapper' @ [238:21] ==> public final val typeMapper: (KotlinTypeMapper..KotlinTypeMapper?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'mapClass' @ [238:32] ==> @NotNull public open fun mapClass(@NotNull classifier: ClassifierDescriptor): Type defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'classDescriptor' @ [238:41] ==> val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod[LocalVariableDescriptor]

'thisOrOuter' @ [240:39] ==> @NotNull public open fun thisOrOuter(@NotNull codegen: ExpressionCodegen, @NotNull descriptor: ClassDescriptor, isSuper: Boolean, castReceiver: Boolean): StackValue defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'codegen' @ [240:51] ==> value-parameter codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod[ValueParameterDescriptorImpl]

'classDescriptor' @ [240:60] ==> val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod[LocalVariableDescriptor]

'with' @ [242:9] ==> @InlineOnly public inline fun <T, R> with(receiver: (InstructionAdapter..InstructionAdapter?), block: (InstructionAdapter..InstructionAdapter?).() -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.org.objectweb.asm.commons.InstructionAdapter..org.jetbrains.org.objectweb.asm.commons.InstructionAdapter?)
    <R> -> Unit

'codegen' @ [242:14] ==> value-parameter codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod[ValueParameterDescriptorImpl]

'v' @ [242:22] ==> public final val v: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'anew' @ [243:13] ==> public open fun anew(p0: (Type..Type?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'owner' @ [243:18] ==> val owner: Type defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod[LocalVariableDescriptor]

'dup' @ [244:13] ==> public open fun dup(): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'calculateConstructorParameters' @ [247:41] ==> @NotNull public open fun calculateConstructorParameters(@NotNull typeMapper: KotlinTypeMapper, @NotNull closure: CalculatedClosure, @NotNull ownerType: Type): (MutableList<(FieldInfo..FieldInfo?)>..List<(FieldInfo..FieldInfo?)>) defined in org.jetbrains.kotlin.codegen.ClosureCodegen[JavaMethodDescriptor]

'typeMapper' @ [247:72] ==> public final val typeMapper: (KotlinTypeMapper..KotlinTypeMapper?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'closure' @ [247:84] ==> protected/*protected and package*/ final val closure: (CalculatedClosure..CalculatedClosure?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'owner' @ [247:93] ==> val owner: Type defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod[LocalVariableDescriptor]

'constructorParameters' @ [248:31] ==> val constructorParameters: (MutableList<(FieldInfo..FieldInfo?)>..List<(FieldInfo..FieldInfo?)>) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod.<anonymous>[LocalVariableDescriptor]

'field' @ [249:28] ==> @NotNull public open fun field(@NotNull info: FieldInfo, @NotNull receiver: StackValue): StackValue.Field defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'parameter' @ [249:34] ==> val parameter: (FieldInfo..FieldInfo?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod.<anonymous>[LocalVariableDescriptor]

'thisInstance' @ [249:45] ==> val thisInstance: StackValue defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod[LocalVariableDescriptor]

'put' @ [249:59] ==> public open fun put(@NotNull type: Type, @NotNull v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.StackValue.Field[JavaMethodDescriptor]

'parameter' @ [249:63] ==> val parameter: (FieldInfo..FieldInfo?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod.<anonymous>[LocalVariableDescriptor]

'fieldType' @ [249:73] ==> public final val FieldInfo.fieldType: Type[MyPropertyDescriptor]

'this' @ [249:84] ==> <this> defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod.<anonymous>[ReceiverParameterDescriptorImpl]

'load' @ [253:13] ==> public open fun load(p0: Int, p1: (Type..Type?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'allFunctionParameters' @ [253:18] ==> private final fun allFunctionParameters(): List<(ParameterDescriptor..ParameterDescriptor?)> defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[SimpleFunctionDescriptorImpl]

'map' @ [253:42] ==> public inline fun <T, R> Iterable<(ParameterDescriptor..ParameterDescriptor?)>.map(transform: ((ParameterDescriptor..ParameterDescriptor?)) -> Int): List<Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ParameterDescriptor..org.jetbrains.kotlin.descriptors.ParameterDescriptor?)
    <R> -> Int

'typeMapper' @ [253:48] ==> public final val typeMapper: (KotlinTypeMapper..KotlinTypeMapper?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'mapType' @ [253:59] ==> @NotNull public open fun mapType(@NotNull jetType: KotlinType): Type defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'it' @ [253:67] ==> value-parameter it: (ParameterDescriptor..ParameterDescriptor?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [253:70] ==> public final val ParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'size' @ [253:76] ==> public final val Type.size: Int[MyPropertyDescriptor]

'sum' @ [253:83] ==> @JvmName public fun Iterable<Int>.sum(): Int defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]

'OBJECT_TYPE' @ [253:103] ==> public final val OBJECT_TYPE: (Type..Type?) defined in org.jetbrains.kotlin.resolve.jvm.AsmTypes[JavaPropertyDescriptor]

'invokespecial' @ [255:13] ==> public open fun invokespecial(p0: (String..String?), p1: (String..String?), p2: (String..String?), p3: Boolean): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'owner' @ [255:27] ==> val owner: Type defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod[LocalVariableDescriptor]

'internalName' @ [255:33] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'constructorToUseFromInvoke' @ [255:47] ==> private final lateinit var constructorToUseFromInvoke: Method defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[PropertyDescriptorImpl]

'name' @ [255:74] ==> public final val Method.name: (String..String?)[MyPropertyDescriptor]

'constructorToUseFromInvoke' @ [255:80] ==> private final lateinit var constructorToUseFromInvoke: Method defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[PropertyDescriptorImpl]

'descriptor' @ [255:107] ==> public final val Method.descriptor: (String..String?)[MyPropertyDescriptor]

'codegen' @ [257:30] ==> value-parameter codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod[ValueParameterDescriptorImpl]

'frameMap' @ [257:38] ==> public open val frameMap: FrameMap defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'enterTemp' @ [257:47] ==> public open fun enterTemp(type: (Type..Type?)): Int defined in org.jetbrains.kotlin.codegen.FrameMap[JavaMethodDescriptor]

'OBJECT_TYPE' @ [257:66] ==> public final val OBJECT_TYPE: (Type..Type?) defined in org.jetbrains.kotlin.resolve.jvm.AsmTypes[JavaPropertyDescriptor]

'store' @ [258:13] ==> public open fun store(p0: Int, p1: (Type..Type?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'cloneIndex' @ [258:19] ==> val cloneIndex: Int defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod.<anonymous>[LocalVariableDescriptor]

'OBJECT_TYPE' @ [258:40] ==> public final val OBJECT_TYPE: (Type..Type?) defined in org.jetbrains.kotlin.resolve.jvm.AsmTypes[JavaPropertyDescriptor]

'allFunctionParameters' @ [262:31] ==> private final fun allFunctionParameters(): List<(ParameterDescriptor..ParameterDescriptor?)> defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[SimpleFunctionDescriptorImpl]

'parameter' @ [263:60] ==> val parameter: (ParameterDescriptor..ParameterDescriptor?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod.<anonymous>[LocalVariableDescriptor]

'getFieldInfoForCoroutineLambdaParameter' @ [263:70] ==> private final fun ParameterDescriptor.getFieldInfoForCoroutineLambdaParameter(): FieldInfo defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[SimpleFunctionDescriptorImpl]

'load' @ [264:17] ==> public open fun load(p0: Int, p1: (Type..Type?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'index' @ [264:22] ==> var index: Int defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod.<anonymous>[LocalVariableDescriptor]

'fieldInfoForCoroutineLambdaParameter' @ [264:29] ==> val fieldInfoForCoroutineLambdaParameter: FieldInfo defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod.<anonymous>[LocalVariableDescriptor]

'fieldType' @ [264:66] ==> public final val FieldInfo.fieldType: Type[MyPropertyDescriptor]

'genAssignInstanceFieldFromParam' @ [265:25] ==> public open fun genAssignInstanceFieldFromParam(info: (FieldInfo..FieldInfo?), index: Int, iv: (InstructionAdapter..InstructionAdapter?), ownerIndex: Int): Int defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaMethodDescriptor]

'fieldInfoForCoroutineLambdaParameter' @ [265:57] ==> val fieldInfoForCoroutineLambdaParameter: FieldInfo defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod.<anonymous>[LocalVariableDescriptor]

'index' @ [265:95] ==> var index: Int defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod.<anonymous>[LocalVariableDescriptor]

'this' @ [265:102] ==> <this> defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod.<anonymous>[ReceiverParameterDescriptorImpl]

'cloneIndex' @ [265:108] ==> val cloneIndex: Int defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod.<anonymous>[LocalVariableDescriptor]

'index' @ [266:17] ==> var index: Int defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod.<anonymous>[LocalVariableDescriptor]

'fieldInfoForCoroutineLambdaParameter' @ [266:26] ==> val fieldInfoForCoroutineLambdaParameter: FieldInfo defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod.<anonymous>[LocalVariableDescriptor]

'fieldType' @ [266:63] ==> public final val FieldInfo.fieldType: Type[MyPropertyDescriptor]

'size' @ [266:73] ==> public final val Type.size: Int[MyPropertyDescriptor]

'load' @ [269:13] ==> public open fun load(p0: Int, p1: (Type..Type?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'cloneIndex' @ [269:18] ==> val cloneIndex: Int defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateCreateCoroutineMethod.<anonymous>[LocalVariableDescriptor]

'OBJECT_TYPE' @ [269:39] ==> public final val OBJECT_TYPE: (Type..Type?) defined in org.jetbrains.kotlin.resolve.jvm.AsmTypes[JavaPropertyDescriptor]

'areturn' @ [270:13] ==> public open fun areturn(p0: (Type..Type?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'OBJECT_TYPE' @ [270:30] ==> public final val OBJECT_TYPE: (Type..Type?) defined in org.jetbrains.kotlin.resolve.jvm.AsmTypes[JavaPropertyDescriptor]

'allFunctionParameters' @ [275:27] ==> private final fun allFunctionParameters(): List<(ParameterDescriptor..ParameterDescriptor?)> defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[SimpleFunctionDescriptorImpl]

'field' @ [277:32] ==> @NotNull public open fun field(@NotNull info: FieldInfo, @NotNull receiver: StackValue): StackValue.Field defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'parameter' @ [278:29] ==> val parameter: (ParameterDescriptor..ParameterDescriptor?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.initializeCoroutineParameters[LocalVariableDescriptor]

'getFieldInfoForCoroutineLambdaParameter' @ [278:39] ==> private final fun ParameterDescriptor.getFieldInfoForCoroutineLambdaParameter(): FieldInfo defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[SimpleFunctionDescriptorImpl]

'generateThisOrOuter' @ [278:82] ==> @NotNull public open fun generateThisOrOuter(@NotNull calleeContainingClass: ClassDescriptor, isSuper: Boolean): StackValue defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'context' @ [278:102] ==> public final val context: (MethodContext..MethodContext?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'thisDescriptor' @ [278:110] ==> public final val MethodContext.thisDescriptor: ClassDescriptor[MyPropertyDescriptor]

'typeMapper' @ [281:30] ==> public final val typeMapper: (KotlinTypeMapper..KotlinTypeMapper?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'mapType' @ [281:41] ==> @NotNull public open fun mapType(@NotNull jetType: KotlinType): Type defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'parameter' @ [281:49] ==> val parameter: (ParameterDescriptor..ParameterDescriptor?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.initializeCoroutineParameters[LocalVariableDescriptor]

'type' @ [281:59] ==> public final val ParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'fieldStackValue' @ [282:13] ==> val fieldStackValue: StackValue.Field defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.initializeCoroutineParameters[LocalVariableDescriptor]

'put' @ [282:29] ==> public open fun put(@NotNull type: Type, @NotNull v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.StackValue.Field[JavaMethodDescriptor]

'mappedType' @ [282:33] ==> val mappedType: Type defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.initializeCoroutineParameters[LocalVariableDescriptor]

'v' @ [282:45] ==> public final val v: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'myFrameMap' @ [284:28] ==> public final val myFrameMap: (FrameMap..FrameMap?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'enter' @ [284:39] ==> public open fun enter(descriptor: (DeclarationDescriptor..DeclarationDescriptor?), type: (Type..Type?)): Int defined in org.jetbrains.kotlin.codegen.FrameMap[JavaMethodDescriptor]

'parameter' @ [284:45] ==> val parameter: (ParameterDescriptor..ParameterDescriptor?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.initializeCoroutineParameters[LocalVariableDescriptor]

'mappedType' @ [284:56] ==> val mappedType: Type defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.initializeCoroutineParameters[LocalVariableDescriptor]

'v' @ [285:13] ==> public final val v: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'store' @ [285:15] ==> public open fun store(p0: Int, p1: (Type..Type?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'newIndex' @ [285:21] ==> val newIndex: Int defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.initializeCoroutineParameters[LocalVariableDescriptor]

'mappedType' @ [285:31] ==> val mappedType: Type defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.initializeCoroutineParameters[LocalVariableDescriptor]

'initializeVariablesForDestructuredLambdaParameters' @ [288:9] ==> public fun initializeVariablesForDestructuredLambdaParameters(codegen: ExpressionCodegen, valueParameters: List<ValueParameterDescriptor>): Unit defined in org.jetbrains.kotlin.codegen in file codegenUtil.kt[SimpleFunctionDescriptorImpl]

'this' @ [288:60] ==> <this> defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.initializeCoroutineParameters[ReceiverParameterDescriptorImpl]

'originalSuspendFunctionDescriptor' @ [288:66] ==> private final val originalSuspendFunctionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[PropertyDescriptorImpl]

'valueParameters' @ [288:100] ==> public final val FunctionDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'originalSuspendFunctionDescriptor' @ [292:13] ==> private final val originalSuspendFunctionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[PropertyDescriptorImpl]

'extensionReceiverParameter' @ [292:47] ==> public final val FunctionDescriptor.extensionReceiverParameter: ReceiverParameterDescriptor?[MyPropertyDescriptor]

'let' @ [292:74] ==> @InlineOnly public inline fun <T, R> ReceiverParameterDescriptor?.let(block: (ReceiverParameterDescriptor?) -> List<ReceiverParameterDescriptor>): List<ReceiverParameterDescriptor> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ReceiverParameterDescriptor?
    <R> -> List<ReceiverParameterDescriptor>

'listOfNotNull' @ [292:80] ==> public fun <T : Any> listOfNotNull(element: ReceiverParameterDescriptor?): List<ReceiverParameterDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> ReceiverParameterDescriptor

'originalSuspendFunctionDescriptor' @ [293:13] ==> private final val originalSuspendFunctionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[PropertyDescriptorImpl]

'valueParameters' @ [293:47] ==> public final val FunctionDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'createHiddenFieldInfo' @ [296:13] ==> private final fun createHiddenFieldInfo(type: KotlinType, name: String): FieldInfo defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[SimpleFunctionDescriptorImpl]

'type' @ [296:35] ==> public final val ParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'COROUTINE_LAMBDA_PARAMETER_PREFIX' @ [296:41] ==> private const val COROUTINE_LAMBDA_PARAMETER_PREFIX: String defined in org.jetbrains.kotlin.codegen.coroutines in file CoroutineCodegen.kt[PropertyDescriptorImpl]

'this' @ [296:78] ==> <this> defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.getFieldInfoForCoroutineLambdaParameter[ReceiverParameterDescriptorImpl]

'safeAs' @ [296:83] ==> public inline fun <reified T : Any> Any?.safeAs(): ValueParameterDescriptor? defined in org.jetbrains.kotlin.utils.addToStdlib[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : Any> -> ValueParameterDescriptor

'index' @ [296:119] ==> public abstract val index: Int defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'createForHiddenField' @ [299:23] ==> @NotNull public open fun createForHiddenField(@NotNull owner: Type, @NotNull fieldType: Type, @NotNull fieldName: String): FieldInfo defined in org.jetbrains.kotlin.codegen.FieldInfo[JavaMethodDescriptor]

'typeMapper' @ [300:21] ==> public final val typeMapper: (KotlinTypeMapper..KotlinTypeMapper?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'mapClass' @ [300:32] ==> @NotNull public open fun mapClass(@NotNull classifier: ClassifierDescriptor): Type defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'closureContext' @ [300:41] ==> private final val closureContext: ClosureContext defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[PropertyDescriptorImpl]

'thisDescriptor' @ [300:56] ==> public final val ClosureContext.thisDescriptor: ClassDescriptor[MyPropertyDescriptor]

'typeMapper' @ [301:21] ==> public final val typeMapper: (KotlinTypeMapper..KotlinTypeMapper?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'mapType' @ [301:32] ==> @NotNull public open fun mapType(@NotNull jetType: KotlinType): Type defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'type' @ [301:40] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.createHiddenFieldInfo[ValueParameterDescriptorImpl]

'name' @ [302:21] ==> value-parameter name: String defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.createHiddenFieldInfo[ValueParameterDescriptorImpl]

'functionCodegen' @ [306:9] ==> public final val functionCodegen: (FunctionCodegen..FunctionCodegen?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'generateMethod' @ [306:25] ==> public open fun generateMethod(@NotNull origin: JvmDeclarationOrigin, @NotNull descriptor: FunctionDescriptor, @NotNull strategy: FunctionGenerationStrategy): Unit defined in org.jetbrains.kotlin.codegen.FunctionCodegen[JavaMethodDescriptor]

'OtherOrigin' @ [307:17] ==> @JvmOverloads public fun OtherOrigin(element: PsiElement?, descriptor: DeclarationDescriptor? = ...): JvmDeclarationOrigin defined in org.jetbrains.kotlin.resolve.jvm.diagnostics[DeserializedSimpleFunctionDescriptor]

'element' @ [307:29] ==> protected/*protected and package*/ final val element: (KtElement..KtElement?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'doResumeDescriptor' @ [308:17] ==> protected final val doResumeDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[PropertyDescriptorImpl]

'FunctionGenerationStrategy.FunctionDefault' @ [309:26] ==> public constructor FunctionDefault(@NotNull state: GenerationState, @NotNull declaration: KtDeclarationWithBody) defined in org.jetbrains.kotlin.codegen.FunctionGenerationStrategy.FunctionDefault[JavaClassConstructorDescriptor]

'state' @ [309:69] ==> public final val state: (GenerationState..GenerationState?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'element' @ [309:76] ==> protected/*protected and package*/ final val element: (KtElement..KtElement?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'CoroutineTransformerMethodVisitor' @ [312:32] ==> public constructor CoroutineTransformerMethodVisitor(delegate: MethodVisitor, access: Int, name: String, desc: String, signature: String?, exceptions: Array<out String>?, containingClassInternalName: String, obtainClassBuilderForCoroutineState: () -> ClassBuilder, isForNamedFunction: Boolean, element: KtElement, needDispatchReceiver: Boolean = ..., internalNameForDispatchReceiver: String? = ...) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineTransformerMethodVisitor[ClassConstructorDescriptorImpl]

'mv' @ [313:33] ==> value-parameter mv: MethodVisitor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateDoResume.<no name provided>.wrapMethodVisitor[ValueParameterDescriptorImpl]

'access' @ [313:37] ==> value-parameter access: Int defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateDoResume.<no name provided>.wrapMethodVisitor[ValueParameterDescriptorImpl]

'name' @ [313:45] ==> value-parameter name: String defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateDoResume.<no name provided>.wrapMethodVisitor[ValueParameterDescriptorImpl]

'desc' @ [313:51] ==> value-parameter desc: String defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateDoResume.<no name provided>.wrapMethodVisitor[ValueParameterDescriptorImpl]

'v' @ [314:73] ==> public final val v: (ClassBuilder..ClassBuilder?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'element' @ [315:43] ==> protected/*protected and package*/ final val element: (KtElement..KtElement?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'v' @ [316:63] ==> public final val v: (ClassBuilder..ClassBuilder?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[JavaPropertyDescriptor]

'thisName' @ [316:65] ==> public final val ClassBuilder.thisName: String[MyPropertyDescriptor]

'codegen' @ [322:25] ==> value-parameter codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateDoResume.<no name provided>.doGenerateBody[ValueParameterDescriptorImpl]

'initializeCoroutineParameters' @ [322:33] ==> private final fun ExpressionCodegen.initializeCoroutineParameters(): Unit defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[SimpleFunctionDescriptorImpl]

'super' @ [323:25] ==> <this> defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateDoResume.<no name provided>[LazyClassReceiverParameterDescriptor]

'doGenerateBody' @ [323:31] ==> @Override public open fun doGenerateBody(@NotNull codegen: ExpressionCodegen, @NotNull signature: JvmMethodSignature): Unit defined in org.jetbrains.kotlin.codegen.FunctionGenerationStrategy.FunctionDefault[JavaMethodDescriptor]

'codegen' @ [323:46] ==> value-parameter codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateDoResume.<no name provided>.doGenerateBody[ValueParameterDescriptorImpl]

'signature' @ [323:55] ==> value-parameter signature: JvmMethodSignature defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.generateDoResume.<no name provided>.doGenerateBody[ValueParameterDescriptorImpl]

'JvmStatic' @ [330:9] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'declaration' @ [337:17] ==> value-parameter declaration: KtElement defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.Companion.create[ValueParameterDescriptorImpl]

'!' @ [337:54] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'originalSuspendLambdaDescriptor' @ [337:55] ==> value-parameter originalSuspendLambdaDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.Companion.create[ValueParameterDescriptorImpl]

'isSuspendLambda' @ [337:87] ==> public val CallableDescriptor.isSuspendLambda: Boolean defined in org.jetbrains.kotlin.coroutines[DeserializedPropertyDescriptor]

'CoroutineCodegenForLambda' @ [339:20] ==> private constructor CoroutineCodegenForLambda(outerExpressionCodegen: ExpressionCodegen, element: KtElement, closureContext: ClosureContext, classBuilder: ClassBuilder, originalSuspendFunctionDescriptor: FunctionDescriptor) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda[ClassConstructorDescriptorImpl]

'expressionCodegen' @ [340:21] ==> value-parameter expressionCodegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.Companion.create[ValueParameterDescriptorImpl]

'declaration' @ [341:21] ==> value-parameter declaration: KtElement defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.Companion.create[ValueParameterDescriptorImpl]

'expressionCodegen' @ [342:21] ==> value-parameter expressionCodegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.Companion.create[ValueParameterDescriptorImpl]

'context' @ [342:39] ==> public final val context: (MethodContext..MethodContext?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'intoCoroutineClosure' @ [342:47] ==> @NotNull public open fun intoCoroutineClosure(@NotNull jvmViewOfSuspendLambda: FunctionDescriptor, @NotNull originalSuspendLambdaDescriptor: FunctionDescriptor, @NotNull localLookup: LocalLookup, @NotNull typeMapper: KotlinTypeMapper): ClosureContext defined in org.jetbrains.kotlin.codegen.context.MethodContext[JavaMethodDescriptor]

'getOrCreateJvmSuspendFunctionView' @ [343:29] ==> @JvmOverloads public fun <D : FunctionDescriptor> getOrCreateJvmSuspendFunctionView(function: FunctionDescriptor, bindingContext: BindingContext? = ...): FunctionDescriptor defined in org.jetbrains.kotlin.codegen.coroutines[SimpleFunctionDescriptorImpl]
Inferred types:
    <D : FunctionDescriptor> -> FunctionDescriptor

'originalSuspendLambdaDescriptor' @ [343:63] ==> value-parameter originalSuspendLambdaDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.Companion.create[ValueParameterDescriptorImpl]

'expressionCodegen' @ [343:96] ==> value-parameter expressionCodegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.Companion.create[ValueParameterDescriptorImpl]

'state' @ [343:114] ==> public final val ExpressionCodegen.state: GenerationState[MyPropertyDescriptor]

'bindingContext' @ [343:120] ==> public final val bindingContext: BindingContext defined in org.jetbrains.kotlin.codegen.state.GenerationState[PropertyDescriptorImpl]

'originalSuspendLambdaDescriptor' @ [344:29] ==> value-parameter originalSuspendLambdaDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.Companion.create[ValueParameterDescriptorImpl]

'expressionCodegen' @ [344:62] ==> value-parameter expressionCodegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.Companion.create[ValueParameterDescriptorImpl]

'expressionCodegen' @ [344:81] ==> value-parameter expressionCodegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.Companion.create[ValueParameterDescriptorImpl]

'state' @ [344:99] ==> public final val ExpressionCodegen.state: GenerationState[MyPropertyDescriptor]

'typeMapper' @ [344:105] ==> public final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.state.GenerationState[PropertyDescriptorImpl]

'classBuilder' @ [346:21] ==> value-parameter classBuilder: ClassBuilder defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.Companion.create[ValueParameterDescriptorImpl]

'originalSuspendLambdaDescriptor' @ [347:21] ==> value-parameter originalSuspendLambdaDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForLambda.Companion.create[ValueParameterDescriptorImpl]

'AbstractCoroutineCodegen' @ [359:5] ==> public constructor AbstractCoroutineCodegen(outerExpressionCodegen: ExpressionCodegen, element: KtElement, closureContext: ClosureContext, classBuilder: ClassBuilder, userDataForDoResume: Map<out FunctionDescriptor.UserDataKey<*>, *>? = ...) defined in org.jetbrains.kotlin.codegen.coroutines.AbstractCoroutineCodegen[ClassConstructorDescriptorImpl]

'outerExpressionCodegen' @ [359:30] ==> value-parameter outerExpressionCodegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.<init>[ValueParameterDescriptorImpl]

'element' @ [359:54] ==> value-parameter element: KtElement defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.<init>[ValueParameterDescriptorImpl]

'closureContext' @ [359:63] ==> value-parameter closureContext: ClosureContext defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.<init>[ValueParameterDescriptorImpl]

'classBuilder' @ [359:79] ==> value-parameter classBuilder: ClassBuilder defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.<init>[ValueParameterDescriptorImpl]

'bindingContext' @ [361:13] ==> public final val bindingContext: (BindingContext..BindingContext?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[JavaPropertyDescriptor]

'SUSPEND_FUNCTION_TO_JVM_VIEW' @ [361:43] ==> public final val SUSPEND_FUNCTION_TO_JVM_VIEW: (WritableSlice<(FunctionDescriptor..FunctionDescriptor?), (FunctionDescriptor..FunctionDescriptor?)>..WritableSlice<(FunctionDescriptor..FunctionDescriptor?), (FunctionDescriptor..FunctionDescriptor?)>?) defined in org.jetbrains.kotlin.codegen.binding.CodegenBinding[JavaPropertyDescriptor]

'originalSuspendFunctionDescriptor' @ [361:73] ==> value-parameter originalSuspendFunctionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.<init>[ValueParameterDescriptorImpl]

'generateDoResume' @ [370:9] ==> private final fun generateDoResume(): Unit defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[SimpleFunctionDescriptorImpl]

'generateGetLabelMethod' @ [372:9] ==> private final fun generateGetLabelMethod(): Unit defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[SimpleFunctionDescriptorImpl]

'generateSetLabelMethod' @ [373:9] ==> private final fun generateSetLabelMethod(): Unit defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[SimpleFunctionDescriptorImpl]

'v' @ [375:9] ==> public final val v: (ClassBuilder..ClassBuilder?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[JavaPropertyDescriptor]

'newField' @ [375:11] ==> @NotNull public abstract fun newField(@NotNull origin: JvmDeclarationOrigin, access: Int, @NotNull name: String, @NotNull desc: String, @Nullable signature: String?, @Nullable value: Any?): FieldVisitor defined in org.jetbrains.kotlin.codegen.ClassBuilder[JavaMethodDescriptor]

'NO_ORIGIN' @ [376:38] ==> @field:JvmField public final val NO_ORIGIN: JvmDeclarationOrigin defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOrigin.Companion[DeserializedPropertyDescriptor]

'or' @ [376:49] ==> public final infix fun or(other: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'ACC_SYNTHETIC' @ [376:57] ==> public const final val ACC_SYNTHETIC: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'NO_FLAG_PACKAGE_PRIVATE' @ [376:82] ==> public const final val NO_FLAG_PACKAGE_PRIVATE: Int defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaPropertyDescriptor]

'DATA_FIELD_NAME' @ [377:17] ==> public const val DATA_FIELD_NAME: String defined in org.jetbrains.kotlin.codegen.coroutines in file coroutineCodegenUtil.kt[PropertyDescriptorImpl]

'OBJECT_TYPE' @ [377:43] ==> public final val OBJECT_TYPE: (Type..Type?) defined in org.jetbrains.kotlin.resolve.jvm.AsmTypes[JavaPropertyDescriptor]

'descriptor' @ [377:55] ==> public final val Type.descriptor: (String..String?)[MyPropertyDescriptor]

'v' @ [379:9] ==> public final val v: (ClassBuilder..ClassBuilder?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[JavaPropertyDescriptor]

'newField' @ [379:11] ==> @NotNull public abstract fun newField(@NotNull origin: JvmDeclarationOrigin, access: Int, @NotNull name: String, @NotNull desc: String, @Nullable signature: String?, @Nullable value: Any?): FieldVisitor defined in org.jetbrains.kotlin.codegen.ClassBuilder[JavaMethodDescriptor]

'NO_ORIGIN' @ [380:38] ==> @field:JvmField public final val NO_ORIGIN: JvmDeclarationOrigin defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOrigin.Companion[DeserializedPropertyDescriptor]

'or' @ [380:49] ==> public final infix fun or(other: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'ACC_SYNTHETIC' @ [380:57] ==> public const final val ACC_SYNTHETIC: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'NO_FLAG_PACKAGE_PRIVATE' @ [380:82] ==> public const final val NO_FLAG_PACKAGE_PRIVATE: Int defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaPropertyDescriptor]

'EXCEPTION_FIELD_NAME' @ [381:17] ==> public const val EXCEPTION_FIELD_NAME: String defined in org.jetbrains.kotlin.codegen.coroutines in file coroutineCodegenUtil.kt[PropertyDescriptorImpl]

'JAVA_THROWABLE_TYPE' @ [381:48] ==> public final val JAVA_THROWABLE_TYPE: (Type..Type?) defined in org.jetbrains.kotlin.resolve.jvm.AsmTypes[JavaPropertyDescriptor]

'descriptor' @ [381:68] ==> public final val Type.descriptor: (String..String?)[MyPropertyDescriptor]

'functionCodegen' @ [386:9] ==> public final val functionCodegen: (FunctionCodegen..FunctionCodegen?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[JavaPropertyDescriptor]

'generateMethod' @ [386:25] ==> public open fun generateMethod(@NotNull origin: JvmDeclarationOrigin, @NotNull descriptor: FunctionDescriptor, @NotNull strategy: FunctionGenerationStrategy): Unit defined in org.jetbrains.kotlin.codegen.FunctionCodegen[JavaMethodDescriptor]

'OtherOrigin' @ [387:17] ==> @JvmOverloads public fun OtherOrigin(element: PsiElement?, descriptor: DeclarationDescriptor? = ...): JvmDeclarationOrigin defined in org.jetbrains.kotlin.resolve.jvm.diagnostics[DeserializedSimpleFunctionDescriptor]

'element' @ [387:29] ==> protected/*protected and package*/ final val element: (KtElement..KtElement?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[JavaPropertyDescriptor]

'doResumeDescriptor' @ [388:17] ==> protected final val doResumeDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[PropertyDescriptorImpl]

'FunctionGenerationStrategy.CodegenBased' @ [389:26] ==> public constructor CodegenBased(@NotNull state: GenerationState) defined in org.jetbrains.kotlin.codegen.FunctionGenerationStrategy.CodegenBased[JavaClassConstructorDescriptor]

'state' @ [389:66] ==> public final val state: (GenerationState..GenerationState?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[JavaPropertyDescriptor]

'field' @ [391:36] ==> @NotNull public open fun field(@NotNull type: Type, @NotNull owner: Type, @NotNull name: String, isStatic: Boolean, @NotNull receiver: StackValue): StackValue.Field defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'OBJECT_TYPE' @ [392:42] ==> public final val OBJECT_TYPE: (Type..Type?) defined in org.jetbrains.kotlin.resolve.jvm.AsmTypes[JavaPropertyDescriptor]

'getObjectType' @ [392:60] ==> public open fun getObjectType(p0: (String..String?)): (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaMethodDescriptor]

'v' @ [392:74] ==> public final val v: (ClassBuilder..ClassBuilder?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[JavaPropertyDescriptor]

'thisName' @ [392:76] ==> public final val ClassBuilder.thisName: String[MyPropertyDescriptor]

'DATA_FIELD_NAME' @ [392:87] ==> public const val DATA_FIELD_NAME: String defined in org.jetbrains.kotlin.codegen.coroutines in file coroutineCodegenUtil.kt[PropertyDescriptorImpl]

'LOCAL_0' @ [393:44] ==> public final val LOCAL_0: (StackValue.Local..StackValue.Local?) defined in org.jetbrains.kotlin.codegen.StackValue[JavaPropertyDescriptor]

'store' @ [394:27] ==> public open fun store(@NotNull value: StackValue, @NotNull v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.StackValue.Field[JavaMethodDescriptor]

'local' @ [394:44] ==> @NotNull public open fun local(index: Int, @NotNull type: Type): StackValue.Local defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'OBJECT_TYPE' @ [394:62] ==> public final val OBJECT_TYPE: (Type..Type?) defined in org.jetbrains.kotlin.resolve.jvm.AsmTypes[JavaPropertyDescriptor]

'codegen' @ [394:76] ==> value-parameter codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody[ValueParameterDescriptorImpl]

'v' @ [394:84] ==> public final val v: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'field' @ [396:36] ==> @NotNull public open fun field(@NotNull type: Type, @NotNull owner: Type, @NotNull name: String, isStatic: Boolean, @NotNull receiver: StackValue): StackValue.Field defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'JAVA_THROWABLE_TYPE' @ [397:42] ==> public final val JAVA_THROWABLE_TYPE: (Type..Type?) defined in org.jetbrains.kotlin.resolve.jvm.AsmTypes[JavaPropertyDescriptor]

'getObjectType' @ [397:68] ==> public open fun getObjectType(p0: (String..String?)): (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaMethodDescriptor]

'v' @ [397:82] ==> public final val v: (ClassBuilder..ClassBuilder?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[JavaPropertyDescriptor]

'thisName' @ [397:84] ==> public final val ClassBuilder.thisName: String[MyPropertyDescriptor]

'EXCEPTION_FIELD_NAME' @ [397:95] ==> public const val EXCEPTION_FIELD_NAME: String defined in org.jetbrains.kotlin.codegen.coroutines in file coroutineCodegenUtil.kt[PropertyDescriptorImpl]

'LOCAL_0' @ [398:44] ==> public final val LOCAL_0: (StackValue.Local..StackValue.Local?) defined in org.jetbrains.kotlin.codegen.StackValue[JavaPropertyDescriptor]

'store' @ [399:27] ==> public open fun store(@NotNull value: StackValue, @NotNull v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.StackValue.Field[JavaMethodDescriptor]

'local' @ [399:44] ==> @NotNull public open fun local(index: Int, @NotNull type: Type): StackValue.Local defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'JAVA_THROWABLE_TYPE' @ [399:62] ==> public final val JAVA_THROWABLE_TYPE: (Type..Type?) defined in org.jetbrains.kotlin.resolve.jvm.AsmTypes[JavaPropertyDescriptor]

'codegen' @ [399:84] ==> value-parameter codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody[ValueParameterDescriptorImpl]

'v' @ [399:92] ==> public final val v: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'LABEL_FIELD_STACK_VALUE' @ [401:25] ==> private final val LABEL_FIELD_STACK_VALUE: StackValue.Field defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.Companion[PropertyDescriptorImpl]

'store' @ [401:49] ==> public open fun store(@NotNull value: StackValue, @NotNull v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.StackValue.Field[JavaMethodDescriptor]

'operation' @ [402:44] ==> public open fun operation(type: (Type..Type?), lambda: (((InstructionAdapter..InstructionAdapter?)) -> (Unit..Unit?)..(((InstructionAdapter..InstructionAdapter?)) -> (Unit..Unit?))?)): (StackValue..StackValue?) defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'INT_TYPE' @ [402:59] ==> public final val INT_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'LABEL_FIELD_STACK_VALUE' @ [403:37] ==> private final val LABEL_FIELD_STACK_VALUE: StackValue.Field defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.Companion[PropertyDescriptorImpl]

'put' @ [403:61] ==> public open fun put(@NotNull type: Type, @NotNull v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.StackValue.Field[JavaMethodDescriptor]

'INT_TYPE' @ [403:70] ==> public final val INT_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'it' @ [403:80] ==> value-parameter it: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [404:37] ==> value-parameter it: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody.<anonymous>[ValueParameterDescriptorImpl]

'iconst' @ [404:40] ==> public open fun iconst(p0: Int): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'shl' @ [404:47] ==> public final infix fun shl(bitCount: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'it' @ [405:37] ==> value-parameter it: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody.<anonymous>[ValueParameterDescriptorImpl]

'or' @ [405:40] ==> public open fun or(p0: (Type..Type?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'INT_TYPE' @ [405:48] ==> public final val INT_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'codegen' @ [407:33] ==> value-parameter codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody[ValueParameterDescriptorImpl]

'v' @ [407:41] ==> public final val v: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'closure' @ [410:47] ==> protected/*protected and package*/ final val closure: (CalculatedClosure..CalculatedClosure?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[JavaPropertyDescriptor]

'captureThis' @ [410:55] ==> public final val CalculatedClosure.captureThis: ClassDescriptor?[MyPropertyDescriptor]

'let' @ [410:68] ==> @InlineOnly public inline fun <T, R> ClassDescriptor.let(block: (ClassDescriptor) -> Type): Type defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ClassDescriptor
    <R> -> Type

'typeMapper' @ [410:72] ==> public final val typeMapper: (KotlinTypeMapper..KotlinTypeMapper?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[JavaPropertyDescriptor]

'mapType' @ [410:84] ==> @NotNull public open fun mapType(@NotNull descriptor: ClassifierDescriptor): Type defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'captureThisType' @ [411:29] ==> val captureThisType: Type? defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'field' @ [412:40] ==> @NotNull public open fun field(@NotNull type: Type, @NotNull owner: Type, @NotNull name: String, isStatic: Boolean, @NotNull receiver: StackValue): StackValue.Field defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'captureThisType' @ [413:37] ==> val captureThisType: Type? defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'getObjectType' @ [413:59] ==> public open fun getObjectType(p0: (String..String?)): (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaMethodDescriptor]

'v' @ [413:73] ==> public final val v: (ClassBuilder..ClassBuilder?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[JavaPropertyDescriptor]

'thisName' @ [413:75] ==> public final val ClassBuilder.thisName: String[MyPropertyDescriptor]

'CAPTURED_THIS_FIELD' @ [413:94] ==> public const final val CAPTURED_THIS_FIELD: String defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaPropertyDescriptor]

'LOCAL_0' @ [414:55] ==> public final val LOCAL_0: (StackValue.Local..StackValue.Local?) defined in org.jetbrains.kotlin.codegen.StackValue[JavaPropertyDescriptor]

'put' @ [415:31] ==> public open fun put(@NotNull type: Type, @NotNull v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.StackValue.Field[JavaMethodDescriptor]

'captureThisType' @ [415:35] ==> val captureThisType: Type? defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'codegen' @ [415:52] ==> value-parameter codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody[ValueParameterDescriptorImpl]

'v' @ [415:60] ==> public final val v: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'isInterface' @ [418:65] ==> public open fun isInterface(@Nullable p0: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'suspendFunctionJvmView' @ [418:77] ==> private final val suspendFunctionJvmView: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[PropertyDescriptorImpl]

'containingDeclaration' @ [418:100] ==> public final val FunctionDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'typeMapper' @ [420:33] ==> public final val typeMapper: (KotlinTypeMapper..KotlinTypeMapper?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[JavaPropertyDescriptor]

'mapToCallableMethod' @ [420:44] ==> @NotNull public open fun mapToCallableMethod(@NotNull descriptor: FunctionDescriptor, superCall: Boolean): CallableMethod defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'suspendFunctionJvmView' @ [421:41] ==> private final val suspendFunctionJvmView: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[PropertyDescriptorImpl]

'isInterfaceMethod' @ [423:41] ==> val isInterfaceMethod: Boolean defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'callableMethod' @ [426:46] ==> val callableMethod: CallableMethod defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'getAsmMethod' @ [426:61] ==> public final fun getAsmMethod(): Method defined in org.jetbrains.kotlin.codegen.CallableMethod[SimpleFunctionDescriptorImpl]

'argumentTypes' @ [426:76] ==> public final val Method.argumentTypes: (Array<(Type..Type?)>..Array<out (Type..Type?)>?)[MyPropertyDescriptor]

'dropLast' @ [426:90] ==> public fun <T> Array<out (Type..Type?)>.dropLast(n: Int): List<(Type..Type?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.org.objectweb.asm.Type..org.jetbrains.org.objectweb.asm.Type?)

'pushDefaultValueOnStack' @ [427:37] ==> public open fun pushDefaultValueOnStack(@NotNull type: Type, @NotNull v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaMethodDescriptor]

'argumentType' @ [427:61] ==> val argumentType: (Type..Type?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'codegen' @ [427:75] ==> value-parameter codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody[ValueParameterDescriptorImpl]

'v' @ [427:83] ==> public final val v: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'codegen' @ [430:25] ==> value-parameter codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody[ValueParameterDescriptorImpl]

'v' @ [430:33] ==> public final val v: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'load' @ [430:35] ==> public open fun load(p0: Int, p1: (Type..Type?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'OBJECT_TYPE' @ [430:52] ==> public final val OBJECT_TYPE: (Type..Type?) defined in org.jetbrains.kotlin.resolve.jvm.AsmTypes[JavaPropertyDescriptor]

'if (suspendFunctionJvmView.isOverridable && !isInterfaceMethod && captureThisType != null) {
                            val owner = captureThisType.internalName
                            val impl = callableMethod.getAsmMethod().getImplForOpenMethod(owner)
                            codegen.v.invokestatic(owner, impl.name, impl.descriptor, false)
                        }
                        else {
                            callableMethod.genInvokeInstruction(codegen.v)
                        }' @ [432:25] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'suspendFunctionJvmView' @ [432:29] ==> private final val suspendFunctionJvmView: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[PropertyDescriptorImpl]

'isOverridable' @ [432:52] ==> public val CallableMemberDescriptor.isOverridable: Boolean defined in org.jetbrains.kotlin.descriptors[DeserializedPropertyDescriptor]

'!' @ [432:69] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isInterfaceMethod' @ [432:70] ==> val isInterfaceMethod: Boolean defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'captureThisType' @ [432:91] ==> val captureThisType: Type? defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'captureThisType' @ [433:41] ==> val captureThisType: Type? defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'internalName' @ [433:57] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'callableMethod' @ [434:40] ==> val callableMethod: CallableMethod defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'getAsmMethod' @ [434:55] ==> public final fun getAsmMethod(): Method defined in org.jetbrains.kotlin.codegen.CallableMethod[SimpleFunctionDescriptorImpl]

'getImplForOpenMethod' @ [434:70] ==> public fun Method.getImplForOpenMethod(ownerInternalName: String): Method defined in org.jetbrains.kotlin.codegen.coroutines in file coroutineCodegenUtil.kt[SimpleFunctionDescriptorImpl]

'owner' @ [434:91] ==> val owner: (String..String?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'codegen' @ [435:29] ==> value-parameter codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody[ValueParameterDescriptorImpl]

'v' @ [435:37] ==> public final val v: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'invokestatic' @ [435:39] ==> public open fun invokestatic(p0: (String..String?), p1: (String..String?), p2: (String..String?), p3: Boolean): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'owner' @ [435:52] ==> val owner: (String..String?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'impl' @ [435:59] ==> val impl: Method defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'name' @ [435:64] ==> public final val Method.name: (String..String?)[MyPropertyDescriptor]

'impl' @ [435:70] ==> val impl: Method defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'descriptor' @ [435:75] ==> public final val Method.descriptor: (String..String?)[MyPropertyDescriptor]

'callableMethod' @ [438:29] ==> val callableMethod: CallableMethod defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody[LocalVariableDescriptor]

'genInvokeInstruction' @ [438:44] ==> public open fun genInvokeInstruction(v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.CallableMethod[SimpleFunctionDescriptorImpl]

'codegen' @ [438:65] ==> value-parameter codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody[ValueParameterDescriptorImpl]

'v' @ [438:73] ==> public final val v: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'codegen' @ [441:25] ==> value-parameter codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateDoResume.<no name provided>.doGenerateBody[ValueParameterDescriptorImpl]

'v' @ [441:33] ==> public final val v: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'visitInsn' @ [441:35] ==> public open fun visitInsn(p0: Int): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'ARETURN' @ [441:53] ==> public const final val ARETURN: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'v' @ [448:18] ==> public final val v: (ClassBuilder..ClassBuilder?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[JavaPropertyDescriptor]

'newMethod' @ [448:20] ==> @NotNull public abstract fun newMethod(@NotNull origin: JvmDeclarationOrigin, access: Int, @NotNull name: String, @NotNull desc: String, @Nullable signature: String?, @Nullable exceptions: (Array<(String..String?)>?..Array<out (String..String?)>?)): MethodVisitor defined in org.jetbrains.kotlin.codegen.ClassBuilder[JavaMethodDescriptor]

'NO_ORIGIN' @ [449:38] ==> @field:JvmField public final val NO_ORIGIN: JvmDeclarationOrigin defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOrigin.Companion[DeserializedPropertyDescriptor]

'or' @ [450:17] ==> public final infix fun or(other: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'ACC_SYNTHETIC' @ [450:25] ==> public const final val ACC_SYNTHETIC: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'ACC_FINAL' @ [450:50] ==> public const final val ACC_FINAL: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'NO_FLAG_PACKAGE_PRIVATE' @ [450:71] ==> public const final val NO_FLAG_PACKAGE_PRIVATE: Int defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaPropertyDescriptor]

'getMethodDescriptor' @ [452:22] ==> public open fun getMethodDescriptor(p0: (Type..Type?), vararg p1: (Type..Type?)): (String..String?) defined in org.jetbrains.org.objectweb.asm.Type[JavaMethodDescriptor]

'INT_TYPE' @ [452:47] ==> public final val INT_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'mv' @ [457:9] ==> val mv: MethodVisitor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateGetLabelMethod[LocalVariableDescriptor]

'visitCode' @ [457:12] ==> public open fun visitCode(): Unit defined in org.jetbrains.org.objectweb.asm.MethodVisitor[JavaMethodDescriptor]

'LABEL_FIELD_STACK_VALUE' @ [458:9] ==> private final val LABEL_FIELD_STACK_VALUE: StackValue.Field defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.Companion[PropertyDescriptorImpl]

'put' @ [458:33] ==> public open fun put(@NotNull type: Type, @NotNull v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.StackValue.Field[JavaMethodDescriptor]

'INT_TYPE' @ [458:42] ==> public final val INT_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'InstructionAdapter' @ [458:52] ==> public constructor InstructionAdapter(p0: (MethodVisitor..MethodVisitor?)) defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaClassConstructorDescriptor]

'mv' @ [458:71] ==> val mv: MethodVisitor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateGetLabelMethod[LocalVariableDescriptor]

'mv' @ [459:9] ==> val mv: MethodVisitor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateGetLabelMethod[LocalVariableDescriptor]

'visitInsn' @ [459:12] ==> public open fun visitInsn(p0: Int): Unit defined in org.jetbrains.org.objectweb.asm.MethodVisitor[JavaMethodDescriptor]

'IRETURN' @ [459:30] ==> public const final val IRETURN: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'mv' @ [460:9] ==> val mv: MethodVisitor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateGetLabelMethod[LocalVariableDescriptor]

'visitEnd' @ [460:12] ==> public open fun visitEnd(): Unit defined in org.jetbrains.org.objectweb.asm.MethodVisitor[JavaMethodDescriptor]

'v' @ [464:18] ==> public final val v: (ClassBuilder..ClassBuilder?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[JavaPropertyDescriptor]

'newMethod' @ [464:20] ==> @NotNull public abstract fun newMethod(@NotNull origin: JvmDeclarationOrigin, access: Int, @NotNull name: String, @NotNull desc: String, @Nullable signature: String?, @Nullable exceptions: (Array<(String..String?)>?..Array<out (String..String?)>?)): MethodVisitor defined in org.jetbrains.kotlin.codegen.ClassBuilder[JavaMethodDescriptor]

'NO_ORIGIN' @ [465:38] ==> @field:JvmField public final val NO_ORIGIN: JvmDeclarationOrigin defined in org.jetbrains.kotlin.resolve.jvm.diagnostics.JvmDeclarationOrigin.Companion[DeserializedPropertyDescriptor]

'or' @ [466:17] ==> public final infix fun or(other: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'ACC_SYNTHETIC' @ [466:25] ==> public const final val ACC_SYNTHETIC: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'ACC_FINAL' @ [466:50] ==> public const final val ACC_FINAL: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'NO_FLAG_PACKAGE_PRIVATE' @ [466:71] ==> public const final val NO_FLAG_PACKAGE_PRIVATE: Int defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaPropertyDescriptor]

'getMethodDescriptor' @ [468:22] ==> public open fun getMethodDescriptor(p0: (Type..Type?), vararg p1: (Type..Type?)): (String..String?) defined in org.jetbrains.org.objectweb.asm.Type[JavaMethodDescriptor]

'VOID_TYPE' @ [468:47] ==> public final val VOID_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'INT_TYPE' @ [468:63] ==> public final val INT_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'mv' @ [473:9] ==> val mv: MethodVisitor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateSetLabelMethod[LocalVariableDescriptor]

'visitCode' @ [473:12] ==> public open fun visitCode(): Unit defined in org.jetbrains.org.objectweb.asm.MethodVisitor[JavaMethodDescriptor]

'LABEL_FIELD_STACK_VALUE' @ [474:9] ==> private final val LABEL_FIELD_STACK_VALUE: StackValue.Field defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.Companion[PropertyDescriptorImpl]

'store' @ [474:33] ==> public open fun store(@NotNull value: StackValue, @NotNull v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.StackValue.Field[JavaMethodDescriptor]

'local' @ [474:50] ==> @NotNull public open fun local(index: Int, @NotNull type: Type): StackValue.Local defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'INT_TYPE' @ [474:64] ==> public final val INT_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'InstructionAdapter' @ [474:75] ==> public constructor InstructionAdapter(p0: (MethodVisitor..MethodVisitor?)) defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaClassConstructorDescriptor]

'mv' @ [474:94] ==> val mv: MethodVisitor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateSetLabelMethod[LocalVariableDescriptor]

'mv' @ [475:9] ==> val mv: MethodVisitor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateSetLabelMethod[LocalVariableDescriptor]

'visitInsn' @ [475:12] ==> public open fun visitInsn(p0: Int): Unit defined in org.jetbrains.org.objectweb.asm.MethodVisitor[JavaMethodDescriptor]

'RETURN' @ [475:30] ==> public const final val RETURN: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'mv' @ [476:9] ==> val mv: MethodVisitor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateSetLabelMethod[LocalVariableDescriptor]

'visitEnd' @ [476:12] ==> public open fun visitEnd(): Unit defined in org.jetbrains.org.objectweb.asm.MethodVisitor[JavaMethodDescriptor]

'writeKotlinMetadata' @ [480:9] ==> public fun writeKotlinMetadata(cb: ClassBuilder, state: GenerationState, kind: KotlinClassHeader.Kind, extraFlags: Int, action: (AnnotationVisitor) -> Unit): Unit defined in org.jetbrains.kotlin.codegen in file writeAnnotationUtil.kt[SimpleFunctionDescriptorImpl]

'v' @ [480:29] ==> public final val v: (ClassBuilder..ClassBuilder?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[JavaPropertyDescriptor]

'state' @ [480:32] ==> public final val state: (GenerationState..GenerationState?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[JavaPropertyDescriptor]

'SYNTHETIC_CLASS' @ [480:62] ==> enum entry SYNTHETIC_CLASS defined in org.jetbrains.kotlin.load.kotlin.header.KotlinClassHeader.Kind[FakeCallableDescriptorForObject]

'DescriptorSerializer' @ [481:30] ==> public companion object defined in org.jetbrains.kotlin.serialization.DescriptorSerializer[FakeCallableDescriptorForObject]

'createForLambda' @ [481:51] ==> @JvmStatic public final fun createForLambda(extension: SerializerExtension): DescriptorSerializer defined in org.jetbrains.kotlin.serialization.DescriptorSerializer.Companion[DeserializedSimpleFunctionDescriptor]

'JvmSerializerExtension' @ [481:67] ==> public constructor JvmSerializerExtension(@NotNull bindings: JvmSerializationBindings, @NotNull state: GenerationState) defined in org.jetbrains.kotlin.codegen.serialization.JvmSerializerExtension[JavaClassConstructorDescriptor]

'v' @ [481:90] ==> public final val v: (ClassBuilder..ClassBuilder?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[JavaPropertyDescriptor]

'serializationBindings' @ [481:92] ==> public final val ClassBuilder.serializationBindings: JvmSerializationBindings[MyPropertyDescriptor]

'state' @ [481:115] ==> public final val state: (GenerationState..GenerationState?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[JavaPropertyDescriptor]

'serializer' @ [482:33] ==> val serializer: DescriptorSerializer defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateKotlinMetadataAnnotation.<anonymous>[LocalVariableDescriptor]

'functionProto' @ [482:44] ==> public final fun functionProto(descriptor: FunctionDescriptor): ProtoBuf.Function.Builder defined in org.jetbrains.kotlin.serialization.DescriptorSerializer[DeserializedSimpleFunctionDescriptor]

'createFreeFakeLambdaDescriptor' @ [482:58] ==> public fun createFreeFakeLambdaDescriptor(descriptor: FunctionDescriptor): FunctionDescriptor defined in org.jetbrains.kotlin.codegen in file fakeDescriptorsForReferences.kt[SimpleFunctionDescriptorImpl]

'suspendFunctionJvmView' @ [482:89] ==> private final val suspendFunctionJvmView: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[PropertyDescriptorImpl]

'build' @ [482:114] ==> public open fun build(): (ProtoBuf.Function..ProtoBuf.Function?) defined in org.jetbrains.kotlin.serialization.ProtoBuf.Function.Builder[JavaMethodDescriptor]

'writeAnnotationData' @ [483:21] ==> public open fun writeAnnotationData(@NotNull av: AnnotationVisitor, @NotNull serializer: DescriptorSerializer, @NotNull message: MessageLite): Unit defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaMethodDescriptor]

'av' @ [483:41] ==> value-parameter av: AnnotationVisitor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateKotlinMetadataAnnotation.<anonymous>[ValueParameterDescriptorImpl]

'serializer' @ [483:45] ==> val serializer: DescriptorSerializer defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateKotlinMetadataAnnotation.<anonymous>[LocalVariableDescriptor]

'functionProto' @ [483:57] ==> val functionProto: (ProtoBuf.Function..ProtoBuf.Function?) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.generateKotlinMetadataAnnotation.<anonymous>[LocalVariableDescriptor]

'field' @ [489:28] ==> @NotNull public open fun field(@NotNull info: FieldInfo, @NotNull receiver: StackValue): StackValue.Field defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'createForHiddenField' @ [490:35] ==> @NotNull public open fun createForHiddenField(@NotNull owner: Type, @NotNull fieldType: Type, @NotNull fieldName: String): FieldInfo defined in org.jetbrains.kotlin.codegen.FieldInfo[JavaMethodDescriptor]

'COROUTINE_IMPL_ASM_TYPE' @ [490:56] ==> @JvmField public val COROUTINE_IMPL_ASM_TYPE: Type defined in org.jetbrains.kotlin.codegen.coroutines in file coroutineCodegenUtil.kt[PropertyDescriptorImpl]

'INT_TYPE' @ [490:86] ==> public final val INT_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'COROUTINE_LABEL_FIELD_NAME' @ [490:96] ==> public const val COROUTINE_LABEL_FIELD_NAME: String defined in org.jetbrains.kotlin.codegen.coroutines in file coroutineCodegenUtil.kt[PropertyDescriptorImpl]

'LOCAL_0' @ [491:36] ==> public final val LOCAL_0: (StackValue.Local..StackValue.Local?) defined in org.jetbrains.kotlin.codegen.StackValue[JavaPropertyDescriptor]

'expressionCodegen' @ [500:34] ==> value-parameter expressionCodegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.Companion.create[ValueParameterDescriptorImpl]

'state' @ [500:52] ==> public final val ExpressionCodegen.state: GenerationState[MyPropertyDescriptor]

'bindingContext' @ [500:58] ==> public final val bindingContext: BindingContext defined in org.jetbrains.kotlin.codegen.state.GenerationState[PropertyDescriptorImpl]

'bindingContext' @ [502:21] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.Companion.create[LocalVariableDescriptor]

'CLOSURE' @ [503:44] ==> public final val CLOSURE: (WritableSlice<(ClassDescriptor..ClassDescriptor?), (MutableClosure..MutableClosure?)>..WritableSlice<(ClassDescriptor..ClassDescriptor?), (MutableClosure..MutableClosure?)>?) defined in org.jetbrains.kotlin.codegen.binding.CodegenBinding[JavaPropertyDescriptor]

'bindingContext' @ [504:29] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.Companion.create[LocalVariableDescriptor]

'CLASS_FOR_CALLABLE' @ [504:59] ==> public final val CLASS_FOR_CALLABLE: (WritableSlice<(CallableDescriptor..CallableDescriptor?), (ClassDescriptor..ClassDescriptor?)>..WritableSlice<(CallableDescriptor..CallableDescriptor?), (ClassDescriptor..ClassDescriptor?)>?) defined in org.jetbrains.kotlin.codegen.binding.CodegenBinding[JavaPropertyDescriptor]

'originalSuspendDescriptor' @ [504:79] ==> value-parameter originalSuspendDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.Companion.create[ValueParameterDescriptorImpl]

'sure' @ [505:23] ==> public inline fun <T : Any> MutableClosure?.sure(message: () -> String): MutableClosure defined in org.jetbrains.kotlin.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> MutableClosure

'originalSuspendDescriptor' @ [505:68] ==> value-parameter originalSuspendDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.Companion.create[ValueParameterDescriptorImpl]

'bindingContext' @ [508:21] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.Companion.create[LocalVariableDescriptor]

'SUSPEND_FUNCTION_TO_JVM_VIEW' @ [509:44] ==> public final val SUSPEND_FUNCTION_TO_JVM_VIEW: (WritableSlice<(FunctionDescriptor..FunctionDescriptor?), (FunctionDescriptor..FunctionDescriptor?)>..WritableSlice<(FunctionDescriptor..FunctionDescriptor?), (FunctionDescriptor..FunctionDescriptor?)>?) defined in org.jetbrains.kotlin.codegen.binding.CodegenBinding[JavaPropertyDescriptor]

'originalSuspendDescriptor' @ [509:74] ==> value-parameter originalSuspendDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.Companion.create[ValueParameterDescriptorImpl]

'sure' @ [510:23] ==> public inline fun <T : Any> FunctionDescriptor?.sure(message: () -> String): FunctionDescriptor defined in org.jetbrains.kotlin.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> FunctionDescriptor

'originalSuspendDescriptor' @ [510:69] ==> value-parameter originalSuspendDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.Companion.create[ValueParameterDescriptorImpl]

'suspendFunctionView' @ [512:17] ==> val suspendFunctionView: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.Companion.create[LocalVariableDescriptor]

'dispatchReceiverParameter' @ [512:37] ==> public final val FunctionDescriptor.dispatchReceiverParameter: ReceiverParameterDescriptor?[MyPropertyDescriptor]

'closure' @ [513:17] ==> val closure: MutableClosure defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.Companion.create[LocalVariableDescriptor]

'setCaptureThis' @ [513:25] ==> public open fun setCaptureThis(): Unit defined in org.jetbrains.kotlin.codegen.binding.MutableClosure[JavaMethodDescriptor]

'CoroutineCodegenForNamedFunction' @ [516:20] ==> private constructor CoroutineCodegenForNamedFunction(outerExpressionCodegen: ExpressionCodegen, element: KtElement, closureContext: ClosureContext, classBuilder: ClassBuilder, originalSuspendFunctionDescriptor: FunctionDescriptor) defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction[ClassConstructorDescriptorImpl]

'expressionCodegen' @ [517:21] ==> value-parameter expressionCodegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.Companion.create[ValueParameterDescriptorImpl]

'declaration' @ [517:40] ==> value-parameter declaration: KtFunction defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.Companion.create[ValueParameterDescriptorImpl]

'expressionCodegen' @ [518:21] ==> value-parameter expressionCodegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.Companion.create[ValueParameterDescriptorImpl]

'context' @ [518:39] ==> public final val context: (MethodContext..MethodContext?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'intoClosure' @ [518:47] ==> @NotNull public open fun intoClosure(@NotNull funDescriptor: FunctionDescriptor, @NotNull localLookup: LocalLookup, @NotNull typeMapper: KotlinTypeMapper): ClosureContext defined in org.jetbrains.kotlin.codegen.context.MethodContext[JavaMethodDescriptor]

'originalSuspendDescriptor' @ [519:29] ==> value-parameter originalSuspendDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.Companion.create[ValueParameterDescriptorImpl]

'expressionCodegen' @ [519:56] ==> value-parameter expressionCodegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.Companion.create[ValueParameterDescriptorImpl]

'expressionCodegen' @ [519:75] ==> value-parameter expressionCodegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.Companion.create[ValueParameterDescriptorImpl]

'state' @ [519:93] ==> public final val ExpressionCodegen.state: GenerationState[MyPropertyDescriptor]

'typeMapper' @ [519:99] ==> public final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.state.GenerationState[PropertyDescriptorImpl]

'cv' @ [521:21] ==> value-parameter cv: ClassBuilder defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.Companion.create[ValueParameterDescriptorImpl]

'originalSuspendDescriptor' @ [522:21] ==> value-parameter originalSuspendDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.coroutines.CoroutineCodegenForNamedFunction.Companion.create[ValueParameterDescriptorImpl]

'FunctionGenerationStrategy' @ [530:52] ==> public constructor FunctionGenerationStrategy() defined in org.jetbrains.kotlin.codegen.FunctionGenerationStrategy[JavaClassConstructorDescriptor]

'error' @ [538:9] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

