'KotlinTypeMapper' @ [30:30] ==> public constructor KotlinTypeMapper(@NotNull bindingContext: BindingContext, @NotNull classBuilderMode: ClassBuilderMode, @NotNull fileClassesProvider: JvmFileClassesProvider, @NotNull incompatibleClassTracker: IncompatibleClassTracker, @NotNull moduleName: String, isJvm8Target: Boolean, isJvm8TargetWithDefaults: Boolean) defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaClassConstructorDescriptor]

'EMPTY' @ [30:62] ==> public final val EMPTY: (BindingContext..BindingContext?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'LIGHT_CLASSES' @ [30:86] ==> public final val LIGHT_CLASSES: (ClassBuilderMode..ClassBuilderMode?) defined in org.jetbrains.kotlin.codegen.ClassBuilderMode[JavaPropertyDescriptor]

'NoResolveFileClassesProvider' @ [30:101] ==> public object NoResolveFileClassesProvider : JvmFileClassesProvider defined in org.jetbrains.kotlin.fileClasses[FakeCallableDescriptorForObject]

'DoNothing' @ [31:72] ==> public object DoNothing : IncompatibleClassTracker defined in org.jetbrains.kotlin.codegen.state.IncompatibleClassTracker[FakeCallableDescriptorForObject]

'DEFAULT_MODULE_NAME' @ [31:90] ==> public const final val DEFAULT_MODULE_NAME: String defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaPropertyDescriptor]

'typeMapper' @ [33:74] ==> private final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.signature.KotlinToJvmSignatureMapperImpl[PropertyDescriptorImpl]

'mapAsmMethod' @ [33:85] ==> @NotNull public open fun mapAsmMethod(@NotNull descriptor: FunctionDescriptor): Method defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'function' @ [33:98] ==> value-parameter function: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.signature.KotlinToJvmSignatureMapperImpl.mapToJvmMethodSignature[ValueParameterDescriptorImpl]

