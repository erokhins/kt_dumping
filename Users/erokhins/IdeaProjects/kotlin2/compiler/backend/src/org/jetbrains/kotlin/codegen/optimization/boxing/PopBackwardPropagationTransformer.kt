'MethodTransformer' @ [35:43] ==> public constructor MethodTransformer() defined in org.jetbrains.kotlin.codegen.optimization.transformer.MethodTransformer[JavaClassConstructorDescriptor]

'!' @ [37:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'OptimizationMethodVisitor' @ [37:14] ==> public companion object defined in org.jetbrains.kotlin.codegen.optimization.OptimizationMethodVisitor[FakeCallableDescriptorForObject]

'canBeOptimizedUsingSourceInterpreter' @ [37:40] ==> public final fun canBeOptimizedUsingSourceInterpreter(node: MethodNode): Boolean defined in org.jetbrains.kotlin.codegen.optimization.OptimizationMethodVisitor.Companion[SimpleFunctionDescriptorImpl]

'methodNode' @ [37:77] ==> value-parameter methodNode: MethodNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.transform[ValueParameterDescriptorImpl]

'Transformer' @ [38:9] ==> public constructor Transformer(methodNode: MethodNode) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[ClassConstructorDescriptorImpl]

'methodNode' @ [38:21] ==> value-parameter methodNode: MethodNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.transform[ValueParameterDescriptorImpl]

'transform' @ [38:33] ==> public final fun transform(): Unit defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'invoke' @ [49:25] ==> public abstract operator fun invoke(p1: AbstractInsnNode): Unit defined in kotlin.Function1[FunctionInvokeDescriptor]

'insn' @ [49:30] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.Transformation.<no name provided>.apply[ValueParameterDescriptorImpl]

'Transformation' @ [53:40] ==> private final inline fun Transformation(crossinline body: (AbstractInsnNode) -> Unit): PopBackwardPropagationTransformer.Transformer.Transformation defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'insnList' @ [53:57] ==> private final val insnList: (InsnList..InsnList?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'set' @ [53:66] ==> public open operator fun set(p0: (AbstractInsnNode..AbstractInsnNode?), p1: (AbstractInsnNode..AbstractInsnNode?)): Unit defined in org.jetbrains.org.objectweb.asm.tree.InsnList[JavaMethodDescriptor]

'it' @ [53:70] ==> value-parameter it: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.REPLACE_WITH_NOP.<anonymous>[ValueParameterDescriptorImpl]

'createRemovableNopInsn' @ [53:74] ==> private final fun createRemovableNopInsn(): InsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'Transformation' @ [54:41] ==> private final inline fun Transformation(crossinline body: (AbstractInsnNode) -> Unit): PopBackwardPropagationTransformer.Transformer.Transformation defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'insnList' @ [54:58] ==> private final val insnList: (InsnList..InsnList?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'set' @ [54:67] ==> public open operator fun set(p0: (AbstractInsnNode..AbstractInsnNode?), p1: (AbstractInsnNode..AbstractInsnNode?)): Unit defined in org.jetbrains.org.objectweb.asm.tree.InsnList[JavaMethodDescriptor]

'it' @ [54:71] ==> value-parameter it: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.REPLACE_WITH_POP1.<anonymous>[ValueParameterDescriptorImpl]

'InsnNode' @ [54:75] ==> public constructor InsnNode(p0: Int) defined in org.jetbrains.org.objectweb.asm.tree.InsnNode[JavaClassConstructorDescriptor]

'POP' @ [54:92] ==> public const final val POP: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'Transformation' @ [55:41] ==> private final inline fun Transformation(crossinline body: (AbstractInsnNode) -> Unit): PopBackwardPropagationTransformer.Transformer.Transformation defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'insnList' @ [55:58] ==> private final val insnList: (InsnList..InsnList?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'set' @ [55:67] ==> public open operator fun set(p0: (AbstractInsnNode..AbstractInsnNode?), p1: (AbstractInsnNode..AbstractInsnNode?)): Unit defined in org.jetbrains.org.objectweb.asm.tree.InsnList[JavaMethodDescriptor]

'it' @ [55:71] ==> value-parameter it: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.REPLACE_WITH_POP2.<anonymous>[ValueParameterDescriptorImpl]

'InsnNode' @ [55:75] ==> public constructor InsnNode(p0: Int) defined in org.jetbrains.org.objectweb.asm.tree.InsnNode[JavaClassConstructorDescriptor]

'POP2' @ [55:92] ==> public const final val POP2: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'Transformation' @ [56:41] ==> private final inline fun Transformation(crossinline body: (AbstractInsnNode) -> Unit): PopBackwardPropagationTransformer.Transformer.Transformation defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'insnList' @ [56:58] ==> private final val insnList: (InsnList..InsnList?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'insert' @ [56:67] ==> public open fun insert(p0: (AbstractInsnNode..AbstractInsnNode?), p1: (AbstractInsnNode..AbstractInsnNode?)): Unit defined in org.jetbrains.org.objectweb.asm.tree.InsnList[JavaMethodDescriptor]

'it' @ [56:74] ==> value-parameter it: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.INSERT_POP1_AFTER.<anonymous>[ValueParameterDescriptorImpl]

'InsnNode' @ [56:78] ==> public constructor InsnNode(p0: Int) defined in org.jetbrains.org.objectweb.asm.tree.InsnNode[JavaClassConstructorDescriptor]

'POP' @ [56:95] ==> public const final val POP: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'Transformation' @ [57:41] ==> private final inline fun Transformation(crossinline body: (AbstractInsnNode) -> Unit): PopBackwardPropagationTransformer.Transformer.Transformation defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'insnList' @ [57:58] ==> private final val insnList: (InsnList..InsnList?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'insert' @ [57:67] ==> public open fun insert(p0: (AbstractInsnNode..AbstractInsnNode?), p1: (AbstractInsnNode..AbstractInsnNode?)): Unit defined in org.jetbrains.org.objectweb.asm.tree.InsnList[JavaMethodDescriptor]

'it' @ [57:74] ==> value-parameter it: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.INSERT_POP2_AFTER.<anonymous>[ValueParameterDescriptorImpl]

'InsnNode' @ [57:78] ==> public constructor InsnNode(p0: Int) defined in org.jetbrains.org.objectweb.asm.tree.InsnNode[JavaClassConstructorDescriptor]

'POP2' @ [57:95] ==> public const final val POP2: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'methodNode' @ [59:32] ==> public final val methodNode: MethodNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'instructions' @ [59:43] ==> public final var instructions: (InsnList..InsnList?) defined in org.jetbrains.org.objectweb.asm.tree.MethodNode[JavaPropertyDescriptor]

'insnList' @ [61:29] ==> private final val insnList: (InsnList..InsnList?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'toArray' @ [61:38] ==> public open fun toArray(): (Array<(AbstractInsnNode..AbstractInsnNode?)>..Array<out (AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.org.objectweb.asm.tree.InsnList[JavaMethodDescriptor]

'BitSet' @ [63:44] ==> public constructor BitSet(p0: Int) defined in java.util.BitSet[JavaClassConstructorDescriptor]

'insns' @ [63:51] ==> private final val insns: (Array<(AbstractInsnNode..AbstractInsnNode?)>..Array<out (AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'size' @ [63:57] ==> public final val size: Int defined in kotlin.Array[DeserializedPropertyDescriptor]

'hashMapOf' @ [64:39] ==> @SinceKotlin @InlineOnly public inline fun <K, V> hashMapOf(): HashMap<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation> /* = HashMap<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> AbstractInsnNode
    <V> -> Transformation

'hashSetOf' @ [65:37] ==> @SinceKotlin @InlineOnly public inline fun <T> hashSetOf(): HashSet<InsnNode> /* = HashSet<InsnNode> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> InsnNode

'lazy' @ [67:31] ==> public fun <T> lazy(initializer: () -> Array<out Frame<SourceValue>?>): Lazy<Array<out Frame<SourceValue>?>> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Array<out Frame<SourceValue>?>

'analyzeMethodBody' @ [67:38] ==> private final fun analyzeMethodBody(): Array<out Frame<SourceValue>?> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'insns' @ [70:17] ==> private final val insns: (Array<(AbstractInsnNode..AbstractInsnNode?)>..Array<out (AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'none' @ [70:23] ==> public inline fun <T> Array<out (AbstractInsnNode..AbstractInsnNode?)>.none(predicate: ((AbstractInsnNode..AbstractInsnNode?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode..org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode?)

'it' @ [70:30] ==> value-parameter it: (AbstractInsnNode..AbstractInsnNode?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.transform.<anonymous>[ValueParameterDescriptorImpl]

'isPop' @ [70:33] ==> public fun AbstractInsnNode.isPop(): Boolean defined in org.jetbrains.kotlin.codegen.optimization.boxing[SimpleFunctionDescriptorImpl]

'it' @ [70:44] ==> value-parameter it: (AbstractInsnNode..AbstractInsnNode?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.transform.<anonymous>[ValueParameterDescriptorImpl]

'isPurePush' @ [70:47] ==> public fun AbstractInsnNode.isPurePush(): Boolean defined in org.jetbrains.kotlin.codegen.optimization.boxing[SimpleFunctionDescriptorImpl]

'computeTransformations' @ [72:13] ==> private final fun computeTransformations(): Unit defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'component1' @ [73:19] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation>.component1(): AbstractInsnNode defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> AbstractInsnNode
    <V> -> Transformation

'component2' @ [73:25] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation>.component2(): PopBackwardPropagationTransformer.Transformer.Transformation defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> AbstractInsnNode
    <V> -> Transformation

'transformations' @ [73:44] ==> private final val transformations: HashMap<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation> /* = HashMap<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation> */ defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'entries' @ [73:60] ==> public open val entries: MutableSet<MutableMap.MutableEntry<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation>> defined in java.util.HashMap[JavaPropertyDescriptor]

'transformation' @ [74:17] ==> val transformation: PopBackwardPropagationTransformer.Transformer.Transformation defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.transform[LocalVariableDescriptor]

'apply' @ [74:32] ==> public abstract fun apply(insn: AbstractInsnNode): Unit defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.Transformation[SimpleFunctionDescriptorImpl]

'insn' @ [74:38] ==> val insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.transform[LocalVariableDescriptor]

'postprocessNops' @ [76:13] ==> private final fun postprocessNops(): Unit defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'Analyzer' @ [80:26] ==> public constructor Analyzer<V : (Value..Value?)>(p0: (Interpreter<(SourceValue..SourceValue?)>..Interpreter<(SourceValue..SourceValue?)>?)) defined in org.jetbrains.org.objectweb.asm.tree.analysis.Analyzer[JavaClassConstructorDescriptor]
Inferred types:
    <V : (Value..Value?)> -> SourceValue

'HazardsTrackingInterpreter' @ [80:48] ==> public constructor HazardsTrackingInterpreter() defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter[ClassConstructorDescriptorImpl]

'analyze' @ [80:78] ==> public open fun analyze(p0: (String..String?), p1: (MethodNode..MethodNode?)): (Array<(Frame<(SourceValue..SourceValue?)>..Frame<(SourceValue..SourceValue?)>?)>..Array<out (Frame<(SourceValue..SourceValue?)>..Frame<(SourceValue..SourceValue?)>?)>?) defined in org.jetbrains.org.objectweb.asm.tree.analysis.Analyzer[JavaMethodDescriptor]

'methodNode' @ [80:94] ==> public final val methodNode: MethodNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'postprocessDupNxM' @ [82:13] ==> private final fun postprocessDupNxM(frames: Array<out Frame<SourceValue>?>): Unit defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'frames' @ [82:31] ==> val frames: (Array<(Frame<(SourceValue..SourceValue?)>..Frame<(SourceValue..SourceValue?)>?)>..Array<out (Frame<(SourceValue..SourceValue?)>..Frame<(SourceValue..SourceValue?)>?)>?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.analyzeMethodBody[LocalVariableDescriptor]

'frames' @ [84:20] ==> val frames: (Array<(Frame<(SourceValue..SourceValue?)>..Frame<(SourceValue..SourceValue?)>?)>..Array<out (Frame<(SourceValue..SourceValue?)>..Frame<(SourceValue..SourceValue?)>?)>?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.analyzeMethodBody[LocalVariableDescriptor]

'methodNode' @ [88:25] ==> public final val methodNode: MethodNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'instructions' @ [88:36] ==> public final var instructions: (InsnList..InsnList?) defined in org.jetbrains.org.objectweb.asm.tree.MethodNode[JavaPropertyDescriptor]

'toArray' @ [88:49] ==> public open fun toArray(): (Array<(AbstractInsnNode..AbstractInsnNode?)>..Array<out (AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.org.objectweb.asm.tree.InsnList[JavaMethodDescriptor]

'frames' @ [89:23] ==> value-parameter frames: Array<out Frame<SourceValue>?> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM[ValueParameterDescriptorImpl]

'indices' @ [89:30] ==> public val <T> Array<out Frame<SourceValue>?>.indices: IntRange defined in kotlin.collections[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> Frame<SourceValue>?

'frames' @ [90:29] ==> value-parameter frames: Array<out Frame<SourceValue>?> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM[ValueParameterDescriptorImpl]

'i' @ [90:36] ==> val i: Int defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM[LocalVariableDescriptor]

'insns' @ [91:28] ==> val insns: (Array<(AbstractInsnNode..AbstractInsnNode?)>..Array<out (AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM[LocalVariableDescriptor]

'i' @ [91:34] ==> val i: Int defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM[LocalVariableDescriptor]

'when (insn.opcode) {
                    Opcodes.DUP_X1 -> {
                        val top2 = frame.peekWords(1, 1) ?: throwIncorrectBytecode(insn, frame)
                        top2.forEach { it.insns.markAsDontTouch() }
                    }
                    Opcodes.DUP2_X1 -> {
                        val top3 = frame.peekWords(2, 1) ?: throwIncorrectBytecode(insn, frame)
                        top3.forEach { it.insns.markAsDontTouch() }
                    }
                    Opcodes.DUP_X2 -> {
                        val top3 = frame.peekWords(1, 2) ?: throwIncorrectBytecode(insn, frame)
                        top3.forEach { it.insns.markAsDontTouch() }
                    }
                    Opcodes.DUP2_X2 -> {
                        val top4 = frame.peekWords(2, 2) ?: throwIncorrectBytecode(insn, frame)
                        top4.forEach { it.insns.markAsDontTouch() }
                    }
                }' @ [93:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit, entry3: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'insn' @ [93:23] ==> val insn: (AbstractInsnNode..AbstractInsnNode?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM[LocalVariableDescriptor]

'opcode' @ [93:28] ==> public final val AbstractInsnNode.opcode: Int[MyPropertyDescriptor]

'DUP_X1' @ [94:29] ==> public const final val DUP_X1: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'frame' @ [95:36] ==> val frame: Frame<SourceValue> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM[LocalVariableDescriptor]

'peekWords' @ [95:42] ==> public fun <V : Value> Frame<SourceValue>.peekWords(size1: Int, size2: Int): List<SourceValue>? defined in org.jetbrains.kotlin.codegen.optimization.fixStack[SimpleFunctionDescriptorImpl]
Inferred types:
    <V : Value> -> SourceValue

'throwIncorrectBytecode' @ [95:61] ==> private final fun throwIncorrectBytecode(insn: AbstractInsnNode?, frame: Frame<SourceValue>): Nothing defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'insn' @ [95:84] ==> val insn: (AbstractInsnNode..AbstractInsnNode?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM[LocalVariableDescriptor]

'frame' @ [95:90] ==> val frame: Frame<SourceValue> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM[LocalVariableDescriptor]

'top2' @ [96:25] ==> val top2: List<SourceValue> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM[LocalVariableDescriptor]

'forEach' @ [96:30] ==> @HidesMembers public inline fun <T> Iterable<SourceValue>.forEach(action: (SourceValue) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SourceValue

'it' @ [96:40] ==> value-parameter it: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM.<anonymous>[ValueParameterDescriptorImpl]

'insns' @ [96:43] ==> public final val insns: (MutableSet<(AbstractInsnNode..AbstractInsnNode?)>..Set<(AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceValue[JavaPropertyDescriptor]

'markAsDontTouch' @ [96:49] ==> private final fun Collection<AbstractInsnNode>.markAsDontTouch(): Unit defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'DUP2_X1' @ [98:29] ==> public const final val DUP2_X1: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'frame' @ [99:36] ==> val frame: Frame<SourceValue> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM[LocalVariableDescriptor]

'peekWords' @ [99:42] ==> public fun <V : Value> Frame<SourceValue>.peekWords(size1: Int, size2: Int): List<SourceValue>? defined in org.jetbrains.kotlin.codegen.optimization.fixStack[SimpleFunctionDescriptorImpl]
Inferred types:
    <V : Value> -> SourceValue

'throwIncorrectBytecode' @ [99:61] ==> private final fun throwIncorrectBytecode(insn: AbstractInsnNode?, frame: Frame<SourceValue>): Nothing defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'insn' @ [99:84] ==> val insn: (AbstractInsnNode..AbstractInsnNode?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM[LocalVariableDescriptor]

'frame' @ [99:90] ==> val frame: Frame<SourceValue> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM[LocalVariableDescriptor]

'top3' @ [100:25] ==> val top3: List<SourceValue> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM[LocalVariableDescriptor]

'forEach' @ [100:30] ==> @HidesMembers public inline fun <T> Iterable<SourceValue>.forEach(action: (SourceValue) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SourceValue

'it' @ [100:40] ==> value-parameter it: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM.<anonymous>[ValueParameterDescriptorImpl]

'insns' @ [100:43] ==> public final val insns: (MutableSet<(AbstractInsnNode..AbstractInsnNode?)>..Set<(AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceValue[JavaPropertyDescriptor]

'markAsDontTouch' @ [100:49] ==> private final fun Collection<AbstractInsnNode>.markAsDontTouch(): Unit defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'DUP_X2' @ [102:29] ==> public const final val DUP_X2: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'frame' @ [103:36] ==> val frame: Frame<SourceValue> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM[LocalVariableDescriptor]

'peekWords' @ [103:42] ==> public fun <V : Value> Frame<SourceValue>.peekWords(size1: Int, size2: Int): List<SourceValue>? defined in org.jetbrains.kotlin.codegen.optimization.fixStack[SimpleFunctionDescriptorImpl]
Inferred types:
    <V : Value> -> SourceValue

'throwIncorrectBytecode' @ [103:61] ==> private final fun throwIncorrectBytecode(insn: AbstractInsnNode?, frame: Frame<SourceValue>): Nothing defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'insn' @ [103:84] ==> val insn: (AbstractInsnNode..AbstractInsnNode?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM[LocalVariableDescriptor]

'frame' @ [103:90] ==> val frame: Frame<SourceValue> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM[LocalVariableDescriptor]

'top3' @ [104:25] ==> val top3: List<SourceValue> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM[LocalVariableDescriptor]

'forEach' @ [104:30] ==> @HidesMembers public inline fun <T> Iterable<SourceValue>.forEach(action: (SourceValue) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SourceValue

'it' @ [104:40] ==> value-parameter it: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM.<anonymous>[ValueParameterDescriptorImpl]

'insns' @ [104:43] ==> public final val insns: (MutableSet<(AbstractInsnNode..AbstractInsnNode?)>..Set<(AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceValue[JavaPropertyDescriptor]

'markAsDontTouch' @ [104:49] ==> private final fun Collection<AbstractInsnNode>.markAsDontTouch(): Unit defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'DUP2_X2' @ [106:29] ==> public const final val DUP2_X2: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'frame' @ [107:36] ==> val frame: Frame<SourceValue> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM[LocalVariableDescriptor]

'peekWords' @ [107:42] ==> public fun <V : Value> Frame<SourceValue>.peekWords(size1: Int, size2: Int): List<SourceValue>? defined in org.jetbrains.kotlin.codegen.optimization.fixStack[SimpleFunctionDescriptorImpl]
Inferred types:
    <V : Value> -> SourceValue

'throwIncorrectBytecode' @ [107:61] ==> private final fun throwIncorrectBytecode(insn: AbstractInsnNode?, frame: Frame<SourceValue>): Nothing defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'insn' @ [107:84] ==> val insn: (AbstractInsnNode..AbstractInsnNode?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM[LocalVariableDescriptor]

'frame' @ [107:90] ==> val frame: Frame<SourceValue> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM[LocalVariableDescriptor]

'top4' @ [108:25] ==> val top4: List<SourceValue> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM[LocalVariableDescriptor]

'forEach' @ [108:30] ==> @HidesMembers public inline fun <T> Iterable<SourceValue>.forEach(action: (SourceValue) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SourceValue

'it' @ [108:40] ==> value-parameter it: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessDupNxM.<anonymous>[ValueParameterDescriptorImpl]

'insns' @ [108:43] ==> public final val insns: (MutableSet<(AbstractInsnNode..AbstractInsnNode?)>..Set<(AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceValue[JavaPropertyDescriptor]

'markAsDontTouch' @ [108:49] ==> private final fun Collection<AbstractInsnNode>.markAsDontTouch(): Unit defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'AssertionError' @ [115:19] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'methodNode' @ [115:59] ==> public final val methodNode: MethodNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'instructions' @ [115:70] ==> public final var instructions: (InsnList..InsnList?) defined in org.jetbrains.org.objectweb.asm.tree.MethodNode[JavaPropertyDescriptor]

'indexOf' @ [115:83] ==> public open fun indexOf(p0: (AbstractInsnNode..AbstractInsnNode?)): Int defined in org.jetbrains.org.objectweb.asm.tree.InsnList[JavaMethodDescriptor]

'insn' @ [115:91] ==> value-parameter insn: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.throwIncorrectBytecode[ValueParameterDescriptorImpl]

'insn' @ [115:101] ==> value-parameter insn: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.throwIncorrectBytecode[ValueParameterDescriptorImpl]

'debugText' @ [115:106] ==> public val AbstractInsnNode?.debugText: String defined in org.jetbrains.kotlin.codegen.optimization.common in file Util.kt[PropertyDescriptorImpl]

'frame' @ [115:118] ==> value-parameter frame: Frame<SourceValue> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.throwIncorrectBytecode[ValueParameterDescriptorImpl]

'SourceInterpreter' @ [118:58] ==> public constructor SourceInterpreter() defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceInterpreter[JavaClassConstructorDescriptor]

'values' @ [120:31] ==> value-parameter values: MutableList<out SourceValue> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter.naryOperation[ValueParameterDescriptorImpl]

'value' @ [121:21] ==> val value: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter.naryOperation[LocalVariableDescriptor]

'insns' @ [121:27] ==> public final val insns: (MutableSet<(AbstractInsnNode..AbstractInsnNode?)>..Set<(AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceValue[JavaPropertyDescriptor]

'markAsDontTouch' @ [121:33] ==> private final fun Collection<AbstractInsnNode>.markAsDontTouch(): Unit defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'super' @ [123:24] ==> <this> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter[LazyClassReceiverParameterDescriptor]

'naryOperation' @ [123:30] ==> public open fun naryOperation(p0: (AbstractInsnNode..AbstractInsnNode?), p1: (MutableList<out (SourceValue..SourceValue?)>..List<(SourceValue..SourceValue?)>?)): (SourceValue..SourceValue?) defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceInterpreter[JavaMethodDescriptor]

'insn' @ [123:44] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter.naryOperation[ValueParameterDescriptorImpl]

'values' @ [123:50] ==> value-parameter values: MutableList<out SourceValue> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter.naryOperation[ValueParameterDescriptorImpl]

'value' @ [127:17] ==> value-parameter value: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter.copyOperation[ValueParameterDescriptorImpl]

'insns' @ [127:23] ==> public final val insns: (MutableSet<(AbstractInsnNode..AbstractInsnNode?)>..Set<(AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceValue[JavaPropertyDescriptor]

'markAsDontTouch' @ [127:29] ==> private final fun Collection<AbstractInsnNode>.markAsDontTouch(): Unit defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'super' @ [128:24] ==> <this> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter[LazyClassReceiverParameterDescriptor]

'copyOperation' @ [128:30] ==> public open fun copyOperation(p0: (AbstractInsnNode..AbstractInsnNode?), p1: (SourceValue..SourceValue?)): (SourceValue..SourceValue?) defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceInterpreter[JavaMethodDescriptor]

'insn' @ [128:44] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter.copyOperation[ValueParameterDescriptorImpl]

'value' @ [128:50] ==> value-parameter value: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter.copyOperation[ValueParameterDescriptorImpl]

'insn' @ [132:21] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter.unaryOperation[ValueParameterDescriptorImpl]

'opcode' @ [132:26] ==> public final val AbstractInsnNode.opcode: Int[MyPropertyDescriptor]

'CHECKCAST' @ [132:44] ==> public const final val CHECKCAST: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'!' @ [132:57] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'insn' @ [132:58] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter.unaryOperation[ValueParameterDescriptorImpl]

'isPrimitiveTypeConversion' @ [132:63] ==> public fun AbstractInsnNode.isPrimitiveTypeConversion(): Boolean defined in org.jetbrains.kotlin.codegen.optimization.boxing[SimpleFunctionDescriptorImpl]

'value' @ [133:21] ==> value-parameter value: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter.unaryOperation[ValueParameterDescriptorImpl]

'insns' @ [133:27] ==> public final val insns: (MutableSet<(AbstractInsnNode..AbstractInsnNode?)>..Set<(AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceValue[JavaPropertyDescriptor]

'markAsDontTouch' @ [133:33] ==> private final fun Collection<AbstractInsnNode>.markAsDontTouch(): Unit defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'super' @ [135:24] ==> <this> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter[LazyClassReceiverParameterDescriptor]

'unaryOperation' @ [135:30] ==> public open fun unaryOperation(p0: (AbstractInsnNode..AbstractInsnNode?), p1: (SourceValue..SourceValue?)): (SourceValue..SourceValue?) defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceInterpreter[JavaMethodDescriptor]

'insn' @ [135:45] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter.unaryOperation[ValueParameterDescriptorImpl]

'value' @ [135:51] ==> value-parameter value: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter.unaryOperation[ValueParameterDescriptorImpl]

'value1' @ [139:17] ==> value-parameter value1: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter.binaryOperation[ValueParameterDescriptorImpl]

'insns' @ [139:24] ==> public final val insns: (MutableSet<(AbstractInsnNode..AbstractInsnNode?)>..Set<(AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceValue[JavaPropertyDescriptor]

'markAsDontTouch' @ [139:30] ==> private final fun Collection<AbstractInsnNode>.markAsDontTouch(): Unit defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'value2' @ [140:17] ==> value-parameter value2: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter.binaryOperation[ValueParameterDescriptorImpl]

'insns' @ [140:24] ==> public final val insns: (MutableSet<(AbstractInsnNode..AbstractInsnNode?)>..Set<(AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceValue[JavaPropertyDescriptor]

'markAsDontTouch' @ [140:30] ==> private final fun Collection<AbstractInsnNode>.markAsDontTouch(): Unit defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'super' @ [141:24] ==> <this> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter[LazyClassReceiverParameterDescriptor]

'binaryOperation' @ [141:30] ==> public open fun binaryOperation(p0: (AbstractInsnNode..AbstractInsnNode?), p1: (SourceValue..SourceValue?), p2: (SourceValue..SourceValue?)): (SourceValue..SourceValue?) defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceInterpreter[JavaMethodDescriptor]

'insn' @ [141:46] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter.binaryOperation[ValueParameterDescriptorImpl]

'value1' @ [141:52] ==> value-parameter value1: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter.binaryOperation[ValueParameterDescriptorImpl]

'value2' @ [141:60] ==> value-parameter value2: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter.binaryOperation[ValueParameterDescriptorImpl]

'value1' @ [145:17] ==> value-parameter value1: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter.ternaryOperation[ValueParameterDescriptorImpl]

'insns' @ [145:24] ==> public final val insns: (MutableSet<(AbstractInsnNode..AbstractInsnNode?)>..Set<(AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceValue[JavaPropertyDescriptor]

'markAsDontTouch' @ [145:30] ==> private final fun Collection<AbstractInsnNode>.markAsDontTouch(): Unit defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'value2' @ [146:17] ==> value-parameter value2: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter.ternaryOperation[ValueParameterDescriptorImpl]

'insns' @ [146:24] ==> public final val insns: (MutableSet<(AbstractInsnNode..AbstractInsnNode?)>..Set<(AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceValue[JavaPropertyDescriptor]

'markAsDontTouch' @ [146:30] ==> private final fun Collection<AbstractInsnNode>.markAsDontTouch(): Unit defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'value3' @ [147:17] ==> value-parameter value3: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter.ternaryOperation[ValueParameterDescriptorImpl]

'insns' @ [147:24] ==> public final val insns: (MutableSet<(AbstractInsnNode..AbstractInsnNode?)>..Set<(AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceValue[JavaPropertyDescriptor]

'markAsDontTouch' @ [147:30] ==> private final fun Collection<AbstractInsnNode>.markAsDontTouch(): Unit defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'super' @ [148:24] ==> <this> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter[LazyClassReceiverParameterDescriptor]

'ternaryOperation' @ [148:30] ==> public open fun ternaryOperation(p0: (AbstractInsnNode..AbstractInsnNode?), p1: (SourceValue..SourceValue?), p2: (SourceValue..SourceValue?), p3: (SourceValue..SourceValue?)): (SourceValue..SourceValue?) defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceInterpreter[JavaMethodDescriptor]

'insn' @ [148:47] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter.ternaryOperation[ValueParameterDescriptorImpl]

'value1' @ [148:53] ==> value-parameter value1: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter.ternaryOperation[ValueParameterDescriptorImpl]

'value2' @ [148:61] ==> value-parameter value2: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter.ternaryOperation[ValueParameterDescriptorImpl]

'value3' @ [148:69] ==> value-parameter value3: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.HazardsTrackingInterpreter.ternaryOperation[ValueParameterDescriptorImpl]

'forEach' @ [153:13] ==> @HidesMembers public inline fun <T> Iterable<AbstractInsnNode>.forEach(action: (AbstractInsnNode) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> AbstractInsnNode

'dontTouchInsnIndices' @ [154:17] ==> private final val dontTouchInsnIndices: BitSet defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'insnList' @ [154:38] ==> private final val insnList: (InsnList..InsnList?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'indexOf' @ [154:47] ==> public open fun indexOf(p0: (AbstractInsnNode..AbstractInsnNode?)): Int defined in org.jetbrains.org.objectweb.asm.tree.InsnList[JavaMethodDescriptor]

'it' @ [154:55] ==> value-parameter it: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.markAsDontTouch.<anonymous>[ValueParameterDescriptorImpl]

'transformations' @ [160:13] ==> private final val transformations: HashMap<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation> /* = HashMap<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation> */ defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'clear' @ [160:29] ==> public open fun clear(): Unit defined in java.util.HashMap[JavaMethodDescriptor]

'insns' @ [162:23] ==> private final val insns: (Array<(AbstractInsnNode..AbstractInsnNode?)>..Array<out (AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'indices' @ [162:29] ==> public val <T> Array<out (AbstractInsnNode..AbstractInsnNode?)>.indices: IntRange defined in kotlin.collections[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> (org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode..org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode?)

'frames' @ [163:21] ==> private final val frames: Array<out Frame<SourceValue>?> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'i' @ [163:28] ==> val i: Int defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.computeTransformations[LocalVariableDescriptor]

'insns' @ [164:28] ==> private final val insns: (Array<(AbstractInsnNode..AbstractInsnNode?)>..Array<out (AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'i' @ [164:34] ==> val i: Int defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.computeTransformations[LocalVariableDescriptor]

'insn' @ [166:21] ==> val insn: (AbstractInsnNode..AbstractInsnNode?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.computeTransformations[LocalVariableDescriptor]

'opcode' @ [166:26] ==> public final val AbstractInsnNode.opcode: Int[MyPropertyDescriptor]

'POP' @ [166:44] ==> public const final val POP: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'propagatePopBackwards' @ [167:21] ==> private final fun propagatePopBackwards(insn: AbstractInsnNode, poppedValueSize: Int): Unit defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'insn' @ [167:43] ==> val insn: (AbstractInsnNode..AbstractInsnNode?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.computeTransformations[LocalVariableDescriptor]

'transformations' @ [173:17] ==> private final val transformations: HashMap<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation> /* = HashMap<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation> */ defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'containsKey' @ [173:33] ==> public open fun containsKey(key: AbstractInsnNode): Boolean defined in java.util.HashMap[JavaMethodDescriptor]

'insn' @ [173:45] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[ValueParameterDescriptorImpl]

'when {
                insn.opcode == Opcodes.POP -> {
                    val inputTop = getInputTop(insn)
                    val sources = inputTop.insns
                    if (sources.all { !isDontTouch(it) } && sources.any { isTransformablePopOperand(it) }) {
                        transformations[insn] = replaceWithNopTransformation()
                        sources.forEach { propagatePopBackwards(it, inputTop.size) }
                    }
                }

                insn.opcode == Opcodes.CHECKCAST -> {
                    val inputTop = getInputTop(insn)
                    val sources = inputTop.insns
                    val resultType = (insn as TypeInsnNode).desc
                    if (sources.all { !isDontTouch(it) } && sources.any { isTransformableCheckcastOperand(it, resultType) }) {
                        transformations[insn] = replaceWithNopTransformation()
                        sources.forEach { propagatePopBackwards(it, inputTop.size) }
                    }
                    else {
                        transformations[insn] = insertPopAfterTransformation(poppedValueSize)
                    }
                }

                insn.isPrimitiveBoxing() -> {
                    val boxedValueSize = getInputTop(insn).size
                    transformations[insn] = replaceWithPopTransformation(boxedValueSize)
                }

                insn.isPurePush() -> {
                    transformations[insn] = replaceWithNopTransformation()
                }

                insn.isPrimitiveTypeConversion() -> {
                    val inputTop = getInputTop(insn)
                    val sources = inputTop.insns
                    if (sources.all { !isDontTouch(it) }) {
                        transformations[insn] = replaceWithNopTransformation()
                        sources.forEach { propagatePopBackwards(it, inputTop.size) }
                    }
                    else {
                        transformations[insn] = replaceWithPopTransformation(poppedValueSize)
                    }
                }

                else -> {
                    transformations[insn] = insertPopAfterTransformation(poppedValueSize)
                }
            }' @ [175:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit, entry3: Unit, entry4: Unit, entry5: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'insn' @ [176:17] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[ValueParameterDescriptorImpl]

'opcode' @ [176:22] ==> public final val AbstractInsnNode.opcode: Int[MyPropertyDescriptor]

'POP' @ [176:40] ==> public const final val POP: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'getInputTop' @ [177:36] ==> private final fun getInputTop(insn: AbstractInsnNode): SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'insn' @ [177:48] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[ValueParameterDescriptorImpl]

'inputTop' @ [178:35] ==> val inputTop: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[LocalVariableDescriptor]

'insns' @ [178:44] ==> public final val insns: (MutableSet<(AbstractInsnNode..AbstractInsnNode?)>..Set<(AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceValue[JavaPropertyDescriptor]

'sources' @ [179:25] ==> val sources: (MutableSet<(AbstractInsnNode..AbstractInsnNode?)>..Set<(AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[LocalVariableDescriptor]

'all' @ [179:33] ==> public inline fun <T> Iterable<(AbstractInsnNode..AbstractInsnNode?)>.all(predicate: ((AbstractInsnNode..AbstractInsnNode?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode..org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode?)

'!' @ [179:39] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isDontTouch' @ [179:40] ==> private final fun isDontTouch(insn: AbstractInsnNode): Boolean defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'it' @ [179:52] ==> value-parameter it: (AbstractInsnNode..AbstractInsnNode?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards.<anonymous>[ValueParameterDescriptorImpl]

'sources' @ [179:61] ==> val sources: (MutableSet<(AbstractInsnNode..AbstractInsnNode?)>..Set<(AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[LocalVariableDescriptor]

'any' @ [179:69] ==> public inline fun <T> Iterable<(AbstractInsnNode..AbstractInsnNode?)>.any(predicate: ((AbstractInsnNode..AbstractInsnNode?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode..org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode?)

'isTransformablePopOperand' @ [179:75] ==> private final fun isTransformablePopOperand(insn: AbstractInsnNode): Boolean defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'it' @ [179:101] ==> value-parameter it: (AbstractInsnNode..AbstractInsnNode?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards.<anonymous>[ValueParameterDescriptorImpl]

'transformations' @ [180:25] ==> private final val transformations: HashMap<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation> /* = HashMap<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation> */ defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'insn' @ [180:41] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[ValueParameterDescriptorImpl]

'replaceWithNopTransformation' @ [180:49] ==> private final fun replaceWithNopTransformation(): PopBackwardPropagationTransformer.Transformer.Transformation defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'sources' @ [181:25] ==> val sources: (MutableSet<(AbstractInsnNode..AbstractInsnNode?)>..Set<(AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[LocalVariableDescriptor]

'forEach' @ [181:33] ==> @HidesMembers public inline fun <T> Iterable<(AbstractInsnNode..AbstractInsnNode?)>.forEach(action: ((AbstractInsnNode..AbstractInsnNode?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode..org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode?)

'propagatePopBackwards' @ [181:43] ==> private final fun propagatePopBackwards(insn: AbstractInsnNode, poppedValueSize: Int): Unit defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'it' @ [181:65] ==> value-parameter it: (AbstractInsnNode..AbstractInsnNode?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards.<anonymous>[ValueParameterDescriptorImpl]

'inputTop' @ [181:69] ==> val inputTop: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[LocalVariableDescriptor]

'size' @ [181:78] ==> public final val size: Int defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceValue[JavaPropertyDescriptor]

'insn' @ [185:17] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[ValueParameterDescriptorImpl]

'opcode' @ [185:22] ==> public final val AbstractInsnNode.opcode: Int[MyPropertyDescriptor]

'CHECKCAST' @ [185:40] ==> public const final val CHECKCAST: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'getInputTop' @ [186:36] ==> private final fun getInputTop(insn: AbstractInsnNode): SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'insn' @ [186:48] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[ValueParameterDescriptorImpl]

'inputTop' @ [187:35] ==> val inputTop: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[LocalVariableDescriptor]

'insns' @ [187:44] ==> public final val insns: (MutableSet<(AbstractInsnNode..AbstractInsnNode?)>..Set<(AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceValue[JavaPropertyDescriptor]

'insn' @ [188:39] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[ValueParameterDescriptorImpl]

'desc' @ [188:61] ==> public final var desc: (String..String?) defined in org.jetbrains.org.objectweb.asm.tree.TypeInsnNode[JavaPropertyDescriptor]

'if (sources.all { !isDontTouch(it) } && sources.any { isTransformableCheckcastOperand(it, resultType) }) {
                        transformations[insn] = replaceWithNopTransformation()
                        sources.forEach { propagatePopBackwards(it, inputTop.size) }
                    }
                    else {
                        transformations[insn] = insertPopAfterTransformation(poppedValueSize)
                    }' @ [189:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'sources' @ [189:25] ==> val sources: (MutableSet<(AbstractInsnNode..AbstractInsnNode?)>..Set<(AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[LocalVariableDescriptor]

'all' @ [189:33] ==> public inline fun <T> Iterable<(AbstractInsnNode..AbstractInsnNode?)>.all(predicate: ((AbstractInsnNode..AbstractInsnNode?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode..org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode?)

'!' @ [189:39] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isDontTouch' @ [189:40] ==> private final fun isDontTouch(insn: AbstractInsnNode): Boolean defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'it' @ [189:52] ==> value-parameter it: (AbstractInsnNode..AbstractInsnNode?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards.<anonymous>[ValueParameterDescriptorImpl]

'sources' @ [189:61] ==> val sources: (MutableSet<(AbstractInsnNode..AbstractInsnNode?)>..Set<(AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[LocalVariableDescriptor]

'any' @ [189:69] ==> public inline fun <T> Iterable<(AbstractInsnNode..AbstractInsnNode?)>.any(predicate: ((AbstractInsnNode..AbstractInsnNode?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode..org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode?)

'isTransformableCheckcastOperand' @ [189:75] ==> private final fun isTransformableCheckcastOperand(it: AbstractInsnNode, resultType: String): Boolean defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'it' @ [189:107] ==> value-parameter it: (AbstractInsnNode..AbstractInsnNode?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards.<anonymous>[ValueParameterDescriptorImpl]

'resultType' @ [189:111] ==> val resultType: (String..String?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[LocalVariableDescriptor]

'transformations' @ [190:25] ==> private final val transformations: HashMap<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation> /* = HashMap<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation> */ defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'insn' @ [190:41] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[ValueParameterDescriptorImpl]

'replaceWithNopTransformation' @ [190:49] ==> private final fun replaceWithNopTransformation(): PopBackwardPropagationTransformer.Transformer.Transformation defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'sources' @ [191:25] ==> val sources: (MutableSet<(AbstractInsnNode..AbstractInsnNode?)>..Set<(AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[LocalVariableDescriptor]

'forEach' @ [191:33] ==> @HidesMembers public inline fun <T> Iterable<(AbstractInsnNode..AbstractInsnNode?)>.forEach(action: ((AbstractInsnNode..AbstractInsnNode?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode..org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode?)

'propagatePopBackwards' @ [191:43] ==> private final fun propagatePopBackwards(insn: AbstractInsnNode, poppedValueSize: Int): Unit defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'it' @ [191:65] ==> value-parameter it: (AbstractInsnNode..AbstractInsnNode?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards.<anonymous>[ValueParameterDescriptorImpl]

'inputTop' @ [191:69] ==> val inputTop: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[LocalVariableDescriptor]

'size' @ [191:78] ==> public final val size: Int defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceValue[JavaPropertyDescriptor]

'transformations' @ [194:25] ==> private final val transformations: HashMap<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation> /* = HashMap<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation> */ defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'insn' @ [194:41] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[ValueParameterDescriptorImpl]

'insertPopAfterTransformation' @ [194:49] ==> private final fun insertPopAfterTransformation(size: Int): PopBackwardPropagationTransformer.Transformer.Transformation defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'poppedValueSize' @ [194:78] ==> value-parameter poppedValueSize: Int defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[ValueParameterDescriptorImpl]

'insn' @ [198:17] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[ValueParameterDescriptorImpl]

'isPrimitiveBoxing' @ [198:22] ==> public fun AbstractInsnNode.isPrimitiveBoxing(): Boolean defined in org.jetbrains.kotlin.codegen.optimization.boxing[SimpleFunctionDescriptorImpl]

'getInputTop' @ [199:42] ==> private final fun getInputTop(insn: AbstractInsnNode): SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'insn' @ [199:54] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[ValueParameterDescriptorImpl]

'size' @ [199:60] ==> public final val size: Int defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceValue[JavaPropertyDescriptor]

'transformations' @ [200:21] ==> private final val transformations: HashMap<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation> /* = HashMap<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation> */ defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'insn' @ [200:37] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[ValueParameterDescriptorImpl]

'replaceWithPopTransformation' @ [200:45] ==> private final fun replaceWithPopTransformation(size: Int): PopBackwardPropagationTransformer.Transformer.Transformation defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'boxedValueSize' @ [200:74] ==> val boxedValueSize: Int defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[LocalVariableDescriptor]

'insn' @ [203:17] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[ValueParameterDescriptorImpl]

'isPurePush' @ [203:22] ==> public fun AbstractInsnNode.isPurePush(): Boolean defined in org.jetbrains.kotlin.codegen.optimization.boxing[SimpleFunctionDescriptorImpl]

'transformations' @ [204:21] ==> private final val transformations: HashMap<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation> /* = HashMap<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation> */ defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'insn' @ [204:37] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[ValueParameterDescriptorImpl]

'replaceWithNopTransformation' @ [204:45] ==> private final fun replaceWithNopTransformation(): PopBackwardPropagationTransformer.Transformer.Transformation defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'insn' @ [207:17] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[ValueParameterDescriptorImpl]

'isPrimitiveTypeConversion' @ [207:22] ==> public fun AbstractInsnNode.isPrimitiveTypeConversion(): Boolean defined in org.jetbrains.kotlin.codegen.optimization.boxing[SimpleFunctionDescriptorImpl]

'getInputTop' @ [208:36] ==> private final fun getInputTop(insn: AbstractInsnNode): SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'insn' @ [208:48] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[ValueParameterDescriptorImpl]

'inputTop' @ [209:35] ==> val inputTop: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[LocalVariableDescriptor]

'insns' @ [209:44] ==> public final val insns: (MutableSet<(AbstractInsnNode..AbstractInsnNode?)>..Set<(AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceValue[JavaPropertyDescriptor]

'if (sources.all { !isDontTouch(it) }) {
                        transformations[insn] = replaceWithNopTransformation()
                        sources.forEach { propagatePopBackwards(it, inputTop.size) }
                    }
                    else {
                        transformations[insn] = replaceWithPopTransformation(poppedValueSize)
                    }' @ [210:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'sources' @ [210:25] ==> val sources: (MutableSet<(AbstractInsnNode..AbstractInsnNode?)>..Set<(AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[LocalVariableDescriptor]

'all' @ [210:33] ==> public inline fun <T> Iterable<(AbstractInsnNode..AbstractInsnNode?)>.all(predicate: ((AbstractInsnNode..AbstractInsnNode?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode..org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode?)

'!' @ [210:39] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isDontTouch' @ [210:40] ==> private final fun isDontTouch(insn: AbstractInsnNode): Boolean defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'it' @ [210:52] ==> value-parameter it: (AbstractInsnNode..AbstractInsnNode?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards.<anonymous>[ValueParameterDescriptorImpl]

'transformations' @ [211:25] ==> private final val transformations: HashMap<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation> /* = HashMap<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation> */ defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'insn' @ [211:41] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[ValueParameterDescriptorImpl]

'replaceWithNopTransformation' @ [211:49] ==> private final fun replaceWithNopTransformation(): PopBackwardPropagationTransformer.Transformer.Transformation defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'sources' @ [212:25] ==> val sources: (MutableSet<(AbstractInsnNode..AbstractInsnNode?)>..Set<(AbstractInsnNode..AbstractInsnNode?)>?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[LocalVariableDescriptor]

'forEach' @ [212:33] ==> @HidesMembers public inline fun <T> Iterable<(AbstractInsnNode..AbstractInsnNode?)>.forEach(action: ((AbstractInsnNode..AbstractInsnNode?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode..org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode?)

'propagatePopBackwards' @ [212:43] ==> private final fun propagatePopBackwards(insn: AbstractInsnNode, poppedValueSize: Int): Unit defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'it' @ [212:65] ==> value-parameter it: (AbstractInsnNode..AbstractInsnNode?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards.<anonymous>[ValueParameterDescriptorImpl]

'inputTop' @ [212:69] ==> val inputTop: SourceValue defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[LocalVariableDescriptor]

'size' @ [212:78] ==> public final val size: Int defined in org.jetbrains.org.objectweb.asm.tree.analysis.SourceValue[JavaPropertyDescriptor]

'transformations' @ [215:25] ==> private final val transformations: HashMap<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation> /* = HashMap<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation> */ defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'insn' @ [215:41] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[ValueParameterDescriptorImpl]

'replaceWithPopTransformation' @ [215:49] ==> private final fun replaceWithPopTransformation(size: Int): PopBackwardPropagationTransformer.Transformer.Transformation defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'poppedValueSize' @ [215:78] ==> value-parameter poppedValueSize: Int defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[ValueParameterDescriptorImpl]

'transformations' @ [220:21] ==> private final val transformations: HashMap<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation> /* = HashMap<AbstractInsnNode, PopBackwardPropagationTransformer.Transformer.Transformation> */ defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'insn' @ [220:37] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[ValueParameterDescriptorImpl]

'insertPopAfterTransformation' @ [220:45] ==> private final fun insertPopAfterTransformation(size: Int): PopBackwardPropagationTransformer.Transformer.Transformation defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'poppedValueSize' @ [220:74] ==> value-parameter poppedValueSize: Int defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.propagatePopBackwards[ValueParameterDescriptorImpl]

'insnList' @ [226:43] ==> private final val insnList: (InsnList..InsnList?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'first' @ [226:52] ==> public final val InsnList.first: (AbstractInsnNode..AbstractInsnNode?)[MyPropertyDescriptor]

'node' @ [228:20] ==> var node: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessNops[LocalVariableDescriptor]

'node' @ [229:17] ==> var node: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessNops[LocalVariableDescriptor]

'node' @ [229:24] ==> var node: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessNops[LocalVariableDescriptor]

'next' @ [229:29] ==> public final val AbstractInsnNode.next: (AbstractInsnNode..AbstractInsnNode?)[MyPropertyDescriptor]

'node' @ [230:29] ==> var node: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessNops[LocalVariableDescriptor]

'node' @ [231:24] ==> var node: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessNops[LocalVariableDescriptor]

'node' @ [231:40] ==> var node: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessNops[LocalVariableDescriptor]

'node' @ [232:25] ==> var node: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessNops[LocalVariableDescriptor]

'removableNops' @ [232:33] ==> private final val removableNops: HashSet<InsnNode> /* = HashSet<InsnNode> */ defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'hasRemovableNops' @ [233:25] ==> var hasRemovableNops: Boolean defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessNops[LocalVariableDescriptor]

'node' @ [235:21] ==> var node: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessNops[LocalVariableDescriptor]

'node' @ [235:28] ==> var node: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessNops[LocalVariableDescriptor]

'next' @ [235:33] ==> public final val AbstractInsnNode.next: (AbstractInsnNode..AbstractInsnNode?)[MyPropertyDescriptor]

'node' @ [237:27] ==> var node: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessNops[LocalVariableDescriptor]

'hasRemovableNops' @ [238:21] ==> var hasRemovableNops: Boolean defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessNops[LocalVariableDescriptor]

'removeUnneededNopsInRange' @ [239:21] ==> private final fun removeUnneededNopsInRange(begin: AbstractInsnNode, end: AbstractInsnNode?): Unit defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[SimpleFunctionDescriptorImpl]

'begin' @ [239:47] ==> val begin: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessNops[LocalVariableDescriptor]

'end' @ [239:54] ==> val end: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessNops[LocalVariableDescriptor]

'hasRemovableNops' @ [241:17] ==> var hasRemovableNops: Boolean defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.postprocessNops[LocalVariableDescriptor]

'begin' @ [246:43] ==> value-parameter begin: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.removeUnneededNopsInRange[ValueParameterDescriptorImpl]

'node' @ [248:20] ==> var node: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.removeUnneededNopsInRange[LocalVariableDescriptor]

'node' @ [248:36] ==> var node: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.removeUnneededNopsInRange[LocalVariableDescriptor]

'end' @ [248:44] ==> value-parameter end: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.removeUnneededNopsInRange[ValueParameterDescriptorImpl]

'if (node in removableNops && !keepNop) {
                    node = insnList.removeNodeGetNext(node)
                }
                else {
                    if (node.isMeaningful) keepNop = false
                    node = node.next
                }' @ [249:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'node' @ [249:21] ==> var node: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.removeUnneededNopsInRange[LocalVariableDescriptor]

'removableNops' @ [249:29] ==> private final val removableNops: HashSet<InsnNode> /* = HashSet<InsnNode> */ defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'!' @ [249:46] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'keepNop' @ [249:47] ==> var keepNop: Boolean defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.removeUnneededNopsInRange[LocalVariableDescriptor]

'node' @ [250:21] ==> var node: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.removeUnneededNopsInRange[LocalVariableDescriptor]

'insnList' @ [250:28] ==> private final val insnList: (InsnList..InsnList?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'removeNodeGetNext' @ [250:37] ==> public fun InsnList.removeNodeGetNext(oldNode: AbstractInsnNode): AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.optimization in file LabelNormalizationMethodTransformer.kt[SimpleFunctionDescriptorImpl]

'node' @ [250:55] ==> var node: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.removeUnneededNopsInRange[LocalVariableDescriptor]

'node' @ [253:25] ==> var node: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.removeUnneededNopsInRange[LocalVariableDescriptor]

'isMeaningful' @ [253:30] ==> public val AbstractInsnNode.isMeaningful: Boolean defined in org.jetbrains.kotlin.codegen.optimization.common in file Util.kt[PropertyDescriptorImpl]

'keepNop' @ [253:44] ==> var keepNop: Boolean defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.removeUnneededNopsInRange[LocalVariableDescriptor]

'node' @ [254:21] ==> var node: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.removeUnneededNopsInRange[LocalVariableDescriptor]

'node' @ [254:28] ==> var node: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.removeUnneededNopsInRange[LocalVariableDescriptor]

'next' @ [254:33] ==> public final val AbstractInsnNode.next: (AbstractInsnNode..AbstractInsnNode?)[MyPropertyDescriptor]

'when (size) {
                    1 -> REPLACE_WITH_POP1
                    2 -> REPLACE_WITH_POP2
                    else -> throw AssertionError("Unexpected pop value size: $size")
                }' @ [260:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: PopBackwardPropagationTransformer.Transformer.Transformation, entry1: PopBackwardPropagationTransformer.Transformer.Transformation, entry2: PopBackwardPropagationTransformer.Transformer.Transformation): PopBackwardPropagationTransformer.Transformer.Transformation[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Transformation

'size' @ [260:23] ==> value-parameter size: Int defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.replaceWithPopTransformation[ValueParameterDescriptorImpl]

'REPLACE_WITH_POP1' @ [261:26] ==> private final val REPLACE_WITH_POP1: PopBackwardPropagationTransformer.Transformer.Transformation defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'REPLACE_WITH_POP2' @ [262:26] ==> private final val REPLACE_WITH_POP2: PopBackwardPropagationTransformer.Transformer.Transformation defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'AssertionError' @ [263:35] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'size' @ [263:79] ==> value-parameter size: Int defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.replaceWithPopTransformation[ValueParameterDescriptorImpl]

'when (size) {
                    1 -> INSERT_POP1_AFTER
                    2 -> INSERT_POP2_AFTER
                    else -> throw AssertionError("Unexpected pop value size: $size")
                }' @ [267:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: PopBackwardPropagationTransformer.Transformer.Transformation, entry1: PopBackwardPropagationTransformer.Transformer.Transformation, entry2: PopBackwardPropagationTransformer.Transformer.Transformation): PopBackwardPropagationTransformer.Transformer.Transformation[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Transformation

'size' @ [267:23] ==> value-parameter size: Int defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.insertPopAfterTransformation[ValueParameterDescriptorImpl]

'INSERT_POP1_AFTER' @ [268:26] ==> private final val INSERT_POP1_AFTER: PopBackwardPropagationTransformer.Transformer.Transformation defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'INSERT_POP2_AFTER' @ [269:26] ==> private final val INSERT_POP2_AFTER: PopBackwardPropagationTransformer.Transformer.Transformation defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'AssertionError' @ [270:35] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'size' @ [270:79] ==> value-parameter size: Int defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.insertPopAfterTransformation[ValueParameterDescriptorImpl]

'REPLACE_WITH_NOP' @ [274:17] ==> private final val REPLACE_WITH_NOP: PopBackwardPropagationTransformer.Transformer.Transformation defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'InsnNode' @ [277:17] ==> public constructor InsnNode(p0: Int) defined in org.jetbrains.org.objectweb.asm.tree.InsnNode[JavaClassConstructorDescriptor]

'NOP' @ [277:34] ==> public const final val NOP: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'apply' @ [277:39] ==> @InlineOnly public inline fun <T> InsnNode.apply(block: InsnNode.() -> Unit): InsnNode defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> InsnNode

'removableNops' @ [277:47] ==> private final val removableNops: HashSet<InsnNode> /* = HashSet<InsnNode> */ defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'add' @ [277:61] ==> public open fun add(element: InsnNode): Boolean defined in java.util.HashSet[JavaMethodDescriptor]

'this' @ [277:65] ==> <this> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.createRemovableNopInsn.<anonymous>[ReceiverParameterDescriptorImpl]

'insnList' @ [280:21] ==> private final val insnList: (InsnList..InsnList?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'indexOf' @ [280:30] ==> public open fun indexOf(p0: (AbstractInsnNode..AbstractInsnNode?)): Int defined in org.jetbrains.org.objectweb.asm.tree.InsnList[JavaMethodDescriptor]

'insn' @ [280:38] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.getInputTop[ValueParameterDescriptorImpl]

'frames' @ [281:25] ==> private final val frames: Array<out Frame<SourceValue>?> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'i' @ [281:32] ==> val i: Int defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.getInputTop[LocalVariableDescriptor]

'AssertionError' @ [281:44] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'i' @ [281:90] ==> val i: Int defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.getInputTop[LocalVariableDescriptor]

'frame' @ [282:20] ==> val frame: Frame<SourceValue> defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.getInputTop[LocalVariableDescriptor]

'top' @ [282:26] ==> public fun <V : Value> Frame<SourceValue>.top(): SourceValue? defined in org.jetbrains.kotlin.codegen.optimization.fixStack[SimpleFunctionDescriptorImpl]
Inferred types:
    <V : Value> -> SourceValue

'AssertionError' @ [282:41] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'i' @ [282:71] ==> val i: Int defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.getInputTop[LocalVariableDescriptor]

'it' @ [286:17] ==> value-parameter it: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.isTransformableCheckcastOperand[ValueParameterDescriptorImpl]

'isPrimitiveBoxing' @ [286:20] ==> public fun AbstractInsnNode.isPrimitiveBoxing(): Boolean defined in org.jetbrains.kotlin.codegen.optimization.boxing[SimpleFunctionDescriptorImpl]

'==' @ [286:43] ==> public open fun equals(other: Any?): Boolean defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'it' @ [286:44] ==> value-parameter it: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.isTransformableCheckcastOperand[ValueParameterDescriptorImpl]

'owner' @ [286:66] ==> public final var owner: (String..String?) defined in org.jetbrains.org.objectweb.asm.tree.MethodInsnNode[JavaPropertyDescriptor]

'resultType' @ [286:75] ==> value-parameter resultType: String defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.isTransformableCheckcastOperand[ValueParameterDescriptorImpl]

'insn' @ [289:17] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.isTransformablePopOperand[ValueParameterDescriptorImpl]

'opcode' @ [289:22] ==> public final val AbstractInsnNode.opcode: Int[MyPropertyDescriptor]

'CHECKCAST' @ [289:40] ==> public const final val CHECKCAST: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'insn' @ [289:53] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.isTransformablePopOperand[ValueParameterDescriptorImpl]

'isPrimitiveBoxing' @ [289:58] ==> public fun AbstractInsnNode.isPrimitiveBoxing(): Boolean defined in org.jetbrains.kotlin.codegen.optimization.boxing[SimpleFunctionDescriptorImpl]

'insn' @ [289:81] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.isTransformablePopOperand[ValueParameterDescriptorImpl]

'isPurePush' @ [289:86] ==> public fun AbstractInsnNode.isPurePush(): Boolean defined in org.jetbrains.kotlin.codegen.optimization.boxing[SimpleFunctionDescriptorImpl]

'dontTouchInsnIndices' @ [292:17] ==> private final val dontTouchInsnIndices: BitSet defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'insnList' @ [292:38] ==> private final val insnList: (InsnList..InsnList?) defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer[PropertyDescriptorImpl]

'indexOf' @ [292:47] ==> public open fun indexOf(p0: (AbstractInsnNode..AbstractInsnNode?)): Int defined in org.jetbrains.org.objectweb.asm.tree.InsnList[JavaMethodDescriptor]

'insn' @ [292:55] ==> value-parameter insn: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer.Transformer.isDontTouch[ValueParameterDescriptorImpl]

'isLoadOperation' @ [298:9] ==> public fun AbstractInsnNode.isLoadOperation(): Boolean defined in org.jetbrains.kotlin.codegen.optimization.common in file Util.kt[SimpleFunctionDescriptorImpl]

'opcode' @ [299:9] ==> public final val AbstractInsnNode.opcode: Int[MyPropertyDescriptor]

'..' @ [299:19] ==> public final operator fun rangeTo(other: Int): IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'ACONST_NULL' @ [299:27] ==> public const final val ACONST_NULL: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'+' @ [299:42] ==> public final operator fun plus(other: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'LDC' @ [299:50] ==> public const final val LDC: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'isUnitInstance' @ [300:9] ==> public fun AbstractInsnNode.isUnitInstance(): Boolean defined in org.jetbrains.kotlin.codegen.optimization.boxing[SimpleFunctionDescriptorImpl]

'opcode' @ [303:9] ==> public final val AbstractInsnNode.opcode: Int[MyPropertyDescriptor]

'POP' @ [303:27] ==> public const final val POP: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'opcode' @ [303:34] ==> public final val AbstractInsnNode.opcode: Int[MyPropertyDescriptor]

'POP2' @ [303:52] ==> public const final val POP2: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'opcode' @ [306:9] ==> public final val AbstractInsnNode.opcode: Int[MyPropertyDescriptor]

'GETSTATIC' @ [306:27] ==> public const final val GETSTATIC: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'this' @ [307:9] ==> <this> defined in org.jetbrains.kotlin.codegen.optimization.boxing.isUnitInstance[ReceiverParameterDescriptorImpl]

'owner' @ [307:34] ==> public final var owner: (String..String?) defined in org.jetbrains.org.objectweb.asm.tree.FieldInsnNode[JavaPropertyDescriptor]

'name' @ [307:60] ==> public final var name: (String..String?) defined in org.jetbrains.org.objectweb.asm.tree.FieldInsnNode[JavaPropertyDescriptor]

'opcode' @ [310:9] ==> public final val AbstractInsnNode.opcode: Int[MyPropertyDescriptor]

'..' @ [310:19] ==> public final operator fun rangeTo(other: Int): IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'I2L' @ [310:27] ==> public const final val I2L: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'I2S' @ [310:42] ==> public const final val I2S: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

