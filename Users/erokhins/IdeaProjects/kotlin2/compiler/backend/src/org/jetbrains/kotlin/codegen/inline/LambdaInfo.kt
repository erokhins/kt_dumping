'JvmField' @ [44:27] ==> public constructor JvmField() defined in kotlin.jvm.JvmField[DeserializedClassConstructorDescriptor]

'ParametersBuilder' @ [61:23] ==> public companion object defined in org.jetbrains.kotlin.codegen.inline.ParametersBuilder[FakeCallableDescriptorForObject]

'initializeBuilderFrom' @ [61:41] ==> @JvmOverloads @JvmStatic public final fun initializeBuilderFrom(objectType: Type, descriptor: String, inlineLambda: LambdaInfo? = ...): ParametersBuilder defined in org.jetbrains.kotlin.codegen.inline.ParametersBuilder.Companion[SimpleFunctionDescriptorImpl]

'OBJECT_TYPE' @ [61:72] ==> public final val OBJECT_TYPE: (Type..Type?) defined in org.jetbrains.kotlin.resolve.jvm.AsmTypes[JavaPropertyDescriptor]

'invokeMethod' @ [61:85] ==> public abstract val invokeMethod: Method defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo[PropertyDescriptorImpl]

'descriptor' @ [61:98] ==> public final val Method.descriptor: (String..String?)[MyPropertyDescriptor]

'this' @ [61:110] ==> <this> defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo[LazyClassReceiverParameterDescriptor]

'capturedVars' @ [63:22] ==> public abstract val capturedVars: List<CapturedParamDesc> defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo[PropertyDescriptorImpl]

'remapper' @ [64:25] ==> value-parameter remapper: FieldRemapper defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo.addAllParameters[ValueParameterDescriptorImpl]

'findField' @ [64:34] ==> @JvmOverloads public open fun findField(fieldInsnNode: FieldInsnNode, captured: Collection<CapturedParamInfo> = ...): CapturedParamInfo? defined in org.jetbrains.kotlin.codegen.inline.FieldRemapper[SimpleFunctionDescriptorImpl]

'FieldInsnNode' @ [64:44] ==> public constructor FieldInsnNode(p0: Int, p1: (String..String?), p2: (String..String?), p3: (String..String?)) defined in org.jetbrains.org.objectweb.asm.tree.FieldInsnNode[JavaClassConstructorDescriptor]

'info' @ [64:61] ==> val info: CapturedParamDesc defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo.addAllParameters[LocalVariableDescriptor]

'containingLambdaName' @ [64:66] ==> public final val CapturedParamDesc.containingLambdaName: String[MyPropertyDescriptor]

'info' @ [64:88] ==> val info: CapturedParamDesc defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo.addAllParameters[LocalVariableDescriptor]

'fieldName' @ [64:93] ==> public final val CapturedParamDesc.fieldName: String[MyPropertyDescriptor]

'error' @ [65:25] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'+' @ [65:31] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'info' @ [65:62] ==> val info: CapturedParamDesc defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo.addAllParameters[LocalVariableDescriptor]

'containingLambdaName' @ [65:67] ==> public final val CapturedParamDesc.containingLambdaName: String[MyPropertyDescriptor]

'info' @ [65:96] ==> val info: CapturedParamDesc defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo.addAllParameters[LocalVariableDescriptor]

'fieldName' @ [65:101] ==> public final val CapturedParamDesc.fieldName: String[MyPropertyDescriptor]

'builder' @ [66:13] ==> val builder: ParametersBuilder defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo.addAllParameters[LocalVariableDescriptor]

'addCapturedParam' @ [66:21] ==> public final fun addCapturedParam(original: CapturedParamInfo, newFieldName: String): CapturedParamInfo defined in org.jetbrains.kotlin.codegen.inline.ParametersBuilder[SimpleFunctionDescriptorImpl]

'field' @ [66:38] ==> val field: CapturedParamInfo defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo.addAllParameters[LocalVariableDescriptor]

'info' @ [66:45] ==> val info: CapturedParamDesc defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo.addAllParameters[LocalVariableDescriptor]

'fieldName' @ [66:50] ==> public final val CapturedParamDesc.fieldName: String[MyPropertyDescriptor]

'builder' @ [69:16] ==> val builder: ParametersBuilder defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo.addAllParameters[LocalVariableDescriptor]

'buildParameters' @ [69:24] ==> public final fun buildParameters(): Parameters defined in org.jetbrains.kotlin.codegen.inline.ParametersBuilder[SimpleFunctionDescriptorImpl]

'capturedParamDesc' @ [75:20] ==> public final fun LambdaInfo.capturedParamDesc(fieldName: String, fieldType: Type): CapturedParamDesc defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo.Companion[SimpleFunctionDescriptorImpl]

'descriptor' @ [75:38] ==> value-parameter descriptor: EnclosedValueDescriptor defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo.Companion.getCapturedParamInfo[ValueParameterDescriptorImpl]

'fieldName' @ [75:49] ==> public final val EnclosedValueDescriptor.fieldName: String[MyPropertyDescriptor]

'descriptor' @ [75:60] ==> value-parameter descriptor: EnclosedValueDescriptor defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo.Companion.getCapturedParamInfo[ValueParameterDescriptorImpl]

'type' @ [75:71] ==> public final val EnclosedValueDescriptor.type: Type[MyPropertyDescriptor]

'CapturedParamDesc' @ [79:20] ==> public constructor CapturedParamDesc(@NotNull containingLambdaType: Type, @NotNull fieldName: String, @NotNull type: Type) defined in org.jetbrains.kotlin.codegen.inline.CapturedParamDesc[JavaClassConstructorDescriptor]

'lambdaClassType' @ [79:38] ==> public abstract val lambdaClassType: Type defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo[PropertyDescriptorImpl]

'fieldName' @ [79:55] ==> value-parameter fieldName: String defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo.Companion.capturedParamDesc[ValueParameterDescriptorImpl]

'fieldType' @ [79:66] ==> value-parameter fieldType: Type defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo.Companion.capturedParamDesc[ValueParameterDescriptorImpl]

'LambdaInfo' @ [91:5] ==> public constructor LambdaInfo(isCrossInline: Boolean) defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo[ClassConstructorDescriptorImpl]

'parameterDescriptor' @ [91:16] ==> value-parameter parameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.<init>[ValueParameterDescriptorImpl]

'isCrossinline' @ [91:36] ==> public abstract val isCrossinline: Boolean defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'Delegates' @ [93:46] ==> public object Delegates defined in kotlin.properties[FakeCallableDescriptorForObject]

'notNull' @ [93:56] ==> public final fun <T : Any> notNull(): ReadWriteProperty<Any?, Boolean> defined in kotlin.properties.Delegates[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> Boolean

'arrayListOf' @ [96:55] ==> @SinceKotlin @InlineOnly public inline fun <T> arrayListOf(): ArrayList<Int> /* = ArrayList<Int> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Int

'buildClassReaderByInternalName' @ [112:27] ==> internal fun buildClassReaderByInternalName(state: GenerationState, internalName: String): ClassReader defined in org.jetbrains.kotlin.codegen.inline in file inlineCodegenUtils.kt[SimpleFunctionDescriptorImpl]

'sourceCompiler' @ [112:58] ==> value-parameter sourceCompiler: SourceCompilerForInline defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody[ValueParameterDescriptorImpl]

'state' @ [112:73] ==> public abstract val state: GenerationState defined in org.jetbrains.kotlin.codegen.inline.SourceCompilerForInline[PropertyDescriptorImpl]

'lambdaClassType' @ [112:80] ==> public open val lambdaClassType: Type defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda[PropertyDescriptorImpl]

'internalName' @ [112:96] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'classReader' @ [115:9] ==> val classReader: ClassReader defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody[LocalVariableDescriptor]

'accept' @ [115:21] ==> public open fun accept(p0: (ClassVisitor..ClassVisitor?), p1: Int): Unit defined in org.jetbrains.org.objectweb.asm.ClassReader[JavaMethodDescriptor]

'ClassVisitor' @ [115:36] ==> public constructor ClassVisitor(p0: Int) defined in org.jetbrains.org.objectweb.asm.ClassVisitor[JavaClassConstructorDescriptor]

'API' @ [115:49] ==> public const val API: Int defined in org.jetbrains.kotlin.codegen.inline in file inlineCodegenUtils.kt[PropertyDescriptorImpl]

'isPropertyReference' @ [117:17] ==> var isPropertyReference: Boolean defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody[LocalVariableDescriptor]

'superName' @ [117:39] ==> value-parameter superName: String? defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody.<no name provided>.visit[ValueParameterDescriptorImpl]

'startsWith' @ [117:50] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'isFunctionReference' @ [118:17] ==> var isFunctionReference: Boolean defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody[LocalVariableDescriptor]

'==' @ [118:39] ==> public open fun equals(other: Any?): Boolean defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'superName' @ [118:82] ==> value-parameter superName: String? defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody.<no name provided>.visit[ValueParameterDescriptorImpl]

'super' @ [120:17] ==> <this> defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody.<no name provided>[LazyClassReceiverParameterDescriptor]

'visit' @ [120:23] ==> public open fun visit(p0: Int, p1: Int, p2: (String..String?), p3: (String..String?), p4: (String..String?), p5: (Array<(String..String?)>..Array<out (String..String?)>?)): Unit defined in org.jetbrains.org.objectweb.asm.ClassVisitor[JavaMethodDescriptor]

'version' @ [120:29] ==> value-parameter version: Int defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody.<no name provided>.visit[ValueParameterDescriptorImpl]

'access' @ [120:38] ==> value-parameter access: Int defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody.<no name provided>.visit[ValueParameterDescriptorImpl]

'name' @ [120:46] ==> value-parameter name: String defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody.<no name provided>.visit[ValueParameterDescriptorImpl]

'signature' @ [120:52] ==> value-parameter signature: String? defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody.<no name provided>.visit[ValueParameterDescriptorImpl]

'superName' @ [120:63] ==> value-parameter superName: String? defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody.<no name provided>.visit[ValueParameterDescriptorImpl]

'interfaces' @ [120:74] ==> value-parameter interfaces: Array<out String>? defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody.<no name provided>.visit[ValueParameterDescriptorImpl]

'or' @ [122:12] ==> public final infix fun or(other: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'SKIP_CODE' @ [122:24] ==> public const final val SKIP_CODE: Int defined in org.jetbrains.org.objectweb.asm.ClassReader[JavaPropertyDescriptor]

'SKIP_FRAMES' @ [122:49] ==> public const final val SKIP_FRAMES: Int defined in org.jetbrains.org.objectweb.asm.ClassReader[JavaPropertyDescriptor]

'SKIP_DEBUG' @ [122:76] ==> public const final val SKIP_DEBUG: Int defined in org.jetbrains.org.objectweb.asm.ClassReader[JavaPropertyDescriptor]

'invokeMethodDescriptor' @ [124:9] ==> public open lateinit var invokeMethodDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda[PropertyDescriptorImpl]

'parameterDescriptor' @ [125:17] ==> public final val parameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda[PropertyDescriptorImpl]

'type' @ [125:37] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'memberScope' @ [125:42] ==> public abstract val memberScope: MemberScope defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'getContributedFunctions' @ [126:26] ==> public abstract fun getContributedFunctions(name: Name, location: LookupLocation): Collection<SimpleFunctionDescriptor> defined in org.jetbrains.kotlin.resolve.scopes.MemberScope[DeserializedSimpleFunctionDescriptor]

'OperatorNameConventions' @ [126:50] ==> public object OperatorNameConventions defined in org.jetbrains.kotlin.util[FakeCallableDescriptorForObject]

'INVOKE' @ [126:74] ==> @field:JvmField public final val INVOKE: Name defined in org.jetbrains.kotlin.util.OperatorNameConventions[DeserializedPropertyDescriptor]

'FROM_BACKEND' @ [126:99] ==> enum entry FROM_BACKEND defined in org.jetbrains.kotlin.incremental.components.NoLookupLocation[FakeCallableDescriptorForObject]

'single' @ [127:26] ==> public fun <T> Iterable<SimpleFunctionDescriptor>.single(): SimpleFunctionDescriptor defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SimpleFunctionDescriptor

'let' @ [128:26] ==> @InlineOnly public inline fun <T, R> SimpleFunctionDescriptor.let(block: (SimpleFunctionDescriptor) -> SimpleFunctionDescriptor): SimpleFunctionDescriptor defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SimpleFunctionDescriptor
    <R> -> SimpleFunctionDescriptor

'if (isPropertyReference) it.original else it' @ [130:29] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: SimpleFunctionDescriptor, elseBranch: SimpleFunctionDescriptor): SimpleFunctionDescriptor[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> SimpleFunctionDescriptor

'isPropertyReference' @ [130:33] ==> var isPropertyReference: Boolean defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody[LocalVariableDescriptor]

'it' @ [130:54] ==> value-parameter it: SimpleFunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody.<anonymous>[ValueParameterDescriptorImpl]

'original' @ [130:57] ==> public final val SimpleFunctionDescriptor.original: SimpleFunctionDescriptor[MyPropertyDescriptor]

'it' @ [130:71] ==> value-parameter it: SimpleFunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody.<anonymous>[ValueParameterDescriptorImpl]

'getMethodDescriptor' @ [133:31] ==> public open fun getMethodDescriptor(p0: (Type..Type?), vararg p1: (Type..Type?)): (String..String?) defined in org.jetbrains.org.objectweb.asm.Type[JavaMethodDescriptor]

'VOID_TYPE' @ [133:56] ==> public final val VOID_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'capturedArgs' @ [133:68] ==> private final val capturedArgs: Array<Type> defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda[PropertyDescriptorImpl]

'getMethodNode' @ [134:27] ==> internal fun getMethodNode(classData: ByteArray, methodName: String, methodDescriptor: String, classType: Type): SMAPAndMethodNode? defined in org.jetbrains.kotlin.codegen.inline in file inlineCodegenUtils.kt[SimpleFunctionDescriptorImpl]

'classReader' @ [135:17] ==> val classReader: ClassReader defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody[LocalVariableDescriptor]

'b' @ [135:29] ==> public final val b: (ByteArray..ByteArray?) defined in org.jetbrains.org.objectweb.asm.ClassReader[JavaPropertyDescriptor]

'descriptor' @ [137:17] ==> val descriptor: (String..String?) defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody[LocalVariableDescriptor]

'lambdaClassType' @ [138:17] ==> public open val lambdaClassType: Type defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda[PropertyDescriptorImpl]

'node' @ [138:35] ==> public final val node: MethodNode defined in org.jetbrains.kotlin.codegen.inline.SMAPAndMethodNode[PropertyDescriptorImpl]

'assert' @ [140:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'constructor' @ [140:16] ==> val constructor: MethodNode? defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody[LocalVariableDescriptor]

'capturedArgs' @ [140:39] ==> private final val capturedArgs: Array<Type> defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda[PropertyDescriptorImpl]

'isEmpty' @ [140:52] ==> @InlineOnly public inline fun <T> Array<out Type>.isEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Type

'descriptor' @ [141:56] ==> val descriptor: (String..String?) defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody[LocalVariableDescriptor]

'lambdaClassType' @ [141:87] ==> public open val lambdaClassType: Type defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda[PropertyDescriptorImpl]

'capturedVars' @ [144:9] ==> public open lateinit var capturedVars: List<CapturedParamDesc> defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda[PropertyDescriptorImpl]

'if (isFunctionReference || isPropertyReference)
                    constructor?.desc?.let { Type.getArgumentTypes(it) }?.singleOrNull()?.let {
                        originalBoundReceiverType = it
                        listOf(capturedParamDesc(AsmUtil.RECEIVER_NAME, it.boxReceiverForBoundReference()))
                    } ?: emptyList()
                else
                    constructor?.findCapturedFieldAssignmentInstructions()?.map {
                        fieldNode ->
                        capturedParamDesc(fieldNode.name, Type.getType(fieldNode.desc))
                    }?.toList() ?: emptyList()' @ [145:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<CapturedParamDesc>, elseBranch: List<CapturedParamDesc>): List<CapturedParamDesc>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<CapturedParamDesc>

'isFunctionReference' @ [145:21] ==> var isFunctionReference: Boolean defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody[LocalVariableDescriptor]

'isPropertyReference' @ [145:44] ==> var isPropertyReference: Boolean defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody[LocalVariableDescriptor]

'constructor' @ [146:21] ==> val constructor: MethodNode? defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody[LocalVariableDescriptor]

'desc' @ [146:34] ==> public final var desc: (String..String?) defined in org.jetbrains.org.objectweb.asm.tree.MethodNode[JavaPropertyDescriptor]

'let' @ [146:40] ==> @InlineOnly public inline fun <T, R> String.let(block: (String) -> (Array<(Type..Type?)>..Array<out (Type..Type?)>?)): (Array<(Type..Type?)>..Array<out (Type..Type?)>?) defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String
    <R> -> (kotlin.Array<(org.jetbrains.org.objectweb.asm.Type..org.jetbrains.org.objectweb.asm.Type?)>..kotlin.Array<out (org.jetbrains.org.objectweb.asm.Type..org.jetbrains.org.objectweb.asm.Type?)>?)

'getArgumentTypes' @ [146:51] ==> public open fun getArgumentTypes(p0: (String..String?)): (Array<(Type..Type?)>..Array<out (Type..Type?)>?) defined in org.jetbrains.org.objectweb.asm.Type[JavaMethodDescriptor]

'it' @ [146:68] ==> value-parameter it: String defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody.<anonymous>[ValueParameterDescriptorImpl]

'singleOrNull' @ [146:75] ==> public fun <T> Array<out (Type..Type?)>.singleOrNull(): Type? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.org.objectweb.asm.Type..org.jetbrains.org.objectweb.asm.Type?)

'let' @ [146:91] ==> @InlineOnly public inline fun <T, R> Type.let(block: (Type) -> List<CapturedParamDesc>): List<CapturedParamDesc> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Type
    <R> -> List<CapturedParamDesc>

'originalBoundReceiverType' @ [147:25] ==> public final var originalBoundReceiverType: Type? defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda[PropertyDescriptorImpl]

'it' @ [147:53] ==> value-parameter it: Type defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody.<anonymous>[ValueParameterDescriptorImpl]

'listOf' @ [148:25] ==> public fun <T> listOf(element: CapturedParamDesc): List<CapturedParamDesc> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> CapturedParamDesc

'capturedParamDesc' @ [148:32] ==> public final fun LambdaInfo.capturedParamDesc(fieldName: String, fieldType: Type): CapturedParamDesc defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo.Companion[SimpleFunctionDescriptorImpl]

'RECEIVER_NAME' @ [148:58] ==> public const final val RECEIVER_NAME: String defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaPropertyDescriptor]

'it' @ [148:73] ==> value-parameter it: Type defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody.<anonymous>[ValueParameterDescriptorImpl]

'boxReceiverForBoundReference' @ [148:76] ==> public fun Type.boxReceiverForBoundReference(): Type defined in org.jetbrains.kotlin.codegen.inline[SimpleFunctionDescriptorImpl]

'emptyList' @ [149:26] ==> public fun <T> emptyList(): List<CapturedParamDesc> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> CapturedParamDesc

'constructor' @ [151:21] ==> val constructor: MethodNode? defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody[LocalVariableDescriptor]

'findCapturedFieldAssignmentInstructions' @ [151:34] ==> public fun MethodNode.findCapturedFieldAssignmentInstructions(): Sequence<FieldInsnNode> defined in org.jetbrains.kotlin.codegen.inline[SimpleFunctionDescriptorImpl]

'map' @ [151:77] ==> public fun <T, R> Sequence<FieldInsnNode>.map(transform: (FieldInsnNode) -> CapturedParamDesc): Sequence<CapturedParamDesc> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FieldInsnNode
    <R> -> CapturedParamDesc

'capturedParamDesc' @ [153:25] ==> public final fun LambdaInfo.capturedParamDesc(fieldName: String, fieldType: Type): CapturedParamDesc defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo.Companion[SimpleFunctionDescriptorImpl]

'fieldNode' @ [153:43] ==> value-parameter fieldNode: FieldInsnNode defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [153:53] ==> public final var name: (String..String?) defined in org.jetbrains.org.objectweb.asm.tree.FieldInsnNode[JavaPropertyDescriptor]

'getType' @ [153:64] ==> public open fun getType(p0: (String..String?)): (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaMethodDescriptor]

'fieldNode' @ [153:72] ==> value-parameter fieldNode: FieldInsnNode defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody.<anonymous>[ValueParameterDescriptorImpl]

'desc' @ [153:82] ==> public final var desc: (String..String?) defined in org.jetbrains.org.objectweb.asm.tree.FieldInsnNode[JavaPropertyDescriptor]

'toList' @ [154:24] ==> public fun <T> Sequence<CapturedParamDesc>.toList(): List<CapturedParamDesc> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> CapturedParamDesc

'emptyList' @ [154:36] ==> public fun <T> emptyList(): List<CapturedParamDesc> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> CapturedParamDesc

'isBoundCallableReference' @ [156:9] ==> public open var isBoundCallableReference: Boolean defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda[PropertyDescriptorImpl]

'isFunctionReference' @ [156:37] ==> var isFunctionReference: Boolean defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody[LocalVariableDescriptor]

'isPropertyReference' @ [156:60] ==> var isPropertyReference: Boolean defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody[LocalVariableDescriptor]

'capturedVars' @ [156:84] ==> public open lateinit var capturedVars: List<CapturedParamDesc> defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda[PropertyDescriptorImpl]

'isNotEmpty' @ [156:97] ==> @InlineOnly public inline fun <T> Collection<CapturedParamDesc>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> CapturedParamDesc

'invokeMethod' @ [158:9] ==> public open lateinit var invokeMethod: Method defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda[PropertyDescriptorImpl]

'Method' @ [158:24] ==> public constructor Method(p0: (String..String?), p1: (String..String?)) defined in org.jetbrains.org.objectweb.asm.commons.Method[JavaClassConstructorDescriptor]

'if (isPropertyReference) OperatorNameConventions.GET else OperatorNameConventions.INVOKE' @ [159:18] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Name, elseBranch: Name): Name[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Name

'isPropertyReference' @ [159:22] ==> var isPropertyReference: Boolean defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody[LocalVariableDescriptor]

'OperatorNameConventions' @ [159:43] ==> public object OperatorNameConventions defined in org.jetbrains.kotlin.util[FakeCallableDescriptorForObject]

'GET' @ [159:67] ==> @field:JvmField public final val GET: Name defined in org.jetbrains.kotlin.util.OperatorNameConventions[DeserializedPropertyDescriptor]

'OperatorNameConventions' @ [159:76] ==> public object OperatorNameConventions defined in org.jetbrains.kotlin.util[FakeCallableDescriptorForObject]

'INVOKE' @ [159:100] ==> @field:JvmField public final val INVOKE: Name defined in org.jetbrains.kotlin.util.OperatorNameConventions[DeserializedPropertyDescriptor]

'asString' @ [159:108] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'sourceCompiler' @ [160:17] ==> value-parameter sourceCompiler: SourceCompilerForInline defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody[ValueParameterDescriptorImpl]

'state' @ [160:32] ==> public abstract val state: GenerationState defined in org.jetbrains.kotlin.codegen.inline.SourceCompilerForInline[PropertyDescriptorImpl]

'typeMapper' @ [160:38] ==> public final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.state.GenerationState[PropertyDescriptorImpl]

'mapSignatureSkipGeneric' @ [160:49] ==> @NotNull public open fun mapSignatureSkipGeneric(@NotNull f: FunctionDescriptor): JvmMethodSignature defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'invokeMethodDescriptor' @ [160:73] ==> public open lateinit var invokeMethodDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda[PropertyDescriptorImpl]

'asmMethod' @ [160:97] ==> public final val JvmMethodSignature.asmMethod: Method[MyPropertyDescriptor]

'descriptor' @ [160:107] ==> public final val Method.descriptor: (String..String?)[MyPropertyDescriptor]

'node' @ [163:9] ==> public final lateinit var node: SMAPAndMethodNode defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda[PropertyDescriptorImpl]

'getMethodNode' @ [163:16] ==> internal fun getMethodNode(classData: ByteArray, methodName: String, methodDescriptor: String, classType: Type): SMAPAndMethodNode? defined in org.jetbrains.kotlin.codegen.inline in file inlineCodegenUtils.kt[SimpleFunctionDescriptorImpl]

'classReader' @ [164:17] ==> val classReader: ClassReader defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody[LocalVariableDescriptor]

'b' @ [164:29] ==> public final val b: (ByteArray..ByteArray?) defined in org.jetbrains.org.objectweb.asm.ClassReader[JavaPropertyDescriptor]

'invokeMethod' @ [165:17] ==> public open lateinit var invokeMethod: Method defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda[PropertyDescriptorImpl]

'name' @ [165:30] ==> public final val Method.name: (String..String?)[MyPropertyDescriptor]

'invokeMethod' @ [166:17] ==> public open lateinit var invokeMethod: Method defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda[PropertyDescriptorImpl]

'descriptor' @ [166:30] ==> public final val Method.descriptor: (String..String?)[MyPropertyDescriptor]

'lambdaClassType' @ [167:17] ==> public open val lambdaClassType: Type defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda[PropertyDescriptorImpl]

'needReification' @ [169:13] ==> public final val needReification: Boolean defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda[PropertyDescriptorImpl]

'reifiedTypeInliner' @ [171:13] ==> value-parameter reifiedTypeInliner: ReifiedTypeInliner defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda.generateLambdaBody[ValueParameterDescriptorImpl]

'reifyInstructions' @ [171:32] ==> public final fun reifyInstructions(node: MethodNode): ReifiedTypeParametersUsages defined in org.jetbrains.kotlin.codegen.inline.ReifiedTypeInliner[SimpleFunctionDescriptorImpl]

'node' @ [171:50] ==> public final lateinit var node: SMAPAndMethodNode defined in org.jetbrains.kotlin.codegen.inline.DefaultLambda[PropertyDescriptorImpl]

'node' @ [171:55] ==> public final val node: MethodNode defined in org.jetbrains.kotlin.codegen.inline.SMAPAndMethodNode[PropertyDescriptorImpl]

'boxType' @ [176:51] ==> @NotNull public open fun boxType(@NotNull type: Type): Type defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaMethodDescriptor]

'this' @ [176:59] ==> <this> defined in org.jetbrains.kotlin.codegen.inline.boxReceiverForBoundReference[ReceiverParameterDescriptorImpl]

'LambdaInfo' @ [184:5] ==> public constructor LambdaInfo(isCrossInline: Boolean) defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo[ClassConstructorDescriptorImpl]

'isCrossInline' @ [184:16] ==> value-parameter isCrossInline: Boolean defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>[ValueParameterDescriptorImpl]

'?:' @ [196:61] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtExpression?, right: KtExpression): KtExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtExpression

'expression' @ [196:62] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>[ValueParameterDescriptorImpl]

'functionLiteral' @ [196:98] ==> public final val KtLambdaExpression.functionLiteral: KtFunctionLiteral[MyPropertyDescriptor]

'expression' @ [196:117] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>[ValueParameterDescriptorImpl]

'typeMapper' @ [203:30] ==> private final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'bindingContext' @ [203:41] ==> public final val KotlinTypeMapper.bindingContext: BindingContext[MyPropertyDescriptor]

'bindingContext' @ [204:24] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>[LocalVariableDescriptor]

'get' @ [204:39] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(p0: (ReadOnlySlice<(PsiElement..PsiElement?), (SimpleFunctionDescriptor..SimpleFunctionDescriptor?)>..ReadOnlySlice<(PsiElement..PsiElement?), (SimpleFunctionDescriptor..SimpleFunctionDescriptor?)>?), p1: (PsiElement..PsiElement?)): SimpleFunctionDescriptor? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> PsiElement
    <V : (Any..Any?)> -> SimpleFunctionDescriptor

'FUNCTION' @ [204:96] ==> public final val FUNCTION: (WritableSlice<(PsiElement..PsiElement?), (SimpleFunctionDescriptor..SimpleFunctionDescriptor?)>..WritableSlice<(PsiElement..PsiElement?), (SimpleFunctionDescriptor..SimpleFunctionDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'functionWithBodyOrCallableReference' @ [204:106] ==> public final val functionWithBodyOrCallableReference: KtExpression defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'if (function == null && expression is KtCallableReferenceExpression) {
            val variableDescriptor =
                    bindingContext.get(BindingContext.VARIABLE, functionWithBodyOrCallableReference) as? VariableDescriptorWithAccessors ?:
                    throw AssertionError("""Reference expression not resolved to variable descriptor with accessors: ${expression.getText()}""")
            classDescriptor = CodegenBinding.anonymousClassForCallable(bindingContext, variableDescriptor)
            lambdaClassType = typeMapper.mapClass(classDescriptor)
            val getFunction = PropertyReferenceCodegen.findGetFunction(variableDescriptor)
            invokeMethodDescriptor = PropertyReferenceCodegen.createFakeOpenDescriptor(getFunction, classDescriptor)
            val resolvedCall = expression.callableReference.getResolvedCallWithAssert(bindingContext)
            propertyReferenceInfo = PropertyReferenceInfo(
                    resolvedCall.resultingDescriptor as VariableDescriptor, getFunction
            )
        }
        else {
            propertyReferenceInfo = null
            invokeMethodDescriptor = function ?: throw AssertionError("Function is not resolved to descriptor: " + expression.text)
            classDescriptor = anonymousClassForCallable(bindingContext, invokeMethodDescriptor)
            lambdaClassType = asmTypeForAnonymousClass(bindingContext, invokeMethodDescriptor)
        }' @ [205:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'function' @ [205:13] ==> val function: SimpleFunctionDescriptor? defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>[LocalVariableDescriptor]

'expression' @ [205:33] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>[ValueParameterDescriptorImpl]

'bindingContext' @ [207:21] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>[LocalVariableDescriptor]

'get' @ [207:36] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(p0: (ReadOnlySlice<(PsiElement..PsiElement?), (VariableDescriptor..VariableDescriptor?)>..ReadOnlySlice<(PsiElement..PsiElement?), (VariableDescriptor..VariableDescriptor?)>?), p1: (PsiElement..PsiElement?)): VariableDescriptor? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> PsiElement
    <V : (Any..Any?)> -> VariableDescriptor

'VARIABLE' @ [207:55] ==> public final val VARIABLE: (WritableSlice<(PsiElement..PsiElement?), (VariableDescriptor..VariableDescriptor?)>..WritableSlice<(PsiElement..PsiElement?), (VariableDescriptor..VariableDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'functionWithBodyOrCallableReference' @ [207:65] ==> public final val functionWithBodyOrCallableReference: KtExpression defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'AssertionError' @ [208:27] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'expression' @ [208:120] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>[ValueParameterDescriptorImpl]

'getText' @ [208:131] ==> @NonNls @Contract public abstract fun getText(): (String..String?) defined in org.jetbrains.kotlin.psi.KtExpression[JavaMethodDescriptor]

'classDescriptor' @ [209:13] ==> public final val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'anonymousClassForCallable' @ [209:46] ==> @NotNull public open fun anonymousClassForCallable(@NotNull bindingContext: BindingContext, @NotNull descriptor: CallableDescriptor): ClassDescriptor defined in org.jetbrains.kotlin.codegen.binding.CodegenBinding[JavaMethodDescriptor]

'bindingContext' @ [209:72] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>[LocalVariableDescriptor]

'variableDescriptor' @ [209:88] ==> val variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>[LocalVariableDescriptor]

'lambdaClassType' @ [210:13] ==> public open val lambdaClassType: Type defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'typeMapper' @ [210:31] ==> private final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'mapClass' @ [210:42] ==> @NotNull public open fun mapClass(@NotNull classifier: ClassifierDescriptor): Type defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'classDescriptor' @ [210:51] ==> public final val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'PropertyReferenceCodegen' @ [211:31] ==> public companion object defined in org.jetbrains.kotlin.codegen.PropertyReferenceCodegen[FakeCallableDescriptorForObject]

'findGetFunction' @ [211:56] ==> @JvmStatic public final fun findGetFunction(localVariableDescriptorForReference: VariableDescriptor): SimpleFunctionDescriptor defined in org.jetbrains.kotlin.codegen.PropertyReferenceCodegen.Companion[SimpleFunctionDescriptorImpl]

'variableDescriptor' @ [211:72] ==> val variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>[LocalVariableDescriptor]

'invokeMethodDescriptor' @ [212:13] ==> public open val invokeMethodDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'PropertyReferenceCodegen' @ [212:38] ==> public companion object defined in org.jetbrains.kotlin.codegen.PropertyReferenceCodegen[FakeCallableDescriptorForObject]

'createFakeOpenDescriptor' @ [212:63] ==> @JvmStatic public final fun createFakeOpenDescriptor(getFunction: FunctionDescriptor, classDescriptor: ClassDescriptor): FunctionDescriptor defined in org.jetbrains.kotlin.codegen.PropertyReferenceCodegen.Companion[SimpleFunctionDescriptorImpl]

'getFunction' @ [212:88] ==> val getFunction: SimpleFunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>[LocalVariableDescriptor]

'classDescriptor' @ [212:101] ==> public final val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'expression' @ [213:32] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>[ValueParameterDescriptorImpl]

'callableReference' @ [213:43] ==> public final val KtCallableReferenceExpression.callableReference: KtSimpleNameExpression[MyPropertyDescriptor]

'getResolvedCallWithAssert' @ [213:61] ==> public fun KtElement.getResolvedCallWithAssert(context: BindingContext): ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [213:87] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>[LocalVariableDescriptor]

'propertyReferenceInfo' @ [214:13] ==> public final val propertyReferenceInfo: PropertyReferenceInfo? defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'PropertyReferenceInfo' @ [214:37] ==> public constructor PropertyReferenceInfo(target: VariableDescriptor, getFunction: FunctionDescriptor) defined in org.jetbrains.kotlin.codegen.inline.PropertyReferenceInfo[ClassConstructorDescriptorImpl]

'resolvedCall' @ [215:21] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>[LocalVariableDescriptor]

'resultingDescriptor' @ [215:34] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.resultingDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'getFunction' @ [215:77] ==> val getFunction: SimpleFunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>[LocalVariableDescriptor]

'propertyReferenceInfo' @ [219:13] ==> public final val propertyReferenceInfo: PropertyReferenceInfo? defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'invokeMethodDescriptor' @ [220:13] ==> public open val invokeMethodDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'function' @ [220:38] ==> val function: SimpleFunctionDescriptor? defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>[LocalVariableDescriptor]

'AssertionError' @ [220:56] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'+' @ [220:71] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'expression' @ [220:116] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>[ValueParameterDescriptorImpl]

'text' @ [220:127] ==> public final val KtExpression.text: (String..String?)[MyPropertyDescriptor]

'classDescriptor' @ [221:13] ==> public final val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'anonymousClassForCallable' @ [221:31] ==> @NotNull public open fun anonymousClassForCallable(@NotNull bindingContext: BindingContext, @NotNull descriptor: CallableDescriptor): ClassDescriptor defined in org.jetbrains.kotlin.codegen.binding.CodegenBinding[JavaMethodDescriptor]

'bindingContext' @ [221:57] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>[LocalVariableDescriptor]

'invokeMethodDescriptor' @ [221:73] ==> public open val invokeMethodDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'lambdaClassType' @ [222:13] ==> public open val lambdaClassType: Type defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'asmTypeForAnonymousClass' @ [222:31] ==> @NotNull public open fun asmTypeForAnonymousClass(@NotNull bindingContext: BindingContext, @NotNull descriptor: CallableDescriptor): Type defined in org.jetbrains.kotlin.codegen.binding.CodegenBinding[JavaMethodDescriptor]

'bindingContext' @ [222:56] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>[LocalVariableDescriptor]

'invokeMethodDescriptor' @ [222:72] ==> public open val invokeMethodDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'bindingContext' @ [225:9] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>[LocalVariableDescriptor]

'get' @ [225:24] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(p0: (ReadOnlySlice<(ClassDescriptor..ClassDescriptor?), (MutableClosure..MutableClosure?)>..ReadOnlySlice<(ClassDescriptor..ClassDescriptor?), (MutableClosure..MutableClosure?)>?), p1: (ClassDescriptor..ClassDescriptor?)): MutableClosure? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> ClassDescriptor
    <V : (Any..Any?)> -> MutableClosure

'CLOSURE' @ [225:61] ==> public final val CLOSURE: (WritableSlice<(ClassDescriptor..ClassDescriptor?), (MutableClosure..MutableClosure?)>..WritableSlice<(ClassDescriptor..ClassDescriptor?), (MutableClosure..MutableClosure?)>?) defined in org.jetbrains.kotlin.codegen.binding.CodegenBinding[JavaPropertyDescriptor]

'classDescriptor' @ [225:70] ==> public final val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'let' @ [225:87] ==> @InlineOnly public inline fun <T, R> MutableClosure?.let(block: (MutableClosure?) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> MutableClosure?
    <R> -> Unit

'assert' @ [226:13] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'it' @ [226:20] ==> value-parameter it: MutableClosure? defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>.<anonymous>[ValueParameterDescriptorImpl]

'+' @ [226:34] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'expression' @ [226:77] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>[ValueParameterDescriptorImpl]

'text' @ [226:88] ==> public final val KtExpression.text: (String..String?)[MyPropertyDescriptor]

'closure' @ [227:13] ==> private final lateinit var closure: CalculatedClosure defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'it' @ [227:23] ==> value-parameter it: MutableClosure? defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>.<anonymous>[ValueParameterDescriptorImpl]

'labels' @ [230:9] ==> private final val labels: Set<String> defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'InlineCodegen' @ [230:18] ==> public companion object defined in org.jetbrains.kotlin.codegen.inline.InlineCodegen[FakeCallableDescriptorForObject]

'getDeclarationLabels' @ [230:32] ==> public final fun getDeclarationLabels(lambdaOrFun: PsiElement?, descriptor: DeclarationDescriptor): Set<String> defined in org.jetbrains.kotlin.codegen.inline.InlineCodegen.Companion[SimpleFunctionDescriptorImpl]

'expression' @ [230:53] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.<init>[ValueParameterDescriptorImpl]

'invokeMethodDescriptor' @ [230:65] ==> public open val invokeMethodDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'invokeMethod' @ [231:9] ==> public open val invokeMethod: Method defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'typeMapper' @ [231:24] ==> private final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'mapAsmMethod' @ [231:35] ==> @NotNull public open fun mapAsmMethod(@NotNull descriptor: FunctionDescriptor): Method defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'invokeMethodDescriptor' @ [231:48] ==> public open val invokeMethodDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'lazy' @ [234:59] ==> public fun <T> lazy(initializer: () -> ArrayList<CapturedParamDesc> /* = ArrayList<CapturedParamDesc> */): Lazy<ArrayList<CapturedParamDesc> /* = ArrayList<CapturedParamDesc> */> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ArrayList<CapturedParamDesc>

'arrayListOf' @ [235:9] ==> @SinceKotlin @InlineOnly public inline fun <T> arrayListOf(): ArrayList<CapturedParamDesc> /* = ArrayList<CapturedParamDesc> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> CapturedParamDesc

'apply' @ [235:42] ==> @InlineOnly public inline fun <T> ArrayList<CapturedParamDesc> /* = ArrayList<CapturedParamDesc> */.apply(block: ArrayList<CapturedParamDesc> /* = ArrayList<CapturedParamDesc> */.() -> Unit): ArrayList<CapturedParamDesc> /* = ArrayList<CapturedParamDesc> */ defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ArrayList<CapturedParamDesc>

'closure' @ [236:17] ==> private final lateinit var closure: CalculatedClosure defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'captureThis' @ [236:25] ==> public final val CalculatedClosure.captureThis: ClassDescriptor?[MyPropertyDescriptor]

'typeMapper' @ [237:28] ==> private final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'mapType' @ [237:39] ==> @NotNull public open fun mapType(@NotNull descriptor: ClassifierDescriptor): Type defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'closure' @ [237:47] ==> private final lateinit var closure: CalculatedClosure defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'captureThis' @ [237:55] ==> public final val CalculatedClosure.captureThis: ClassDescriptor?[MyPropertyDescriptor]

'EnclosedValueDescriptor' @ [238:34] ==> public constructor EnclosedValueDescriptor(@NotNull fieldName: String, @Nullable descriptor: DeclarationDescriptor?, @NotNull innerValue: StackValue.StackValueWithSimpleReceiver, @NotNull type: Type) defined in org.jetbrains.kotlin.codegen.context.EnclosedValueDescriptor[JavaClassConstructorDescriptor]

'CAPTURED_THIS_FIELD' @ [239:33] ==> public const final val CAPTURED_THIS_FIELD: String defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaPropertyDescriptor]

'field' @ [240:36] ==> @NotNull public open fun field(@NotNull type: Type, @NotNull owner: Type, @NotNull name: String, isStatic: Boolean, @NotNull receiver: StackValue): StackValue.Field defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'type' @ [240:42] ==> val type: Type defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.capturedVars.<anonymous>.<anonymous>[LocalVariableDescriptor]

'lambdaClassType' @ [240:48] ==> public open val lambdaClassType: Type defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'CAPTURED_THIS_FIELD' @ [240:73] ==> public const final val CAPTURED_THIS_FIELD: String defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaPropertyDescriptor]

'LOCAL_0' @ [240:112] ==> public final val LOCAL_0: (StackValue.Local..StackValue.Local?) defined in org.jetbrains.kotlin.codegen.StackValue[JavaPropertyDescriptor]

'type' @ [241:25] ==> val type: Type defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.capturedVars.<anonymous>.<anonymous>[LocalVariableDescriptor]

'add' @ [243:17] ==> public open fun add(element: CapturedParamDesc): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'getCapturedParamInfo' @ [243:21] ==> public final fun LambdaInfo.getCapturedParamInfo(descriptor: EnclosedValueDescriptor): CapturedParamDesc defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo.Companion[SimpleFunctionDescriptorImpl]

'descriptor' @ [243:42] ==> val descriptor: EnclosedValueDescriptor defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.capturedVars.<anonymous>.<anonymous>[LocalVariableDescriptor]

'closure' @ [246:17] ==> private final lateinit var closure: CalculatedClosure defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'captureReceiverType' @ [246:25] ==> public final val CalculatedClosure.captureReceiverType: KotlinType?[MyPropertyDescriptor]

'typeMapper' @ [247:28] ==> private final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'mapType' @ [247:39] ==> @NotNull public open fun mapType(@NotNull jetType: KotlinType): Type defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'closure' @ [247:47] ==> private final lateinit var closure: CalculatedClosure defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'captureReceiverType' @ [247:55] ==> public final val CalculatedClosure.captureReceiverType: KotlinType?[MyPropertyDescriptor]

'let' @ [247:78] ==> @InlineOnly public inline fun <T, R> Type.let(block: (Type) -> Type): Type defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Type
    <R> -> Type

'if (isBoundCallableReference) it.boxReceiverForBoundReference() else it' @ [248:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Type, elseBranch: Type): Type[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Type

'isBoundCallableReference' @ [248:25] ==> public open val isBoundCallableReference: Boolean defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'it' @ [248:51] ==> value-parameter it: Type defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.capturedVars.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'boxReceiverForBoundReference' @ [248:54] ==> public fun Type.boxReceiverForBoundReference(): Type defined in org.jetbrains.kotlin.codegen.inline[SimpleFunctionDescriptorImpl]

'it' @ [248:90] ==> value-parameter it: Type defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.capturedVars.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'EnclosedValueDescriptor' @ [250:34] ==> public constructor EnclosedValueDescriptor(@NotNull fieldName: String, @Nullable descriptor: DeclarationDescriptor?, @NotNull innerValue: StackValue.StackValueWithSimpleReceiver, @NotNull type: Type) defined in org.jetbrains.kotlin.codegen.context.EnclosedValueDescriptor[JavaClassConstructorDescriptor]

'CAPTURED_RECEIVER_FIELD' @ [251:33] ==> public const final val CAPTURED_RECEIVER_FIELD: String defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaPropertyDescriptor]

'field' @ [252:36] ==> @NotNull public open fun field(@NotNull type: Type, @NotNull owner: Type, @NotNull name: String, isStatic: Boolean, @NotNull receiver: StackValue): StackValue.Field defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'type' @ [252:42] ==> val type: Type defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.capturedVars.<anonymous>.<anonymous>[LocalVariableDescriptor]

'lambdaClassType' @ [252:48] ==> public open val lambdaClassType: Type defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'CAPTURED_RECEIVER_FIELD' @ [252:73] ==> public const final val CAPTURED_RECEIVER_FIELD: String defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaPropertyDescriptor]

'LOCAL_0' @ [252:116] ==> public final val LOCAL_0: (StackValue.Local..StackValue.Local?) defined in org.jetbrains.kotlin.codegen.StackValue[JavaPropertyDescriptor]

'type' @ [253:25] ==> val type: Type defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.capturedVars.<anonymous>.<anonymous>[LocalVariableDescriptor]

'add' @ [255:17] ==> public open fun add(element: CapturedParamDesc): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'getCapturedParamInfo' @ [255:21] ==> public final fun LambdaInfo.getCapturedParamInfo(descriptor: EnclosedValueDescriptor): CapturedParamDesc defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo.Companion[SimpleFunctionDescriptorImpl]

'descriptor' @ [255:42] ==> val descriptor: EnclosedValueDescriptor defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.capturedVars.<anonymous>.<anonymous>[LocalVariableDescriptor]

'closure' @ [258:13] ==> private final lateinit var closure: CalculatedClosure defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'captureVariables' @ [258:21] ==> public final val CalculatedClosure.captureVariables: (MutableMap<(DeclarationDescriptor..DeclarationDescriptor?), (EnclosedValueDescriptor..EnclosedValueDescriptor?)>..Map<(DeclarationDescriptor..DeclarationDescriptor?), (EnclosedValueDescriptor..EnclosedValueDescriptor?)>)[MyPropertyDescriptor]

'values' @ [258:38] ==> public abstract val values: MutableCollection<(EnclosedValueDescriptor..EnclosedValueDescriptor?)> defined in kotlin.collections.MutableMap[DeserializedPropertyDescriptor]

'forEach' @ [258:45] ==> @HidesMembers public inline fun <T> Iterable<(EnclosedValueDescriptor..EnclosedValueDescriptor?)>.forEach(action: ((EnclosedValueDescriptor..EnclosedValueDescriptor?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.codegen.context.EnclosedValueDescriptor..org.jetbrains.kotlin.codegen.context.EnclosedValueDescriptor?)

'add' @ [260:17] ==> public open fun add(element: CapturedParamDesc): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'getCapturedParamInfo' @ [260:21] ==> public final fun LambdaInfo.getCapturedParamInfo(descriptor: EnclosedValueDescriptor): CapturedParamDesc defined in org.jetbrains.kotlin.codegen.inline.LambdaInfo.Companion[SimpleFunctionDescriptorImpl]

'descriptor' @ [260:42] ==> value-parameter descriptor: (EnclosedValueDescriptor..EnclosedValueDescriptor?) defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.capturedVars.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'labels' @ [266:16] ==> private final val labels: Set<String> defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'contains' @ [266:23] ==> public abstract fun contains(element: String): Boolean defined in kotlin.collections.Set[DeserializedSimpleFunctionDescriptor]

'name' @ [266:32] ==> value-parameter name: String defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.isMyLabel[ValueParameterDescriptorImpl]

'propertyReferenceInfo' @ [270:17] ==> public final val propertyReferenceInfo: PropertyReferenceInfo? defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'typeMapper' @ [273:34] ==> private final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'mapSignatureSkipGeneric' @ [273:45] ==> @NotNull public open fun mapSignatureSkipGeneric(@NotNull f: FunctionDescriptor): JvmMethodSignature defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'invokeMethodDescriptor' @ [273:69] ==> public open val invokeMethodDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'jvmMethodSignature' @ [274:25] ==> val jvmMethodSignature: JvmMethodSignature defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.generateLambdaBody[LocalVariableDescriptor]

'asmMethod' @ [274:44] ==> public final val JvmMethodSignature.asmMethod: Method[MyPropertyDescriptor]

'MethodNode' @ [275:26] ==> public constructor MethodNode(p0: Int, p1: Int, p2: (String..String?), p3: (String..String?), p4: (String..String?), p5: (Array<(String..String?)>..Array<out (String..String?)>?)) defined in org.jetbrains.org.objectweb.asm.tree.MethodNode[JavaClassConstructorDescriptor]

'API' @ [276:17] ==> public const val API: Int defined in org.jetbrains.kotlin.codegen.inline in file inlineCodegenUtils.kt[PropertyDescriptorImpl]

'getMethodAsmFlags' @ [276:30] ==> public open fun getMethodAsmFlags(functionDescriptor: (FunctionDescriptor..FunctionDescriptor?), kind: (OwnerKind..OwnerKind?), state: (GenerationState..GenerationState?)): Int defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaMethodDescriptor]

'invokeMethodDescriptor' @ [276:48] ==> public open val invokeMethodDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'OwnerKind' @ [276:72] ==> public companion object defined in org.jetbrains.kotlin.codegen.OwnerKind[FakeCallableDescriptorForObject]

'IMPLEMENTATION' @ [276:82] ==> enum entry IMPLEMENTATION defined in org.jetbrains.kotlin.codegen.OwnerKind[FakeCallableDescriptorForObject]

'sourceCompiler' @ [276:98] ==> value-parameter sourceCompiler: SourceCompilerForInline defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.generateLambdaBody[ValueParameterDescriptorImpl]

'state' @ [276:113] ==> public abstract val state: GenerationState defined in org.jetbrains.kotlin.codegen.inline.SourceCompilerForInline[PropertyDescriptorImpl]

'asmMethod' @ [277:17] ==> val asmMethod: Method defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.generateLambdaBody[LocalVariableDescriptor]

'name' @ [277:27] ==> public final val Method.name: (String..String?)[MyPropertyDescriptor]

'asmMethod' @ [277:33] ==> val asmMethod: Method defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.generateLambdaBody[LocalVariableDescriptor]

'descriptor' @ [277:43] ==> public final val Method.descriptor: (String..String?)[MyPropertyDescriptor]

'node' @ [280:9] ==> public final lateinit var node: SMAPAndMethodNode defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'wrapWithMaxLocalCalc' @ [280:16] ==> public fun wrapWithMaxLocalCalc(methodNode: MethodNode): MethodVisitor defined in org.jetbrains.kotlin.codegen.inline in file inlineCodegenUtils.kt[SimpleFunctionDescriptorImpl]

'methodNode' @ [280:37] ==> val methodNode: MethodNode defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.generateLambdaBody[LocalVariableDescriptor]

'let' @ [280:49] ==> @InlineOnly public inline fun <T, R> MethodVisitor.let(block: (MethodVisitor) -> SMAPAndMethodNode): SMAPAndMethodNode defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> MethodVisitor
    <R> -> SMAPAndMethodNode

'sourceCompiler' @ [281:24] ==> value-parameter sourceCompiler: SourceCompilerForInline defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.generateLambdaBody[ValueParameterDescriptorImpl]

'generateLambdaBody' @ [281:39] ==> public abstract fun generateLambdaBody(adapter: MethodVisitor, jvmMethodSignature: JvmMethodSignature, lambdaInfo: ExpressionLambda): SMAP defined in org.jetbrains.kotlin.codegen.inline.SourceCompilerForInline[SimpleFunctionDescriptorImpl]

'adapter' @ [282:21] ==> value-parameter adapter: MethodVisitor defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.generateLambdaBody.<anonymous>[ValueParameterDescriptorImpl]

'jvmMethodSignature' @ [282:30] ==> val jvmMethodSignature: JvmMethodSignature defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.generateLambdaBody[LocalVariableDescriptor]

'this' @ [282:50] ==> <this> defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[LazyClassReceiverParameterDescriptor]

'adapter' @ [284:13] ==> value-parameter adapter: MethodVisitor defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.generateLambdaBody.<anonymous>[ValueParameterDescriptorImpl]

'visitMaxs' @ [284:21] ==> public open fun visitMaxs(p0: Int, p1: Int): Unit defined in org.jetbrains.org.objectweb.asm.MethodVisitor[JavaMethodDescriptor]

'-' @ [284:31] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'-' @ [284:35] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'SMAPAndMethodNode' @ [285:13] ==> public constructor SMAPAndMethodNode(node: MethodNode, classSMAP: SMAP) defined in org.jetbrains.kotlin.codegen.inline.SMAPAndMethodNode[ClassConstructorDescriptorImpl]

'methodNode' @ [285:31] ==> val methodNode: MethodNode defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.generateLambdaBody[LocalVariableDescriptor]

'smap' @ [285:43] ==> val smap: SMAP defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda.generateLambdaBody.<anonymous>[LocalVariableDescriptor]

