'codegen' @ [35:36] ==> protected final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'bindingContext' @ [35:44] ==> public final val ExpressionCodegen.bindingContext: BindingContext[MyPropertyDescriptor]

'codegen' @ [36:23] ==> protected final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'v' @ [36:31] ==> public final val v: (InstructionAdapter..InstructionAdapter?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'Label' @ [38:43] ==> public constructor Label() defined in org.jetbrains.org.objectweb.asm.Label[JavaClassConstructorDescriptor]

'Label' @ [39:27] ==> public constructor Label() defined in org.jetbrains.org.objectweb.asm.Label[JavaClassConstructorDescriptor]

'arrayListOf' @ [40:38] ==> @SinceKotlin @InlineOnly public inline fun <T> arrayListOf(): ArrayList<Runnable> /* = ArrayList<Runnable> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Runnable

'bindingContext' @ [42:45] ==> protected final val bindingContext: BindingContext defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'getElementType' @ [42:60] ==> private final fun BindingContext.getElementType(forExpression: KtForExpression): KotlinType defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[SimpleFunctionDescriptorImpl]

'forExpression' @ [42:75] ==> public open val forExpression: KtForExpression defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'codegen' @ [43:42] ==> protected final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'asmType' @ [43:50] ==> @NotNull public open fun asmType(@NotNull type: KotlinType): Type defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'elementType' @ [43:58] ==> protected final val elementType: KotlinType defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'-' @ [45:43] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'forExpression' @ [49:25] ==> value-parameter forExpression: KtForExpression defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.getElementType[ValueParameterDescriptorImpl]

'loopRange' @ [49:39] ==> public final val KtForExpression.loopRange: KtExpression?[MyPropertyDescriptor]

'get' @ [50:24] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(p0: (ReadOnlySlice<(KtExpression..KtExpression?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>..ReadOnlySlice<(KtExpression..KtExpression?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>?), p1: (KtExpression..KtExpression?)): ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedCall<(org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)>..org.jetbrains.kotlin.resolve.calls.model.ResolvedCall<(org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)>?)

'LOOP_RANGE_NEXT_RESOLVED_CALL' @ [50:43] ==> public final val LOOP_RANGE_NEXT_RESOLVED_CALL: (WritableSlice<(KtExpression..KtExpression?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>..WritableSlice<(KtExpression..KtExpression?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'loopRange' @ [50:74] ==> val loopRange: KtExpression defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.getElementType[LocalVariableDescriptor]

'AssertionError' @ [51:30] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'+' @ [51:45] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'atLocation' @ [51:85] ==> public open fun atLocation(p0: (KtExpression..KtExpression?)): (String..String?) defined in org.jetbrains.kotlin.diagnostics.DiagnosticUtils[JavaMethodDescriptor]

'loopRange' @ [51:96] ==> val loopRange: KtExpression defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.getElementType[LocalVariableDescriptor]

'nextCall' @ [52:16] ==> val nextCall: ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)> defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.getElementType[LocalVariableDescriptor]

'resultingDescriptor' @ [52:25] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>.resultingDescriptor: FunctionDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)

'returnType' @ [52:45] ==> public final val FunctionDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'forExpression' @ [56:29] ==> public open val forExpression: KtForExpression defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'loopParameter' @ [56:43] ==> public final val KtForExpression.loopParameter: KtParameter?[MyPropertyDescriptor]

'loopParameter' @ [57:30] ==> val loopParameter: KtParameter defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.beforeLoop[LocalVariableDescriptor]

'destructuringDeclaration' @ [57:44] ==> public final val KtParameter.destructuringDeclaration: KtDestructuringDeclaration?[MyPropertyDescriptor]

'if (multiParameter != null) {
            // E tmp<e> = tmp<iterator>.next()
            loopParameterType = asmElementType
            loopParameterVar = createLoopTempVariable(asmElementType)
        }
        else {
            // E e = tmp<iterator>.next()
            val parameterDescriptor = bindingContext.get(BindingContext.VALUE_PARAMETER, loopParameter)
            loopParameterType = codegen.asmType(parameterDescriptor!!.type)
            loopParameterVar = codegen.myFrameMap.enter(parameterDescriptor, loopParameterType)
            scheduleLeaveVariable(Runnable {
                codegen.myFrameMap.leave(parameterDescriptor)
                v.visitLocalVariable(parameterDescriptor.name.asString(),
                                     loopParameterType.descriptor, null,
                                     loopParameterStartLabel, bodyEnd,
                                     loopParameterVar)
            })
        }' @ [58:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'multiParameter' @ [58:13] ==> val multiParameter: KtDestructuringDeclaration? defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.beforeLoop[LocalVariableDescriptor]

'loopParameterType' @ [60:13] ==> protected final lateinit var loopParameterType: Type defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'asmElementType' @ [60:33] ==> protected final val asmElementType: Type defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'loopParameterVar' @ [61:13] ==> protected final var loopParameterVar: Int defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'createLoopTempVariable' @ [61:32] ==> protected final fun createLoopTempVariable(type: Type): Int defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[SimpleFunctionDescriptorImpl]

'asmElementType' @ [61:55] ==> protected final val asmElementType: Type defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'bindingContext' @ [65:39] ==> protected final val bindingContext: BindingContext defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'get' @ [65:54] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(p0: (ReadOnlySlice<(KtParameter..KtParameter?), (VariableDescriptor..VariableDescriptor?)>..ReadOnlySlice<(KtParameter..KtParameter?), (VariableDescriptor..VariableDescriptor?)>?), p1: (KtParameter..KtParameter?)): VariableDescriptor? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtParameter..org.jetbrains.kotlin.psi.KtParameter?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.descriptors.VariableDescriptor..org.jetbrains.kotlin.descriptors.VariableDescriptor?)

'VALUE_PARAMETER' @ [65:73] ==> public final val VALUE_PARAMETER: (WritableSlice<(KtParameter..KtParameter?), (VariableDescriptor..VariableDescriptor?)>..WritableSlice<(KtParameter..KtParameter?), (VariableDescriptor..VariableDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'loopParameter' @ [65:90] ==> val loopParameter: KtParameter defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.beforeLoop[LocalVariableDescriptor]

'loopParameterType' @ [66:13] ==> protected final lateinit var loopParameterType: Type defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'codegen' @ [66:33] ==> protected final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'asmType' @ [66:41] ==> @NotNull public open fun asmType(@NotNull type: KotlinType): Type defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'parameterDescriptor' @ [66:49] ==> val parameterDescriptor: VariableDescriptor? defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.beforeLoop[LocalVariableDescriptor]

'type' @ [66:71] ==> public final val VariableDescriptor.type: KotlinType[MyPropertyDescriptor]

'loopParameterVar' @ [67:13] ==> protected final var loopParameterVar: Int defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'codegen' @ [67:32] ==> protected final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'myFrameMap' @ [67:40] ==> public final val myFrameMap: (FrameMap..FrameMap?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'enter' @ [67:51] ==> public open fun enter(descriptor: (DeclarationDescriptor..DeclarationDescriptor?), type: (Type..Type?)): Int defined in org.jetbrains.kotlin.codegen.FrameMap[JavaMethodDescriptor]

'parameterDescriptor' @ [67:57] ==> val parameterDescriptor: VariableDescriptor? defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.beforeLoop[LocalVariableDescriptor]

'loopParameterType' @ [67:78] ==> protected final lateinit var loopParameterType: Type defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'scheduleLeaveVariable' @ [68:13] ==> private final fun scheduleLeaveVariable(runnable: Runnable): Unit defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[SimpleFunctionDescriptorImpl]

'Runnable' @ [68:35] ==> @FunctionalInterface public fun Runnable(function: () -> Unit): Runnable defined in java.lang[SamConstructorDescriptorImpl]

'codegen' @ [69:17] ==> protected final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'myFrameMap' @ [69:25] ==> public final val myFrameMap: (FrameMap..FrameMap?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'leave' @ [69:36] ==> public open fun leave(descriptor: (DeclarationDescriptor..DeclarationDescriptor?)): Int defined in org.jetbrains.kotlin.codegen.FrameMap[JavaMethodDescriptor]

'parameterDescriptor' @ [69:42] ==> val parameterDescriptor: VariableDescriptor? defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.beforeLoop[LocalVariableDescriptor]

'v' @ [70:17] ==> protected final val v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'visitLocalVariable' @ [70:19] ==> public open fun visitLocalVariable(p0: (String..String?), p1: (String..String?), p2: (String..String?), p3: (Label..Label?), p4: (Label..Label?), p5: Int): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'parameterDescriptor' @ [70:38] ==> val parameterDescriptor: VariableDescriptor? defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.beforeLoop[LocalVariableDescriptor]

'name' @ [70:58] ==> public final val VariableDescriptor.name: Name[MyPropertyDescriptor]

'asString' @ [70:63] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'loopParameterType' @ [71:38] ==> protected final lateinit var loopParameterType: Type defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'descriptor' @ [71:56] ==> public final val Type.descriptor: (String..String?)[MyPropertyDescriptor]

'loopParameterStartLabel' @ [72:38] ==> private final val loopParameterStartLabel: Label defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'bodyEnd' @ [72:63] ==> private final val bodyEnd: Label defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'loopParameterVar' @ [73:38] ==> protected final var loopParameterVar: Int defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'assignToLoopParameter' @ [79:9] ==> protected abstract fun assignToLoopParameter(): Unit defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[SimpleFunctionDescriptorImpl]

'v' @ [80:9] ==> protected final val v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'mark' @ [80:11] ==> public open fun mark(p0: (Label..Label?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'loopParameterStartLabel' @ [80:16] ==> private final val loopParameterStartLabel: Label defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'forExpression' @ [82:40] ==> public open val forExpression: KtForExpression defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'destructuringDeclaration' @ [82:54] ==> public final val KtForExpression.destructuringDeclaration: KtDestructuringDeclaration?[MyPropertyDescriptor]

'destructuringDeclaration' @ [83:13] ==> val destructuringDeclaration: KtDestructuringDeclaration? defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.beforeBody[LocalVariableDescriptor]

'generateDestructuringDeclaration' @ [84:13] ==> private final fun generateDestructuringDeclaration(destructuringDeclaration: KtDestructuringDeclaration): Unit defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[SimpleFunctionDescriptorImpl]

'destructuringDeclaration' @ [84:46] ==> val destructuringDeclaration: KtDestructuringDeclaration? defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.beforeBody[LocalVariableDescriptor]

'Label' @ [89:39] ==> public constructor Label() defined in org.jetbrains.org.objectweb.asm.Label[JavaClassConstructorDescriptor]

'destructuringDeclaration' @ [91:36] ==> value-parameter destructuringDeclaration: KtDestructuringDeclaration defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.generateDestructuringDeclaration[ValueParameterDescriptorImpl]

'entries' @ [91:61] ==> public final val KtDestructuringDeclaration.entries: (MutableList<(KtDestructuringDeclarationEntry..KtDestructuringDeclarationEntry?)>..List<(KtDestructuringDeclarationEntry..KtDestructuringDeclarationEntry?)>)[MyPropertyDescriptor]

'map' @ [91:69] ==> public inline fun <T, R> Iterable<(KtDestructuringDeclarationEntry..KtDestructuringDeclarationEntry?)>.map(transform: ((KtDestructuringDeclarationEntry..KtDestructuringDeclarationEntry?)) -> VariableDescriptor): List<VariableDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtDestructuringDeclarationEntry..org.jetbrains.kotlin.psi.KtDestructuringDeclarationEntry?)
    <R> -> VariableDescriptor

'codegen' @ [91:90] ==> protected final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'getVariableDescriptorNotNull' @ [91:98] ==> @NotNull public open fun getVariableDescriptorNotNull(@NotNull declaration: KtElement): VariableDescriptor defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'declaration' @ [91:127] ==> value-parameter declaration: (KtDestructuringDeclarationEntry..KtDestructuringDeclarationEntry?) defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.generateDestructuringDeclaration.<anonymous>[ValueParameterDescriptorImpl]

'componentDescriptors' @ [93:37] ==> val componentDescriptors: List<VariableDescriptor> defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.generateDestructuringDeclaration[LocalVariableDescriptor]

'filterOutDescriptorsWithSpecialNames' @ [93:58] ==> public fun Collection<VariableDescriptor>.filterOutDescriptorsWithSpecialNames(): List<VariableDescriptor> defined in org.jetbrains.kotlin.codegen in file codegenUtil.kt[SimpleFunctionDescriptorImpl]

'codegen' @ [94:36] ==> protected final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'asmType' @ [94:44] ==> @NotNull public open fun asmType(@NotNull type: KotlinType): Type defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'componentDescriptor' @ [94:52] ==> val componentDescriptor: VariableDescriptor defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.generateDestructuringDeclaration[LocalVariableDescriptor]

'returnType' @ [94:72] ==> public final val VariableDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'codegen' @ [95:37] ==> protected final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'myFrameMap' @ [95:45] ==> public final val myFrameMap: (FrameMap..FrameMap?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'enter' @ [95:56] ==> public open fun enter(descriptor: (DeclarationDescriptor..DeclarationDescriptor?), type: (Type..Type?)): Int defined in org.jetbrains.kotlin.codegen.FrameMap[JavaMethodDescriptor]

'componentDescriptor' @ [95:62] ==> val componentDescriptor: VariableDescriptor defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.generateDestructuringDeclaration[LocalVariableDescriptor]

'componentAsmType' @ [95:83] ==> val componentAsmType: Type defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.generateDestructuringDeclaration[LocalVariableDescriptor]

'scheduleLeaveVariable' @ [96:13] ==> private final fun scheduleLeaveVariable(runnable: Runnable): Unit defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[SimpleFunctionDescriptorImpl]

'Runnable' @ [96:35] ==> @FunctionalInterface public fun Runnable(function: () -> Unit): Runnable defined in java.lang[SamConstructorDescriptorImpl]

'codegen' @ [97:17] ==> protected final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'myFrameMap' @ [97:25] ==> public final val myFrameMap: (FrameMap..FrameMap?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'leave' @ [97:36] ==> public open fun leave(descriptor: (DeclarationDescriptor..DeclarationDescriptor?)): Int defined in org.jetbrains.kotlin.codegen.FrameMap[JavaMethodDescriptor]

'componentDescriptor' @ [97:42] ==> val componentDescriptor: VariableDescriptor defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.generateDestructuringDeclaration[LocalVariableDescriptor]

'v' @ [98:17] ==> protected final val v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'visitLocalVariable' @ [98:19] ==> public open fun visitLocalVariable(p0: (String..String?), p1: (String..String?), p2: (String..String?), p3: (Label..Label?), p4: (Label..Label?), p5: Int): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'componentDescriptor' @ [98:38] ==> val componentDescriptor: VariableDescriptor defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.generateDestructuringDeclaration[LocalVariableDescriptor]

'name' @ [98:58] ==> public final val VariableDescriptor.name: Name[MyPropertyDescriptor]

'asString' @ [98:63] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'componentAsmType' @ [99:38] ==> val componentAsmType: Type defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.generateDestructuringDeclaration[LocalVariableDescriptor]

'descriptor' @ [99:55] ==> public final val Type.descriptor: (String..String?)[MyPropertyDescriptor]

'destructuringStartLabel' @ [100:38] ==> val destructuringStartLabel: Label defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.generateDestructuringDeclaration[LocalVariableDescriptor]

'bodyEnd' @ [100:63] ==> private final val bodyEnd: Label defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'componentVarIndex' @ [101:38] ==> val componentVarIndex: Int defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.generateDestructuringDeclaration[LocalVariableDescriptor]

'v' @ [105:9] ==> protected final val v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'visitLabel' @ [105:11] ==> public open fun visitLabel(p0: (Label..Label?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'destructuringStartLabel' @ [105:22] ==> val destructuringStartLabel: Label defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.generateDestructuringDeclaration[LocalVariableDescriptor]

'codegen' @ [107:9] ==> protected final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'initializeDestructuringDeclarationVariables' @ [107:17] ==> public open fun initializeDestructuringDeclarationVariables(@NotNull destructuringDeclaration: KtDestructuringDeclaration, @NotNull receiver: ReceiverValue, @NotNull receiverStackValue: StackValue): Unit defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'destructuringDeclaration' @ [108:17] ==> value-parameter destructuringDeclaration: KtDestructuringDeclaration defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.generateDestructuringDeclaration[ValueParameterDescriptorImpl]

'TransientReceiver' @ [109:17] ==> public constructor TransientReceiver(@NotNull p0: KotlinType) defined in org.jetbrains.kotlin.resolve.scopes.receivers.TransientReceiver[JavaClassConstructorDescriptor]

'elementType' @ [109:35] ==> protected final val elementType: KotlinType defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'local' @ [110:28] ==> @NotNull public open fun local(index: Int, @NotNull type: Type): StackValue.Local defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'loopParameterVar' @ [110:34] ==> protected final var loopParameterVar: Int defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'asmElementType' @ [110:52] ==> protected final val asmElementType: Type defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'codegen' @ [118:9] ==> protected final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'generateLoopBody' @ [118:17] ==> public open fun generateLoopBody(@Nullable body: KtExpression?): Unit defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'forExpression' @ [118:34] ==> public open val forExpression: KtForExpression defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'body' @ [118:48] ==> public final val KtForExpression.body: KtExpression?[MyPropertyDescriptor]

'leaveVariableTasks' @ [122:9] ==> private final val leaveVariableTasks: ArrayList<Runnable> /* = ArrayList<Runnable> */ defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'add' @ [122:28] ==> public open fun add(element: Runnable): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'runnable' @ [122:32] ==> value-parameter runnable: Runnable defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.scheduleLeaveVariable[ValueParameterDescriptorImpl]

'codegen' @ [126:24] ==> protected final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'myFrameMap' @ [126:32] ==> public final val myFrameMap: (FrameMap..FrameMap?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'enterTemp' @ [126:43] ==> public open fun enterTemp(type: (Type..Type?)): Int defined in org.jetbrains.kotlin.codegen.FrameMap[JavaMethodDescriptor]

'type' @ [126:53] ==> value-parameter type: Type defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.createLoopTempVariable[ValueParameterDescriptorImpl]

'scheduleLeaveVariable' @ [127:9] ==> private final fun scheduleLeaveVariable(runnable: Runnable): Unit defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[SimpleFunctionDescriptorImpl]

'Runnable' @ [127:31] ==> @FunctionalInterface public fun Runnable(function: () -> Unit): Runnable defined in java.lang[SamConstructorDescriptorImpl]

'codegen' @ [127:42] ==> protected final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'myFrameMap' @ [127:50] ==> public final val myFrameMap: (FrameMap..FrameMap?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'leaveTemp' @ [127:61] ==> public open fun leaveTemp(type: (Type..Type?)): Unit defined in org.jetbrains.kotlin.codegen.FrameMap[JavaMethodDescriptor]

'type' @ [127:71] ==> value-parameter type: Type defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.createLoopTempVariable[ValueParameterDescriptorImpl]

'varIndex' @ [128:16] ==> val varIndex: Int defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.createLoopTempVariable[LocalVariableDescriptor]

'codegen' @ [132:9] ==> protected final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'markStartLineNumber' @ [132:17] ==> public open fun markStartLineNumber(@NotNull element: KtElement): Unit defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'forExpression' @ [132:37] ==> public open val forExpression: KtForExpression defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'checkPostConditionAndIncrement' @ [134:9] ==> protected abstract fun checkPostConditionAndIncrement(loopExit: Label): Unit defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[SimpleFunctionDescriptorImpl]

'loopExit' @ [134:40] ==> value-parameter loopExit: Label defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.afterBody[ValueParameterDescriptorImpl]

'v' @ [136:9] ==> protected final val v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'mark' @ [136:11] ==> public open fun mark(p0: (Label..Label?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'bodyEnd' @ [136:16] ==> private final val bodyEnd: Label defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'leaveVariableTasks' @ [140:22] ==> private final val leaveVariableTasks: ArrayList<Runnable> /* = ArrayList<Runnable> */ defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'asReversed' @ [140:41] ==> @JvmName public fun <T> MutableList<Runnable>.asReversed(): MutableList<Runnable> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Runnable

'task' @ [141:13] ==> val task: Runnable defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.afterLoop[LocalVariableDescriptor]

'run' @ [141:18] ==> public abstract fun run(): Unit defined in java.lang.Runnable[JavaMethodDescriptor]

'v' @ [154:9] ==> protected final val v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

'invokevirtual' @ [154:11] ==> public open fun invokevirtual(p0: (String..String?), p1: (String..String?), p2: (String..String?), p3: Boolean): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'loopRangeType' @ [154:25] ==> value-parameter loopRangeType: Type defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.generateRangeOrProgressionProperty[ValueParameterDescriptorImpl]

'internalName' @ [154:39] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'getterName' @ [154:53] ==> value-parameter getterName: String defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.generateRangeOrProgressionProperty[ValueParameterDescriptorImpl]

'+' @ [154:65] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'getterReturnType' @ [154:72] ==> value-parameter getterReturnType: Type defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.generateRangeOrProgressionProperty[ValueParameterDescriptorImpl]

'descriptor' @ [154:89] ==> public final val Type.descriptor: (String..String?)[MyPropertyDescriptor]

'local' @ [155:20] ==> @NotNull public open fun local(index: Int, @NotNull type: Type): StackValue.Local defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'varToStore' @ [155:26] ==> value-parameter varToStore: Int defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.generateRangeOrProgressionProperty[ValueParameterDescriptorImpl]

'varType' @ [155:38] ==> value-parameter varType: Type defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.generateRangeOrProgressionProperty[ValueParameterDescriptorImpl]

'store' @ [155:47] ==> public open fun store(@NotNull value: StackValue, @NotNull v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.StackValue.Local[JavaMethodDescriptor]

'onStack' @ [155:64] ==> @NotNull public open fun onStack(@NotNull type: Type): StackValue defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'getterReturnType' @ [155:72] ==> value-parameter getterReturnType: Type defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator.generateRangeOrProgressionProperty[ValueParameterDescriptorImpl]

'v' @ [155:91] ==> protected final val v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[PropertyDescriptorImpl]

