'StackValue' @ [33:5] ==> protected/*protected and package*/ constructor StackValue(@NotNull type: Type) defined in org.jetbrains.kotlin.codegen.StackValue[JavaClassConstructorDescriptor]

'BOOLEAN_TYPE' @ [33:21] ==> public final val BOOLEAN_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'Label' @ [36:31] ==> public constructor Label() defined in org.jetbrains.org.objectweb.asm.Label[JavaClassConstructorDescriptor]

'condJump' @ [37:9] ==> public open fun condJump(jumpLabel: Label, v: InstructionAdapter, jumpIfFalse: Boolean): Unit defined in org.jetbrains.kotlin.codegen.BranchedValue[SimpleFunctionDescriptorImpl]

'branchJumpLabel' @ [37:18] ==> val branchJumpLabel: Label defined in org.jetbrains.kotlin.codegen.BranchedValue.putSelector[LocalVariableDescriptor]

'v' @ [37:35] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.putSelector[ValueParameterDescriptorImpl]

'Label' @ [38:24] ==> public constructor Label() defined in org.jetbrains.org.objectweb.asm.Label[JavaClassConstructorDescriptor]

'v' @ [39:9] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.putSelector[ValueParameterDescriptorImpl]

'iconst' @ [39:11] ==> public open fun iconst(p0: Int): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'v' @ [40:9] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.putSelector[ValueParameterDescriptorImpl]

'visitJumpInsn' @ [40:11] ==> public open fun visitJumpInsn(p0: Int, p1: (Label..Label?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'GOTO' @ [40:25] ==> public const final val GOTO: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'endLabel' @ [40:31] ==> val endLabel: Label defined in org.jetbrains.kotlin.codegen.BranchedValue.putSelector[LocalVariableDescriptor]

'v' @ [41:9] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.putSelector[ValueParameterDescriptorImpl]

'visitLabel' @ [41:11] ==> public open fun visitLabel(p0: (Label..Label?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'branchJumpLabel' @ [41:22] ==> val branchJumpLabel: Label defined in org.jetbrains.kotlin.codegen.BranchedValue.putSelector[LocalVariableDescriptor]

'v' @ [42:9] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.putSelector[ValueParameterDescriptorImpl]

'iconst' @ [42:11] ==> public open fun iconst(p0: Int): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'v' @ [43:9] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.putSelector[ValueParameterDescriptorImpl]

'visitLabel' @ [43:11] ==> public open fun visitLabel(p0: (Label..Label?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'endLabel' @ [43:22] ==> val endLabel: Label defined in org.jetbrains.kotlin.codegen.BranchedValue.putSelector[LocalVariableDescriptor]

'coerceTo' @ [44:9] ==> protected/*protected and package*/ open fun coerceTo(@NotNull toType: Type, @NotNull v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.BranchedValue[JavaMethodDescriptor]

'type' @ [44:18] ==> value-parameter type: Type defined in org.jetbrains.kotlin.codegen.BranchedValue.putSelector[ValueParameterDescriptorImpl]

'v' @ [44:24] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.putSelector[ValueParameterDescriptorImpl]

'if (arg1 is CondJump) arg1.condJump(jumpLabel, v, jumpIfFalse) else arg1.put(operandType, v)' @ [48:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'arg1' @ [48:13] ==> public final val arg1: StackValue defined in org.jetbrains.kotlin.codegen.BranchedValue[PropertyDescriptorImpl]

'arg1' @ [48:31] ==> public final val arg1: StackValue defined in org.jetbrains.kotlin.codegen.BranchedValue[PropertyDescriptorImpl]

'condJump' @ [48:36] ==> public open fun condJump(jumpLabel: Label, v: InstructionAdapter, jumpIfFalse: Boolean): Unit defined in org.jetbrains.kotlin.codegen.CondJump[SimpleFunctionDescriptorImpl]

'jumpLabel' @ [48:45] ==> value-parameter jumpLabel: Label defined in org.jetbrains.kotlin.codegen.BranchedValue.condJump[ValueParameterDescriptorImpl]

'v' @ [48:56] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.condJump[ValueParameterDescriptorImpl]

'jumpIfFalse' @ [48:59] ==> value-parameter jumpIfFalse: Boolean defined in org.jetbrains.kotlin.codegen.BranchedValue.condJump[ValueParameterDescriptorImpl]

'arg1' @ [48:77] ==> public final val arg1: StackValue defined in org.jetbrains.kotlin.codegen.BranchedValue[PropertyDescriptorImpl]

'put' @ [48:82] ==> public open fun put(@NotNull type: Type, @NotNull v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'operandType' @ [48:86] ==> public final val operandType: Type defined in org.jetbrains.kotlin.codegen.BranchedValue[PropertyDescriptorImpl]

'v' @ [48:99] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.condJump[ValueParameterDescriptorImpl]

'arg2' @ [49:9] ==> public final val arg2: StackValue? defined in org.jetbrains.kotlin.codegen.BranchedValue[PropertyDescriptorImpl]

'put' @ [49:15] ==> public open fun put(@NotNull type: Type, @NotNull v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'operandType' @ [49:19] ==> public final val operandType: Type defined in org.jetbrains.kotlin.codegen.BranchedValue[PropertyDescriptorImpl]

'v' @ [49:32] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.condJump[ValueParameterDescriptorImpl]

'v' @ [50:9] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.condJump[ValueParameterDescriptorImpl]

'visitJumpInsn' @ [50:11] ==> public open fun visitJumpInsn(p0: Int, p1: (Label..Label?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'patchOpcode' @ [50:25] ==> protected open fun patchOpcode(opcode: Int, v: InstructionAdapter): Int defined in org.jetbrains.kotlin.codegen.BranchedValue[SimpleFunctionDescriptorImpl]

'if (jumpIfFalse) opcode else negatedOperations[opcode]!!' @ [50:37] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Int, elseBranch: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Int

'jumpIfFalse' @ [50:41] ==> value-parameter jumpIfFalse: Boolean defined in org.jetbrains.kotlin.codegen.BranchedValue.condJump[ValueParameterDescriptorImpl]

'opcode' @ [50:54] ==> public final val opcode: Int defined in org.jetbrains.kotlin.codegen.BranchedValue[PropertyDescriptorImpl]

'negatedOperations' @ [50:66] ==> public final val negatedOperations: HashMap<Int, Int> /* = HashMap<Int, Int> */ defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion[PropertyDescriptorImpl]

'opcode' @ [50:84] ==> public final val opcode: Int defined in org.jetbrains.kotlin.codegen.BranchedValue[PropertyDescriptorImpl]

'v' @ [50:95] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.condJump[ValueParameterDescriptorImpl]

'jumpLabel' @ [50:99] ==> value-parameter jumpLabel: Label defined in org.jetbrains.kotlin.codegen.BranchedValue.condJump[ValueParameterDescriptorImpl]

'condJump' @ [54:9] ==> public open fun condJump(jumpLabel: Label, v: InstructionAdapter, jumpIfFalse: Boolean): Unit defined in org.jetbrains.kotlin.codegen.BranchedValue[SimpleFunctionDescriptorImpl]

'jumpLabel' @ [54:18] ==> value-parameter jumpLabel: Label defined in org.jetbrains.kotlin.codegen.BranchedValue.loopJump[ValueParameterDescriptorImpl]

'v' @ [54:29] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.loopJump[ValueParameterDescriptorImpl]

'jumpIfFalse' @ [54:32] ==> value-parameter jumpIfFalse: Boolean defined in org.jetbrains.kotlin.codegen.BranchedValue.loopJump[ValueParameterDescriptorImpl]

'opcode' @ [57:79] ==> value-parameter opcode: Int defined in org.jetbrains.kotlin.codegen.BranchedValue.patchOpcode[ValueParameterDescriptorImpl]

'hashMapOf' @ [60:33] ==> @SinceKotlin @InlineOnly public inline fun <K, V> hashMapOf(): HashMap<Int, Int> /* = HashMap<Int, Int> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Int
    <V> -> Int

'BranchedValue' @ [62:44] ==> public constructor BranchedValue(arg1: StackValue, arg2: StackValue? = ..., operandType: Type, opcode: Int) defined in org.jetbrains.kotlin.codegen.BranchedValue[ClassConstructorDescriptorImpl]

'none' @ [62:69] ==> public open fun none(): (StackValue..StackValue?) defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'BOOLEAN_TYPE' @ [62:100] ==> public final val BOOLEAN_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'IFEQ' @ [62:114] ==> public const final val IFEQ: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'!' @ [64:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'jumpIfFalse' @ [64:22] ==> value-parameter jumpIfFalse: Boolean defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.TRUE.<no name provided>.condJump[ValueParameterDescriptorImpl]

'v' @ [65:21] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.TRUE.<no name provided>.condJump[ValueParameterDescriptorImpl]

'goTo' @ [65:23] ==> public open fun goTo(p0: (Label..Label?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'jumpLabel' @ [65:28] ==> value-parameter jumpLabel: Label defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.TRUE.<no name provided>.condJump[ValueParameterDescriptorImpl]

'if (!jumpIfFalse) {
                    v.fakeAlwaysTrueIfeq(jumpLabel)
                }
                else {
                    v.fakeAlwaysFalseIfeq(jumpLabel)
                }' @ [70:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'!' @ [70:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'jumpIfFalse' @ [70:22] ==> value-parameter jumpIfFalse: Boolean defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.TRUE.<no name provided>.loopJump[ValueParameterDescriptorImpl]

'v' @ [71:21] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.TRUE.<no name provided>.loopJump[ValueParameterDescriptorImpl]

'fakeAlwaysTrueIfeq' @ [71:23] ==> public fun InstructionAdapter.fakeAlwaysTrueIfeq(label: Label): Unit defined in org.jetbrains.kotlin.codegen.pseudoInsns in file PseudoInsns.kt[SimpleFunctionDescriptorImpl]

'jumpLabel' @ [71:42] ==> value-parameter jumpLabel: Label defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.TRUE.<no name provided>.loopJump[ValueParameterDescriptorImpl]

'v' @ [74:21] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.TRUE.<no name provided>.loopJump[ValueParameterDescriptorImpl]

'fakeAlwaysFalseIfeq' @ [74:23] ==> public fun InstructionAdapter.fakeAlwaysFalseIfeq(label: Label): Unit defined in org.jetbrains.kotlin.codegen.pseudoInsns in file PseudoInsns.kt[SimpleFunctionDescriptorImpl]

'jumpLabel' @ [74:43] ==> value-parameter jumpLabel: Label defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.TRUE.<no name provided>.loopJump[ValueParameterDescriptorImpl]

'v' @ [79:17] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.TRUE.<no name provided>.putSelector[ValueParameterDescriptorImpl]

'iconst' @ [79:19] ==> public open fun iconst(p0: Int): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'coerceTo' @ [80:17] ==> protected/*protected and package*/ open fun coerceTo(@NotNull toType: Type, @NotNull v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.TRUE.<no name provided>[JavaMethodDescriptor]

'type' @ [80:26] ==> value-parameter type: Type defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.TRUE.<no name provided>.putSelector[ValueParameterDescriptorImpl]

'v' @ [80:32] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.TRUE.<no name provided>.putSelector[ValueParameterDescriptorImpl]

'BranchedValue' @ [84:45] ==> public constructor BranchedValue(arg1: StackValue, arg2: StackValue? = ..., operandType: Type, opcode: Int) defined in org.jetbrains.kotlin.codegen.BranchedValue[ClassConstructorDescriptorImpl]

'none' @ [84:70] ==> public open fun none(): (StackValue..StackValue?) defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'BOOLEAN_TYPE' @ [84:101] ==> public final val BOOLEAN_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'IFEQ' @ [84:115] ==> public const final val IFEQ: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'jumpIfFalse' @ [86:21] ==> value-parameter jumpIfFalse: Boolean defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.FALSE.<no name provided>.condJump[ValueParameterDescriptorImpl]

'v' @ [87:21] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.FALSE.<no name provided>.condJump[ValueParameterDescriptorImpl]

'goTo' @ [87:23] ==> public open fun goTo(p0: (Label..Label?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'jumpLabel' @ [87:28] ==> value-parameter jumpLabel: Label defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.FALSE.<no name provided>.condJump[ValueParameterDescriptorImpl]

'if (jumpIfFalse) {
                    v.fakeAlwaysTrueIfeq(jumpLabel)
                }
                else {
                    v.fakeAlwaysFalseIfeq(jumpLabel)
                }' @ [92:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'jumpIfFalse' @ [92:21] ==> value-parameter jumpIfFalse: Boolean defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.FALSE.<no name provided>.loopJump[ValueParameterDescriptorImpl]

'v' @ [93:21] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.FALSE.<no name provided>.loopJump[ValueParameterDescriptorImpl]

'fakeAlwaysTrueIfeq' @ [93:23] ==> public fun InstructionAdapter.fakeAlwaysTrueIfeq(label: Label): Unit defined in org.jetbrains.kotlin.codegen.pseudoInsns in file PseudoInsns.kt[SimpleFunctionDescriptorImpl]

'jumpLabel' @ [93:42] ==> value-parameter jumpLabel: Label defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.FALSE.<no name provided>.loopJump[ValueParameterDescriptorImpl]

'v' @ [96:21] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.FALSE.<no name provided>.loopJump[ValueParameterDescriptorImpl]

'fakeAlwaysFalseIfeq' @ [96:23] ==> public fun InstructionAdapter.fakeAlwaysFalseIfeq(label: Label): Unit defined in org.jetbrains.kotlin.codegen.pseudoInsns in file PseudoInsns.kt[SimpleFunctionDescriptorImpl]

'jumpLabel' @ [96:43] ==> value-parameter jumpLabel: Label defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.FALSE.<no name provided>.loopJump[ValueParameterDescriptorImpl]

'v' @ [101:17] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.FALSE.<no name provided>.putSelector[ValueParameterDescriptorImpl]

'iconst' @ [101:19] ==> public open fun iconst(p0: Int): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'coerceTo' @ [102:17] ==> protected/*protected and package*/ open fun coerceTo(@NotNull toType: Type, @NotNull v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.FALSE.<no name provided>[JavaMethodDescriptor]

'type' @ [102:26] ==> value-parameter type: Type defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.FALSE.<no name provided>.putSelector[ValueParameterDescriptorImpl]

'v' @ [102:32] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.FALSE.<no name provided>.putSelector[ValueParameterDescriptorImpl]

'registerOperations' @ [107:13] ==> private final fun registerOperations(op: Int, negatedOp: Int): Unit defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion[SimpleFunctionDescriptorImpl]

'IFNE' @ [107:32] ==> public const final val IFNE: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'IFEQ' @ [107:38] ==> public const final val IFEQ: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'registerOperations' @ [108:13] ==> private final fun registerOperations(op: Int, negatedOp: Int): Unit defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion[SimpleFunctionDescriptorImpl]

'IFLE' @ [108:32] ==> public const final val IFLE: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'IFGT' @ [108:38] ==> public const final val IFGT: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'registerOperations' @ [109:13] ==> private final fun registerOperations(op: Int, negatedOp: Int): Unit defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion[SimpleFunctionDescriptorImpl]

'IFLT' @ [109:32] ==> public const final val IFLT: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'IFGE' @ [109:38] ==> public const final val IFGE: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'registerOperations' @ [110:13] ==> private final fun registerOperations(op: Int, negatedOp: Int): Unit defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion[SimpleFunctionDescriptorImpl]

'IFGE' @ [110:32] ==> public const final val IFGE: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'IFLT' @ [110:38] ==> public const final val IFLT: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'registerOperations' @ [111:13] ==> private final fun registerOperations(op: Int, negatedOp: Int): Unit defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion[SimpleFunctionDescriptorImpl]

'IFGT' @ [111:32] ==> public const final val IFGT: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'IFLE' @ [111:38] ==> public const final val IFLE: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'registerOperations' @ [112:13] ==> private final fun registerOperations(op: Int, negatedOp: Int): Unit defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion[SimpleFunctionDescriptorImpl]

'IF_ACMPNE' @ [112:32] ==> public const final val IF_ACMPNE: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'IF_ACMPEQ' @ [112:43] ==> public const final val IF_ACMPEQ: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'registerOperations' @ [113:13] ==> private final fun registerOperations(op: Int, negatedOp: Int): Unit defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion[SimpleFunctionDescriptorImpl]

'IFNULL' @ [113:32] ==> public const final val IFNULL: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'IFNONNULL' @ [113:40] ==> public const final val IFNONNULL: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'negatedOperations' @ [117:13] ==> public final val negatedOperations: HashMap<Int, Int> /* = HashMap<Int, Int> */ defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion[PropertyDescriptorImpl]

'put' @ [117:31] ==> public open fun put(key: Int, value: Int): Int? defined in java.util.HashMap[JavaMethodDescriptor]

'op' @ [117:35] ==> value-parameter op: Int defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.registerOperations[ValueParameterDescriptorImpl]

'negatedOp' @ [117:39] ==> value-parameter negatedOp: Int defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.registerOperations[ValueParameterDescriptorImpl]

'negatedOperations' @ [118:13] ==> public final val negatedOperations: HashMap<Int, Int> /* = HashMap<Int, Int> */ defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion[PropertyDescriptorImpl]

'put' @ [118:31] ==> public open fun put(key: Int, value: Int): Int? defined in java.util.HashMap[JavaMethodDescriptor]

'negatedOp' @ [118:35] ==> value-parameter negatedOp: Int defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.registerOperations[ValueParameterDescriptorImpl]

'op' @ [118:46] ==> value-parameter op: Int defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.registerOperations[ValueParameterDescriptorImpl]

'if (value) TRUE else FALSE' @ [121:62] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: BranchedValue, elseBranch: BranchedValue): BranchedValue[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> BranchedValue

'value' @ [121:66] ==> value-parameter value: Boolean defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.booleanConstant[ValueParameterDescriptorImpl]

'TRUE' @ [121:73] ==> public final val TRUE: BranchedValue defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion[PropertyDescriptorImpl]

'FALSE' @ [121:83] ==> public final val FALSE: BranchedValue defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion[PropertyDescriptorImpl]

'Invert' @ [123:67] ==> public constructor Invert(condition: BranchedValue) defined in org.jetbrains.kotlin.codegen.Invert[ClassConstructorDescriptorImpl]

'condJump' @ [123:74] ==> public final fun condJump(condition: StackValue): CondJump defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion[SimpleFunctionDescriptorImpl]

'argument' @ [123:83] ==> value-parameter argument: StackValue defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.createInvertValue[ValueParameterDescriptorImpl]

'condJump' @ [126:13] ==> public final fun condJump(condition: StackValue): CondJump defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion[SimpleFunctionDescriptorImpl]

'condition' @ [126:22] ==> value-parameter condition: StackValue defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.condJump[ValueParameterDescriptorImpl]

'condJump' @ [126:33] ==> public open fun condJump(jumpLabel: Label, v: InstructionAdapter, jumpIfFalse: Boolean): Unit defined in org.jetbrains.kotlin.codegen.CondJump[SimpleFunctionDescriptorImpl]

'label' @ [126:42] ==> value-parameter label: Label defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.condJump[ValueParameterDescriptorImpl]

'iv' @ [126:49] ==> value-parameter iv: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.condJump[ValueParameterDescriptorImpl]

'jumpIfFalse' @ [126:53] ==> value-parameter jumpIfFalse: Boolean defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.condJump[ValueParameterDescriptorImpl]

'condJump' @ [130:13] ==> public final fun condJump(condition: StackValue): CondJump defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion[SimpleFunctionDescriptorImpl]

'condition' @ [130:22] ==> value-parameter condition: StackValue defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.loopJump[ValueParameterDescriptorImpl]

'loopJump' @ [130:33] ==> public open fun loopJump(jumpLabel: Label, v: InstructionAdapter, jumpIfFalse: Boolean): Unit defined in org.jetbrains.kotlin.codegen.CondJump[SimpleFunctionDescriptorImpl]

'label' @ [130:42] ==> value-parameter label: Label defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.loopJump[ValueParameterDescriptorImpl]

'iv' @ [130:49] ==> value-parameter iv: InstructionAdapter defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.loopJump[ValueParameterDescriptorImpl]

'jumpIfFalse' @ [130:53] ==> value-parameter jumpIfFalse: Boolean defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.loopJump[ValueParameterDescriptorImpl]

'CondJump' @ [134:17] ==> public constructor CondJump(condition: BranchedValue, op: Int) defined in org.jetbrains.kotlin.codegen.CondJump[ClassConstructorDescriptorImpl]

'condition' @ [135:25] ==> value-parameter condition: StackValue defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.condJump[ValueParameterDescriptorImpl]

'BranchedValue' @ [135:56] ==> public constructor BranchedValue(arg1: StackValue, arg2: StackValue? = ..., operandType: Type, opcode: Int) defined in org.jetbrains.kotlin.codegen.BranchedValue[ClassConstructorDescriptorImpl]

'condition' @ [135:70] ==> value-parameter condition: StackValue defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.condJump[ValueParameterDescriptorImpl]

'BOOLEAN_TYPE' @ [135:92] ==> public final val BOOLEAN_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'IFEQ' @ [135:106] ==> public const final val IFEQ: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'IFEQ' @ [136:25] ==> public const final val IFEQ: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'if (operandType.sort == Type.OBJECT)
                    ObjectCompare(opToken, operandType, left, right)
                else
                    NumberCompare(opToken, operandType, left, right)' @ [140:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: StackValue, elseBranch: StackValue): StackValue[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> StackValue

'operandType' @ [140:21] ==> value-parameter operandType: Type defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.cmp[ValueParameterDescriptorImpl]

'sort' @ [140:33] ==> public final val Type.sort: Int[MyPropertyDescriptor]

'OBJECT' @ [140:46] ==> public const final val OBJECT: Int defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'ObjectCompare' @ [141:21] ==> public constructor ObjectCompare(opToken: IElementType, operandType: Type, left: StackValue, right: StackValue) defined in org.jetbrains.kotlin.codegen.ObjectCompare[ClassConstructorDescriptorImpl]

'opToken' @ [141:35] ==> value-parameter opToken: IElementType defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.cmp[ValueParameterDescriptorImpl]

'operandType' @ [141:44] ==> value-parameter operandType: Type defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.cmp[ValueParameterDescriptorImpl]

'left' @ [141:57] ==> value-parameter left: StackValue defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.cmp[ValueParameterDescriptorImpl]

'right' @ [141:63] ==> value-parameter right: StackValue defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.cmp[ValueParameterDescriptorImpl]

'NumberCompare' @ [143:21] ==> public constructor NumberCompare(opToken: IElementType, operandType: Type, left: StackValue, right: StackValue) defined in org.jetbrains.kotlin.codegen.NumberCompare[ClassConstructorDescriptorImpl]

'opToken' @ [143:35] ==> value-parameter opToken: IElementType defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.cmp[ValueParameterDescriptorImpl]

'operandType' @ [143:44] ==> value-parameter operandType: Type defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.cmp[ValueParameterDescriptorImpl]

'left' @ [143:57] ==> value-parameter left: StackValue defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.cmp[ValueParameterDescriptorImpl]

'right' @ [143:63] ==> value-parameter right: StackValue defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion.cmp[ValueParameterDescriptorImpl]

'BranchedValue' @ [151:5] ==> public constructor BranchedValue(arg1: StackValue, arg2: StackValue? = ..., operandType: Type, opcode: Int) defined in org.jetbrains.kotlin.codegen.BranchedValue[ClassConstructorDescriptorImpl]

'BranchedValue' @ [151:19] ==> public companion object defined in org.jetbrains.kotlin.codegen.BranchedValue[FakeCallableDescriptorForObject]

'condJump' @ [151:33] ==> public final fun condJump(condition: StackValue): CondJump defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion[SimpleFunctionDescriptorImpl]

'arg1' @ [151:42] ==> value-parameter arg1: StackValue defined in org.jetbrains.kotlin.codegen.And.<init>[ValueParameterDescriptorImpl]

'BranchedValue' @ [151:49] ==> public companion object defined in org.jetbrains.kotlin.codegen.BranchedValue[FakeCallableDescriptorForObject]

'condJump' @ [151:63] ==> public final fun condJump(condition: StackValue): CondJump defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion[SimpleFunctionDescriptorImpl]

'arg2' @ [151:72] ==> value-parameter arg2: StackValue defined in org.jetbrains.kotlin.codegen.And.<init>[ValueParameterDescriptorImpl]

'BOOLEAN_TYPE' @ [151:84] ==> public final val BOOLEAN_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'IFEQ' @ [151:98] ==> public const final val IFEQ: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'Label' @ [154:25] ==> public constructor Label() defined in org.jetbrains.org.objectweb.asm.Label[JavaClassConstructorDescriptor]

'arg1' @ [155:10] ==> public final val arg1: StackValue defined in org.jetbrains.kotlin.codegen.And[PropertyDescriptorImpl]

'condJump' @ [155:28] ==> public open fun condJump(jumpLabel: Label, v: InstructionAdapter, jumpIfFalse: Boolean): Unit defined in org.jetbrains.kotlin.codegen.CondJump[SimpleFunctionDescriptorImpl]

'if (jumpIfFalse) jumpLabel else stayLabel' @ [155:37] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Label, elseBranch: Label): Label[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Label

'jumpIfFalse' @ [155:41] ==> value-parameter jumpIfFalse: Boolean defined in org.jetbrains.kotlin.codegen.And.condJump[ValueParameterDescriptorImpl]

'jumpLabel' @ [155:54] ==> value-parameter jumpLabel: Label defined in org.jetbrains.kotlin.codegen.And.condJump[ValueParameterDescriptorImpl]

'stayLabel' @ [155:69] ==> val stayLabel: Label defined in org.jetbrains.kotlin.codegen.And.condJump[LocalVariableDescriptor]

'v' @ [155:80] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.And.condJump[ValueParameterDescriptorImpl]

'arg2' @ [156:10] ==> public final val arg2: StackValue? defined in org.jetbrains.kotlin.codegen.And[PropertyDescriptorImpl]

'condJump' @ [156:28] ==> public open fun condJump(jumpLabel: Label, v: InstructionAdapter, jumpIfFalse: Boolean): Unit defined in org.jetbrains.kotlin.codegen.CondJump[SimpleFunctionDescriptorImpl]

'jumpLabel' @ [156:37] ==> value-parameter jumpLabel: Label defined in org.jetbrains.kotlin.codegen.And.condJump[ValueParameterDescriptorImpl]

'v' @ [156:48] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.And.condJump[ValueParameterDescriptorImpl]

'jumpIfFalse' @ [156:51] ==> value-parameter jumpIfFalse: Boolean defined in org.jetbrains.kotlin.codegen.And.condJump[ValueParameterDescriptorImpl]

'v' @ [157:9] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.And.condJump[ValueParameterDescriptorImpl]

'visitLabel' @ [157:11] ==> public open fun visitLabel(p0: (Label..Label?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'stayLabel' @ [157:22] ==> val stayLabel: Label defined in org.jetbrains.kotlin.codegen.And.condJump[LocalVariableDescriptor]

'BranchedValue' @ [164:5] ==> public constructor BranchedValue(arg1: StackValue, arg2: StackValue? = ..., operandType: Type, opcode: Int) defined in org.jetbrains.kotlin.codegen.BranchedValue[ClassConstructorDescriptorImpl]

'BranchedValue' @ [164:19] ==> public companion object defined in org.jetbrains.kotlin.codegen.BranchedValue[FakeCallableDescriptorForObject]

'condJump' @ [164:33] ==> public final fun condJump(condition: StackValue): CondJump defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion[SimpleFunctionDescriptorImpl]

'arg1' @ [164:42] ==> value-parameter arg1: StackValue defined in org.jetbrains.kotlin.codegen.Or.<init>[ValueParameterDescriptorImpl]

'BranchedValue' @ [164:49] ==> public companion object defined in org.jetbrains.kotlin.codegen.BranchedValue[FakeCallableDescriptorForObject]

'condJump' @ [164:63] ==> public final fun condJump(condition: StackValue): CondJump defined in org.jetbrains.kotlin.codegen.BranchedValue.Companion[SimpleFunctionDescriptorImpl]

'arg2' @ [164:72] ==> value-parameter arg2: StackValue defined in org.jetbrains.kotlin.codegen.Or.<init>[ValueParameterDescriptorImpl]

'BOOLEAN_TYPE' @ [164:84] ==> public final val BOOLEAN_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'IFEQ' @ [164:98] ==> public const final val IFEQ: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'Label' @ [167:25] ==> public constructor Label() defined in org.jetbrains.org.objectweb.asm.Label[JavaClassConstructorDescriptor]

'arg1' @ [168:10] ==> public final val arg1: StackValue defined in org.jetbrains.kotlin.codegen.Or[PropertyDescriptorImpl]

'condJump' @ [168:28] ==> public open fun condJump(jumpLabel: Label, v: InstructionAdapter, jumpIfFalse: Boolean): Unit defined in org.jetbrains.kotlin.codegen.CondJump[SimpleFunctionDescriptorImpl]

'if (jumpIfFalse) stayLabel else jumpLabel' @ [168:37] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Label, elseBranch: Label): Label[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Label

'jumpIfFalse' @ [168:41] ==> value-parameter jumpIfFalse: Boolean defined in org.jetbrains.kotlin.codegen.Or.condJump[ValueParameterDescriptorImpl]

'stayLabel' @ [168:54] ==> val stayLabel: Label defined in org.jetbrains.kotlin.codegen.Or.condJump[LocalVariableDescriptor]

'jumpLabel' @ [168:69] ==> value-parameter jumpLabel: Label defined in org.jetbrains.kotlin.codegen.Or.condJump[ValueParameterDescriptorImpl]

'v' @ [168:80] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.Or.condJump[ValueParameterDescriptorImpl]

'arg2' @ [169:10] ==> public final val arg2: StackValue? defined in org.jetbrains.kotlin.codegen.Or[PropertyDescriptorImpl]

'condJump' @ [169:28] ==> public open fun condJump(jumpLabel: Label, v: InstructionAdapter, jumpIfFalse: Boolean): Unit defined in org.jetbrains.kotlin.codegen.CondJump[SimpleFunctionDescriptorImpl]

'jumpLabel' @ [169:37] ==> value-parameter jumpLabel: Label defined in org.jetbrains.kotlin.codegen.Or.condJump[ValueParameterDescriptorImpl]

'v' @ [169:48] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.Or.condJump[ValueParameterDescriptorImpl]

'jumpIfFalse' @ [169:51] ==> value-parameter jumpIfFalse: Boolean defined in org.jetbrains.kotlin.codegen.Or.condJump[ValueParameterDescriptorImpl]

'v' @ [170:9] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.Or.condJump[ValueParameterDescriptorImpl]

'visitLabel' @ [170:11] ==> public open fun visitLabel(p0: (Label..Label?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'stayLabel' @ [170:22] ==> val stayLabel: Label defined in org.jetbrains.kotlin.codegen.Or.condJump[LocalVariableDescriptor]

'BranchedValue' @ [174:46] ==> public constructor BranchedValue(arg1: StackValue, arg2: StackValue? = ..., operandType: Type, opcode: Int) defined in org.jetbrains.kotlin.codegen.BranchedValue[ClassConstructorDescriptorImpl]

'condition' @ [174:60] ==> value-parameter condition: BranchedValue defined in org.jetbrains.kotlin.codegen.Invert.<init>[ValueParameterDescriptorImpl]

'BOOLEAN_TYPE' @ [174:82] ==> public final val BOOLEAN_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'IFEQ' @ [174:96] ==> public const final val IFEQ: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'condition' @ [177:9] ==> public final val condition: BranchedValue defined in org.jetbrains.kotlin.codegen.Invert[PropertyDescriptorImpl]

'condJump' @ [177:19] ==> public open fun condJump(jumpLabel: Label, v: InstructionAdapter, jumpIfFalse: Boolean): Unit defined in org.jetbrains.kotlin.codegen.BranchedValue[SimpleFunctionDescriptorImpl]

'jumpLabel' @ [177:28] ==> value-parameter jumpLabel: Label defined in org.jetbrains.kotlin.codegen.Invert.condJump[ValueParameterDescriptorImpl]

'v' @ [177:39] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.Invert.condJump[ValueParameterDescriptorImpl]

'!' @ [177:42] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'jumpIfFalse' @ [177:43] ==> value-parameter jumpIfFalse: Boolean defined in org.jetbrains.kotlin.codegen.Invert.condJump[ValueParameterDescriptorImpl]

'BranchedValue' @ [181:57] ==> public constructor BranchedValue(arg1: StackValue, arg2: StackValue? = ..., operandType: Type, opcode: Int) defined in org.jetbrains.kotlin.codegen.BranchedValue[ClassConstructorDescriptorImpl]

'condition' @ [181:71] ==> value-parameter condition: BranchedValue defined in org.jetbrains.kotlin.codegen.CondJump.<init>[ValueParameterDescriptorImpl]

'BOOLEAN_TYPE' @ [181:93] ==> public final val BOOLEAN_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'op' @ [181:107] ==> value-parameter op: Int defined in org.jetbrains.kotlin.codegen.CondJump.<init>[ValueParameterDescriptorImpl]

'UnsupportedOperationException' @ [184:15] ==> public final fun <init>(p0: (String..String?)): UnsupportedOperationException /* = UnsupportedOperationException */ defined in kotlin.UnsupportedOperationException[TypeAliasConstructorDescriptorImpl]

'condition' @ [188:9] ==> public final val condition: BranchedValue defined in org.jetbrains.kotlin.codegen.CondJump[PropertyDescriptorImpl]

'condJump' @ [188:19] ==> public open fun condJump(jumpLabel: Label, v: InstructionAdapter, jumpIfFalse: Boolean): Unit defined in org.jetbrains.kotlin.codegen.BranchedValue[SimpleFunctionDescriptorImpl]

'jumpLabel' @ [188:28] ==> value-parameter jumpLabel: Label defined in org.jetbrains.kotlin.codegen.CondJump.condJump[ValueParameterDescriptorImpl]

'v' @ [188:39] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.CondJump.condJump[ValueParameterDescriptorImpl]

'jumpIfFalse' @ [188:42] ==> value-parameter jumpIfFalse: Boolean defined in org.jetbrains.kotlin.codegen.CondJump.condJump[ValueParameterDescriptorImpl]

'condition' @ [192:9] ==> public final val condition: BranchedValue defined in org.jetbrains.kotlin.codegen.CondJump[PropertyDescriptorImpl]

'loopJump' @ [192:19] ==> public open fun loopJump(jumpLabel: Label, v: InstructionAdapter, jumpIfFalse: Boolean): Unit defined in org.jetbrains.kotlin.codegen.BranchedValue[SimpleFunctionDescriptorImpl]

'jumpLabel' @ [192:28] ==> value-parameter jumpLabel: Label defined in org.jetbrains.kotlin.codegen.CondJump.loopJump[ValueParameterDescriptorImpl]

'v' @ [192:39] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.CondJump.loopJump[ValueParameterDescriptorImpl]

'jumpIfFalse' @ [192:42] ==> value-parameter jumpIfFalse: Boolean defined in org.jetbrains.kotlin.codegen.CondJump.loopJump[ValueParameterDescriptorImpl]

'BranchedValue' @ [201:5] ==> public constructor BranchedValue(arg1: StackValue, arg2: StackValue? = ..., operandType: Type, opcode: Int) defined in org.jetbrains.kotlin.codegen.BranchedValue[ClassConstructorDescriptorImpl]

'left' @ [201:19] ==> value-parameter left: StackValue defined in org.jetbrains.kotlin.codegen.NumberCompare.<init>[ValueParameterDescriptorImpl]

'right' @ [201:25] ==> value-parameter right: StackValue defined in org.jetbrains.kotlin.codegen.NumberCompare.<init>[ValueParameterDescriptorImpl]

'operandType' @ [201:32] ==> value-parameter operandType: Type defined in org.jetbrains.kotlin.codegen.NumberCompare.<init>[ValueParameterDescriptorImpl]

'NumberCompare' @ [201:45] ==> public companion object defined in org.jetbrains.kotlin.codegen.NumberCompare[FakeCallableDescriptorForObject]

'getNumberCompareOpcode' @ [201:59] ==> public final fun getNumberCompareOpcode(opToken: IElementType): Int defined in org.jetbrains.kotlin.codegen.NumberCompare.Companion[SimpleFunctionDescriptorImpl]

'opToken' @ [201:82] ==> value-parameter opToken: IElementType defined in org.jetbrains.kotlin.codegen.NumberCompare.<init>[ValueParameterDescriptorImpl]

'patchOpcode' @ [204:13] ==> public final fun patchOpcode(opcode: Int, v: InstructionAdapter, opToken: IElementType, operandType: Type): Int defined in org.jetbrains.kotlin.codegen.NumberCompare.Companion[SimpleFunctionDescriptorImpl]

'opcode' @ [204:25] ==> value-parameter opcode: Int defined in org.jetbrains.kotlin.codegen.NumberCompare.patchOpcode[ValueParameterDescriptorImpl]

'v' @ [204:33] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.NumberCompare.patchOpcode[ValueParameterDescriptorImpl]

'opToken' @ [204:36] ==> private final val opToken: IElementType defined in org.jetbrains.kotlin.codegen.NumberCompare[PropertyDescriptorImpl]

'operandType' @ [204:45] ==> public final val operandType: Type defined in org.jetbrains.kotlin.codegen.NumberCompare[PropertyDescriptorImpl]

'when (opToken) {
            KtTokens.EQEQ, KtTokens.EQEQEQ -> IFNE
            KtTokens.EXCLEQ, KtTokens.EXCLEQEQEQ -> IFEQ
            KtTokens.GT -> IFLE
            KtTokens.GTEQ -> IFLT
            KtTokens.LT -> IFGE
            KtTokens.LTEQ -> IFGT
            else -> {
                throw UnsupportedOperationException("Don't know how to generate this condJump: " + opToken)
            }
        }' @ [207:66] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Int, entry1: Int, entry2: Int, entry3: Int, entry4: Int, entry5: Int, entry6: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Int

'opToken' @ [207:72] ==> value-parameter opToken: IElementType defined in org.jetbrains.kotlin.codegen.NumberCompare.Companion.getNumberCompareOpcode[ValueParameterDescriptorImpl]

'EQEQ' @ [208:22] ==> public final val EQEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'EQEQEQ' @ [208:37] ==> public final val EQEQEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'IFNE' @ [208:47] ==> public const final val IFNE: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'EXCLEQ' @ [209:22] ==> public final val EXCLEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'EXCLEQEQEQ' @ [209:39] ==> public final val EXCLEQEQEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'IFEQ' @ [209:53] ==> public const final val IFEQ: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'GT' @ [210:22] ==> public final val GT: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'IFLE' @ [210:28] ==> public const final val IFLE: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'GTEQ' @ [211:22] ==> public final val GTEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'IFLT' @ [211:30] ==> public const final val IFLT: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'LT' @ [212:22] ==> public final val LT: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'IFGE' @ [212:28] ==> public const final val IFGE: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'LTEQ' @ [213:22] ==> public final val LTEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'IFGT' @ [213:30] ==> public const final val IFGT: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'UnsupportedOperationException' @ [215:23] ==> public final fun <init>(p0: (String..String?)): UnsupportedOperationException /* = UnsupportedOperationException */ defined in kotlin.UnsupportedOperationException[TypeAliasConstructorDescriptorImpl]

'+' @ [215:53] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'opToken' @ [215:100] ==> value-parameter opToken: IElementType defined in org.jetbrains.kotlin.codegen.NumberCompare.Companion.getNumberCompareOpcode[ValueParameterDescriptorImpl]

'assert' @ [220:13] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'opcode' @ [220:20] ==> value-parameter opcode: Int defined in org.jetbrains.kotlin.codegen.NumberCompare.Companion.patchOpcode[ValueParameterDescriptorImpl]

'IFEQ' @ [220:30] ==> public const final val IFEQ: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'IFLE' @ [220:36] ==> public const final val IFLE: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'IFEQ' @ [221:58] ==> public const final val IFEQ: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'IFLE' @ [221:64] ==> public const final val IFLE: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'opcode' @ [221:76] ==> value-parameter opcode: Int defined in org.jetbrains.kotlin.codegen.NumberCompare.Companion.patchOpcode[ValueParameterDescriptorImpl]

'when (operandType) {
                Type.FLOAT_TYPE, Type.DOUBLE_TYPE -> {
                    if (opToken == KtTokens.GT || opToken == KtTokens.GTEQ)
                        v.cmpl(operandType)
                    else
                        v.cmpg(operandType)
                    opcode
                }
                Type.LONG_TYPE -> {
                    v.lcmp()
                    opcode
                }
                else ->
                    opcode + (IF_ICMPEQ - IFEQ)
            }' @ [223:20] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Int, entry1: Int, entry2: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Int

'operandType' @ [223:26] ==> value-parameter operandType: Type defined in org.jetbrains.kotlin.codegen.NumberCompare.Companion.patchOpcode[ValueParameterDescriptorImpl]

'FLOAT_TYPE' @ [224:22] ==> public final val FLOAT_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'DOUBLE_TYPE' @ [224:39] ==> public final val DOUBLE_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'if (opToken == KtTokens.GT || opToken == KtTokens.GTEQ)
                        v.cmpl(operandType)
                    else
                        v.cmpg(operandType)' @ [225:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'opToken' @ [225:25] ==> value-parameter opToken: IElementType defined in org.jetbrains.kotlin.codegen.NumberCompare.Companion.patchOpcode[ValueParameterDescriptorImpl]

'GT' @ [225:45] ==> public final val GT: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'opToken' @ [225:51] ==> value-parameter opToken: IElementType defined in org.jetbrains.kotlin.codegen.NumberCompare.Companion.patchOpcode[ValueParameterDescriptorImpl]

'GTEQ' @ [225:71] ==> public final val GTEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'v' @ [226:25] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.NumberCompare.Companion.patchOpcode[ValueParameterDescriptorImpl]

'cmpl' @ [226:27] ==> public open fun cmpl(p0: (Type..Type?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'operandType' @ [226:32] ==> value-parameter operandType: Type defined in org.jetbrains.kotlin.codegen.NumberCompare.Companion.patchOpcode[ValueParameterDescriptorImpl]

'v' @ [228:25] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.NumberCompare.Companion.patchOpcode[ValueParameterDescriptorImpl]

'cmpg' @ [228:27] ==> public open fun cmpg(p0: (Type..Type?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'operandType' @ [228:32] ==> value-parameter operandType: Type defined in org.jetbrains.kotlin.codegen.NumberCompare.Companion.patchOpcode[ValueParameterDescriptorImpl]

'opcode' @ [229:21] ==> value-parameter opcode: Int defined in org.jetbrains.kotlin.codegen.NumberCompare.Companion.patchOpcode[ValueParameterDescriptorImpl]

'LONG_TYPE' @ [231:22] ==> public final val LONG_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'v' @ [232:21] ==> value-parameter v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.NumberCompare.Companion.patchOpcode[ValueParameterDescriptorImpl]

'lcmp' @ [232:23] ==> public open fun lcmp(): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'opcode' @ [233:21] ==> value-parameter opcode: Int defined in org.jetbrains.kotlin.codegen.NumberCompare.Companion.patchOpcode[ValueParameterDescriptorImpl]

'opcode' @ [236:21] ==> value-parameter opcode: Int defined in org.jetbrains.kotlin.codegen.NumberCompare.Companion.patchOpcode[ValueParameterDescriptorImpl]

'IF_ICMPEQ' @ [236:31] ==> public const final val IF_ICMPEQ: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'IFEQ' @ [236:43] ==> public const final val IFEQ: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'BranchedValue' @ [247:5] ==> public constructor BranchedValue(arg1: StackValue, arg2: StackValue? = ..., operandType: Type, opcode: Int) defined in org.jetbrains.kotlin.codegen.BranchedValue[ClassConstructorDescriptorImpl]

'left' @ [247:19] ==> value-parameter left: StackValue defined in org.jetbrains.kotlin.codegen.ObjectCompare.<init>[ValueParameterDescriptorImpl]

'right' @ [247:25] ==> value-parameter right: StackValue defined in org.jetbrains.kotlin.codegen.ObjectCompare.<init>[ValueParameterDescriptorImpl]

'operandType' @ [247:32] ==> value-parameter operandType: Type defined in org.jetbrains.kotlin.codegen.ObjectCompare.<init>[ValueParameterDescriptorImpl]

'ObjectCompare' @ [247:45] ==> public companion object defined in org.jetbrains.kotlin.codegen.ObjectCompare[FakeCallableDescriptorForObject]

'getObjectCompareOpcode' @ [247:59] ==> public final fun getObjectCompareOpcode(opToken: IElementType): Int defined in org.jetbrains.kotlin.codegen.ObjectCompare.Companion[SimpleFunctionDescriptorImpl]

'opToken' @ [247:82] ==> value-parameter opToken: IElementType defined in org.jetbrains.kotlin.codegen.ObjectCompare.<init>[ValueParameterDescriptorImpl]

'when (opToken) {
            KtTokens.EQEQEQ -> IF_ACMPNE
            KtTokens.EXCLEQEQEQ -> IF_ACMPEQ
            else -> throw UnsupportedOperationException("don't know how to generate this condjump")
        }' @ [250:66] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Int, entry1: Int, entry2: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Int

'opToken' @ [250:72] ==> value-parameter opToken: IElementType defined in org.jetbrains.kotlin.codegen.ObjectCompare.Companion.getObjectCompareOpcode[ValueParameterDescriptorImpl]

'EQEQEQ' @ [251:22] ==> public final val EQEQEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'IF_ACMPNE' @ [251:32] ==> public const final val IF_ACMPNE: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'EXCLEQEQEQ' @ [252:22] ==> public final val EXCLEQEQEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'IF_ACMPEQ' @ [252:36] ==> public const final val IF_ACMPEQ: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'UnsupportedOperationException' @ [253:27] ==> public final fun <init>(p0: (String..String?)): UnsupportedOperationException /* = UnsupportedOperationException */ defined in kotlin.UnsupportedOperationException[TypeAliasConstructorDescriptorImpl]

