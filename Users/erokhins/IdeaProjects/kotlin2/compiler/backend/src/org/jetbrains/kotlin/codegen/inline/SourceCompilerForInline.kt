'codegen' @ [94:26] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'state' @ [94:34] ==> public final val ExpressionCodegen.state: GenerationState[MyPropertyDescriptor]

'Delegates' @ [96:28] ==> public object Delegates defined in kotlin.properties[FakeCallableDescriptorForObject]

'notNull' @ [96:38] ==> public final fun <T : Any> notNull(): ReadWriteProperty<Any?, CodegenContext<*>> defined in kotlin.properties.Delegates[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> CodegenContext<*>

'mutableListOf' @ [98:42] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableListOf(): MutableList<ClassDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ClassDescriptor

'KotlinLookupLocation' @ [100:35] ==> public constructor KotlinLookupLocation(element: KtElement) defined in org.jetbrains.kotlin.incremental.KotlinLookupLocation[DeserializedClassConstructorDescriptor]

'callElement' @ [100:56] ==> public open val callElement: KtElement defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'getValue' @ [103:37] ==> @InlineOnly public operator inline fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> T

'callElement' @ [104:9] ==> public open val callElement: KtElement defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'text' @ [104:21] ==> public final val KtElement.text: (String..String?)[MyPropertyDescriptor]

'getValue' @ [107:34] ==> @InlineOnly public operator inline fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> T

'callElement' @ [108:9] ==> public open val callElement: KtElement defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'containingFile' @ [108:21] ==> public final val KtElement.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'context' @ [112:18] ==> private final var context: CodegenContext<*> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'contextKind' @ [112:26] ==> public final val <T : (DeclarationDescriptor..DeclarationDescriptor?)> CodegenContext<out (DeclarationDescriptor..DeclarationDescriptor?)>.contextKind: OwnerKind[MyPropertyDescriptor]
Inferred types:
    <T : (DeclarationDescriptor..DeclarationDescriptor?)> -> Captured(*)

'codegen' @ [116:27] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'getContext' @ [116:35] ==> @NotNull public open fun getContext(): MethodContext defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'codegen' @ [117:33] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'parentCodegen' @ [117:41] ==> public final val ExpressionCodegen.parentCodegen: MemberCodegen<*>[MyPropertyDescriptor]

'context' @ [118:20] ==> var context: MethodContext defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.<get-inlineCallSiteInfo>[LocalVariableDescriptor]

'context' @ [119:38] ==> var context: MethodContext defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.<get-inlineCallSiteInfo>[LocalVariableDescriptor]

'getParentContext' @ [119:46] ==> @NotNull @Override public open fun getParentContext(): raw (CodegenContext<(DeclarationDescriptor..DeclarationDescriptor?)>..CodegenContext<*>) defined in org.jetbrains.kotlin.codegen.context.MethodContext[JavaMethodDescriptor]

'assert' @ [120:17] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'closureContext' @ [120:24] ==> val closureContext: raw (CodegenContext<(DeclarationDescriptor..DeclarationDescriptor?)>..CodegenContext<*>) defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.<get-inlineCallSiteInfo>[LocalVariableDescriptor]

'assert' @ [121:17] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'closureContext' @ [121:24] ==> val closureContext: raw (CodegenContext<(DeclarationDescriptor..DeclarationDescriptor?)>..CodegenContext<*>) defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.<get-inlineCallSiteInfo>[LocalVariableDescriptor]

'parentContext' @ [121:39] ==> public final val <T : (DeclarationDescriptor..DeclarationDescriptor?)> CodegenContext<(DeclarationDescriptor..DeclarationDescriptor?)>.parentContext: raw (CodegenContext<(DeclarationDescriptor..DeclarationDescriptor?)>?..CodegenContext<*>?)[MyPropertyDescriptor]
Inferred types:
    <T : (DeclarationDescriptor..DeclarationDescriptor?)> -> (org.jetbrains.kotlin.descriptors.DeclarationDescriptor..org.jetbrains.kotlin.descriptors.DeclarationDescriptor?)

'context' @ [122:17] ==> var context: MethodContext defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.<get-inlineCallSiteInfo>[LocalVariableDescriptor]

'closureContext' @ [122:27] ==> val closureContext: raw (CodegenContext<(DeclarationDescriptor..DeclarationDescriptor?)>..CodegenContext<*>) defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.<get-inlineCallSiteInfo>[LocalVariableDescriptor]

'parentContext' @ [122:42] ==> public final val <T : (DeclarationDescriptor..DeclarationDescriptor?)> CodegenContext<(DeclarationDescriptor..DeclarationDescriptor?)>.parentContext: raw (CodegenContext<(DeclarationDescriptor..DeclarationDescriptor?)>?..CodegenContext<*>?)[MyPropertyDescriptor]
Inferred types:
    <T : (DeclarationDescriptor..DeclarationDescriptor?)> -> (org.jetbrains.kotlin.descriptors.DeclarationDescriptor..org.jetbrains.kotlin.descriptors.DeclarationDescriptor?)

'assert' @ [123:17] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'parentCodegen' @ [123:24] ==> var parentCodegen: MemberCodegen<*> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.<get-inlineCallSiteInfo>[LocalVariableDescriptor]

'parentCodegen' @ [124:17] ==> var parentCodegen: MemberCodegen<*> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.<get-inlineCallSiteInfo>[LocalVariableDescriptor]

'parentCodegen' @ [124:34] ==> var parentCodegen: MemberCodegen<*> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.<get-inlineCallSiteInfo>[LocalVariableDescriptor]

'delegate' @ [124:70] ==> internal final val delegate: MemberCodegen<*> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.FakeMemberCodegen[PropertyDescriptorImpl]

'codegen' @ [127:29] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'state' @ [127:37] ==> public final val ExpressionCodegen.state: GenerationState[MyPropertyDescriptor]

'typeMapper' @ [127:43] ==> public final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.state.GenerationState[PropertyDescriptorImpl]

'mapSignatureSkipGeneric' @ [127:54] ==> @NotNull public open fun mapSignatureSkipGeneric(@NotNull f: FunctionDescriptor, @NotNull kind: OwnerKind): JvmMethodSignature defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'context' @ [127:78] ==> var context: MethodContext defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.<get-inlineCallSiteInfo>[LocalVariableDescriptor]

'functionDescriptor' @ [127:86] ==> public final val MethodContext.functionDescriptor: FunctionDescriptor[MyPropertyDescriptor]

'context' @ [127:106] ==> var context: MethodContext defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.<get-inlineCallSiteInfo>[LocalVariableDescriptor]

'contextKind' @ [127:114] ==> public final val MethodContext.contextKind: OwnerKind[MyPropertyDescriptor]

'InlineCallSiteInfo' @ [128:20] ==> public constructor InlineCallSiteInfo(ownerClassName: String, functionName: String?, functionDesc: String?) defined in org.jetbrains.kotlin.codegen.inline.InlineCallSiteInfo[ClassConstructorDescriptorImpl]

'parentCodegen' @ [129:21] ==> var parentCodegen: MemberCodegen<*> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.<get-inlineCallSiteInfo>[LocalVariableDescriptor]

'className' @ [129:35] ==> public final val <T : (KtPureElement..KtPureElement?)> MemberCodegen<out (KtPureElement..KtPureElement?)>.className: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <T : (KtPureElement..KtPureElement?)> -> Captured(*)

'signature' @ [129:46] ==> val signature: JvmMethodSignature defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.<get-inlineCallSiteInfo>[LocalVariableDescriptor]

'asmMethod' @ [129:56] ==> public final val JvmMethodSignature.asmMethod: Method[MyPropertyDescriptor]

'name' @ [129:66] ==> public final val Method.name: (String..String?)[MyPropertyDescriptor]

'signature' @ [129:72] ==> val signature: JvmMethodSignature defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.<get-inlineCallSiteInfo>[LocalVariableDescriptor]

'asmMethod' @ [129:82] ==> public final val JvmMethodSignature.asmMethod: Method[MyPropertyDescriptor]

'descriptor' @ [129:92] ==> public final val Method.descriptor: (String..String?)[MyPropertyDescriptor]

'codegen' @ [134:17] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'parentCodegen' @ [134:25] ==> public final val ExpressionCodegen.parentCodegen: MemberCodegen<*>[MyPropertyDescriptor]

'orCreateSourceMapper' @ [134:39] ==> public final val <T : (KtPureElement..KtPureElement?)> MemberCodegen<out (KtPureElement..KtPureElement?)>.orCreateSourceMapper: DefaultSourceMapper[MyPropertyDescriptor]
Inferred types:
    <T : (KtPureElement..KtPureElement?)> -> Captured(*)

'lambdaInfo' @ [139:38] ==> value-parameter lambdaInfo: ExpressionLambda defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateLambdaBody[ValueParameterDescriptorImpl]

'invokeMethodDescriptor' @ [139:49] ==> public open val invokeMethodDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'if (lambdaInfo.isPropertyReference)
                    codegen.getContext().intoAnonymousClass(lambdaInfo.classDescriptor, codegen, OwnerKind.IMPLEMENTATION)
                else
                    codegen.getContext().intoClosure(invokeMethodDescriptor, codegen, state.typeMapper)' @ [141:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: ClassContext, elseBranch: ClassContext): ClassContext[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> ClassContext

'lambdaInfo' @ [141:21] ==> value-parameter lambdaInfo: ExpressionLambda defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateLambdaBody[ValueParameterDescriptorImpl]

'isPropertyReference' @ [141:32] ==> public final val isPropertyReference: Boolean defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'codegen' @ [142:21] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'getContext' @ [142:29] ==> @NotNull public open fun getContext(): MethodContext defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'intoAnonymousClass' @ [142:42] ==> @NotNull public open fun intoAnonymousClass(@NotNull descriptor: ClassDescriptor, @NotNull codegen: ExpressionCodegen, @NotNull ownerKind: OwnerKind): ClassContext defined in org.jetbrains.kotlin.codegen.context.MethodContext[JavaMethodDescriptor]

'lambdaInfo' @ [142:61] ==> value-parameter lambdaInfo: ExpressionLambda defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateLambdaBody[ValueParameterDescriptorImpl]

'classDescriptor' @ [142:72] ==> public final val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'codegen' @ [142:89] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'IMPLEMENTATION' @ [142:108] ==> enum entry IMPLEMENTATION defined in org.jetbrains.kotlin.codegen.OwnerKind[FakeCallableDescriptorForObject]

'codegen' @ [144:21] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'getContext' @ [144:29] ==> @NotNull public open fun getContext(): MethodContext defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'intoClosure' @ [144:42] ==> @NotNull public open fun intoClosure(@NotNull funDescriptor: FunctionDescriptor, @NotNull localLookup: LocalLookup, @NotNull typeMapper: KotlinTypeMapper): ClosureContext defined in org.jetbrains.kotlin.codegen.context.MethodContext[JavaMethodDescriptor]

'invokeMethodDescriptor' @ [144:54] ==> val invokeMethodDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateLambdaBody[LocalVariableDescriptor]

'codegen' @ [144:78] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'state' @ [144:87] ==> public open val state: GenerationState defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'typeMapper' @ [144:93] ==> public final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.state.GenerationState[PropertyDescriptorImpl]

'closureContext' @ [145:23] ==> val closureContext: ClassContext defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateLambdaBody[LocalVariableDescriptor]

'intoInlinedLambda' @ [145:38] ==> @NotNull public open fun intoInlinedLambda(descriptor: (FunctionDescriptor..FunctionDescriptor?), isCrossInline: Boolean, isPropertyReference: Boolean): MethodContext defined in org.jetbrains.kotlin.codegen.context.ClassContext[JavaMethodDescriptor]

'invokeMethodDescriptor' @ [145:56] ==> val invokeMethodDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateLambdaBody[LocalVariableDescriptor]

'lambdaInfo' @ [145:80] ==> value-parameter lambdaInfo: ExpressionLambda defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateLambdaBody[ValueParameterDescriptorImpl]

'isCrossInline' @ [145:91] ==> @JvmField public final val isCrossInline: Boolean defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'lambdaInfo' @ [145:106] ==> value-parameter lambdaInfo: ExpressionLambda defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateLambdaBody[ValueParameterDescriptorImpl]

'isPropertyReference' @ [145:117] ==> public final val isPropertyReference: Boolean defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'generateMethodBody' @ [147:16] ==> private final fun generateMethodBody(adapter: MethodVisitor, descriptor: FunctionDescriptor, context: MethodContext, expression: KtExpression, jvmMethodSignature: JvmMethodSignature, lambdaInfo: ExpressionLambda?): SMAP defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[SimpleFunctionDescriptorImpl]

'adapter' @ [148:17] ==> value-parameter adapter: MethodVisitor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateLambdaBody[ValueParameterDescriptorImpl]

'invokeMethodDescriptor' @ [148:26] ==> val invokeMethodDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateLambdaBody[LocalVariableDescriptor]

'context' @ [148:50] ==> val context: MethodContext defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateLambdaBody[LocalVariableDescriptor]

'lambdaInfo' @ [149:17] ==> value-parameter lambdaInfo: ExpressionLambda defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateLambdaBody[ValueParameterDescriptorImpl]

'functionWithBodyOrCallableReference' @ [149:28] ==> public final val functionWithBodyOrCallableReference: KtExpression defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'jvmMethodSignature' @ [150:17] ==> value-parameter jvmMethodSignature: JvmMethodSignature defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateLambdaBody[ValueParameterDescriptorImpl]

'lambdaInfo' @ [150:37] ==> value-parameter lambdaInfo: ExpressionLambda defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateLambdaBody[ValueParameterDescriptorImpl]

'lambdaInfo' @ [162:24] ==> value-parameter lambdaInfo: ExpressionLambda? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[ValueParameterDescriptorImpl]

'FakeMemberCodegen' @ [165:29] ==> public constructor FakeMemberCodegen(delegate: MemberCodegen<*>, declaration: KtElement, codegenContext: FieldOwnerContext<*>, className: String, parentAsInnerClasses: List<ClassDescriptor>, isInlineLambdaCodegen: Boolean) defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.FakeMemberCodegen[ClassConstructorDescriptorImpl]

'codegen' @ [166:17] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'parentCodegen' @ [166:25] ==> public final val ExpressionCodegen.parentCodegen: MemberCodegen<*>[MyPropertyDescriptor]

'expression' @ [166:40] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[ValueParameterDescriptorImpl]

'context' @ [166:52] ==> value-parameter context: MethodContext defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[ValueParameterDescriptorImpl]

'parentContext' @ [166:60] ==> public final val MethodContext.parentContext: raw (CodegenContext<(DeclarationDescriptor..DeclarationDescriptor?)>..CodegenContext<*>)[MyPropertyDescriptor]

'if (isLambda)
                    codegen.parentCodegen.className
                else
                    state.typeMapper.mapImplementationOwner(descriptor).internalName' @ [167:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (String..String?), elseBranch: (String..String?)): (String..String?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (kotlin.String..kotlin.String?)

'isLambda' @ [167:21] ==> val isLambda: Boolean defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[LocalVariableDescriptor]

'codegen' @ [168:21] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'parentCodegen' @ [168:29] ==> public final val ExpressionCodegen.parentCodegen: MemberCodegen<*>[MyPropertyDescriptor]

'className' @ [168:43] ==> public final val <T : (KtPureElement..KtPureElement?)> MemberCodegen<out (KtPureElement..KtPureElement?)>.className: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <T : (KtPureElement..KtPureElement?)> -> Captured(*)

'state' @ [170:21] ==> public open val state: GenerationState defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'typeMapper' @ [170:27] ==> public final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.state.GenerationState[PropertyDescriptorImpl]

'mapImplementationOwner' @ [170:38] ==> public open fun mapImplementationOwner(@NotNull descriptor: DeclarationDescriptor): (Type..Type?) defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'descriptor' @ [170:61] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[ValueParameterDescriptorImpl]

'internalName' @ [170:73] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'if (isLambda) emptyList() else additionalInnerClasses' @ [171:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<ClassDescriptor>, elseBranch: List<ClassDescriptor>): List<ClassDescriptor>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<ClassDescriptor>

'isLambda' @ [171:21] ==> val isLambda: Boolean defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[LocalVariableDescriptor]

'emptyList' @ [171:31] ==> public fun <T> emptyList(): List<ClassDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ClassDescriptor

'additionalInnerClasses' @ [171:48] ==> private final var additionalInnerClasses: MutableList<ClassDescriptor> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'isLambda' @ [172:17] ==> val isLambda: Boolean defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[LocalVariableDescriptor]

'when (expression) {
            is KtCallableReferenceExpression -> {
                val receiverExpression = expression.receiverExpression
                val receiverType = if (receiverExpression != null && state.bindingContext.getType(receiverExpression) != null)
                    state.typeMapper.mapType(state.bindingContext.getType(receiverExpression)!!)
                else
                    null

                if (isLambda && lambdaInfo!!.isPropertyReference) {
                    val asmType = state.typeMapper.mapClass(lambdaInfo.classDescriptor)
                    val info = lambdaInfo.propertyReferenceInfo
                    PropertyReferenceCodegen.PropertyReferenceGenerationStrategy(
                            true, info!!.getFunction, info.target, asmType, receiverType,
                            lambdaInfo.functionWithBodyOrCallableReference, state, true)
                }
                else {
                    FunctionReferenceGenerationStrategy(
                            state,
                            descriptor,
                            expression.callableReference
                                    .getResolvedCallWithAssert(state.bindingContext),
                            receiverType, null,
                            true
                    )
                }
            }
            is KtFunctionLiteral -> ClosureGenerationStrategy(state, expression as KtDeclarationWithBody)
            else -> FunctionGenerationStrategy.FunctionDefault(state, expression as KtDeclarationWithBody)
        }' @ [175:24] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: FunctionGenerationStrategy.CodegenBased, entry1: FunctionGenerationStrategy.CodegenBased, entry2: FunctionGenerationStrategy.CodegenBased): FunctionGenerationStrategy.CodegenBased[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> CodegenBased

'expression' @ [175:30] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[ValueParameterDescriptorImpl]

'expression' @ [177:42] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[ValueParameterDescriptorImpl]

'receiverExpression' @ [177:53] ==> public final val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.psi.KtCallableReferenceExpression[DeserializedPropertyDescriptor]

'if (receiverExpression != null && state.bindingContext.getType(receiverExpression) != null)
                    state.typeMapper.mapType(state.bindingContext.getType(receiverExpression)!!)
                else
                    null' @ [178:36] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Type?, elseBranch: Type?): Type?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Type?

'receiverExpression' @ [178:40] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[LocalVariableDescriptor]

'state' @ [178:70] ==> public open val state: GenerationState defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'bindingContext' @ [178:76] ==> public final val bindingContext: BindingContext defined in org.jetbrains.kotlin.codegen.state.GenerationState[PropertyDescriptorImpl]

'getType' @ [178:91] ==> @Nullable public abstract fun getType(@NotNull p0: KtExpression): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]

'receiverExpression' @ [178:99] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[LocalVariableDescriptor]

'state' @ [179:21] ==> public open val state: GenerationState defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'typeMapper' @ [179:27] ==> public final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.state.GenerationState[PropertyDescriptorImpl]

'mapType' @ [179:38] ==> @NotNull public open fun mapType(@NotNull jetType: KotlinType): Type defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'state' @ [179:46] ==> public open val state: GenerationState defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'bindingContext' @ [179:52] ==> public final val bindingContext: BindingContext defined in org.jetbrains.kotlin.codegen.state.GenerationState[PropertyDescriptorImpl]

'getType' @ [179:67] ==> @Nullable public abstract fun getType(@NotNull p0: KtExpression): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]

'receiverExpression' @ [179:75] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[LocalVariableDescriptor]

'if (isLambda && lambdaInfo!!.isPropertyReference) {
                    val asmType = state.typeMapper.mapClass(lambdaInfo.classDescriptor)
                    val info = lambdaInfo.propertyReferenceInfo
                    PropertyReferenceCodegen.PropertyReferenceGenerationStrategy(
                            true, info!!.getFunction, info.target, asmType, receiverType,
                            lambdaInfo.functionWithBodyOrCallableReference, state, true)
                }
                else {
                    FunctionReferenceGenerationStrategy(
                            state,
                            descriptor,
                            expression.callableReference
                                    .getResolvedCallWithAssert(state.bindingContext),
                            receiverType, null,
                            true
                    )
                }' @ [183:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: FunctionGenerationStrategy.CodegenBased, elseBranch: FunctionGenerationStrategy.CodegenBased): FunctionGenerationStrategy.CodegenBased[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> CodegenBased

'isLambda' @ [183:21] ==> val isLambda: Boolean defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[LocalVariableDescriptor]

'lambdaInfo' @ [183:33] ==> value-parameter lambdaInfo: ExpressionLambda? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[ValueParameterDescriptorImpl]

'isPropertyReference' @ [183:46] ==> public final val isPropertyReference: Boolean defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'state' @ [184:35] ==> public open val state: GenerationState defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'typeMapper' @ [184:41] ==> public final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.state.GenerationState[PropertyDescriptorImpl]

'mapClass' @ [184:52] ==> @NotNull public open fun mapClass(@NotNull classifier: ClassifierDescriptor): Type defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'lambdaInfo' @ [184:61] ==> value-parameter lambdaInfo: ExpressionLambda? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[ValueParameterDescriptorImpl]

'classDescriptor' @ [184:72] ==> public final val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'lambdaInfo' @ [185:32] ==> value-parameter lambdaInfo: ExpressionLambda? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[ValueParameterDescriptorImpl]

'propertyReferenceInfo' @ [185:43] ==> public final val propertyReferenceInfo: PropertyReferenceInfo? defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'PropertyReferenceGenerationStrategy' @ [186:46] ==> public constructor PropertyReferenceGenerationStrategy(isGetter: Boolean, originalFunctionDesc: FunctionDescriptor, target: VariableDescriptor, asmType: Type, receiverType: Type?, expression: KtElement, state: GenerationState, isInliningStrategy: Boolean) defined in org.jetbrains.kotlin.codegen.PropertyReferenceCodegen.PropertyReferenceGenerationStrategy[ClassConstructorDescriptorImpl]

'info' @ [187:35] ==> val info: PropertyReferenceInfo? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[LocalVariableDescriptor]

'getFunction' @ [187:42] ==> public final val getFunction: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.PropertyReferenceInfo[PropertyDescriptorImpl]

'info' @ [187:55] ==> val info: PropertyReferenceInfo? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[LocalVariableDescriptor]

'target' @ [187:60] ==> public final val target: VariableDescriptor defined in org.jetbrains.kotlin.codegen.inline.PropertyReferenceInfo[PropertyDescriptorImpl]

'asmType' @ [187:68] ==> val asmType: Type defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[LocalVariableDescriptor]

'receiverType' @ [187:77] ==> val receiverType: Type? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[LocalVariableDescriptor]

'lambdaInfo' @ [188:29] ==> value-parameter lambdaInfo: ExpressionLambda? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[ValueParameterDescriptorImpl]

'functionWithBodyOrCallableReference' @ [188:40] ==> public final val functionWithBodyOrCallableReference: KtExpression defined in org.jetbrains.kotlin.codegen.inline.ExpressionLambda[PropertyDescriptorImpl]

'state' @ [188:77] ==> public open val state: GenerationState defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'FunctionReferenceGenerationStrategy' @ [191:21] ==> public constructor FunctionReferenceGenerationStrategy(@NotNull state: GenerationState, @NotNull functionDescriptor: FunctionDescriptor, @NotNull resolvedCall: ResolvedCall<*>, @Nullable receiverType: Type?, @Nullable receiverValue: StackValue?, isInliningStrategy: Boolean) defined in org.jetbrains.kotlin.codegen.FunctionReferenceGenerationStrategy[JavaClassConstructorDescriptor]

'state' @ [192:29] ==> public open val state: GenerationState defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'descriptor' @ [193:29] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[ValueParameterDescriptorImpl]

'expression' @ [194:29] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[ValueParameterDescriptorImpl]

'callableReference' @ [194:40] ==> public final val KtCallableReferenceExpression.callableReference: KtSimpleNameExpression[MyPropertyDescriptor]

'getResolvedCallWithAssert' @ [195:38] ==> public fun KtElement.getResolvedCallWithAssert(context: BindingContext): ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'state' @ [195:64] ==> public open val state: GenerationState defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'bindingContext' @ [195:70] ==> public final val bindingContext: BindingContext defined in org.jetbrains.kotlin.codegen.state.GenerationState[PropertyDescriptorImpl]

'receiverType' @ [196:29] ==> val receiverType: Type? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[LocalVariableDescriptor]

'ClosureGenerationStrategy' @ [201:37] ==> public constructor ClosureGenerationStrategy(state: GenerationState, declaration: KtDeclarationWithBody) defined in org.jetbrains.kotlin.codegen.ClosureGenerationStrategy[ClassConstructorDescriptorImpl]

'state' @ [201:63] ==> public open val state: GenerationState defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'expression' @ [201:70] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[ValueParameterDescriptorImpl]

'FunctionDefault' @ [202:48] ==> public constructor FunctionDefault(@NotNull state: GenerationState, @NotNull declaration: KtDeclarationWithBody) defined in org.jetbrains.kotlin.codegen.FunctionGenerationStrategy.FunctionDefault[JavaClassConstructorDescriptor]

'state' @ [202:64] ==> public open val state: GenerationState defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'expression' @ [202:71] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[ValueParameterDescriptorImpl]

'generateMethodBody' @ [205:25] ==> public open fun generateMethodBody(@NotNull mv: MethodVisitor, @NotNull functionDescriptor: FunctionDescriptor, @NotNull context: MethodContext, @NotNull signature: JvmMethodSignature, @NotNull strategy: FunctionGenerationStrategy, @NotNull parentCodegen: MemberCodegen<*>): Unit defined in org.jetbrains.kotlin.codegen.FunctionCodegen[JavaMethodDescriptor]

'adapter' @ [205:44] ==> value-parameter adapter: MethodVisitor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[ValueParameterDescriptorImpl]

'descriptor' @ [205:53] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[ValueParameterDescriptorImpl]

'context' @ [205:65] ==> value-parameter context: MethodContext defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[ValueParameterDescriptorImpl]

'jvmMethodSignature' @ [205:74] ==> value-parameter jvmMethodSignature: JvmMethodSignature defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[ValueParameterDescriptorImpl]

'strategy' @ [205:94] ==> val strategy: FunctionGenerationStrategy.CodegenBased defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[LocalVariableDescriptor]

'parentCodegen' @ [205:104] ==> val parentCodegen: PsiSourceCompilerForInline.FakeMemberCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[LocalVariableDescriptor]

'isLambda' @ [207:13] ==> val isLambda: Boolean defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[LocalVariableDescriptor]

'codegen' @ [208:13] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'propagateChildReifiedTypeParametersUsages' @ [208:21] ==> @Override public open fun propagateChildReifiedTypeParametersUsages(@NotNull reifiedTypeParametersUsages: ReifiedTypeParametersUsages): Unit defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'parentCodegen' @ [208:63] ==> val parentCodegen: PsiSourceCompilerForInline.FakeMemberCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[LocalVariableDescriptor]

'reifiedTypeParametersUsages' @ [208:77] ==> public final val PsiSourceCompilerForInline.FakeMemberCodegen.reifiedTypeParametersUsages: ReifiedTypeParametersUsages[MyPropertyDescriptor]

'createSMAPWithDefaultMapping' @ [211:16] ==> private final fun createSMAPWithDefaultMapping(declaration: KtExpression, mappings: List<FileMapping>): SMAP defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[SimpleFunctionDescriptorImpl]

'expression' @ [211:45] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[ValueParameterDescriptorImpl]

'parentCodegen' @ [211:57] ==> val parentCodegen: PsiSourceCompilerForInline.FakeMemberCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateMethodBody[LocalVariableDescriptor]

'orCreateSourceMapper' @ [211:71] ==> public final val PsiSourceCompilerForInline.FakeMemberCodegen.orCreateSourceMapper: DefaultSourceMapper[MyPropertyDescriptor]

'resultMappings' @ [211:92] ==> public open val resultMappings: List<FileMapping> defined in org.jetbrains.kotlin.codegen.inline.DefaultSourceMapper[PropertyDescriptorImpl]

'declaration' @ [219:30] ==> value-parameter declaration: KtExpression defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.createSMAPWithDefaultMapping[ValueParameterDescriptorImpl]

'containingFile' @ [219:42] ==> public final val KtExpression.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'?:' @ [220:9] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: Int?, right: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> Int

'getLineNumberForElement' @ [220:21] ==> @JvmStatic public final fun getLineNumberForElement(statement: PsiElement, markEndOffset: Boolean): Int? defined in org.jetbrains.kotlin.backend.common.CodegenUtil[DeserializedSimpleFunctionDescriptor]

'containingFile' @ [220:45] ==> val containingFile: (PsiFile..PsiFile?) defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.createSMAPWithDefaultMapping[LocalVariableDescriptor]

'error' @ [220:70] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'+' @ [220:76] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'containingFile' @ [220:112] ==> val containingFile: (PsiFile..PsiFile?) defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.createSMAPWithDefaultMapping[LocalVariableDescriptor]

'SMAP' @ [222:16] ==> public constructor SMAP(fileMappings: List<FileMapping>) defined in org.jetbrains.kotlin.codegen.inline.SMAP[ClassConstructorDescriptorImpl]

'mappings' @ [222:21] ==> value-parameter mappings: List<FileMapping> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.createSMAPWithDefaultMapping[ValueParameterDescriptorImpl]

'Suppress' @ [225:5] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'MemberCodegen<KtPureElement>' @ [233:9] ==> protected/*protected and package*/ constructor MemberCodegen<T : (KtPureElement..KtPureElement?)>(@NotNull wrapped: MemberCodegen<(KtPureElement..KtPureElement?)>, declaration: (KtPureElement..KtPureElement?), codegenContext: raw (FieldOwnerContext<(DeclarationDescriptor..DeclarationDescriptor?)>..FieldOwnerContext<*>?)) defined in org.jetbrains.kotlin.codegen.MemberCodegen[JavaClassConstructorDescriptor]
Inferred types:
    <T : (KtPureElement..KtPureElement?)> -> KtPureElement

'delegate' @ [233:38] ==> value-parameter delegate: MemberCodegen<*> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.FakeMemberCodegen.<init>[ValueParameterDescriptorImpl]

'declaration' @ [233:80] ==> value-parameter declaration: KtElement defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.FakeMemberCodegen.<init>[ValueParameterDescriptorImpl]

'codegenContext' @ [233:93] ==> value-parameter codegenContext: FieldOwnerContext<*> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.FakeMemberCodegen.<init>[ValueParameterDescriptorImpl]

'IllegalStateException' @ [236:19] ==> public final fun <init>(): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'IllegalStateException' @ [240:19] ==> public final fun <init>(): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'IllegalStateException' @ [244:19] ==> public final fun <init>(): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'delegate' @ [248:20] ==> internal final val delegate: MemberCodegen<*> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.FakeMemberCodegen[PropertyDescriptorImpl]

'inlineNameGenerator' @ [248:29] ==> public final val <T : (KtPureElement..KtPureElement?)> MemberCodegen<out (KtPureElement..KtPureElement?)>.inlineNameGenerator: NameGenerator[MyPropertyDescriptor]
Inferred types:
    <T : (KtPureElement..KtPureElement?)> -> Captured(*)

'className' @ [253:20] ==> private final val className: String defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.FakeMemberCodegen[PropertyDescriptorImpl]

'if (isInlineLambdaCodegen) {
                super.addParentsToInnerClassesIfNeeded(innerClasses)
            }
            else {
                innerClasses.addAll(parentAsInnerClasses)
            }' @ [257:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any, elseBranch: Any): Any[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any

'isInlineLambdaCodegen' @ [257:17] ==> private final val isInlineLambdaCodegen: Boolean defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.FakeMemberCodegen[PropertyDescriptorImpl]

'super' @ [258:17] ==> <this> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.FakeMemberCodegen[LazyClassReceiverParameterDescriptor]

'addParentsToInnerClassesIfNeeded' @ [258:23] ==> protected/*protected and package*/ open fun addParentsToInnerClassesIfNeeded(@NotNull innerClasses: (MutableCollection<(ClassDescriptor..ClassDescriptor?)>..Collection<(ClassDescriptor..ClassDescriptor?)>)): Unit defined in org.jetbrains.kotlin.codegen.MemberCodegen[JavaMethodDescriptor]

'innerClasses' @ [258:56] ==> value-parameter innerClasses: MutableCollection<ClassDescriptor> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.FakeMemberCodegen.addParentsToInnerClassesIfNeeded[ValueParameterDescriptorImpl]

'innerClasses' @ [261:17] ==> value-parameter innerClasses: MutableCollection<ClassDescriptor> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.FakeMemberCodegen.addParentsToInnerClassesIfNeeded[ValueParameterDescriptorImpl]

'addAll' @ [261:30] ==> public abstract fun addAll(elements: Collection<ClassDescriptor>): Boolean defined in kotlin.collections.MutableCollection[DeserializedSimpleFunctionDescriptor]

'parentAsInnerClasses' @ [261:37] ==> private final val parentAsInnerClasses: List<ClassDescriptor> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.FakeMemberCodegen[PropertyDescriptorImpl]

'DescriptorToSourceUtils' @ [272:23] ==> public object DescriptorToSourceUtils defined in org.jetbrains.kotlin.resolve[FakeCallableDescriptorForObject]

'descriptorToDeclaration' @ [272:47] ==> @JvmStatic public final fun descriptorToDeclaration(descriptor: DeclarationDescriptor): PsiElement? defined in org.jetbrains.kotlin.resolve.DescriptorToSourceUtils[DeserializedSimpleFunctionDescriptor]

'callableDescriptor' @ [272:71] ==> value-parameter callableDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[ValueParameterDescriptorImpl]

'!' @ [274:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'element' @ [274:15] ==> val element: PsiElement? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[LocalVariableDescriptor]

'element' @ [274:45] ==> val element: PsiElement? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[LocalVariableDescriptor]

'IllegalStateException' @ [275:19] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'+' @ [275:41] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'callableDescriptor' @ [275:85] ==> value-parameter callableDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[ValueParameterDescriptorImpl]

'element' @ [277:32] ==> val element: PsiElement? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[LocalVariableDescriptor]

'MethodNode' @ [279:20] ==> public constructor MethodNode(p0: Int, p1: Int, p2: (String..String?), p3: (String..String?), p4: (String..String?), p5: (Array<(String..String?)>..Array<out (String..String?)>?)) defined in org.jetbrains.org.objectweb.asm.tree.MethodNode[JavaClassConstructorDescriptor]

'API' @ [280:17] ==> public const val API: Int defined in org.jetbrains.kotlin.codegen.inline in file inlineCodegenUtils.kt[PropertyDescriptorImpl]

'or' @ [281:17] ==> public final infix fun or(other: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'getMethodAsmFlags' @ [281:25] ==> public open fun getMethodAsmFlags(functionDescriptor: (FunctionDescriptor..FunctionDescriptor?), kind: (OwnerKind..OwnerKind?), state: (GenerationState..GenerationState?)): Int defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaMethodDescriptor]

'callableDescriptor' @ [281:43] ==> value-parameter callableDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[ValueParameterDescriptorImpl]

'context' @ [281:63] ==> private final var context: CodegenContext<*> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'contextKind' @ [281:71] ==> public final val <T : (DeclarationDescriptor..DeclarationDescriptor?)> CodegenContext<out (DeclarationDescriptor..DeclarationDescriptor?)>.contextKind: OwnerKind[MyPropertyDescriptor]
Inferred types:
    <T : (DeclarationDescriptor..DeclarationDescriptor?)> -> Captured(*)

'state' @ [281:84] ==> public open val state: GenerationState defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'if (callDefault) Opcodes.ACC_STATIC else 0' @ [281:94] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Int, elseBranch: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Int

'callDefault' @ [281:98] ==> value-parameter callDefault: Boolean defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[ValueParameterDescriptorImpl]

'ACC_STATIC' @ [281:119] ==> public const final val ACC_STATIC: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'asmMethod' @ [282:17] ==> value-parameter asmMethod: Method defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[ValueParameterDescriptorImpl]

'name' @ [282:27] ==> public final val Method.name: (String..String?)[MyPropertyDescriptor]

'asmMethod' @ [283:17] ==> value-parameter asmMethod: Method defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[ValueParameterDescriptorImpl]

'descriptor' @ [283:27] ==> public final val Method.descriptor: (String..String?)[MyPropertyDescriptor]

'wrapWithMaxLocalCalc' @ [287:30] ==> public fun wrapWithMaxLocalCalc(methodNode: MethodNode): MethodVisitor defined in org.jetbrains.kotlin.codegen.inline in file inlineCodegenUtils.kt[SimpleFunctionDescriptorImpl]

'node' @ [287:51] ==> val node: MethodNode defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[LocalVariableDescriptor]

'context' @ [288:29] ==> private final var context: CodegenContext<*> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'parentContext' @ [288:37] ==> public final val <T : (DeclarationDescriptor..DeclarationDescriptor?)> CodegenContext<out (DeclarationDescriptor..DeclarationDescriptor?)>.parentContext: raw (CodegenContext<(DeclarationDescriptor..DeclarationDescriptor?)>?..CodegenContext<*>?)[MyPropertyDescriptor]
Inferred types:
    <T : (DeclarationDescriptor..DeclarationDescriptor?)> -> Captured(*)

'error' @ [288:54] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'+' @ [288:60] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'context' @ [288:88] ==> private final var context: CodegenContext<*> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'parentContext' @ [289:29] ==> val parentContext: (CodegenContext<(DeclarationDescriptor..DeclarationDescriptor?)>..CodegenContext<*>) defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[LocalVariableDescriptor]

'intoFunction' @ [289:43] ==> @NotNull public open fun intoFunction(descriptor: (FunctionDescriptor..FunctionDescriptor?)): MethodContext defined in org.jetbrains.kotlin.codegen.context.CodegenContext[JavaMethodDescriptor]

'callableDescriptor' @ [289:56] ==> value-parameter callableDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[ValueParameterDescriptorImpl]

'if (callDefault) {
            val implementationOwner = state.typeMapper.mapImplementationOwner(callableDescriptor)
            val parentCodegen = FakeMemberCodegen(
                    codegen.parentCodegen, inliningFunction!!, methodContext.parentContext as FieldOwnerContext<*>,
                    implementationOwner.internalName,
                    additionalInnerClasses,
                    false
            )
            if (element !is KtNamedFunction) {
                throw IllegalStateException("Property accessors with default parameters not supported " + callableDescriptor)
            }
            FunctionCodegen.generateDefaultImplBody(
                    methodContext, callableDescriptor, maxCalcAdapter, DefaultParameterValueLoader.DEFAULT,
                    inliningFunction as KtNamedFunction?, parentCodegen, asmMethod
            )
            smap = createSMAPWithDefaultMapping(inliningFunction, parentCodegen.orCreateSourceMapper.resultMappings)
        }
        else {
            smap = generateMethodBody(maxCalcAdapter, callableDescriptor, methodContext, inliningFunction!!, jvmSignature, null)
        }' @ [292:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'callDefault' @ [292:13] ==> value-parameter callDefault: Boolean defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[ValueParameterDescriptorImpl]

'state' @ [293:39] ==> public open val state: GenerationState defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'typeMapper' @ [293:45] ==> public final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.state.GenerationState[PropertyDescriptorImpl]

'mapImplementationOwner' @ [293:56] ==> public open fun mapImplementationOwner(@NotNull descriptor: DeclarationDescriptor): (Type..Type?) defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'callableDescriptor' @ [293:79] ==> value-parameter callableDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[ValueParameterDescriptorImpl]

'FakeMemberCodegen' @ [294:33] ==> public constructor FakeMemberCodegen(delegate: MemberCodegen<*>, declaration: KtElement, codegenContext: FieldOwnerContext<*>, className: String, parentAsInnerClasses: List<ClassDescriptor>, isInlineLambdaCodegen: Boolean) defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.FakeMemberCodegen[ClassConstructorDescriptorImpl]

'codegen' @ [295:21] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'parentCodegen' @ [295:29] ==> public final val ExpressionCodegen.parentCodegen: MemberCodegen<*>[MyPropertyDescriptor]

'inliningFunction' @ [295:44] ==> val inliningFunction: KtDeclarationWithBody? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[LocalVariableDescriptor]

'methodContext' @ [295:64] ==> val methodContext: MethodContext defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[LocalVariableDescriptor]

'parentContext' @ [295:78] ==> public final val MethodContext.parentContext: raw (CodegenContext<(DeclarationDescriptor..DeclarationDescriptor?)>..CodegenContext<*>)[MyPropertyDescriptor]

'implementationOwner' @ [296:21] ==> val implementationOwner: (Type..Type?) defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[LocalVariableDescriptor]

'internalName' @ [296:41] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'additionalInnerClasses' @ [297:21] ==> private final var additionalInnerClasses: MutableList<ClassDescriptor> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'element' @ [300:17] ==> val element: PsiElement? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[LocalVariableDescriptor]

'IllegalStateException' @ [301:23] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'+' @ [301:45] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'callableDescriptor' @ [301:107] ==> value-parameter callableDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[ValueParameterDescriptorImpl]

'generateDefaultImplBody' @ [303:29] ==> public open fun generateDefaultImplBody(@NotNull methodContext: MethodContext, @NotNull functionDescriptor: FunctionDescriptor, @NotNull mv: MethodVisitor, @NotNull loadStrategy: DefaultParameterValueLoader, @Nullable function: KtNamedFunction?, @NotNull parentCodegen: MemberCodegen<*>, @NotNull defaultMethod: Method): Unit defined in org.jetbrains.kotlin.codegen.FunctionCodegen[JavaMethodDescriptor]

'methodContext' @ [304:21] ==> val methodContext: MethodContext defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[LocalVariableDescriptor]

'callableDescriptor' @ [304:36] ==> value-parameter callableDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[ValueParameterDescriptorImpl]

'maxCalcAdapter' @ [304:56] ==> val maxCalcAdapter: MethodVisitor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[LocalVariableDescriptor]

'DEFAULT' @ [304:100] ==> public final val DEFAULT: (DefaultParameterValueLoader..DefaultParameterValueLoader?) defined in org.jetbrains.kotlin.codegen.DefaultParameterValueLoader[JavaPropertyDescriptor]

'inliningFunction' @ [305:21] ==> val inliningFunction: KtDeclarationWithBody? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[LocalVariableDescriptor]

'parentCodegen' @ [305:59] ==> val parentCodegen: PsiSourceCompilerForInline.FakeMemberCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[LocalVariableDescriptor]

'asmMethod' @ [305:74] ==> value-parameter asmMethod: Method defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[ValueParameterDescriptorImpl]

'smap' @ [307:13] ==> val smap: SMAP defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[LocalVariableDescriptor]

'createSMAPWithDefaultMapping' @ [307:20] ==> private final fun createSMAPWithDefaultMapping(declaration: KtExpression, mappings: List<FileMapping>): SMAP defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[SimpleFunctionDescriptorImpl]

'inliningFunction' @ [307:49] ==> val inliningFunction: KtDeclarationWithBody? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[LocalVariableDescriptor]

'parentCodegen' @ [307:67] ==> val parentCodegen: PsiSourceCompilerForInline.FakeMemberCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[LocalVariableDescriptor]

'orCreateSourceMapper' @ [307:81] ==> public final val PsiSourceCompilerForInline.FakeMemberCodegen.orCreateSourceMapper: DefaultSourceMapper[MyPropertyDescriptor]

'resultMappings' @ [307:102] ==> public open val resultMappings: List<FileMapping> defined in org.jetbrains.kotlin.codegen.inline.DefaultSourceMapper[PropertyDescriptorImpl]

'smap' @ [310:13] ==> val smap: SMAP defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[LocalVariableDescriptor]

'generateMethodBody' @ [310:20] ==> private final fun generateMethodBody(adapter: MethodVisitor, descriptor: FunctionDescriptor, context: MethodContext, expression: KtExpression, jvmMethodSignature: JvmMethodSignature, lambdaInfo: ExpressionLambda?): SMAP defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[SimpleFunctionDescriptorImpl]

'maxCalcAdapter' @ [310:39] ==> val maxCalcAdapter: MethodVisitor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[LocalVariableDescriptor]

'callableDescriptor' @ [310:55] ==> value-parameter callableDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[ValueParameterDescriptorImpl]

'methodContext' @ [310:75] ==> val methodContext: MethodContext defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[LocalVariableDescriptor]

'inliningFunction' @ [310:90] ==> val inliningFunction: KtDeclarationWithBody? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[LocalVariableDescriptor]

'jvmSignature' @ [310:110] ==> value-parameter jvmSignature: JvmMethodSignature defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[ValueParameterDescriptorImpl]

'maxCalcAdapter' @ [312:9] ==> val maxCalcAdapter: MethodVisitor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[LocalVariableDescriptor]

'visitMaxs' @ [312:24] ==> public open fun visitMaxs(p0: Int, p1: Int): Unit defined in org.jetbrains.org.objectweb.asm.MethodVisitor[JavaMethodDescriptor]

'-' @ [312:34] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'-' @ [312:38] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'maxCalcAdapter' @ [313:9] ==> val maxCalcAdapter: MethodVisitor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[LocalVariableDescriptor]

'visitEnd' @ [313:24] ==> public open fun visitEnd(): Unit defined in org.jetbrains.org.objectweb.asm.MethodVisitor[JavaMethodDescriptor]

'SMAPAndMethodNode' @ [315:16] ==> public constructor SMAPAndMethodNode(node: MethodNode, classSMAP: SMAP) defined in org.jetbrains.kotlin.codegen.inline.SMAPAndMethodNode[ClassConstructorDescriptorImpl]

'node' @ [315:34] ==> val node: MethodNode defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[LocalVariableDescriptor]

'smap' @ [315:40] ==> val smap: SMAP defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.doCreateMethodNodeFromSource[LocalVariableDescriptor]

'!' @ [323:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'codegen' @ [323:14] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'hasFinallyBlocks' @ [323:22] ==> public open fun hasFinallyBlocks(): Boolean defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'HashMap' @ [325:31] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> AbstractInsnNode
    <V : (Any..Any?)> -> PointForExternalFinallyBlocks

'insertPoints' @ [326:29] ==> value-parameter insertPoints: List<MethodInliner.PointForExternalFinallyBlocks> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[ValueParameterDescriptorImpl]

'extensionPoints' @ [327:13] ==> val extensionPoints: HashMap<AbstractInsnNode, MethodInliner.PointForExternalFinallyBlocks> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'put' @ [327:29] ==> public open fun put(key: AbstractInsnNode, value: MethodInliner.PointForExternalFinallyBlocks): MethodInliner.PointForExternalFinallyBlocks? defined in java.util.HashMap[JavaMethodDescriptor]

'insertPoint' @ [327:33] ==> val insertPoint: MethodInliner.PointForExternalFinallyBlocks defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'beforeIns' @ [327:45] ==> @JvmField public final val beforeIns: AbstractInsnNode defined in org.jetbrains.kotlin.codegen.inline.MethodInliner.PointForExternalFinallyBlocks[PropertyDescriptorImpl]

'insertPoint' @ [327:56] ==> val insertPoint: MethodInliner.PointForExternalFinallyBlocks defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'DefaultProcessor' @ [330:25] ==> public constructor DefaultProcessor(node: MethodNode, parameterSize: Int) defined in org.jetbrains.kotlin.codegen.inline.DefaultProcessor[ClassConstructorDescriptorImpl]

'intoNode' @ [330:42] ==> value-parameter intoNode: MethodNode defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[ValueParameterDescriptorImpl]

'offsetForFinallyLocalVar' @ [330:52] ==> value-parameter offsetForFinallyLocalVar: Int defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[ValueParameterDescriptorImpl]

'intoNode' @ [333:43] ==> value-parameter intoNode: MethodNode defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[ValueParameterDescriptorImpl]

'instructions' @ [333:52] ==> public final var instructions: (InsnList..InsnList?) defined in org.jetbrains.org.objectweb.asm.tree.MethodNode[JavaPropertyDescriptor]

'first' @ [333:65] ==> public final val InsnList.first: (AbstractInsnNode..AbstractInsnNode?)[MyPropertyDescriptor]

'curInstr' @ [334:16] ==> var curInstr: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'processor' @ [335:13] ==> val processor: DefaultProcessor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'processInstruction' @ [335:23] ==> public open fun processInstruction(curInstr: AbstractInsnNode, directOrder: Boolean): Unit defined in org.jetbrains.kotlin.codegen.inline.DefaultProcessor[SimpleFunctionDescriptorImpl]

'curInstr' @ [335:42] ==> var curInstr: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'isFinallyStart' @ [336:17] ==> internal fun isFinallyStart(node: AbstractInsnNode): Boolean defined in org.jetbrains.kotlin.codegen.inline in file inlineCodegenUtils.kt[SimpleFunctionDescriptorImpl]

'curInstr' @ [336:32] ==> var curInstr: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'curFinallyDepth' @ [338:17] ==> var curFinallyDepth: Int defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'getConstant' @ [338:35] ==> internal fun getConstant(ins: AbstractInsnNode): Int defined in org.jetbrains.kotlin.codegen.inline in file inlineCodegenUtils.kt[SimpleFunctionDescriptorImpl]

'curInstr' @ [338:47] ==> var curInstr: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'previous' @ [338:56] ==> public final val AbstractInsnNode.previous: (AbstractInsnNode..AbstractInsnNode?)[MyPropertyDescriptor]

'extensionPoints' @ [341:29] ==> val extensionPoints: HashMap<AbstractInsnNode, MethodInliner.PointForExternalFinallyBlocks> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'curInstr' @ [341:45] ==> var curInstr: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'extension' @ [342:17] ==> val extension: MethodInliner.PointForExternalFinallyBlocks? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'Label' @ [343:29] ==> public constructor Label() defined in org.jetbrains.org.objectweb.asm.Label[JavaClassConstructorDescriptor]

'createEmptyMethodNode' @ [345:35] ==> internal fun createEmptyMethodNode(): MethodNode defined in org.jetbrains.kotlin.codegen.inline in file inlineCodegenUtils.kt[SimpleFunctionDescriptorImpl]

'finallyNode' @ [346:17] ==> val finallyNode: MethodNode defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'visitLabel' @ [346:29] ==> public open fun visitLabel(p0: (Label..Label?)): Unit defined in org.jetbrains.org.objectweb.asm.tree.MethodNode[JavaMethodDescriptor]

'start' @ [346:40] ==> val start: Label defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'ExpressionCodegen' @ [348:38] ==> public constructor ExpressionCodegen(@NotNull mv: MethodVisitor, @NotNull frameMap: FrameMap, @NotNull returnType: Type, @NotNull context: MethodContext, @NotNull state: GenerationState, @NotNull parentCodegen: MemberCodegen<*>) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaClassConstructorDescriptor]

'finallyNode' @ [348:56] ==> val finallyNode: MethodNode defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'codegen' @ [348:69] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'frameMap' @ [348:77] ==> public open val frameMap: FrameMap defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'codegen' @ [348:87] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'returnType' @ [348:95] ==> public final val ExpressionCodegen.returnType: (Type..Type?)[MyPropertyDescriptor]

'codegen' @ [349:56] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'getContext' @ [349:64] ==> @NotNull public open fun getContext(): MethodContext defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'codegen' @ [349:78] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'state' @ [349:86] ==> public final val ExpressionCodegen.state: GenerationState[MyPropertyDescriptor]

'codegen' @ [349:93] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'parentCodegen' @ [349:101] ==> public final val ExpressionCodegen.parentCodegen: MemberCodegen<*>[MyPropertyDescriptor]

'finallyCodegen' @ [350:17] ==> val finallyCodegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'addBlockStackElementsForNonLocalReturns' @ [350:32] ==> public open fun addBlockStackElementsForNonLocalReturns(@NotNull elements: Stack<(ExpressionCodegen.BlockStackElement..ExpressionCodegen.BlockStackElement?)>, finallyDepth: Int): Unit defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'codegen' @ [350:72] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'blockStackElements' @ [350:80] ==> public final val ExpressionCodegen.blockStackElements: (Stack<(ExpressionCodegen.BlockStackElement..ExpressionCodegen.BlockStackElement?)>..Stack<(ExpressionCodegen.BlockStackElement..ExpressionCodegen.BlockStackElement?)>?)[MyPropertyDescriptor]

'curFinallyDepth' @ [350:100] ==> var curFinallyDepth: Int defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'finallyCodegen' @ [352:32] ==> val finallyCodegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'frameMap' @ [352:47] ==> public open val frameMap: FrameMap defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaPropertyDescriptor]

'frameMap' @ [353:28] ==> val frameMap: FrameMap defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'mark' @ [353:37] ==> public open fun mark(): (FrameMap.Mark..FrameMap.Mark?) defined in org.jetbrains.kotlin.codegen.FrameMap[JavaMethodDescriptor]

'-' @ [354:30] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'processor' @ [355:33] ==> val processor: DefaultProcessor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'localVarsMetaInfo' @ [355:43] ==> public final val localVarsMetaInfo: IntervalMetaInfo<LocalVarNodeWrapper> defined in org.jetbrains.kotlin.codegen.inline.DefaultProcessor[PropertyDescriptorImpl]

'currentIntervals' @ [355:61] ==> public final val currentIntervals: MutableSet<LocalVarNodeWrapper> defined in org.jetbrains.kotlin.codegen.inline.IntervalMetaInfo[PropertyDescriptorImpl]

'intervals' @ [356:34] ==> val intervals: MutableSet<LocalVarNodeWrapper> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'marker' @ [357:21] ==> var marker: Int defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'max' @ [357:35] ==> public open fun max(p0: Int, p1: Int): Int defined in java.lang.Math[JavaMethodDescriptor]

'interval' @ [357:39] ==> val interval: LocalVarNodeWrapper defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'node' @ [357:48] ==> public final val node: LocalVariableNode defined in org.jetbrains.kotlin.codegen.inline.LocalVarNodeWrapper[PropertyDescriptorImpl]

'index' @ [357:53] ==> public final var index: Int defined in org.jetbrains.org.objectweb.asm.tree.LocalVariableNode[JavaPropertyDescriptor]

'marker' @ [357:64] ==> var marker: Int defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'frameMap' @ [359:24] ==> val frameMap: FrameMap defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'currentSize' @ [359:33] ==> public final val FrameMap.currentSize: Int[MyPropertyDescriptor]

'max' @ [359:52] ==> public open fun max(p0: Int, p1: Int): Int defined in java.lang.Math[JavaMethodDescriptor]

'processor' @ [359:56] ==> val processor: DefaultProcessor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'nextFreeLocalIndex' @ [359:66] ==> public final var nextFreeLocalIndex: Int defined in org.jetbrains.kotlin.codegen.inline.DefaultProcessor[PropertyDescriptorImpl]

'offsetForFinallyLocalVar' @ [359:86] ==> value-parameter offsetForFinallyLocalVar: Int defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[ValueParameterDescriptorImpl]

'marker' @ [359:113] ==> var marker: Int defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'frameMap' @ [360:21] ==> val frameMap: FrameMap defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'enterTemp' @ [360:30] ==> public open fun enterTemp(type: (Type..Type?)): Int defined in org.jetbrains.kotlin.codegen.FrameMap[JavaMethodDescriptor]

'INT_TYPE' @ [360:45] ==> public final val INT_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'finallyCodegen' @ [363:17] ==> val finallyCodegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'generateFinallyBlocksIfNeeded' @ [363:32] ==> public open fun generateFinallyBlocksIfNeeded(returnType: (Type..Type?), @NotNull afterReturnLabel: Label): Unit defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'extension' @ [363:62] ==> val extension: MethodInliner.PointForExternalFinallyBlocks? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'returnType' @ [363:72] ==> @JvmField public final val returnType: Type defined in org.jetbrains.kotlin.codegen.inline.MethodInliner.PointForExternalFinallyBlocks[PropertyDescriptorImpl]

'extension' @ [363:84] ==> val extension: MethodInliner.PointForExternalFinallyBlocks? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'finallyIntervalEnd' @ [363:94] ==> @JvmField public final val finallyIntervalEnd: LabelNode defined in org.jetbrains.kotlin.codegen.inline.MethodInliner.PointForExternalFinallyBlocks[PropertyDescriptorImpl]

'label' @ [363:113] ==> public final val LabelNode.label: (Label..Label?)[MyPropertyDescriptor]

'insertNodeBefore' @ [366:17] ==> internal fun insertNodeBefore(from: MethodNode, to: MethodNode, beforeNode: AbstractInsnNode): Unit defined in org.jetbrains.kotlin.codegen.inline in file inlineCodegenUtils.kt[SimpleFunctionDescriptorImpl]

'finallyNode' @ [366:34] ==> val finallyNode: MethodNode defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'intoNode' @ [366:47] ==> value-parameter intoNode: MethodNode defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[ValueParameterDescriptorImpl]

'curInstr' @ [366:57] ==> var curInstr: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'SimpleInterval' @ [368:31] ==> public constructor SimpleInterval(startLabel: LabelNode, endLabel: LabelNode) defined in org.jetbrains.kotlin.codegen.inline.SimpleInterval[ClassConstructorDescriptorImpl]

'start' @ [368:46] ==> val start: Label defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'info' @ [368:52] ==> public final var info: (Any..Any?) defined in org.jetbrains.org.objectweb.asm.Label[JavaPropertyDescriptor]

'extension' @ [368:71] ==> val extension: MethodInliner.PointForExternalFinallyBlocks? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'finallyIntervalEnd' @ [368:81] ==> @JvmField public final val finallyIntervalEnd: LabelNode defined in org.jetbrains.kotlin.codegen.inline.MethodInliner.PointForExternalFinallyBlocks[PropertyDescriptorImpl]

'processor' @ [369:17] ==> val processor: DefaultProcessor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'tryBlocksMetaInfo' @ [369:27] ==> public final val tryBlocksMetaInfo: IntervalMetaInfo<TryCatchBlockNodeInfo> defined in org.jetbrains.kotlin.codegen.inline.DefaultProcessor[PropertyDescriptorImpl]

'splitCurrentIntervals' @ [369:45] ==> public final fun splitCurrentIntervals(by: Interval, keepStart: Boolean): List<SplitPair<TryCatchBlockNodeInfo>> defined in org.jetbrains.kotlin.codegen.inline.IntervalMetaInfo[SimpleFunctionDescriptorImpl]

'splitBy' @ [369:67] ==> val splitBy: SimpleInterval defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'mark' @ [373:17] ==> val mark: (FrameMap.Mark..FrameMap.Mark?) defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'dropTo' @ [373:22] ==> public open fun dropTo(): Unit defined in org.jetbrains.kotlin.codegen.FrameMap.Mark[JavaMethodDescriptor]

'curInstr' @ [376:13] ==> var curInstr: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'curInstr' @ [376:24] ==> var curInstr: AbstractInsnNode? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'next' @ [376:33] ==> public final val AbstractInsnNode.next: (AbstractInsnNode..AbstractInsnNode?)[MyPropertyDescriptor]

'processor' @ [379:9] ==> val processor: DefaultProcessor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[LocalVariableDescriptor]

'substituteTryBlockNodes' @ [379:19] ==> public final fun substituteTryBlockNodes(node: MethodNode): Unit defined in org.jetbrains.kotlin.codegen.inline.DefaultProcessor[SimpleFunctionDescriptorImpl]

'intoNode' @ [379:43] ==> value-parameter intoNode: MethodNode defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.generateAndInsertFinallyBlocks[ValueParameterDescriptorImpl]

'isCallInsideSameModuleAsDeclared' @ [385:31] ==> public open fun isCallInsideSameModuleAsDeclared(@NotNull declarationDescriptor: CallableMemberDescriptor, @NotNull context: raw (CodegenContext<(DeclarationDescriptor..DeclarationDescriptor?)>..CodegenContext<*>), @Nullable outDirectory: File?): Boolean defined in org.jetbrains.kotlin.codegen.JvmCodegenUtil[JavaMethodDescriptor]

'functionDescriptor' @ [385:64] ==> value-parameter functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.isCallInsideSameModuleAsDeclared[ValueParameterDescriptorImpl]

'codegen' @ [385:84] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'getContext' @ [385:92] ==> @NotNull public open fun getContext(): MethodContext defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'codegen' @ [385:106] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'state' @ [385:114] ==> public final val ExpressionCodegen.state: GenerationState[MyPropertyDescriptor]

'outDirectory' @ [385:120] ==> public final val outDirectory: File? defined in org.jetbrains.kotlin.codegen.state.GenerationState[PropertyDescriptorImpl]

'isFinallyMarkerRequired' @ [388:55] ==> internal fun isFinallyMarkerRequired(context: MethodContext): Boolean defined in org.jetbrains.kotlin.codegen.inline in file inlineCodegenUtils.kt[SimpleFunctionDescriptorImpl]

'codegen' @ [388:79] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'getContext' @ [388:87] ==> @NotNull public open fun getContext(): MethodContext defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'codegen' @ [392:17] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'getContext' @ [392:25] ==> @NotNull public open fun getContext(): MethodContext defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'contextDescriptor' @ [392:38] ==> public final val MethodContext.contextDescriptor: CallableMemberDescriptor[MyPropertyDescriptor]

'codegen' @ [395:17] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'getContext' @ [395:25] ==> @NotNull public open fun getContext(): MethodContext defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'functionDescriptor' @ [395:38] ==> public final val MethodContext.functionDescriptor: FunctionDescriptor[MyPropertyDescriptor]

'codegen' @ [398:23] ==> private final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'getContext' @ [398:31] ==> @NotNull public open fun getContext(): MethodContext defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'context' @ [399:29] ==> val context: MethodContext defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.getContextLabels[LocalVariableDescriptor]

'parentContext' @ [399:37] ==> public final val MethodContext.parentContext: raw (CodegenContext<(DeclarationDescriptor..DeclarationDescriptor?)>..CodegenContext<*>)[MyPropertyDescriptor]

'if (parentContext is ClosureContext && parentContext.originalSuspendLambdaDescriptor != null) {
            parentContext.originalSuspendLambdaDescriptor!!
        }
        else context.contextDescriptor' @ [400:26] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: CallableMemberDescriptor, elseBranch: CallableMemberDescriptor): CallableMemberDescriptor[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> CallableMemberDescriptor

'parentContext' @ [400:30] ==> val parentContext: raw (CodegenContext<(DeclarationDescriptor..DeclarationDescriptor?)>..CodegenContext<*>) defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.getContextLabels[LocalVariableDescriptor]

'parentContext' @ [400:65] ==> val parentContext: raw (CodegenContext<(DeclarationDescriptor..DeclarationDescriptor?)>..CodegenContext<*>) defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.getContextLabels[LocalVariableDescriptor]

'originalSuspendLambdaDescriptor' @ [400:79] ==> public final val ClosureContext.originalSuspendLambdaDescriptor: FunctionDescriptor?[MyPropertyDescriptor]

'parentContext' @ [401:13] ==> val parentContext: raw (CodegenContext<(DeclarationDescriptor..DeclarationDescriptor?)>..CodegenContext<*>) defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.getContextLabels[LocalVariableDescriptor]

'originalSuspendLambdaDescriptor' @ [401:27] ==> public final val ClosureContext.originalSuspendLambdaDescriptor: FunctionDescriptor?[MyPropertyDescriptor]

'context' @ [403:14] ==> val context: MethodContext defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.getContextLabels[LocalVariableDescriptor]

'contextDescriptor' @ [403:22] ==> public final val MethodContext.contextDescriptor: CallableMemberDescriptor[MyPropertyDescriptor]

'InlineCodegen' @ [405:16] ==> public companion object defined in org.jetbrains.kotlin.codegen.inline.InlineCodegen[FakeCallableDescriptorForObject]

'getDeclarationLabels' @ [405:30] ==> public final fun getDeclarationLabels(lambdaOrFun: PsiElement?, descriptor: DeclarationDescriptor): Set<String> defined in org.jetbrains.kotlin.codegen.inline.InlineCodegen.Companion[SimpleFunctionDescriptorImpl]

'descriptorToDeclaration' @ [405:75] ==> @JvmStatic public final fun descriptorToDeclaration(descriptor: DeclarationDescriptor): PsiElement? defined in org.jetbrains.kotlin.resolve.DescriptorToSourceUtils[DeserializedSimpleFunctionDescriptor]

'descriptor' @ [405:99] ==> val descriptor: CallableMemberDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.getContextLabels[LocalVariableDescriptor]

'descriptor' @ [405:112] ==> val descriptor: CallableMemberDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.getContextLabels[LocalVariableDescriptor]

'context' @ [409:9] ==> private final var context: CodegenContext<*> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'getContext' @ [409:19] ==> public final fun getContext(descriptor: DeclarationDescriptor, innerDescriptor: DeclarationDescriptor, state: GenerationState, sourceFile: KtFile?, additionalInners: MutableList<ClassDescriptor>): CodegenContext<*> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion[SimpleFunctionDescriptorImpl]

'functionDescriptor' @ [409:30] ==> value-parameter functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.initializeInlineFunctionContext[ValueParameterDescriptorImpl]

'functionDescriptor' @ [409:50] ==> value-parameter functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.initializeInlineFunctionContext[ValueParameterDescriptorImpl]

'state' @ [409:70] ==> public open val state: GenerationState defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'DescriptorToSourceUtils' @ [409:77] ==> public object DescriptorToSourceUtils defined in org.jetbrains.kotlin.resolve[FakeCallableDescriptorForObject]

'descriptorToDeclaration' @ [409:101] ==> @JvmStatic public final fun descriptorToDeclaration(descriptor: DeclarationDescriptor): PsiElement? defined in org.jetbrains.kotlin.resolve.DescriptorToSourceUtils[DeserializedSimpleFunctionDescriptor]

'functionDescriptor' @ [409:125] ==> value-parameter functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.initializeInlineFunctionContext[ValueParameterDescriptorImpl]

'containingFile' @ [409:146] ==> public final val PsiElement.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'additionalInnerClasses' @ [409:173] ==> private final var additionalInnerClasses: MutableList<ClassDescriptor> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline[PropertyDescriptorImpl]

'descriptor' @ [416:17] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[ValueParameterDescriptorImpl]

'PackageContext' @ [418:24] ==> public constructor PackageContext(@NotNull contextDescriptor: PackageFragmentDescriptor, @NotNull parent: raw (CodegenContext<(DeclarationDescriptor..DeclarationDescriptor?)>..CodegenContext<*>), @Nullable packagePartType: Type?, @Nullable sourceFile: KtFile?) defined in org.jetbrains.kotlin.codegen.context.PackageContext[JavaClassConstructorDescriptor]

'descriptor' @ [418:39] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[ValueParameterDescriptorImpl]

'state' @ [418:51] ==> value-parameter state: GenerationState defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[ValueParameterDescriptorImpl]

'rootContext' @ [418:57] ==> public final val rootContext: CodegenContext<*> defined in org.jetbrains.kotlin.codegen.state.GenerationState[PropertyDescriptorImpl]

'sourceFile' @ [418:76] ==> value-parameter sourceFile: KtFile? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[ValueParameterDescriptorImpl]

'descriptor' @ [421:29] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[ValueParameterDescriptorImpl]

'containingDeclaration' @ [421:40] ==> public final val DeclarationDescriptor.containingDeclaration: DeclarationDescriptor?[MyPropertyDescriptor]

'error' @ [421:65] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'+' @ [421:71] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'descriptor' @ [421:105] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[ValueParameterDescriptorImpl]

'getContext' @ [422:26] ==> public final fun getContext(descriptor: DeclarationDescriptor, innerDescriptor: DeclarationDescriptor, state: GenerationState, sourceFile: KtFile?, additionalInners: MutableList<ClassDescriptor>): CodegenContext<*> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion[SimpleFunctionDescriptorImpl]

'container' @ [423:21] ==> val container: DeclarationDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[LocalVariableDescriptor]

'descriptor' @ [424:21] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[ValueParameterDescriptorImpl]

'state' @ [425:21] ==> value-parameter state: GenerationState defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[ValueParameterDescriptorImpl]

'sourceFile' @ [426:21] ==> value-parameter sourceFile: KtFile? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[ValueParameterDescriptorImpl]

'additionalInners' @ [427:21] ==> value-parameter additionalInners: MutableList<ClassDescriptor> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[ValueParameterDescriptorImpl]

'when (descriptor) {
                is ScriptDescriptor -> {
                    val earlierScripts = state.replSpecific.earlierScriptsForReplInterpreter
                    parent.intoScript(
                            descriptor,
                            earlierScripts ?: emptyList(),
                            descriptor as ClassDescriptor, state.typeMapper
                    )
                }
                is ClassDescriptor -> {
                    val kind =
                            if (DescriptorUtils.isInterface(descriptor) && innerDescriptor !is ClassDescriptor)
                                OwnerKind.DEFAULT_IMPLS
                            else OwnerKind.IMPLEMENTATION

                    additionalInners.addIfNotNull(
                            InnerClassConsumer.classForInnerClassRecord(descriptor, kind == OwnerKind.DEFAULT_IMPLS)
                    )
                    parent.intoClass(descriptor, kind, state)
                }
                is FunctionDescriptor -> {
                    parent.intoFunction(descriptor)
                }
                else -> {
                    throw IllegalStateException("Couldn't build context for " + descriptor)
                }
            }' @ [430:20] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: CodegenContext<*>, entry1: CodegenContext<*>, entry2: CodegenContext<*>, entry3: CodegenContext<*>): CodegenContext<*>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> CodegenContext<*>

'descriptor' @ [430:26] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[ValueParameterDescriptorImpl]

'state' @ [432:42] ==> value-parameter state: GenerationState defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[ValueParameterDescriptorImpl]

'replSpecific' @ [432:48] ==> public final val replSpecific: GenerationState.ForRepl defined in org.jetbrains.kotlin.codegen.state.GenerationState[PropertyDescriptorImpl]

'earlierScriptsForReplInterpreter' @ [432:61] ==> public final var earlierScriptsForReplInterpreter: List<ScriptDescriptor>? defined in org.jetbrains.kotlin.codegen.state.GenerationState.ForRepl[PropertyDescriptorImpl]

'parent' @ [433:21] ==> val parent: CodegenContext<*> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[LocalVariableDescriptor]

'intoScript' @ [433:28] ==> @NotNull public open fun intoScript(@NotNull script: ScriptDescriptor, @NotNull earlierScripts: (MutableList<(ScriptDescriptor..ScriptDescriptor?)>..List<(ScriptDescriptor..ScriptDescriptor?)>), @NotNull classDescriptor: ClassDescriptor, @NotNull typeMapper: KotlinTypeMapper): ScriptContext defined in org.jetbrains.kotlin.codegen.context.CodegenContext[JavaMethodDescriptor]

'descriptor' @ [434:29] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[ValueParameterDescriptorImpl]

'earlierScripts' @ [435:29] ==> val earlierScripts: List<ScriptDescriptor>? defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[LocalVariableDescriptor]

'emptyList' @ [435:47] ==> public fun <T> emptyList(): List<(ScriptDescriptor..ScriptDescriptor?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ScriptDescriptor..org.jetbrains.kotlin.descriptors.ScriptDescriptor?)

'descriptor' @ [436:29] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[ValueParameterDescriptorImpl]

'state' @ [436:60] ==> value-parameter state: GenerationState defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[ValueParameterDescriptorImpl]

'typeMapper' @ [436:66] ==> public final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.state.GenerationState[PropertyDescriptorImpl]

'if (DescriptorUtils.isInterface(descriptor) && innerDescriptor !is ClassDescriptor)
                                OwnerKind.DEFAULT_IMPLS
                            else OwnerKind.IMPLEMENTATION' @ [441:29] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: OwnerKind, elseBranch: OwnerKind): OwnerKind[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> OwnerKind

'isInterface' @ [441:49] ==> public open fun isInterface(@Nullable p0: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'descriptor' @ [441:61] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[ValueParameterDescriptorImpl]

'innerDescriptor' @ [441:76] ==> value-parameter innerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[ValueParameterDescriptorImpl]

'DEFAULT_IMPLS' @ [442:43] ==> enum entry DEFAULT_IMPLS defined in org.jetbrains.kotlin.codegen.OwnerKind[FakeCallableDescriptorForObject]

'IMPLEMENTATION' @ [443:44] ==> enum entry IMPLEMENTATION defined in org.jetbrains.kotlin.codegen.OwnerKind[FakeCallableDescriptorForObject]

'additionalInners' @ [445:21] ==> value-parameter additionalInners: MutableList<ClassDescriptor> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[ValueParameterDescriptorImpl]

'addIfNotNull' @ [445:38] ==> public fun <T : Any> MutableCollection<ClassDescriptor>.addIfNotNull(t: ClassDescriptor?): Unit defined in org.jetbrains.kotlin.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> ClassDescriptor

'classForInnerClassRecord' @ [446:48] ==> public final fun classForInnerClassRecord(descriptor: ClassDescriptor, defaultImpls: Boolean): ClassDescriptor? defined in org.jetbrains.kotlin.codegen.InnerClassConsumer.Companion[SimpleFunctionDescriptorImpl]

'descriptor' @ [446:73] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[ValueParameterDescriptorImpl]

'kind' @ [446:85] ==> val kind: OwnerKind defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[LocalVariableDescriptor]

'DEFAULT_IMPLS' @ [446:103] ==> enum entry DEFAULT_IMPLS defined in org.jetbrains.kotlin.codegen.OwnerKind[FakeCallableDescriptorForObject]

'parent' @ [448:21] ==> val parent: CodegenContext<*> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[LocalVariableDescriptor]

'intoClass' @ [448:28] ==> @NotNull public open fun intoClass(@NotNull descriptor: ClassDescriptor, @NotNull kind: OwnerKind, @NotNull state: GenerationState): ClassContext defined in org.jetbrains.kotlin.codegen.context.CodegenContext[JavaMethodDescriptor]

'descriptor' @ [448:38] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[ValueParameterDescriptorImpl]

'kind' @ [448:50] ==> val kind: OwnerKind defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[LocalVariableDescriptor]

'state' @ [448:56] ==> value-parameter state: GenerationState defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[ValueParameterDescriptorImpl]

'parent' @ [451:21] ==> val parent: CodegenContext<*> defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[LocalVariableDescriptor]

'intoFunction' @ [451:28] ==> @NotNull public open fun intoFunction(descriptor: (FunctionDescriptor..FunctionDescriptor?)): MethodContext defined in org.jetbrains.kotlin.codegen.context.CodegenContext[JavaMethodDescriptor]

'descriptor' @ [451:41] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[ValueParameterDescriptorImpl]

'IllegalStateException' @ [454:27] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'+' @ [454:49] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'descriptor' @ [454:81] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.codegen.inline.PsiSourceCompilerForInline.Companion.getContext[ValueParameterDescriptorImpl]

