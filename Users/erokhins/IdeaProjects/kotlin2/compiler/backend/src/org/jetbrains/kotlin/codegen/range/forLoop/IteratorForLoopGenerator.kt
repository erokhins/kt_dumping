'AbstractForLoopGenerator' @ [32:7] ==> public constructor AbstractForLoopGenerator(codegen: ExpressionCodegen, forExpression: KtForExpression) defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[ClassConstructorDescriptorImpl]

'codegen' @ [32:32] ==> value-parameter codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator.<init>[ValueParameterDescriptorImpl]

'forExpression' @ [32:41] ==> value-parameter forExpression: KtForExpression defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator.<init>[ValueParameterDescriptorImpl]

'forExpression' @ [40:25] ==> value-parameter forExpression: KtForExpression defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator.<init>[ValueParameterDescriptorImpl]

'loopRange' @ [40:39] ==> public final val KtForExpression.loopRange: KtExpression?[MyPropertyDescriptor]

'this' @ [41:9] ==> <this> defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[LazyClassReceiverParameterDescriptor]

'iteratorCall' @ [41:14] ==> private final val iteratorCall: ResolvedCall<FunctionDescriptor> defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'getNotNull' @ [41:29] ==> @NotNull public open fun <K : (Any..Any?), V : (Any..Any?)> getNotNull(@NotNull p0: BindingContext, @NotNull p1: ReadOnlySlice<(KtExpression..KtExpression?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>, @NotNull p2: KtExpression, @NotNull p3: String): ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)> defined in org.jetbrains.kotlin.resolve.BindingContextUtils[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedCall<(org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)>..org.jetbrains.kotlin.resolve.calls.model.ResolvedCall<(org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)>?)

'bindingContext' @ [41:40] ==> protected final val bindingContext: BindingContext defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'LOOP_RANGE_ITERATOR_RESOLVED_CALL' @ [42:40] ==> public final val LOOP_RANGE_ITERATOR_RESOLVED_CALL: (WritableSlice<(KtExpression..KtExpression?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>..WritableSlice<(KtExpression..KtExpression?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'loopRange' @ [42:75] ==> val loopRange: KtExpression defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator.<init>[LocalVariableDescriptor]

'+' @ [43:40] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'atLocation' @ [43:85] ==> public open fun atLocation(p0: (KtExpression..KtExpression?)): (String..String?) defined in org.jetbrains.kotlin.diagnostics.DiagnosticUtils[JavaMethodDescriptor]

'loopRange' @ [43:96] ==> val loopRange: KtExpression defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator.<init>[LocalVariableDescriptor]

'iteratorCall' @ [45:28] ==> private final val iteratorCall: ResolvedCall<FunctionDescriptor> defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'resultingDescriptor' @ [45:41] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>.resultingDescriptor: FunctionDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)

'returnType' @ [45:61] ==> public final val FunctionDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'this' @ [46:9] ==> <this> defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[LazyClassReceiverParameterDescriptor]

'asmTypeForIterator' @ [46:14] ==> private final val asmTypeForIterator: Type defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'codegen' @ [46:35] ==> value-parameter codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator.<init>[ValueParameterDescriptorImpl]

'asmType' @ [46:43] ==> @NotNull public open fun asmType(@NotNull type: KotlinType): Type defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'iteratorType' @ [46:51] ==> val iteratorType: KotlinType defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator.<init>[LocalVariableDescriptor]

'this' @ [48:9] ==> <this> defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[LazyClassReceiverParameterDescriptor]

'nextCall' @ [48:14] ==> private final val nextCall: ResolvedCall<FunctionDescriptor> defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'getNotNull' @ [48:25] ==> @NotNull public open fun <K : (Any..Any?), V : (Any..Any?)> getNotNull(@NotNull p0: BindingContext, @NotNull p1: ReadOnlySlice<(KtExpression..KtExpression?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>, @NotNull p2: KtExpression, @NotNull p3: String): ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)> defined in org.jetbrains.kotlin.resolve.BindingContextUtils[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedCall<(org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)>..org.jetbrains.kotlin.resolve.calls.model.ResolvedCall<(org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)>?)

'bindingContext' @ [48:36] ==> protected final val bindingContext: BindingContext defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'LOOP_RANGE_NEXT_RESOLVED_CALL' @ [49:36] ==> public final val LOOP_RANGE_NEXT_RESOLVED_CALL: (WritableSlice<(KtExpression..KtExpression?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>..WritableSlice<(KtExpression..KtExpression?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'loopRange' @ [49:67] ==> val loopRange: KtExpression defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator.<init>[LocalVariableDescriptor]

'+' @ [50:36] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'atLocation' @ [50:76] ==> public open fun atLocation(p0: (KtExpression..KtExpression?)): (String..String?) defined in org.jetbrains.kotlin.diagnostics.DiagnosticUtils[JavaMethodDescriptor]

'loopRange' @ [50:87] ==> val loopRange: KtExpression defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator.<init>[LocalVariableDescriptor]

'super' @ [54:9] ==> <this> defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[LazyClassReceiverParameterDescriptor]

'beforeLoop' @ [54:15] ==> public open fun beforeLoop(): Unit defined in org.jetbrains.kotlin.codegen.range.forLoop.AbstractForLoopGenerator[SimpleFunctionDescriptorImpl]

'iteratorVarIndex' @ [57:9] ==> private final var iteratorVarIndex: Int defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'createLoopTempVariable' @ [57:28] ==> protected final fun createLoopTempVariable(type: Type): Int defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[SimpleFunctionDescriptorImpl]

'asmTypeForIterator' @ [57:51] ==> private final val asmTypeForIterator: Type defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'local' @ [58:20] ==> @NotNull public open fun local(index: Int, @NotNull type: Type): StackValue.Local defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'iteratorVarIndex' @ [58:26] ==> private final var iteratorVarIndex: Int defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'asmTypeForIterator' @ [58:44] ==> private final val asmTypeForIterator: Type defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'store' @ [58:64] ==> public open fun store(@NotNull value: StackValue, @NotNull v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.StackValue.Local[JavaMethodDescriptor]

'codegen' @ [58:70] ==> protected final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'invokeFunction' @ [58:78] ==> @NotNull public open fun invokeFunction(@NotNull resolvedCall: ResolvedCall<*>, @NotNull receiver: StackValue): StackValue defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'iteratorCall' @ [58:93] ==> private final val iteratorCall: ResolvedCall<FunctionDescriptor> defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'none' @ [58:118] ==> public open fun none(): (StackValue..StackValue?) defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'v' @ [58:127] ==> protected final val v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'forExpression' @ [66:25] ==> public open val forExpression: KtForExpression defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'loopRange' @ [66:39] ==> public final val KtForExpression.loopRange: KtExpression?[MyPropertyDescriptor]

'getNotNull' @ [67:27] ==> @NotNull public open fun <K : (Any..Any?), V : (Any..Any?)> getNotNull(@NotNull p0: BindingContext, @NotNull p1: ReadOnlySlice<(KtExpression..KtExpression?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>, @NotNull p2: KtExpression, @NotNull p3: String): ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)> defined in org.jetbrains.kotlin.resolve.BindingContextUtils[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedCall<(org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)>..org.jetbrains.kotlin.resolve.calls.model.ResolvedCall<(org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)>?)

'codegen' @ [68:17] ==> protected final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'bindingContext' @ [68:25] ==> public final val ExpressionCodegen.bindingContext: BindingContext[MyPropertyDescriptor]

'LOOP_RANGE_HAS_NEXT_RESOLVED_CALL' @ [68:41] ==> public final val LOOP_RANGE_HAS_NEXT_RESOLVED_CALL: (WritableSlice<(KtExpression..KtExpression?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>..WritableSlice<(KtExpression..KtExpression?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'loopRange' @ [69:17] ==> val loopRange: KtExpression? defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator.checkPreCondition[LocalVariableDescriptor]

'+' @ [70:17] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'atLocation' @ [70:60] ==> public open fun atLocation(p0: (KtExpression..KtExpression?)): (String..String?) defined in org.jetbrains.kotlin.diagnostics.DiagnosticUtils[JavaMethodDescriptor]

'loopRange' @ [70:71] ==> val loopRange: KtExpression? defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator.checkPreCondition[LocalVariableDescriptor]

'codegen' @ [72:24] ==> protected final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'makeFakeCall' @ [72:32] ==> public open fun makeFakeCall(initializerAsReceiver: (ReceiverValue..ReceiverValue?)): (Call..Call?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'TransientReceiver' @ [72:45] ==> public constructor TransientReceiver(@NotNull p0: KotlinType) defined in org.jetbrains.kotlin.resolve.scopes.receivers.TransientReceiver[JavaClassConstructorDescriptor]

'iteratorCall' @ [72:63] ==> private final val iteratorCall: ResolvedCall<FunctionDescriptor> defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'resultingDescriptor' @ [72:76] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<FunctionDescriptor>.resultingDescriptor: FunctionDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'returnType' @ [72:96] ==> public final val FunctionDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'codegen' @ [73:22] ==> protected final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'invokeFunction' @ [73:30] ==> @NotNull public open fun invokeFunction(@NotNull call: Call, @NotNull resolvedCall: ResolvedCall<*>, @NotNull receiver: StackValue): StackValue defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'fakeCall' @ [73:45] ==> val fakeCall: (Call..Call?) defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator.checkPreCondition[LocalVariableDescriptor]

'hasNextCall' @ [73:55] ==> val hasNextCall: ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)> defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator.checkPreCondition[LocalVariableDescriptor]

'local' @ [73:79] ==> @NotNull public open fun local(index: Int, @NotNull type: Type): StackValue.Local defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'iteratorVarIndex' @ [73:85] ==> private final var iteratorVarIndex: Int defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'asmTypeForIterator' @ [73:103] ==> private final val asmTypeForIterator: Type defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'result' @ [74:9] ==> val result: StackValue defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator.checkPreCondition[LocalVariableDescriptor]

'put' @ [74:16] ==> public open fun put(@NotNull type: Type, @NotNull v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'BOOLEAN_TYPE' @ [74:25] ==> public final val BOOLEAN_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'v' @ [74:39] ==> protected final val v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'v' @ [76:9] ==> protected final val v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'ifeq' @ [76:11] ==> public open fun ifeq(p0: (Label..Label?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'loopExit' @ [76:16] ==> value-parameter loopExit: Label defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator.checkPreCondition[ValueParameterDescriptorImpl]

'codegen' @ [80:24] ==> protected final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'makeFakeCall' @ [80:32] ==> public open fun makeFakeCall(initializerAsReceiver: (ReceiverValue..ReceiverValue?)): (Call..Call?) defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'TransientReceiver' @ [80:45] ==> public constructor TransientReceiver(@NotNull p0: KotlinType) defined in org.jetbrains.kotlin.resolve.scopes.receivers.TransientReceiver[JavaClassConstructorDescriptor]

'iteratorCall' @ [80:63] ==> private final val iteratorCall: ResolvedCall<FunctionDescriptor> defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'resultingDescriptor' @ [80:76] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<FunctionDescriptor>.resultingDescriptor: FunctionDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'returnType' @ [80:96] ==> public final val FunctionDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'codegen' @ [81:21] ==> protected final val codegen: ExpressionCodegen defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'invokeFunction' @ [81:29] ==> @NotNull public open fun invokeFunction(@NotNull call: Call, @NotNull resolvedCall: ResolvedCall<*>, @NotNull receiver: StackValue): StackValue defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'fakeCall' @ [81:44] ==> val fakeCall: (Call..Call?) defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator.assignToLoopParameter[LocalVariableDescriptor]

'nextCall' @ [81:54] ==> private final val nextCall: ResolvedCall<FunctionDescriptor> defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'local' @ [81:75] ==> @NotNull public open fun local(index: Int, @NotNull type: Type): StackValue.Local defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'iteratorVarIndex' @ [81:81] ==> private final var iteratorVarIndex: Int defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'asmTypeForIterator' @ [81:99] ==> private final val asmTypeForIterator: Type defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'local' @ [83:20] ==> @NotNull public open fun local(index: Int, @NotNull type: Type): StackValue.Local defined in org.jetbrains.kotlin.codegen.StackValue[JavaMethodDescriptor]

'loopParameterVar' @ [83:26] ==> protected final var loopParameterVar: Int defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'loopParameterType' @ [83:44] ==> protected final lateinit var loopParameterType: Type defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

'store' @ [83:63] ==> public open fun store(@NotNull value: StackValue, @NotNull v: InstructionAdapter): Unit defined in org.jetbrains.kotlin.codegen.StackValue.Local[JavaMethodDescriptor]

'value' @ [83:69] ==> val value: StackValue defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator.assignToLoopParameter[LocalVariableDescriptor]

'v' @ [83:76] ==> protected final val v: InstructionAdapter defined in org.jetbrains.kotlin.codegen.range.forLoop.IteratorForLoopGenerator[PropertyDescriptorImpl]

