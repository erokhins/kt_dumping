'JvmStatic' @ [33:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'?:' @ [37:20] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: ResolvedCall<out CallableDescriptor>?, right: ResolvedCall<out CallableDescriptor>): ResolvedCall<out CallableDescriptor>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> ResolvedCall<out CallableDescriptor>

'expression' @ [37:21] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getDelegatePropertyIfAny[ValueParameterDescriptorImpl]

'getResolvedCall' @ [37:61] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[DeserializedSimpleFunctionDescriptor]

'bindingContext' @ [37:77] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getDelegatePropertyIfAny[ValueParameterDescriptorImpl]

'call' @ [38:39] ==> val call: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getDelegatePropertyIfAny[LocalVariableDescriptor]

'resultingDescriptor' @ [38:44] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.resultingDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'callResultingDescriptor' @ [40:13] ==> val callResultingDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getDelegatePropertyIfAny[LocalVariableDescriptor]

'containingDeclaration' @ [40:37] ==> public final val ValueParameterDescriptor.containingDeclaration: CallableDescriptor[MyPropertyDescriptor]

'callResultingDescriptor' @ [42:17] ==> val callResultingDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getDelegatePropertyIfAny[LocalVariableDescriptor]

'containingDeclaration' @ [42:41] ==> public final val ValueParameterDescriptor.containingDeclaration: CallableDescriptor[MyPropertyDescriptor]

'containingDeclaration' @ [42:63] ==> public final val CallableDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'classDescriptor' @ [42:89] ==> value-parameter classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getDelegatePropertyIfAny[ValueParameterDescriptorImpl]

'bindingContext' @ [43:24] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getDelegatePropertyIfAny[ValueParameterDescriptorImpl]

'get' @ [43:39] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(p0: (ReadOnlySlice<(ValueParameterDescriptor..ValueParameterDescriptor?), (PropertyDescriptor..PropertyDescriptor?)>..ReadOnlySlice<(ValueParameterDescriptor..ValueParameterDescriptor?), (PropertyDescriptor..PropertyDescriptor?)>?), p1: (ValueParameterDescriptor..ValueParameterDescriptor?)): PropertyDescriptor? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> ValueParameterDescriptor
    <V : (Any..Any?)> -> PropertyDescriptor

'VALUE_PARAMETER_AS_PROPERTY' @ [43:58] ==> public final val VALUE_PARAMETER_AS_PROPERTY: (WritableSlice<(ValueParameterDescriptor..ValueParameterDescriptor?), (PropertyDescriptor..PropertyDescriptor?)>..WritableSlice<(ValueParameterDescriptor..ValueParameterDescriptor?), (PropertyDescriptor..PropertyDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'callResultingDescriptor' @ [43:87] ==> val callResultingDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getDelegatePropertyIfAny[LocalVariableDescriptor]

'JvmStatic' @ [49:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'propertyDescriptor' @ [51:16] ==> value-parameter propertyDescriptor: PropertyDescriptor? defined in org.jetbrains.kotlin.backend.common.CodegenUtil.isFinalPropertyWithBackingField[ValueParameterDescriptorImpl]

'!' @ [52:16] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'propertyDescriptor' @ [52:17] ==> value-parameter propertyDescriptor: PropertyDescriptor? defined in org.jetbrains.kotlin.backend.common.CodegenUtil.isFinalPropertyWithBackingField[ValueParameterDescriptorImpl]

'isVar' @ [52:36] ==> public final val PropertyDescriptor.isVar: Boolean[MyPropertyDescriptor]

'bindingContext' @ [53:17] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.backend.common.CodegenUtil.isFinalPropertyWithBackingField[ValueParameterDescriptorImpl]

'get' @ [53:32] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(p0: (ReadOnlySlice<(PropertyDescriptor..PropertyDescriptor?), (Boolean..Boolean?)>..ReadOnlySlice<(PropertyDescriptor..PropertyDescriptor?), (Boolean..Boolean?)>?), p1: (PropertyDescriptor..PropertyDescriptor?)): Boolean? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> PropertyDescriptor
    <V : (Any..Any?)> -> Boolean

'BACKING_FIELD_REQUIRED' @ [53:51] ==> public final val BACKING_FIELD_REQUIRED: (WritableSlice<(PropertyDescriptor..PropertyDescriptor?), (Boolean..Boolean?)>..WritableSlice<(PropertyDescriptor..PropertyDescriptor?), (Boolean..Boolean?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'propertyDescriptor' @ [53:75] ==> value-parameter propertyDescriptor: PropertyDescriptor? defined in org.jetbrains.kotlin.backend.common.CodegenUtil.isFinalPropertyWithBackingField[ValueParameterDescriptorImpl]

'JvmStatic' @ [56:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'linkedMapOf' @ [58:22] ==> @SinceKotlin @InlineOnly public inline fun <K, V> linkedMapOf(): LinkedHashMap<FunctionDescriptor, FunctionDescriptor> /* = LinkedHashMap<FunctionDescriptor, FunctionDescriptor> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> FunctionDescriptor
    <V> -> FunctionDescriptor

'iterator' @ [59:29] ==> public abstract fun iterator(): MutableIterator<(DeclarationDescriptor..DeclarationDescriptor?)> defined in kotlin.collections.MutableCollection[DeserializedSimpleFunctionDescriptor]

'getAllDescriptors' @ [59:45] ==> @NotNull public open fun getAllDescriptors(@NotNull p0: MemberScope): (MutableCollection<(DeclarationDescriptor..DeclarationDescriptor?)>..Collection<(DeclarationDescriptor..DeclarationDescriptor?)>) defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'descriptor' @ [59:63] ==> value-parameter descriptor: ClassDescriptor defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getNonPrivateTraitMethods[ValueParameterDescriptorImpl]

'defaultType' @ [59:74] ==> public final val ClassDescriptor.defaultType: SimpleType[MyPropertyDescriptor]

'memberScope' @ [59:86] ==> public abstract val memberScope: MemberScope defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'declaration' @ [60:17] ==> val declaration: (DeclarationDescriptor..DeclarationDescriptor?) defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getNonPrivateTraitMethods[LocalVariableDescriptor]

'findInterfaceImplementation' @ [62:31] ==> public fun findInterfaceImplementation(descriptor: CallableMemberDescriptor): CallableMemberDescriptor? defined in org.jetbrains.kotlin.backend.common.bridges in file impl.kt[SimpleFunctionDescriptorImpl]

'declaration' @ [62:59] ==> val declaration: (DeclarationDescriptor..DeclarationDescriptor?) defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getNonPrivateTraitMethods[LocalVariableDescriptor]

'traitMember' @ [63:17] ==> val traitMember: CallableMemberDescriptor? defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getNonPrivateTraitMethods[LocalVariableDescriptor]

'isPrivate' @ [64:34] ==> public open fun isPrivate(@NotNull p0: Visibility): Boolean defined in org.jetbrains.kotlin.descriptors.Visibilities[JavaMethodDescriptor]

'traitMember' @ [64:44] ==> val traitMember: CallableMemberDescriptor? defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getNonPrivateTraitMethods[LocalVariableDescriptor]

'visibility' @ [64:56] ==> public final val CallableMemberDescriptor.visibility: Visibility[MyPropertyDescriptor]

'traitMember' @ [65:21] ==> val traitMember: CallableMemberDescriptor? defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getNonPrivateTraitMethods[LocalVariableDescriptor]

'visibility' @ [65:33] ==> public final val CallableMemberDescriptor.visibility: Visibility[MyPropertyDescriptor]

'INVISIBLE_FAKE' @ [65:60] ==> @NotNull public final val INVISIBLE_FAKE: Visibility defined in org.jetbrains.kotlin.descriptors.Visibilities[JavaPropertyDescriptor]

'assert' @ [67:13] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'traitMember' @ [67:20] ==> val traitMember: CallableMemberDescriptor? defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getNonPrivateTraitMethods[LocalVariableDescriptor]

'modality' @ [67:32] ==> public final val CallableMemberDescriptor.modality: Modality[MyPropertyDescriptor]

'Modality' @ [67:45] ==> public companion object defined in org.jetbrains.kotlin.descriptors.Modality[FakeCallableDescriptorForObject]

'ABSTRACT' @ [67:54] ==> enum entry ABSTRACT defined in org.jetbrains.kotlin.descriptors.Modality[FakeCallableDescriptorForObject]

'declaration' @ [67:110] ==> val declaration: (DeclarationDescriptor..DeclarationDescriptor?) defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getNonPrivateTraitMethods[LocalVariableDescriptor]

'result' @ [71:13] ==> val result: LinkedHashMap<FunctionDescriptor, FunctionDescriptor> /* = LinkedHashMap<FunctionDescriptor, FunctionDescriptor> */ defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getNonPrivateTraitMethods[LocalVariableDescriptor]

'putAll' @ [71:20] ==> public open fun putAll(from: Map<out FunctionDescriptor, FunctionDescriptor>): Unit defined in java.util.LinkedHashMap[JavaMethodDescriptor]

'copyFunctions' @ [71:27] ==> public final fun copyFunctions(inheritedMember: CallableMemberDescriptor, traitMember: CallableMemberDescriptor, newOwner: DeclarationDescriptor, modality: Modality, visibility: Visibility, kind: CallableMemberDescriptor.Kind, copyOverrides: Boolean): Map<FunctionDescriptor, FunctionDescriptor> defined in org.jetbrains.kotlin.backend.common.CodegenUtil[SimpleFunctionDescriptorImpl]

'declaration' @ [71:41] ==> val declaration: (DeclarationDescriptor..DeclarationDescriptor?) defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getNonPrivateTraitMethods[LocalVariableDescriptor]

'traitMember' @ [71:54] ==> val traitMember: CallableMemberDescriptor? defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getNonPrivateTraitMethods[LocalVariableDescriptor]

'declaration' @ [71:67] ==> val declaration: (DeclarationDescriptor..DeclarationDescriptor?) defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getNonPrivateTraitMethods[LocalVariableDescriptor]

'containingDeclaration' @ [71:79] ==> public final val CallableMemberDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'traitMember' @ [71:102] ==> val traitMember: CallableMemberDescriptor? defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getNonPrivateTraitMethods[LocalVariableDescriptor]

'modality' @ [71:114] ==> public final val CallableMemberDescriptor.modality: Modality[MyPropertyDescriptor]

'PUBLIC' @ [72:54] ==> @NotNull public final val PUBLIC: Visibility defined in org.jetbrains.kotlin.descriptors.Visibilities[JavaPropertyDescriptor]

'DECLARATION' @ [72:92] ==> enum entry DECLARATION defined in org.jetbrains.kotlin.descriptors.CallableMemberDescriptor.Kind[FakeCallableDescriptorForObject]

'result' @ [74:16] ==> val result: LinkedHashMap<FunctionDescriptor, FunctionDescriptor> /* = LinkedHashMap<FunctionDescriptor, FunctionDescriptor> */ defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getNonPrivateTraitMethods[LocalVariableDescriptor]

'inheritedMember' @ [86:20] ==> value-parameter inheritedMember: CallableMemberDescriptor defined in org.jetbrains.kotlin.backend.common.CodegenUtil.copyFunctions[ValueParameterDescriptorImpl]

'copy' @ [86:36] ==> @NotNull public abstract fun copy(p0: (DeclarationDescriptor..DeclarationDescriptor?), p1: (Modality..Modality?), p2: (Visibility..Visibility?), p3: (CallableMemberDescriptor.Kind..CallableMemberDescriptor.Kind?), p4: Boolean): CallableMemberDescriptor defined in org.jetbrains.kotlin.descriptors.CallableMemberDescriptor[JavaMethodDescriptor]

'newOwner' @ [86:41] ==> value-parameter newOwner: DeclarationDescriptor defined in org.jetbrains.kotlin.backend.common.CodegenUtil.copyFunctions[ValueParameterDescriptorImpl]

'modality' @ [86:51] ==> value-parameter modality: Modality defined in org.jetbrains.kotlin.backend.common.CodegenUtil.copyFunctions[ValueParameterDescriptorImpl]

'visibility' @ [86:61] ==> value-parameter visibility: Visibility defined in org.jetbrains.kotlin.backend.common.CodegenUtil.copyFunctions[ValueParameterDescriptorImpl]

'kind' @ [86:73] ==> value-parameter kind: CallableMemberDescriptor.Kind defined in org.jetbrains.kotlin.backend.common.CodegenUtil.copyFunctions[ValueParameterDescriptorImpl]

'copyOverrides' @ [86:79] ==> value-parameter copyOverrides: Boolean defined in org.jetbrains.kotlin.backend.common.CodegenUtil.copyFunctions[ValueParameterDescriptorImpl]

'linkedMapOf' @ [87:22] ==> @SinceKotlin @InlineOnly public inline fun <K, V> linkedMapOf(): LinkedHashMap<FunctionDescriptor, FunctionDescriptor> /* = LinkedHashMap<FunctionDescriptor, FunctionDescriptor> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> FunctionDescriptor
    <V> -> FunctionDescriptor

'if (traitMember is SimpleFunctionDescriptor) {
            result[traitMember] = copy as FunctionDescriptor
        }
        else if (traitMember is PropertyDescriptor) {
            for (traitAccessor in traitMember.accessors) {
                for (inheritedAccessor in (copy as PropertyDescriptor).accessors) {
                    if (inheritedAccessor::class.java == traitAccessor::class.java) { // same accessor kind
                        result.put(traitAccessor, inheritedAccessor)
                    }
                }
            }
        }' @ [88:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'traitMember' @ [88:13] ==> value-parameter traitMember: CallableMemberDescriptor defined in org.jetbrains.kotlin.backend.common.CodegenUtil.copyFunctions[ValueParameterDescriptorImpl]

'result' @ [89:13] ==> val result: LinkedHashMap<FunctionDescriptor, FunctionDescriptor> /* = LinkedHashMap<FunctionDescriptor, FunctionDescriptor> */ defined in org.jetbrains.kotlin.backend.common.CodegenUtil.copyFunctions[LocalVariableDescriptor]

'traitMember' @ [89:20] ==> value-parameter traitMember: CallableMemberDescriptor defined in org.jetbrains.kotlin.backend.common.CodegenUtil.copyFunctions[ValueParameterDescriptorImpl]

'copy' @ [89:35] ==> val copy: CallableMemberDescriptor defined in org.jetbrains.kotlin.backend.common.CodegenUtil.copyFunctions[LocalVariableDescriptor]

'traitMember' @ [91:18] ==> value-parameter traitMember: CallableMemberDescriptor defined in org.jetbrains.kotlin.backend.common.CodegenUtil.copyFunctions[ValueParameterDescriptorImpl]

'traitMember' @ [92:35] ==> value-parameter traitMember: CallableMemberDescriptor defined in org.jetbrains.kotlin.backend.common.CodegenUtil.copyFunctions[ValueParameterDescriptorImpl]

'accessors' @ [92:47] ==> public final val PropertyDescriptor.accessors: (MutableList<(PropertyAccessorDescriptor..PropertyAccessorDescriptor?)>..List<(PropertyAccessorDescriptor..PropertyAccessorDescriptor?)>)[MyPropertyDescriptor]

'iterator' @ [93:43] ==> public abstract fun iterator(): MutableIterator<(PropertyAccessorDescriptor..PropertyAccessorDescriptor?)> defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'copy' @ [93:44] ==> val copy: CallableMemberDescriptor defined in org.jetbrains.kotlin.backend.common.CodegenUtil.copyFunctions[LocalVariableDescriptor]

'accessors' @ [93:72] ==> public final val PropertyDescriptor.accessors: (MutableList<(PropertyAccessorDescriptor..PropertyAccessorDescriptor?)>..List<(PropertyAccessorDescriptor..PropertyAccessorDescriptor?)>)[MyPropertyDescriptor]

'inheritedAccessor' @ [94:25] ==> val inheritedAccessor: (PropertyAccessorDescriptor..PropertyAccessorDescriptor?) defined in org.jetbrains.kotlin.backend.common.CodegenUtil.copyFunctions[LocalVariableDescriptor]

'java' @ [94:50] ==> public val <T> KClass<out PropertyAccessorDescriptor>.java: Class<out PropertyAccessorDescriptor> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> PropertyAccessorDescriptor

'traitAccessor' @ [94:58] ==> val traitAccessor: (PropertyAccessorDescriptor..PropertyAccessorDescriptor?) defined in org.jetbrains.kotlin.backend.common.CodegenUtil.copyFunctions[LocalVariableDescriptor]

'java' @ [94:79] ==> public val <T> KClass<out PropertyAccessorDescriptor>.java: Class<out PropertyAccessorDescriptor> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> PropertyAccessorDescriptor

'result' @ [95:25] ==> val result: LinkedHashMap<FunctionDescriptor, FunctionDescriptor> /* = LinkedHashMap<FunctionDescriptor, FunctionDescriptor> */ defined in org.jetbrains.kotlin.backend.common.CodegenUtil.copyFunctions[LocalVariableDescriptor]

'put' @ [95:32] ==> public open fun put(key: FunctionDescriptor, value: FunctionDescriptor): FunctionDescriptor? defined in java.util.LinkedHashMap[JavaMethodDescriptor]

'traitAccessor' @ [95:36] ==> val traitAccessor: (PropertyAccessorDescriptor..PropertyAccessorDescriptor?) defined in org.jetbrains.kotlin.backend.common.CodegenUtil.copyFunctions[LocalVariableDescriptor]

'inheritedAccessor' @ [95:51] ==> val inheritedAccessor: (PropertyAccessorDescriptor..PropertyAccessorDescriptor?) defined in org.jetbrains.kotlin.backend.common.CodegenUtil.copyFunctions[LocalVariableDescriptor]

'result' @ [100:16] ==> val result: LinkedHashMap<FunctionDescriptor, FunctionDescriptor> /* = LinkedHashMap<FunctionDescriptor, FunctionDescriptor> */ defined in org.jetbrains.kotlin.backend.common.CodegenUtil.copyFunctions[LocalVariableDescriptor]

'JvmStatic' @ [103:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'bindingContext' @ [105:25] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getSuperClassBySuperTypeListEntry[ValueParameterDescriptorImpl]

'get' @ [105:40] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(p0: (ReadOnlySlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>..ReadOnlySlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>?), p1: (KtTypeReference..KtTypeReference?)): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> KtTypeReference
    <V : (Any..Any?)> -> KotlinType

'TYPE' @ [105:59] ==> public final val TYPE: (WritableSlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>..WritableSlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'specifier' @ [105:65] ==> value-parameter specifier: KtSuperTypeListEntry defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getSuperClassBySuperTypeListEntry[ValueParameterDescriptorImpl]

'typeReference' @ [105:75] ==> public final val KtSuperTypeListEntry.typeReference: KtTypeReference?[MyPropertyDescriptor]

'error' @ [106:28] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'specifier' @ [106:67] ==> value-parameter specifier: KtSuperTypeListEntry defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getSuperClassBySuperTypeListEntry[ValueParameterDescriptorImpl]

'text' @ [106:77] ==> public final val KtSuperTypeListEntry.text: (String..String?)[MyPropertyDescriptor]

'superType' @ [108:16] ==> val superType: KotlinType defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getSuperClassBySuperTypeListEntry[LocalVariableDescriptor]

'constructor' @ [108:26] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'declarationDescriptor' @ [108:38] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'JvmStatic' @ [111:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'statement' @ [113:20] ==> value-parameter statement: PsiElement defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getLineNumberForElement[ValueParameterDescriptorImpl]

'containingFile' @ [113:30] ==> public final val PsiElement.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'file' @ [114:13] ==> val file: (PsiFile..PsiFile?) defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getLineNumberForElement[LocalVariableDescriptor]

'file' @ [114:31] ==> val file: (PsiFile..PsiFile?) defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getLineNumberForElement[LocalVariableDescriptor]

'doNotAnalyze' @ [114:36] ==> public var KtFile.doNotAnalyze: String? defined in org.jetbrains.kotlin.psi[DeserializedPropertyDescriptor]

'statement' @ [118:13] ==> value-parameter statement: PsiElement defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getLineNumberForElement[ValueParameterDescriptorImpl]

'statement' @ [118:72] ==> value-parameter statement: PsiElement defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getLineNumberForElement[ValueParameterDescriptorImpl]

'textLength' @ [118:82] ==> public final val KtConstructorDelegationReferenceExpression.textLength: Int[MyPropertyDescriptor]

'file' @ [123:24] ==> val file: (PsiFile..PsiFile?) defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getLineNumberForElement[LocalVariableDescriptor]

'viewProvider' @ [123:29] ==> public final val PsiFile.viewProvider: FileViewProvider[MyPropertyDescriptor]

'document' @ [123:42] ==> public final val FileViewProvider.document: Document?[MyPropertyDescriptor]

'document' @ [124:16] ==> val document: Document? defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getLineNumberForElement[LocalVariableDescriptor]

'getLineNumber' @ [124:26] ==> @Contract public abstract fun getLineNumber(p0: Int): Int defined in com.intellij.openapi.editor.Document[JavaMethodDescriptor]

'if (markEndOffset) statement.textRange.endOffset else statement.textOffset' @ [124:40] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Int, elseBranch: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Int

'markEndOffset' @ [124:44] ==> value-parameter markEndOffset: Boolean defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getLineNumberForElement[ValueParameterDescriptorImpl]

'statement' @ [124:59] ==> value-parameter statement: PsiElement defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getLineNumberForElement[ValueParameterDescriptorImpl]

'textRange' @ [124:69] ==> public final val PsiElement.textRange: (TextRange..TextRange?)[MyPropertyDescriptor]

'endOffset' @ [124:79] ==> public final val TextRange.endOffset: Int[MyPropertyDescriptor]

'statement' @ [124:94] ==> value-parameter statement: PsiElement defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getLineNumberForElement[ValueParameterDescriptorImpl]

'textOffset' @ [124:104] ==> public final val PsiElement.textOffset: Int[MyPropertyDescriptor]

'plus' @ [124:117] ==> public final operator fun plus(other: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'classDescriptor' @ [137:13] ==> value-parameter classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getMemberToGenerate[ValueParameterDescriptorImpl]

'unsubstitutedMemberScope' @ [137:29] ==> public final val ClassDescriptor.unsubstitutedMemberScope: MemberScope[MyPropertyDescriptor]

'getContributedFunctions' @ [137:54] ==> public abstract fun getContributedFunctions(name: Name, location: LookupLocation): Collection<SimpleFunctionDescriptor> defined in org.jetbrains.kotlin.resolve.scopes.MemberScope[DeserializedSimpleFunctionDescriptor]

'identifier' @ [137:83] ==> @NotNull public open fun identifier(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'name' @ [137:94] ==> value-parameter name: String defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getMemberToGenerate[ValueParameterDescriptorImpl]

'FROM_BACKEND' @ [137:118] ==> enum entry FROM_BACKEND defined in org.jetbrains.kotlin.incremental.components.NoLookupLocation[FakeCallableDescriptorForObject]

'singleOrNull' @ [138:22] ==> public inline fun <T> Iterable<SimpleFunctionDescriptor>.singleOrNull(predicate: (SimpleFunctionDescriptor) -> Boolean): SimpleFunctionDescriptor? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SimpleFunctionDescriptor

'function' @ [139:25] ==> value-parameter function: SimpleFunctionDescriptor defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getMemberToGenerate.<anonymous>[ValueParameterDescriptorImpl]

'kind' @ [139:34] ==> public final val SimpleFunctionDescriptor.kind: CallableMemberDescriptor.Kind[MyPropertyDescriptor]

'let' @ [139:39] ==> @InlineOnly public inline fun <T, R> CallableMemberDescriptor.Kind.let(block: (CallableMemberDescriptor.Kind) -> Boolean): Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Kind
    <R> -> Boolean

'kind' @ [139:53] ==> value-parameter kind: CallableMemberDescriptor.Kind defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getMemberToGenerate.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'SYNTHESIZED' @ [139:91] ==> enum entry SYNTHESIZED defined in org.jetbrains.kotlin.descriptors.CallableMemberDescriptor.Kind[FakeCallableDescriptorForObject]

'kind' @ [139:106] ==> value-parameter kind: CallableMemberDescriptor.Kind defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getMemberToGenerate.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'FAKE_OVERRIDE' @ [139:144] ==> enum entry FAKE_OVERRIDE defined in org.jetbrains.kotlin.descriptors.CallableMemberDescriptor.Kind[FakeCallableDescriptorForObject]

'function' @ [140:25] ==> value-parameter function: SimpleFunctionDescriptor defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getMemberToGenerate.<anonymous>[ValueParameterDescriptorImpl]

'modality' @ [140:34] ==> public final val SimpleFunctionDescriptor.modality: Modality[MyPropertyDescriptor]

'Modality' @ [140:46] ==> public companion object defined in org.jetbrains.kotlin.descriptors.Modality[FakeCallableDescriptorForObject]

'FINAL' @ [140:55] ==> enum entry FINAL defined in org.jetbrains.kotlin.descriptors.Modality[FakeCallableDescriptorForObject]

'invoke' @ [141:25] ==> public abstract operator fun invoke(p1: List<ValueParameterDescriptor>): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'function' @ [141:41] ==> value-parameter function: SimpleFunctionDescriptor defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getMemberToGenerate.<anonymous>[ValueParameterDescriptorImpl]

'valueParameters' @ [141:50] ==> public final val SimpleFunctionDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'function' @ [142:25] ==> value-parameter function: SimpleFunctionDescriptor defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getMemberToGenerate.<anonymous>[ValueParameterDescriptorImpl]

'returnType' @ [142:34] ==> public final val SimpleFunctionDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'invoke' @ [143:25] ==> public abstract operator fun invoke(p1: KotlinType): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'function' @ [143:40] ==> value-parameter function: SimpleFunctionDescriptor defined in org.jetbrains.kotlin.backend.common.CodegenUtil.getMemberToGenerate.<anonymous>[ValueParameterDescriptorImpl]

'returnType' @ [143:49] ==> public final val SimpleFunctionDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'JvmStatic' @ [147:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'if (isStatement && !whenExpression.isUsedAsExpression(this)) {
            BindingContext.IMPLICIT_EXHAUSTIVE_WHEN
        }
        else {
            BindingContext.EXHAUSTIVE_WHEN
        }' @ [149:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (WritableSlice<(KtWhenExpression..KtWhenExpression?), (Boolean..Boolean?)>..WritableSlice<(KtWhenExpression..KtWhenExpression?), (Boolean..Boolean?)>?), elseBranch: (WritableSlice<(KtWhenExpression..KtWhenExpression?), (Boolean..Boolean?)>..WritableSlice<(KtWhenExpression..KtWhenExpression?), (Boolean..Boolean?)>?)): (WritableSlice<(KtWhenExpression..KtWhenExpression?), (Boolean..Boolean?)>..WritableSlice<(KtWhenExpression..KtWhenExpression?), (Boolean..Boolean?)>?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (org.jetbrains.kotlin.util.slicedMap.WritableSlice<(org.jetbrains.kotlin.psi.KtWhenExpression..org.jetbrains.kotlin.psi.KtWhenExpression?), (kotlin.Boolean..kotlin.Boolean?)>..org.jetbrains.kotlin.util.slicedMap.WritableSlice<(org.jetbrains.kotlin.psi.KtWhenExpression..org.jetbrains.kotlin.psi.KtWhenExpression?), (kotlin.Boolean..kotlin.Boolean?)>?)

'isStatement' @ [149:25] ==> value-parameter isStatement: Boolean defined in org.jetbrains.kotlin.backend.common.CodegenUtil.isExhaustive[ValueParameterDescriptorImpl]

'!' @ [149:40] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'whenExpression' @ [149:41] ==> value-parameter whenExpression: KtWhenExpression defined in org.jetbrains.kotlin.backend.common.CodegenUtil.isExhaustive[ValueParameterDescriptorImpl]

'isUsedAsExpression' @ [149:56] ==> public fun KtExpression.isUsedAsExpression(context: BindingContext): Boolean defined in org.jetbrains.kotlin.resolve.bindingContextUtil[DeserializedSimpleFunctionDescriptor]

'this' @ [149:75] ==> <this> defined in org.jetbrains.kotlin.backend.common.CodegenUtil.isExhaustive[ReceiverParameterDescriptorImpl]

'IMPLICIT_EXHAUSTIVE_WHEN' @ [150:28] ==> public final val IMPLICIT_EXHAUSTIVE_WHEN: (WritableSlice<(KtWhenExpression..KtWhenExpression?), (Boolean..Boolean?)>..WritableSlice<(KtWhenExpression..KtWhenExpression?), (Boolean..Boolean?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'EXHAUSTIVE_WHEN' @ [153:28] ==> public final val EXHAUSTIVE_WHEN: (WritableSlice<(KtWhenExpression..KtWhenExpression?), (Boolean..Boolean?)>..WritableSlice<(KtWhenExpression..KtWhenExpression?), (Boolean..Boolean?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'this' @ [155:16] ==> <this> defined in org.jetbrains.kotlin.backend.common.CodegenUtil.isExhaustive[ReceiverParameterDescriptorImpl]

'slice' @ [155:21] ==> val slice: (WritableSlice<(KtWhenExpression..KtWhenExpression?), (Boolean..Boolean?)>..WritableSlice<(KtWhenExpression..KtWhenExpression?), (Boolean..Boolean?)>?) defined in org.jetbrains.kotlin.backend.common.CodegenUtil.isExhaustive[LocalVariableDescriptor]

'whenExpression' @ [155:28] ==> value-parameter whenExpression: KtWhenExpression defined in org.jetbrains.kotlin.backend.common.CodegenUtil.isExhaustive[ValueParameterDescriptorImpl]

'JvmStatic' @ [158:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'StringBuilder' @ [160:32] ==> public final fun <init>(p0: (String..String?)): StringBuilder /* = StringBuilder */ defined in kotlin.text.StringBuilder[TypeAliasConstructorDescriptorImpl]

'fakeFunctionCall' @ [161:9] ==> val fakeFunctionCall: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.backend.common.CodegenUtil.constructFakeFunctionCall[LocalVariableDescriptor]

'append' @ [161:26] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'referencedFunction' @ [161:33] ==> value-parameter referencedFunction: FunctionDescriptor defined in org.jetbrains.kotlin.backend.common.CodegenUtil.constructFakeFunctionCall[ValueParameterDescriptorImpl]

'valueParameters' @ [161:52] ==> public final val FunctionDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'joinToString' @ [161:68] ==> public fun <T> Iterable<(ValueParameterDescriptor..ValueParameterDescriptor?)>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: (((ValueParameterDescriptor..ValueParameterDescriptor?)) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)

'it' @ [161:93] ==> value-parameter it: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.backend.common.CodegenUtil.constructFakeFunctionCall.<anonymous>[ValueParameterDescriptorImpl]

'index' @ [161:96] ==> public abstract val index: Int defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'fakeFunctionCall' @ [162:9] ==> val fakeFunctionCall: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.backend.common.CodegenUtil.constructFakeFunctionCall[LocalVariableDescriptor]

'append' @ [162:26] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'KtPsiFactory' @ [163:16] ==> @JvmOverloads public constructor KtPsiFactory(project: Project, markGenerated: Boolean = ...) defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedClassConstructorDescriptor]

'project' @ [163:29] ==> value-parameter project: Project defined in org.jetbrains.kotlin.backend.common.CodegenUtil.constructFakeFunctionCall[ValueParameterDescriptorImpl]

'createExpression' @ [163:61] ==> public final fun createExpression(text: String): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'fakeFunctionCall' @ [163:78] ==> val fakeFunctionCall: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.backend.common.CodegenUtil.constructFakeFunctionCall[LocalVariableDescriptor]

'toString' @ [163:95] ==> public open fun toString(): String defined in java.lang.StringBuilder[JavaMethodDescriptor]

