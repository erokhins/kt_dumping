'values' @ [58:55] ==> public final fun values(): Array<ControlStructureTypingUtils.ResolveConstruct> defined in org.jetbrains.kotlin.types.expressions.ControlStructureTypingUtils.ResolveConstruct[SimpleFunctionDescriptorImpl]

'map' @ [58:64] ==> public inline fun <T, R> Array<out ControlStructureTypingUtils.ResolveConstruct>.map(transform: (ControlStructureTypingUtils.ResolveConstruct) -> (Name..Name?)): List<(Name..Name?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ResolveConstruct
    <R> -> (org.jetbrains.kotlin.name.Name..org.jetbrains.kotlin.name.Name?)

'it' @ [58:70] ==> value-parameter it: ControlStructureTypingUtils.ResolveConstruct defined in org.jetbrains.kotlin.resolve.calls.SPECIAL_FUNCTION_NAMES.<anonymous>[ValueParameterDescriptorImpl]

'specialFunctionName' @ [58:73] ==> public final val ControlStructureTypingUtils.ResolveConstruct.specialFunctionName: (Name..Name?)[MyPropertyDescriptor]

'toSet' @ [58:95] ==> public fun <T> Iterable<(Name..Name?)>.toSet(): Set<(Name..Name?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.name.Name..org.jetbrains.kotlin.name.Name?)

'context' @ [65:29] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[ValueParameterDescriptorImpl]

'candidateCall' @ [65:37] ==> @NotNull public final val candidateCall: MutableResolvedCall<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaPropertyDescriptor]

'candidateCall' @ [66:25] ==> val candidateCall: MutableResolvedCall<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'candidateDescriptor' @ [66:39] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> MutableResolvedCall<(D..D?)>.candidateDescriptor: (D..D?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (D..D?)

'ConstraintSystemBuilderImpl' @ [68:23] ==> public constructor ConstraintSystemBuilderImpl(mode: ConstraintSystemBuilderImpl.Mode = ...) defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl[ClassConstructorDescriptorImpl]

'builder' @ [69:9] ==> val builder: ConstraintSystemBuilderImpl defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'registerTypeVariables' @ [69:17] ==> public open fun registerTypeVariables(call: CallHandle, typeParameters: Collection<TypeParameterDescriptor>, external: Boolean): TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl[SimpleFunctionDescriptorImpl]

'candidateCall' @ [69:39] ==> val candidateCall: MutableResolvedCall<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'call' @ [69:53] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> MutableResolvedCall<(D..D?)>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (D..D?)

'toHandle' @ [69:58] ==> public fun Call.toHandle(): CallHandle defined in org.jetbrains.kotlin.resolve.calls.inference in file TypeVariable.kt[SimpleFunctionDescriptorImpl]

'candidate' @ [69:70] ==> val candidate: (D..D?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'typeParameters' @ [69:80] ==> public final val CallableDescriptor.typeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'makeConstantSubstitutor' @ [71:34] ==> public fun makeConstantSubstitutor(typeParameterDescriptors: Collection<TypeParameterDescriptor>, type: KotlinType): TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls[SimpleFunctionDescriptorImpl]

'candidate' @ [71:58] ==> val candidate: (D..D?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'typeParameters' @ [71:68] ==> public final val CallableDescriptor.typeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'DONT_CARE' @ [71:84] ==> public final val DONT_CARE: (SimpleType..SimpleType?) defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'component1' @ [74:15] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>.component1(): (ValueParameterDescriptor..ValueParameterDescriptor?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)
    <V> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument..org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument?)

'component2' @ [74:35] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>.component2(): (ResolvedValueArgument..ResolvedValueArgument?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)
    <V> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument..org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument?)

'candidateCall' @ [74:61] ==> val candidateCall: MutableResolvedCall<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'valueArguments' @ [74:75] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> MutableResolvedCall<(D..D?)>.valueArguments: (MutableMap<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>..Map<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (D..D?)

'candidate' @ [75:44] ==> val candidate: (D..D?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'valueParameters' @ [75:54] ==> public final val CallableDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'candidateParameter' @ [75:70] ==> val candidateParameter: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'index' @ [75:89] ==> public abstract val index: Int defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'resolvedValueArgument' @ [77:35] ==> val resolvedValueArgument: (ResolvedValueArgument..ResolvedValueArgument?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'arguments' @ [77:57] ==> public final val ResolvedValueArgument.arguments: (MutableList<(ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>)[MyPropertyDescriptor]

'addConstraintForValueArgument' @ [83:17] ==> private final fun addConstraintForValueArgument(valueArgument: ValueArgument, valueParameterDescriptor: ValueParameterDescriptor, substitutor: TypeSubstitutor, builder: ConstraintSystem.Builder, context: CallCandidateResolutionContext<*>, resolveFunctionArgumentBodies: ResolveArgumentsMode): Unit defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver[SimpleFunctionDescriptorImpl]

'valueArgument' @ [84:25] ==> val valueArgument: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'valueParameterDescriptor' @ [84:40] ==> val valueParameterDescriptor: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'substituteDontCare' @ [84:66] ==> val substituteDontCare: TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'builder' @ [84:86] ==> val builder: ConstraintSystemBuilderImpl defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'context' @ [84:95] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[ValueParameterDescriptorImpl]

'SHAPE_FUNCTION_ARGUMENTS' @ [84:104] ==> enum entry SHAPE_FUNCTION_ARGUMENTS defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.ResolveArgumentsMode[FakeCallableDescriptorForObject]

'candidate' @ [89:13] ==> val candidate: (D..D?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'builder' @ [90:41] ==> val builder: ConstraintSystemBuilderImpl defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'compositeSubstitutor' @ [90:49] ==> private final fun ConstraintSystem.Builder.compositeSubstitutor(): TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver[SimpleFunctionDescriptorImpl]

'safeSubstitute' @ [90:72] ==> @NotNull public open fun safeSubstitute(@NotNull p0: KotlinType, @NotNull p1: Variance): KotlinType defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'candidate' @ [90:87] ==> val candidate: (D..D?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'returnType' @ [90:97] ==> public final val TypeAliasConstructorDescriptor.returnType: KotlinType[MyPropertyDescriptor]

'INVARIANT' @ [90:118] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'addValidityConstraintsForConstituentTypes' @ [91:13] ==> private final fun addValidityConstraintsForConstituentTypes(builder: ConstraintSystem.Builder, type: KotlinType): Unit defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver[SimpleFunctionDescriptorImpl]

'builder' @ [91:55] ==> val builder: ConstraintSystemBuilderImpl defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'substitutedReturnType' @ [91:64] ==> val substitutedReturnType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'candidateCall' @ [96:32] ==> val candidateCall: MutableResolvedCall<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'extensionReceiver' @ [96:46] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> MutableResolvedCall<(D..D?)>.extensionReceiver: ReceiverValue?[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (D..D?)

'candidate' @ [97:33] ==> val candidate: (D..D?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'extensionReceiverParameter' @ [97:43] ==> public final val CallableDescriptor.extensionReceiverParameter: ReceiverParameterDescriptor?[MyPropertyDescriptor]

'receiverArgument' @ [98:13] ==> val receiverArgument: ReceiverValue? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'receiverParameter' @ [98:41] ==> val receiverParameter: ReceiverParameterDescriptor? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'receiverArgument' @ [99:40] ==> val receiverArgument: ReceiverValue? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'type' @ [99:57] ==> public final val ReceiverValue.type: KotlinType[MyPropertyDescriptor]

'if (context.candidateCall.call.isSafeCall())
                TypeUtils.makeNotNullable(receiverArgumentType)
            else
                receiverArgumentType' @ [100:45] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType?, elseBranch: KotlinType?): KotlinType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType?

'context' @ [100:49] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[ValueParameterDescriptorImpl]

'candidateCall' @ [100:57] ==> @NotNull public final val candidateCall: MutableResolvedCall<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaPropertyDescriptor]

'call' @ [100:71] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> MutableResolvedCall<(D..D?)>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (D..D?)

'isSafeCall' @ [100:76] ==> public fun Call.isSafeCall(): Boolean defined in org.jetbrains.kotlin.resolve.calls.callUtil in file callUtil.kt[SimpleFunctionDescriptorImpl]

'makeNotNullable' @ [101:27] ==> @NotNull public open fun makeNotNullable(@NotNull p0: KotlinType): KotlinType defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'receiverArgumentType' @ [101:43] ==> val receiverArgumentType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'receiverArgumentType' @ [103:17] ==> val receiverArgumentType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'receiverArgument' @ [104:17] ==> val receiverArgument: ReceiverValue? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'receiverType' @ [105:17] ==> var receiverType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'updateResultTypeForSmartCasts' @ [105:32] ==> private final fun updateResultTypeForSmartCasts(type: KotlinType?, argumentExpression: KtExpression?, context: ResolutionContext<*>): KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver[SimpleFunctionDescriptorImpl]

'receiverType' @ [105:62] ==> var receiverType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'receiverArgument' @ [105:76] ==> val receiverArgument: ReceiverValue? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'expression' @ [105:93] ==> public abstract val expression: KtExpression defined in org.jetbrains.kotlin.resolve.scopes.receivers.ExpressionReceiver[PropertyDescriptorImpl]

'context' @ [105:105] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[ValueParameterDescriptorImpl]

'builder' @ [107:13] ==> val builder: ConstraintSystemBuilderImpl defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'addSubtypeConstraint' @ [107:21] ==> public open fun addSubtypeConstraint(constrainingType: KotlinType?, subjectType: KotlinType?, constraintPosition: ConstraintPosition): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl[SimpleFunctionDescriptorImpl]

'receiverType' @ [108:21] ==> var receiverType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'builder' @ [109:21] ==> val builder: ConstraintSystemBuilderImpl defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'compositeSubstitutor' @ [109:29] ==> private final fun ConstraintSystem.Builder.compositeSubstitutor(): TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver[SimpleFunctionDescriptorImpl]

'substitute' @ [109:52] ==> @Nullable public open fun substitute(@NotNull p0: KotlinType, @NotNull p1: Variance): KotlinType? defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'receiverParameter' @ [109:63] ==> val receiverParameter: ReceiverParameterDescriptor? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'type' @ [109:81] ==> public final val ReceiverParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'INVARIANT' @ [109:96] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'RECEIVER_POSITION' @ [110:21] ==> enum entry RECEIVER_POSITION defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPositionKind[FakeCallableDescriptorForObject]

'position' @ [110:39] ==> public final fun position(): ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPositionKind[SimpleFunctionDescriptorImpl]

'builder' @ [114:32] ==> val builder: ConstraintSystemBuilderImpl defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'build' @ [114:40] ==> public open fun build(): ConstraintSystem defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl[SimpleFunctionDescriptorImpl]

'candidateCall' @ [115:9] ==> val candidateCall: MutableResolvedCall<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'setConstraintSystem' @ [115:23] ==> public abstract fun setConstraintSystem(@NotNull constraintSystem: ConstraintSystem): Unit defined in org.jetbrains.kotlin.resolve.calls.model.MutableResolvedCall[JavaMethodDescriptor]

'constraintSystem' @ [115:43] ==> val constraintSystem: ConstraintSystem defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'constraintSystem' @ [118:32] ==> val constraintSystem: ConstraintSystem defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'status' @ [118:49] ==> public abstract val status: ConstraintSystemStatus defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem[PropertyDescriptorImpl]

'hasContradiction' @ [118:56] ==> public abstract fun hasContradiction(): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemStatus[SimpleFunctionDescriptorImpl]

'!' @ [119:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'hasContradiction' @ [119:14] ==> val hasContradiction: Boolean defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.inferTypeArguments[LocalVariableDescriptor]

'INCOMPLETE_TYPE_INFERENCE' @ [120:20] ==> enum entry INCOMPLETE_TYPE_INFERENCE defined in org.jetbrains.kotlin.resolve.calls.results.ResolutionStatus[FakeCallableDescriptorForObject]

'OTHER_ERROR' @ [122:16] ==> enum entry OTHER_ERROR defined in org.jetbrains.kotlin.resolve.calls.results.ResolutionStatus[FakeCallableDescriptorForObject]

'type' @ [126:31] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForConstituentTypes[ValueParameterDescriptorImpl]

'constructor' @ [126:36] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'typeConstructor' @ [127:13] ==> val typeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForConstituentTypes[LocalVariableDescriptor]

'declarationDescriptor' @ [127:29] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'create' @ [129:49] ==> @NotNull public open fun create(@NotNull p0: KotlinType): TypeSubstitutor defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'type' @ [129:56] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForConstituentTypes[ValueParameterDescriptorImpl]

'type' @ [131:9] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForConstituentTypes[ValueParameterDescriptorImpl]

'arguments' @ [131:14] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'forEachIndexed' @ [131:24] ==> public inline fun <T> Iterable<TypeProjection>.forEachIndexed(action: (index: Int, TypeProjection) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection

'typeProjection' @ [132:17] ==> value-parameter typeProjection: TypeProjection defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForConstituentTypes.<anonymous>[ValueParameterDescriptorImpl]

'isStarProjection' @ [132:32] ==> public final val TypeProjection.isStarProjection: Boolean[MyPropertyDescriptor]

'typeConstructor' @ [134:33] ==> val typeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForConstituentTypes[LocalVariableDescriptor]

'parameters' @ [134:49] ==> public final val TypeConstructor.parameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'i' @ [134:60] ==> value-parameter i: Int defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForConstituentTypes.<anonymous>[ValueParameterDescriptorImpl]

'addValidityConstraintsForTypeArgument' @ [135:13] ==> private final fun addValidityConstraintsForTypeArgument(builder: ConstraintSystem.Builder, substitutedArgument: TypeProjection, typeParameter: TypeParameterDescriptor, boundsSubstitutor: TypeSubstitutor): Unit defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver[SimpleFunctionDescriptorImpl]

'builder' @ [135:51] ==> value-parameter builder: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForConstituentTypes[ValueParameterDescriptorImpl]

'typeProjection' @ [135:60] ==> value-parameter typeProjection: TypeProjection defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForConstituentTypes.<anonymous>[ValueParameterDescriptorImpl]

'typeParameter' @ [135:76] ==> val typeParameter: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForConstituentTypes.<anonymous>[LocalVariableDescriptor]

'boundsSubstitutor' @ [135:91] ==> val boundsSubstitutor: TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForConstituentTypes[LocalVariableDescriptor]

'addValidityConstraintsForConstituentTypes' @ [137:13] ==> private final fun addValidityConstraintsForConstituentTypes(builder: ConstraintSystem.Builder, type: KotlinType): Unit defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver[SimpleFunctionDescriptorImpl]

'builder' @ [137:55] ==> value-parameter builder: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForConstituentTypes[ValueParameterDescriptorImpl]

'typeProjection' @ [137:64] ==> value-parameter typeProjection: TypeProjection defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForConstituentTypes.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [137:79] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'substitutedArgument' @ [147:31] ==> value-parameter substitutedArgument: TypeProjection defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForTypeArgument[ValueParameterDescriptorImpl]

'type' @ [147:51] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'typeParameter' @ [148:28] ==> value-parameter typeParameter: TypeParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForTypeArgument[ValueParameterDescriptorImpl]

'upperBounds' @ [148:42] ==> public final val TypeParameterDescriptor.upperBounds: (MutableList<(KotlinType..KotlinType?)>..List<(KotlinType..KotlinType?)>)[MyPropertyDescriptor]

'boundsSubstitutor' @ [149:41] ==> value-parameter boundsSubstitutor: TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForTypeArgument[ValueParameterDescriptorImpl]

'safeSubstitute' @ [149:59] ==> @NotNull public open fun safeSubstitute(@NotNull p0: KotlinType, @NotNull p1: Variance): KotlinType defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'upperBound' @ [149:74] ==> val upperBound: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForTypeArgument[LocalVariableDescriptor]

'INVARIANT' @ [149:95] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'upperIfFlexible' @ [149:106] ==> public fun KotlinType.upperIfFlexible(): SimpleType defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'ValidityConstraintForConstituentType' @ [150:38] ==> public constructor ValidityConstraintForConstituentType(typeArgument: KotlinType, typeParameter: TypeParameterDescriptor, bound: KotlinType) defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ValidityConstraintForConstituentType[ClassConstructorDescriptorImpl]

'substitutedType' @ [150:75] ==> val substitutedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForTypeArgument[LocalVariableDescriptor]

'typeParameter' @ [150:92] ==> value-parameter typeParameter: TypeParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForTypeArgument[ValueParameterDescriptorImpl]

'substitutedUpperBound' @ [150:107] ==> val substitutedUpperBound: SimpleType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForTypeArgument[LocalVariableDescriptor]

'isNullableAny' @ [154:32] ==> public open fun isNullableAny(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'substitutedUpperBound' @ [154:46] ==> val substitutedUpperBound: SimpleType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForTypeArgument[LocalVariableDescriptor]

'builder' @ [156:13] ==> value-parameter builder: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForTypeArgument[ValueParameterDescriptorImpl]

'addSubtypeConstraint' @ [156:21] ==> public abstract fun addSubtypeConstraint(constrainingType: KotlinType?, subjectType: KotlinType?, constraintPosition: ConstraintPosition): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem.Builder[SimpleFunctionDescriptorImpl]

'substitutedType' @ [156:42] ==> val substitutedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForTypeArgument[LocalVariableDescriptor]

'substitutedUpperBound' @ [156:59] ==> val substitutedUpperBound: SimpleType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForTypeArgument[LocalVariableDescriptor]

'constraintPosition' @ [156:82] ==> val constraintPosition: ValidityConstraintForConstituentType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addValidityConstraintsForTypeArgument[LocalVariableDescriptor]

'create' @ [163:32] ==> @NotNull public open fun create(@NotNull p0: TypeSubstitution): TypeSubstitutor defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'TypeSubstitution' @ [163:48] ==> public constructor TypeSubstitution() defined in org.jetbrains.kotlin.types.TypeSubstitution[DeserializedClassConstructorDescriptor]

'typeVariableSubstitutors' @ [165:24] ==> public abstract val typeVariableSubstitutors: Map<CallHandle, TypeSubstitutor> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem.Builder[PropertyDescriptorImpl]

'values' @ [165:49] ==> public abstract val values: Collection<TypeSubstitutor> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'reversed' @ [165:56] ==> public fun <T> Iterable<TypeSubstitutor>.reversed(): List<TypeSubstitutor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeSubstitutor

'asSequence' @ [165:67] ==> public fun <T> Iterable<TypeSubstitutor>.asSequence(): Sequence<TypeSubstitutor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeSubstitutor

'mapNotNull' @ [165:80] ==> public fun <T, R : Any> Sequence<TypeSubstitutor>.mapNotNull(transform: (TypeSubstitutor) -> TypeProjection?): Sequence<TypeProjection> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeSubstitutor
    <R : Any> -> TypeProjection

'it' @ [165:93] ==> value-parameter it: TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.compositeSubstitutor.<no name provided>.get.<anonymous>[ValueParameterDescriptorImpl]

'substitution' @ [165:96] ==> public final val TypeSubstitutor.substitution: TypeSubstitution[MyPropertyDescriptor]

'get' @ [165:109] ==> public abstract operator fun get(key: KotlinType): TypeProjection? defined in org.jetbrains.kotlin.types.TypeSubstitution[DeserializedSimpleFunctionDescriptor]

'key' @ [165:113] ==> value-parameter key: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.compositeSubstitutor.<no name provided>.get[ValueParameterDescriptorImpl]

'firstOrNull' @ [165:120] ==> public fun <T> Sequence<TypeProjection>.firstOrNull(): TypeProjection? defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection

'getEffectiveExpectedType' @ [178:37] ==> public fun getEffectiveExpectedType(parameterDescriptor: ValueParameterDescriptor, argument: ValueArgument): KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil in file CallResolverUtil.kt[SimpleFunctionDescriptorImpl]

'valueParameterDescriptor' @ [178:62] ==> value-parameter valueParameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[ValueParameterDescriptorImpl]

'valueArgument' @ [178:88] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[ValueParameterDescriptorImpl]

'valueArgument' @ [179:34] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[ValueParameterDescriptorImpl]

'getArgumentExpression' @ [179:48] ==> @IfNotParsed public abstract fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.ValueArgument[SimpleFunctionDescriptorImpl]

'substitutor' @ [181:28] ==> value-parameter substitutor: TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[ValueParameterDescriptorImpl]

'substitute' @ [181:40] ==> @Nullable public open fun substitute(@NotNull p0: KotlinType, @NotNull p1: Variance): KotlinType? defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'effectiveExpectedType' @ [181:51] ==> val effectiveExpectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[LocalVariableDescriptor]

'INVARIANT' @ [181:83] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'context' @ [182:39] ==> value-parameter context: CallCandidateResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[ValueParameterDescriptorImpl]

'candidateCall' @ [182:47] ==> @NotNull public final val candidateCall: MutableResolvedCall<out (CallableDescriptor..CallableDescriptor?)> defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaPropertyDescriptor]

'dataFlowInfoForArguments' @ [182:61] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> MutableResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.dataFlowInfoForArguments: MutableDataFlowInfoForArguments[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'getInfo' @ [182:86] ==> @NotNull public abstract fun getInfo(@NotNull valueArgument: ValueArgument): DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.model.MutableDataFlowInfoForArguments[JavaMethodDescriptor]

'valueArgument' @ [182:94] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[ValueParameterDescriptorImpl]

'context' @ [183:26] ==> value-parameter context: CallCandidateResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[ValueParameterDescriptorImpl]

'replaceExpectedType' @ [183:34] ==> @NotNull public open fun replaceExpectedType(@Nullable newExpectedType: KotlinType?): CallCandidateResolutionContext<out (CallableDescriptor..CallableDescriptor?)> defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaMethodDescriptor]

'expectedType' @ [183:54] ==> val expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[LocalVariableDescriptor]

'replaceDataFlowInfo' @ [183:68] ==> @NotNull public open fun replaceDataFlowInfo(@NotNull newDataFlowInfo: DataFlowInfo): CallCandidateResolutionContext<out (CallableDescriptor..CallableDescriptor?)> defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaMethodDescriptor]

'dataFlowInfoForArgument' @ [183:88] ==> val dataFlowInfoForArgument: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[LocalVariableDescriptor]

'argumentTypeResolver' @ [185:31] ==> private final val argumentTypeResolver: ArgumentTypeResolver defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver[PropertyDescriptorImpl]

'getArgumentTypeInfo' @ [185:52] ==> @NotNull public open fun getArgumentTypeInfo(@Nullable expression: KtExpression?, @NotNull context: CallResolutionContext<*>, @NotNull resolveArgumentsMode: ResolveArgumentsMode): KotlinTypeInfo defined in org.jetbrains.kotlin.resolve.calls.ArgumentTypeResolver[JavaMethodDescriptor]

'argumentExpression' @ [185:72] ==> val argumentExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[LocalVariableDescriptor]

'newContext' @ [185:92] ==> val newContext: CallCandidateResolutionContext<out (CallableDescriptor..CallableDescriptor?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[LocalVariableDescriptor]

'resolveFunctionArgumentBodies' @ [185:104] ==> value-parameter resolveFunctionArgumentBodies: ResolveArgumentsMode defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[ValueParameterDescriptorImpl]

'context' @ [186:9] ==> value-parameter context: CallCandidateResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[ValueParameterDescriptorImpl]

'candidateCall' @ [186:17] ==> @NotNull public final val candidateCall: MutableResolvedCall<out (CallableDescriptor..CallableDescriptor?)> defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaPropertyDescriptor]

'dataFlowInfoForArguments' @ [186:31] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> MutableResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.dataFlowInfoForArguments: MutableDataFlowInfoForArguments[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'updateInfo' @ [186:56] ==> public abstract fun updateInfo(@NotNull valueArgument: ValueArgument, @NotNull dataFlowInfo: DataFlowInfo): Unit defined in org.jetbrains.kotlin.resolve.calls.model.MutableDataFlowInfoForArguments[JavaMethodDescriptor]

'valueArgument' @ [186:67] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[ValueParameterDescriptorImpl]

'typeInfoForCall' @ [186:82] ==> val typeInfoForCall: KotlinTypeInfo defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[LocalVariableDescriptor]

'dataFlowInfo' @ [186:98] ==> public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.types.expressions.KotlinTypeInfo[PropertyDescriptorImpl]

'VALUE_PARAMETER_POSITION' @ [188:34] ==> enum entry VALUE_PARAMETER_POSITION defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPositionKind[FakeCallableDescriptorForObject]

'position' @ [188:59] ==> public final fun position(index: Int): ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPositionKind[SimpleFunctionDescriptorImpl]

'valueParameterDescriptor' @ [188:68] ==> value-parameter valueParameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[ValueParameterDescriptorImpl]

'index' @ [188:93] ==> public abstract val index: Int defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'addConstraintForNestedCall' @ [190:13] ==> private final fun addConstraintForNestedCall(argumentExpression: KtExpression?, constraintPosition: ConstraintPosition, builder: ConstraintSystem.Builder, context: CallCandidateResolutionContext<*>, effectiveExpectedType: KotlinType): Boolean defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver[SimpleFunctionDescriptorImpl]

'argumentExpression' @ [190:40] ==> val argumentExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[LocalVariableDescriptor]

'constraintPosition' @ [190:60] ==> val constraintPosition: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[LocalVariableDescriptor]

'builder' @ [190:80] ==> value-parameter builder: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[ValueParameterDescriptorImpl]

'newContext' @ [190:89] ==> val newContext: CallCandidateResolutionContext<out (CallableDescriptor..CallableDescriptor?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[LocalVariableDescriptor]

'effectiveExpectedType' @ [190:101] ==> val effectiveExpectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[LocalVariableDescriptor]

'updateResultTypeForSmartCasts' @ [192:20] ==> private final fun updateResultTypeForSmartCasts(type: KotlinType?, argumentExpression: KtExpression?, context: ResolutionContext<*>): KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver[SimpleFunctionDescriptorImpl]

'typeInfoForCall' @ [192:50] ==> val typeInfoForCall: KotlinTypeInfo defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[LocalVariableDescriptor]

'type' @ [192:66] ==> public final val type: KotlinType? defined in org.jetbrains.kotlin.types.expressions.KotlinTypeInfo[PropertyDescriptorImpl]

'argumentExpression' @ [192:72] ==> val argumentExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[LocalVariableDescriptor]

'context' @ [192:92] ==> value-parameter context: CallCandidateResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[ValueParameterDescriptorImpl]

'replaceDataFlowInfo' @ [192:100] ==> @NotNull public open fun replaceDataFlowInfo(@NotNull newDataFlowInfo: DataFlowInfo): CallCandidateResolutionContext<out (CallableDescriptor..CallableDescriptor?)> defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaMethodDescriptor]

'dataFlowInfoForArgument' @ [192:120] ==> val dataFlowInfoForArgument: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[LocalVariableDescriptor]

'argumentExpression' @ [194:13] ==> val argumentExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[LocalVariableDescriptor]

'type' @ [194:68] ==> val type: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[LocalVariableDescriptor]

'builder' @ [196:9] ==> value-parameter builder: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[ValueParameterDescriptorImpl]

'addSubtypeConstraint' @ [196:17] ==> public abstract fun addSubtypeConstraint(constrainingType: KotlinType?, subjectType: KotlinType?, constraintPosition: ConstraintPosition): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem.Builder[SimpleFunctionDescriptorImpl]

'type' @ [197:17] ==> val type: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[LocalVariableDescriptor]

'builder' @ [198:17] ==> value-parameter builder: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[ValueParameterDescriptorImpl]

'compositeSubstitutor' @ [198:25] ==> private final fun ConstraintSystem.Builder.compositeSubstitutor(): TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver[SimpleFunctionDescriptorImpl]

'substitute' @ [198:48] ==> @Nullable public open fun substitute(@NotNull p0: KotlinType, @NotNull p1: Variance): KotlinType? defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'effectiveExpectedType' @ [198:59] ==> val effectiveExpectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[LocalVariableDescriptor]

'INVARIANT' @ [198:91] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'constraintPosition' @ [199:17] ==> val constraintPosition: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForValueArgument[LocalVariableDescriptor]

'getResolutionResultsCachedData' @ [210:33] ==> public fun getResolutionResultsCachedData(expression: KtExpression?, context: ResolutionContext<*>): ResolutionResultsCache.CachedData? defined in org.jetbrains.kotlin.resolve.calls in file GenericCandidateResolver.kt[SimpleFunctionDescriptorImpl]

'argumentExpression' @ [210:64] ==> value-parameter argumentExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[ValueParameterDescriptorImpl]

'context' @ [210:84] ==> value-parameter context: CallCandidateResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[ValueParameterDescriptorImpl]

'resolutionResults' @ [210:94] ==> public final val resolutionResults: OverloadResolutionResultsImpl<*> defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionResultsCache.CachedData[PropertyDescriptorImpl]

'resolutionResults' @ [211:13] ==> val resolutionResults: OverloadResolutionResultsImpl<*>? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[LocalVariableDescriptor]

'!' @ [211:42] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'resolutionResults' @ [211:43] ==> val resolutionResults: OverloadResolutionResultsImpl<*>? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[LocalVariableDescriptor]

'isSingleResult' @ [211:61] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResultsImpl<out (CallableDescriptor..CallableDescriptor?)>.isSingleResult: Boolean[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'resolutionResults' @ [213:26] ==> val resolutionResults: OverloadResolutionResultsImpl<*>? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[LocalVariableDescriptor]

'resultingCall' @ [213:44] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResultsImpl<out (CallableDescriptor..CallableDescriptor?)>.resultingCall: MutableResolvedCall<out (CallableDescriptor..CallableDescriptor?)>[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'nestedCall' @ [214:13] ==> val nestedCall: MutableResolvedCall<out (CallableDescriptor..CallableDescriptor?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[LocalVariableDescriptor]

'isCompleted' @ [214:24] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> MutableResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.isCompleted: Boolean[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'nestedCall' @ [216:38] ==> val nestedCall: MutableResolvedCall<out (CallableDescriptor..CallableDescriptor?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[LocalVariableDescriptor]

'constraintSystem' @ [216:49] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> MutableResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.constraintSystem: ConstraintSystem?[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'nestedCall' @ [218:35] ==> val nestedCall: MutableResolvedCall<out (CallableDescriptor..CallableDescriptor?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[LocalVariableDescriptor]

'candidateDescriptor' @ [218:46] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> MutableResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.candidateDescriptor: (CallableDescriptor..CallableDescriptor?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'candidateDescriptor' @ [219:26] ==> val candidateDescriptor: (CallableDescriptor..CallableDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[LocalVariableDescriptor]

'returnType' @ [219:46] ==> public final val CallableDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'nestedConstraintSystem' @ [221:35] ==> val nestedConstraintSystem: ConstraintSystem defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[LocalVariableDescriptor]

'getNestedTypeVariables' @ [221:58] ==> public fun ConstraintSystem.getNestedTypeVariables(type: KotlinType): List<TypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference[SimpleFunctionDescriptorImpl]

'returnType' @ [221:81] ==> val returnType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[LocalVariableDescriptor]

'nestedTypeVariables' @ [225:13] ==> val nestedTypeVariables: List<TypeVariable> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[LocalVariableDescriptor]

'any' @ [225:33] ==> public inline fun <T> Iterable<TypeVariable>.any(predicate: (TypeVariable) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeVariable

'nestedConstraintSystem' @ [225:39] ==> val nestedConstraintSystem: ConstraintSystem defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[LocalVariableDescriptor]

'getTypeBounds' @ [225:62] ==> public abstract fun getTypeBounds(typeVariable: TypeVariable): TypeBounds defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem[SimpleFunctionDescriptorImpl]

'it' @ [225:76] ==> value-parameter it: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall.<anonymous>[ValueParameterDescriptorImpl]

'bounds' @ [225:80] ==> public abstract val bounds: Collection<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds[PropertyDescriptorImpl]

'isNotEmpty' @ [225:87] ==> @InlineOnly public inline fun <T> Collection<TypeBounds.Bound>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Bound

'alphaConvertTypeParameters' @ [227:66] ==> @SuppressWarnings public open fun <D : (CallableDescriptor..CallableDescriptor?)> alphaConvertTypeParameters(candidate: (CallableDescriptor..CallableDescriptor?)): (CallableDescriptor..CallableDescriptor?) defined in org.jetbrains.kotlin.resolve.FunctionDescriptorUtil[JavaMethodDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'candidateDescriptor' @ [227:93] ==> val candidateDescriptor: (CallableDescriptor..CallableDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[LocalVariableDescriptor]

'candidateDescriptor' @ [228:26] ==> val candidateDescriptor: (CallableDescriptor..CallableDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[LocalVariableDescriptor]

'typeParameters' @ [228:46] ==> public final val CallableDescriptor.typeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'zip' @ [228:61] ==> public infix fun <T, R> Iterable<(TypeParameterDescriptor..TypeParameterDescriptor?)>.zip(other: Iterable<(TypeParameterDescriptor..TypeParameterDescriptor?)>): List<Pair<(TypeParameterDescriptor..TypeParameterDescriptor?), (TypeParameterDescriptor..TypeParameterDescriptor?)>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)
    <R> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)

'candidateWithFreshVariables' @ [228:65] ==> val candidateWithFreshVariables: (CallableDescriptor..CallableDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[LocalVariableDescriptor]

'typeParameters' @ [228:93] ==> public final val CallableDescriptor.typeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'toMap' @ [228:109] ==> public fun <K, V> Iterable<Pair<(TypeParameterDescriptor..TypeParameterDescriptor?), (TypeParameterDescriptor..TypeParameterDescriptor?)>>.toMap(): Map<(TypeParameterDescriptor..TypeParameterDescriptor?), (TypeParameterDescriptor..TypeParameterDescriptor?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)
    <V> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)

'returnType' @ [230:30] ==> val returnType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[LocalVariableDescriptor]

'getNestedTypeParameters' @ [230:41] ==> internal fun KotlinType.getNestedTypeParameters(): List<TypeParameterDescriptor> defined in org.jetbrains.kotlin.resolve.calls.inference[SimpleFunctionDescriptorImpl]

'mapNotNull' @ [230:67] ==> public inline fun <T, R : Any> Iterable<TypeParameterDescriptor>.mapNotNull(transform: (TypeParameterDescriptor) -> TypeParameterDescriptor?): List<TypeParameterDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeParameterDescriptor
    <R : Any> -> TypeParameterDescriptor

'conversion' @ [230:80] ==> val conversion: Map<(TypeParameterDescriptor..TypeParameterDescriptor?), (TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[LocalVariableDescriptor]

'it' @ [230:91] ==> value-parameter it: TypeParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall.<anonymous>[ValueParameterDescriptorImpl]

'builder' @ [231:9] ==> value-parameter builder: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[ValueParameterDescriptorImpl]

'registerTypeVariables' @ [231:17] ==> public abstract fun registerTypeVariables(call: CallHandle, typeParameters: Collection<TypeParameterDescriptor>, external: Boolean = ...): TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem.Builder[SimpleFunctionDescriptorImpl]

'nestedCall' @ [231:39] ==> val nestedCall: MutableResolvedCall<out (CallableDescriptor..CallableDescriptor?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[LocalVariableDescriptor]

'call' @ [231:50] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> MutableResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'toHandle' @ [231:55] ==> public fun Call.toHandle(): CallHandle defined in org.jetbrains.kotlin.resolve.calls.inference in file TypeVariable.kt[SimpleFunctionDescriptorImpl]

'freshVariables' @ [231:67] ==> val freshVariables: List<TypeParameterDescriptor> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[LocalVariableDescriptor]

'nestedCall' @ [233:38] ==> val nestedCall: MutableResolvedCall<out (CallableDescriptor..CallableDescriptor?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[LocalVariableDescriptor]

'makeNullableTypeIfSafeReceiver' @ [233:49] ==> public fun ResolvedCall<*>.makeNullableTypeIfSafeReceiver(type: KotlinType?, context: CallResolutionContext<*>): KotlinType? defined in org.jetbrains.kotlin.resolve.calls.resolvedCallUtil[SimpleFunctionDescriptorImpl]

'candidateWithFreshVariables' @ [233:80] ==> val candidateWithFreshVariables: (CallableDescriptor..CallableDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[LocalVariableDescriptor]

'returnType' @ [233:108] ==> public final val CallableDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'context' @ [233:120] ==> value-parameter context: CallCandidateResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[ValueParameterDescriptorImpl]

'builder' @ [235:9] ==> value-parameter builder: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[ValueParameterDescriptorImpl]

'addSubtypeConstraint' @ [235:17] ==> public abstract fun addSubtypeConstraint(constrainingType: KotlinType?, subjectType: KotlinType?, constraintPosition: ConstraintPosition): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem.Builder[SimpleFunctionDescriptorImpl]

'argumentExpressionType' @ [236:17] ==> val argumentExpressionType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[LocalVariableDescriptor]

'builder' @ [237:17] ==> value-parameter builder: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[ValueParameterDescriptorImpl]

'compositeSubstitutor' @ [237:25] ==> private final fun ConstraintSystem.Builder.compositeSubstitutor(): TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver[SimpleFunctionDescriptorImpl]

'substitute' @ [237:48] ==> @Nullable public open fun substitute(@NotNull p0: KotlinType, @NotNull p1: Variance): KotlinType? defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'effectiveExpectedType' @ [237:59] ==> value-parameter effectiveExpectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[ValueParameterDescriptorImpl]

'INVARIANT' @ [237:91] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'constraintPosition' @ [238:17] ==> value-parameter constraintPosition: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForNestedCall[ValueParameterDescriptorImpl]

'getLastElementDeparenthesized' @ [249:49] ==> @Nullable public open fun getLastElementDeparenthesized(@Nullable expression: KtExpression?, @NotNull statementFilter: StatementFilter): KtExpression? defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'argumentExpression' @ [249:79] ==> value-parameter argumentExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.updateResultTypeForSmartCasts[ValueParameterDescriptorImpl]

'context' @ [249:99] ==> value-parameter context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.updateResultTypeForSmartCasts[ValueParameterDescriptorImpl]

'statementFilter' @ [249:107] ==> @NotNull public final val statementFilter: StatementFilter defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'deparenthesizedArgument' @ [250:13] ==> val deparenthesizedArgument: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.updateResultTypeForSmartCasts[LocalVariableDescriptor]

'type' @ [250:48] ==> value-parameter type: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.updateResultTypeForSmartCasts[ValueParameterDescriptorImpl]

'type' @ [250:69] ==> value-parameter type: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.updateResultTypeForSmartCasts[ValueParameterDescriptorImpl]

'DataFlowValueFactory' @ [252:29] ==> public object DataFlowValueFactory defined in org.jetbrains.kotlin.resolve.calls.smartcasts in file DataFlowValueFactory.kt[FakeCallableDescriptorForObject]

'createDataFlowValue' @ [252:50] ==> @JvmStatic public final fun createDataFlowValue(expression: KtExpression, type: KotlinType, resolutionContext: ResolutionContext<*>): DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValueFactory[SimpleFunctionDescriptorImpl]

'deparenthesizedArgument' @ [252:70] ==> val deparenthesizedArgument: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.updateResultTypeForSmartCasts[LocalVariableDescriptor]

'type' @ [252:95] ==> value-parameter type: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.updateResultTypeForSmartCasts[ValueParameterDescriptorImpl]

'context' @ [252:101] ==> value-parameter context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.updateResultTypeForSmartCasts[ValueParameterDescriptorImpl]

'!' @ [253:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'dataFlowValue' @ [253:14] ==> val dataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.updateResultTypeForSmartCasts[LocalVariableDescriptor]

'isStable' @ [253:28] ==> public final val isStable: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'type' @ [253:45] ==> value-parameter type: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.updateResultTypeForSmartCasts[ValueParameterDescriptorImpl]

'context' @ [255:29] ==> value-parameter context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.updateResultTypeForSmartCasts[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [255:37] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'getCollectedTypes' @ [255:50] ==> public abstract fun getCollectedTypes(key: DataFlowValue): Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo[SimpleFunctionDescriptorImpl]

'dataFlowValue' @ [255:68] ==> val dataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.updateResultTypeForSmartCasts[LocalVariableDescriptor]

'possibleTypes' @ [256:13] ==> val possibleTypes: Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.updateResultTypeForSmartCasts[LocalVariableDescriptor]

'isEmpty' @ [256:27] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.Set[DeserializedSimpleFunctionDescriptor]

'type' @ [256:45] ==> value-parameter type: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.updateResultTypeForSmartCasts[ValueParameterDescriptorImpl]

'intersectTypes' @ [258:32] ==> @Nullable public open fun intersectTypes(@NotNull typeChecker: KotlinTypeChecker, @NotNull types: (MutableCollection<(KotlinType..KotlinType?)>..Collection<(KotlinType..KotlinType?)>)): KotlinType? defined in org.jetbrains.kotlin.types.TypeIntersector[JavaMethodDescriptor]

'DEFAULT' @ [258:65] ==> public final val DEFAULT: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaPropertyDescriptor]

'possibleTypes' @ [258:74] ==> val possibleTypes: Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.updateResultTypeForSmartCasts[LocalVariableDescriptor]

'type' @ [258:90] ==> value-parameter type: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.updateResultTypeForSmartCasts[ValueParameterDescriptorImpl]

'context' @ [262:28] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[ValueParameterDescriptorImpl]

'candidateCall' @ [262:36] ==> @NotNull public final val candidateCall: MutableResolvedCall<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaPropertyDescriptor]

'resolvedCall' @ [263:32] ==> val resolvedCall: MutableResolvedCall<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'constraintSystem' @ [263:45] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> MutableResolvedCall<(D..D?)>.constraintSystem: ConstraintSystem?[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (D..D?)

'toBuilder' @ [263:63] ==> public abstract fun toBuilder(filterConstraintPosition: (ConstraintPosition) -> Boolean = ...): ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem[SimpleFunctionDescriptorImpl]

'if (resolvedCall is VariableAsFunctionResolvedCall) {
            CallCandidateResolutionContext.create(
                    resolvedCall, context, context.trace, context.tracing, resolvedCall.functionCall.call, context.candidateResolveMode)
        } else {
            context
        }' @ [267:26] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (CallCandidateResolutionContext<D>..CallCandidateResolutionContext<D>?), elseBranch: (CallCandidateResolutionContext<D>..CallCandidateResolutionContext<D>?)): (CallCandidateResolutionContext<D>..CallCandidateResolutionContext<D>?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext<D>..org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext<D>?)

'resolvedCall' @ [267:30] ==> val resolvedCall: MutableResolvedCall<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'create' @ [268:44] ==> public open fun <D : (CallableDescriptor..CallableDescriptor?)> create(@NotNull candidateCall: MutableResolvedCall<(D..D?)>, @NotNull context: CallResolutionContext<*>, @NotNull trace: BindingTrace, @NotNull tracing: TracingStrategy, @NotNull call: Call, @NotNull candidateResolveMode: CandidateResolveMode): (CallCandidateResolutionContext<(D..D?)>..CallCandidateResolutionContext<(D..D?)>?) defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaMethodDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> D

'resolvedCall' @ [269:21] ==> val resolvedCall: MutableResolvedCall<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'context' @ [269:35] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[ValueParameterDescriptorImpl]

'context' @ [269:44] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[ValueParameterDescriptorImpl]

'trace' @ [269:52] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaPropertyDescriptor]

'context' @ [269:59] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[ValueParameterDescriptorImpl]

'tracing' @ [269:67] ==> @NotNull public final val tracing: TracingStrategy defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaPropertyDescriptor]

'resolvedCall' @ [269:76] ==> val resolvedCall: MutableResolvedCall<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'functionCall' @ [269:89] ==> public abstract val functionCall: ResolvedCall<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.calls.model.VariableAsFunctionResolvedCall[PropertyDescriptorImpl]

'call' @ [269:102] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<FunctionDescriptor>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'context' @ [269:108] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[ValueParameterDescriptorImpl]

'candidateResolveMode' @ [269:116] ==> @NotNull public final val candidateResolveMode: CandidateResolveMode defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaPropertyDescriptor]

'context' @ [271:13] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[ValueParameterDescriptorImpl]

'component1' @ [276:15] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>.component1(): (ValueParameterDescriptor..ValueParameterDescriptor?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)
    <V> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument..org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument?)

'component2' @ [276:41] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>.component2(): (ResolvedValueArgument..ResolvedValueArgument?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)
    <V> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument..org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument?)

'resolvedCall' @ [276:67] ==> val resolvedCall: MutableResolvedCall<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'valueArguments' @ [276:80] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> MutableResolvedCall<(D..D?)>.valueArguments: (MutableMap<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>..Map<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (D..D?)

'resolvedValueArgument' @ [277:35] ==> val resolvedValueArgument: (ResolvedValueArgument..ResolvedValueArgument?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'arguments' @ [277:57] ==> public final val ResolvedValueArgument.arguments: (MutableList<(ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>)[MyPropertyDescriptor]

'valueArgument' @ [278:17] ==> val valueArgument: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'getArgumentExpression' @ [278:31] ==> @IfNotParsed public abstract fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.ValueArgument[SimpleFunctionDescriptorImpl]

'let' @ [278:56] ==> @InlineOnly public inline fun <T, R> KtExpression.let(block: (KtExpression) -> Unit?): Unit? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression
    <R> -> Unit?

'getFunctionLiteralArgumentIfAny' @ [279:42] ==> @Nullable public open fun getFunctionLiteralArgumentIfAny(@NotNull expression: KtExpression, @NotNull context: raw (ResolutionContext<(ResolutionContext<*>..ResolutionContext<*>?)>..ResolutionContext<out (ResolutionContext<*>..ResolutionContext<*>?)>)): KtFunction? defined in org.jetbrains.kotlin.resolve.calls.ArgumentTypeResolver[JavaMethodDescriptor]

'argumentExpression' @ [279:74] ==> value-parameter argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall.<anonymous>[ValueParameterDescriptorImpl]

'newContext' @ [279:94] ==> val newContext: (CallCandidateResolutionContext<D>..CallCandidateResolutionContext<D>?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'let' @ [279:107] ==> @InlineOnly public inline fun <T, R> KtFunction.let(block: (KtFunction) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtFunction
    <R> -> Unit

'addConstraintForFunctionLiteralArgument' @ [280:25] ==> private final fun <D : CallableDescriptor> addConstraintForFunctionLiteralArgument(functionLiteral: KtFunction, valueArgument: ValueArgument, valueParameterDescriptor: ValueParameterDescriptor, constraintSystem: ConstraintSystem.Builder, context: CallCandidateResolutionContext<D>, argumentOwnerReturnType: KotlinType?): Unit defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver[SimpleFunctionDescriptorImpl]
Inferred types:
    <D : CallableDescriptor> -> D

'functionLiteral' @ [280:65] ==> value-parameter functionLiteral: KtFunction defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'valueArgument' @ [280:82] ==> val valueArgument: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'valueParameterDescriptor' @ [280:97] ==> val valueParameterDescriptor: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'constraintSystem' @ [280:123] ==> val constraintSystem: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'newContext' @ [280:141] ==> val newContext: (CallCandidateResolutionContext<D>..CallCandidateResolutionContext<D>?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'resolvedCall' @ [281:65] ==> val resolvedCall: MutableResolvedCall<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'candidateDescriptor' @ [281:78] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> MutableResolvedCall<(D..D?)>.candidateDescriptor: (D..D?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (D..D?)

'returnType' @ [281:98] ==> public final val CallableDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'if (resolvedCall.candidateDescriptor.name in SPECIAL_FUNCTION_NAMES) {
                        newContext
                    }
                    else {
                        val temporaryBindingTrace = TemporaryBindingTrace.create(
                                newContext.trace, "Trace to complete argument for call that might be not resulting call")
                        newContext.replaceBindingTrace(temporaryBindingTrace)
                    }' @ [289:51] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (CallCandidateResolutionContext<D>..CallCandidateResolutionContext<D>?), elseBranch: (CallCandidateResolutionContext<D>..CallCandidateResolutionContext<D>?)): (CallCandidateResolutionContext<D>..CallCandidateResolutionContext<D>?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext<D>..org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext<D>?)

'resolvedCall' @ [289:55] ==> val resolvedCall: MutableResolvedCall<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'candidateDescriptor' @ [289:68] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> MutableResolvedCall<(D..D?)>.candidateDescriptor: (D..D?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (D..D?)

'name' @ [289:88] ==> public final val CallableDescriptor.name: Name[MyPropertyDescriptor]

'SPECIAL_FUNCTION_NAMES' @ [289:96] ==> private val SPECIAL_FUNCTION_NAMES: Set<(Name..Name?)> defined in org.jetbrains.kotlin.resolve.calls in file GenericCandidateResolver.kt[PropertyDescriptorImpl]

'newContext' @ [290:25] ==> val newContext: (CallCandidateResolutionContext<D>..CallCandidateResolutionContext<D>?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'create' @ [293:75] ==> @NotNull public open fun create(@NotNull trace: BindingTrace, debugName: (String..String?)): TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.TemporaryBindingTrace[JavaMethodDescriptor]

'newContext' @ [294:33] ==> val newContext: (CallCandidateResolutionContext<D>..CallCandidateResolutionContext<D>?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'trace' @ [294:44] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaPropertyDescriptor]

'newContext' @ [295:25] ==> val newContext: (CallCandidateResolutionContext<D>..CallCandidateResolutionContext<D>?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'replaceBindingTrace' @ [295:36] ==> @NotNull public open fun replaceBindingTrace(@NotNull trace: BindingTrace): CallCandidateResolutionContext<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaMethodDescriptor]

'temporaryBindingTrace' @ [295:56] ==> val temporaryBindingTrace: TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall.<anonymous>[LocalVariableDescriptor]

'getCallableReferenceExpressionIfAny' @ [298:42] ==> @Nullable public open fun getCallableReferenceExpressionIfAny(@NotNull expression: KtExpression, @NotNull context: raw (ResolutionContext<(ResolutionContext<*>..ResolutionContext<*>?)>..ResolutionContext<out (ResolutionContext<*>..ResolutionContext<*>?)>)): KtCallableReferenceExpression? defined in org.jetbrains.kotlin.resolve.calls.ArgumentTypeResolver[JavaMethodDescriptor]

'argumentExpression' @ [298:78] ==> value-parameter argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall.<anonymous>[ValueParameterDescriptorImpl]

'newContext' @ [298:98] ==> val newContext: (CallCandidateResolutionContext<D>..CallCandidateResolutionContext<D>?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'let' @ [298:111] ==> @InlineOnly public inline fun <T, R> KtCallableReferenceExpression.let(block: (KtCallableReferenceExpression) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtCallableReferenceExpression
    <R> -> Unit

'addConstraintForCallableReference' @ [299:25] ==> private final fun <D : CallableDescriptor> addConstraintForCallableReference(callableReference: KtCallableReferenceExpression, valueArgument: ValueArgument, valueParameterDescriptor: ValueParameterDescriptor, constraintSystem: ConstraintSystem.Builder, context: CallCandidateResolutionContext<D>): Unit defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver[SimpleFunctionDescriptorImpl]
Inferred types:
    <D : CallableDescriptor> -> D

'callableReference' @ [300:33] ==> value-parameter callableReference: KtCallableReferenceExpression defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'valueArgument' @ [301:33] ==> val valueArgument: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'valueParameterDescriptor' @ [302:33] ==> val valueParameterDescriptor: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'constraintSystem' @ [303:33] ==> val constraintSystem: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'temporaryContextForCall' @ [304:33] ==> val temporaryContextForCall: (CallCandidateResolutionContext<D>..CallCandidateResolutionContext<D>?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall.<anonymous>[LocalVariableDescriptor]

'constraintSystem' @ [309:31] ==> val constraintSystem: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'build' @ [309:48] ==> public abstract fun build(): ConstraintSystem defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem.Builder[SimpleFunctionDescriptorImpl]

'resolvedCall' @ [310:9] ==> val resolvedCall: MutableResolvedCall<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'setConstraintSystem' @ [310:22] ==> public abstract fun setConstraintSystem(@NotNull constraintSystem: ConstraintSystem): Unit defined in org.jetbrains.kotlin.resolve.calls.model.MutableResolvedCall[JavaMethodDescriptor]

'resultingSystem' @ [310:42] ==> val resultingSystem: ConstraintSystem defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'resolvedCall' @ [311:9] ==> val resolvedCall: MutableResolvedCall<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'setResultingSubstitutor' @ [311:22] ==> public abstract fun setResultingSubstitutor(@NotNull substitutor: TypeSubstitutor): Unit defined in org.jetbrains.kotlin.resolve.calls.model.MutableResolvedCall[JavaMethodDescriptor]

'resultingSystem' @ [311:46] ==> val resultingSystem: ConstraintSystem defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.completeTypeInferenceDependentOnFunctionArgumentsForCall[LocalVariableDescriptor]

'resultingSubstitutor' @ [311:62] ==> public abstract val resultingSubstitutor: TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem[PropertyDescriptorImpl]

'if (!TypeUtils.noExpectedType(context.expectedType) &&
            ownerReturnType != null &&
            TypeUtils.isTypeParameter(ownerReturnType) &&
            literalExpectedType.isFunctionTypeOrSubtype &&
            getReturnTypeForCallable(literalExpectedType) == ownerReturnType)
        context.expectedType
    else DONT_CARE' @ [322:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (KotlinType..KotlinType?), elseBranch: (KotlinType..KotlinType?)): (KotlinType..KotlinType?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)

'!' @ [322:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'noExpectedType' @ [322:24] ==> public open fun noExpectedType(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'context' @ [322:39] ==> value-parameter context: CallCandidateResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.estimateLiteralReturnType[ValueParameterDescriptorImpl]

'expectedType' @ [322:47] ==> @NotNull public final val expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaPropertyDescriptor]

'ownerReturnType' @ [323:13] ==> value-parameter ownerReturnType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.estimateLiteralReturnType[ValueParameterDescriptorImpl]

'isTypeParameter' @ [324:23] ==> public open fun isTypeParameter(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'ownerReturnType' @ [324:39] ==> value-parameter ownerReturnType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.estimateLiteralReturnType[ValueParameterDescriptorImpl]

'literalExpectedType' @ [325:13] ==> value-parameter literalExpectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.estimateLiteralReturnType[ValueParameterDescriptorImpl]

'isFunctionTypeOrSubtype' @ [325:33] ==> public val KotlinType.isFunctionTypeOrSubtype: Boolean defined in org.jetbrains.kotlin.builtins[DeserializedPropertyDescriptor]

'getReturnTypeForCallable' @ [326:13] ==> public fun getReturnTypeForCallable(type: KotlinType): KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil[SimpleFunctionDescriptorImpl]

'literalExpectedType' @ [326:38] ==> value-parameter literalExpectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.estimateLiteralReturnType[ValueParameterDescriptorImpl]

'ownerReturnType' @ [326:62] ==> value-parameter ownerReturnType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.estimateLiteralReturnType[ValueParameterDescriptorImpl]

'context' @ [327:9] ==> value-parameter context: CallCandidateResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.estimateLiteralReturnType[ValueParameterDescriptorImpl]

'expectedType' @ [327:17] ==> @NotNull public final val expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaPropertyDescriptor]

'DONT_CARE' @ [328:10] ==> public final val DONT_CARE: (SimpleType..SimpleType?) defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'valueArgument' @ [338:34] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'getArgumentExpression' @ [338:48] ==> @IfNotParsed public abstract fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.ValueArgument[SimpleFunctionDescriptorImpl]

'getEffectiveExpectedType' @ [340:37] ==> public fun getEffectiveExpectedType(parameterDescriptor: ValueParameterDescriptor, argument: ValueArgument): KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil in file CallResolverUtil.kt[SimpleFunctionDescriptorImpl]

'valueParameterDescriptor' @ [340:62] ==> value-parameter valueParameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'valueArgument' @ [340:88] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'isCoroutineCallWithAdditionalInference' @ [342:13] ==> public fun isCoroutineCallWithAdditionalInference(parameterDescriptor: ValueParameterDescriptor, argument: ValueArgument): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference[SimpleFunctionDescriptorImpl]

'valueParameterDescriptor' @ [342:52] ==> value-parameter valueParameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'valueArgument' @ [342:78] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'coroutineInferenceSupport' @ [343:13] ==> private final val coroutineInferenceSupport: CoroutineInferenceSupport defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver[PropertyDescriptorImpl]

'analyzeCoroutine' @ [343:39] ==> public final fun analyzeCoroutine(functionLiteral: KtFunction, valueArgument: ValueArgument, csBuilder: ConstraintSystem.Builder, context: CallCandidateResolutionContext<*>, lambdaExpectedType: KotlinType): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.CoroutineInferenceSupport[SimpleFunctionDescriptorImpl]

'functionLiteral' @ [343:56] ==> value-parameter functionLiteral: KtFunction defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'valueArgument' @ [343:73] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'constraintSystem' @ [343:88] ==> value-parameter constraintSystem: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'context' @ [343:106] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'effectiveExpectedType' @ [343:115] ==> val effectiveExpectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'constraintSystem' @ [346:34] ==> value-parameter constraintSystem: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'build' @ [346:51] ==> public abstract fun build(): ConstraintSystem defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem.Builder[SimpleFunctionDescriptorImpl]

'currentSubstitutor' @ [346:59] ==> public abstract val currentSubstitutor: TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem[PropertyDescriptorImpl]

'DelegatedTypeSubstitution' @ [347:40] ==> public constructor DelegatedTypeSubstitution(substitution: TypeSubstitution) defined in org.jetbrains.kotlin.types.DelegatedTypeSubstitution[DeserializedClassConstructorDescriptor]

'currentSubstitutor' @ [347:66] ==> val currentSubstitutor: TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'substitution' @ [347:85] ==> public final val TypeSubstitutor.substitution: TypeSubstitution[MyPropertyDescriptor]

'newSubstitution' @ [351:28] ==> val newSubstitution: <no name provided><D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'buildSubstitutor' @ [351:44] ==> public final fun buildSubstitutor(): TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument.<no name provided>[DeserializedSimpleFunctionDescriptor]

'substitute' @ [351:63] ==> @Nullable public open fun substitute(@NotNull p0: KotlinType, @NotNull p1: Variance): KotlinType? defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'effectiveExpectedType' @ [351:74] ==> val effectiveExpectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'IN_VARIANCE' @ [351:106] ==> enum entry IN_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'expectedType' @ [353:13] ==> var expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'isDontCarePlaceholder' @ [353:47] ==> public open fun isDontCarePlaceholder(@Nullable p0: KotlinType?): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'expectedType' @ [353:69] ==> var expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'expectedType' @ [354:13] ==> var expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'argumentTypeResolver' @ [354:28] ==> private final val argumentTypeResolver: ArgumentTypeResolver defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver[PropertyDescriptorImpl]

'getShapeTypeOfFunctionLiteral' @ [354:49] ==> @Nullable public open fun getShapeTypeOfFunctionLiteral(@NotNull function: KtFunction, @NotNull scope: LexicalScope, @NotNull trace: BindingTrace, expectedTypeIsUnknown: Boolean): KotlinType? defined in org.jetbrains.kotlin.resolve.calls.ArgumentTypeResolver[JavaMethodDescriptor]

'functionLiteral' @ [354:79] ==> value-parameter functionLiteral: KtFunction defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'context' @ [354:96] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'scope' @ [354:104] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaPropertyDescriptor]

'context' @ [354:111] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'trace' @ [354:119] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaPropertyDescriptor]

'expectedType' @ [356:13] ==> var expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'!' @ [356:37] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'expectedType' @ [356:38] ==> var expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'isBuiltinFunctionalTypeOrSubtype' @ [356:51] ==> public val KotlinType.isBuiltinFunctionalTypeOrSubtype: Boolean defined in org.jetbrains.kotlin.builtins[DeserializedPropertyDescriptor]

'hasUnknownFunctionParameter' @ [356:87] ==> public fun hasUnknownFunctionParameter(type: KotlinType): Boolean defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil in file CallResolverUtil.kt[SimpleFunctionDescriptorImpl]

'expectedType' @ [356:115] ==> var expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'context' @ [359:40] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'candidateCall' @ [359:48] ==> @NotNull public final val candidateCall: MutableResolvedCall<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaPropertyDescriptor]

'dataFlowInfoForArguments' @ [359:62] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> MutableResolvedCall<(D..D?)>.dataFlowInfoForArguments: MutableDataFlowInfoForArguments[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (D..D?)

'dataFlowInfoForArguments' @ [360:39] ==> val dataFlowInfoForArguments: MutableDataFlowInfoForArguments defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'getInfo' @ [360:64] ==> @NotNull public abstract fun getInfo(@NotNull valueArgument: ValueArgument): DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.model.MutableDataFlowInfoForArguments[JavaMethodDescriptor]

'valueArgument' @ [360:72] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'constraintSystem' @ [363:17] ==> value-parameter constraintSystem: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'typeVariableSubstitutors' @ [363:34] ==> public abstract val typeVariableSubstitutors: Map<CallHandle, TypeSubstitutor> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem.Builder[PropertyDescriptorImpl]

'context' @ [363:59] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'call' @ [363:67] ==> @NotNull public final val call: Call defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaPropertyDescriptor]

'toHandle' @ [363:72] ==> public fun Call.toHandle(): CallHandle defined in org.jetbrains.kotlin.resolve.calls.inference in file TypeVariable.kt[SimpleFunctionDescriptorImpl]

'substitute' @ [363:85] ==> @Nullable public open fun substitute(@NotNull p0: KotlinType, @NotNull p1: Variance): KotlinType? defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'effectiveExpectedType' @ [363:96] ==> val effectiveExpectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'INVARIANT' @ [363:128] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'!' @ [366:37] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'hasUnknownReturnType' @ [366:38] ==> public fun hasUnknownReturnType(type: KotlinType): Boolean defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil in file CallResolverUtil.kt[SimpleFunctionDescriptorImpl]

'expectedType' @ [366:59] ==> var expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'VALUE_PARAMETER_POSITION' @ [367:24] ==> enum entry VALUE_PARAMETER_POSITION defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPositionKind[FakeCallableDescriptorForObject]

'position' @ [367:49] ==> public final fun position(index: Int): ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPositionKind[SimpleFunctionDescriptorImpl]

'valueParameterDescriptor' @ [367:58] ==> value-parameter valueParameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'index' @ [367:83] ==> public abstract val index: Int defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'hasExpectedReturnType' @ [368:13] ==> val hasExpectedReturnType: Boolean defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'create' @ [369:76] ==> public open fun create(context: raw (ResolutionContext<(ResolutionContext<*>..ResolutionContext<*>?)>..ResolutionContext<out (ResolutionContext<*>..ResolutionContext<*>?)>?), debugName: (String..String?), expression: (KtExpression..KtExpression?)): (TemporaryTraceAndCache..TemporaryTraceAndCache?) defined in org.jetbrains.kotlin.resolve.calls.context.TemporaryTraceAndCache[JavaMethodDescriptor]

'context' @ [370:21] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'argumentExpression' @ [370:93] ==> val argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'?:' @ [372:39] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtExpression?, right: KtExpression): KtExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtExpression

'getExpressionOrLastStatementInBlock' @ [372:49] ==> @Nullable public open fun getExpressionOrLastStatementInBlock(@Nullable expression: KtExpression?): KtExpression? defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'functionLiteral' @ [372:85] ==> value-parameter functionLiteral: KtFunction defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'bodyExpression' @ [372:101] ==> public final val KtFunction.bodyExpression: KtExpression?[MyPropertyDescriptor]

'BooleanArray' @ [373:28] ==> public constructor BooleanArray(size: Int) defined in kotlin.BooleanArray[DeserializedClassConstructorDescriptor]

'makeTraceInterceptingTypeMismatch' @ [374:64] ==> public open fun makeTraceInterceptingTypeMismatch(@NotNull trace: BindingTrace, @NotNull expressionToWatch: KtElement, @NotNull mismatchFound: BooleanArray): (ObservableBindingTrace..ObservableBindingTrace?) defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingUtils[JavaMethodDescriptor]

'temporaryToResolveFunctionLiteral' @ [375:21] ==> val temporaryToResolveFunctionLiteral: (TemporaryTraceAndCache..TemporaryTraceAndCache?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'trace' @ [375:55] ==> public final val trace: (TemporaryBindingTrace..TemporaryBindingTrace?) defined in org.jetbrains.kotlin.resolve.calls.context.TemporaryTraceAndCache[JavaPropertyDescriptor]

'statementExpression' @ [375:62] ==> val statementExpression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'mismatch' @ [375:83] ==> val mismatch: BooleanArray defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'context' @ [376:30] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'replaceBindingTrace' @ [376:38] ==> @NotNull public open fun replaceBindingTrace(@NotNull trace: BindingTrace): CallCandidateResolutionContext<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaMethodDescriptor]

'errorInterceptingTrace' @ [376:58] ==> val errorInterceptingTrace: (ObservableBindingTrace..ObservableBindingTrace?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'replaceExpectedType' @ [376:82] ==> @NotNull public open fun replaceExpectedType(@Nullable newExpectedType: KotlinType?): CallCandidateResolutionContext<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaMethodDescriptor]

'expectedType' @ [376:102] ==> var expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'replaceDataFlowInfo' @ [377:22] ==> @NotNull public open fun replaceDataFlowInfo(@NotNull newDataFlowInfo: DataFlowInfo): CallCandidateResolutionContext<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaMethodDescriptor]

'dataFlowInfoForArgument' @ [377:42] ==> val dataFlowInfoForArgument: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'replaceResolutionResultsCache' @ [377:67] ==> @NotNull public open fun replaceResolutionResultsCache(@NotNull newResolutionResultsCache: ResolutionResultsCache): CallCandidateResolutionContext<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaMethodDescriptor]

'temporaryToResolveFunctionLiteral' @ [377:97] ==> val temporaryToResolveFunctionLiteral: (TemporaryTraceAndCache..TemporaryTraceAndCache?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'cache' @ [377:131] ==> public final val cache: (TemporaryResolutionResultsCache..TemporaryResolutionResultsCache?) defined in org.jetbrains.kotlin.resolve.calls.context.TemporaryTraceAndCache[JavaPropertyDescriptor]

'replaceContextDependency' @ [378:22] ==> @NotNull public open fun replaceContextDependency(@NotNull newContextDependency: ContextDependency): CallCandidateResolutionContext<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaMethodDescriptor]

'INDEPENDENT' @ [378:47] ==> enum entry INDEPENDENT defined in org.jetbrains.kotlin.resolve.calls.context.ContextDependency[FakeCallableDescriptorForObject]

'argumentTypeResolver' @ [379:24] ==> private final val argumentTypeResolver: ArgumentTypeResolver defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver[PropertyDescriptorImpl]

'getFunctionLiteralTypeInfo' @ [379:45] ==> @NotNull public open fun getFunctionLiteralTypeInfo(@NotNull expression: KtExpression, @NotNull functionLiteral: KtFunction, @NotNull context: CallResolutionContext<*>, @NotNull resolveArgumentsMode: ResolveArgumentsMode): KotlinTypeInfo defined in org.jetbrains.kotlin.resolve.calls.ArgumentTypeResolver[JavaMethodDescriptor]

'argumentExpression' @ [380:21] ==> val argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'functionLiteral' @ [380:41] ==> value-parameter functionLiteral: KtFunction defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'newContext' @ [380:58] ==> val newContext: CallCandidateResolutionContext<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'RESOLVE_FUNCTION_ARGUMENTS' @ [380:70] ==> enum entry RESOLVE_FUNCTION_ARGUMENTS defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.ResolveArgumentsMode[FakeCallableDescriptorForObject]

'type' @ [380:98] ==> public final val type: KotlinType? defined in org.jetbrains.kotlin.types.expressions.KotlinTypeInfo[PropertyDescriptorImpl]

'!' @ [381:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'mismatch' @ [381:18] ==> val mismatch: BooleanArray defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'constraintSystem' @ [382:17] ==> value-parameter constraintSystem: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'addSubtypeConstraint' @ [382:34] ==> public abstract fun addSubtypeConstraint(constrainingType: KotlinType?, subjectType: KotlinType?, constraintPosition: ConstraintPosition): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem.Builder[SimpleFunctionDescriptorImpl]

'type' @ [382:55] ==> val type: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'effectiveExpectedTypeInSystem' @ [382:61] ==> val effectiveExpectedTypeInSystem: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'position' @ [382:92] ==> val position: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'temporaryToResolveFunctionLiteral' @ [383:17] ==> val temporaryToResolveFunctionLiteral: (TemporaryTraceAndCache..TemporaryTraceAndCache?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'commit' @ [383:51] ==> public open fun commit(): Unit defined in org.jetbrains.kotlin.resolve.calls.context.TemporaryTraceAndCache[JavaMethodDescriptor]

'estimateLiteralReturnType' @ [387:35] ==> private final fun estimateLiteralReturnType(context: CallCandidateResolutionContext<*>, literalExpectedType: KotlinType, ownerReturnType: KotlinType?): (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver[SimpleFunctionDescriptorImpl]

'context' @ [387:61] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'effectiveExpectedType' @ [387:70] ==> val effectiveExpectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'argumentOwnerReturnType' @ [387:93] ==> value-parameter argumentOwnerReturnType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'replaceReturnTypeForCallable' @ [388:51] ==> public fun replaceReturnTypeForCallable(type: KotlinType, given: KotlinType): KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil in file CallResolverUtil.kt[SimpleFunctionDescriptorImpl]

'expectedType' @ [388:80] ==> var expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'estimatedReturnType' @ [388:94] ==> val estimatedReturnType: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'context' @ [389:26] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'replaceExpectedType' @ [389:34] ==> @NotNull public open fun replaceExpectedType(@Nullable newExpectedType: KotlinType?): CallCandidateResolutionContext<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaMethodDescriptor]

'expectedTypeWithEstimatedReturnType' @ [389:54] ==> val expectedTypeWithEstimatedReturnType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'replaceDataFlowInfo' @ [389:91] ==> @NotNull public open fun replaceDataFlowInfo(@NotNull newDataFlowInfo: DataFlowInfo): CallCandidateResolutionContext<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaMethodDescriptor]

'dataFlowInfoForArgument' @ [389:111] ==> val dataFlowInfoForArgument: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'replaceContextDependency' @ [390:18] ==> @NotNull public open fun replaceContextDependency(@NotNull newContextDependency: ContextDependency): CallCandidateResolutionContext<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaMethodDescriptor]

'INDEPENDENT' @ [390:43] ==> enum entry INDEPENDENT defined in org.jetbrains.kotlin.resolve.calls.context.ContextDependency[FakeCallableDescriptorForObject]

'argumentTypeResolver' @ [391:20] ==> private final val argumentTypeResolver: ArgumentTypeResolver defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver[PropertyDescriptorImpl]

'getFunctionLiteralTypeInfo' @ [391:41] ==> @NotNull public open fun getFunctionLiteralTypeInfo(@NotNull expression: KtExpression, @NotNull functionLiteral: KtFunction, @NotNull context: CallResolutionContext<*>, @NotNull resolveArgumentsMode: ResolveArgumentsMode): KotlinTypeInfo defined in org.jetbrains.kotlin.resolve.calls.ArgumentTypeResolver[JavaMethodDescriptor]

'argumentExpression' @ [391:68] ==> val argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'functionLiteral' @ [391:88] ==> value-parameter functionLiteral: KtFunction defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'newContext' @ [391:105] ==> val newContext: CallCandidateResolutionContext<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'RESOLVE_FUNCTION_ARGUMENTS' @ [391:117] ==> enum entry RESOLVE_FUNCTION_ARGUMENTS defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.ResolveArgumentsMode[FakeCallableDescriptorForObject]

'type' @ [391:145] ==> public final val type: KotlinType? defined in org.jetbrains.kotlin.types.expressions.KotlinTypeInfo[PropertyDescriptorImpl]

'constraintSystem' @ [392:9] ==> value-parameter constraintSystem: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[ValueParameterDescriptorImpl]

'addSubtypeConstraint' @ [392:26] ==> public abstract fun addSubtypeConstraint(constrainingType: KotlinType?, subjectType: KotlinType?, constraintPosition: ConstraintPosition): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem.Builder[SimpleFunctionDescriptorImpl]

'type' @ [392:47] ==> val type: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'effectiveExpectedTypeInSystem' @ [392:53] ==> val effectiveExpectedTypeInSystem: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'position' @ [392:84] ==> val position: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForFunctionLiteralArgument[LocalVariableDescriptor]

'getEffectiveExpectedType' @ [402:37] ==> public fun getEffectiveExpectedType(parameterDescriptor: ValueParameterDescriptor, argument: ValueArgument): KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil in file CallResolverUtil.kt[SimpleFunctionDescriptorImpl]

'valueParameterDescriptor' @ [402:62] ==> value-parameter valueParameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForCallableReference[ValueParameterDescriptorImpl]

'valueArgument' @ [402:88] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForCallableReference[ValueParameterDescriptorImpl]

'getExpectedTypeForCallableReference' @ [403:28] ==> private final fun <D : CallableDescriptor> getExpectedTypeForCallableReference(callableReference: KtCallableReferenceExpression, constraintSystem: ConstraintSystem.Builder, context: CallCandidateResolutionContext<D>, effectiveExpectedType: KotlinType): KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver[SimpleFunctionDescriptorImpl]
Inferred types:
    <D : CallableDescriptor> -> D

'callableReference' @ [403:64] ==> value-parameter callableReference: KtCallableReferenceExpression defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForCallableReference[ValueParameterDescriptorImpl]

'constraintSystem' @ [403:83] ==> value-parameter constraintSystem: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForCallableReference[ValueParameterDescriptorImpl]

'context' @ [403:101] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForCallableReference[ValueParameterDescriptorImpl]

'effectiveExpectedType' @ [403:110] ==> val effectiveExpectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForCallableReference[LocalVariableDescriptor]

'!' @ [405:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'ReflectionTypes' @ [405:14] ==> public companion object defined in org.jetbrains.kotlin.builtins.ReflectionTypes[FakeCallableDescriptorForObject]

'isCallableType' @ [405:30] ==> public final fun isCallableType(type: KotlinType): Boolean defined in org.jetbrains.kotlin.builtins.ReflectionTypes.Companion[DeserializedSimpleFunctionDescriptor]

'expectedType' @ [405:45] ==> val expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForCallableReference[LocalVariableDescriptor]

'getResolvedTypeForCallableReference' @ [406:28] ==> private final fun <D : CallableDescriptor> getResolvedTypeForCallableReference(callableReference: KtCallableReferenceExpression, context: CallCandidateResolutionContext<D>, expectedType: KotlinType, valueArgument: ValueArgument): KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver[SimpleFunctionDescriptorImpl]
Inferred types:
    <D : CallableDescriptor> -> D

'callableReference' @ [406:64] ==> value-parameter callableReference: KtCallableReferenceExpression defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForCallableReference[ValueParameterDescriptorImpl]

'context' @ [406:83] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForCallableReference[ValueParameterDescriptorImpl]

'expectedType' @ [406:92] ==> val expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForCallableReference[LocalVariableDescriptor]

'valueArgument' @ [406:106] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForCallableReference[ValueParameterDescriptorImpl]

'VALUE_PARAMETER_POSITION' @ [407:24] ==> enum entry VALUE_PARAMETER_POSITION defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPositionKind[FakeCallableDescriptorForObject]

'position' @ [407:49] ==> public final fun position(index: Int): ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPositionKind[SimpleFunctionDescriptorImpl]

'valueParameterDescriptor' @ [407:58] ==> value-parameter valueParameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForCallableReference[ValueParameterDescriptorImpl]

'index' @ [407:83] ==> public abstract val index: Int defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'constraintSystem' @ [408:9] ==> value-parameter constraintSystem: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForCallableReference[ValueParameterDescriptorImpl]

'addSubtypeConstraint' @ [408:26] ==> public abstract fun addSubtypeConstraint(constrainingType: KotlinType?, subjectType: KotlinType?, constraintPosition: ConstraintPosition): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem.Builder[SimpleFunctionDescriptorImpl]

'resolvedType' @ [409:17] ==> val resolvedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForCallableReference[LocalVariableDescriptor]

'constraintSystem' @ [410:17] ==> value-parameter constraintSystem: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForCallableReference[ValueParameterDescriptorImpl]

'typeVariableSubstitutors' @ [410:34] ==> public abstract val typeVariableSubstitutors: Map<CallHandle, TypeSubstitutor> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem.Builder[PropertyDescriptorImpl]

'context' @ [410:59] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForCallableReference[ValueParameterDescriptorImpl]

'call' @ [410:67] ==> @NotNull public final val call: Call defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaPropertyDescriptor]

'toHandle' @ [410:72] ==> public fun Call.toHandle(): CallHandle defined in org.jetbrains.kotlin.resolve.calls.inference in file TypeVariable.kt[SimpleFunctionDescriptorImpl]

'substitute' @ [410:85] ==> @Nullable public open fun substitute(@NotNull p0: KotlinType, @NotNull p1: Variance): KotlinType? defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'effectiveExpectedType' @ [410:96] ==> val effectiveExpectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForCallableReference[LocalVariableDescriptor]

'INVARIANT' @ [410:128] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'position' @ [411:17] ==> val position: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.addConstraintForCallableReference[LocalVariableDescriptor]

'constraintSystem' @ [421:31] ==> value-parameter constraintSystem: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.getExpectedTypeForCallableReference[ValueParameterDescriptorImpl]

'build' @ [421:48] ==> public abstract fun build(): ConstraintSystem defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem.Builder[SimpleFunctionDescriptorImpl]

'currentSubstitutor' @ [421:56] ==> public abstract val currentSubstitutor: TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem[PropertyDescriptorImpl]

'substitute' @ [421:75] ==> @Nullable public open fun substitute(@NotNull p0: KotlinType, @NotNull p1: Variance): KotlinType? defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'effectiveExpectedType' @ [421:86] ==> value-parameter effectiveExpectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.getExpectedTypeForCallableReference[ValueParameterDescriptorImpl]

'INVARIANT' @ [421:118] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'substitutedType' @ [422:13] ==> val substitutedType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.getExpectedTypeForCallableReference[LocalVariableDescriptor]

'!' @ [422:40] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isDontCarePlaceholder' @ [422:51] ==> public open fun isDontCarePlaceholder(@Nullable p0: KotlinType?): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'substitutedType' @ [422:73] ==> val substitutedType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.getExpectedTypeForCallableReference[LocalVariableDescriptor]

'substitutedType' @ [423:20] ==> val substitutedType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.getExpectedTypeForCallableReference[LocalVariableDescriptor]

'argumentTypeResolver' @ [425:25] ==> private final val argumentTypeResolver: ArgumentTypeResolver defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver[PropertyDescriptorImpl]

'getShapeTypeOfCallableReference' @ [425:46] ==> @Nullable public open fun getShapeTypeOfCallableReference(@NotNull callableReferenceExpression: KtCallableReferenceExpression, @NotNull context: CallResolutionContext<*>, expectedTypeIsUnknown: Boolean): KotlinType? defined in org.jetbrains.kotlin.resolve.calls.ArgumentTypeResolver[JavaMethodDescriptor]

'callableReference' @ [425:78] ==> value-parameter callableReference: KtCallableReferenceExpression defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.getExpectedTypeForCallableReference[ValueParameterDescriptorImpl]

'context' @ [425:97] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.getExpectedTypeForCallableReference[ValueParameterDescriptorImpl]

'shapeType' @ [426:13] ==> val shapeType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.getExpectedTypeForCallableReference[LocalVariableDescriptor]

'shapeType' @ [426:34] ==> val shapeType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.getExpectedTypeForCallableReference[LocalVariableDescriptor]

'isFunctionTypeOrSubtype' @ [426:44] ==> public val KotlinType.isFunctionTypeOrSubtype: Boolean defined in org.jetbrains.kotlin.builtins[DeserializedPropertyDescriptor]

'!' @ [426:71] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'hasUnknownFunctionParameter' @ [426:72] ==> public fun hasUnknownFunctionParameter(type: KotlinType): Boolean defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil in file CallResolverUtil.kt[SimpleFunctionDescriptorImpl]

'shapeType' @ [426:100] ==> val shapeType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.getExpectedTypeForCallableReference[LocalVariableDescriptor]

'shapeType' @ [427:20] ==> val shapeType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.getExpectedTypeForCallableReference[LocalVariableDescriptor]

'context' @ [438:39] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.getResolvedTypeForCallableReference[ValueParameterDescriptorImpl]

'candidateCall' @ [438:47] ==> @NotNull public final val candidateCall: MutableResolvedCall<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaPropertyDescriptor]

'dataFlowInfoForArguments' @ [438:61] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> MutableResolvedCall<(D..D?)>.dataFlowInfoForArguments: MutableDataFlowInfoForArguments[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (D..D?)

'getInfo' @ [438:86] ==> @NotNull public abstract fun getInfo(@NotNull valueArgument: ValueArgument): DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.model.MutableDataFlowInfoForArguments[JavaMethodDescriptor]

'valueArgument' @ [438:94] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.getResolvedTypeForCallableReference[ValueParameterDescriptorImpl]

'if (!hasUnknownReturnType(expectedType)) replaceReturnTypeByUnknown(expectedType) else expectedType' @ [439:45] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType, elseBranch: KotlinType): KotlinType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType

'!' @ [439:49] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'hasUnknownReturnType' @ [439:50] ==> public fun hasUnknownReturnType(type: KotlinType): Boolean defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil in file CallResolverUtil.kt[SimpleFunctionDescriptorImpl]

'expectedType' @ [439:71] ==> value-parameter expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.getResolvedTypeForCallableReference[ValueParameterDescriptorImpl]

'replaceReturnTypeByUnknown' @ [439:86] ==> public fun replaceReturnTypeByUnknown(type: KotlinType): KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil[SimpleFunctionDescriptorImpl]

'expectedType' @ [439:113] ==> value-parameter expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.getResolvedTypeForCallableReference[ValueParameterDescriptorImpl]

'expectedType' @ [439:132] ==> value-parameter expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.getResolvedTypeForCallableReference[ValueParameterDescriptorImpl]

'context' @ [440:26] ==> value-parameter context: CallCandidateResolutionContext<D> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.getResolvedTypeForCallableReference[ValueParameterDescriptorImpl]

'replaceExpectedType' @ [441:18] ==> @NotNull public open fun replaceExpectedType(@Nullable newExpectedType: KotlinType?): CallCandidateResolutionContext<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaMethodDescriptor]

'expectedTypeWithoutReturnType' @ [441:38] ==> val expectedTypeWithoutReturnType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.getResolvedTypeForCallableReference[LocalVariableDescriptor]

'replaceDataFlowInfo' @ [442:18] ==> @NotNull public open fun replaceDataFlowInfo(@NotNull newDataFlowInfo: DataFlowInfo): CallCandidateResolutionContext<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaMethodDescriptor]

'dataFlowInfoForArgument' @ [442:38] ==> val dataFlowInfoForArgument: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.getResolvedTypeForCallableReference[LocalVariableDescriptor]

'replaceContextDependency' @ [443:18] ==> @NotNull public open fun replaceContextDependency(@NotNull newContextDependency: ContextDependency): CallCandidateResolutionContext<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext[JavaMethodDescriptor]

'INDEPENDENT' @ [443:43] ==> enum entry INDEPENDENT defined in org.jetbrains.kotlin.resolve.calls.context.ContextDependency[FakeCallableDescriptorForObject]

'argumentTypeResolver' @ [444:16] ==> private final val argumentTypeResolver: ArgumentTypeResolver defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver[PropertyDescriptorImpl]

'getCallableReferenceTypeInfo' @ [444:37] ==> @NotNull public open fun getCallableReferenceTypeInfo(@NotNull expression: KtExpression, @NotNull callableReferenceExpression: KtCallableReferenceExpression, @NotNull context: CallResolutionContext<*>, @NotNull resolveArgumentsMode: ResolveArgumentsMode): KotlinTypeInfo defined in org.jetbrains.kotlin.resolve.calls.ArgumentTypeResolver[JavaMethodDescriptor]

'callableReference' @ [445:17] ==> value-parameter callableReference: KtCallableReferenceExpression defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.getResolvedTypeForCallableReference[ValueParameterDescriptorImpl]

'callableReference' @ [445:36] ==> value-parameter callableReference: KtCallableReferenceExpression defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.getResolvedTypeForCallableReference[ValueParameterDescriptorImpl]

'newContext' @ [445:55] ==> val newContext: CallCandidateResolutionContext<(D..D?)> defined in org.jetbrains.kotlin.resolve.calls.GenericCandidateResolver.getResolvedTypeForCallableReference[LocalVariableDescriptor]

'RESOLVE_FUNCTION_ARGUMENTS' @ [445:67] ==> enum entry RESOLVE_FUNCTION_ARGUMENTS defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.ResolveArgumentsMode[FakeCallableDescriptorForObject]

'type' @ [446:11] ==> public final val type: KotlinType? defined in org.jetbrains.kotlin.types.expressions.KotlinTypeInfo[PropertyDescriptorImpl]

'!' @ [451:9] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'dependsOnExpectedType' @ [451:32] ==> public open fun dependsOnExpectedType(@Nullable expression: KtExpression?): Boolean defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingUtils[JavaMethodDescriptor]

'expression' @ [451:54] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.getResolutionResultsCachedData[ValueParameterDescriptorImpl]

'expression' @ [452:24] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.getResolutionResultsCachedData[ValueParameterDescriptorImpl]

'getCall' @ [452:36] ==> public fun KtElement.getCall(context: BindingContext): Call? defined in org.jetbrains.kotlin.resolve.calls.callUtil in file callUtil.kt[SimpleFunctionDescriptorImpl]

'context' @ [452:44] ==> value-parameter context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.getResolutionResultsCachedData[ValueParameterDescriptorImpl]

'trace' @ [452:52] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'bindingContext' @ [452:58] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'context' @ [454:12] ==> value-parameter context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.getResolutionResultsCachedData[ValueParameterDescriptorImpl]

'resolutionResultsCache' @ [454:20] ==> @NotNull public final val resolutionResultsCache: ResolutionResultsCache defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'argumentCall' @ [454:43] ==> val argumentCall: Call defined in org.jetbrains.kotlin.resolve.calls.getResolutionResultsCachedData[LocalVariableDescriptor]

'typeParameterDescriptors' @ [458:24] ==> value-parameter typeParameterDescriptors: Collection<TypeParameterDescriptor> defined in org.jetbrains.kotlin.resolve.calls.makeConstantSubstitutor[ValueParameterDescriptorImpl]

'map' @ [458:49] ==> public inline fun <T, R> Iterable<TypeParameterDescriptor>.map(transform: (TypeParameterDescriptor) -> TypeConstructor): List<TypeConstructor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeParameterDescriptor
    <R> -> TypeConstructor

'it' @ [458:55] ==> value-parameter it: TypeParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.makeConstantSubstitutor.<anonymous>[ValueParameterDescriptorImpl]

'typeConstructor' @ [458:58] ==> public final val TypeParameterDescriptor.typeConstructor: TypeConstructor[MyPropertyDescriptor]

'toSet' @ [458:76] ==> public fun <T> Iterable<TypeConstructor>.toSet(): Set<TypeConstructor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeConstructor

'TypeProjectionImpl' @ [459:22] ==> public constructor TypeProjectionImpl(@NotNull p0: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'type' @ [459:41] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.makeConstantSubstitutor[ValueParameterDescriptorImpl]

'create' @ [461:28] ==> @NotNull public open fun create(@NotNull p0: TypeSubstitution): TypeSubstitutor defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'TypeConstructorSubstitution' @ [461:44] ==> public constructor TypeConstructorSubstitution() defined in org.jetbrains.kotlin.types.TypeConstructorSubstitution[DeserializedClassConstructorDescriptor]

'if (key in constructors) projection else null' @ [463:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: TypeProjectionImpl?, elseBranch: TypeProjectionImpl?): TypeProjectionImpl?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> TypeProjectionImpl?

'key' @ [463:21] ==> value-parameter key: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.makeConstantSubstitutor.<no name provided>.get[ValueParameterDescriptorImpl]

'constructors' @ [463:28] ==> val constructors: Set<TypeConstructor> defined in org.jetbrains.kotlin.resolve.calls.makeConstantSubstitutor[LocalVariableDescriptor]

'projection' @ [463:42] ==> val projection: TypeProjectionImpl defined in org.jetbrains.kotlin.resolve.calls.makeConstantSubstitutor[LocalVariableDescriptor]

