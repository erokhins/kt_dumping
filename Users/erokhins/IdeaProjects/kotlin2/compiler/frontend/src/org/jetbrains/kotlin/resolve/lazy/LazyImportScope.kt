'allImports' @ [48:28] ==> value-parameter allImports: Collection<KtImportDirective> defined in org.jetbrains.kotlin.resolve.lazy.AllUnderImportsIndexed.<init>[ValueParameterDescriptorImpl]

'filter' @ [48:39] ==> public inline fun <T> Iterable<KtImportDirective>.filter(predicate: (KtImportDirective) -> Boolean): List<KtImportDirective> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtImportDirective

'it' @ [48:48] ==> value-parameter it: KtImportDirective defined in org.jetbrains.kotlin.resolve.lazy.AllUnderImportsIndexed.imports.<anonymous>[ValueParameterDescriptorImpl]

'isAllUnder' @ [48:51] ==> public final val KtImportDirective.isAllUnder: Boolean[MyPropertyDescriptor]

'imports' @ [49:47] ==> public open val imports: List<KtImportDirective> defined in org.jetbrains.kotlin.resolve.lazy.AllUnderImportsIndexed[PropertyDescriptorImpl]

'allImports' @ [53:28] ==> value-parameter allImports: Collection<KtImportDirective> defined in org.jetbrains.kotlin.resolve.lazy.ExplicitImportsIndexed.<init>[ValueParameterDescriptorImpl]

'filter' @ [53:39] ==> public inline fun <T> Iterable<KtImportDirective>.filter(predicate: (KtImportDirective) -> Boolean): List<KtImportDirective> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtImportDirective

'!' @ [53:48] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'it' @ [53:49] ==> value-parameter it: KtImportDirective defined in org.jetbrains.kotlin.resolve.lazy.ExplicitImportsIndexed.imports.<anonymous>[ValueParameterDescriptorImpl]

'isAllUnder' @ [53:52] ==> public final val KtImportDirective.isAllUnder: Boolean[MyPropertyDescriptor]

'lazy' @ [55:76] ==> public fun <T> lazy(initializer: () -> (ImmutableListMultimap<(Name..Name?), (KtImportDirective..KtImportDirective?)>..ImmutableListMultimap<(Name..Name?), (KtImportDirective..KtImportDirective?)>?)): Lazy<(ImmutableListMultimap<(Name..Name?), (KtImportDirective..KtImportDirective?)>..ImmutableListMultimap<(Name..Name?), (KtImportDirective..KtImportDirective?)>?)> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (com.google.common.collect.ImmutableListMultimap<(org.jetbrains.kotlin.name.Name..org.jetbrains.kotlin.name.Name?), (org.jetbrains.kotlin.psi.KtImportDirective..org.jetbrains.kotlin.psi.KtImportDirective?)>..com.google.common.collect.ImmutableListMultimap<(org.jetbrains.kotlin.name.Name..org.jetbrains.kotlin.name.Name?), (org.jetbrains.kotlin.psi.KtImportDirective..org.jetbrains.kotlin.psi.KtImportDirective?)>?)

'builder' @ [56:45] ==> public open fun <K : (Any..Any?), V : (Any..Any?)> builder(): (ImmutableListMultimap.Builder<(Name..Name?), (KtImportDirective..KtImportDirective?)>..ImmutableListMultimap.Builder<(Name..Name?), (KtImportDirective..KtImportDirective?)>?) defined in com.google.common.collect.ImmutableListMultimap[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> Name
    <V : (Any..Any?)> -> KtImportDirective

'imports' @ [58:27] ==> public open val imports: List<KtImportDirective> defined in org.jetbrains.kotlin.resolve.lazy.ExplicitImportsIndexed[PropertyDescriptorImpl]

'directive' @ [59:24] ==> val directive: KtImportDirective defined in org.jetbrains.kotlin.resolve.lazy.ExplicitImportsIndexed.nameToDirectives.<anonymous>[LocalVariableDescriptor]

'importPath' @ [59:34] ==> public final val KtImportDirective.importPath: ImportPath?[MyPropertyDescriptor]

'path' @ [60:32] ==> val path: ImportPath defined in org.jetbrains.kotlin.resolve.lazy.ExplicitImportsIndexed.nameToDirectives.<anonymous>[LocalVariableDescriptor]

'importedName' @ [60:37] ==> public final val importedName: Name? defined in org.jetbrains.kotlin.resolve.ImportPath[PropertyDescriptorImpl]

'builder' @ [61:13] ==> val builder: (ImmutableListMultimap.Builder<(Name..Name?), (KtImportDirective..KtImportDirective?)>..ImmutableListMultimap.Builder<(Name..Name?), (KtImportDirective..KtImportDirective?)>?) defined in org.jetbrains.kotlin.resolve.lazy.ExplicitImportsIndexed.nameToDirectives.<anonymous>[LocalVariableDescriptor]

'put' @ [61:21] ==> @CanIgnoreReturnValue public open fun put(p0: (Name..Name?), p1: (KtImportDirective..KtImportDirective?)): (ImmutableListMultimap.Builder<(Name..Name?), (KtImportDirective..KtImportDirective?)>..ImmutableListMultimap.Builder<(Name..Name?), (KtImportDirective..KtImportDirective?)>?) defined in com.google.common.collect.ImmutableListMultimap.Builder[JavaMethodDescriptor]

'importedName' @ [61:25] ==> val importedName: Name defined in org.jetbrains.kotlin.resolve.lazy.ExplicitImportsIndexed.nameToDirectives.<anonymous>[LocalVariableDescriptor]

'directive' @ [61:39] ==> val directive: KtImportDirective defined in org.jetbrains.kotlin.resolve.lazy.ExplicitImportsIndexed.nameToDirectives.<anonymous>[LocalVariableDescriptor]

'builder' @ [64:9] ==> val builder: (ImmutableListMultimap.Builder<(Name..Name?), (KtImportDirective..KtImportDirective?)>..ImmutableListMultimap.Builder<(Name..Name?), (KtImportDirective..KtImportDirective?)>?) defined in org.jetbrains.kotlin.resolve.lazy.ExplicitImportsIndexed.nameToDirectives.<anonymous>[LocalVariableDescriptor]

'build' @ [64:17] ==> public open fun build(): (ImmutableListMultimap<(Name..Name?), (KtImportDirective..KtImportDirective?)>..ImmutableListMultimap<(Name..Name?), (KtImportDirective..KtImportDirective?)>?) defined in com.google.common.collect.ImmutableListMultimap.Builder[JavaMethodDescriptor]

'nameToDirectives' @ [67:47] ==> private final val nameToDirectives: ListMultimap<Name, KtImportDirective> defined in org.jetbrains.kotlin.resolve.lazy.ExplicitImportsIndexed[PropertyDescriptorImpl]

'get' @ [67:64] ==> public abstract fun get(@Nullable p0: Name?): (MutableList<(KtImportDirective..KtImportDirective?)>..List<(KtImportDirective..KtImportDirective?)>?) defined in com.google.common.collect.ListMultimap[JavaMethodDescriptor]

'name' @ [67:68] ==> value-parameter name: Name defined in org.jetbrains.kotlin.resolve.lazy.ExplicitImportsIndexed.importsForName[ValueParameterDescriptorImpl]

'storageManager' @ [86:42] ==> public final val storageManager: StorageManager defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[PropertyDescriptorImpl]

'createMemoizedFunctionWithNullableValues' @ [86:57] ==> public abstract fun <K, V : Any> createMemoizedFunctionWithNullableValues(compute: (KtImportDirective) -> ImportingScope?): MemoizedFunctionToNullable<KtImportDirective, ImportingScope> defined in org.jetbrains.kotlin.storage.StorageManager[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> KtImportDirective
    <V : Any> -> ImportingScope

'qualifiedExpressionResolver' @ [89:9] ==> private final val qualifiedExpressionResolver: QualifiedExpressionResolver defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[PropertyDescriptorImpl]

'processImportReference' @ [89:37] ==> public final fun processImportReference(importDirective: KtImportDirective, moduleDescriptor: ModuleDescriptor, trace: BindingTrace, excludedImportNames: Collection<FqName>, packageFragmentForVisibilityCheck: PackageFragmentDescriptor?): ImportingScope? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'directive' @ [90:17] ==> value-parameter directive: KtImportDirective defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.importedScopesProvider.<anonymous>[ValueParameterDescriptorImpl]

'moduleDescriptor' @ [90:28] ==> public final val moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[PropertyDescriptorImpl]

'traceForImportResolve' @ [90:46] ==> private final val traceForImportResolve: BindingTrace defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[PropertyDescriptorImpl]

'excludedImportNames' @ [90:69] ==> value-parameter excludedImportNames: Collection<FqName> defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.<init>[ValueParameterDescriptorImpl]

'packageFragment' @ [90:90] ==> private final val packageFragment: PackageFragmentDescriptor defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[PropertyDescriptorImpl]

'storageManager' @ [94:47] ==> public final val storageManager: StorageManager defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[PropertyDescriptorImpl]

'createMemoizedFunction' @ [94:62] ==> public abstract fun <K, V : Any> createMemoizedFunction(compute: (KtImportDirective) -> Unit): MemoizedFunctionToNotNull<KtImportDirective, Unit> defined in org.jetbrains.kotlin.storage.StorageManager[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> KtImportDirective
    <V : Any> -> Unit

'invoke' @ [96:21] ==> public abstract fun invoke(p1: KtImportDirective): ImportingScope? defined in org.jetbrains.kotlin.storage.MemoizedFunctionToNullable[FunctionInvokeDescriptor]

'directive' @ [96:44] ==> value-parameter directive: KtImportDirective defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveImportDirective.<anonymous>[ValueParameterDescriptorImpl]

'scope' @ [97:13] ==> val scope: ImportingScope? defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveImportDirective.<anonymous>[LocalVariableDescriptor]

'scope' @ [98:34] ==> val scope: ImportingScope? defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveImportDirective.<anonymous>[LocalVariableDescriptor]

'storeReferencesToDescriptors' @ [98:40] ==> internal final fun storeReferencesToDescriptors(): Collection<DeclarationDescriptor> defined in org.jetbrains.kotlin.resolve.LazyExplicitImportScope[SimpleFunctionDescriptorImpl]

'checkPlatformClassesMappedToKotlin' @ [99:50] ==> public open fun checkPlatformClassesMappedToKotlin(@NotNull platformToKotlinMap: PlatformToKotlinClassMap, @NotNull trace: BindingTrace, @NotNull importDirective: KtImportDirective, @NotNull descriptors: (MutableCollection<out (DeclarationDescriptor..DeclarationDescriptor?)>..Collection<(DeclarationDescriptor..DeclarationDescriptor?)>)): Unit defined in org.jetbrains.kotlin.resolve.PlatformClassesMappedToKotlinChecker[JavaMethodDescriptor]

'platformToKotlinClassMap' @ [100:21] ==> private final val platformToKotlinClassMap: PlatformToKotlinClassMap defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[PropertyDescriptorImpl]

'traceForImportResolve' @ [100:47] ==> private final val traceForImportResolve: BindingTrace defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[PropertyDescriptorImpl]

'directive' @ [100:70] ==> value-parameter directive: KtImportDirective defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveImportDirective.<anonymous>[ValueParameterDescriptorImpl]

'allDescriptors' @ [100:81] ==> val allDescriptors: Collection<DeclarationDescriptor> defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveImportDirective.<anonymous>[LocalVariableDescriptor]

'Unit' @ [104:9] ==> public object Unit defined in kotlin[FakeCallableDescriptorForObject]

'storageManager' @ [107:70] ==> public final val storageManager: StorageManager defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[PropertyDescriptorImpl]

'createLazyValue' @ [107:85] ==> public abstract fun <T : Any> createLazyValue(computable: () -> Unit): NotNullLazyValue<Unit> defined in org.jetbrains.kotlin.storage.StorageManager[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> Unit

'create' @ [108:49] ==> public open fun <K : (Any..Any?), V : (Any..Any?)> create(): (HashMultimap<(String..String?), (KtImportDirective..KtImportDirective?)>..HashMultimap<(String..String?), (KtImportDirective..KtImportDirective?)>?) defined in com.google.common.collect.HashMultimap[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> String
    <V : (Any..Any?)> -> KtImportDirective

'indexedImports' @ [109:33] ==> public final val indexedImports: IndexedImports defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[PropertyDescriptorImpl]

'imports' @ [109:48] ==> public abstract val imports: List<KtImportDirective> defined in org.jetbrains.kotlin.resolve.lazy.IndexedImports[PropertyDescriptorImpl]

'forceResolveImport' @ [110:13] ==> public open fun forceResolveImport(importDirective: KtImportDirective): Unit defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[SimpleFunctionDescriptorImpl]

'importDirective' @ [110:32] ==> val importDirective: KtImportDirective defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveAllImportsTask.<anonymous>[LocalVariableDescriptor]

'invoke' @ [111:25] ==> public abstract fun invoke(p1: KtImportDirective): ImportingScope? defined in org.jetbrains.kotlin.storage.MemoizedFunctionToNullable[FunctionInvokeDescriptor]

'importDirective' @ [111:48] ==> val importDirective: KtImportDirective defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveAllImportsTask.<anonymous>[LocalVariableDescriptor]

'getAliasName' @ [113:35] ==> @Nullable public open fun getAliasName(@NotNull importDirective: KtImportDirective): Name? defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'importDirective' @ [113:48] ==> val importDirective: KtImportDirective defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveAllImportsTask.<anonymous>[LocalVariableDescriptor]

'identifier' @ [113:66] ==> public final val Name.identifier: String[MyPropertyDescriptor]

'scope' @ [114:17] ==> val scope: ImportingScope? defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveAllImportsTask.<anonymous>[LocalVariableDescriptor]

'alias' @ [114:34] ==> val alias: String? defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveAllImportsTask.<anonymous>[LocalVariableDescriptor]

'scope' @ [115:21] ==> val scope: ImportingScope? defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveAllImportsTask.<anonymous>[LocalVariableDescriptor]

'getContributedClassifier' @ [115:27] ==> public abstract fun getContributedClassifier(name: Name, location: LookupLocation): ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.scopes.ImportingScope[DeserializedSimpleFunctionDescriptor]

'identifier' @ [115:57] ==> @NotNull public open fun identifier(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'alias' @ [115:68] ==> val alias: String? defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveAllImportsTask.<anonymous>[LocalVariableDescriptor]

'KotlinLookupLocation' @ [115:76] ==> public constructor KotlinLookupLocation(element: KtElement) defined in org.jetbrains.kotlin.incremental.KotlinLookupLocation[ClassConstructorDescriptorImpl]

'importDirective' @ [115:97] ==> val importDirective: KtImportDirective defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveAllImportsTask.<anonymous>[LocalVariableDescriptor]

'explicitClassImports' @ [116:21] ==> val explicitClassImports: (HashMultimap<(String..String?), (KtImportDirective..KtImportDirective?)>..HashMultimap<(String..String?), (KtImportDirective..KtImportDirective?)>?) defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveAllImportsTask.<anonymous>[LocalVariableDescriptor]

'put' @ [116:42] ==> @CanIgnoreReturnValue public open fun put(@Nullable p0: String?, @Nullable p1: KtImportDirective?): Boolean defined in com.google.common.collect.HashMultimap[JavaMethodDescriptor]

'alias' @ [116:46] ==> val alias: String? defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveAllImportsTask.<anonymous>[LocalVariableDescriptor]

'importDirective' @ [116:53] ==> val importDirective: KtImportDirective defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveAllImportsTask.<anonymous>[LocalVariableDescriptor]

'checkResolvedImportDirective' @ [120:13] ==> private final fun checkResolvedImportDirective(importDirective: KtImportDirective): Unit defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[SimpleFunctionDescriptorImpl]

'importDirective' @ [120:42] ==> val importDirective: KtImportDirective defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveAllImportsTask.<anonymous>[LocalVariableDescriptor]

'component1' @ [122:15] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(String..String?), (KtImportDirective..KtImportDirective?)>.component1(): (String..String?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (kotlin.String..kotlin.String?)
    <V> -> (org.jetbrains.kotlin.psi.KtImportDirective..org.jetbrains.kotlin.psi.KtImportDirective?)

'component2' @ [122:22] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(String..String?), (KtImportDirective..KtImportDirective?)>.component2(): (KtImportDirective..KtImportDirective?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (kotlin.String..kotlin.String?)
    <V> -> (org.jetbrains.kotlin.psi.KtImportDirective..org.jetbrains.kotlin.psi.KtImportDirective?)

'explicitClassImports' @ [122:33] ==> val explicitClassImports: (HashMultimap<(String..String?), (KtImportDirective..KtImportDirective?)>..HashMultimap<(String..String?), (KtImportDirective..KtImportDirective?)>?) defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveAllImportsTask.<anonymous>[LocalVariableDescriptor]

'entries' @ [122:54] ==> public open fun entries(): (MutableSet<(MutableMap.MutableEntry<(String..String?), (KtImportDirective..KtImportDirective?)>..Map.Entry<(String..String?), (KtImportDirective..KtImportDirective?)>?)>..Set<(MutableMap.MutableEntry<(String..String?), (KtImportDirective..KtImportDirective?)>..Map.Entry<(String..String?), (KtImportDirective..KtImportDirective?)>?)>?) defined in com.google.common.collect.HashMultimap[JavaMethodDescriptor]

'alias' @ [123:17] ==> val alias: (String..String?) defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveAllImportsTask.<anonymous>[LocalVariableDescriptor]

'all' @ [123:23] ==> public inline fun CharSequence.all(predicate: (Char) -> Boolean): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'it' @ [123:29] ==> value-parameter it: Char defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveAllImportsTask.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'traceForImportResolve' @ [124:17] ==> private final val traceForImportResolve: BindingTrace defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[PropertyDescriptorImpl]

'report' @ [124:39] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'UNDERSCORE_IS_RESERVED' @ [124:53] ==> public final val UNDERSCORE_IS_RESERVED: (DiagnosticFactory0<(PsiElement..PsiElement?)>..DiagnosticFactory0<(PsiElement..PsiElement?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [124:76] ==> @NotNull public open fun on(@NotNull element: PsiElement): SimpleDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'import' @ [124:79] ==> val import: (KtImportDirective..KtImportDirective?) defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveAllImportsTask.<anonymous>[LocalVariableDescriptor]

'explicitClassImports' @ [127:23] ==> val explicitClassImports: (HashMultimap<(String..String?), (KtImportDirective..KtImportDirective?)>..HashMultimap<(String..String?), (KtImportDirective..KtImportDirective?)>?) defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveAllImportsTask.<anonymous>[LocalVariableDescriptor]

'keySet' @ [127:44] ==> public open fun keySet(): (MutableSet<(String..String?)>..Set<(String..String?)>?) defined in com.google.common.collect.HashMultimap[JavaMethodDescriptor]

'explicitClassImports' @ [128:27] ==> val explicitClassImports: (HashMultimap<(String..String?), (KtImportDirective..KtImportDirective?)>..HashMultimap<(String..String?), (KtImportDirective..KtImportDirective?)>?) defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveAllImportsTask.<anonymous>[LocalVariableDescriptor]

'get' @ [128:48] ==> public open fun get(@Nullable p0: String?): (MutableSet<(KtImportDirective..KtImportDirective?)>..Set<(KtImportDirective..KtImportDirective?)>?) defined in com.google.common.collect.HashMultimap[JavaMethodDescriptor]

'alias' @ [128:52] ==> val alias: (String..String?) defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveAllImportsTask.<anonymous>[LocalVariableDescriptor]

'imports' @ [129:17] ==> val imports: (MutableSet<(KtImportDirective..KtImportDirective?)>..Set<(KtImportDirective..KtImportDirective?)>?) defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveAllImportsTask.<anonymous>[LocalVariableDescriptor]

'size' @ [129:25] ==> public abstract val size: Int defined in kotlin.collections.MutableSet[DeserializedPropertyDescriptor]

'imports' @ [130:17] ==> val imports: (MutableSet<(KtImportDirective..KtImportDirective?)>..Set<(KtImportDirective..KtImportDirective?)>?) defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveAllImportsTask.<anonymous>[LocalVariableDescriptor]

'forEach' @ [130:25] ==> @HidesMembers public inline fun <T> Iterable<(KtImportDirective..KtImportDirective?)>.forEach(action: ((KtImportDirective..KtImportDirective?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtImportDirective..org.jetbrains.kotlin.psi.KtImportDirective?)

'traceForImportResolve' @ [131:21] ==> private final val traceForImportResolve: BindingTrace defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[PropertyDescriptorImpl]

'report' @ [131:43] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'CONFLICTING_IMPORT' @ [131:57] ==> public final val CONFLICTING_IMPORT: (DiagnosticFactory1<(KtImportDirective..KtImportDirective?), (String..String?)>..DiagnosticFactory1<(KtImportDirective..KtImportDirective?), (String..String?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [131:76] ==> @NotNull public open fun on(@NotNull element: KtImportDirective, @NotNull argument: String): ParametrizedDiagnostic<(KtImportDirective..KtImportDirective?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory1[JavaMethodDescriptor]

'it' @ [131:79] ==> value-parameter it: (KtImportDirective..KtImportDirective?) defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveAllImportsTask.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'alias' @ [131:83] ==> val alias: (String..String?) defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveAllImportsTask.<anonymous>[LocalVariableDescriptor]

'invoke' @ [138:9] ==> public abstract fun invoke(): Unit defined in org.jetbrains.kotlin.storage.NotNullLazyValue[FunctionInvokeDescriptor]

'?:' @ [142:33] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtSimpleNameExpression?, right: KtSimpleNameExpression): KtSimpleNameExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtSimpleNameExpression

'getLastReference' @ [142:43] ==> @Nullable public open fun getLastReference(@NotNull importedReference: KtExpression): KtSimpleNameExpression? defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'importDirective' @ [142:60] ==> value-parameter importDirective: KtImportDirective defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.checkResolvedImportDirective[ValueParameterDescriptorImpl]

'importedReference' @ [142:76] ==> public final val KtImportDirective.importedReference: KtExpression?[MyPropertyDescriptor]

'traceForImportResolve' @ [143:34] ==> private final val traceForImportResolve: BindingTrace defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[PropertyDescriptorImpl]

'bindingContext' @ [143:56] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'get' @ [143:71] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(slice: (ReadOnlySlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?), key: (KtReferenceExpression..KtReferenceExpression?)): DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> KtReferenceExpression
    <V : (Any..Any?)> -> DeclarationDescriptor

'REFERENCE_TARGET' @ [143:90] ==> public final val REFERENCE_TARGET: (WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'importedReference' @ [143:108] ==> val importedReference: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.checkResolvedImportDirective[LocalVariableDescriptor]

'importDirective' @ [145:25] ==> value-parameter importDirective: KtImportDirective defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.checkResolvedImportDirective[ValueParameterDescriptorImpl]

'aliasName' @ [145:41] ==> public final val KtImportDirective.aliasName: String?[MyPropertyDescriptor]

'importedDescriptor' @ [147:13] ==> val importedDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.checkResolvedImportDirective[LocalVariableDescriptor]

'importedDescriptor' @ [147:57] ==> val importedDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.checkResolvedImportDirective[LocalVariableDescriptor]

'isOperator' @ [147:76] ==> public final val FunctionDescriptor.isOperator: Boolean[MyPropertyDescriptor]

'aliasName' @ [148:13] ==> val aliasName: String? defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.checkResolvedImportDirective[LocalVariableDescriptor]

'isConventionName' @ [148:54] ==> public open fun isConventionName(@NotNull name: Name): Boolean defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaMethodDescriptor]

'identifier' @ [148:76] ==> @NotNull public open fun identifier(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'aliasName' @ [148:87] ==> val aliasName: String? defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.checkResolvedImportDirective[LocalVariableDescriptor]

'traceForImportResolve' @ [149:13] ==> private final val traceForImportResolve: BindingTrace defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[PropertyDescriptorImpl]

'report' @ [149:35] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'OPERATOR_RENAMED_ON_IMPORT' @ [149:49] ==> public final val OPERATOR_RENAMED_ON_IMPORT: (DiagnosticFactory0<(KtSimpleNameExpression..KtSimpleNameExpression?)>..DiagnosticFactory0<(KtSimpleNameExpression..KtSimpleNameExpression?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [149:76] ==> @NotNull public open fun on(@NotNull element: KtSimpleNameExpression): SimpleDiagnostic<(KtSimpleNameExpression..KtSimpleNameExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'importedReference' @ [149:79] ==> val importedReference: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.checkResolvedImportDirective[LocalVariableDescriptor]

'invoke' @ [154:9] ==> public abstract fun invoke(p1: KtImportDirective): Unit defined in org.jetbrains.kotlin.storage.MemoizedFunctionToNotNull[FunctionInvokeDescriptor]

'importDirective' @ [154:37] ==> value-parameter importDirective: KtImportDirective defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.forceResolveImport[ValueParameterDescriptorImpl]

'indexedImports' @ [162:27] ==> public final val indexedImports: IndexedImports defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[PropertyDescriptorImpl]

'importsForName' @ [162:42] ==> public abstract fun importsForName(name: Name): Collection<KtImportDirective> defined in org.jetbrains.kotlin.resolve.lazy.IndexedImports[SimpleFunctionDescriptorImpl]

'name' @ [162:57] ==> value-parameter name: Name defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.selectSingleFromImports[ValueParameterDescriptorImpl]

'imports' @ [165:31] ==> val imports: Collection<KtImportDirective> defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.selectSingleFromImports.compute[LocalVariableDescriptor]

'invoke' @ [166:32] ==> public abstract operator fun invoke(p1: ImportingScope, p2: Name): D? defined in kotlin.Function2[FunctionInvokeDescriptor]

'getImportScope' @ [166:51] ==> public final fun getImportScope(directive: KtImportDirective): ImportingScope defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[SimpleFunctionDescriptorImpl]

'directive' @ [166:66] ==> val directive: KtImportDirective defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.selectSingleFromImports.compute[LocalVariableDescriptor]

'name' @ [166:78] ==> value-parameter name: Name defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.selectSingleFromImports[ValueParameterDescriptorImpl]

'target' @ [167:21] ==> var target: D? defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.selectSingleFromImports.compute[LocalVariableDescriptor]

'target' @ [167:39] ==> var target: D? defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.selectSingleFromImports.compute[LocalVariableDescriptor]

'resolved' @ [167:49] ==> val resolved: D defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.selectSingleFromImports.compute[LocalVariableDescriptor]

'target' @ [168:17] ==> var target: D? defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.selectSingleFromImports.compute[LocalVariableDescriptor]

'resolved' @ [168:26] ==> val resolved: D defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.selectSingleFromImports.compute[LocalVariableDescriptor]

'target' @ [170:20] ==> var target: D? defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.selectSingleFromImports.compute[LocalVariableDescriptor]

'storageManager' @ [172:16] ==> public final val storageManager: StorageManager defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[PropertyDescriptorImpl]

'compute' @ [172:31] ==> public abstract fun <T> compute(computable: () -> D?): D? defined in org.jetbrains.kotlin.storage.StorageManager[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> D?

'storageManager' @ [179:16] ==> public final val storageManager: StorageManager defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[PropertyDescriptorImpl]

'compute' @ [179:31] ==> public abstract fun <T> compute(computable: () -> Collection<D>): Collection<D> defined in org.jetbrains.kotlin.storage.StorageManager[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Collection<D>

'indexedImports' @ [181:31] ==> public final val indexedImports: IndexedImports defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[PropertyDescriptorImpl]

'importsForName' @ [181:46] ==> public abstract fun importsForName(name: Name): Collection<KtImportDirective> defined in org.jetbrains.kotlin.resolve.lazy.IndexedImports[SimpleFunctionDescriptorImpl]

'name' @ [181:61] ==> value-parameter name: Name defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.collectFromImports[ValueParameterDescriptorImpl]

'invoke' @ [182:44] ==> public abstract operator fun invoke(p1: ImportingScope, p2: Name): Collection<D> defined in kotlin.Function2[FunctionInvokeDescriptor]

'getImportScope' @ [182:64] ==> public final fun getImportScope(directive: KtImportDirective): ImportingScope defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[SimpleFunctionDescriptorImpl]

'directive' @ [182:79] ==> val directive: KtImportDirective defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.collectFromImports.<anonymous>[LocalVariableDescriptor]

'name' @ [182:91] ==> value-parameter name: Name defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.collectFromImports[ValueParameterDescriptorImpl]

'descriptors' @ [183:17] ==> var descriptors: Collection<D>? defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.collectFromImports.<anonymous>[LocalVariableDescriptor]

'descriptors' @ [183:31] ==> var descriptors: Collection<D>? defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.collectFromImports.<anonymous>[LocalVariableDescriptor]

'concat' @ [183:43] ==> public fun <T> Collection<D>?.concat(collection: Collection<D>): Collection<D>? defined in org.jetbrains.kotlin.util.collectionUtils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> D

'descriptorsForImport' @ [183:50] ==> val descriptorsForImport: Collection<D> defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.collectFromImports.<anonymous>[LocalVariableDescriptor]

'descriptors' @ [186:13] ==> var descriptors: Collection<D>? defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.collectFromImports.<anonymous>[LocalVariableDescriptor]

'emptySet' @ [186:28] ==> public fun <T> emptySet(): Set<D> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> D

'invoke' @ [191:16] ==> public abstract fun invoke(p1: KtImportDirective): ImportingScope? defined in org.jetbrains.kotlin.storage.MemoizedFunctionToNullable[FunctionInvokeDescriptor]

'directive' @ [191:39] ==> value-parameter directive: KtImportDirective defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver.getImportScope[ValueParameterDescriptorImpl]

'Empty' @ [191:68] ==> public object Empty : BaseImportingScope defined in org.jetbrains.kotlin.resolve.scopes.ImportingScope[FakeCallableDescriptorForObject]

'filteringKind' @ [209:13] ==> private final val filteringKind: LazyImportScope.FilteringKind defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope[PropertyDescriptorImpl]

'ALL' @ [209:44] ==> enum entry ALL defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.FilteringKind[FakeCallableDescriptorForObject]

'descriptor' @ [211:13] ==> value-parameter descriptor: ClassifierDescriptor defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.isClassifierVisible[ValueParameterDescriptorImpl]

'isHiddenInResolution' @ [211:24] ==> @JvmOverloads public fun DeclarationDescriptor.isHiddenInResolution(languageVersionSettings: LanguageVersionSettings, isSuperCall: Boolean = ...): Boolean defined in org.jetbrains.kotlin.resolve in file deprecationUtil.kt[SimpleFunctionDescriptorImpl]

'importResolver' @ [211:45] ==> private final val importResolver: LazyImportResolver defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope[PropertyDescriptorImpl]

'languageVersionSettings' @ [211:60] ==> public final val languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[PropertyDescriptorImpl]

'descriptor' @ [213:27] ==> value-parameter descriptor: ClassifierDescriptor defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.isClassifierVisible[ValueParameterDescriptorImpl]

'visibility' @ [213:78] ==> public final val DeclarationDescriptorWithVisibility.visibility: Visibility[MyPropertyDescriptor]

'filteringKind' @ [214:30] ==> private final val filteringKind: LazyImportScope.FilteringKind defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope[PropertyDescriptorImpl]

'VISIBLE_CLASSES' @ [214:61] ==> enum entry VISIBLE_CLASSES defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.FilteringKind[FakeCallableDescriptorForObject]

'!' @ [215:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'visibility' @ [215:14] ==> val visibility: Visibility defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.isClassifierVisible[LocalVariableDescriptor]

'mustCheckInImports' @ [215:25] ==> public abstract fun mustCheckInImports(): Boolean defined in org.jetbrains.kotlin.descriptors.Visibility[DeserializedSimpleFunctionDescriptor]

'includeVisible' @ [215:54] ==> val includeVisible: Boolean defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.isClassifierVisible[LocalVariableDescriptor]

'==' @ [216:16] ==> public open fun equals(other: Any?): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isVisibleIgnoringReceiver' @ [216:29] ==> public open fun isVisibleIgnoringReceiver(@NotNull p0: DeclarationDescriptorWithVisibility, @NotNull p1: DeclarationDescriptor): Boolean defined in org.jetbrains.kotlin.descriptors.Visibilities[JavaMethodDescriptor]

'descriptor' @ [216:55] ==> value-parameter descriptor: ClassifierDescriptor defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.isClassifierVisible[ValueParameterDescriptorImpl]

'importResolver' @ [216:67] ==> private final val importResolver: LazyImportResolver defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope[PropertyDescriptorImpl]

'moduleDescriptor' @ [216:82] ==> public final val moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[PropertyDescriptorImpl]

'includeVisible' @ [216:103] ==> val includeVisible: Boolean defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.isClassifierVisible[LocalVariableDescriptor]

'importResolver' @ [220:16] ==> private final val importResolver: LazyImportResolver defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope[PropertyDescriptorImpl]

'selectSingleFromImports' @ [220:31] ==> public final fun <D : DeclarationDescriptor> selectSingleFromImports(name: Name, descriptorSelector: (ImportingScope, Name) -> ClassifierDescriptor?): ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[SimpleFunctionDescriptorImpl]
Inferred types:
    <D : DeclarationDescriptor> -> ClassifierDescriptor

'name' @ [220:55] ==> value-parameter name: Name defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedClassifier[ValueParameterDescriptorImpl]

'scope' @ [221:30] ==> value-parameter scope: ImportingScope defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedClassifier.<anonymous>[ValueParameterDescriptorImpl]

'getContributedClassifier' @ [221:36] ==> public abstract fun getContributedClassifier(name: Name, location: LookupLocation): ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.scopes.ImportingScope[DeserializedSimpleFunctionDescriptor]

'name' @ [221:61] ==> value-parameter name: Name defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedClassifier.<anonymous>[ValueParameterDescriptorImpl]

'location' @ [221:67] ==> value-parameter location: LookupLocation defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedClassifier[ValueParameterDescriptorImpl]

'if ((descriptor is ClassDescriptor || descriptor is TypeAliasDescriptor) && isClassifierVisible(descriptor))
                descriptor
            else
                null' @ [222:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: ClassifierDescriptor?, elseBranch: ClassifierDescriptor?): ClassifierDescriptor?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> ClassifierDescriptor?

'descriptor' @ [222:18] ==> val descriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedClassifier.<anonymous>[LocalVariableDescriptor]

'descriptor' @ [222:51] ==> val descriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedClassifier.<anonymous>[LocalVariableDescriptor]

'isClassifierVisible' @ [222:89] ==> private final fun isClassifierVisible(descriptor: ClassifierDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope[SimpleFunctionDescriptorImpl]

'descriptor' @ [222:109] ==> val descriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedClassifier.<anonymous>[LocalVariableDescriptor]

'descriptor' @ [223:17] ==> val descriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedClassifier.<anonymous>[LocalVariableDescriptor]

'filteringKind' @ [232:13] ==> private final val filteringKind: LazyImportScope.FilteringKind defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope[PropertyDescriptorImpl]

'INVISIBLE_CLASSES' @ [232:44] ==> enum entry INVISIBLE_CLASSES defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.FilteringKind[FakeCallableDescriptorForObject]

'listOf' @ [232:70] ==> @InlineOnly public inline fun <T> listOf(): List<VariableDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> VariableDescriptor

'importResolver' @ [233:16] ==> private final val importResolver: LazyImportResolver defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope[PropertyDescriptorImpl]

'collectFromImports' @ [233:31] ==> public final fun <D : DeclarationDescriptor> collectFromImports(name: Name, descriptorsSelector: (ImportingScope, Name) -> Collection<VariableDescriptor>): Collection<VariableDescriptor> defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[SimpleFunctionDescriptorImpl]
Inferred types:
    <D : DeclarationDescriptor> -> VariableDescriptor

'name' @ [233:50] ==> value-parameter name: Name defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedVariables[ValueParameterDescriptorImpl]

'scope' @ [233:73] ==> value-parameter scope: ImportingScope defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedVariables.<anonymous>[ValueParameterDescriptorImpl]

'getContributedVariables' @ [233:79] ==> public abstract fun getContributedVariables(name: Name, location: LookupLocation): Collection<VariableDescriptor> defined in org.jetbrains.kotlin.resolve.scopes.ImportingScope[DeserializedSimpleFunctionDescriptor]

'name' @ [233:103] ==> value-parameter name: Name defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedVariables.<anonymous>[ValueParameterDescriptorImpl]

'location' @ [233:109] ==> value-parameter location: LookupLocation defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedVariables[ValueParameterDescriptorImpl]

'filteringKind' @ [237:13] ==> private final val filteringKind: LazyImportScope.FilteringKind defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope[PropertyDescriptorImpl]

'INVISIBLE_CLASSES' @ [237:44] ==> enum entry INVISIBLE_CLASSES defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.FilteringKind[FakeCallableDescriptorForObject]

'listOf' @ [237:70] ==> @InlineOnly public inline fun <T> listOf(): List<FunctionDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FunctionDescriptor

'importResolver' @ [238:16] ==> private final val importResolver: LazyImportResolver defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope[PropertyDescriptorImpl]

'collectFromImports' @ [238:31] ==> public final fun <D : DeclarationDescriptor> collectFromImports(name: Name, descriptorsSelector: (ImportingScope, Name) -> Collection<FunctionDescriptor>): Collection<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[SimpleFunctionDescriptorImpl]
Inferred types:
    <D : DeclarationDescriptor> -> FunctionDescriptor

'name' @ [238:50] ==> value-parameter name: Name defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedFunctions[ValueParameterDescriptorImpl]

'scope' @ [238:73] ==> value-parameter scope: ImportingScope defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedFunctions.<anonymous>[ValueParameterDescriptorImpl]

'getContributedFunctions' @ [238:79] ==> public abstract fun getContributedFunctions(name: Name, location: LookupLocation): Collection<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.scopes.ImportingScope[DeserializedSimpleFunctionDescriptor]

'name' @ [238:103] ==> value-parameter name: Name defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedFunctions.<anonymous>[ValueParameterDescriptorImpl]

'location' @ [238:109] ==> value-parameter location: LookupLocation defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedFunctions[ValueParameterDescriptorImpl]

'filteringKind' @ [247:13] ==> private final val filteringKind: LazyImportScope.FilteringKind defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope[PropertyDescriptorImpl]

'INVISIBLE_CLASSES' @ [247:44] ==> enum entry INVISIBLE_CLASSES defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.FilteringKind[FakeCallableDescriptorForObject]

'listOf' @ [247:70] ==> @InlineOnly public inline fun <T> listOf(): List<DeclarationDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DeclarationDescriptor

'importResolver' @ [249:16] ==> private final val importResolver: LazyImportResolver defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope[PropertyDescriptorImpl]

'storageManager' @ [249:31] ==> public final val storageManager: StorageManager defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[PropertyDescriptorImpl]

'compute' @ [249:46] ==> public abstract fun <T> compute(computable: () -> LinkedHashSet<DeclarationDescriptor>): LinkedHashSet<DeclarationDescriptor> defined in org.jetbrains.kotlin.storage.StorageManager[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> LinkedHashSet<DeclarationDescriptor>

'LinkedHashSet' @ [250:31] ==> public constructor LinkedHashSet<E : (Any..Any?)>() defined in java.util.LinkedHashSet[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> DeclarationDescriptor

'importResolver' @ [251:31] ==> private final val importResolver: LazyImportResolver defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope[PropertyDescriptorImpl]

'indexedImports' @ [251:46] ==> public final val indexedImports: IndexedImports defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[PropertyDescriptorImpl]

'imports' @ [251:61] ==> public abstract val imports: List<KtImportDirective> defined in org.jetbrains.kotlin.resolve.lazy.IndexedImports[PropertyDescriptorImpl]

'directive' @ [252:34] ==> val directive: KtImportDirective defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedDescriptors.<anonymous>[LocalVariableDescriptor]

'importPath' @ [252:44] ==> public final val KtImportDirective.importPath: ImportPath?[MyPropertyDescriptor]

'importPath' @ [253:36] ==> val importPath: ImportPath defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedDescriptors.<anonymous>[LocalVariableDescriptor]

'importedName' @ [253:47] ==> public final val importedName: Name? defined in org.jetbrains.kotlin.resolve.ImportPath[PropertyDescriptorImpl]

'importedName' @ [254:21] ==> val importedName: Name? defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedDescriptors.<anonymous>[LocalVariableDescriptor]

'invoke' @ [254:45] ==> public abstract operator fun invoke(p1: Name): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'importedName' @ [254:56] ==> val importedName: Name? defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedDescriptors.<anonymous>[LocalVariableDescriptor]

'descriptors' @ [255:21] ==> val descriptors: LinkedHashSet<DeclarationDescriptor> defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedDescriptors.<anonymous>[LocalVariableDescriptor]

'addAll' @ [255:33] ==> public open fun addAll(elements: Collection<DeclarationDescriptor>): Boolean defined in java.util.LinkedHashSet[JavaMethodDescriptor]

'importResolver' @ [255:40] ==> private final val importResolver: LazyImportResolver defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope[PropertyDescriptorImpl]

'getImportScope' @ [255:55] ==> public final fun getImportScope(directive: KtImportDirective): ImportingScope defined in org.jetbrains.kotlin.resolve.lazy.LazyImportResolver[SimpleFunctionDescriptorImpl]

'directive' @ [255:70] ==> val directive: KtImportDirective defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedDescriptors.<anonymous>[LocalVariableDescriptor]

'getContributedDescriptors' @ [255:81] ==> public abstract fun getContributedDescriptors(kindFilter: DescriptorKindFilter = ..., nameFilter: (Name) -> Boolean = ..., changeNamesForAliased: Boolean): Collection<DeclarationDescriptor> defined in org.jetbrains.kotlin.resolve.scopes.ImportingScope[DeserializedSimpleFunctionDescriptor]

'kindFilter' @ [255:107] ==> value-parameter kindFilter: DescriptorKindFilter defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedDescriptors[ValueParameterDescriptorImpl]

'nameFilter' @ [255:119] ==> value-parameter nameFilter: (Name) -> Boolean defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedDescriptors[ValueParameterDescriptorImpl]

'changeNamesForAliased' @ [255:131] ==> value-parameter changeNamesForAliased: Boolean defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedDescriptors[ValueParameterDescriptorImpl]

'descriptors' @ [258:13] ==> val descriptors: LinkedHashSet<DeclarationDescriptor> defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.getContributedDescriptors.<anonymous>[LocalVariableDescriptor]

'+' @ [262:31] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'debugName' @ [262:53] ==> private final val debugName: String defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope[PropertyDescriptorImpl]

'p' @ [265:9] ==> value-parameter p: Printer defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.printStructure[ValueParameterDescriptorImpl]

'println' @ [265:11] ==> @NotNull public open fun println(vararg p0: (Any..Any?)): Printer defined in org.jetbrains.kotlin.utils.Printer[JavaMethodDescriptor]

'this' @ [265:19] ==> <this> defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope[LazyClassReceiverParameterDescriptor]

'java' @ [265:31] ==> public val <T> KClass<out LazyImportScope>.java: Class<out LazyImportScope> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> LazyImportScope

'simpleName' @ [265:36] ==> public final val <T : (Any..Any?)> Class<out LazyImportScope>.simpleName: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> LazyImportScope

'debugName' @ [265:54] ==> private final val debugName: String defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope[PropertyDescriptorImpl]

'p' @ [266:9] ==> value-parameter p: Printer defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.printStructure[ValueParameterDescriptorImpl]

'pushIndent' @ [266:11] ==> @NotNull public open fun pushIndent(): Printer defined in org.jetbrains.kotlin.utils.Printer[JavaMethodDescriptor]

'p' @ [268:9] ==> value-parameter p: Printer defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.printStructure[ValueParameterDescriptorImpl]

'popIndent' @ [268:11] ==> @NotNull public open fun popIndent(): Printer defined in org.jetbrains.kotlin.utils.Printer[JavaMethodDescriptor]

'p' @ [269:9] ==> value-parameter p: Printer defined in org.jetbrains.kotlin.resolve.lazy.LazyImportScope.printStructure[ValueParameterDescriptorImpl]

'println' @ [269:11] ==> @NotNull public open fun println(vararg p0: (Any..Any?)): Printer defined in org.jetbrains.kotlin.utils.Printer[JavaMethodDescriptor]

