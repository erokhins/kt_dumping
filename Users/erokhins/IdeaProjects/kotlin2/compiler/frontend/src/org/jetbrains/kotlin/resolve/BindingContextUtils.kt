'getTargetLabel' @ [41:23] ==> public final fun getTargetLabel(): KtSimpleNameExpression? defined in org.jetbrains.kotlin.psi.KtReturnExpression[SimpleFunctionDescriptorImpl]

'targetLabel' @ [42:9] ==> val targetLabel: KtSimpleNameExpression? defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getTargetFunctionDescriptor[LocalVariableDescriptor]

'context' @ [42:37] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getTargetFunctionDescriptor[ValueParameterDescriptorImpl]

'LABEL_TARGET' @ [42:45] ==> public final val LABEL_TARGET: (WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (PsiElement..PsiElement?)>..WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (PsiElement..PsiElement?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'targetLabel' @ [42:59] ==> val targetLabel: KtSimpleNameExpression? defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getTargetFunctionDescriptor[LocalVariableDescriptor]

'let' @ [42:73] ==> @InlineOnly public inline fun <T, R> PsiElement.let(block: (PsiElement) -> SimpleFunctionDescriptor?): SimpleFunctionDescriptor? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PsiElement
    <R> -> SimpleFunctionDescriptor?

'context' @ [42:79] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getTargetFunctionDescriptor[ValueParameterDescriptorImpl]

'FUNCTION' @ [42:87] ==> public final val FUNCTION: (WritableSlice<(PsiElement..PsiElement?), (SimpleFunctionDescriptor..SimpleFunctionDescriptor?)>..WritableSlice<(PsiElement..PsiElement?), (SimpleFunctionDescriptor..SimpleFunctionDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'it' @ [42:97] ==> value-parameter it: PsiElement defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getTargetFunctionDescriptor.<anonymous>[ValueParameterDescriptorImpl]

'context' @ [44:33] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getTargetFunctionDescriptor[ValueParameterDescriptorImpl]

'DECLARATION_TO_DESCRIPTOR' @ [44:41] ==> @SuppressWarnings public final val DECLARATION_TO_DESCRIPTOR: (ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(PsiElement..PsiElement?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'getNonStrictParentOfType' @ [44:68] ==> public inline fun <reified T : PsiElement> PsiElement.getNonStrictParentOfType(): KtDeclarationWithBody? defined in org.jetbrains.kotlin.psi.psiUtil[SimpleFunctionDescriptorImpl]
Inferred types:
    <reified T : PsiElement> -> KtDeclarationWithBody

'getParentOfType' @ [45:56] ==> @Nullable public open fun <D : (DeclarationDescriptor..DeclarationDescriptor?)> getParentOfType(@Nullable p0: DeclarationDescriptor?, @NotNull p1: Class<(FunctionDescriptor..FunctionDescriptor?)>, p2: Boolean): FunctionDescriptor? defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]
Inferred types:
    <D : (DeclarationDescriptor..DeclarationDescriptor?)> -> (org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)

'declarationDescriptor' @ [45:72] ==> val declarationDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getTargetFunctionDescriptor[LocalVariableDescriptor]

'java' @ [45:121] ==> public val <T> KClass<FunctionDescriptor>.java: Class<FunctionDescriptor> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> FunctionDescriptor

'containingFunctionDescriptor' @ [46:9] ==> val containingFunctionDescriptor: FunctionDescriptor? defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getTargetFunctionDescriptor[LocalVariableDescriptor]

'generateSequence' @ [48:12] ==> @LowPriorityInOverloadResolution public fun <T : Any> generateSequence(seed: FunctionDescriptor?, nextFunction: (FunctionDescriptor) -> FunctionDescriptor?): Sequence<FunctionDescriptor> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> FunctionDescriptor

'containingFunctionDescriptor' @ [48:29] ==> val containingFunctionDescriptor: FunctionDescriptor? defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getTargetFunctionDescriptor[LocalVariableDescriptor]

'getParentOfType' @ [48:77] ==> @Nullable public open fun <D : (DeclarationDescriptor..DeclarationDescriptor?)> getParentOfType(@Nullable p0: DeclarationDescriptor?, @NotNull p1: Class<(FunctionDescriptor..FunctionDescriptor?)>): FunctionDescriptor? defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]
Inferred types:
    <D : (DeclarationDescriptor..DeclarationDescriptor?)> -> (org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)

'it' @ [48:93] ==> value-parameter it: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getTargetFunctionDescriptor.<anonymous>[ValueParameterDescriptorImpl]

'java' @ [48:123] ==> public val <T> KClass<FunctionDescriptor>.java: Class<FunctionDescriptor> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> FunctionDescriptor

'dropWhile' @ [49:14] ==> public fun <T> Sequence<FunctionDescriptor>.dropWhile(predicate: (FunctionDescriptor) -> Boolean): Sequence<FunctionDescriptor> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FunctionDescriptor

'it' @ [49:26] ==> value-parameter it: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getTargetFunctionDescriptor.<anonymous>[ValueParameterDescriptorImpl]

'firstOrNull' @ [50:14] ==> public fun <T> Sequence<FunctionDescriptor>.firstOrNull(): FunctionDescriptor? defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FunctionDescriptor

'getTargetFunctionDescriptor' @ [54:12] ==> public fun KtReturnExpression.getTargetFunctionDescriptor(context: BindingContext): FunctionDescriptor? defined in org.jetbrains.kotlin.resolve.bindingContextUtil in file BindingContextUtils.kt[SimpleFunctionDescriptorImpl]

'context' @ [54:40] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getTargetFunction[ValueParameterDescriptorImpl]

'let' @ [54:50] ==> @InlineOnly public inline fun <T, R> FunctionDescriptor.let(block: (FunctionDescriptor) -> KtCallableDeclaration?): KtCallableDeclaration? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FunctionDescriptor
    <R> -> KtCallableDeclaration?

'DescriptorToSourceUtils' @ [54:56] ==> public object DescriptorToSourceUtils defined in org.jetbrains.kotlin.resolve in file DescriptorToSourceUtils.kt[FakeCallableDescriptorForObject]

'descriptorToDeclaration' @ [54:80] ==> @JvmStatic public final fun descriptorToDeclaration(descriptor: DeclarationDescriptor): PsiElement? defined in org.jetbrains.kotlin.resolve.DescriptorToSourceUtils[SimpleFunctionDescriptorImpl]

'it' @ [54:104] ==> value-parameter it: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getTargetFunction.<anonymous>[ValueParameterDescriptorImpl]

'context' @ [57:73] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.bindingContextUtil.isUsedAsExpression[ValueParameterDescriptorImpl]

'USED_AS_EXPRESSION' @ [57:96] ==> public final val USED_AS_EXPRESSION: (WritableSlice<(KtElement..KtElement?), (Boolean..Boolean?)>..WritableSlice<(KtElement..KtElement?), (Boolean..Boolean?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'this' @ [57:116] ==> <this> defined in org.jetbrains.kotlin.resolve.bindingContextUtil.isUsedAsExpression[ReceiverParameterDescriptorImpl]

'context' @ [58:77] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.bindingContextUtil.isUsedAsResultOfLambda[ValueParameterDescriptorImpl]

'USED_AS_RESULT_OF_LAMBDA' @ [58:100] ==> public final val USED_AS_RESULT_OF_LAMBDA: (WritableSlice<(KtElement..KtElement?), (Boolean..Boolean?)>..WritableSlice<(KtElement..KtElement?), (Boolean..Boolean?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'this' @ [58:126] ==> <this> defined in org.jetbrains.kotlin.resolve.bindingContextUtil.isUsedAsResultOfLambda[ReceiverParameterDescriptorImpl]

'!' @ [59:72] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isUsedAsExpression' @ [59:73] ==> public fun KtExpression.isUsedAsExpression(context: BindingContext): Boolean defined in org.jetbrains.kotlin.resolve.bindingContextUtil in file BindingContextUtils.kt[SimpleFunctionDescriptorImpl]

'context' @ [59:92] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.bindingContextUtil.isUsedAsStatement[ValueParameterDescriptorImpl]

'expression' @ [63:9] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.bindingContextUtil.recordDataFlowInfo[ValueParameterDescriptorImpl]

'trace' @ [65:20] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'get' @ [65:26] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(slice: (ReadOnlySlice<(KtExpression..KtExpression?), (KotlinTypeInfo..KotlinTypeInfo?)>..ReadOnlySlice<(KtExpression..KtExpression?), (KotlinTypeInfo..KotlinTypeInfo?)>?), key: (KtExpression..KtExpression?)): KotlinTypeInfo? defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.types.expressions.KotlinTypeInfo..org.jetbrains.kotlin.types.expressions.KotlinTypeInfo?)

'EXPRESSION_TYPE_INFO' @ [65:45] ==> public final val EXPRESSION_TYPE_INFO: (WritableSlice<(KtExpression..KtExpression?), (KotlinTypeInfo..KotlinTypeInfo?)>..WritableSlice<(KtExpression..KtExpression?), (KotlinTypeInfo..KotlinTypeInfo?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'expression' @ [65:67] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.bindingContextUtil.recordDataFlowInfo[ValueParameterDescriptorImpl]

'if (typeInfo != null) {
        trace.record(BindingContext.EXPRESSION_TYPE_INFO, expression, typeInfo.replaceDataFlowInfo(dataFlowInfo))
    }
    else if (dataFlowInfo != DataFlowInfo.EMPTY) {
        // Don't store anything in BindingTrace if it's simply an empty DataFlowInfo
        trace.record(BindingContext.EXPRESSION_TYPE_INFO, expression, noTypeInfo(dataFlowInfo))
    }' @ [66:5] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'typeInfo' @ [66:9] ==> val typeInfo: KotlinTypeInfo? defined in org.jetbrains.kotlin.resolve.bindingContextUtil.recordDataFlowInfo[LocalVariableDescriptor]

'trace' @ [67:9] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'record' @ [67:15] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(KtExpression..KtExpression?), (KotlinTypeInfo..KotlinTypeInfo?)>..WritableSlice<(KtExpression..KtExpression?), (KotlinTypeInfo..KotlinTypeInfo?)>?), key: (KtExpression..KtExpression?), value: (KotlinTypeInfo..KotlinTypeInfo?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.types.expressions.KotlinTypeInfo..org.jetbrains.kotlin.types.expressions.KotlinTypeInfo?)

'EXPRESSION_TYPE_INFO' @ [67:37] ==> public final val EXPRESSION_TYPE_INFO: (WritableSlice<(KtExpression..KtExpression?), (KotlinTypeInfo..KotlinTypeInfo?)>..WritableSlice<(KtExpression..KtExpression?), (KotlinTypeInfo..KotlinTypeInfo?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'expression' @ [67:59] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.bindingContextUtil.recordDataFlowInfo[ValueParameterDescriptorImpl]

'typeInfo' @ [67:71] ==> val typeInfo: KotlinTypeInfo? defined in org.jetbrains.kotlin.resolve.bindingContextUtil.recordDataFlowInfo[LocalVariableDescriptor]

'replaceDataFlowInfo' @ [67:80] ==> public final fun replaceDataFlowInfo(dataFlowInfo: DataFlowInfo): KotlinTypeInfo defined in org.jetbrains.kotlin.types.expressions.KotlinTypeInfo[SimpleFunctionDescriptorImpl]

'dataFlowInfo' @ [67:100] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'dataFlowInfo' @ [69:14] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'EMPTY' @ [69:43] ==> public final val EMPTY: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo.Companion[PropertyDescriptorImpl]

'trace' @ [71:9] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'record' @ [71:15] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(KtExpression..KtExpression?), (KotlinTypeInfo..KotlinTypeInfo?)>..WritableSlice<(KtExpression..KtExpression?), (KotlinTypeInfo..KotlinTypeInfo?)>?), key: (KtExpression..KtExpression?), value: (KotlinTypeInfo..KotlinTypeInfo?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.types.expressions.KotlinTypeInfo..org.jetbrains.kotlin.types.expressions.KotlinTypeInfo?)

'EXPRESSION_TYPE_INFO' @ [71:37] ==> public final val EXPRESSION_TYPE_INFO: (WritableSlice<(KtExpression..KtExpression?), (KotlinTypeInfo..KotlinTypeInfo?)>..WritableSlice<(KtExpression..KtExpression?), (KotlinTypeInfo..KotlinTypeInfo?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'expression' @ [71:59] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.bindingContextUtil.recordDataFlowInfo[ValueParameterDescriptorImpl]

'noTypeInfo' @ [71:71] ==> public fun noTypeInfo(dataFlowInfo: DataFlowInfo): KotlinTypeInfo defined in org.jetbrains.kotlin.types.expressions.typeInfoFactory in file TypeInfoFactory.kt[SimpleFunctionDescriptorImpl]

'dataFlowInfo' @ [71:82] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'element' @ [76:9] ==> value-parameter element: KtElement? defined in org.jetbrains.kotlin.resolve.bindingContextUtil.recordScope[ValueParameterDescriptorImpl]

'record' @ [77:9] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(KtElement..KtElement?), (LexicalScope..LexicalScope?)>..WritableSlice<(KtElement..KtElement?), (LexicalScope..LexicalScope?)>?), key: (KtElement..KtElement?), value: (LexicalScope..LexicalScope?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtElement..org.jetbrains.kotlin.psi.KtElement?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.resolve.scopes.LexicalScope..org.jetbrains.kotlin.resolve.scopes.LexicalScope?)

'LEXICAL_SCOPE' @ [77:31] ==> public final val LEXICAL_SCOPE: (WritableSlice<(KtElement..KtElement?), (LexicalScope..LexicalScope?)>..WritableSlice<(KtElement..KtElement?), (LexicalScope..LexicalScope?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'element' @ [77:46] ==> value-parameter element: KtElement? defined in org.jetbrains.kotlin.resolve.bindingContextUtil.recordScope[ValueParameterDescriptorImpl]

'scope' @ [77:55] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.bindingContextUtil.recordScope[ValueParameterDescriptorImpl]

'takeSnapshot' @ [77:61] ==> public fun HierarchicalScope.takeSnapshot(): HierarchicalScope defined in org.jetbrains.kotlin.resolve.scopes.utils[DeserializedSimpleFunctionDescriptor]

'position' @ [82:21] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getDataFlowInfoAfter[ValueParameterDescriptorImpl]

'parentsWithSelf' @ [82:30] ==> public val PsiElement.parentsWithSelf: Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil in file psiUtils.kt[PropertyDescriptorImpl]

'element' @ [83:10] ==> val element: PsiElement defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getDataFlowInfoAfter[LocalVariableDescriptor]

'let' @ [83:37] ==> @InlineOnly public inline fun <T, R> KtExpression.let(block: (KtExpression) -> KotlinTypeInfo?): KotlinTypeInfo? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression
    <R> -> KotlinTypeInfo?

'it' @ [84:26] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getDataFlowInfoAfter.<anonymous>[ValueParameterDescriptorImpl]

'parent' @ [84:29] ==> public final val KtExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [86:17] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getDataFlowInfoAfter.<anonymous>[LocalVariableDescriptor]

'it' @ [86:52] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getDataFlowInfoAfter.<anonymous>[ValueParameterDescriptorImpl]

'parent' @ [86:58] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getDataFlowInfoAfter.<anonymous>[LocalVariableDescriptor]

'selectorExpression' @ [86:65] ==> public open val selectorExpression: KtExpression? defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[PropertyDescriptorImpl]

'this' @ [87:13] ==> <this> defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getDataFlowInfoAfter[ReceiverParameterDescriptorImpl]

'EXPRESSION_TYPE_INFO' @ [87:33] ==> public final val EXPRESSION_TYPE_INFO: (WritableSlice<(KtExpression..KtExpression?), (KotlinTypeInfo..KotlinTypeInfo?)>..WritableSlice<(KtExpression..KtExpression?), (KotlinTypeInfo..KotlinTypeInfo?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'it' @ [87:55] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getDataFlowInfoAfter.<anonymous>[ValueParameterDescriptorImpl]

'let' @ [88:12] ==> @InlineOnly public inline fun <T, R> KotlinTypeInfo.let(block: (KotlinTypeInfo) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTypeInfo
    <R> -> Nothing

'it' @ [88:25] ==> value-parameter it: KotlinTypeInfo defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getDataFlowInfoAfter.<anonymous>[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [88:28] ==> public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.types.expressions.KotlinTypeInfo[PropertyDescriptorImpl]

'DataFlowInfo' @ [90:12] ==> public companion object defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo[FakeCallableDescriptorForObject]

'EMPTY' @ [90:25] ==> public final val EMPTY: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo.Companion[PropertyDescriptorImpl]

'position' @ [94:21] ==> value-parameter position: PsiElement defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getDataFlowInfoBefore[ValueParameterDescriptorImpl]

'parentsWithSelf' @ [94:30] ==> public val PsiElement.parentsWithSelf: Sequence<PsiElement> defined in org.jetbrains.kotlin.psi.psiUtil in file psiUtils.kt[PropertyDescriptorImpl]

'element' @ [95:10] ==> val element: PsiElement defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getDataFlowInfoBefore[LocalVariableDescriptor]

'let' @ [96:19] ==> @InlineOnly public inline fun <T, R> KtExpression.let(block: (KtExpression) -> DataFlowInfo?): DataFlowInfo? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression
    <R> -> DataFlowInfo?

'this' @ [96:25] ==> <this> defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getDataFlowInfoBefore[ReceiverParameterDescriptorImpl]

'DATA_FLOW_INFO_BEFORE' @ [96:45] ==> public final val DATA_FLOW_INFO_BEFORE: (WritableSlice<(KtExpression..KtExpression?), (DataFlowInfo..DataFlowInfo?)>..WritableSlice<(KtExpression..KtExpression?), (DataFlowInfo..DataFlowInfo?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'it' @ [96:68] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getDataFlowInfoBefore.<anonymous>[ValueParameterDescriptorImpl]

'let' @ [97:19] ==> @InlineOnly public inline fun <T, R> DataFlowInfo.let(block: (DataFlowInfo) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DataFlowInfo
    <R> -> Nothing

'it' @ [97:32] ==> value-parameter it: DataFlowInfo defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getDataFlowInfoBefore.<anonymous>[ValueParameterDescriptorImpl]

'DataFlowInfo' @ [99:12] ==> public companion object defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo[FakeCallableDescriptorForObject]

'EMPTY' @ [99:25] ==> public final val EMPTY: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo.Companion[PropertyDescriptorImpl]

'context' @ [102:72] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.bindingContextUtil.isUnreachableCode[ValueParameterDescriptorImpl]

'UNREACHABLE_CODE' @ [102:95] ==> public final val UNREACHABLE_CODE: (WritableSlice<(KtElement..KtElement?), (Boolean..Boolean?)>..WritableSlice<(KtElement..KtElement?), (Boolean..Boolean?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'this' @ [102:113] ==> <this> defined in org.jetbrains.kotlin.resolve.bindingContextUtil.isUnreachableCode[ReceiverParameterDescriptorImpl]

'if (this is KtReferenceExpression) context[BindingContext.REFERENCE_TARGET, this] else null' @ [105:28] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: DeclarationDescriptor?, elseBranch: DeclarationDescriptor?): DeclarationDescriptor?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> DeclarationDescriptor?

'this' @ [105:32] ==> <this> defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getReferenceTargets[ReceiverParameterDescriptorImpl]

'context' @ [105:63] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getReferenceTargets[ValueParameterDescriptorImpl]

'REFERENCE_TARGET' @ [105:86] ==> public final val REFERENCE_TARGET: (WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'this' @ [105:104] ==> <this> defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getReferenceTargets[ReceiverParameterDescriptorImpl]

'targetDescriptor' @ [106:12] ==> val targetDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getReferenceTargets[LocalVariableDescriptor]

'let' @ [106:30] ==> @InlineOnly public inline fun <T, R> DeclarationDescriptor.let(block: (DeclarationDescriptor) -> List<DeclarationDescriptor>): List<DeclarationDescriptor> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DeclarationDescriptor
    <R> -> List<DeclarationDescriptor>

'listOf' @ [106:36] ==> public fun <T> listOf(element: DeclarationDescriptor): List<DeclarationDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DeclarationDescriptor

'it' @ [106:43] ==> value-parameter it: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getReferenceTargets.<anonymous>[ValueParameterDescriptorImpl]

'context' @ [106:52] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getReferenceTargets[ValueParameterDescriptorImpl]

'AMBIGUOUS_REFERENCE_TARGET' @ [106:75] ==> public final val AMBIGUOUS_REFERENCE_TARGET: (WritableSlice<(KtExpression..KtExpression?), (MutableCollection<out (DeclarationDescriptor..DeclarationDescriptor?)>..Collection<(DeclarationDescriptor..DeclarationDescriptor?)>?)>..WritableSlice<(KtExpression..KtExpression?), (MutableCollection<out (DeclarationDescriptor..DeclarationDescriptor?)>..Collection<(DeclarationDescriptor..DeclarationDescriptor?)>?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'this' @ [106:103] ==> <this> defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getReferenceTargets[ReceiverParameterDescriptorImpl]

'orEmpty' @ [106:109] ==> @InlineOnly public inline fun <T> Collection<(DeclarationDescriptor..DeclarationDescriptor?)>?.orEmpty(): Collection<(DeclarationDescriptor..DeclarationDescriptor?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.DeclarationDescriptor..org.jetbrains.kotlin.descriptors.DeclarationDescriptor?)

'context' @ [110:9] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getAbbreviatedTypeOrType[ValueParameterDescriptorImpl]

'ABBREVIATED_TYPE' @ [110:32] ==> public final val ABBREVIATED_TYPE: (WritableSlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>..WritableSlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'this' @ [110:50] ==> <this> defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getAbbreviatedTypeOrType[ReceiverParameterDescriptorImpl]

'context' @ [110:59] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getAbbreviatedTypeOrType[ValueParameterDescriptorImpl]

'TYPE' @ [110:82] ==> public final val TYPE: (WritableSlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>..WritableSlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'this' @ [110:88] ==> <this> defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getAbbreviatedTypeOrType[ReceiverParameterDescriptorImpl]

'parent' @ [113:18] ==> public final val KtTypeElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'when (parent) {
        is KtTypeReference -> parent.getAbbreviatedTypeOrType(context)
        is KtNullableType -> {
            val outerType = parent.getAbbreviatedTypeOrType(context)
            if (this is KtNullableType) outerType else outerType?.makeNotNullable()
        }
        else -> null
    }' @ [114:12] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KotlinType?, entry1: KotlinType?, entry2: KotlinType?): KotlinType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KotlinType?

'parent' @ [114:18] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getAbbreviatedTypeOrType[LocalVariableDescriptor]

'parent' @ [115:31] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getAbbreviatedTypeOrType[LocalVariableDescriptor]

'getAbbreviatedTypeOrType' @ [115:38] ==> public fun KtTypeReference.getAbbreviatedTypeOrType(context: BindingContext): KotlinType? defined in org.jetbrains.kotlin.resolve.bindingContextUtil in file BindingContextUtils.kt[SimpleFunctionDescriptorImpl]

'context' @ [115:63] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getAbbreviatedTypeOrType[ValueParameterDescriptorImpl]

'parent' @ [117:29] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getAbbreviatedTypeOrType[LocalVariableDescriptor]

'getAbbreviatedTypeOrType' @ [117:36] ==> public fun KtTypeElement.getAbbreviatedTypeOrType(context: BindingContext): KotlinType? defined in org.jetbrains.kotlin.resolve.bindingContextUtil in file BindingContextUtils.kt[SimpleFunctionDescriptorImpl]

'context' @ [117:61] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getAbbreviatedTypeOrType[ValueParameterDescriptorImpl]

'if (this is KtNullableType) outerType else outerType?.makeNotNullable()' @ [118:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType?, elseBranch: KotlinType?): KotlinType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType?

'this' @ [118:17] ==> <this> defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getAbbreviatedTypeOrType[ReceiverParameterDescriptorImpl]

'outerType' @ [118:41] ==> val outerType: KotlinType? defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getAbbreviatedTypeOrType[LocalVariableDescriptor]

'outerType' @ [118:56] ==> val outerType: KotlinType? defined in org.jetbrains.kotlin.resolve.bindingContextUtil.getAbbreviatedTypeOrType[LocalVariableDescriptor]

'makeNotNullable' @ [118:67] ==> public fun KotlinType.makeNotNullable(): KotlinType defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

