'allTypeParameterBounds' @ [43:17] ==> private final val allTypeParameterBounds: Map<TypeVariable, TypeBoundsImpl> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[PropertyDescriptorImpl]

'filterNot' @ [43:40] ==> public inline fun <K, V> Map<out TypeVariable, TypeBoundsImpl>.filterNot(predicate: (Map.Entry<TypeVariable, TypeBoundsImpl>) -> Boolean): Map<TypeVariable, TypeBoundsImpl> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> TypeVariable
    <V> -> TypeBoundsImpl

'it' @ [43:52] ==> value-parameter it: Map.Entry<TypeVariable, TypeBoundsImpl> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.<get-localTypeParameterBounds>.<anonymous>[ValueParameterDescriptorImpl]

'key' @ [43:55] ==> public abstract val key: TypeVariable defined in kotlin.collections.Map.Entry[DeserializedPropertyDescriptor]

'isExternal' @ [43:59] ==> public final val isExternal: Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.TypeVariable[PropertyDescriptorImpl]

'!' @ [48:39] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'hasContradiction' @ [48:40] ==> public open fun hasContradiction(): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.status.<no name provided>[SimpleFunctionDescriptorImpl]

'!' @ [48:62] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'hasUnknownParameters' @ [48:63] ==> public open fun hasUnknownParameters(): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.status.<no name provided>[SimpleFunctionDescriptorImpl]

'satisfyInitialConstraints' @ [48:89] ==> private final fun satisfyInitialConstraints(): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'hasParameterConstraintError' @ [50:43] ==> public open fun hasParameterConstraintError(): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.status.<no name provided>[SimpleFunctionDescriptorImpl]

'hasConflictingConstraints' @ [50:76] ==> public open fun hasConflictingConstraints(): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.status.<no name provided>[SimpleFunctionDescriptorImpl]

'hasCannotCaptureTypesError' @ [51:46] ==> public open fun hasCannotCaptureTypesError(): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.status.<no name provided>[SimpleFunctionDescriptorImpl]

'errors' @ [51:78] ==> private final val errors: List<ConstraintError> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[PropertyDescriptorImpl]

'any' @ [51:85] ==> public inline fun <T> Iterable<ConstraintError>.any(predicate: (ConstraintError) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ConstraintError

'it' @ [51:91] ==> value-parameter it: ConstraintError defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.status.<no name provided>.hasContradiction.<anonymous>[ValueParameterDescriptorImpl]

'!' @ [82:48] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isSuccessful' @ [82:49] ==> public open fun isSuccessful(): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.status.<no name provided>[SimpleFunctionDescriptorImpl]

'filterConstraintsOut' @ [82:67] ==> public fun ConstraintSystem.filterConstraintsOut(excludePositionKind: ConstraintPositionKind): ConstraintSystem defined in org.jetbrains.kotlin.resolve.calls.inference in file constraintSystemUtils.kt[SimpleFunctionDescriptorImpl]

'TYPE_BOUND_POSITION' @ [82:88] ==> enum entry TYPE_BOUND_POSITION defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPositionKind[FakeCallableDescriptorForObject]

'status' @ [82:109] ==> public abstract val status: ConstraintSystemStatus defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem[PropertyDescriptorImpl]

'isSuccessful' @ [82:116] ==> public abstract fun isSuccessful(): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemStatus[SimpleFunctionDescriptorImpl]

'localTypeParameterBounds' @ [84:52] ==> private final val localTypeParameterBounds: Map<TypeVariable, TypeBoundsImpl> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[PropertyDescriptorImpl]

'values' @ [84:77] ==> public abstract val values: Collection<TypeBoundsImpl> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'any' @ [84:84] ==> public inline fun <T> Iterable<TypeBoundsImpl>.any(predicate: (TypeBoundsImpl) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeBoundsImpl

'it' @ [84:90] ==> value-parameter it: TypeBoundsImpl defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.status.<no name provided>.hasConflictingConstraints.<anonymous>[ValueParameterDescriptorImpl]

'values' @ [84:93] ==> public open val values: Collection<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[PropertyDescriptorImpl]

'size' @ [84:100] ==> public abstract val size: Int defined in kotlin.collections.Collection[DeserializedPropertyDescriptor]

'localTypeParameterBounds' @ [87:17] ==> private final val localTypeParameterBounds: Map<TypeVariable, TypeBoundsImpl> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[PropertyDescriptorImpl]

'values' @ [87:42] ==> public abstract val values: Collection<TypeBoundsImpl> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'any' @ [87:49] ==> public inline fun <T> Iterable<TypeBoundsImpl>.any(predicate: (TypeBoundsImpl) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeBoundsImpl

'it' @ [87:55] ==> value-parameter it: TypeBoundsImpl defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.status.<no name provided>.hasUnknownParameters.<anonymous>[ValueParameterDescriptorImpl]

'values' @ [87:58] ==> public open val values: Collection<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[PropertyDescriptorImpl]

'isEmpty' @ [87:65] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.Collection[DeserializedSimpleFunctionDescriptor]

'hasTypeParameterWithUnsatisfiedOnlyInputTypesError' @ [87:80] ==> public open fun hasTypeParameterWithUnsatisfiedOnlyInputTypesError(): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.status.<no name provided>[SimpleFunctionDescriptorImpl]

'errors' @ [89:54] ==> private final val errors: List<ConstraintError> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[PropertyDescriptorImpl]

'any' @ [89:61] ==> public inline fun <T> Iterable<ConstraintError>.any(predicate: (ConstraintError) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ConstraintError

'it' @ [89:67] ==> value-parameter it: ConstraintError defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.status.<no name provided>.hasParameterConstraintError.<anonymous>[ValueParameterDescriptorImpl]

'isSuccessful' @ [92:17] ==> public open fun isSuccessful(): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.status.<no name provided>[SimpleFunctionDescriptorImpl]

'filterConstraintsOut' @ [93:17] ==> public fun ConstraintSystem.filterConstraintsOut(excludePositionKind: ConstraintPositionKind): ConstraintSystem defined in org.jetbrains.kotlin.resolve.calls.inference in file constraintSystemUtils.kt[SimpleFunctionDescriptorImpl]

'kind' @ [93:38] ==> value-parameter kind: ConstraintPositionKind defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.status.<no name provided>.hasOnlyErrorsDerivedFrom[ValueParameterDescriptorImpl]

'status' @ [93:44] ==> public abstract val status: ConstraintSystemStatus defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem[PropertyDescriptorImpl]

'isSuccessful' @ [93:51] ==> public abstract fun isSuccessful(): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemStatus[SimpleFunctionDescriptorImpl]

'errors' @ [94:20] ==> private final val errors: List<ConstraintError> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[PropertyDescriptorImpl]

'isNotEmpty' @ [94:27] ==> @InlineOnly public inline fun <T> Collection<ConstraintError>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ConstraintError

'errors' @ [94:43] ==> private final val errors: List<ConstraintError> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[PropertyDescriptorImpl]

'all' @ [94:50] ==> public inline fun <T> Iterable<ConstraintError>.all(predicate: (ConstraintError) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ConstraintError

'it' @ [94:56] ==> value-parameter it: ConstraintError defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.status.<no name provided>.hasOnlyErrorsDerivedFrom.<anonymous>[ValueParameterDescriptorImpl]

'constraintPosition' @ [94:59] ==> public final val constraintPosition: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintError[PropertyDescriptorImpl]

'derivedFrom' @ [94:78] ==> public fun ConstraintPosition.derivedFrom(kind: ConstraintPositionKind): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition in file ConstraintPosition.kt[SimpleFunctionDescriptorImpl]

'kind' @ [94:90] ==> value-parameter kind: ConstraintPositionKind defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.status.<no name provided>.hasOnlyErrorsDerivedFrom[ValueParameterDescriptorImpl]

'errors' @ [97:54] ==> private final val errors: List<ConstraintError> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[PropertyDescriptorImpl]

'any' @ [97:61] ==> public inline fun <T> Iterable<ConstraintError>.any(predicate: (ConstraintError) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ConstraintError

'it' @ [97:67] ==> value-parameter it: ConstraintError defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.status.<no name provided>.hasErrorInConstrainingTypes.<anonymous>[ValueParameterDescriptorImpl]

'errors' @ [99:53] ==> private final val errors: List<ConstraintError> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[PropertyDescriptorImpl]

'any' @ [99:60] ==> public inline fun <T> Iterable<ConstraintError>.any(predicate: (ConstraintError) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ConstraintError

'it' @ [99:66] ==> value-parameter it: ConstraintError defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.status.<no name provided>.hasCannotCaptureTypesError.<anonymous>[ValueParameterDescriptorImpl]

'errors' @ [101:61] ==> private final val errors: List<ConstraintError> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[PropertyDescriptorImpl]

'any' @ [101:68] ==> public inline fun <T> Iterable<ConstraintError>.any(predicate: (ConstraintError) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ConstraintError

'it' @ [101:74] ==> value-parameter it: ConstraintError defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.status.<no name provided>.hasTypeInferenceIncorporationError.<anonymous>[ValueParameterDescriptorImpl]

'!' @ [101:104] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'satisfyInitialConstraints' @ [101:105] ==> private final fun satisfyInitialConstraints(): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'localTypeParameterBounds' @ [104:17] ==> private final val localTypeParameterBounds: Map<TypeVariable, TypeBoundsImpl> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[PropertyDescriptorImpl]

'values' @ [104:42] ==> public abstract val values: Collection<TypeBoundsImpl> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'any' @ [104:49] ==> public inline fun <T> Iterable<TypeBoundsImpl>.any(predicate: (TypeBoundsImpl) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeBoundsImpl

'it' @ [104:55] ==> value-parameter it: TypeBoundsImpl defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.status.<no name provided>.hasTypeParameterWithUnsatisfiedOnlyInputTypesError.<anonymous>[ValueParameterDescriptorImpl]

'typeVariable' @ [104:58] ==> public open val typeVariable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[PropertyDescriptorImpl]

'hasOnlyInputTypesAnnotation' @ [104:71] ==> public final fun hasOnlyInputTypesAnnotation(): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.TypeVariable[SimpleFunctionDescriptorImpl]

'it' @ [104:104] ==> value-parameter it: TypeBoundsImpl defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.status.<no name provided>.hasTypeParameterWithUnsatisfiedOnlyInputTypesError.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [104:107] ==> public open val value: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[PropertyDescriptorImpl]

'errors' @ [107:21] ==> private final val errors: List<ConstraintError> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[PropertyDescriptorImpl]

'HashMap' @ [115:35] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> TypeConstructor
    <V : (Any..Any?)> -> TypeProjection

'component1' @ [116:15] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<TypeVariable, TypeBoundsImpl>.component1(): TypeVariable defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> TypeVariable
    <V> -> TypeBoundsImpl

'component2' @ [116:25] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<TypeVariable, TypeBoundsImpl>.component2(): TypeBoundsImpl defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> TypeVariable
    <V> -> TypeBoundsImpl

'typeParameterBounds' @ [116:40] ==> value-parameter typeParameterBounds: Map<TypeVariable, TypeBoundsImpl> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.getParameterToInferredValueMap[ValueParameterDescriptorImpl]

'typeBounds' @ [117:25] ==> val typeBounds: TypeBoundsImpl defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.getParameterToInferredValueMap[LocalVariableDescriptor]

'value' @ [117:36] ==> public open val value: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[PropertyDescriptorImpl]

'if (substituteOriginal) variable.originalTypeParameter.typeConstructor
                    else variable.type.constructor' @ [119:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: TypeConstructor, elseBranch: TypeConstructor): TypeConstructor[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> TypeConstructor

'substituteOriginal' @ [119:25] ==> value-parameter substituteOriginal: Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.getParameterToInferredValueMap[ValueParameterDescriptorImpl]

'variable' @ [119:45] ==> val variable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.getParameterToInferredValueMap[LocalVariableDescriptor]

'originalTypeParameter' @ [119:54] ==> public final val originalTypeParameter: TypeParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.inference.TypeVariable[PropertyDescriptorImpl]

'typeConstructor' @ [119:76] ==> public final val TypeParameterDescriptor.typeConstructor: TypeConstructor[MyPropertyDescriptor]

'variable' @ [120:26] ==> val variable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.getParameterToInferredValueMap[LocalVariableDescriptor]

'type' @ [120:35] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeVariable[PropertyDescriptorImpl]

'constructor' @ [120:40] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'if (value != null && !TypeUtils.contains(value, DONT_CARE)) value
                    else getDefaultType(variable)' @ [122:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType, elseBranch: KotlinType): KotlinType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType

'value' @ [122:25] ==> val value: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.getParameterToInferredValueMap[LocalVariableDescriptor]

'!' @ [122:42] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'contains' @ [122:53] ==> public open fun contains(@Nullable p0: KotlinType?, @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'value' @ [122:62] ==> val value: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.getParameterToInferredValueMap[LocalVariableDescriptor]

'DONT_CARE' @ [122:69] ==> public final val DONT_CARE: (SimpleType..SimpleType?) defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'value' @ [122:81] ==> val value: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.getParameterToInferredValueMap[LocalVariableDescriptor]

'invoke' @ [123:26] ==> public abstract operator fun invoke(p1: TypeVariable): KotlinType defined in kotlin.Function1[FunctionInvokeDescriptor]

'variable' @ [123:41] ==> val variable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.getParameterToInferredValueMap[LocalVariableDescriptor]

'substitutionContext' @ [124:13] ==> val substitutionContext: HashMap<TypeConstructor, TypeProjection> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.getParameterToInferredValueMap[LocalVariableDescriptor]

'put' @ [124:33] ==> public open fun put(key: TypeConstructor, value: TypeProjection): TypeProjection? defined in java.util.HashMap[JavaMethodDescriptor]

'typeConstructor' @ [124:37] ==> val typeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.getParameterToInferredValueMap[LocalVariableDescriptor]

'TypeProjectionImpl' @ [124:54] ==> public constructor TypeProjectionImpl(@NotNull p0: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'type' @ [124:73] ==> val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.getParameterToInferredValueMap[LocalVariableDescriptor]

'substitutionContext' @ [126:16] ==> val substitutionContext: HashMap<TypeConstructor, TypeProjection> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.getParameterToInferredValueMap[LocalVariableDescriptor]

'allTypeParameterBounds' @ [130:17] ==> private final val allTypeParameterBounds: Map<TypeVariable, TypeBoundsImpl> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[PropertyDescriptorImpl]

'keys' @ [130:40] ==> public abstract val keys: Set<TypeVariable> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'allTypeParameterBounds' @ [133:16] ==> private final val allTypeParameterBounds: Map<TypeVariable, TypeBoundsImpl> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[PropertyDescriptorImpl]

'typeVariable' @ [133:39] ==> value-parameter typeVariable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.getTypeBounds[ValueParameterDescriptorImpl]

'IllegalArgumentException' @ [134:22] ==> public final fun <init>(p0: (String..String?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'typeVariable' @ [134:119] ==> value-parameter typeVariable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.getTypeBounds[ValueParameterDescriptorImpl]

'getSubstitutor' @ [138:17] ==> private final fun getSubstitutor(substituteOriginal: Boolean, getDefaultValue: (TypeVariable) -> KotlinType): TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'createUninferredParameterType' @ [138:72] ==> @NotNull public open fun createUninferredParameterType(@NotNull p0: TypeParameterDescriptor): KotlinType defined in org.jetbrains.kotlin.types.ErrorUtils[JavaMethodDescriptor]

'it' @ [138:102] ==> value-parameter it: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.<get-resultingSubstitutor>.<anonymous>[ValueParameterDescriptorImpl]

'originalTypeParameter' @ [138:105] ==> public final val originalTypeParameter: TypeParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.inference.TypeVariable[PropertyDescriptorImpl]

'getSubstitutor' @ [141:17] ==> private final fun getSubstitutor(substituteOriginal: Boolean, getDefaultValue: (TypeVariable) -> KotlinType): TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'DONT_CARE' @ [141:71] ==> public final val DONT_CARE: (SimpleType..SimpleType?) defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'getParameterToInferredValueMap' @ [144:43] ==> private final fun getParameterToInferredValueMap(typeParameterBounds: Map<TypeVariable, TypeBoundsImpl>, getDefaultType: (TypeVariable) -> KotlinType, substituteOriginal: Boolean): Map<TypeConstructor, TypeProjection> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'allTypeParameterBounds' @ [144:74] ==> private final val allTypeParameterBounds: Map<TypeVariable, TypeBoundsImpl> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[PropertyDescriptorImpl]

'getDefaultValue' @ [144:98] ==> value-parameter getDefaultValue: (TypeVariable) -> KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.getSubstitutor[ValueParameterDescriptorImpl]

'substituteOriginal' @ [144:115] ==> value-parameter substituteOriginal: Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.getSubstitutor[ValueParameterDescriptorImpl]

'create' @ [145:32] ==> @NotNull public open fun create(@NotNull p0: TypeSubstitution): TypeSubstitutor defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'SubstitutionWithCapturedTypeApproximation' @ [146:17] ==> public constructor SubstitutionWithCapturedTypeApproximation(substitution: TypeSubstitution) defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.SubstitutionWithCapturedTypeApproximation[ClassConstructorDescriptorImpl]

'SubstitutionFilteringInternalResolveAnnotations' @ [147:25] ==> public constructor SubstitutionFilteringInternalResolveAnnotations(substitution: TypeSubstitution) defined in org.jetbrains.kotlin.resolve.calls.inference.SubstitutionFilteringInternalResolveAnnotations[ClassConstructorDescriptorImpl]

'createByConstructorsMap' @ [148:61] ==> @JvmStatic @JvmOverloads public final fun createByConstructorsMap(map: Map<TypeConstructor, TypeProjection>, approximateCapturedTypes: Boolean = ...): TypeConstructorSubstitution defined in org.jetbrains.kotlin.types.TypeConstructorSubstitution.Companion[DeserializedSimpleFunctionDescriptor]

'parameterToInferredValueMap' @ [148:85] ==> val parameterToInferredValueMap: Map<TypeConstructor, TypeProjection> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.getSubstitutor[LocalVariableDescriptor]

'DelegatedTypeSubstitution' @ [154:95] ==> public constructor DelegatedTypeSubstitution(substitution: TypeSubstitution) defined in org.jetbrains.kotlin.types.DelegatedTypeSubstitution[DeserializedClassConstructorDescriptor]

'substitution' @ [154:121] ==> value-parameter substitution: TypeSubstitution defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.SubstitutionWithCapturedTypeApproximation.<init>[ValueParameterDescriptorImpl]

'getSubstitutor' @ [159:27] ==> private final fun getSubstitutor(substituteOriginal: Boolean, getDefaultValue: (TypeVariable) -> KotlinType): TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'createUninferredParameterType' @ [159:83] ==> @NotNull public open fun createUninferredParameterType(@NotNull p0: TypeParameterDescriptor): KotlinType defined in org.jetbrains.kotlin.types.ErrorUtils[JavaMethodDescriptor]

'it' @ [159:113] ==> value-parameter it: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.satisfyInitialConstraints.<anonymous>[ValueParameterDescriptorImpl]

'originalTypeParameter' @ [159:116] ==> public final val originalTypeParameter: TypeParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.inference.TypeVariable[PropertyDescriptorImpl]

'substitutor' @ [160:52] ==> val substitutor: TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.satisfyInitialConstraints[LocalVariableDescriptor]

'substitute' @ [160:64] ==> @Nullable public open fun substitute(@NotNull p0: KotlinType, @NotNull p1: Variance): KotlinType? defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'this' @ [160:75] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.satisfyInitialConstraints.substitute[ReceiverParameterDescriptorImpl]

'INVARIANT' @ [160:90] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'initialConstraints' @ [162:16] ==> private final val initialConstraints: List<ConstraintSystemBuilderImpl.Constraint> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[PropertyDescriptorImpl]

'all' @ [162:35] ==> public inline fun <T> Iterable<ConstraintSystemBuilderImpl.Constraint>.all(predicate: (ConstraintSystemBuilderImpl.Constraint) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Constraint

'component1' @ [163:14] ==> public final operator fun component1(): ConstraintSystemBuilderImpl.ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl.Constraint[SimpleFunctionDescriptorImpl]

'component2' @ [163:20] ==> public final operator fun component2(): KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl.Constraint[SimpleFunctionDescriptorImpl]

'component3' @ [163:29] ==> public final operator fun component3(): KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl.Constraint[SimpleFunctionDescriptorImpl]

'component4' @ [163:40] ==> public final operator fun component4(): ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl.Constraint[SimpleFunctionDescriptorImpl]

'subtype' @ [164:33] ==> val subtype: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.satisfyInitialConstraints.<anonymous>[LocalVariableDescriptor]

'substitute' @ [164:41] ==> local final fun KotlinType.substitute(): KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.satisfyInitialConstraints[SimpleFunctionDescriptorImpl]

'let' @ [164:55] ==> @InlineOnly public inline fun <T, R> KotlinType.let(block: (KotlinType) -> KotlinType): KotlinType defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType
    <R> -> KotlinType

'if (position.kind != ConstraintPositionKind.RECEIVER_POSITION) it else it.makeNotNullable()' @ [167:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType, elseBranch: KotlinType): KotlinType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType

'position' @ [167:21] ==> val position: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.satisfyInitialConstraints.<anonymous>[LocalVariableDescriptor]

'kind' @ [167:30] ==> public abstract val kind: ConstraintPositionKind defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPosition[PropertyDescriptorImpl]

'RECEIVER_POSITION' @ [167:61] ==> enum entry RECEIVER_POSITION defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPositionKind[FakeCallableDescriptorForObject]

'it' @ [167:80] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.satisfyInitialConstraints.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [167:88] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.satisfyInitialConstraints.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'makeNotNullable' @ [167:91] ==> public fun KotlinType.makeNotNullable(): KotlinType defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'superType' @ [169:35] ==> val superType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.satisfyInitialConstraints.<anonymous>[LocalVariableDescriptor]

'substitute' @ [169:45] ==> local final fun KotlinType.substitute(): KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.satisfyInitialConstraints[SimpleFunctionDescriptorImpl]

'when (kind) {
                SUB_TYPE -> KotlinTypeChecker.DEFAULT.isSubtypeOf(resultSubType, resultSuperType)
                EQUAL -> KotlinTypeChecker.DEFAULT.equalTypes(resultSubType, resultSuperType)
            }' @ [170:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'kind' @ [170:19] ==> val kind: ConstraintSystemBuilderImpl.ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.satisfyInitialConstraints.<anonymous>[LocalVariableDescriptor]

'SUB_TYPE' @ [171:17] ==> enum entry SUB_TYPE defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl.ConstraintKind[FakeCallableDescriptorForObject]

'DEFAULT' @ [171:47] ==> public final val DEFAULT: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaPropertyDescriptor]

'isSubtypeOf' @ [171:55] ==> public abstract fun isSubtypeOf(@NotNull p0: KotlinType, @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaMethodDescriptor]

'resultSubType' @ [171:67] ==> val resultSubType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.satisfyInitialConstraints.<anonymous>[LocalVariableDescriptor]

'resultSuperType' @ [171:82] ==> val resultSuperType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.satisfyInitialConstraints.<anonymous>[LocalVariableDescriptor]

'EQUAL' @ [172:17] ==> enum entry EQUAL defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl.ConstraintKind[FakeCallableDescriptorForObject]

'DEFAULT' @ [172:44] ==> public final val DEFAULT: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaPropertyDescriptor]

'equalTypes' @ [172:52] ==> public abstract fun equalTypes(@NotNull p0: KotlinType, @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaMethodDescriptor]

'resultSubType' @ [172:63] ==> val resultSubType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.satisfyInitialConstraints.<anonymous>[LocalVariableDescriptor]

'resultSuperType' @ [172:78] ==> val resultSuperType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.satisfyInitialConstraints.<anonymous>[LocalVariableDescriptor]

'ConstraintSystemBuilderImpl' @ [178:22] ==> public constructor ConstraintSystemBuilderImpl(mode: ConstraintSystemBuilderImpl.Mode = ...) defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl[ClassConstructorDescriptorImpl]

'component1' @ [179:15] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<TypeVariable, TypeBoundsImpl>.component1(): TypeVariable defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> TypeVariable
    <V> -> TypeBoundsImpl

'component2' @ [179:30] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<TypeVariable, TypeBoundsImpl>.component2(): TypeBoundsImpl defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> TypeVariable
    <V> -> TypeBoundsImpl

'allTypeParameterBounds' @ [179:45] ==> private final val allTypeParameterBounds: Map<TypeVariable, TypeBoundsImpl> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[PropertyDescriptorImpl]

'result' @ [180:13] ==> val result: ConstraintSystemBuilderImpl defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.toBuilder[LocalVariableDescriptor]

'allTypeParameterBounds' @ [180:20] ==> internal final val allTypeParameterBounds: LinkedHashMap<TypeVariable, TypeBoundsImpl> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl[PropertyDescriptorImpl]

'put' @ [180:43] ==> public open fun put(key: TypeVariable, value: TypeBoundsImpl): TypeBoundsImpl? defined in java.util.LinkedHashMap[JavaMethodDescriptor]

'typeParameter' @ [180:47] ==> val typeParameter: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.toBuilder[LocalVariableDescriptor]

'typeBounds' @ [180:62] ==> val typeBounds: TypeBoundsImpl defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.toBuilder[LocalVariableDescriptor]

'filter' @ [180:73] ==> public final fun filter(condition: (ConstraintPosition) -> Boolean): TypeBoundsImpl defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[SimpleFunctionDescriptorImpl]

'filterConstraintPosition' @ [180:80] ==> value-parameter filterConstraintPosition: (ConstraintPosition) -> Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.toBuilder[ValueParameterDescriptorImpl]

'result' @ [182:9] ==> val result: ConstraintSystemBuilderImpl defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.toBuilder[LocalVariableDescriptor]

'usedInBounds' @ [182:16] ==> internal final val usedInBounds: HashMap<TypeVariable, MutableList<TypeBounds.Bound>> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl[PropertyDescriptorImpl]

'putAll' @ [182:29] ==> public open fun putAll(from: Map<out TypeVariable, MutableList<TypeBounds.Bound>>): Unit defined in java.util.HashMap[JavaMethodDescriptor]

'usedInBounds' @ [182:36] ==> private final val usedInBounds: Map<TypeVariable, MutableList<TypeBounds.Bound>> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[PropertyDescriptorImpl]

'map' @ [182:49] ==> public inline fun <K, V, R> Map<out TypeVariable, MutableList<TypeBounds.Bound>>.map(transform: (Map.Entry<TypeVariable, MutableList<TypeBounds.Bound>>) -> Pair<TypeVariable, ArrayList<TypeBounds.Bound> /* = ArrayList<TypeBounds.Bound> */>): List<Pair<TypeVariable, ArrayList<TypeBounds.Bound> /* = ArrayList<TypeBounds.Bound> */>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> TypeVariable
    <V> -> MutableList<Bound>
    <R> -> Pair<TypeVariable, ArrayList<Bound>>

'component1' @ [183:18] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<TypeVariable, MutableList<TypeBounds.Bound>>.component1(): TypeVariable defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> TypeVariable
    <V> -> MutableList<Bound>

'component2' @ [183:28] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<TypeVariable, MutableList<TypeBounds.Bound>>.component2(): MutableList<TypeBounds.Bound> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> TypeVariable
    <V> -> MutableList<Bound>

'it' @ [183:38] ==> value-parameter it: Map.Entry<TypeVariable, MutableList<TypeBounds.Bound>> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.toBuilder.<anonymous>[ValueParameterDescriptorImpl]

'variable' @ [184:13] ==> val variable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.toBuilder.<anonymous>[LocalVariableDescriptor]

'bounds' @ [184:25] ==> val bounds: MutableList<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.toBuilder.<anonymous>[LocalVariableDescriptor]

'filterTo' @ [184:32] ==> public inline fun <T, C : MutableCollection<in TypeBounds.Bound>> Iterable<TypeBounds.Bound>.filterTo(destination: ArrayList<TypeBounds.Bound> /* = ArrayList<TypeBounds.Bound> */, predicate: (TypeBounds.Bound) -> Boolean): ArrayList<TypeBounds.Bound> /* = ArrayList<TypeBounds.Bound> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Bound
    <C : MutableCollection<in T>> -> ArrayList<Bound>

'arrayListOf' @ [184:41] ==> @SinceKotlin @InlineOnly public inline fun <T> arrayListOf(): ArrayList<TypeBounds.Bound> /* = ArrayList<TypeBounds.Bound> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Bound

'invoke' @ [184:76] ==> public abstract operator fun invoke(p1: ConstraintPosition): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'it' @ [184:101] ==> value-parameter it: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.toBuilder.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'position' @ [184:104] ==> public final val position: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'toMap' @ [185:11] ==> public fun <K, V> Iterable<Pair<TypeVariable, ArrayList<TypeBounds.Bound> /* = ArrayList<TypeBounds.Bound> */>>.toMap(): Map<TypeVariable, ArrayList<TypeBounds.Bound> /* = ArrayList<TypeBounds.Bound> */> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> TypeVariable
    <V> -> ArrayList<Bound>

'result' @ [186:9] ==> val result: ConstraintSystemBuilderImpl defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.toBuilder[LocalVariableDescriptor]

'errors' @ [186:16] ==> internal final val errors: ArrayList<ConstraintError> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl[PropertyDescriptorImpl]

'addAll' @ [186:23] ==> public open fun addAll(elements: Collection<ConstraintError>): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'errors' @ [186:30] ==> private final val errors: List<ConstraintError> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[PropertyDescriptorImpl]

'filter' @ [186:37] ==> public inline fun <T> Iterable<ConstraintError>.filter(predicate: (ConstraintError) -> Boolean): List<ConstraintError> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ConstraintError

'invoke' @ [186:46] ==> public abstract operator fun invoke(p1: ConstraintPosition): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'it' @ [186:71] ==> value-parameter it: ConstraintError defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.toBuilder.<anonymous>[ValueParameterDescriptorImpl]

'constraintPosition' @ [186:74] ==> public final val constraintPosition: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintError[PropertyDescriptorImpl]

'result' @ [188:9] ==> val result: ConstraintSystemBuilderImpl defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.toBuilder[LocalVariableDescriptor]

'initialConstraints' @ [188:16] ==> internal final val initialConstraints: ArrayList<ConstraintSystemBuilderImpl.Constraint> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl[PropertyDescriptorImpl]

'addAll' @ [188:35] ==> public open fun addAll(elements: Collection<ConstraintSystemBuilderImpl.Constraint>): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'initialConstraints' @ [188:42] ==> private final val initialConstraints: List<ConstraintSystemBuilderImpl.Constraint> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[PropertyDescriptorImpl]

'filter' @ [188:61] ==> public inline fun <T> Iterable<ConstraintSystemBuilderImpl.Constraint>.filter(predicate: (ConstraintSystemBuilderImpl.Constraint) -> Boolean): List<ConstraintSystemBuilderImpl.Constraint> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Constraint

'invoke' @ [188:70] ==> public abstract operator fun invoke(p1: ConstraintPosition): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'it' @ [188:95] ==> value-parameter it: ConstraintSystemBuilderImpl.Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.toBuilder.<anonymous>[ValueParameterDescriptorImpl]

'position' @ [188:98] ==> public final val position: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl.Constraint[PropertyDescriptorImpl]

'result' @ [189:9] ==> val result: ConstraintSystemBuilderImpl defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.toBuilder[LocalVariableDescriptor]

'typeVariableSubstitutors' @ [189:16] ==> public open val typeVariableSubstitutors: LinkedHashMap<CallHandle, TypeSubstitutor> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl[PropertyDescriptorImpl]

'putAll' @ [189:41] ==> public open fun putAll(from: Map<out CallHandle, TypeSubstitutor>): Unit defined in java.util.LinkedHashMap[JavaMethodDescriptor]

'typeVariableSubstitutors' @ [189:48] ==> private final val typeVariableSubstitutors: Map<CallHandle, TypeSubstitutor> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl[PropertyDescriptorImpl]

'result' @ [191:16] ==> val result: ConstraintSystemBuilderImpl defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemImpl.toBuilder[LocalVariableDescriptor]

'DelegatedTypeSubstitution' @ [195:98] ==> public constructor DelegatedTypeSubstitution(substitution: TypeSubstitution) defined in org.jetbrains.kotlin.types.DelegatedTypeSubstitution[DeserializedClassConstructorDescriptor]

'substitution' @ [195:124] ==> value-parameter substitution: TypeSubstitution defined in org.jetbrains.kotlin.resolve.calls.inference.SubstitutionFilteringInternalResolveAnnotations.<init>[ValueParameterDescriptorImpl]

'!' @ [197:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'annotations' @ [197:14] ==> value-parameter annotations: Annotations defined in org.jetbrains.kotlin.resolve.calls.inference.SubstitutionFilteringInternalResolveAnnotations.filterAnnotations[ValueParameterDescriptorImpl]

'hasInternalAnnotationForResolve' @ [197:26] ==> public fun Annotations.hasInternalAnnotationForResolve(): Boolean defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedSimpleFunctionDescriptor]

'annotations' @ [197:68] ==> value-parameter annotations: Annotations defined in org.jetbrains.kotlin.resolve.calls.inference.SubstitutionFilteringInternalResolveAnnotations.filterAnnotations[ValueParameterDescriptorImpl]

'FilteredAnnotations' @ [198:16] ==> public constructor FilteredAnnotations(delegate: Annotations, fqNameFilter: (FqName) -> Boolean) defined in org.jetbrains.kotlin.descriptors.annotations.FilteredAnnotations[DeserializedClassConstructorDescriptor]

'annotations' @ [198:36] ==> value-parameter annotations: Annotations defined in org.jetbrains.kotlin.resolve.calls.inference.SubstitutionFilteringInternalResolveAnnotations.filterAnnotations[ValueParameterDescriptorImpl]

'!' @ [198:51] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'it' @ [198:52] ==> value-parameter it: FqName defined in org.jetbrains.kotlin.resolve.calls.inference.SubstitutionFilteringInternalResolveAnnotations.filterAnnotations.<anonymous>[ValueParameterDescriptorImpl]

'isInternalAnnotationForResolve' @ [198:55] ==> public fun FqName.isInternalAnnotationForResolve(): Boolean defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedSimpleFunctionDescriptor]

