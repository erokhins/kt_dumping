'newBound' @ [42:24] ==> value-parameter newBound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound[ValueParameterDescriptorImpl]

'typeVariable' @ [42:33] ==> public final val typeVariable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'getTypeBounds' @ [43:22] ==> internal final fun getTypeBounds(variable: TypeVariable): TypeBoundsImpl defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl[SimpleFunctionDescriptorImpl]

'typeVariable' @ [43:36] ==> val typeVariable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound[LocalVariableDescriptor]

'typeBounds' @ [46:27] ==> val typeBounds: TypeBoundsImpl defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound[LocalVariableDescriptor]

'bounds' @ [46:38] ==> public open val bounds: ArrayList<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[PropertyDescriptorImpl]

'indices' @ [46:45] ==> public val Collection<*>.indices: IntRange defined in kotlin.collections[DeserializedPropertyDescriptor]

'addConstraintFromBounds' @ [47:9] ==> private fun ConstraintSystemBuilderImpl.addConstraintFromBounds(old: TypeBounds.Bound, new: TypeBounds.Bound): Unit defined in org.jetbrains.kotlin.resolve.calls.inference in file constraintIncorporation.kt[SimpleFunctionDescriptorImpl]

'typeBounds' @ [47:33] ==> val typeBounds: TypeBoundsImpl defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound[LocalVariableDescriptor]

'bounds' @ [47:44] ==> public open val bounds: ArrayList<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[PropertyDescriptorImpl]

'oldBoundIndex' @ [47:51] ==> val oldBoundIndex: Int defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound[LocalVariableDescriptor]

'newBound' @ [47:67] ==> value-parameter newBound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound[ValueParameterDescriptorImpl]

'usedInBounds' @ [49:24] ==> internal final val usedInBounds: HashMap<TypeVariable, MutableList<TypeBounds.Bound>> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl[PropertyDescriptorImpl]

'typeVariable' @ [49:37] ==> val typeVariable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound[LocalVariableDescriptor]

'emptyList' @ [49:54] ==> public fun <T> emptyList(): List<TypeBounds.Bound> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Bound

'boundsUsedIn' @ [50:19] ==> val boundsUsedIn: List<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound[LocalVariableDescriptor]

'indices' @ [50:32] ==> public val Collection<*>.indices: IntRange defined in kotlin.collections[DeserializedPropertyDescriptor]

'boundsUsedIn' @ [51:27] ==> val boundsUsedIn: List<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound[LocalVariableDescriptor]

'index' @ [51:40] ==> val index: Int defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound[LocalVariableDescriptor]

'generateNewBound' @ [52:9] ==> private fun ConstraintSystemBuilderImpl.generateNewBound(bound: TypeBounds.Bound, substitution: TypeBounds.Bound): Unit defined in org.jetbrains.kotlin.resolve.calls.inference in file constraintIncorporation.kt[SimpleFunctionDescriptorImpl]

'boundUsedIn' @ [52:26] ==> val boundUsedIn: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound[LocalVariableDescriptor]

'newBound' @ [52:39] ==> value-parameter newBound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound[ValueParameterDescriptorImpl]

'newBound' @ [55:28] ==> value-parameter newBound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound[ValueParameterDescriptorImpl]

'constrainingType' @ [55:37] ==> public final val constrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'isMyTypeVariable' @ [56:9] ==> internal final fun isMyTypeVariable(type: KotlinType): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl[SimpleFunctionDescriptorImpl]

'constrainingType' @ [56:26] ==> val constrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound[LocalVariableDescriptor]

'ConstraintContext' @ [57:23] ==> public constructor ConstraintContext(position: ConstraintPosition, derivedFrom: Set<TypeVariable>? = ..., initial: Boolean = ..., initialReduction: Boolean = ...) defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintContext[ClassConstructorDescriptorImpl]

'newBound' @ [57:41] ==> value-parameter newBound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound[ValueParameterDescriptorImpl]

'position' @ [57:50] ==> public final val position: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'newBound' @ [57:60] ==> value-parameter newBound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound[ValueParameterDescriptorImpl]

'derivedFrom' @ [57:69] ==> public final val derivedFrom: Set<TypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'addBound' @ [58:9] ==> internal final fun addBound(typeVariable: TypeVariable, constrainingType: KotlinType, kind: TypeBounds.BoundKind, constraintContext: ConstraintContext): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl[SimpleFunctionDescriptorImpl]

'getMyTypeVariable' @ [58:18] ==> internal final fun getMyTypeVariable(type: KotlinType): TypeVariable? defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl[SimpleFunctionDescriptorImpl]

'constrainingType' @ [58:36] ==> val constrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound[LocalVariableDescriptor]

'typeVariable' @ [58:57] ==> val typeVariable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound[LocalVariableDescriptor]

'type' @ [58:70] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeVariable[PropertyDescriptorImpl]

'newBound' @ [58:76] ==> value-parameter newBound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound[ValueParameterDescriptorImpl]

'kind' @ [58:85] ==> public final val kind: TypeBounds.BoundKind defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'reverse' @ [58:90] ==> public fun TypeBounds.BoundKind.reverse(): TypeBounds.BoundKind defined in org.jetbrains.kotlin.resolve.calls.inference[SimpleFunctionDescriptorImpl]

'context' @ [58:101] ==> val context: ConstraintContext defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound[LocalVariableDescriptor]

'getNestedTypeVariables' @ [62:5] ==> internal final fun getNestedTypeVariables(type: KotlinType): List<TypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl[SimpleFunctionDescriptorImpl]

'constrainingType' @ [62:28] ==> val constrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound[LocalVariableDescriptor]

'forEach' @ [62:46] ==> @HidesMembers public inline fun <T> Iterable<TypeVariable>.forEach(action: (TypeVariable) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeVariable

'getTypeBounds' @ [63:39] ==> internal final fun getTypeBounds(variable: TypeVariable): TypeBoundsImpl defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl[SimpleFunctionDescriptorImpl]

'it' @ [63:53] ==> value-parameter it: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound.<anonymous>[ValueParameterDescriptorImpl]

'bounds' @ [63:57] ==> public open val bounds: ArrayList<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[PropertyDescriptorImpl]

'boundsForNestedVariable' @ [64:23] ==> val boundsForNestedVariable: ArrayList<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound.<anonymous>[LocalVariableDescriptor]

'indices' @ [64:47] ==> public val Collection<*>.indices: IntRange defined in kotlin.collections[DeserializedPropertyDescriptor]

'generateNewBound' @ [65:13] ==> private fun ConstraintSystemBuilderImpl.generateNewBound(bound: TypeBounds.Bound, substitution: TypeBounds.Bound): Unit defined in org.jetbrains.kotlin.resolve.calls.inference in file constraintIncorporation.kt[SimpleFunctionDescriptorImpl]

'newBound' @ [65:30] ==> value-parameter newBound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound[ValueParameterDescriptorImpl]

'boundsForNestedVariable' @ [65:40] ==> val boundsForNestedVariable: ArrayList<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound.<anonymous>[LocalVariableDescriptor]

'index' @ [65:64] ==> val index: Int defined in org.jetbrains.kotlin.resolve.calls.inference.incorporateBound.<anonymous>[LocalVariableDescriptor]

'old' @ [71:9] ==> value-parameter old: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.addConstraintFromBounds[ValueParameterDescriptorImpl]

'new' @ [71:16] ==> value-parameter new: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.addConstraintFromBounds[ValueParameterDescriptorImpl]

'old' @ [73:19] ==> value-parameter old: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.addConstraintFromBounds[ValueParameterDescriptorImpl]

'constrainingType' @ [73:23] ==> public final val constrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'new' @ [74:19] ==> value-parameter new: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.addConstraintFromBounds[ValueParameterDescriptorImpl]

'constrainingType' @ [74:23] ==> public final val constrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'ConstraintContext' @ [75:19] ==> public constructor ConstraintContext(position: ConstraintPosition, derivedFrom: Set<TypeVariable>? = ..., initial: Boolean = ..., initialReduction: Boolean = ...) defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintContext[ClassConstructorDescriptorImpl]

'CompoundConstraintPosition' @ [75:37] ==> public constructor CompoundConstraintPosition(vararg positions: ConstraintPosition) defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.CompoundConstraintPosition[ClassConstructorDescriptorImpl]

'old' @ [75:64] ==> value-parameter old: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.addConstraintFromBounds[ValueParameterDescriptorImpl]

'position' @ [75:68] ==> public final val position: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'new' @ [75:78] ==> value-parameter new: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.addConstraintFromBounds[ValueParameterDescriptorImpl]

'position' @ [75:82] ==> public final val position: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'old' @ [75:93] ==> value-parameter old: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.addConstraintFromBounds[ValueParameterDescriptorImpl]

'derivedFrom' @ [75:97] ==> public final val derivedFrom: Set<TypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'new' @ [75:111] ==> value-parameter new: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.addConstraintFromBounds[ValueParameterDescriptorImpl]

'derivedFrom' @ [75:115] ==> public final val derivedFrom: Set<TypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'when {
        old.kind.ordinal < new.kind.ordinal -> addConstraint(SUB_TYPE, oldType, newType, context)
        old.kind.ordinal > new.kind.ordinal -> addConstraint(SUB_TYPE, newType, oldType, context)
        old.kind == new.kind && old.kind == EXACT_BOUND -> addConstraint(EQUAL, oldType, newType, context)
    }' @ [77:5] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'old' @ [78:9] ==> value-parameter old: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.addConstraintFromBounds[ValueParameterDescriptorImpl]

'kind' @ [78:13] ==> public final val kind: TypeBounds.BoundKind defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'ordinal' @ [78:18] ==> public final val ordinal: Int defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[DeserializedPropertyDescriptor]

'new' @ [78:28] ==> value-parameter new: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.addConstraintFromBounds[ValueParameterDescriptorImpl]

'kind' @ [78:32] ==> public final val kind: TypeBounds.BoundKind defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'ordinal' @ [78:37] ==> public final val ordinal: Int defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[DeserializedPropertyDescriptor]

'addConstraint' @ [78:48] ==> public final fun addConstraint(constraintKind: ConstraintSystemBuilderImpl.ConstraintKind, subType: KotlinType?, superType: KotlinType?, constraintContext: ConstraintContext): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl[SimpleFunctionDescriptorImpl]

'SUB_TYPE' @ [78:62] ==> enum entry SUB_TYPE defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl.ConstraintKind[FakeCallableDescriptorForObject]

'oldType' @ [78:72] ==> val oldType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.addConstraintFromBounds[LocalVariableDescriptor]

'newType' @ [78:81] ==> val newType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.addConstraintFromBounds[LocalVariableDescriptor]

'context' @ [78:90] ==> val context: ConstraintContext defined in org.jetbrains.kotlin.resolve.calls.inference.addConstraintFromBounds[LocalVariableDescriptor]

'old' @ [79:9] ==> value-parameter old: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.addConstraintFromBounds[ValueParameterDescriptorImpl]

'kind' @ [79:13] ==> public final val kind: TypeBounds.BoundKind defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'ordinal' @ [79:18] ==> public final val ordinal: Int defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[DeserializedPropertyDescriptor]

'new' @ [79:28] ==> value-parameter new: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.addConstraintFromBounds[ValueParameterDescriptorImpl]

'kind' @ [79:32] ==> public final val kind: TypeBounds.BoundKind defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'ordinal' @ [79:37] ==> public final val ordinal: Int defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[DeserializedPropertyDescriptor]

'addConstraint' @ [79:48] ==> public final fun addConstraint(constraintKind: ConstraintSystemBuilderImpl.ConstraintKind, subType: KotlinType?, superType: KotlinType?, constraintContext: ConstraintContext): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl[SimpleFunctionDescriptorImpl]

'SUB_TYPE' @ [79:62] ==> enum entry SUB_TYPE defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl.ConstraintKind[FakeCallableDescriptorForObject]

'newType' @ [79:72] ==> val newType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.addConstraintFromBounds[LocalVariableDescriptor]

'oldType' @ [79:81] ==> val oldType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.addConstraintFromBounds[LocalVariableDescriptor]

'context' @ [79:90] ==> val context: ConstraintContext defined in org.jetbrains.kotlin.resolve.calls.inference.addConstraintFromBounds[LocalVariableDescriptor]

'old' @ [80:9] ==> value-parameter old: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.addConstraintFromBounds[ValueParameterDescriptorImpl]

'kind' @ [80:13] ==> public final val kind: TypeBounds.BoundKind defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'new' @ [80:21] ==> value-parameter new: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.addConstraintFromBounds[ValueParameterDescriptorImpl]

'kind' @ [80:25] ==> public final val kind: TypeBounds.BoundKind defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'old' @ [80:33] ==> value-parameter old: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.addConstraintFromBounds[ValueParameterDescriptorImpl]

'kind' @ [80:37] ==> public final val kind: TypeBounds.BoundKind defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'EXACT_BOUND' @ [80:45] ==> enum entry EXACT_BOUND defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[FakeCallableDescriptorForObject]

'addConstraint' @ [80:60] ==> public final fun addConstraint(constraintKind: ConstraintSystemBuilderImpl.ConstraintKind, subType: KotlinType?, superType: KotlinType?, constraintContext: ConstraintContext): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl[SimpleFunctionDescriptorImpl]

'EQUAL' @ [80:74] ==> enum entry EQUAL defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl.ConstraintKind[FakeCallableDescriptorForObject]

'oldType' @ [80:81] ==> val oldType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.addConstraintFromBounds[LocalVariableDescriptor]

'newType' @ [80:90] ==> val newType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.addConstraintFromBounds[LocalVariableDescriptor]

'context' @ [80:99] ==> val context: ConstraintContext defined in org.jetbrains.kotlin.resolve.calls.inference.addConstraintFromBounds[LocalVariableDescriptor]

'when (substitution.kind) {
        EXACT_BOUND -> substitution.constrainingType
        UPPER_BOUND -> CapturedType(TypeProjectionImpl(Variance.OUT_VARIANCE, substitution.constrainingType))
        LOWER_BOUND -> CapturedType(TypeProjectionImpl(Variance.IN_VARIANCE, substitution.constrainingType))
    }' @ [89:27] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KotlinType, entry1: KotlinType, entry2: KotlinType): KotlinType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KotlinType

'substitution' @ [89:33] ==> value-parameter substitution: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[ValueParameterDescriptorImpl]

'kind' @ [89:46] ==> public final val kind: TypeBounds.BoundKind defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'EXACT_BOUND' @ [90:9] ==> enum entry EXACT_BOUND defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[FakeCallableDescriptorForObject]

'substitution' @ [90:24] ==> value-parameter substitution: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[ValueParameterDescriptorImpl]

'constrainingType' @ [90:37] ==> public final val constrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'UPPER_BOUND' @ [91:9] ==> enum entry UPPER_BOUND defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[FakeCallableDescriptorForObject]

'CapturedType' @ [91:24] ==> public constructor CapturedType(typeProjection: TypeProjection, constructor: CapturedTypeConstructor = ..., isMarkedNullable: Boolean = ..., annotations: Annotations = ...) defined in org.jetbrains.kotlin.resolve.calls.inference.CapturedType[DeserializedClassConstructorDescriptor]

'TypeProjectionImpl' @ [91:37] ==> public constructor TypeProjectionImpl(@NotNull p0: Variance, @NotNull p1: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'OUT_VARIANCE' @ [91:65] ==> enum entry OUT_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'substitution' @ [91:79] ==> value-parameter substitution: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[ValueParameterDescriptorImpl]

'constrainingType' @ [91:92] ==> public final val constrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'LOWER_BOUND' @ [92:9] ==> enum entry LOWER_BOUND defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[FakeCallableDescriptorForObject]

'CapturedType' @ [92:24] ==> public constructor CapturedType(typeProjection: TypeProjection, constructor: CapturedTypeConstructor = ..., isMarkedNullable: Boolean = ..., annotations: Annotations = ...) defined in org.jetbrains.kotlin.resolve.calls.inference.CapturedType[DeserializedClassConstructorDescriptor]

'TypeProjectionImpl' @ [92:37] ==> public constructor TypeProjectionImpl(@NotNull p0: Variance, @NotNull p1: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'IN_VARIANCE' @ [92:65] ==> enum entry IN_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'substitution' @ [92:78] ==> value-parameter substitution: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[ValueParameterDescriptorImpl]

'constrainingType' @ [92:91] ==> public final val constrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'TypeProjectionImpl' @ [95:29] ==> public constructor TypeProjectionImpl(@NotNull p0: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'substitutedType' @ [95:48] ==> val substitutedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[LocalVariableDescriptor]

'create' @ [96:39] ==> @NotNull public open fun create(@NotNull p0: (MutableMap<(TypeConstructor..TypeConstructor?), (TypeProjection..TypeProjection?)>..Map<(TypeConstructor..TypeConstructor?), (TypeProjection..TypeProjection?)>)): TypeSubstitutor defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'mapOf' @ [96:46] ==> public fun <K, V> mapOf(pair: Pair<(TypeConstructor..TypeConstructor?), TypeProjectionImpl>): Map<(TypeConstructor..TypeConstructor?), TypeProjectionImpl> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.types.TypeConstructor..org.jetbrains.kotlin.types.TypeConstructor?)
    <V> -> TypeProjectionImpl

'substitution' @ [96:52] ==> value-parameter substitution: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[ValueParameterDescriptorImpl]

'typeVariable' @ [96:65] ==> public final val typeVariable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'type' @ [96:78] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeVariable[PropertyDescriptorImpl]

'constructor' @ [96:83] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'newTypeProjection' @ [96:98] ==> val newTypeProjection: TypeProjectionImpl defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[LocalVariableDescriptor]

'substitutor' @ [97:16] ==> val substitutor: TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[LocalVariableDescriptor]

'substitute' @ [97:28] ==> @Nullable public open fun substitute(@NotNull p0: KotlinType, @NotNull p1: Variance): KotlinType? defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'bound' @ [97:39] ==> value-parameter bound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[ValueParameterDescriptorImpl]

'constrainingType' @ [97:45] ==> public final val constrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'INVARIANT' @ [97:63] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'CompoundConstraintPosition' @ [99:20] ==> public constructor CompoundConstraintPosition(vararg positions: ConstraintPosition) defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.CompoundConstraintPosition[ClassConstructorDescriptorImpl]

'bound' @ [99:47] ==> value-parameter bound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[ValueParameterDescriptorImpl]

'position' @ [99:53] ==> public final val position: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'substitution' @ [99:63] ==> value-parameter substitution: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[ValueParameterDescriptorImpl]

'position' @ [99:76] ==> public final val position: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'bound' @ [103:13] ==> value-parameter bound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[ValueParameterDescriptorImpl]

'typeVariable' @ [103:19] ==> public final val typeVariable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'getNestedTypeVariables' @ [103:35] ==> internal final fun getNestedTypeVariables(type: KotlinType): List<TypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl[SimpleFunctionDescriptorImpl]

'newConstrainingType' @ [103:58] ==> value-parameter newConstrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound.addNewBound[ValueParameterDescriptorImpl]

'HashSet' @ [106:27] ==> public constructor HashSet<E : (Any..Any?)>(p0: (MutableCollection<out (TypeVariable..TypeVariable?)>..Collection<(TypeVariable..TypeVariable?)>?)) defined in java.util.HashSet[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> TypeVariable

'bound' @ [106:35] ==> value-parameter bound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[ValueParameterDescriptorImpl]

'derivedFrom' @ [106:41] ==> public final val derivedFrom: Set<TypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'substitution' @ [106:55] ==> value-parameter substitution: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[ValueParameterDescriptorImpl]

'derivedFrom' @ [106:68] ==> public final val derivedFrom: Set<TypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'derivedFrom' @ [107:13] ==> val derivedFrom: HashSet<TypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound.addNewBound[LocalVariableDescriptor]

'contains' @ [107:25] ==> public open fun contains(element: TypeVariable): Boolean defined in java.util.HashSet[JavaMethodDescriptor]

'substitution' @ [107:34] ==> value-parameter substitution: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[ValueParameterDescriptorImpl]

'typeVariable' @ [107:47] ==> public final val typeVariable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'derivedFrom' @ [109:9] ==> val derivedFrom: HashSet<TypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound.addNewBound[LocalVariableDescriptor]

'add' @ [109:21] ==> public open fun add(element: TypeVariable): Boolean defined in java.util.HashSet[JavaMethodDescriptor]

'substitution' @ [109:25] ==> value-parameter substitution: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[ValueParameterDescriptorImpl]

'typeVariable' @ [109:38] ==> public final val typeVariable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'addBound' @ [110:9] ==> internal final fun addBound(typeVariable: TypeVariable, constrainingType: KotlinType, kind: TypeBounds.BoundKind, constraintContext: ConstraintContext): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemBuilderImpl[SimpleFunctionDescriptorImpl]

'bound' @ [110:18] ==> value-parameter bound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[ValueParameterDescriptorImpl]

'typeVariable' @ [110:24] ==> public final val typeVariable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'newConstrainingType' @ [110:38] ==> value-parameter newConstrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound.addNewBound[ValueParameterDescriptorImpl]

'newBoundKind' @ [110:59] ==> value-parameter newBoundKind: TypeBounds.BoundKind defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound.addNewBound[ValueParameterDescriptorImpl]

'ConstraintContext' @ [110:73] ==> public constructor ConstraintContext(position: ConstraintPosition, derivedFrom: Set<TypeVariable>? = ..., initial: Boolean = ..., initialReduction: Boolean = ...) defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintContext[ClassConstructorDescriptorImpl]

'position' @ [110:91] ==> val position: CompoundConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[LocalVariableDescriptor]

'derivedFrom' @ [110:101] ==> val derivedFrom: HashSet<TypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound.addNewBound[LocalVariableDescriptor]

'substitution' @ [113:9] ==> value-parameter substitution: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[ValueParameterDescriptorImpl]

'kind' @ [113:22] ==> public final val kind: TypeBounds.BoundKind defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'EXACT_BOUND' @ [113:30] ==> enum entry EXACT_BOUND defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[FakeCallableDescriptorForObject]

'addNewBound' @ [114:9] ==> local final fun addNewBound(newConstrainingType: KotlinType, newBoundKind: TypeBounds.BoundKind): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[SimpleFunctionDescriptorImpl]

'type' @ [114:21] ==> val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[LocalVariableDescriptor]

'bound' @ [114:27] ==> value-parameter bound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[ValueParameterDescriptorImpl]

'kind' @ [114:33] ==> public final val kind: TypeBounds.BoundKind defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'approximateCapturedTypes' @ [117:31] ==> public fun approximateCapturedTypes(type: KotlinType): ApproximationBounds<KotlinType> defined in org.jetbrains.kotlin.types.typesApproximation[DeserializedSimpleFunctionDescriptor]

'type' @ [117:56] ==> val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[LocalVariableDescriptor]

'this' @ [121:66] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound.containsConstrainingTypeWithoutProjection[ReceiverParameterDescriptorImpl]

'getNestedArguments' @ [121:71] ==> internal fun KotlinType.getNestedArguments(): List<TypeProjection> defined in org.jetbrains.kotlin.resolve.calls.inference[SimpleFunctionDescriptorImpl]

'any' @ [121:92] ==> public inline fun <T> Iterable<TypeProjection>.any(predicate: (TypeProjection) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection

'it' @ [122:9] ==> value-parameter it: TypeProjection defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound.containsConstrainingTypeWithoutProjection.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [122:12] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'constructor' @ [122:17] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'substitution' @ [122:32] ==> value-parameter substitution: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[ValueParameterDescriptorImpl]

'constrainingType' @ [122:45] ==> public final val constrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'constructor' @ [122:62] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'it' @ [122:77] ==> value-parameter it: TypeProjection defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound.containsConstrainingTypeWithoutProjection.<anonymous>[ValueParameterDescriptorImpl]

'projectionKind' @ [122:80] ==> public final val TypeProjection.projectionKind: Variance[MyPropertyDescriptor]

'INVARIANT' @ [122:107] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'approximationBounds' @ [124:9] ==> val approximationBounds: ApproximationBounds<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[LocalVariableDescriptor]

'upper' @ [124:29] ==> public final val upper: KotlinType defined in org.jetbrains.kotlin.types.typesApproximation.ApproximationBounds[DeserializedPropertyDescriptor]

'containsConstrainingTypeWithoutProjection' @ [124:35] ==> local final fun KotlinType.containsConstrainingTypeWithoutProjection(): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[SimpleFunctionDescriptorImpl]

'bound' @ [124:82] ==> value-parameter bound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[ValueParameterDescriptorImpl]

'kind' @ [124:88] ==> public final val kind: TypeBounds.BoundKind defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'LOWER_BOUND' @ [124:96] ==> enum entry LOWER_BOUND defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[FakeCallableDescriptorForObject]

'addNewBound' @ [125:9] ==> local final fun addNewBound(newConstrainingType: KotlinType, newBoundKind: TypeBounds.BoundKind): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[SimpleFunctionDescriptorImpl]

'approximationBounds' @ [125:21] ==> val approximationBounds: ApproximationBounds<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[LocalVariableDescriptor]

'upper' @ [125:41] ==> public final val upper: KotlinType defined in org.jetbrains.kotlin.types.typesApproximation.ApproximationBounds[DeserializedPropertyDescriptor]

'UPPER_BOUND' @ [125:48] ==> enum entry UPPER_BOUND defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[FakeCallableDescriptorForObject]

'approximationBounds' @ [127:9] ==> val approximationBounds: ApproximationBounds<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[LocalVariableDescriptor]

'lower' @ [127:29] ==> public final val lower: KotlinType defined in org.jetbrains.kotlin.types.typesApproximation.ApproximationBounds[DeserializedPropertyDescriptor]

'containsConstrainingTypeWithoutProjection' @ [127:35] ==> local final fun KotlinType.containsConstrainingTypeWithoutProjection(): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[SimpleFunctionDescriptorImpl]

'bound' @ [127:82] ==> value-parameter bound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[ValueParameterDescriptorImpl]

'kind' @ [127:88] ==> public final val kind: TypeBounds.BoundKind defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'UPPER_BOUND' @ [127:96] ==> enum entry UPPER_BOUND defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[FakeCallableDescriptorForObject]

'addNewBound' @ [128:9] ==> local final fun addNewBound(newConstrainingType: KotlinType, newBoundKind: TypeBounds.BoundKind): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[SimpleFunctionDescriptorImpl]

'approximationBounds' @ [128:21] ==> val approximationBounds: ApproximationBounds<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.generateNewBound[LocalVariableDescriptor]

'lower' @ [128:41] ==> public final val lower: KotlinType defined in org.jetbrains.kotlin.types.typesApproximation.ApproximationBounds[DeserializedPropertyDescriptor]

'LOWER_BOUND' @ [128:48] ==> enum entry LOWER_BOUND defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[FakeCallableDescriptorForObject]

