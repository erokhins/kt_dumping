'LanguageFeature' @ [29:57] ==> public companion object defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'TypeInferenceOnGenericsForCallableReferences' @ [29:73] ==> enum entry TypeInferenceOnGenericsForCallableReferences defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'context' @ [30:13] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.CallableReferenceCompatibilityChecker.check[ValueParameterDescriptorImpl]

'languageVersionSettings' @ [30:21] ==> public final val languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[PropertyDescriptorImpl]

'supportsFeature' @ [30:45] ==> public open fun supportsFeature(feature: LanguageFeature): Boolean defined in org.jetbrains.kotlin.config.LanguageVersionSettings[DeserializedSimpleFunctionDescriptor]

'typeInferenceForCallableReferencesFeature' @ [30:61] ==> val typeInferenceForCallableReferencesFeature: LanguageFeature defined in org.jetbrains.kotlin.resolve.calls.checkers.CallableReferenceCompatibilityChecker.check[LocalVariableDescriptor]

'component1' @ [32:15] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>.component1(): (ValueParameterDescriptor..ValueParameterDescriptor?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)
    <V> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument..org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument?)

'component2' @ [32:18] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>.component2(): (ResolvedValueArgument..ResolvedValueArgument?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)
    <V> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument..org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument?)

'resolvedCall' @ [32:39] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.calls.checkers.CallableReferenceCompatibilityChecker.check[ValueParameterDescriptorImpl]

'valueArguments' @ [32:52] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.valueArguments: (MutableMap<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>..Map<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(*)

'resolvedArgument' @ [33:37] ==> val resolvedArgument: (ResolvedValueArgument..ResolvedValueArgument?) defined in org.jetbrains.kotlin.resolve.calls.checkers.CallableReferenceCompatibilityChecker.check[LocalVariableDescriptor]

'arguments' @ [33:54] ==> public final val ResolvedValueArgument.arguments: (MutableList<(ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>)[MyPropertyDescriptor]

'argument' @ [34:42] ==> val argument: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.resolve.calls.checkers.CallableReferenceCompatibilityChecker.check[LocalVariableDescriptor]

'getArgumentExpression' @ [34:51] ==> @IfNotParsed public abstract fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.ValueArgument[SimpleFunctionDescriptorImpl]

'argumentExpression' @ [35:53] ==> val argumentExpression: KtCallableReferenceExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.CallableReferenceCompatibilityChecker.check[LocalVariableDescriptor]

'callableReference' @ [35:72] ==> public final val KtCallableReferenceExpression.callableReference: KtSimpleNameExpression[MyPropertyDescriptor]

'getResolvedCall' @ [35:90] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil in file callUtil.kt[SimpleFunctionDescriptorImpl]

'context' @ [35:106] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.CallableReferenceCompatibilityChecker.check[ValueParameterDescriptorImpl]

'trace' @ [35:114] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[PropertyDescriptorImpl]

'bindingContext' @ [35:120] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'callableReferenceResolvedCall' @ [36:21] ==> val callableReferenceResolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.checkers.CallableReferenceCompatibilityChecker.check[LocalVariableDescriptor]

'call' @ [36:51] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out CallableDescriptor)

'isCallableReference' @ [36:56] ==> public fun Call.isCallableReference(): Boolean defined in org.jetbrains.kotlin.resolve.calls.callUtil in file callUtil.kt[SimpleFunctionDescriptorImpl]

'callableReferenceResolvedCall' @ [37:21] ==> val callableReferenceResolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.checkers.CallableReferenceCompatibilityChecker.check[LocalVariableDescriptor]

'candidateDescriptor' @ [37:51] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.candidateDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out CallableDescriptor)

'typeParameters' @ [37:71] ==> public final val CallableDescriptor.typeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'isNotEmpty' @ [37:86] ==> @InlineOnly public inline fun <T> Collection<(TypeParameterDescriptor..TypeParameterDescriptor?)>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)

'context' @ [38:21] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.CallableReferenceCompatibilityChecker.check[ValueParameterDescriptorImpl]

'trace' @ [38:29] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[PropertyDescriptorImpl]

'report' @ [38:35] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'UNSUPPORTED_FEATURE' @ [38:49] ==> public final val UNSUPPORTED_FEATURE: (DiagnosticFactory1<(PsiElement..PsiElement?), (Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>..Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>..Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [38:69] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull argument: Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory1[JavaMethodDescriptor]

'argumentExpression' @ [38:72] ==> val argumentExpression: KtCallableReferenceExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.CallableReferenceCompatibilityChecker.check[LocalVariableDescriptor]

'typeInferenceForCallableReferencesFeature' @ [39:72] ==> val typeInferenceForCallableReferencesFeature: LanguageFeature defined in org.jetbrains.kotlin.resolve.calls.checkers.CallableReferenceCompatibilityChecker.check[LocalVariableDescriptor]

'context' @ [39:117] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.CallableReferenceCompatibilityChecker.check[ValueParameterDescriptorImpl]

'languageVersionSettings' @ [39:125] ==> public final val languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[PropertyDescriptorImpl]

