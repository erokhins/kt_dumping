'property' @ [77:9] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'getter' @ [77:18] ==> public final val KtProperty.getter: KtPropertyAccessor?[MyPropertyDescriptor]

'let' @ [77:26] ==> @InlineOnly public inline fun <T, R> KtPropertyAccessor.let(block: (KtPropertyAccessor) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtPropertyAccessor
    <R> -> Unit

'getter' @ [78:17] ==> value-parameter getter: KtPropertyAccessor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate.<anonymous>[ValueParameterDescriptorImpl]

'hasBody' @ [78:24] ==> @Override public open fun hasBody(): Boolean defined in org.jetbrains.kotlin.psi.KtPropertyAccessor[JavaMethodDescriptor]

'trace' @ [78:35] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'report' @ [78:41] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'ACCESSOR_FOR_DELEGATED_PROPERTY' @ [78:48] ==> public final val ACCESSOR_FOR_DELEGATED_PROPERTY: (DiagnosticFactory0<(KtPropertyAccessor..KtPropertyAccessor?)>..DiagnosticFactory0<(KtPropertyAccessor..KtPropertyAccessor?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [78:80] ==> @NotNull public open fun on(@NotNull element: KtPropertyAccessor): SimpleDiagnostic<(KtPropertyAccessor..KtPropertyAccessor?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'getter' @ [78:83] ==> value-parameter getter: KtPropertyAccessor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate.<anonymous>[ValueParameterDescriptorImpl]

'property' @ [80:9] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'setter' @ [80:18] ==> public final val KtProperty.setter: KtPropertyAccessor?[MyPropertyDescriptor]

'let' @ [80:26] ==> @InlineOnly public inline fun <T, R> KtPropertyAccessor.let(block: (KtPropertyAccessor) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtPropertyAccessor
    <R> -> Unit

'setter' @ [81:17] ==> value-parameter setter: KtPropertyAccessor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate.<anonymous>[ValueParameterDescriptorImpl]

'hasBody' @ [81:24] ==> @Override public open fun hasBody(): Boolean defined in org.jetbrains.kotlin.psi.KtPropertyAccessor[JavaMethodDescriptor]

'trace' @ [81:35] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'report' @ [81:41] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'ACCESSOR_FOR_DELEGATED_PROPERTY' @ [81:48] ==> public final val ACCESSOR_FOR_DELEGATED_PROPERTY: (DiagnosticFactory0<(KtPropertyAccessor..KtPropertyAccessor?)>..DiagnosticFactory0<(KtPropertyAccessor..KtPropertyAccessor?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [81:80] ==> @NotNull public open fun on(@NotNull element: KtPropertyAccessor): SimpleDiagnostic<(KtPropertyAccessor..KtPropertyAccessor?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'setter' @ [81:83] ==> value-parameter setter: KtPropertyAccessor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate.<anonymous>[ValueParameterDescriptorImpl]

'if (variableDescriptor is PropertyDescriptor)
                    ScopeUtils.makeScopeForPropertyInitializer(propertyHeaderScope, variableDescriptor)
                else propertyHeaderScope' @ [85:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: LexicalScope, elseBranch: LexicalScope): LexicalScope[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> LexicalScope

'variableDescriptor' @ [85:21] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'makeScopeForPropertyInitializer' @ [86:32] ==> @NotNull public open fun makeScopeForPropertyInitializer(@NotNull p0: LexicalScope, @NotNull p1: PropertyDescriptor): LexicalScope defined in org.jetbrains.kotlin.resolve.scopes.ScopeUtils[JavaMethodDescriptor]

'propertyHeaderScope' @ [86:64] ==> value-parameter propertyHeaderScope: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'variableDescriptor' @ [86:85] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'propertyHeaderScope' @ [87:22] ==> value-parameter propertyHeaderScope: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'resolveDelegateExpression' @ [89:32] ==> public final fun resolveDelegateExpression(delegateExpression: KtExpression, property: KtProperty, variableDescriptor: VariableDescriptorWithAccessors, scopeForDelegate: LexicalScope, trace: BindingTrace, dataFlowInfo: DataFlowInfo): KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'delegateExpression' @ [89:58] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'property' @ [89:78] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'variableDescriptor' @ [89:88] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'initializerScope' @ [89:108] ==> val initializerScope: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[LocalVariableDescriptor]

'trace' @ [89:126] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'outerDataFlowInfo' @ [89:133] ==> value-parameter outerDataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'resolveProvideDelegateMethod' @ [91:9] ==> private final fun resolveProvideDelegateMethod(propertyDescriptor: VariableDescriptorWithAccessors, byExpression: KtExpression, byExpressionType: KotlinType, trace: BindingTrace, initializerScope: LexicalScope, dataFlowInfo: DataFlowInfo): Unit defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'variableDescriptor' @ [91:38] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'delegateExpression' @ [91:58] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'byExpressionType' @ [91:78] ==> val byExpressionType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[LocalVariableDescriptor]

'trace' @ [91:96] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'initializerScope' @ [91:103] ==> val initializerScope: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[LocalVariableDescriptor]

'outerDataFlowInfo' @ [91:121] ==> value-parameter outerDataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'getResolvedDelegateType' @ [92:28] ==> private final fun getResolvedDelegateType(variableDescriptor: VariableDescriptorWithAccessors, delegateExpression: KtExpression, byExpressionType: KotlinType, trace: BindingTrace): KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'variableDescriptor' @ [92:52] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'delegateExpression' @ [92:72] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'byExpressionType' @ [92:92] ==> val byExpressionType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[LocalVariableDescriptor]

'trace' @ [92:110] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'resolveGetValueMethod' @ [94:9] ==> private final fun resolveGetValueMethod(variableDescriptor: VariableDescriptorWithAccessors, delegateExpression: KtExpression, delegateType: KotlinType, trace: BindingTrace, initializerScope: LexicalScope, dataFlowInfo: DataFlowInfo): Unit defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'variableDescriptor' @ [94:31] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'delegateExpression' @ [94:51] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'delegateType' @ [94:71] ==> val delegateType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[LocalVariableDescriptor]

'trace' @ [94:85] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'initializerScope' @ [94:92] ==> val initializerScope: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[LocalVariableDescriptor]

'outerDataFlowInfo' @ [94:110] ==> value-parameter outerDataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'property' @ [95:13] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'isVar' @ [95:22] ==> public final val KtProperty.isVar: Boolean[MyPropertyDescriptor]

'resolveSetValueMethod' @ [96:13] ==> private final fun resolveSetValueMethod(variableDescriptor: VariableDescriptorWithAccessors, delegateExpression: KtExpression, delegateType: KotlinType, trace: BindingTrace, initializerScope: LexicalScope, dataFlowInfo: DataFlowInfo): Unit defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'variableDescriptor' @ [96:35] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'delegateExpression' @ [96:55] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'delegateType' @ [96:75] ==> val delegateType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[LocalVariableDescriptor]

'trace' @ [96:89] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'initializerScope' @ [96:96] ==> val initializerScope: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[LocalVariableDescriptor]

'outerDataFlowInfo' @ [96:114] ==> value-parameter outerDataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolvePropertyDelegate[ValueParameterDescriptorImpl]

'trace' @ [106:43] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getResolvedDelegateType[ValueParameterDescriptorImpl]

'bindingContext' @ [106:49] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'get' @ [106:64] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(slice: (ReadOnlySlice<(VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>..ReadOnlySlice<(VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>?), key: (VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?)): ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> VariableDescriptorWithAccessors
    <V : (Any..Any?)> -> ResolvedCall<(org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)>

'PROVIDE_DELEGATE_RESOLVED_CALL' @ [106:68] ==> public final val PROVIDE_DELEGATE_RESOLVED_CALL: (WritableSlice<(VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>..WritableSlice<(VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'variableDescriptor' @ [106:100] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getResolvedDelegateType[ValueParameterDescriptorImpl]

'provideDelegateResolvedCall' @ [107:13] ==> val provideDelegateResolvedCall: ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getResolvedDelegateType[LocalVariableDescriptor]

'provideDelegateResolvedCall' @ [108:20] ==> val provideDelegateResolvedCall: ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getResolvedDelegateType[LocalVariableDescriptor]

'resultingDescriptor' @ [108:48] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>.resultingDescriptor: (FunctionDescriptor..FunctionDescriptor?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)

'returnType' @ [108:68] ==> public final val FunctionDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'AssertionError' @ [109:29] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'delegateExpression' @ [109:88] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getResolvedDelegateType[ValueParameterDescriptorImpl]

'text' @ [109:107] ==> public final val KtExpression.text: (String..String?)[MyPropertyDescriptor]

'byExpressionType' @ [111:16] ==> value-parameter byExpressionType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getResolvedDelegateType[ValueParameterDescriptorImpl]

'resolveProvideDelegateMethod' @ [122:9] ==> private final fun resolveProvideDelegateMethod(propertyDescriptor: VariableDescriptorWithAccessors, byExpression: KtExpression, byExpressionType: KotlinType, trace: BindingTrace, initializerScope: LexicalScope, dataFlowInfo: DataFlowInfo): Unit defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'variableDescriptor' @ [122:38] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetValueMethodReturnType[ValueParameterDescriptorImpl]

'delegateExpression' @ [122:58] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetValueMethodReturnType[ValueParameterDescriptorImpl]

'byExpressionType' @ [122:78] ==> value-parameter byExpressionType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetValueMethodReturnType[ValueParameterDescriptorImpl]

'trace' @ [122:96] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetValueMethodReturnType[ValueParameterDescriptorImpl]

'initializerScope' @ [122:103] ==> value-parameter initializerScope: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetValueMethodReturnType[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [122:121] ==> value-parameter dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetValueMethodReturnType[ValueParameterDescriptorImpl]

'getResolvedDelegateType' @ [123:28] ==> private final fun getResolvedDelegateType(variableDescriptor: VariableDescriptorWithAccessors, delegateExpression: KtExpression, byExpressionType: KotlinType, trace: BindingTrace): KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'variableDescriptor' @ [123:52] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetValueMethodReturnType[ValueParameterDescriptorImpl]

'delegateExpression' @ [123:72] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetValueMethodReturnType[ValueParameterDescriptorImpl]

'byExpressionType' @ [123:92] ==> value-parameter byExpressionType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetValueMethodReturnType[ValueParameterDescriptorImpl]

'trace' @ [123:110] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetValueMethodReturnType[ValueParameterDescriptorImpl]

'resolveGetSetValueMethod' @ [124:9] ==> private final fun resolveGetSetValueMethod(propertyDescriptor: VariableDescriptorWithAccessors, delegateExpression: KtExpression, delegateType: KotlinType, trace: BindingTrace, initializerScope: LexicalScope, dataFlowInfo: DataFlowInfo, isGet: Boolean): Unit defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'variableDescriptor' @ [124:34] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetValueMethodReturnType[ValueParameterDescriptorImpl]

'delegateExpression' @ [124:54] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetValueMethodReturnType[ValueParameterDescriptorImpl]

'delegateType' @ [124:74] ==> val delegateType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetValueMethodReturnType[LocalVariableDescriptor]

'trace' @ [124:88] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetValueMethodReturnType[ValueParameterDescriptorImpl]

'initializerScope' @ [124:95] ==> value-parameter initializerScope: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetValueMethodReturnType[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [124:113] ==> value-parameter dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetValueMethodReturnType[ValueParameterDescriptorImpl]

'trace' @ [126:28] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetValueMethodReturnType[ValueParameterDescriptorImpl]

'bindingContext' @ [126:34] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'get' @ [126:49] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(slice: (ReadOnlySlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>..ReadOnlySlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>?), key: (VariableAccessorDescriptor..VariableAccessorDescriptor?)): ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> VariableAccessorDescriptor
    <V : (Any..Any?)> -> ResolvedCall<(org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)>

'DELEGATED_PROPERTY_RESOLVED_CALL' @ [126:53] ==> public final val DELEGATED_PROPERTY_RESOLVED_CALL: (WritableSlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>..WritableSlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'variableDescriptor' @ [126:87] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetValueMethodReturnType[ValueParameterDescriptorImpl]

'getter' @ [126:106] ==> public abstract val getter: VariableAccessorDescriptor? defined in org.jetbrains.kotlin.descriptors.VariableDescriptorWithAccessors[DeserializedPropertyDescriptor]

'if (resolvedCall != null) resolvedCall.resultingDescriptor.returnType else null' @ [127:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType?, elseBranch: KotlinType?): KotlinType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType?

'resolvedCall' @ [127:20] ==> val resolvedCall: ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetValueMethodReturnType[LocalVariableDescriptor]

'resolvedCall' @ [127:42] ==> val resolvedCall: ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetValueMethodReturnType[LocalVariableDescriptor]

'resultingDescriptor' @ [127:55] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>.resultingDescriptor: (FunctionDescriptor..FunctionDescriptor?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)

'returnType' @ [127:75] ==> public final val FunctionDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'languageVersionSettings' @ [131:17] ==> private final val languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[PropertyDescriptorImpl]

'supportsFeature' @ [131:41] ==> public open fun supportsFeature(feature: LanguageFeature): Boolean defined in org.jetbrains.kotlin.config.LanguageVersionSettings[DeserializedSimpleFunctionDescriptor]

'LanguageFeature' @ [131:57] ==> public companion object defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'OperatorProvideDelegate' @ [131:73] ==> enum entry OperatorProvideDelegate defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'getGetValueMethodReturnType' @ [141:26] ==> public final fun getGetValueMethodReturnType(variableDescriptor: VariableDescriptorWithAccessors, delegateExpression: KtExpression, byExpressionType: KotlinType, trace: BindingTrace, initializerScope: LexicalScope, dataFlowInfo: DataFlowInfo): KotlinType? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'variableDescriptor' @ [141:54] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetValueMethod[ValueParameterDescriptorImpl]

'delegateExpression' @ [141:74] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetValueMethod[ValueParameterDescriptorImpl]

'delegateType' @ [141:94] ==> value-parameter delegateType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetValueMethod[ValueParameterDescriptorImpl]

'trace' @ [141:108] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetValueMethod[ValueParameterDescriptorImpl]

'initializerScope' @ [141:115] ==> value-parameter initializerScope: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetValueMethod[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [141:133] ==> value-parameter dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetValueMethod[ValueParameterDescriptorImpl]

'variableDescriptor' @ [142:28] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetValueMethod[ValueParameterDescriptorImpl]

'type' @ [142:47] ==> public final val VariableDescriptorWithAccessors.type: KotlinType[MyPropertyDescriptor]

'propertyType' @ [145:13] ==> val propertyType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetValueMethod[LocalVariableDescriptor]

'returnType' @ [145:46] ==> val returnType: KotlinType? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetValueMethod[LocalVariableDescriptor]

'!' @ [145:68] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'DEFAULT' @ [145:87] ==> public final val DEFAULT: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaPropertyDescriptor]

'isSubtypeOf' @ [145:95] ==> public abstract fun isSubtypeOf(@NotNull p0: KotlinType, @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaMethodDescriptor]

'returnType' @ [145:107] ==> val returnType: KotlinType? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetValueMethod[LocalVariableDescriptor]

'propertyType' @ [145:119] ==> val propertyType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetValueMethod[LocalVariableDescriptor]

'trace' @ [146:24] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetValueMethod[ValueParameterDescriptorImpl]

'bindingContext' @ [146:30] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'get' @ [146:45] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(slice: (ReadOnlySlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (Call..Call?)>..ReadOnlySlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (Call..Call?)>?), key: (VariableAccessorDescriptor..VariableAccessorDescriptor?)): Call? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> VariableAccessorDescriptor
    <V : (Any..Any?)> -> Call

'DELEGATED_PROPERTY_CALL' @ [146:49] ==> public final val DELEGATED_PROPERTY_CALL: (WritableSlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (Call..Call?)>..WritableSlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (Call..Call?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'variableDescriptor' @ [146:74] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetValueMethod[ValueParameterDescriptorImpl]

'getter' @ [146:93] ==> public abstract val getter: VariableAccessorDescriptor? defined in org.jetbrains.kotlin.descriptors.VariableDescriptorWithAccessors[DeserializedPropertyDescriptor]

'AssertionError' @ [147:33] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'variableDescriptor' @ [147:74] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetValueMethod[ValueParameterDescriptorImpl]

'getter' @ [147:93] ==> public abstract val getter: VariableAccessorDescriptor? defined in org.jetbrains.kotlin.descriptors.VariableDescriptorWithAccessors[DeserializedPropertyDescriptor]

'trace' @ [148:13] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetValueMethod[ValueParameterDescriptorImpl]

'report' @ [148:19] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'DELEGATE_SPECIAL_FUNCTION_RETURN_TYPE_MISMATCH' @ [148:26] ==> public final val DELEGATE_SPECIAL_FUNCTION_RETURN_TYPE_MISMATCH: (DiagnosticFactory3<(KtExpression..KtExpression?), (String..String?), (KotlinType..KotlinType?), (KotlinType..KotlinType?)>..DiagnosticFactory3<(KtExpression..KtExpression?), (String..String?), (KotlinType..KotlinType?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [148:73] ==> @NotNull public open fun on(@NotNull element: KtExpression, @NotNull a: String, @NotNull b: KotlinType, @NotNull c: KotlinType): ParametrizedDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory3[JavaMethodDescriptor]

'delegateExpression' @ [149:21] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetValueMethod[ValueParameterDescriptorImpl]

'renderCall' @ [149:41] ==> private final fun renderCall(call: Call, context: BindingContext): String defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'call' @ [149:52] ==> val call: Call defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetValueMethod[LocalVariableDescriptor]

'trace' @ [149:58] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetValueMethod[ValueParameterDescriptorImpl]

'bindingContext' @ [149:64] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'variableDescriptor' @ [149:81] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetValueMethod[ValueParameterDescriptorImpl]

'type' @ [149:100] ==> public final val VariableDescriptorWithAccessors.type: KotlinType[MyPropertyDescriptor]

'returnType' @ [149:106] ==> val returnType: KotlinType? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetValueMethod[LocalVariableDescriptor]

'resolveGetSetValueMethod' @ [161:9] ==> private final fun resolveGetSetValueMethod(propertyDescriptor: VariableDescriptorWithAccessors, delegateExpression: KtExpression, delegateType: KotlinType, trace: BindingTrace, initializerScope: LexicalScope, dataFlowInfo: DataFlowInfo, isGet: Boolean): Unit defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'variableDescriptor' @ [161:34] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveSetValueMethod[ValueParameterDescriptorImpl]

'delegateExpression' @ [161:54] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveSetValueMethod[ValueParameterDescriptorImpl]

'delegateType' @ [161:74] ==> value-parameter delegateType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveSetValueMethod[ValueParameterDescriptorImpl]

'trace' @ [161:88] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveSetValueMethod[ValueParameterDescriptorImpl]

'initializerScope' @ [162:34] ==> value-parameter initializerScope: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveSetValueMethod[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [162:52] ==> value-parameter dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveSetValueMethod[ValueParameterDescriptorImpl]

'createExpression' @ [166:16] ==> public final fun createExpression(text: String): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[SimpleFunctionDescriptorImpl]

'FQ_NAMES' @ [166:59] ==> public final val FQ_NAMES: (KotlinBuiltIns.FqNames..KotlinBuiltIns.FqNames?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaPropertyDescriptor]

'kProperty' @ [166:68] ==> public final val kProperty: (ClassId..ClassId?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns.FqNames[JavaPropertyDescriptor]

'asSingleFqName' @ [166:78] ==> @NotNull public open fun asSingleFqName(): FqName defined in org.jetbrains.kotlin.name.ClassId[JavaMethodDescriptor]

'asString' @ [166:95] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'?:' @ [179:24] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: VariableAccessorDescriptor?, right: VariableAccessorDescriptor): VariableAccessorDescriptor[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> VariableAccessorDescriptor

'if (isGet) propertyDescriptor.getter else propertyDescriptor.setter' @ [179:25] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: VariableAccessorDescriptor?, elseBranch: VariableAccessorDescriptor?): VariableAccessorDescriptor?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> VariableAccessorDescriptor?

'isGet' @ [179:29] ==> value-parameter isGet: Boolean defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[ValueParameterDescriptorImpl]

'propertyDescriptor' @ [179:36] ==> value-parameter propertyDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[ValueParameterDescriptorImpl]

'getter' @ [179:55] ==> public abstract val getter: VariableAccessorDescriptor? defined in org.jetbrains.kotlin.descriptors.VariableDescriptorWithAccessors[DeserializedPropertyDescriptor]

'propertyDescriptor' @ [179:67] ==> value-parameter propertyDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[ValueParameterDescriptorImpl]

'setter' @ [179:86] ==> public abstract val setter: VariableAccessorDescriptor? defined in org.jetbrains.kotlin.descriptors.VariableDescriptorWithAccessors[DeserializedPropertyDescriptor]

'AssertionError' @ [180:33] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'propertyDescriptor' @ [180:95] ==> value-parameter propertyDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[ValueParameterDescriptorImpl]

'delegateExpression' @ [180:116] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[ValueParameterDescriptorImpl]

'text' @ [180:135] ==> public final val KtExpression.text: (String..String?)[MyPropertyDescriptor]

'trace' @ [182:13] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[ValueParameterDescriptorImpl]

'bindingContext' @ [182:19] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'get' @ [182:34] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(slice: (ReadOnlySlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (Call..Call?)>..ReadOnlySlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (Call..Call?)>?), key: (VariableAccessorDescriptor..VariableAccessorDescriptor?)): Call? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> VariableAccessorDescriptor
    <V : (Any..Any?)> -> Call

'DELEGATED_PROPERTY_CALL' @ [182:38] ==> public final val DELEGATED_PROPERTY_CALL: (WritableSlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (Call..Call?)>..WritableSlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (Call..Call?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'accessor' @ [182:63] ==> val accessor: VariableAccessorDescriptor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[LocalVariableDescriptor]

'getGetSetValueMethod' @ [184:31] ==> private final fun getGetSetValueMethod(propertyDescriptor: VariableDescriptorWithAccessors, delegateExpression: KtExpression, delegateType: KotlinType, trace: BindingTrace, scopeForDelegate: LexicalScope, dataFlowInfo: DataFlowInfo, isGet: Boolean, isComplete: Boolean): OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'propertyDescriptor' @ [185:17] ==> value-parameter propertyDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[ValueParameterDescriptorImpl]

'delegateExpression' @ [185:37] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[ValueParameterDescriptorImpl]

'delegateType' @ [185:57] ==> value-parameter delegateType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[ValueParameterDescriptorImpl]

'trace' @ [185:71] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[ValueParameterDescriptorImpl]

'initializerScope' @ [185:78] ==> value-parameter initializerScope: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [185:96] ==> value-parameter dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[ValueParameterDescriptorImpl]

'isGet' @ [186:25] ==> value-parameter isGet: Boolean defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[ValueParameterDescriptorImpl]

'!' @ [189:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'functionResults' @ [189:14] ==> val functionResults: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[LocalVariableDescriptor]

'isSuccess' @ [189:30] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<FunctionDescriptor>.isSuccess: Boolean[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'trace' @ [190:24] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[ValueParameterDescriptorImpl]

'bindingContext' @ [190:30] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'get' @ [190:45] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(slice: (ReadOnlySlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (Call..Call?)>..ReadOnlySlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (Call..Call?)>?), key: (VariableAccessorDescriptor..VariableAccessorDescriptor?)): Call? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> VariableAccessorDescriptor
    <V : (Any..Any?)> -> Call

'DELEGATED_PROPERTY_CALL' @ [190:49] ==> public final val DELEGATED_PROPERTY_CALL: (WritableSlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (Call..Call?)>..WritableSlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (Call..Call?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'accessor' @ [190:74] ==> val accessor: VariableAccessorDescriptor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[LocalVariableDescriptor]

'AssertionError' @ [191:33] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'reportDelegateOperatorResolutionError' @ [192:13] ==> private final fun reportDelegateOperatorResolutionError(trace: BindingTrace, delegateOperatorCall: Call, delegateOperatorResults: OverloadResolutionResults<FunctionDescriptor>, delegateExpression: KtExpression, delegateType: KotlinType, operatorRequired: Boolean = ...): Boolean defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'trace' @ [192:51] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[ValueParameterDescriptorImpl]

'call' @ [192:58] ==> val call: Call defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[LocalVariableDescriptor]

'functionResults' @ [192:64] ==> val functionResults: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[LocalVariableDescriptor]

'delegateExpression' @ [192:81] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[ValueParameterDescriptorImpl]

'delegateType' @ [192:101] ==> value-parameter delegateType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[ValueParameterDescriptorImpl]

'functionResults' @ [196:35] ==> val functionResults: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[LocalVariableDescriptor]

'resultingDescriptor' @ [196:51] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<FunctionDescriptor>.resultingDescriptor: FunctionDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'functionResults' @ [197:29] ==> val functionResults: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[LocalVariableDescriptor]

'resultingCall' @ [197:45] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<FunctionDescriptor>.resultingCall: ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'!' @ [199:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'resultingDescriptor' @ [199:14] ==> val resultingDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[LocalVariableDescriptor]

'isOperator' @ [199:34] ==> public final val FunctionDescriptor.isOperator: Boolean[MyPropertyDescriptor]

'DescriptorToSourceUtils' @ [200:31] ==> public object DescriptorToSourceUtils defined in org.jetbrains.kotlin.resolve in file DescriptorToSourceUtils.kt[FakeCallableDescriptorForObject]

'descriptorToDeclaration' @ [200:55] ==> @JvmStatic public final fun descriptorToDeclaration(descriptor: DeclarationDescriptor): PsiElement? defined in org.jetbrains.kotlin.resolve.DescriptorToSourceUtils[SimpleFunctionDescriptorImpl]

'propertyDescriptor' @ [200:79] ==> value-parameter propertyDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[ValueParameterDescriptorImpl]

'declaration' @ [201:17] ==> val declaration: PsiElement? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[LocalVariableDescriptor]

'declaration' @ [202:32] ==> val declaration: PsiElement? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[LocalVariableDescriptor]

'delegate' @ [202:44] ==> public final val KtProperty.delegate: KtPropertyDelegate?[MyPropertyDescriptor]

'delegate' @ [203:21] ==> val delegate: KtPropertyDelegate? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[LocalVariableDescriptor]

'delegate' @ [204:37] ==> val delegate: KtPropertyDelegate? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[LocalVariableDescriptor]

'byKeywordNode' @ [204:46] ==> public final val KtPropertyDelegate.byKeywordNode: ASTNode[MyPropertyDescriptor]

'psi' @ [204:60] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'OperatorCallChecker' @ [205:21] ==> public companion object defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker[FakeCallableDescriptorForObject]

'report' @ [205:41] ==> public final fun report(reportOn: PsiElement, descriptor: FunctionDescriptor, sink: DiagnosticSink): Unit defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.Companion[SimpleFunctionDescriptorImpl]

'byKeyword' @ [205:48] ==> val byKeyword: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[LocalVariableDescriptor]

'resultingDescriptor' @ [205:59] ==> val resultingDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[LocalVariableDescriptor]

'trace' @ [205:80] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[ValueParameterDescriptorImpl]

'trace' @ [210:9] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[ValueParameterDescriptorImpl]

'record' @ [210:15] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>..WritableSlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>?), key: (VariableAccessorDescriptor..VariableAccessorDescriptor?), value: (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> VariableAccessorDescriptor
    <V : (Any..Any?)> -> ResolvedCall<(org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)>

'DELEGATED_PROPERTY_RESOLVED_CALL' @ [210:22] ==> public final val DELEGATED_PROPERTY_RESOLVED_CALL: (WritableSlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>..WritableSlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'accessor' @ [210:56] ==> val accessor: VariableAccessorDescriptor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[LocalVariableDescriptor]

'resultingCall' @ [210:66] ==> val resultingCall: ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveGetSetValueMethod[LocalVariableDescriptor]

'renderCall' @ [221:32] ==> private final fun renderCall(call: Call, context: BindingContext): String defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'delegateOperatorCall' @ [221:43] ==> value-parameter delegateOperatorCall: Call defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.reportDelegateOperatorResolutionError[ValueParameterDescriptorImpl]

'trace' @ [221:65] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.reportDelegateOperatorResolutionError[ValueParameterDescriptorImpl]

'bindingContext' @ [221:71] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'when {
            delegateOperatorResults.isSingleResult ||
            delegateOperatorResults.isIncomplete ||
            delegateOperatorResults.resultCode == OverloadResolutionResults.Code.MANY_FAILED_CANDIDATES -> DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE

            delegateOperatorResults.isAmbiguity -> DELEGATE_SPECIAL_FUNCTION_AMBIGUITY

            else -> null
        }' @ [223:38] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: DiagnosticFactory2<(KtExpression..KtExpression?), (String..String?), (MutableCollection<out (ResolvedCall<*>..ResolvedCall<*>?)>..Collection<(ResolvedCall<*>..ResolvedCall<*>?)>?)>?, entry1: DiagnosticFactory2<(KtExpression..KtExpression?), (String..String?), (MutableCollection<out (ResolvedCall<*>..ResolvedCall<*>?)>..Collection<(ResolvedCall<*>..ResolvedCall<*>?)>?)>?, entry2: DiagnosticFactory2<(KtExpression..KtExpression?), (String..String?), (MutableCollection<out (ResolvedCall<*>..ResolvedCall<*>?)>..Collection<(ResolvedCall<*>..ResolvedCall<*>?)>?)>?): DiagnosticFactory2<(KtExpression..KtExpression?), (String..String?), (MutableCollection<out (ResolvedCall<*>..ResolvedCall<*>?)>..Collection<(ResolvedCall<*>..ResolvedCall<*>?)>?)>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> DiagnosticFactory2<(org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?), (kotlin.String..kotlin.String?), (kotlin.collections.MutableCollection<out (org.jetbrains.kotlin.resolve.calls.model.ResolvedCall<*>..org.jetbrains.kotlin.resolve.calls.model.ResolvedCall<*>?)>..kotlin.collections.Collection<(org.jetbrains.kotlin.resolve.calls.model.ResolvedCall<*>..org.jetbrains.kotlin.resolve.calls.model.ResolvedCall<*>?)>?)>?

'delegateOperatorResults' @ [224:13] ==> value-parameter delegateOperatorResults: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.reportDelegateOperatorResolutionError[ValueParameterDescriptorImpl]

'isSingleResult' @ [224:37] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<FunctionDescriptor>.isSingleResult: Boolean[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'delegateOperatorResults' @ [225:13] ==> value-parameter delegateOperatorResults: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.reportDelegateOperatorResolutionError[ValueParameterDescriptorImpl]

'isIncomplete' @ [225:37] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<FunctionDescriptor>.isIncomplete: Boolean[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'delegateOperatorResults' @ [226:13] ==> value-parameter delegateOperatorResults: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.reportDelegateOperatorResolutionError[ValueParameterDescriptorImpl]

'resultCode' @ [226:37] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<FunctionDescriptor>.resultCode: OverloadResolutionResults.Code[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'MANY_FAILED_CANDIDATES' @ [226:82] ==> enum entry MANY_FAILED_CANDIDATES defined in org.jetbrains.kotlin.resolve.calls.results.OverloadResolutionResults.Code[FakeCallableDescriptorForObject]

'DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE' @ [226:108] ==> public final val DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE: (DiagnosticFactory2<(KtExpression..KtExpression?), (String..String?), (MutableCollection<out (ResolvedCall<*>..ResolvedCall<*>?)>..Collection<(ResolvedCall<*>..ResolvedCall<*>?)>?)>..DiagnosticFactory2<(KtExpression..KtExpression?), (String..String?), (MutableCollection<out (ResolvedCall<*>..ResolvedCall<*>?)>..Collection<(ResolvedCall<*>..ResolvedCall<*>?)>?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'delegateOperatorResults' @ [228:13] ==> value-parameter delegateOperatorResults: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.reportDelegateOperatorResolutionError[ValueParameterDescriptorImpl]

'isAmbiguity' @ [228:37] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<FunctionDescriptor>.isAmbiguity: Boolean[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'DELEGATE_SPECIAL_FUNCTION_AMBIGUITY' @ [228:52] ==> public final val DELEGATE_SPECIAL_FUNCTION_AMBIGUITY: (DiagnosticFactory2<(KtExpression..KtExpression?), (String..String?), (MutableCollection<out (ResolvedCall<*>..ResolvedCall<*>?)>..Collection<(ResolvedCall<*>..ResolvedCall<*>?)>?)>..DiagnosticFactory2<(KtExpression..KtExpression?), (String..String?), (MutableCollection<out (ResolvedCall<*>..ResolvedCall<*>?)>..Collection<(ResolvedCall<*>..ResolvedCall<*>?)>?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'resolutionErrorFactory' @ [233:13] ==> val resolutionErrorFactory: DiagnosticFactory2<(KtExpression..KtExpression?), (String..String?), (MutableCollection<out (ResolvedCall<*>..ResolvedCall<*>?)>..Collection<(ResolvedCall<*>..ResolvedCall<*>?)>?)>? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.reportDelegateOperatorResolutionError[LocalVariableDescriptor]

'trace' @ [234:13] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.reportDelegateOperatorResolutionError[ValueParameterDescriptorImpl]

'report' @ [234:19] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'resolutionErrorFactory' @ [234:26] ==> val resolutionErrorFactory: DiagnosticFactory2<(KtExpression..KtExpression?), (String..String?), (MutableCollection<out (ResolvedCall<*>..ResolvedCall<*>?)>..Collection<(ResolvedCall<*>..ResolvedCall<*>?)>?)>? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.reportDelegateOperatorResolutionError[LocalVariableDescriptor]

'on' @ [234:49] ==> @NotNull public open fun on(@NotNull element: KtExpression, @NotNull a: String, @NotNull b: (MutableCollection<out (ResolvedCall<*>..ResolvedCall<*>?)>..Collection<(ResolvedCall<*>..ResolvedCall<*>?)>)): ParametrizedDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'delegateExpression' @ [234:52] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.reportDelegateOperatorResolutionError[ValueParameterDescriptorImpl]

'expectedFunction' @ [234:72] ==> val expectedFunction: String defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.reportDelegateOperatorResolutionError[LocalVariableDescriptor]

'delegateOperatorResults' @ [234:90] ==> value-parameter delegateOperatorResults: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.reportDelegateOperatorResolutionError[ValueParameterDescriptorImpl]

'resultingCalls' @ [234:114] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<FunctionDescriptor>.resultingCalls: (MutableCollection<out (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>..Collection<(ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'operatorRequired' @ [238:13] ==> value-parameter operatorRequired: Boolean = ... defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.reportDelegateOperatorResolutionError[ValueParameterDescriptorImpl]

'trace' @ [239:13] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.reportDelegateOperatorResolutionError[ValueParameterDescriptorImpl]

'report' @ [239:19] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'DELEGATE_SPECIAL_FUNCTION_MISSING' @ [239:26] ==> public final val DELEGATE_SPECIAL_FUNCTION_MISSING: (DiagnosticFactory2<(KtExpression..KtExpression?), (String..String?), (KotlinType..KotlinType?)>..DiagnosticFactory2<(KtExpression..KtExpression?), (String..String?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [239:60] ==> @NotNull public open fun on(@NotNull element: KtExpression, @NotNull a: String, @NotNull b: KotlinType): ParametrizedDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'delegateExpression' @ [239:63] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.reportDelegateOperatorResolutionError[ValueParameterDescriptorImpl]

'expectedFunction' @ [239:83] ==> val expectedFunction: String defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.reportDelegateOperatorResolutionError[LocalVariableDescriptor]

'delegateType' @ [239:101] ==> value-parameter delegateType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.reportDelegateOperatorResolutionError[ValueParameterDescriptorImpl]

'!' @ [254:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isOperatorProvideDelegateSupported' @ [254:14] ==> private final val isOperatorProvideDelegateSupported: Boolean defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[PropertyDescriptorImpl]

'trace' @ [255:13] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[ValueParameterDescriptorImpl]

'bindingContext' @ [255:19] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'get' @ [255:34] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(slice: (ReadOnlySlice<(VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?), (Call..Call?)>..ReadOnlySlice<(VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?), (Call..Call?)>?), key: (VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?)): Call? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> VariableDescriptorWithAccessors
    <V : (Any..Any?)> -> Call

'PROVIDE_DELEGATE_CALL' @ [255:53] ==> public final val PROVIDE_DELEGATE_CALL: (WritableSlice<(VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?), (Call..Call?)>..WritableSlice<(VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?), (Call..Call?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'propertyDescriptor' @ [255:76] ==> value-parameter propertyDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[ValueParameterDescriptorImpl]

'create' @ [257:61] ==> @NotNull public open fun create(@NotNull trace: BindingTrace, debugName: (String..String?)): TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.TemporaryBindingTrace[JavaMethodDescriptor]

'trace' @ [257:68] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[ValueParameterDescriptorImpl]

'getProvideDelegateMethod' @ [259:38] ==> private final fun getProvideDelegateMethod(propertyDescriptor: VariableDescriptorWithAccessors, delegateExpression: KtExpression, delegateExpressionType: KotlinType, trace: BindingTrace, initializerScope: LexicalScope, dataFlowInfo: DataFlowInfo): OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'propertyDescriptor' @ [259:63] ==> value-parameter propertyDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[ValueParameterDescriptorImpl]

'byExpression' @ [259:83] ==> value-parameter byExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[ValueParameterDescriptorImpl]

'byExpressionType' @ [259:97] ==> value-parameter byExpressionType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[ValueParameterDescriptorImpl]

'traceForProvideDelegate' @ [260:61] ==> val traceForProvideDelegate: TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[LocalVariableDescriptor]

'initializerScope' @ [260:86] ==> value-parameter initializerScope: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [260:104] ==> value-parameter dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[ValueParameterDescriptorImpl]

'!' @ [261:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'provideDelegateResults' @ [261:14] ==> val provideDelegateResults: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[LocalVariableDescriptor]

'isSuccess' @ [261:37] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<FunctionDescriptor>.isSuccess: Boolean[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'traceForProvideDelegate' @ [262:24] ==> val traceForProvideDelegate: TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[LocalVariableDescriptor]

'bindingContext' @ [262:48] ==> public final val TemporaryBindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'get' @ [262:63] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(slice: (ReadOnlySlice<(VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?), (Call..Call?)>..ReadOnlySlice<(VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?), (Call..Call?)>?), key: (VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?)): Call? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> VariableDescriptorWithAccessors
    <V : (Any..Any?)> -> Call

'PROVIDE_DELEGATE_CALL' @ [262:82] ==> public final val PROVIDE_DELEGATE_CALL: (WritableSlice<(VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?), (Call..Call?)>..WritableSlice<(VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?), (Call..Call?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'propertyDescriptor' @ [262:105] ==> value-parameter propertyDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[ValueParameterDescriptorImpl]

'AssertionError' @ [263:33] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'reportDelegateOperatorResolutionError' @ [264:37] ==> private final fun reportDelegateOperatorResolutionError(trace: BindingTrace, delegateOperatorCall: Call, delegateOperatorResults: OverloadResolutionResults<FunctionDescriptor>, delegateExpression: KtExpression, delegateType: KotlinType, operatorRequired: Boolean = ...): Boolean defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'traceForProvideDelegate' @ [265:21] ==> val traceForProvideDelegate: TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[LocalVariableDescriptor]

'call' @ [265:46] ==> val call: Call defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[LocalVariableDescriptor]

'provideDelegateResults' @ [265:52] ==> val provideDelegateResults: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[LocalVariableDescriptor]

'byExpression' @ [265:76] ==> value-parameter byExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[ValueParameterDescriptorImpl]

'byExpressionType' @ [265:90] ==> value-parameter byExpressionType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[ValueParameterDescriptorImpl]

'shouldCommitTrace' @ [267:17] ==> val shouldCommitTrace: Boolean defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[LocalVariableDescriptor]

'traceForProvideDelegate' @ [268:17] ==> val traceForProvideDelegate: TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[LocalVariableDescriptor]

'commit' @ [268:41] ==> public open fun commit(): Unit defined in org.jetbrains.kotlin.resolve.TemporaryBindingTrace[JavaMethodDescriptor]

'traceForProvideDelegate' @ [274:9] ==> val traceForProvideDelegate: TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[LocalVariableDescriptor]

'commit' @ [274:33] ==> public open fun commit(): Unit defined in org.jetbrains.kotlin.resolve.TemporaryBindingTrace[JavaMethodDescriptor]

'provideDelegateResults' @ [276:35] ==> val provideDelegateResults: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[LocalVariableDescriptor]

'resultingDescriptor' @ [276:58] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<FunctionDescriptor>.resultingDescriptor: FunctionDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'!' @ [277:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'resultingDescriptor' @ [277:14] ==> val resultingDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[LocalVariableDescriptor]

'isOperator' @ [277:34] ==> public final val FunctionDescriptor.isOperator: Boolean[MyPropertyDescriptor]

'provideDelegateResults' @ [282:29] ==> val provideDelegateResults: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[LocalVariableDescriptor]

'resultingCall' @ [282:52] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<FunctionDescriptor>.resultingCall: ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'trace' @ [283:9] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[ValueParameterDescriptorImpl]

'record' @ [283:15] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>..WritableSlice<(VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>?), key: (VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?), value: (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> VariableDescriptorWithAccessors
    <V : (Any..Any?)> -> ResolvedCall<(org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)>

'PROVIDE_DELEGATE_RESOLVED_CALL' @ [283:22] ==> public final val PROVIDE_DELEGATE_RESOLVED_CALL: (WritableSlice<(VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>..WritableSlice<(VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'propertyDescriptor' @ [283:54] ==> value-parameter propertyDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[ValueParameterDescriptorImpl]

'resultingCall' @ [283:74] ==> val resultingCall: ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveProvideDelegateMethod[LocalVariableDescriptor]

'makeScopeForDelegateConventionFunctions' @ [297:49] ==> @NotNull public open fun makeScopeForDelegateConventionFunctions(@NotNull p0: LexicalScope, @NotNull p1: VariableDescriptorWithAccessors): LexicalScope defined in org.jetbrains.kotlin.resolve.scopes.ScopeUtils[JavaMethodDescriptor]

'scopeForDelegate' @ [297:89] ==> value-parameter scopeForDelegate: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'propertyDescriptor' @ [297:107] ==> value-parameter propertyDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'?:' @ [299:24] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: VariableAccessorDescriptor?, right: VariableAccessorDescriptor): VariableAccessorDescriptor[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> VariableAccessorDescriptor

'if (isGet) propertyDescriptor.getter else propertyDescriptor.setter' @ [299:25] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: VariableAccessorDescriptor?, elseBranch: VariableAccessorDescriptor?): VariableAccessorDescriptor?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> VariableAccessorDescriptor?

'isGet' @ [299:29] ==> value-parameter isGet: Boolean defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'propertyDescriptor' @ [299:36] ==> value-parameter propertyDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'getter' @ [299:55] ==> public abstract val getter: VariableAccessorDescriptor? defined in org.jetbrains.kotlin.descriptors.VariableDescriptorWithAccessors[DeserializedPropertyDescriptor]

'propertyDescriptor' @ [299:67] ==> value-parameter propertyDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'setter' @ [299:86] ==> public abstract val setter: VariableAccessorDescriptor? defined in org.jetbrains.kotlin.descriptors.VariableDescriptorWithAccessors[DeserializedPropertyDescriptor]

'AssertionError' @ [300:33] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'propertyDescriptor' @ [300:95] ==> value-parameter propertyDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'delegateExpression' @ [300:116] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'text' @ [300:135] ==> public final val KtExpression.text: (String..String?)[MyPropertyDescriptor]

'if (isComplete && isGet && propertyDescriptor.type !is DeferredType)
            propertyDescriptor.type
        else
            TypeUtils.NO_EXPECTED_TYPE' @ [302:28] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType, elseBranch: KotlinType): KotlinType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType

'isComplete' @ [302:32] ==> value-parameter isComplete: Boolean defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'isGet' @ [302:46] ==> value-parameter isGet: Boolean defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'propertyDescriptor' @ [302:55] ==> value-parameter propertyDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'type' @ [302:74] ==> public final val VariableDescriptorWithAccessors.type: KotlinType[MyPropertyDescriptor]

'propertyDescriptor' @ [303:13] ==> value-parameter propertyDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'type' @ [303:32] ==> public final val VariableDescriptorWithAccessors.type: KotlinType[MyPropertyDescriptor]

'NO_EXPECTED_TYPE' @ [305:23] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'newContext' @ [307:47] ==> @NotNull public open fun newContext(@NotNull trace: BindingTrace, @NotNull scope: LexicalScope, @NotNull dataFlowInfo: DataFlowInfo, @NotNull expectedType: KotlinType): ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaMethodDescriptor]

'trace' @ [307:58] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'delegateFunctionsScope' @ [307:65] ==> val delegateFunctionsScope: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[LocalVariableDescriptor]

'dataFlowInfo' @ [307:89] ==> value-parameter dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'expectedType' @ [307:103] ==> val expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[LocalVariableDescriptor]

'propertyDescriptor' @ [309:23] ==> value-parameter propertyDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'extensionReceiverParameter' @ [309:42] ==> public final val VariableDescriptorWithAccessors.extensionReceiverParameter: ReceiverParameterDescriptor?[MyPropertyDescriptor]

'propertyDescriptor' @ [309:80] ==> value-parameter propertyDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'dispatchReceiverParameter' @ [309:99] ==> public final val VariableDescriptorWithAccessors.dispatchReceiverParameter: ReceiverParameterDescriptor?[MyPropertyDescriptor]

'newArrayList' @ [311:31] ==> @GwtCompatible public open fun <E : (Any..Any?)> newArrayList(): (ArrayList<(KtExpression..KtExpression?)>..ArrayList<(KtExpression..KtExpression?)>?) defined in com.google.common.collect.Lists[JavaMethodDescriptor]
Inferred types:
    <E : (Any..Any?)> -> KtExpression

'KtPsiFactory' @ [312:26] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi in file KtPsiFactory.kt[SimpleFunctionDescriptorImpl]

'delegateExpression' @ [312:39] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'arguments' @ [313:9] ==> val arguments: (ArrayList<(KtExpression..KtExpression?)>..ArrayList<(KtExpression..KtExpression?)>?) defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[LocalVariableDescriptor]

'add' @ [313:19] ==> public open fun add(element: (KtExpression..KtExpression?)): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'psiFactory' @ [313:23] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[LocalVariableDescriptor]

'createExpression' @ [313:34] ==> public final fun createExpression(text: String): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[SimpleFunctionDescriptorImpl]

'if (hasThis) "this" else "null"' @ [313:51] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'hasThis' @ [313:55] ==> val hasThis: Boolean defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[LocalVariableDescriptor]

'arguments' @ [314:9] ==> val arguments: (ArrayList<(KtExpression..KtExpression?)>..ArrayList<(KtExpression..KtExpression?)>?) defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[LocalVariableDescriptor]

'add' @ [314:19] ==> public open fun add(element: (KtExpression..KtExpression?)): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'psiFactory' @ [314:23] ==> val psiFactory: KtPsiFactory defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[LocalVariableDescriptor]

'createExpressionForProperty' @ [314:34] ==> private final fun KtPsiFactory.createExpressionForProperty(): KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'!' @ [316:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isGet' @ [316:14] ==> value-parameter isGet: Boolean defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'createFakeExpressionOfType' @ [317:32] ==> public open fun createFakeExpressionOfType(@NotNull project: Project, @NotNull trace: BindingTrace, @NotNull argumentName: String, @NotNull argumentType: KotlinType): (KtExpression..KtExpression?) defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingUtils[JavaMethodDescriptor]

'delegateExpression' @ [317:59] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'project' @ [317:78] ==> public final val KtExpression.project: Project[MyPropertyDescriptor]

'trace' @ [317:87] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'arguments' @ [318:74] ==> val arguments: (ArrayList<(KtExpression..KtExpression?)>..ArrayList<(KtExpression..KtExpression?)>?) defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[LocalVariableDescriptor]

'size' @ [318:84] ==> public open val size: Int defined in java.util.ArrayList[JavaPropertyDescriptor]

'propertyDescriptor' @ [319:59] ==> value-parameter propertyDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'type' @ [319:78] ==> public final val VariableDescriptorWithAccessors.type: KotlinType[MyPropertyDescriptor]

'arguments' @ [320:13] ==> val arguments: (ArrayList<(KtExpression..KtExpression?)>..ArrayList<(KtExpression..KtExpression?)>?) defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[LocalVariableDescriptor]

'add' @ [320:23] ==> public open fun add(element: (KtExpression..KtExpression?)): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'fakeArgument' @ [320:27] ==> val fakeArgument: KtReferenceExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[LocalVariableDescriptor]

'accessor' @ [321:35] ==> val accessor: VariableAccessorDescriptor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[LocalVariableDescriptor]

'valueParameters' @ [321:44] ==> public final val VariableAccessorDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'trace' @ [322:13] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'record' @ [322:19] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?), key: (KtReferenceExpression..KtReferenceExpression?), value: (DeclarationDescriptor..DeclarationDescriptor?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> KtReferenceExpression
    <V : (Any..Any?)> -> DeclarationDescriptor

'REFERENCE_TARGET' @ [322:26] ==> public final val REFERENCE_TARGET: (WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'fakeArgument' @ [322:44] ==> val fakeArgument: KtReferenceExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[LocalVariableDescriptor]

'valueParameters' @ [322:58] ==> val valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>) defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[LocalVariableDescriptor]

'if (isGet) OperatorNameConventions.GET_VALUE else OperatorNameConventions.SET_VALUE' @ [325:28] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Name, elseBranch: Name): Name[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Name

'isGet' @ [325:32] ==> value-parameter isGet: Boolean defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'OperatorNameConventions' @ [325:39] ==> public object OperatorNameConventions defined in org.jetbrains.kotlin.util[FakeCallableDescriptorForObject]

'GET_VALUE' @ [325:63] ==> @field:JvmField public final val GET_VALUE: Name defined in org.jetbrains.kotlin.util.OperatorNameConventions[DeserializedPropertyDescriptor]

'OperatorNameConventions' @ [325:78] ==> public object OperatorNameConventions defined in org.jetbrains.kotlin.util[FakeCallableDescriptorForObject]

'SET_VALUE' @ [325:102] ==> @field:JvmField public final val SET_VALUE: Name defined in org.jetbrains.kotlin.util.OperatorNameConventions[DeserializedPropertyDescriptor]

'ExpressionReceiver' @ [326:24] ==> public companion object defined in org.jetbrains.kotlin.resolve.scopes.receivers.ExpressionReceiver[FakeCallableDescriptorForObject]

'create' @ [326:43] ==> public final fun create(expression: KtExpression, type: KotlinType, bindingContext: BindingContext): ExpressionReceiver defined in org.jetbrains.kotlin.resolve.scopes.receivers.ExpressionReceiver.Companion[SimpleFunctionDescriptorImpl]

'delegateExpression' @ [326:50] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'delegateType' @ [326:70] ==> value-parameter delegateType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'trace' @ [326:84] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'bindingContext' @ [326:90] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'fakeCallResolver' @ [328:32] ==> private final val fakeCallResolver: FakeCallResolver defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[PropertyDescriptorImpl]

'makeAndResolveFakeCallInContext' @ [328:49] ==> @JvmOverloads public final fun makeAndResolveFakeCallInContext(receiver: ReceiverValue?, context: ResolutionContext<*>, valueArguments: List<KtExpression>, name: Name, callElement: KtExpression, onComplete: (KtSimpleNameExpression, Boolean) -> Unit = ...): Pair<Call, OverloadResolutionResults<FunctionDescriptor>> defined in org.jetbrains.kotlin.types.expressions.FakeCallResolver[SimpleFunctionDescriptorImpl]

'receiver' @ [328:81] ==> val receiver: ExpressionReceiver defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[LocalVariableDescriptor]

'context' @ [328:91] ==> val context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[LocalVariableDescriptor]

'arguments' @ [328:100] ==> val arguments: (ArrayList<(KtExpression..KtExpression?)>..ArrayList<(KtExpression..KtExpression?)>?) defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[LocalVariableDescriptor]

'functionName' @ [328:111] ==> val functionName: Name defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[LocalVariableDescriptor]

'delegateExpression' @ [328:125] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'trace' @ [330:9] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[ValueParameterDescriptorImpl]

'record' @ [330:15] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (Call..Call?)>..WritableSlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (Call..Call?)>?), key: (VariableAccessorDescriptor..VariableAccessorDescriptor?), value: (Call..Call?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> VariableAccessorDescriptor
    <V : (Any..Any?)> -> Call

'DELEGATED_PROPERTY_CALL' @ [330:37] ==> public final val DELEGATED_PROPERTY_CALL: (WritableSlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (Call..Call?)>..WritableSlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (Call..Call?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'accessor' @ [330:62] ==> val accessor: VariableAccessorDescriptor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[LocalVariableDescriptor]

'resolutionResult' @ [330:72] ==> val resolutionResult: Pair<Call, OverloadResolutionResults<FunctionDescriptor>> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[LocalVariableDescriptor]

'first' @ [330:89] ==> public final val first: Call defined in kotlin.Pair[DeserializedPropertyDescriptor]

'resolutionResult' @ [331:16] ==> val resolutionResult: Pair<Call, OverloadResolutionResults<FunctionDescriptor>> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getGetSetValueMethod[LocalVariableDescriptor]

'second' @ [331:33] ==> public final val second: OverloadResolutionResults<FunctionDescriptor> defined in kotlin.Pair[DeserializedPropertyDescriptor]

'newContext' @ [342:47] ==> @NotNull public open fun newContext(@NotNull trace: BindingTrace, @NotNull scope: LexicalScope, @NotNull dataFlowInfo: DataFlowInfo, @NotNull expectedType: KotlinType): ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaMethodDescriptor]

'trace' @ [342:58] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[ValueParameterDescriptorImpl]

'initializerScope' @ [342:65] ==> value-parameter initializerScope: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [342:83] ==> value-parameter dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[ValueParameterDescriptorImpl]

'NO_EXPECTED_TYPE' @ [342:97] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'getProvideDelegateMethod' @ [343:16] ==> private final fun getProvideDelegateMethod(propertyDescriptor: VariableDescriptorWithAccessors, delegateExpression: KtExpression, delegateExpressionType: KotlinType, context: ExpressionTypingContext): OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'propertyDescriptor' @ [343:41] ==> value-parameter propertyDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[ValueParameterDescriptorImpl]

'delegateExpression' @ [343:61] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[ValueParameterDescriptorImpl]

'delegateExpressionType' @ [343:81] ==> value-parameter delegateExpressionType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[ValueParameterDescriptorImpl]

'context' @ [343:105] ==> val context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[LocalVariableDescriptor]

'propertyDescriptor' @ [352:35] ==> value-parameter propertyDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[ValueParameterDescriptorImpl]

'dispatchReceiverParameter' @ [352:54] ==> public final val VariableDescriptorWithAccessors.dispatchReceiverParameter: ReceiverParameterDescriptor?[MyPropertyDescriptor]

'KtPsiFactory' @ [353:25] ==> @JvmOverloads public fun KtPsiFactory(elementForProject: PsiElement, markGenerated: Boolean = ...): KtPsiFactory defined in org.jetbrains.kotlin.psi in file KtPsiFactory.kt[SimpleFunctionDescriptorImpl]

'delegateExpression' @ [353:38] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[ValueParameterDescriptorImpl]

'run' @ [353:81] ==> @InlineOnly public inline fun <T, R> KtPsiFactory.run(block: KtPsiFactory.() -> List<KtExpression>): List<KtExpression> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtPsiFactory
    <R> -> List<KtExpression>

'listOf' @ [354:13] ==> public fun <T> listOf(vararg elements: KtExpression): List<KtExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'createExpression' @ [355:21] ==> public final fun createExpression(text: String): KtExpression defined in org.jetbrains.kotlin.psi.KtPsiFactory[SimpleFunctionDescriptorImpl]

'if (propertyHasReceiver) "this" else "null"' @ [355:38] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'propertyHasReceiver' @ [355:42] ==> val propertyHasReceiver: Boolean defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[LocalVariableDescriptor]

'createExpressionForProperty' @ [356:21] ==> private final fun KtPsiFactory.createExpressionForProperty(): KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'OperatorNameConventions' @ [359:28] ==> public object OperatorNameConventions defined in org.jetbrains.kotlin.util[FakeCallableDescriptorForObject]

'PROVIDE_DELEGATE' @ [359:52] ==> @field:JvmField public final val PROVIDE_DELEGATE: Name defined in org.jetbrains.kotlin.util.OperatorNameConventions[DeserializedPropertyDescriptor]

'ExpressionReceiver' @ [360:24] ==> public companion object defined in org.jetbrains.kotlin.resolve.scopes.receivers.ExpressionReceiver[FakeCallableDescriptorForObject]

'create' @ [360:43] ==> public final fun create(expression: KtExpression, type: KotlinType, bindingContext: BindingContext): ExpressionReceiver defined in org.jetbrains.kotlin.resolve.scopes.receivers.ExpressionReceiver.Companion[SimpleFunctionDescriptorImpl]

'delegateExpression' @ [360:50] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[ValueParameterDescriptorImpl]

'delegateExpressionType' @ [360:70] ==> value-parameter delegateExpressionType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[ValueParameterDescriptorImpl]

'context' @ [360:94] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[ValueParameterDescriptorImpl]

'trace' @ [360:102] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'bindingContext' @ [360:108] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'component1' @ [362:14] ==> public final operator fun component1(): Call defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [362:35] ==> public final operator fun component2(): OverloadResolutionResults<FunctionDescriptor> defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'fakeCallResolver' @ [363:17] ==> private final val fakeCallResolver: FakeCallResolver defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[PropertyDescriptorImpl]

'makeAndResolveFakeCallInContext' @ [363:34] ==> @JvmOverloads public final fun makeAndResolveFakeCallInContext(receiver: ReceiverValue?, context: ResolutionContext<*>, valueArguments: List<KtExpression>, name: Name, callElement: KtExpression, onComplete: (KtSimpleNameExpression, Boolean) -> Unit = ...): Pair<Call, OverloadResolutionResults<FunctionDescriptor>> defined in org.jetbrains.kotlin.types.expressions.FakeCallResolver[SimpleFunctionDescriptorImpl]

'receiver' @ [363:66] ==> val receiver: ExpressionReceiver defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[LocalVariableDescriptor]

'context' @ [363:76] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[ValueParameterDescriptorImpl]

'arguments' @ [363:85] ==> val arguments: List<KtExpression> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[LocalVariableDescriptor]

'functionName' @ [363:96] ==> val functionName: Name defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[LocalVariableDescriptor]

'delegateExpression' @ [363:110] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[ValueParameterDescriptorImpl]

'provideDelegateResults' @ [365:13] ==> val provideDelegateResults: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[LocalVariableDescriptor]

'isSingleResult' @ [365:36] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<FunctionDescriptor>.isSingleResult: Boolean[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'context' @ [366:13] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[ValueParameterDescriptorImpl]

'trace' @ [366:21] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'record' @ [366:27] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(KtExpression..KtExpression?), (Call..Call?)>..WritableSlice<(KtExpression..KtExpression?), (Call..Call?)>?), key: (KtExpression..KtExpression?), value: (Call..Call?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> KtExpression
    <V : (Any..Any?)> -> Call

'DELEGATE_EXPRESSION_TO_PROVIDE_DELEGATE_CALL' @ [366:49] ==> public final val DELEGATE_EXPRESSION_TO_PROVIDE_DELEGATE_CALL: (WritableSlice<(KtExpression..KtExpression?), (Call..Call?)>..WritableSlice<(KtExpression..KtExpression?), (Call..Call?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'delegateExpression' @ [366:95] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[ValueParameterDescriptorImpl]

'provideDelegateCall' @ [366:115] ==> val provideDelegateCall: Call defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[LocalVariableDescriptor]

'context' @ [368:9] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[ValueParameterDescriptorImpl]

'trace' @ [368:17] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'record' @ [368:23] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?), (Call..Call?)>..WritableSlice<(VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?), (Call..Call?)>?), key: (VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?), value: (Call..Call?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> VariableDescriptorWithAccessors
    <V : (Any..Any?)> -> Call

'PROVIDE_DELEGATE_CALL' @ [368:45] ==> public final val PROVIDE_DELEGATE_CALL: (WritableSlice<(VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?), (Call..Call?)>..WritableSlice<(VariableDescriptorWithAccessors..VariableDescriptorWithAccessors?), (Call..Call?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'propertyDescriptor' @ [368:68] ==> value-parameter propertyDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[ValueParameterDescriptorImpl]

'provideDelegateCall' @ [368:88] ==> val provideDelegateCall: Call defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[LocalVariableDescriptor]

'provideDelegateResults' @ [370:16] ==> val provideDelegateResults: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.getProvideDelegateMethod[LocalVariableDescriptor]

'call' @ [375:32] ==> value-parameter call: Call defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.renderCall[ValueParameterDescriptorImpl]

'calleeExpression' @ [375:37] ==> public final val Call.calleeExpression: KtExpression?[MyPropertyDescriptor]

'AssertionError' @ [376:41] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'call' @ [378:16] ==> value-parameter call: Call defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.renderCall[ValueParameterDescriptorImpl]

'valueArguments' @ [378:21] ==> public final val Call.valueArguments: List<(ValueArgument..ValueArgument?)>[MyPropertyDescriptor]

'joinToString' @ [378:36] ==> public fun <T> Iterable<(ValueArgument..ValueArgument?)>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: (((ValueArgument..ValueArgument?)) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)

'calleeExpression' @ [379:29] ==> val calleeExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.renderCall[LocalVariableDescriptor]

'text' @ [379:46] ==> public final val KtExpression.text: (String..String?)[MyPropertyDescriptor]

'context' @ [383:32] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.renderCall[ValueParameterDescriptorImpl]

'getType' @ [383:40] ==> @Nullable public abstract fun getType(@NotNull expression: KtExpression): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]

'argument' @ [383:48] ==> value-parameter argument: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.renderCall.<anonymous>[ValueParameterDescriptorImpl]

'getArgumentExpression' @ [383:57] ==> @IfNotParsed public abstract fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.ValueArgument[SimpleFunctionDescriptorImpl]

'DescriptorRenderer' @ [384:21] ==> public companion object defined in org.jetbrains.kotlin.renderer.DescriptorRenderer[FakeCallableDescriptorForObject]

'SHORT_NAMES_IN_TYPES' @ [384:40] ==> @field:JvmField public final val SHORT_NAMES_IN_TYPES: DescriptorRenderer defined in org.jetbrains.kotlin.renderer.DescriptorRenderer.Companion[DeserializedPropertyDescriptor]

'renderType' @ [384:61] ==> public abstract fun renderType(type: KotlinType): String defined in org.jetbrains.kotlin.renderer.DescriptorRenderer[DeserializedSimpleFunctionDescriptor]

'type' @ [384:72] ==> val type: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.renderCall.<anonymous>[LocalVariableDescriptor]

'create' @ [397:69] ==> @NotNull public open fun create(@NotNull trace: BindingTrace, debugName: (String..String?)): TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.TemporaryBindingTrace[JavaMethodDescriptor]

'trace' @ [397:76] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[ValueParameterDescriptorImpl]

'if (property.typeReference != null) variableDescriptor.type else NO_EXPECTED_TYPE' @ [399:36] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType, elseBranch: KotlinType): KotlinType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType

'property' @ [399:40] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[ValueParameterDescriptorImpl]

'typeReference' @ [399:49] ==> public final var KtProperty.typeReference: KtTypeReference?[MyPropertyDescriptor]

'variableDescriptor' @ [399:72] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[ValueParameterDescriptorImpl]

'type' @ [399:91] ==> public final val VariableDescriptorWithAccessors.type: KotlinType[MyPropertyDescriptor]

'NO_EXPECTED_TYPE' @ [399:101] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'ConstraintSystemCompleterImpl' @ [400:25] ==> public constructor ConstraintSystemCompleterImpl(property: KtProperty, expectedType: KotlinType, variableDescriptor: VariableDescriptorWithAccessors, delegateExpression: KtExpression, scopeForDelegate: LexicalScope, trace: BindingTrace, dataFlowInfo: DataFlowInfo) defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[ClassConstructorDescriptorImpl]

'property' @ [400:55] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[ValueParameterDescriptorImpl]

'propertyExpectedType' @ [400:65] ==> val propertyExpectedType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[LocalVariableDescriptor]

'variableDescriptor' @ [400:87] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[ValueParameterDescriptorImpl]

'delegateExpression' @ [400:107] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[ValueParameterDescriptorImpl]

'scopeForDelegate' @ [400:127] ==> value-parameter scopeForDelegate: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[ValueParameterDescriptorImpl]

'trace' @ [400:145] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [400:152] ==> value-parameter dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[ValueParameterDescriptorImpl]

'delegateExpression' @ [402:9] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[ValueParameterDescriptorImpl]

'getCalleeExpressionIfAny' @ [402:28] ==> public fun KtElement?.getCalleeExpressionIfAny(): KtExpression? defined in org.jetbrains.kotlin.resolve.calls.callUtil in file callUtil.kt[SimpleFunctionDescriptorImpl]

'let' @ [402:56] ==> @InlineOnly public inline fun <T, R> KtExpression.let(block: (KtExpression) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression
    <R> -> Unit

'traceToResolveDelegatedProperty' @ [403:13] ==> val traceToResolveDelegatedProperty: TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[LocalVariableDescriptor]

'record' @ [403:45] ==> public open fun <K, V> record(slice: WritableSlice<(KtElement..KtElement?), (ConstraintSystemCompleter..ConstraintSystemCompleter?)>, key: (KtElement..KtElement?), value: (ConstraintSystemCompleter..ConstraintSystemCompleter?)): Unit defined in org.jetbrains.kotlin.resolve.TemporaryBindingTrace[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> (org.jetbrains.kotlin.psi.KtElement..org.jetbrains.kotlin.psi.KtElement?)
    <V> -> (org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemCompleter..org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemCompleter?)

'CONSTRAINT_SYSTEM_COMPLETER' @ [403:52] ==> public final val CONSTRAINT_SYSTEM_COMPLETER: (WritableSlice<(KtElement..KtElement?), (ConstraintSystemCompleter..ConstraintSystemCompleter?)>..WritableSlice<(KtElement..KtElement?), (ConstraintSystemCompleter..ConstraintSystemCompleter?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'it' @ [403:81] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression.<anonymous>[ValueParameterDescriptorImpl]

'completer' @ [403:85] ==> val completer: DelegatedPropertyResolver.ConstraintSystemCompleterImpl defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[LocalVariableDescriptor]

'completer' @ [406:42] ==> val completer: DelegatedPropertyResolver.ConstraintSystemCompleterImpl defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[LocalVariableDescriptor]

'resolveViaNewInference' @ [406:52] ==> public final fun resolveViaNewInference(delegateExpression: KtExpression, variableDescriptor: VariableDescriptorWithAccessors, scopeForDelegate: LexicalScope, trace: BindingTrace, dataFlowInfo: DataFlowInfo): KotlinType? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[SimpleFunctionDescriptorImpl]

'delegateExpression' @ [406:75] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[ValueParameterDescriptorImpl]

'variableDescriptor' @ [406:95] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[ValueParameterDescriptorImpl]

'scopeForDelegate' @ [406:115] ==> value-parameter scopeForDelegate: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[ValueParameterDescriptorImpl]

'trace' @ [406:133] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [406:140] ==> value-parameter dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[ValueParameterDescriptorImpl]

'expressionTypingServices' @ [407:28] ==> private final val expressionTypingServices: ExpressionTypingServices defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[PropertyDescriptorImpl]

'safeGetType' @ [407:53] ==> @NotNull public open fun safeGetType(@NotNull scope: LexicalScope, @NotNull expression: KtExpression, @NotNull expectedType: KotlinType, @NotNull dataFlowInfo: DataFlowInfo, @NotNull trace: BindingTrace): KotlinType defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingServices[JavaMethodDescriptor]

'scopeForDelegate' @ [407:65] ==> value-parameter scopeForDelegate: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[ValueParameterDescriptorImpl]

'delegateExpression' @ [407:83] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[ValueParameterDescriptorImpl]

'expectedTypeByNewInference' @ [407:103] ==> val expectedTypeByNewInference: KotlinType? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[LocalVariableDescriptor]

'NO_EXPECTED_TYPE' @ [407:133] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'dataFlowInfo' @ [407:151] ==> value-parameter dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[ValueParameterDescriptorImpl]

'traceToResolveDelegatedProperty' @ [407:165] ==> val traceToResolveDelegatedProperty: TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[LocalVariableDescriptor]

'traceToResolveDelegatedProperty' @ [409:9] ==> val traceToResolveDelegatedProperty: TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[LocalVariableDescriptor]

'commit' @ [409:41] ==> public final fun commit(@NotNull filter: (slice: WritableSlice<*, *>?, key: (Any..Any?)) -> Boolean, commitDiagnostics: Boolean): Unit defined in org.jetbrains.kotlin.resolve.TemporaryBindingTrace[MyFunctionDescriptor]

'slice' @ [409:62] ==> value-parameter slice: WritableSlice<*, *>? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression.<anonymous>[ValueParameterDescriptorImpl]

'CONSTRAINT_SYSTEM_COMPLETER' @ [409:72] ==> public final val CONSTRAINT_SYSTEM_COMPLETER: (WritableSlice<(KtElement..KtElement?), (ConstraintSystemCompleter..ConstraintSystemCompleter?)>..WritableSlice<(KtElement..KtElement?), (ConstraintSystemCompleter..ConstraintSystemCompleter?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'delegateType' @ [411:16] ==> val delegateType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.resolveDelegateExpression[LocalVariableDescriptor]

'resolvedCall' @ [424:30] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[ValueParameterDescriptorImpl]

'candidateDescriptor' @ [424:43] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.candidateDescriptor: (CallableDescriptor..CallableDescriptor?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'returnType' @ [424:63] ==> public final val CallableDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'constraintSystem' @ [426:43] ==> value-parameter constraintSystem: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[ValueParameterDescriptorImpl]

'typeVariableSubstitutors' @ [426:60] ==> public abstract val typeVariableSubstitutors: Map<CallHandle, TypeSubstitutor> defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem.Builder[PropertyDescriptorImpl]

'resolvedCall' @ [426:85] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[ValueParameterDescriptorImpl]

'call' @ [426:98] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'toHandle' @ [426:103] ==> public fun Call.toHandle(): CallHandle defined in org.jetbrains.kotlin.resolve.calls.inference in file TypeVariable.kt[SimpleFunctionDescriptorImpl]

'AssertionError' @ [427:52] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'+' @ [427:67] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'resolvedCall' @ [427:111] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[ValueParameterDescriptorImpl]

'call' @ [427:124] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'create' @ [429:73] ==> @NotNull public open fun create(@NotNull trace: BindingTrace, debugName: (String..String?)): TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.TemporaryBindingTrace[JavaMethodDescriptor]

'trace' @ [429:80] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[PropertyDescriptorImpl]

'getDelegateType' @ [431:32] ==> private final fun getDelegateType(byExpressionType: KotlinType, constraintSystem: ConstraintSystem.Builder, typeVariableSubstitutor: TypeSubstitutor, traceToResolveConventionMethods: TemporaryBindingTrace): KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[SimpleFunctionDescriptorImpl]

'returnType' @ [431:48] ==> val returnType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'constraintSystem' @ [431:60] ==> value-parameter constraintSystem: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[ValueParameterDescriptorImpl]

'typeVariableSubstitutor' @ [431:78] ==> val typeVariableSubstitutor: TypeSubstitutor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'traceToResolveConventionMethods' @ [431:103] ==> val traceToResolveConventionMethods: TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'getGetSetValueMethod' @ [433:35] ==> private final fun getGetSetValueMethod(propertyDescriptor: VariableDescriptorWithAccessors, delegateExpression: KtExpression, delegateType: KotlinType, trace: BindingTrace, scopeForDelegate: LexicalScope, dataFlowInfo: DataFlowInfo, isGet: Boolean, isComplete: Boolean): OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'variableDescriptor' @ [434:21] ==> public final val variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[PropertyDescriptorImpl]

'delegateExpression' @ [434:41] ==> public final val delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[PropertyDescriptorImpl]

'delegateType' @ [434:61] ==> val delegateType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'traceToResolveConventionMethods' @ [434:75] ==> val traceToResolveConventionMethods: TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'scopeForDelegate' @ [434:108] ==> public final val scopeForDelegate: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[PropertyDescriptorImpl]

'dataFlowInfo' @ [434:126] ==> public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[PropertyDescriptorImpl]

'conventionMethodFound' @ [437:17] ==> private final fun conventionMethodFound(results: OverloadResolutionResults<FunctionDescriptor>): Boolean defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[SimpleFunctionDescriptorImpl]

'getValueResults' @ [437:39] ==> val getValueResults: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'getValueResults' @ [438:42] ==> val getValueResults: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'resultingDescriptor' @ [438:58] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<FunctionDescriptor>.resultingDescriptor: FunctionDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'getValueDescriptor' @ [439:42] ==> val getValueDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'returnType' @ [439:61] ==> public final val FunctionDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'getValueReturnType' @ [440:21] ==> val getValueReturnType: KotlinType? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'!' @ [440:51] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'noExpectedType' @ [440:62] ==> public open fun noExpectedType(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'expectedType' @ [440:77] ==> public final val expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[PropertyDescriptorImpl]

'typeVariableSubstitutor' @ [441:46] ==> val typeVariableSubstitutor: TypeSubstitutor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'substitute' @ [441:70] ==> @Nullable public open fun substitute(@NotNull p0: KotlinType, @NotNull p1: Variance): KotlinType? defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'getValueReturnType' @ [441:81] ==> val getValueReturnType: KotlinType? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'INVARIANT' @ [441:110] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'returnTypeInSystem' @ [442:25] ==> val returnTypeInSystem: KotlinType? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'constraintSystem' @ [443:25] ==> value-parameter constraintSystem: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[ValueParameterDescriptorImpl]

'addSubtypeConstraint' @ [443:42] ==> public abstract fun addSubtypeConstraint(constrainingType: KotlinType?, subjectType: KotlinType?, constraintPosition: ConstraintPosition): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem.Builder[SimpleFunctionDescriptorImpl]

'returnTypeInSystem' @ [443:63] ==> val returnTypeInSystem: KotlinType? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'expectedType' @ [443:83] ==> public final val expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[PropertyDescriptorImpl]

'FROM_COMPLETER' @ [443:97] ==> enum entry FROM_COMPLETER defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPositionKind[FakeCallableDescriptorForObject]

'position' @ [443:112] ==> public final fun position(): ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPositionKind[SimpleFunctionDescriptorImpl]

'addConstraintForThisValue' @ [446:17] ==> private final fun addConstraintForThisValue(constraintSystem: ConstraintSystem.Builder, typeVariableSubstitutor: TypeSubstitutor, resultingDescriptor: FunctionDescriptor, dispatchReceiverOnly: Boolean = ...): Unit defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[SimpleFunctionDescriptorImpl]

'constraintSystem' @ [446:43] ==> value-parameter constraintSystem: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[ValueParameterDescriptorImpl]

'typeVariableSubstitutor' @ [446:61] ==> val typeVariableSubstitutor: TypeSubstitutor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'getValueDescriptor' @ [446:86] ==> val getValueDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'!' @ [448:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'variableDescriptor' @ [448:18] ==> public final val variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[PropertyDescriptorImpl]

'isVar' @ [448:37] ==> public final val VariableDescriptorWithAccessors.isVar: Boolean[MyPropertyDescriptor]

'variableDescriptor' @ [453:17] ==> public final val variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[PropertyDescriptorImpl]

'returnType' @ [453:36] ==> public final val VariableDescriptorWithAccessors.returnType: KotlinType?[MyPropertyDescriptor]

'getGetSetValueMethod' @ [455:35] ==> private final fun getGetSetValueMethod(propertyDescriptor: VariableDescriptorWithAccessors, delegateExpression: KtExpression, delegateType: KotlinType, trace: BindingTrace, scopeForDelegate: LexicalScope, dataFlowInfo: DataFlowInfo, isGet: Boolean, isComplete: Boolean): OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'variableDescriptor' @ [456:21] ==> public final val variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[PropertyDescriptorImpl]

'delegateExpression' @ [456:41] ==> public final val delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[PropertyDescriptorImpl]

'delegateType' @ [456:61] ==> val delegateType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'traceToResolveConventionMethods' @ [456:75] ==> val traceToResolveConventionMethods: TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'scopeForDelegate' @ [456:108] ==> public final val scopeForDelegate: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[PropertyDescriptorImpl]

'dataFlowInfo' @ [456:126] ==> public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[PropertyDescriptorImpl]

'conventionMethodFound' @ [459:17] ==> private final fun conventionMethodFound(results: OverloadResolutionResults<FunctionDescriptor>): Boolean defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[SimpleFunctionDescriptorImpl]

'setValueResults' @ [459:39] ==> val setValueResults: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'setValueResults' @ [460:42] ==> val setValueResults: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'resultingDescriptor' @ [460:58] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<FunctionDescriptor>.resultingDescriptor: FunctionDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'setValueDescriptor' @ [461:42] ==> val setValueDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'valueParameters' @ [461:61] ==> public final val FunctionDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'setValueParameters' @ [462:21] ==> val setValueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>) defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'size' @ [462:40] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'!' @ [463:25] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'noExpectedType' @ [463:26] ==> public open fun noExpectedType(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'expectedType' @ [463:41] ==> public final val expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[PropertyDescriptorImpl]

'setValueParameters' @ [464:49] ==> val setValueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>) defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'type' @ [464:71] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'typeVariableSubstitutor' @ [465:60] ==> val typeVariableSubstitutor: TypeSubstitutor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'substitute' @ [465:84] ==> @Nullable public open fun substitute(@NotNull p0: KotlinType, @NotNull p1: Variance): KotlinType? defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'thisParameterType' @ [465:95] ==> val thisParameterType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'INVARIANT' @ [465:123] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'constraintSystem' @ [466:25] ==> value-parameter constraintSystem: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[ValueParameterDescriptorImpl]

'addSubtypeConstraint' @ [466:42] ==> public abstract fun addSubtypeConstraint(constrainingType: KotlinType?, subjectType: KotlinType?, constraintPosition: ConstraintPosition): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem.Builder[SimpleFunctionDescriptorImpl]

'expectedType' @ [466:63] ==> public final val expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[PropertyDescriptorImpl]

'substitutedThisParameterType' @ [466:77] ==> val substitutedThisParameterType: KotlinType? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'FROM_COMPLETER' @ [466:107] ==> enum entry FROM_COMPLETER defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPositionKind[FakeCallableDescriptorForObject]

'position' @ [466:122] ==> public final fun position(): ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPositionKind[SimpleFunctionDescriptorImpl]

'addConstraintForThisValue' @ [468:21] ==> private final fun addConstraintForThisValue(constraintSystem: ConstraintSystem.Builder, typeVariableSubstitutor: TypeSubstitutor, resultingDescriptor: FunctionDescriptor, dispatchReceiverOnly: Boolean = ...): Unit defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[SimpleFunctionDescriptorImpl]

'constraintSystem' @ [468:47] ==> value-parameter constraintSystem: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[ValueParameterDescriptorImpl]

'typeVariableSubstitutor' @ [468:65] ==> val typeVariableSubstitutor: TypeSubstitutor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'setValueDescriptor' @ [468:90] ==> val setValueDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.completeConstraintSystem[LocalVariableDescriptor]

'isOperatorProvideDelegateSupported' @ [479:17] ==> private final val isOperatorProvideDelegateSupported: Boolean defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[PropertyDescriptorImpl]

'getProvideDelegateMethod' @ [480:46] ==> private final fun getProvideDelegateMethod(propertyDescriptor: VariableDescriptorWithAccessors, delegateExpression: KtExpression, delegateExpressionType: KotlinType, trace: BindingTrace, initializerScope: LexicalScope, dataFlowInfo: DataFlowInfo): OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'variableDescriptor' @ [481:25] ==> public final val variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[PropertyDescriptorImpl]

'delegateExpression' @ [481:45] ==> public final val delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[PropertyDescriptorImpl]

'byExpressionType' @ [481:65] ==> value-parameter byExpressionType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.getDelegateType[ValueParameterDescriptorImpl]

'traceToResolveConventionMethods' @ [482:25] ==> value-parameter traceToResolveConventionMethods: TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.getDelegateType[ValueParameterDescriptorImpl]

'scopeForDelegate' @ [482:58] ==> public final val scopeForDelegate: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[PropertyDescriptorImpl]

'dataFlowInfo' @ [482:76] ==> public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[PropertyDescriptorImpl]

'conventionMethodFound' @ [484:21] ==> private final fun conventionMethodFound(results: OverloadResolutionResults<FunctionDescriptor>): Boolean defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[SimpleFunctionDescriptorImpl]

'provideDelegateResults' @ [484:43] ==> val provideDelegateResults: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.getDelegateType[LocalVariableDescriptor]

'provideDelegateResults' @ [485:53] ==> val provideDelegateResults: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.getDelegateType[LocalVariableDescriptor]

'resultingDescriptor' @ [485:76] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<FunctionDescriptor>.resultingDescriptor: FunctionDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'provideDelegateDescriptor' @ [486:53] ==> val provideDelegateDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.getDelegateType[LocalVariableDescriptor]

'returnType' @ [486:79] ==> public final val FunctionDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'provideDelegateDescriptor' @ [487:25] ==> val provideDelegateDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.getDelegateType[LocalVariableDescriptor]

'isOperator' @ [487:51] ==> public final val FunctionDescriptor.isOperator: Boolean[MyPropertyDescriptor]

'addConstraintForThisValue' @ [488:25] ==> private final fun addConstraintForThisValue(constraintSystem: ConstraintSystem.Builder, typeVariableSubstitutor: TypeSubstitutor, resultingDescriptor: FunctionDescriptor, dispatchReceiverOnly: Boolean = ...): Unit defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[SimpleFunctionDescriptorImpl]

'constraintSystem' @ [488:51] ==> value-parameter constraintSystem: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.getDelegateType[ValueParameterDescriptorImpl]

'typeVariableSubstitutor' @ [488:69] ==> value-parameter typeVariableSubstitutor: TypeSubstitutor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.getDelegateType[ValueParameterDescriptorImpl]

'provideDelegateDescriptor' @ [488:94] ==> val provideDelegateDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.getDelegateType[LocalVariableDescriptor]

'provideDelegateReturnType' @ [490:32] ==> val provideDelegateReturnType: KotlinType? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.getDelegateType[LocalVariableDescriptor]

'AssertionError' @ [491:41] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'delegateExpression' @ [491:100] ==> public final val delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[PropertyDescriptorImpl]

'text' @ [491:119] ==> public final val KtExpression.text: (String..String?)[MyPropertyDescriptor]

'byExpressionType' @ [496:20] ==> value-parameter byExpressionType: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.getDelegateType[ValueParameterDescriptorImpl]

'results' @ [500:17] ==> value-parameter results: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.conventionMethodFound[ValueParameterDescriptorImpl]

'isSuccess' @ [500:25] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<FunctionDescriptor>.isSuccess: Boolean[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'results' @ [501:17] ==> value-parameter results: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.conventionMethodFound[ValueParameterDescriptorImpl]

'isSingleResult' @ [501:25] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<FunctionDescriptor>.isSingleResult: Boolean[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'results' @ [501:43] ==> value-parameter results: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.conventionMethodFound[ValueParameterDescriptorImpl]

'resultCode' @ [501:51] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<FunctionDescriptor>.resultCode: OverloadResolutionResults.Code[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'SINGLE_CANDIDATE_ARGUMENT_MISMATCH' @ [501:96] ==> enum entry SINGLE_CANDIDATE_ARGUMENT_MISMATCH defined in org.jetbrains.kotlin.resolve.calls.results.OverloadResolutionResults.Code[FakeCallableDescriptorForObject]

'variableDescriptor' @ [509:37] ==> public final val variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[PropertyDescriptorImpl]

'extensionReceiverParameter' @ [509:56] ==> public final val VariableDescriptorWithAccessors.extensionReceiverParameter: ReceiverParameterDescriptor?[MyPropertyDescriptor]

'variableDescriptor' @ [510:36] ==> public final val variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[PropertyDescriptorImpl]

'dispatchReceiverParameter' @ [510:55] ==> public final val VariableDescriptorWithAccessors.dispatchReceiverParameter: ReceiverParameterDescriptor?[MyPropertyDescriptor]

'?:' @ [511:30] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KotlinType?, right: KotlinType): KotlinType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KotlinType

'if (dispatchReceiverOnly) dispatchReceiver?.type else (extensionReceiver?.type ?: dispatchReceiver?.type)' @ [511:31] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType?, elseBranch: KotlinType?): KotlinType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType?

'dispatchReceiverOnly' @ [511:35] ==> value-parameter dispatchReceiverOnly: Boolean = ... defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.addConstraintForThisValue[ValueParameterDescriptorImpl]

'dispatchReceiver' @ [511:57] ==> val dispatchReceiver: ReceiverParameterDescriptor? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.addConstraintForThisValue[LocalVariableDescriptor]

'type' @ [511:75] ==> public final val ReceiverParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'extensionReceiver' @ [511:86] ==> val extensionReceiver: ReceiverParameterDescriptor? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.addConstraintForThisValue[LocalVariableDescriptor]

'type' @ [511:105] ==> public final val ReceiverParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'dispatchReceiver' @ [511:113] ==> val dispatchReceiver: ReceiverParameterDescriptor? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.addConstraintForThisValue[LocalVariableDescriptor]

'type' @ [511:131] ==> public final val ReceiverParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'builtIns' @ [512:33] ==> private final val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[PropertyDescriptorImpl]

'nullableNothingType' @ [512:42] ==> public final val KotlinBuiltIns.nullableNothingType: SimpleType[MyPropertyDescriptor]

'resultingDescriptor' @ [514:35] ==> value-parameter resultingDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.addConstraintForThisValue[ValueParameterDescriptorImpl]

'valueParameters' @ [514:55] ==> public final val FunctionDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'valueParameters' @ [515:17] ==> val valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>) defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.addConstraintForThisValue[LocalVariableDescriptor]

'isEmpty' @ [515:33] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'valueParameters' @ [516:41] ==> val valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>) defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.addConstraintForThisValue[LocalVariableDescriptor]

'constraintSystem' @ [518:13] ==> value-parameter constraintSystem: ConstraintSystem.Builder defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.addConstraintForThisValue[ValueParameterDescriptorImpl]

'addSubtypeConstraint' @ [518:30] ==> public abstract fun addSubtypeConstraint(constrainingType: KotlinType?, subjectType: KotlinType?, constraintPosition: ConstraintPosition): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem.Builder[SimpleFunctionDescriptorImpl]

'typeOfThis' @ [519:21] ==> val typeOfThis: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.addConstraintForThisValue[LocalVariableDescriptor]

'typeVariableSubstitutor' @ [520:21] ==> value-parameter typeVariableSubstitutor: TypeSubstitutor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.addConstraintForThisValue[ValueParameterDescriptorImpl]

'substitute' @ [520:45] ==> @Nullable public open fun substitute(@NotNull p0: KotlinType, @NotNull p1: Variance): KotlinType? defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'valueParameterForThis' @ [520:56] ==> val valueParameterForThis: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.addConstraintForThisValue[LocalVariableDescriptor]

'type' @ [520:78] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'INVARIANT' @ [520:93] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'FROM_COMPLETER' @ [521:21] ==> enum entry FROM_COMPLETER defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPositionKind[FakeCallableDescriptorForObject]

'position' @ [521:36] ==> public final fun position(): ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPositionKind[SimpleFunctionDescriptorImpl]

'!' @ [532:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'USE_NEW_INFERENCE' @ [532:18] ==> public val USE_NEW_INFERENCE: Boolean defined in org.jetbrains.kotlin.resolve.calls[DeserializedPropertyDescriptor]

'create' @ [534:73] ==> @NotNull public open fun create(@NotNull trace: BindingTrace, debugName: (String..String?)): TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.TemporaryBindingTrace[JavaMethodDescriptor]

'trace' @ [534:80] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[ValueParameterDescriptorImpl]

'expressionTypingServices' @ [536:32] ==> private final val expressionTypingServices: ExpressionTypingServices defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[PropertyDescriptorImpl]

'getTypeInfo' @ [536:57] ==> @NotNull public open fun getTypeInfo(@NotNull scope: LexicalScope, @NotNull expression: KtExpression, @NotNull expectedType: KotlinType, @NotNull dataFlowInfo: DataFlowInfo, @NotNull trace: BindingTrace, isStatement: Boolean, @NotNull contextExpression: KtExpression, @NotNull contextDependency: ContextDependency): KotlinTypeInfo defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingServices[JavaMethodDescriptor]

'scopeForDelegate' @ [536:69] ==> value-parameter scopeForDelegate: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[ValueParameterDescriptorImpl]

'delegateExpression' @ [536:87] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[ValueParameterDescriptorImpl]

'NO_EXPECTED_TYPE' @ [536:107] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'dataFlowInfo' @ [536:125] ==> value-parameter dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[ValueParameterDescriptorImpl]

'traceToResolveConventionMethods' @ [537:69] ==> val traceToResolveConventionMethods: TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[LocalVariableDescriptor]

'delegateExpression' @ [537:109] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[ValueParameterDescriptorImpl]

'DEPENDENT' @ [537:147] ==> enum entry DEPENDENT defined in org.jetbrains.kotlin.resolve.calls.context.ContextDependency[FakeCallableDescriptorForObject]

'newContext' @ [539:69] ==> @NotNull public open fun newContext(@NotNull trace: BindingTrace, @NotNull scope: LexicalScope, @NotNull dataFlowInfo: DataFlowInfo, @NotNull expectedType: KotlinType, @NotNull contextDependency: ContextDependency, @NotNull statementFilter: StatementFilter): ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaMethodDescriptor]

'traceToResolveConventionMethods' @ [539:80] ==> val traceToResolveConventionMethods: TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[LocalVariableDescriptor]

'scopeForDelegate' @ [539:113] ==> value-parameter scopeForDelegate: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[ValueParameterDescriptorImpl]

'delegateType' @ [539:131] ==> val delegateType: KotlinTypeInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[LocalVariableDescriptor]

'dataFlowInfo' @ [539:144] ==> public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.types.expressions.KotlinTypeInfo[PropertyDescriptorImpl]

'NO_EXPECTED_TYPE' @ [540:80] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'DEPENDENT' @ [540:116] ==> enum entry DEPENDENT defined in org.jetbrains.kotlin.resolve.calls.context.ContextDependency[FakeCallableDescriptorForObject]

'StatementFilter' @ [540:127] ==> public companion object defined in org.jetbrains.kotlin.resolve.StatementFilter[FakeCallableDescriptorForObject]

'NONE' @ [540:143] ==> @JvmField public final val NONE: StatementFilter defined in org.jetbrains.kotlin.resolve.StatementFilter.Companion[PropertyDescriptorImpl]

'getProvideDelegateMethod' @ [542:42] ==> private final fun getProvideDelegateMethod(propertyDescriptor: VariableDescriptorWithAccessors, delegateExpression: KtExpression, delegateExpressionType: KotlinType, context: ExpressionTypingContext): OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'variableDescriptor' @ [543:21] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[ValueParameterDescriptorImpl]

'delegateExpression' @ [543:41] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[ValueParameterDescriptorImpl]

'delegateType' @ [543:61] ==> val delegateType: KotlinTypeInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[LocalVariableDescriptor]

'type' @ [543:74] ==> public final val type: KotlinType? defined in org.jetbrains.kotlin.types.expressions.KotlinTypeInfo[PropertyDescriptorImpl]

'contextForProvideDelegate' @ [543:95] ==> val contextForProvideDelegate: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[LocalVariableDescriptor]

'delegateType' @ [546:47] ==> val delegateType: KotlinTypeInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[LocalVariableDescriptor]

'conventionMethodFound' @ [547:17] ==> private final fun conventionMethodFound(results: OverloadResolutionResults<FunctionDescriptor>): Boolean defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl[SimpleFunctionDescriptorImpl]

'provideDelegateResults' @ [547:39] ==> val provideDelegateResults: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[LocalVariableDescriptor]

'provideDelegateResults' @ [548:49] ==> val provideDelegateResults: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[LocalVariableDescriptor]

'resultingDescriptor' @ [548:72] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<FunctionDescriptor>.resultingDescriptor: FunctionDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'provideDelegateDescriptor' @ [549:21] ==> val provideDelegateDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[LocalVariableDescriptor]

'isOperator' @ [549:47] ==> public final val FunctionDescriptor.isOperator: Boolean[MyPropertyDescriptor]

'typeInfoForGetValueReceiver' @ [550:21] ==> var typeInfoForGetValueReceiver: KotlinTypeInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[LocalVariableDescriptor]

'KotlinTypeInfo' @ [550:51] ==> @JvmOverloads public constructor KotlinTypeInfo(type: KotlinType?, dataFlowInfo: DataFlowInfo, jumpOutPossible: Boolean = ..., jumpFlowInfo: DataFlowInfo = ...) defined in org.jetbrains.kotlin.types.expressions.KotlinTypeInfo[ClassConstructorDescriptorImpl]

'provideDelegateDescriptor' @ [550:66] ==> val provideDelegateDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[LocalVariableDescriptor]

'returnType' @ [550:92] ==> public final val FunctionDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'provideDelegateResults' @ [551:66] ==> val provideDelegateResults: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[LocalVariableDescriptor]

'resultingCall' @ [551:89] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<FunctionDescriptor>.resultingCall: ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'dataFlowInfoForArguments' @ [551:103] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>.dataFlowInfoForArguments: DataFlowInfoForArguments[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)

'resultInfo' @ [551:128] ==> public final val DataFlowInfoForArguments.resultInfo: DataFlowInfo[MyPropertyDescriptor]

'getGetSetValueMethod' @ [555:13] ==> private final fun getGetSetValueMethod(propertyDescriptor: VariableDescriptorWithAccessors, delegateExpression: KtExpression, delegateType: KotlinType, trace: BindingTrace, scopeForDelegate: LexicalScope, dataFlowInfo: DataFlowInfo, isGet: Boolean, isComplete: Boolean): OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'variableDescriptor' @ [556:21] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[ValueParameterDescriptorImpl]

'delegateExpression' @ [556:41] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[ValueParameterDescriptorImpl]

'typeInfoForGetValueReceiver' @ [556:61] ==> var typeInfoForGetValueReceiver: KotlinTypeInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[LocalVariableDescriptor]

'type' @ [556:89] ==> public final val type: KotlinType? defined in org.jetbrains.kotlin.types.expressions.KotlinTypeInfo[PropertyDescriptorImpl]

'traceToResolveConventionMethods' @ [557:21] ==> val traceToResolveConventionMethods: TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[LocalVariableDescriptor]

'scopeForDelegate' @ [557:54] ==> value-parameter scopeForDelegate: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[ValueParameterDescriptorImpl]

'typeInfoForGetValueReceiver' @ [557:72] ==> var typeInfoForGetValueReceiver: KotlinTypeInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[LocalVariableDescriptor]

'dataFlowInfo' @ [557:100] ==> public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.types.expressions.KotlinTypeInfo[PropertyDescriptorImpl]

'variableDescriptor' @ [561:17] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[ValueParameterDescriptorImpl]

'isVar' @ [561:36] ==> public final val VariableDescriptorWithAccessors.isVar: Boolean[MyPropertyDescriptor]

'variableDescriptor' @ [561:45] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[ValueParameterDescriptorImpl]

'returnType' @ [561:64] ==> public final val VariableDescriptorWithAccessors.returnType: KotlinType?[MyPropertyDescriptor]

'getGetSetValueMethod' @ [562:17] ==> private final fun getGetSetValueMethod(propertyDescriptor: VariableDescriptorWithAccessors, delegateExpression: KtExpression, delegateType: KotlinType, trace: BindingTrace, scopeForDelegate: LexicalScope, dataFlowInfo: DataFlowInfo, isGet: Boolean, isComplete: Boolean): OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'variableDescriptor' @ [563:25] ==> value-parameter variableDescriptor: VariableDescriptorWithAccessors defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[ValueParameterDescriptorImpl]

'delegateExpression' @ [563:45] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[ValueParameterDescriptorImpl]

'typeInfoForGetValueReceiver' @ [563:65] ==> var typeInfoForGetValueReceiver: KotlinTypeInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[LocalVariableDescriptor]

'type' @ [563:93] ==> public final val type: KotlinType? defined in org.jetbrains.kotlin.types.expressions.KotlinTypeInfo[PropertyDescriptorImpl]

'traceToResolveConventionMethods' @ [564:25] ==> val traceToResolveConventionMethods: TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[LocalVariableDescriptor]

'scopeForDelegate' @ [564:58] ==> value-parameter scopeForDelegate: LexicalScope defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[ValueParameterDescriptorImpl]

'typeInfoForGetValueReceiver' @ [564:76] ==> var typeInfoForGetValueReceiver: KotlinTypeInfo defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[LocalVariableDescriptor]

'dataFlowInfo' @ [564:104] ==> public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.types.expressions.KotlinTypeInfo[PropertyDescriptorImpl]

'delegateExpression' @ [569:24] ==> value-parameter delegateExpression: KtExpression defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[ValueParameterDescriptorImpl]

'getCall' @ [569:43] ==> public fun KtElement.getCall(context: BindingContext): Call? defined in org.jetbrains.kotlin.resolve.calls.callUtil in file callUtil.kt[SimpleFunctionDescriptorImpl]

'traceToResolveConventionMethods' @ [569:51] ==> val traceToResolveConventionMethods: TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[LocalVariableDescriptor]

'bindingContext' @ [569:83] ==> public final val TemporaryBindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'call' @ [570:37] ==> val call: Call? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[LocalVariableDescriptor]

'getResolvedCall' @ [570:42] ==> public fun Call?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[SimpleFunctionDescriptorImpl]

'traceToResolveConventionMethods' @ [570:58] ==> val traceToResolveConventionMethods: TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[LocalVariableDescriptor]

'bindingContext' @ [570:90] ==> public final val TemporaryBindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'resultingDescriptor' @ [570:107] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.resultingDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'returnType' @ [570:128] ==> public final val CallableDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'pretendReturnType' @ [571:32] ==> val pretendReturnType: KotlinType? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[LocalVariableDescriptor]

'takeUnless' @ [571:51] ==> @InlineOnly @SinceKotlin public inline fun <T> KotlinType.takeUnless(predicate: (KotlinType) -> Boolean): KotlinType? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'it' @ [571:64] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference.<anonymous>[ValueParameterDescriptorImpl]

'contains' @ [571:67] ==> public fun KotlinType.contains(predicate: (UnwrappedType) -> Boolean): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'it' @ [571:78] ==> value-parameter it: UnwrappedType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'constructor' @ [571:81] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.UnwrappedType[DeserializedPropertyDescriptor]

'expectedType' @ [572:20] ==> val expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference[LocalVariableDescriptor]

'let' @ [572:34] ==> @InlineOnly public inline fun <T, R> KotlinType.let(block: (KotlinType) -> UnwrappedType): UnwrappedType defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType
    <R> -> UnwrappedType

'AnonymousTypeSubstitutor' @ [572:40] ==> private object AnonymousTypeSubstitutor : NewTypeSubstitutor defined in org.jetbrains.kotlin.resolve in file DelegatedPropertyResolver.kt[FakeCallableDescriptorForObject]

'safeSubstitute' @ [572:65] ==> public open fun safeSubstitute(type: UnwrappedType): UnwrappedType defined in org.jetbrains.kotlin.resolve.AnonymousTypeSubstitutor[DeserializedSimpleFunctionDescriptor]

'it' @ [572:80] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver.ConstraintSystemCompleterImpl.resolveViaNewInference.<anonymous>[ValueParameterDescriptorImpl]

'unwrap' @ [572:83] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'constructor' @ [579:37] ==> value-parameter constructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.AnonymousTypeSubstitutor.substituteNotNullTypeWithConstructor[ValueParameterDescriptorImpl]

'declarationDescriptor' @ [579:49] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'declarationDescriptor' @ [580:13] ==> val declarationDescriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.AnonymousTypeSubstitutor.substituteNotNullTypeWithConstructor[LocalVariableDescriptor]

'isAnonymousObject' @ [580:78] ==> public open fun isAnonymousObject(@NotNull p0: DeclarationDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'declarationDescriptor' @ [580:96] ==> val declarationDescriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.AnonymousTypeSubstitutor.substituteNotNullTypeWithConstructor[LocalVariableDescriptor]

'constructor' @ [581:20] ==> value-parameter constructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.AnonymousTypeSubstitutor.substituteNotNullTypeWithConstructor[ValueParameterDescriptorImpl]

'supertypes' @ [581:32] ==> public final val TypeConstructor.supertypes: Collection<(KotlinType..KotlinType?)>[MyPropertyDescriptor]

'firstOrNull' @ [581:43] ==> public fun <T> Iterable<(KotlinType..KotlinType?)>.firstOrNull(): KotlinType? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)

'unwrap' @ [581:58] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

