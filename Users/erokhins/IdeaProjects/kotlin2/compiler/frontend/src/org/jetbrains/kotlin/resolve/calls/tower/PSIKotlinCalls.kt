'assert' @ [31:5] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'this' @ [31:12] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.tower.psiKotlinCall[ReceiverParameterDescriptorImpl]

'this' @ [32:30] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.tower.psiKotlinCall[ReceiverParameterDescriptorImpl]

'javaClass' @ [32:50] ==> public val <T : Any> KotlinCall.javaClass: Class<KotlinCall> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> KotlinCall

'canonicalName' @ [32:60] ==> public final val <T : (Any..Any?)> Class<KotlinCall>.canonicalName: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> KotlinCall

'this' @ [34:12] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.tower.psiKotlinCall[ReceiverParameterDescriptorImpl]

'psiCall' @ [44:33] ==> public abstract val psiCall: Call defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCall[PropertyDescriptorImpl]

'PSIKotlinCall' @ [59:5] ==> public constructor PSIKotlinCall() defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCall[ClassConstructorDescriptorImpl]

'PSIKotlinCall' @ [65:5] ==> public constructor PSIKotlinCall() defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCall[ClassConstructorDescriptorImpl]

'VARIABLE' @ [66:66] ==> enum entry VARIABLE defined in org.jetbrains.kotlin.resolve.calls.model.KotlinCallKind[FakeCallableDescriptorForObject]

'emptyList' @ [67:60] ==> public fun <T> emptyList(): List<TypeArgument> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeArgument

'emptyList' @ [68:75] ==> public fun <T> emptyList(): List<KotlinCallArgument> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinCallArgument

'baseCall' @ [71:61] ==> public final val baseCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForVariable[PropertyDescriptorImpl]

'startingDataFlowInfo' @ [71:70] ==> public open val startingDataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallImpl[PropertyDescriptorImpl]

'baseCall' @ [72:59] ==> public final val baseCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForVariable[PropertyDescriptorImpl]

'startingDataFlowInfo' @ [72:68] ==> public open val startingDataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallImpl[PropertyDescriptorImpl]

'baseCall' @ [73:77] ==> public final val baseCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForVariable[PropertyDescriptorImpl]

'dataFlowInfoForArguments' @ [73:86] ==> public open val dataFlowInfoForArguments: DataFlowInfoForArguments defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallImpl[PropertyDescriptorImpl]

'baseCall' @ [75:59] ==> public final val baseCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForVariable[PropertyDescriptorImpl]

'tracingStrategy' @ [75:68] ==> public open val tracingStrategy: TracingStrategy defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallImpl[PropertyDescriptorImpl]

'stripCallArguments' @ [76:50] ==> public open fun stripCallArguments(@NotNull call: Call): (Call..Call?) defined in org.jetbrains.kotlin.resolve.calls.CallTransformer[JavaMethodDescriptor]

'baseCall' @ [76:69] ==> public final val baseCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForVariable[PropertyDescriptorImpl]

'psiCall' @ [76:78] ==> public open val psiCall: Call defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallImpl[PropertyDescriptorImpl]

'let' @ [76:87] ==> @InlineOnly public inline fun <T, R> (Call..Call?).let(block: ((Call..Call?)) -> Call): Call defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.Call..org.jetbrains.kotlin.psi.Call?)
    <R> -> Call

'if (explicitReceiver == null) CallTransformer.stripReceiver(it) else it' @ [77:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Call, elseBranch: Call): Call[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Call

'explicitReceiver' @ [77:13] ==> public open val explicitReceiver: ReceiverKotlinCallArgument? defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForVariable[PropertyDescriptorImpl]

'stripReceiver' @ [77:55] ==> public open fun stripReceiver(@NotNull variableCall: Call): (Call..Call?) defined in org.jetbrains.kotlin.resolve.calls.CallTransformer[JavaMethodDescriptor]

'it' @ [77:69] ==> value-parameter it: (Call..Call?) defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForVariable.psiCall.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [77:78] ==> value-parameter it: (Call..Call?) defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForVariable.psiCall.<anonymous>[ValueParameterDescriptorImpl]

'PSIKotlinCall' @ [86:5] ==> public constructor PSIKotlinCall() defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCall[ClassConstructorDescriptorImpl]

'FUNCTION' @ [87:66] ==> enum entry FUNCTION defined in org.jetbrains.kotlin.resolve.calls.model.KotlinCallKind[FakeCallableDescriptorForObject]

'OperatorNameConventions' @ [88:37] ==> public object OperatorNameConventions defined in org.jetbrains.kotlin.util[FakeCallableDescriptorForObject]

'INVOKE' @ [88:61] ==> @field:JvmField public final val INVOKE: Name defined in org.jetbrains.kotlin.util.OperatorNameConventions[DeserializedPropertyDescriptor]

'baseCall' @ [89:60] ==> public final val baseCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForInvoke[PropertyDescriptorImpl]

'typeArguments' @ [89:69] ==> public open val typeArguments: List<TypeArgument> defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallImpl[PropertyDescriptorImpl]

'baseCall' @ [90:75] ==> public final val baseCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForInvoke[PropertyDescriptorImpl]

'argumentsInParenthesis' @ [90:84] ==> public open val argumentsInParenthesis: List<KotlinCallArgument> defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallImpl[PropertyDescriptorImpl]

'baseCall' @ [91:64] ==> public final val baseCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForInvoke[PropertyDescriptorImpl]

'externalArgument' @ [91:73] ==> public open val externalArgument: KotlinCallArgument? defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallImpl[PropertyDescriptorImpl]

'baseCall' @ [93:61] ==> public final val baseCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForInvoke[PropertyDescriptorImpl]

'startingDataFlowInfo' @ [93:70] ==> public open val startingDataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallImpl[PropertyDescriptorImpl]

'baseCall' @ [94:59] ==> public final val baseCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForInvoke[PropertyDescriptorImpl]

'resultDataFlowInfo' @ [94:68] ==> public open val resultDataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallImpl[PropertyDescriptorImpl]

'baseCall' @ [95:77] ==> public final val baseCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForInvoke[PropertyDescriptorImpl]

'dataFlowInfoForArguments' @ [95:86] ==> public open val dataFlowInfoForArguments: DataFlowInfoForArguments defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallImpl[PropertyDescriptorImpl]

'dispatchReceiverForInvokeExtension' @ [100:32] ==> public open val dispatchReceiverForInvokeExtension: SimpleKotlinCallArgument? defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForInvoke[PropertyDescriptorImpl]

'explicitReceiver' @ [100:70] ==> public open val explicitReceiver: ReceiverKotlinCallArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForInvoke[PropertyDescriptorImpl]

'if (dispatchReceiverForInvokeExtension == null) null else explicitReceiver' @ [101:41] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: ReceiverKotlinCallArgument?, elseBranch: ReceiverKotlinCallArgument?): ReceiverKotlinCallArgument?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> ReceiverKotlinCallArgument?

'dispatchReceiverForInvokeExtension' @ [101:45] ==> public open val dispatchReceiverForInvokeExtension: SimpleKotlinCallArgument? defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForInvoke[PropertyDescriptorImpl]

'explicitReceiver' @ [101:99] ==> public open val explicitReceiver: ReceiverKotlinCallArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForInvoke[PropertyDescriptorImpl]

'baseCall' @ [102:32] ==> public final val baseCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForInvoke[PropertyDescriptorImpl]

'psiCall' @ [102:41] ==> public open val psiCall: Call defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallImpl[PropertyDescriptorImpl]

'calleeExpression' @ [102:49] ==> public final val Call.calleeExpression: KtExpression?[MyPropertyDescriptor]

'psiCall' @ [104:9] ==> public open val psiCall: Call defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForInvoke[PropertyDescriptorImpl]

'CallForImplicitInvoke' @ [104:35] ==> public constructor CallForImplicitInvoke(@Nullable explicitExtensionReceiver: Receiver?, @NotNull calleeExpressionAsDispatchReceiver: ExpressionReceiver, @NotNull call: Call, functionCall: Boolean) defined in org.jetbrains.kotlin.resolve.calls.CallTransformer.CallForImplicitInvoke[JavaClassConstructorDescriptor]

'explicitExtensionReceiver' @ [105:17] ==> val explicitExtensionReceiver: ReceiverKotlinCallArgument? defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForInvoke.<init>[LocalVariableDescriptor]

'receiverValue' @ [105:44] ==> public val ReceiverKotlinCallArgument.receiverValue: ReceiverValue? defined in org.jetbrains.kotlin.resolve.calls.tower in file PSIKotlinCalls.kt[PropertyDescriptorImpl]

'variableReceiver' @ [106:17] ==> val variableReceiver: ReceiverKotlinCallArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForInvoke.<init>[LocalVariableDescriptor]

'receiverValue' @ [106:34] ==> public val ReceiverKotlinCallArgument.receiverValue: ReceiverValue? defined in org.jetbrains.kotlin.resolve.calls.tower in file PSIKotlinCalls.kt[PropertyDescriptorImpl]

'baseCall' @ [106:71] ==> public final val baseCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForInvoke[PropertyDescriptorImpl]

'psiCall' @ [106:80] ==> public open val psiCall: Call defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallImpl[PropertyDescriptorImpl]

'tracingStrategy' @ [107:9] ==> public open val tracingStrategy: TracingStrategy defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForInvoke[PropertyDescriptorImpl]

'TracingStrategyForInvoke' @ [107:27] ==> public constructor TracingStrategyForInvoke(@NotNull reference: KtExpression, @NotNull call: Call, @NotNull calleeType: KotlinType) defined in org.jetbrains.kotlin.resolve.calls.tasks.TracingStrategyForInvoke[JavaClassConstructorDescriptor]

'calleeExpression' @ [107:52] ==> val calleeExpression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForInvoke.<init>[LocalVariableDescriptor]

'psiCall' @ [107:70] ==> public open val psiCall: Call defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForInvoke[PropertyDescriptorImpl]

'variableReceiver' @ [107:79] ==> val variableReceiver: ReceiverKotlinCallArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForInvoke.<init>[LocalVariableDescriptor]

'receiverValue' @ [107:96] ==> public val ReceiverKotlinCallArgument.receiverValue: ReceiverValue? defined in org.jetbrains.kotlin.resolve.calls.tower in file PSIKotlinCalls.kt[PropertyDescriptorImpl]

'type' @ [107:112] ==> public final val ReceiverValue.type: KotlinType[MyPropertyDescriptor]

'when (this) {
        is SimpleKotlinCallArgument -> this.receiver.receiverValue
        is QualifierReceiverKotlinCallArgument -> this.receiver.classValueReceiver
        else -> null
    }' @ [112:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: ReceiverValue?, entry1: ReceiverValue?, entry2: ReceiverValue?): ReceiverValue?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> ReceiverValue?

'this' @ [112:19] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.tower.receiverValue[ReceiverParameterDescriptorImpl]

'this' @ [113:40] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.tower.receiverValue[ReceiverParameterDescriptorImpl]

'receiver' @ [113:45] ==> public abstract val receiver: ReceiverValueWithSmartCastInfo defined in org.jetbrains.kotlin.resolve.calls.model.SimpleKotlinCallArgument[DeserializedPropertyDescriptor]

'receiverValue' @ [113:54] ==> public final val receiverValue: ReceiverValue defined in org.jetbrains.kotlin.resolve.scopes.receivers.ReceiverValueWithSmartCastInfo[DeserializedPropertyDescriptor]

'this' @ [114:51] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.tower.receiverValue[ReceiverParameterDescriptorImpl]

'receiver' @ [114:56] ==> public open val receiver: QualifierReceiver defined in org.jetbrains.kotlin.resolve.calls.model.QualifierReceiverKotlinCallArgument[DeserializedPropertyDescriptor]

'classValueReceiver' @ [114:65] ==> public abstract val classValueReceiver: ReceiverValue? defined in org.jetbrains.kotlin.resolve.scopes.receivers.QualifierReceiver[DeserializedPropertyDescriptor]

