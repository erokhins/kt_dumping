'hashMapOf' @ [44:65] ==> public fun <K, V> hashMapOf(vararg pairs: Pair<PrimitiveType, Name>): HashMap<PrimitiveType, Name> /* = HashMap<PrimitiveType, Name> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> PrimitiveType
    <V> -> Name

'to' @ [45:17] ==> public infix fun <A, B> PrimitiveType.to(that: Name): Pair<PrimitiveType, Name> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> PrimitiveType
    <B> -> Name

'BOOLEAN' @ [45:31] ==> enum entry BOOLEAN defined in org.jetbrains.kotlin.builtins.PrimitiveType[FakeCallableDescriptorForObject]

'identifier' @ [45:47] ==> @NotNull public open fun identifier(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'to' @ [46:17] ==> public infix fun <A, B> PrimitiveType.to(that: Name): Pair<PrimitiveType, Name> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> PrimitiveType
    <B> -> Name

'CHAR' @ [46:31] ==> enum entry CHAR defined in org.jetbrains.kotlin.builtins.PrimitiveType[FakeCallableDescriptorForObject]

'identifier' @ [46:44] ==> @NotNull public open fun identifier(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'to' @ [47:17] ==> public infix fun <A, B> PrimitiveType.to(that: Name): Pair<PrimitiveType, Name> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> PrimitiveType
    <B> -> Name

'INT' @ [47:31] ==> enum entry INT defined in org.jetbrains.kotlin.builtins.PrimitiveType[FakeCallableDescriptorForObject]

'identifier' @ [47:43] ==> @NotNull public open fun identifier(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'to' @ [48:17] ==> public infix fun <A, B> PrimitiveType.to(that: Name): Pair<PrimitiveType, Name> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> PrimitiveType
    <B> -> Name

'BYTE' @ [48:31] ==> enum entry BYTE defined in org.jetbrains.kotlin.builtins.PrimitiveType[FakeCallableDescriptorForObject]

'identifier' @ [48:44] ==> @NotNull public open fun identifier(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'to' @ [49:17] ==> public infix fun <A, B> PrimitiveType.to(that: Name): Pair<PrimitiveType, Name> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> PrimitiveType
    <B> -> Name

'SHORT' @ [49:31] ==> enum entry SHORT defined in org.jetbrains.kotlin.builtins.PrimitiveType[FakeCallableDescriptorForObject]

'identifier' @ [49:45] ==> @NotNull public open fun identifier(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'to' @ [50:17] ==> public infix fun <A, B> PrimitiveType.to(that: Name): Pair<PrimitiveType, Name> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> PrimitiveType
    <B> -> Name

'FLOAT' @ [50:31] ==> enum entry FLOAT defined in org.jetbrains.kotlin.builtins.PrimitiveType[FakeCallableDescriptorForObject]

'identifier' @ [50:45] ==> @NotNull public open fun identifier(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'to' @ [51:17] ==> public infix fun <A, B> PrimitiveType.to(that: Name): Pair<PrimitiveType, Name> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> PrimitiveType
    <B> -> Name

'LONG' @ [51:31] ==> enum entry LONG defined in org.jetbrains.kotlin.builtins.PrimitiveType[FakeCallableDescriptorForObject]

'identifier' @ [51:44] ==> @NotNull public open fun identifier(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'to' @ [52:17] ==> public infix fun <A, B> PrimitiveType.to(that: Name): Pair<PrimitiveType, Name> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> PrimitiveType
    <B> -> Name

'DOUBLE' @ [52:31] ==> enum entry DOUBLE defined in org.jetbrains.kotlin.builtins.PrimitiveType[FakeCallableDescriptorForObject]

'identifier' @ [52:46] ==> @NotNull public open fun identifier(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'identifier' @ [55:38] ==> @NotNull public open fun identifier(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'!' @ [62:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isInsideAnnotationEntryOrClass' @ [62:14] ==> private final fun isInsideAnnotationEntryOrClass(expression: KtCollectionLiteralExpression): Boolean defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver[SimpleFunctionDescriptorImpl]

'collectionLiteralExpression' @ [62:45] ==> value-parameter collectionLiteralExpression: KtCollectionLiteralExpression defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteral[ValueParameterDescriptorImpl]

'context' @ [63:13] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteral[ValueParameterDescriptorImpl]

'trace' @ [63:21] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'report' @ [63:27] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'UNSUPPORTED' @ [63:34] ==> public final val UNSUPPORTED: (DiagnosticFactory1<(PsiElement..PsiElement?), (String..String?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (String..String?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [63:46] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull argument: String): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory1[JavaMethodDescriptor]

'collectionLiteralExpression' @ [63:49] ==> value-parameter collectionLiteralExpression: KtCollectionLiteralExpression defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteral[ValueParameterDescriptorImpl]

'checkSupportsArrayLiterals' @ [66:9] ==> private final fun checkSupportsArrayLiterals(expression: KtCollectionLiteralExpression, context: ExpressionTypingContext): Unit defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver[SimpleFunctionDescriptorImpl]

'collectionLiteralExpression' @ [66:36] ==> value-parameter collectionLiteralExpression: KtCollectionLiteralExpression defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteral[ValueParameterDescriptorImpl]

'context' @ [66:65] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteral[ValueParameterDescriptorImpl]

'resolveCollectionLiteralSpecialMethod' @ [68:16] ==> private final fun resolveCollectionLiteralSpecialMethod(expression: KtCollectionLiteralExpression, context: ExpressionTypingContext): KotlinTypeInfo defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver[SimpleFunctionDescriptorImpl]

'collectionLiteralExpression' @ [68:54] ==> value-parameter collectionLiteralExpression: KtCollectionLiteralExpression defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteral[ValueParameterDescriptorImpl]

'context' @ [68:83] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteral[ValueParameterDescriptorImpl]

'makeCallForCollectionLiteral' @ [75:30] ==> public open fun makeCallForCollectionLiteral(@NotNull collectionLiteralExpression: KtCollectionLiteralExpression): (Call..Call?) defined in org.jetbrains.kotlin.resolve.calls.util.CallMaker[JavaMethodDescriptor]

'expression' @ [75:59] ==> value-parameter expression: KtCollectionLiteralExpression defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteralSpecialMethod[ValueParameterDescriptorImpl]

'getArrayFunctionCallName' @ [76:24] ==> private final fun getArrayFunctionCallName(expectedType: KotlinType): Name defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver[SimpleFunctionDescriptorImpl]

'context' @ [76:49] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteralSpecialMethod[ValueParameterDescriptorImpl]

'expectedType' @ [76:57] ==> @NotNull public final val expectedType: KotlinType defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'getFunctionDescriptorForCollectionLiteral' @ [77:35] ==> private final fun getFunctionDescriptorForCollectionLiteral(expression: KtCollectionLiteralExpression, callName: Name): Collection<SimpleFunctionDescriptor> defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver[SimpleFunctionDescriptorImpl]

'expression' @ [77:77] ==> value-parameter expression: KtCollectionLiteralExpression defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteralSpecialMethod[ValueParameterDescriptorImpl]

'callName' @ [77:89] ==> val callName: Name defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteralSpecialMethod[LocalVariableDescriptor]

'functionDescriptors' @ [78:13] ==> val functionDescriptors: Collection<SimpleFunctionDescriptor> defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteralSpecialMethod[LocalVariableDescriptor]

'isEmpty' @ [78:33] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.Collection[DeserializedSimpleFunctionDescriptor]

'context' @ [79:13] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteralSpecialMethod[ValueParameterDescriptorImpl]

'trace' @ [79:21] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'report' @ [79:27] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'MISSING_STDLIB' @ [79:34] ==> public final val MISSING_STDLIB: (DiagnosticFactory1<(PsiElement..PsiElement?), (String..String?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (String..String?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [79:49] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull argument: String): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory1[JavaMethodDescriptor]

'expression' @ [80:21] ==> value-parameter expression: KtCollectionLiteralExpression defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteralSpecialMethod[ValueParameterDescriptorImpl]

'callName' @ [80:60] ==> val callName: Name defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteralSpecialMethod[LocalVariableDescriptor]

'noTypeInfo' @ [81:20] ==> public fun noTypeInfo(context: ResolutionContext<*>): KotlinTypeInfo defined in org.jetbrains.kotlin.types.expressions.typeInfoFactory in file TypeInfoFactory.kt[SimpleFunctionDescriptorImpl]

'context' @ [81:31] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteralSpecialMethod[ValueParameterDescriptorImpl]

'callResolver' @ [84:33] ==> public final val callResolver: CallResolver defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver[PropertyDescriptorImpl]

'resolveCollectionLiteralCallWithGivenDescriptor' @ [84:46] ==> @NotNull public open fun resolveCollectionLiteralCallWithGivenDescriptor(@NotNull context: ExpressionTypingContext, @NotNull expression: KtCollectionLiteralExpression, @NotNull call: Call, @NotNull functionDescriptors: (MutableCollection<(FunctionDescriptor..FunctionDescriptor?)>..Collection<(FunctionDescriptor..FunctionDescriptor?)>)): OverloadResolutionResults<(FunctionDescriptor..FunctionDescriptor?)> defined in org.jetbrains.kotlin.resolve.calls.CallResolver[JavaMethodDescriptor]

'context' @ [84:94] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteralSpecialMethod[ValueParameterDescriptorImpl]

'expression' @ [84:103] ==> value-parameter expression: KtCollectionLiteralExpression defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteralSpecialMethod[ValueParameterDescriptorImpl]

'call' @ [84:115] ==> val call: (Call..Call?) defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteralSpecialMethod[LocalVariableDescriptor]

'functionDescriptors' @ [84:121] ==> val functionDescriptors: Collection<SimpleFunctionDescriptor> defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteralSpecialMethod[LocalVariableDescriptor]

'!' @ [86:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'resolutionResults' @ [86:14] ==> val resolutionResults: OverloadResolutionResults<(FunctionDescriptor..FunctionDescriptor?)> defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteralSpecialMethod[LocalVariableDescriptor]

'isSingleResult' @ [86:32] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<(FunctionDescriptor..FunctionDescriptor?)>.isSingleResult: Boolean[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)

'noTypeInfo' @ [87:20] ==> public fun noTypeInfo(context: ResolutionContext<*>): KotlinTypeInfo defined in org.jetbrains.kotlin.types.expressions.typeInfoFactory in file TypeInfoFactory.kt[SimpleFunctionDescriptorImpl]

'context' @ [87:31] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteralSpecialMethod[ValueParameterDescriptorImpl]

'context' @ [90:9] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteralSpecialMethod[ValueParameterDescriptorImpl]

'trace' @ [90:17] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'record' @ [90:23] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(KtCollectionLiteralExpression..KtCollectionLiteralExpression?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>..WritableSlice<(KtCollectionLiteralExpression..KtCollectionLiteralExpression?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>?), key: (KtCollectionLiteralExpression..KtCollectionLiteralExpression?), value: (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> KtCollectionLiteralExpression
    <V : (Any..Any?)> -> ResolvedCall<(org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)>

'COLLECTION_LITERAL_CALL' @ [90:30] ==> public final val COLLECTION_LITERAL_CALL: (WritableSlice<(KtCollectionLiteralExpression..KtCollectionLiteralExpression?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>..WritableSlice<(KtCollectionLiteralExpression..KtCollectionLiteralExpression?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'expression' @ [90:55] ==> value-parameter expression: KtCollectionLiteralExpression defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteralSpecialMethod[ValueParameterDescriptorImpl]

'resolutionResults' @ [90:67] ==> val resolutionResults: OverloadResolutionResults<(FunctionDescriptor..FunctionDescriptor?)> defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteralSpecialMethod[LocalVariableDescriptor]

'resultingCall' @ [90:85] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<(FunctionDescriptor..FunctionDescriptor?)>.resultingCall: ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)

'createTypeInfo' @ [91:16] ==> public fun createTypeInfo(type: KotlinType?, context: ResolutionContext<*>): KotlinTypeInfo defined in org.jetbrains.kotlin.types.expressions.typeInfoFactory in file TypeInfoFactory.kt[SimpleFunctionDescriptorImpl]

'resolutionResults' @ [91:31] ==> val resolutionResults: OverloadResolutionResults<(FunctionDescriptor..FunctionDescriptor?)> defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteralSpecialMethod[LocalVariableDescriptor]

'resultingDescriptor' @ [91:49] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<(FunctionDescriptor..FunctionDescriptor?)>.resultingDescriptor: (FunctionDescriptor..FunctionDescriptor?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)

'returnType' @ [91:69] ==> public final val FunctionDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'context' @ [91:81] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.resolveCollectionLiteralSpecialMethod[ValueParameterDescriptorImpl]

'module' @ [98:42] ==> public final val module: ModuleDescriptor defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver[PropertyDescriptorImpl]

'getPackage' @ [98:49] ==> public abstract fun getPackage(fqName: FqName): PackageViewDescriptor defined in org.jetbrains.kotlin.descriptors.ModuleDescriptor[DeserializedSimpleFunctionDescriptor]

'BUILT_INS_PACKAGE_FQ_NAME' @ [98:75] ==> public final val BUILT_INS_PACKAGE_FQ_NAME: (FqName..FqName?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaPropertyDescriptor]

'memberScope' @ [98:102] ==> public abstract val memberScope: MemberScope defined in org.jetbrains.kotlin.descriptors.PackageViewDescriptor[DeserializedPropertyDescriptor]

'memberScopeOfKotlinPackage' @ [99:16] ==> val memberScopeOfKotlinPackage: MemberScope defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.getFunctionDescriptorForCollectionLiteral[LocalVariableDescriptor]

'getContributedFunctions' @ [99:43] ==> public abstract fun getContributedFunctions(name: Name, location: LookupLocation): Collection<SimpleFunctionDescriptor> defined in org.jetbrains.kotlin.resolve.scopes.MemberScope[DeserializedSimpleFunctionDescriptor]

'callName' @ [99:67] ==> value-parameter callName: Name defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.getFunctionDescriptorForCollectionLiteral[ValueParameterDescriptorImpl]

'KotlinLookupLocation' @ [99:77] ==> public constructor KotlinLookupLocation(element: KtElement) defined in org.jetbrains.kotlin.incremental.KotlinLookupLocation[ClassConstructorDescriptorImpl]

'expression' @ [99:98] ==> value-parameter expression: KtCollectionLiteralExpression defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.getFunctionDescriptorForCollectionLiteral[ValueParameterDescriptorImpl]

'isInsideAnnotationEntryOrClass' @ [103:13] ==> private final fun isInsideAnnotationEntryOrClass(expression: KtCollectionLiteralExpression): Boolean defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver[SimpleFunctionDescriptorImpl]

'expression' @ [103:44] ==> value-parameter expression: KtCollectionLiteralExpression defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.checkSupportsArrayLiterals[ValueParameterDescriptorImpl]

'!' @ [104:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'languageVersionSettings' @ [104:14] ==> public final val languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver[PropertyDescriptorImpl]

'supportsFeature' @ [104:38] ==> public open fun supportsFeature(feature: LanguageFeature): Boolean defined in org.jetbrains.kotlin.config.LanguageVersionSettings[DeserializedSimpleFunctionDescriptor]

'LanguageFeature' @ [104:54] ==> public companion object defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'ArrayLiteralsInAnnotations' @ [104:70] ==> enum entry ArrayLiteralsInAnnotations defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'context' @ [105:13] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.checkSupportsArrayLiterals[ValueParameterDescriptorImpl]

'trace' @ [105:21] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'report' @ [105:27] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'UNSUPPORTED_FEATURE' @ [105:34] ==> public final val UNSUPPORTED_FEATURE: (DiagnosticFactory1<(PsiElement..PsiElement?), (Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>..Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>..Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [105:54] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull argument: Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory1[JavaMethodDescriptor]

'expression' @ [105:57] ==> value-parameter expression: KtCollectionLiteralExpression defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.checkSupportsArrayLiterals[ValueParameterDescriptorImpl]

'LanguageFeature' @ [105:69] ==> public companion object defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'ArrayLiteralsInAnnotations' @ [105:85] ==> enum entry ArrayLiteralsInAnnotations defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'languageVersionSettings' @ [105:115] ==> public final val languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver[PropertyDescriptorImpl]

'getParentOfType' @ [110:34] ==> @SafeVarargs @Nullable @Contract public open fun <T : (PsiElement..PsiElement?)> getParentOfType(@Nullable p0: PsiElement?, @NotNull vararg p1: (Class<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>?)>?)>..Class<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>?)>?)>?)): KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>?)>? defined in com.intellij.psi.util.PsiTreeUtil[JavaMethodDescriptor]
Inferred types:
    <T : (PsiElement..PsiElement?)> -> KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out (org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out (org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>..org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>?)>..com.intellij.psi.stubs.StubElement<out (org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>..org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>?)>?)>..org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out (org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>..org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>?)>..com.intellij.psi.stubs.StubElement<out (org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>..org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>?)>?)>?)>..com.intellij.psi.stubs.StubElement<out (org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out (org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>..org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>?)>..com.intellij.psi.stubs.StubElement<out (org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>..org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>?)>?)>..org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<out (org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>..org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>?)>..com.intellij.psi.stubs.StubElement<out (org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>..org.jetbrains.kotlin.psi.KtElementImplStub<out (com.intellij.psi.stubs.StubElement<*>..com.intellij.psi.stubs.StubElement<*>?)>?)>?)>?)>?)>

'expression' @ [110:50] ==> value-parameter expression: KtCollectionLiteralExpression defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.isInsideAnnotationEntryOrClass[ValueParameterDescriptorImpl]

'java' @ [110:87] ==> public val <T> KClass<KtAnnotationEntry>.java: Class<KtAnnotationEntry> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtAnnotationEntry

'java' @ [110:108] ==> public val <T> KClass<KtClass>.java: Class<KtClass> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtClass

'parent' @ [111:16] ==> val parent: KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>?)>? defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.isInsideAnnotationEntryOrClass[LocalVariableDescriptor]

'parent' @ [111:48] ==> val parent: KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>?)>? defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.isInsideAnnotationEntryOrClass[LocalVariableDescriptor]

'parent' @ [111:69] ==> val parent: KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>..KtElementImplStub<out (StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>..StubElement<out (KtElementImplStub<out (StubElement<*>..StubElement<*>?)>..KtElementImplStub<out (StubElement<*>..StubElement<*>?)>?)>?)>?)>?)>? defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.isInsideAnnotationEntryOrClass[LocalVariableDescriptor]

'isAnnotation' @ [111:76] ==> public final fun isAnnotation(): Boolean defined in org.jetbrains.kotlin.psi.KtClass[SimpleFunctionDescriptorImpl]

'NO_EXPECTED_TYPE' @ [115:13] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'expectedType' @ [115:34] ==> value-parameter expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.getArrayFunctionCallName[ValueParameterDescriptorImpl]

'!' @ [115:50] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isPrimitiveArray' @ [115:66] ==> public open fun isPrimitiveArray(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'expectedType' @ [115:83] ==> value-parameter expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.getArrayFunctionCallName[ValueParameterDescriptorImpl]

'ARRAY_OF_FUNCTION' @ [116:20] ==> public final val ARRAY_OF_FUNCTION: Name defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.Companion[PropertyDescriptorImpl]

'expectedType' @ [119:26] ==> value-parameter expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.getArrayFunctionCallName[ValueParameterDescriptorImpl]

'constructor' @ [119:39] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'declarationDescriptor' @ [119:51] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'ARRAY_OF_FUNCTION' @ [119:83] ==> public final val ARRAY_OF_FUNCTION: Name defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.Companion[PropertyDescriptorImpl]

'PRIMITIVE_TYPE_TO_ARRAY' @ [121:16] ==> public final val PRIMITIVE_TYPE_TO_ARRAY: Map<PrimitiveType, Name> defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.Companion[PropertyDescriptorImpl]

'getPrimitiveArrayType' @ [121:55] ==> @Nullable public open fun getPrimitiveArrayType(@NotNull p0: DeclarationDescriptor): PrimitiveType? defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'descriptor' @ [121:77] ==> val descriptor: ClassifierDescriptor defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.getArrayFunctionCallName[LocalVariableDescriptor]

'ARRAY_OF_FUNCTION' @ [121:93] ==> public final val ARRAY_OF_FUNCTION: Name defined in org.jetbrains.kotlin.resolve.CollectionLiteralResolver.Companion[PropertyDescriptorImpl]

