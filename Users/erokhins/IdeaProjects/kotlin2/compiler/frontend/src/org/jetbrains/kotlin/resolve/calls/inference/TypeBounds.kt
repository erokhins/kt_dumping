'if (values.size == 1) values.first() else null' @ [30:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType?, elseBranch: KotlinType?): KotlinType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType?

'values' @ [30:21] ==> public abstract val values: Collection<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds[PropertyDescriptorImpl]

'size' @ [30:28] ==> public abstract val size: Int defined in kotlin.collections.Collection[DeserializedPropertyDescriptor]

'values' @ [30:39] ==> public abstract val values: Collection<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds[PropertyDescriptorImpl]

'first' @ [30:46] ==> public fun <T> Iterable<KotlinType>.first(): KotlinType defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'this' @ [50:17] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[LazyClassReceiverParameterDescriptor]

'other' @ [50:26] ==> value-parameter other: Any? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound.equals[ValueParameterDescriptorImpl]

'other' @ [51:17] ==> value-parameter other: Any? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound.equals[ValueParameterDescriptorImpl]

'this' @ [51:34] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[LazyClassReceiverParameterDescriptor]

'java' @ [51:46] ==> public val <T> KClass<out TypeBounds.Bound>.java: Class<out TypeBounds.Bound> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> Bound

'other' @ [51:54] ==> value-parameter other: Any? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound.equals[ValueParameterDescriptorImpl]

'java' @ [51:67] ==> public val <T> KClass<out Any>.java: Class<out Any> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> Any

'other' @ [53:25] ==> value-parameter other: Any? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound.equals[ValueParameterDescriptorImpl]

'typeVariable' @ [55:17] ==> public final val typeVariable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'bound' @ [55:33] ==> val bound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound.equals[LocalVariableDescriptor]

'typeVariable' @ [55:39] ==> public final val typeVariable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'constrainingType' @ [56:17] ==> public final val constrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'bound' @ [56:37] ==> val bound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound.equals[LocalVariableDescriptor]

'constrainingType' @ [56:43] ==> public final val constrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'kind' @ [57:17] ==> public final val kind: TypeBounds.BoundKind defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'bound' @ [57:25] ==> val bound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound.equals[LocalVariableDescriptor]

'kind' @ [57:31] ==> public final val kind: TypeBounds.BoundKind defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'position' @ [59:17] ==> public final val position: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'isStrong' @ [59:26] ==> public open fun isStrong(): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPosition[SimpleFunctionDescriptorImpl]

'bound' @ [59:40] ==> val bound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound.equals[LocalVariableDescriptor]

'position' @ [59:46] ==> public final val position: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'isStrong' @ [59:55] ==> public open fun isStrong(): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPosition[SimpleFunctionDescriptorImpl]

'typeVariable' @ [65:26] ==> public final val typeVariable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'hashCode' @ [65:39] ==> public open fun hashCode(): Int defined in org.jetbrains.kotlin.resolve.calls.inference.TypeVariable[DeserializedSimpleFunctionDescriptor]

'result' @ [66:13] ==> var result: Int defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound.hashCode[LocalVariableDescriptor]

'*' @ [66:22] ==> public final operator fun times(other: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'result' @ [66:27] ==> var result: Int defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound.hashCode[LocalVariableDescriptor]

'constrainingType' @ [66:36] ==> public final val constrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'hashCode' @ [66:53] ==> public final fun hashCode(): Int defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'result' @ [67:13] ==> var result: Int defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound.hashCode[LocalVariableDescriptor]

'*' @ [67:22] ==> public final operator fun times(other: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'result' @ [67:27] ==> var result: Int defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound.hashCode[LocalVariableDescriptor]

'kind' @ [67:36] ==> public final val kind: TypeBounds.BoundKind defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'hashCode' @ [67:41] ==> public final fun hashCode(): Int defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[DeserializedSimpleFunctionDescriptor]

'result' @ [68:13] ==> var result: Int defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound.hashCode[LocalVariableDescriptor]

'*' @ [68:22] ==> public final operator fun times(other: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'result' @ [68:27] ==> var result: Int defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound.hashCode[LocalVariableDescriptor]

'if (position.isStrong()) 1 else 0' @ [68:36] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Int, elseBranch: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Int

'position' @ [68:40] ==> public final val position: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'isStrong' @ [68:49] ==> public open fun isStrong(): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPosition[SimpleFunctionDescriptorImpl]

'result' @ [69:20] ==> var result: Int defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound.hashCode[LocalVariableDescriptor]

'constrainingType' @ [72:43] ==> public final val constrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'kind' @ [72:62] ==> public final val kind: TypeBounds.BoundKind defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'position' @ [72:69] ==> public final val position: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'isProper' @ [72:91] ==> public final val isProper: Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'when (this) {
    LOWER_BOUND -> UPPER_BOUND
    UPPER_BOUND -> LOWER_BOUND
    EXACT_BOUND -> EXACT_BOUND
}' @ [76:27] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: TypeBounds.BoundKind, entry1: TypeBounds.BoundKind, entry2: TypeBounds.BoundKind): TypeBounds.BoundKind[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> BoundKind

'this' @ [76:33] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.inference.reverse[ReceiverParameterDescriptorImpl]

'LOWER_BOUND' @ [77:5] ==> enum entry LOWER_BOUND defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[FakeCallableDescriptorForObject]

'UPPER_BOUND' @ [77:20] ==> enum entry UPPER_BOUND defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[FakeCallableDescriptorForObject]

'UPPER_BOUND' @ [78:5] ==> enum entry UPPER_BOUND defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[FakeCallableDescriptorForObject]

'LOWER_BOUND' @ [78:20] ==> enum entry LOWER_BOUND defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[FakeCallableDescriptorForObject]

'EXACT_BOUND' @ [79:5] ==> enum entry EXACT_BOUND defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[FakeCallableDescriptorForObject]

'EXACT_BOUND' @ [79:20] ==> enum entry EXACT_BOUND defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[FakeCallableDescriptorForObject]

