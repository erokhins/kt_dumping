'ArrayList' @ [30:27] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> Bound

'isFixed' @ [38:9] ==> public final var isFixed: Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[PropertyDescriptorImpl]

'resultValues' @ [42:9] ==> private final var resultValues: Collection<KotlinType>? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[PropertyDescriptorImpl]

'assert' @ [43:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'bound' @ [43:16] ==> value-parameter bound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.addBound[ValueParameterDescriptorImpl]

'typeVariable' @ [43:22] ==> public final val typeVariable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'typeVariable' @ [43:38] ==> public open val typeVariable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[PropertyDescriptorImpl]

'bound' @ [44:15] ==> value-parameter bound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.addBound[ValueParameterDescriptorImpl]

'bound' @ [44:60] ==> value-parameter bound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.addBound[ValueParameterDescriptorImpl]

'typeVariable' @ [44:66] ==> public final val typeVariable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'name' @ [44:79] ==> public final val name: Name defined in org.jetbrains.kotlin.resolve.calls.inference.TypeVariable[PropertyDescriptorImpl]

'typeVariable' @ [44:98] ==> public open val typeVariable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[PropertyDescriptorImpl]

'name' @ [44:111] ==> public final val name: Name defined in org.jetbrains.kotlin.resolve.calls.inference.TypeVariable[PropertyDescriptorImpl]

'bounds' @ [46:9] ==> public open val bounds: ArrayList<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[PropertyDescriptorImpl]

'add' @ [46:16] ==> public open fun add(element: TypeBounds.Bound): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'bound' @ [46:20] ==> value-parameter bound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.addBound[ValueParameterDescriptorImpl]

'LinkedHashSet' @ [50:22] ==> public constructor LinkedHashSet<E : (Any..Any?)>() defined in java.util.LinkedHashSet[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> KotlinType

'bounds' @ [51:23] ==> value-parameter bounds: Collection<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.filterBounds[ValueParameterDescriptorImpl]

'bound' @ [52:17] ==> val bound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.filterBounds[LocalVariableDescriptor]

'kind' @ [52:23] ==> public final val kind: TypeBounds.BoundKind defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'kind' @ [52:31] ==> value-parameter kind: TypeBounds.BoundKind defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.filterBounds[ValueParameterDescriptorImpl]

'if (!ErrorUtils.containsErrorType(bound.constrainingType)) {
                    result.add(bound.constrainingType)
                }
                else {
                    errorValues?.add(bound.constrainingType)
                }' @ [53:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Boolean?, elseBranch: Boolean?): Boolean?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Boolean?

'!' @ [53:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'containsErrorType' @ [53:33] ==> public open fun containsErrorType(@Nullable p0: KotlinType?): Boolean defined in org.jetbrains.kotlin.types.ErrorUtils[JavaMethodDescriptor]

'bound' @ [53:51] ==> val bound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.filterBounds[LocalVariableDescriptor]

'constrainingType' @ [53:57] ==> public final val constrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'result' @ [54:21] ==> val result: LinkedHashSet<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.filterBounds[LocalVariableDescriptor]

'add' @ [54:28] ==> public open fun add(element: KotlinType): Boolean defined in java.util.LinkedHashSet[JavaMethodDescriptor]

'bound' @ [54:32] ==> val bound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.filterBounds[LocalVariableDescriptor]

'constrainingType' @ [54:38] ==> public final val constrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'errorValues' @ [57:21] ==> value-parameter errorValues: MutableCollection<KotlinType>? = ... defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.filterBounds[ValueParameterDescriptorImpl]

'add' @ [57:34] ==> public abstract fun add(element: KotlinType): Boolean defined in kotlin.collections.MutableCollection[DeserializedSimpleFunctionDescriptor]

'bound' @ [57:38] ==> val bound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.filterBounds[LocalVariableDescriptor]

'constrainingType' @ [57:44] ==> public final val constrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'result' @ [61:16] ==> val result: LinkedHashSet<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.filterBounds[LocalVariableDescriptor]

'TypeBoundsImpl' @ [65:22] ==> public constructor TypeBoundsImpl(typeVariable: TypeVariable) defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[ClassConstructorDescriptorImpl]

'typeVariable' @ [65:37] ==> public open val typeVariable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[PropertyDescriptorImpl]

'result' @ [66:9] ==> val result: TypeBoundsImpl defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.filter[LocalVariableDescriptor]

'bounds' @ [66:16] ==> public open val bounds: ArrayList<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[PropertyDescriptorImpl]

'addAll' @ [66:23] ==> public open fun addAll(elements: Collection<TypeBounds.Bound>): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'bounds' @ [66:30] ==> public open val bounds: ArrayList<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[PropertyDescriptorImpl]

'filter' @ [66:37] ==> public inline fun <T> Iterable<TypeBounds.Bound>.filter(predicate: (TypeBounds.Bound) -> Boolean): List<TypeBounds.Bound> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Bound

'invoke' @ [66:46] ==> public abstract operator fun invoke(p1: ConstraintPosition): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'it' @ [66:56] ==> value-parameter it: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.filter.<anonymous>[ValueParameterDescriptorImpl]

'position' @ [66:59] ==> public final val position: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'result' @ [67:16] ==> val result: TypeBoundsImpl defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.filter[LocalVariableDescriptor]

'resultValues' @ [72:17] ==> private final var resultValues: Collection<KotlinType>? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[PropertyDescriptorImpl]

'resultValues' @ [73:17] ==> private final var resultValues: Collection<KotlinType>? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[PropertyDescriptorImpl]

'computeValues' @ [73:32] ==> private final fun computeValues(): Collection<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[SimpleFunctionDescriptorImpl]

'resultValues' @ [75:20] ==> private final var resultValues: Collection<KotlinType>? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[PropertyDescriptorImpl]

'LinkedHashSet' @ [79:22] ==> public constructor LinkedHashSet<E : (Any..Any?)>() defined in java.util.LinkedHashSet[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> KotlinType

'bounds' @ [80:22] ==> public open val bounds: ArrayList<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[PropertyDescriptorImpl]

'filter' @ [80:29] ==> public inline fun <T> Iterable<TypeBounds.Bound>.filter(predicate: (TypeBounds.Bound) -> Boolean): List<TypeBounds.Bound> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Bound

'it' @ [80:38] ==> value-parameter it: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues.<anonymous>[ValueParameterDescriptorImpl]

'isProper' @ [80:41] ==> public final val isProper: Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'bounds' @ [82:13] ==> val bounds: List<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'isEmpty' @ [82:20] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'listOf' @ [83:20] ==> @InlineOnly public inline fun <T> listOf(): List<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'bounds' @ [85:30] ==> val bounds: List<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'any' @ [85:37] ==> public inline fun <T> Iterable<TypeBounds.Bound>.any(predicate: (TypeBounds.Bound) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Bound

'it' @ [85:43] ==> value-parameter it: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues.<anonymous>[ValueParameterDescriptorImpl]

'position' @ [85:46] ==> public final val position: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'isStrong' @ [85:55] ==> public open fun isStrong(): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPosition[SimpleFunctionDescriptorImpl]

'!' @ [86:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'hasStrongBound' @ [86:14] ==> val hasStrongBound: Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'listOf' @ [87:20] ==> @InlineOnly public inline fun <T> listOf(): List<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'filterBounds' @ [90:27] ==> private final fun filterBounds(bounds: Collection<TypeBounds.Bound>, kind: TypeBounds.BoundKind, errorValues: MutableCollection<KotlinType>? = ...): Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[SimpleFunctionDescriptorImpl]

'bounds' @ [90:40] ==> val bounds: List<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'EXACT_BOUND' @ [90:48] ==> enum entry EXACT_BOUND defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[FakeCallableDescriptorForObject]

'values' @ [90:61] ==> val values: LinkedHashSet<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'exactBounds' @ [91:23] ==> val exactBounds: Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'singleBestRepresentative' @ [91:35] ==> public fun Collection<KotlinType>.singleBestRepresentative(): KotlinType? defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'bestFit' @ [92:13] ==> val bestFit: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'tryPossibleAnswer' @ [93:17] ==> private final fun tryPossibleAnswer(bounds: Collection<TypeBounds.Bound>, possibleAnswer: KotlinType?): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[SimpleFunctionDescriptorImpl]

'bounds' @ [93:35] ==> val bounds: List<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'bestFit' @ [93:43] ==> val bestFit: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'listOf' @ [94:24] ==> public fun <T> listOf(element: KotlinType): List<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'bestFit' @ [94:31] ==> val bestFit: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'values' @ [97:9] ==> val values: LinkedHashSet<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'addAll' @ [97:16] ==> public open fun addAll(elements: Collection<KotlinType>): Boolean defined in java.util.LinkedHashSet[JavaMethodDescriptor]

'exactBounds' @ [97:23] ==> val exactBounds: Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'component1' @ [99:14] ==> public final operator fun component1(): List<KotlinType> defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [99:33] ==> public final operator fun component2(): List<KotlinType> defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'filterBounds' @ [100:17] ==> private final fun filterBounds(bounds: Collection<TypeBounds.Bound>, kind: TypeBounds.BoundKind, errorValues: MutableCollection<KotlinType>? = ...): Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[SimpleFunctionDescriptorImpl]

'bounds' @ [100:30] ==> val bounds: List<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'LOWER_BOUND' @ [100:38] ==> enum entry LOWER_BOUND defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[FakeCallableDescriptorForObject]

'values' @ [100:51] ==> val values: LinkedHashSet<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'partition' @ [100:59] ==> public inline fun <T> Iterable<KotlinType>.partition(predicate: (KotlinType) -> Boolean): Pair<List<KotlinType>, List<KotlinType>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'it' @ [100:71] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues.<anonymous>[ValueParameterDescriptorImpl]

'constructor' @ [100:74] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'commonSupertypeForNonDenotableTypes' @ [102:55] ==> @Nullable public open fun commonSupertypeForNonDenotableTypes(@NotNull types: (MutableCollection<(KotlinType..KotlinType?)>..Collection<(KotlinType..KotlinType?)>)): KotlinType? defined in org.jetbrains.kotlin.types.CommonSupertypes[JavaMethodDescriptor]

'generalLowerBounds' @ [102:91] ==> val generalLowerBounds: List<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'tryPossibleAnswer' @ [103:13] ==> private final fun tryPossibleAnswer(bounds: Collection<TypeBounds.Bound>, possibleAnswer: KotlinType?): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[SimpleFunctionDescriptorImpl]

'bounds' @ [103:31] ==> val bounds: List<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'superTypeOfLowerBounds' @ [103:39] ==> val superTypeOfLowerBounds: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'setOf' @ [104:20] ==> public fun <T> setOf(element: KotlinType): Set<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'superTypeOfLowerBounds' @ [104:26] ==> val superTypeOfLowerBounds: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'values' @ [106:9] ==> val values: LinkedHashSet<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'addIfNotNull' @ [106:16] ==> public fun <T : Any> MutableCollection<KotlinType>.addIfNotNull(t: KotlinType?): Unit defined in org.jetbrains.kotlin.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> KotlinType

'superTypeOfLowerBounds' @ [106:29] ==> val superTypeOfLowerBounds: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'commonSupertypeForNumberTypes' @ [112:44] ==> private final fun commonSupertypeForNumberTypes(numberLowerBounds: Collection<KotlinType>): KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[SimpleFunctionDescriptorImpl]

'numberLowerBounds' @ [112:74] ==> val numberLowerBounds: List<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'tryPossibleAnswer' @ [113:13] ==> private final fun tryPossibleAnswer(bounds: Collection<TypeBounds.Bound>, possibleAnswer: KotlinType?): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[SimpleFunctionDescriptorImpl]

'bounds' @ [113:31] ==> val bounds: List<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'superTypeOfNumberLowerBounds' @ [113:39] ==> val superTypeOfNumberLowerBounds: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'setOf' @ [114:20] ==> public fun <T> setOf(element: KotlinType): Set<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'superTypeOfNumberLowerBounds' @ [114:26] ==> val superTypeOfNumberLowerBounds: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'values' @ [116:9] ==> val values: LinkedHashSet<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'addIfNotNull' @ [116:16] ==> public fun <T : Any> MutableCollection<KotlinType>.addIfNotNull(t: KotlinType?): Unit defined in org.jetbrains.kotlin.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> KotlinType

'superTypeOfNumberLowerBounds' @ [116:29] ==> val superTypeOfNumberLowerBounds: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'superTypeOfLowerBounds' @ [118:13] ==> val superTypeOfLowerBounds: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'superTypeOfNumberLowerBounds' @ [118:47] ==> val superTypeOfNumberLowerBounds: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'commonSupertypeForNonDenotableTypes' @ [119:62] ==> @Nullable public open fun commonSupertypeForNonDenotableTypes(@NotNull types: (MutableCollection<(KotlinType..KotlinType?)>..Collection<(KotlinType..KotlinType?)>)): KotlinType? defined in org.jetbrains.kotlin.types.CommonSupertypes[JavaMethodDescriptor]

'listOf' @ [119:98] ==> public fun <T> listOf(vararg elements: KotlinType): List<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'superTypeOfLowerBounds' @ [119:105] ==> val superTypeOfLowerBounds: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'superTypeOfNumberLowerBounds' @ [119:129] ==> val superTypeOfNumberLowerBounds: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'tryPossibleAnswer' @ [120:17] ==> private final fun tryPossibleAnswer(bounds: Collection<TypeBounds.Bound>, possibleAnswer: KotlinType?): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[SimpleFunctionDescriptorImpl]

'bounds' @ [120:35] ==> val bounds: List<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'superTypeOfAllLowerBounds' @ [120:43] ==> val superTypeOfAllLowerBounds: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'setOf' @ [121:24] ==> public fun <T> setOf(element: KotlinType): Set<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'superTypeOfAllLowerBounds' @ [121:30] ==> val superTypeOfAllLowerBounds: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'filterBounds' @ [125:27] ==> private final fun filterBounds(bounds: Collection<TypeBounds.Bound>, kind: TypeBounds.BoundKind, errorValues: MutableCollection<KotlinType>? = ...): Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[SimpleFunctionDescriptorImpl]

'bounds' @ [125:40] ==> val bounds: List<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'UPPER_BOUND' @ [125:69] ==> enum entry UPPER_BOUND defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[FakeCallableDescriptorForObject]

'values' @ [125:82] ==> val values: LinkedHashSet<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'upperBounds' @ [126:13] ==> val upperBounds: Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'isNotEmpty' @ [126:25] ==> @InlineOnly public inline fun <T> Collection<KotlinType>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'intersectTypes' @ [127:61] ==> @Nullable public open fun intersectTypes(@NotNull typeChecker: KotlinTypeChecker, @NotNull types: (MutableCollection<(KotlinType..KotlinType?)>..Collection<(KotlinType..KotlinType?)>)): KotlinType? defined in org.jetbrains.kotlin.types.TypeIntersector[JavaMethodDescriptor]

'DEFAULT' @ [127:94] ==> public final val DEFAULT: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaPropertyDescriptor]

'upperBounds' @ [127:103] ==> val upperBounds: Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'intersectionOfUpperBounds' @ [128:17] ==> val intersectionOfUpperBounds: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'tryPossibleAnswer' @ [128:54] ==> private final fun tryPossibleAnswer(bounds: Collection<TypeBounds.Bound>, possibleAnswer: KotlinType?): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[SimpleFunctionDescriptorImpl]

'bounds' @ [128:72] ==> val bounds: List<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'intersectionOfUpperBounds' @ [128:80] ==> val intersectionOfUpperBounds: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'setOf' @ [129:24] ==> public fun <T> setOf(element: KotlinType): Set<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'intersectionOfUpperBounds' @ [129:30] ==> val intersectionOfUpperBounds: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'values' @ [133:9] ==> val values: LinkedHashSet<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'addAll' @ [133:16] ==> public open fun addAll(elements: Collection<KotlinType>): Boolean defined in java.util.LinkedHashSet[JavaMethodDescriptor]

'filterBounds' @ [133:23] ==> private final fun filterBounds(bounds: Collection<TypeBounds.Bound>, kind: TypeBounds.BoundKind, errorValues: MutableCollection<KotlinType>? = ...): Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[SimpleFunctionDescriptorImpl]

'bounds' @ [133:36] ==> val bounds: List<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'UPPER_BOUND' @ [133:65] ==> enum entry UPPER_BOUND defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[FakeCallableDescriptorForObject]

'values' @ [135:13] ==> val values: LinkedHashSet<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'size' @ [135:20] ==> public open val size: Int defined in java.util.LinkedHashSet[JavaPropertyDescriptor]

'typeVariable' @ [135:33] ==> public open val typeVariable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[PropertyDescriptorImpl]

'hasOnlyInputTypesAnnotation' @ [135:46] ==> public final fun hasOnlyInputTypesAnnotation(): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.TypeVariable[SimpleFunctionDescriptorImpl]

'!' @ [135:79] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'tryPossibleAnswer' @ [135:80] ==> private final fun tryPossibleAnswer(bounds: Collection<TypeBounds.Bound>, possibleAnswer: KotlinType?): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[SimpleFunctionDescriptorImpl]

'bounds' @ [135:98] ==> val bounds: List<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'values' @ [135:106] ==> val values: LinkedHashSet<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'first' @ [135:113] ==> public fun <T> Iterable<KotlinType>.first(): KotlinType defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'listOf' @ [135:130] ==> @InlineOnly public inline fun <T> listOf(): List<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'values' @ [137:16] ==> val values: LinkedHashSet<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.computeValues[LocalVariableDescriptor]

'!' @ [141:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'typeVariable' @ [141:14] ==> public open val typeVariable: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[PropertyDescriptorImpl]

'hasOnlyInputTypesAnnotation' @ [141:27] ==> public final fun hasOnlyInputTypesAnnotation(): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.TypeVariable[SimpleFunctionDescriptorImpl]

'bounds' @ [144:32] ==> value-parameter bounds: Collection<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.checkOnlyInputTypes[ValueParameterDescriptorImpl]

'filter' @ [144:39] ==> public inline fun <T> Iterable<TypeBounds.Bound>.filter(predicate: (TypeBounds.Bound) -> Boolean): List<TypeBounds.Bound> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Bound

'it' @ [144:48] ==> value-parameter it: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.checkOnlyInputTypes.<anonymous>[ValueParameterDescriptorImpl]

'isProper' @ [144:51] ==> public final val isProper: Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'it' @ [144:63] ==> value-parameter it: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.checkOnlyInputTypes.<anonymous>[ValueParameterDescriptorImpl]

'constrainingType' @ [144:66] ==> public final val constrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'constructor' @ [144:83] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'isDenotable' @ [144:95] ==> public final val TypeConstructor.isDenotable: Boolean[MyPropertyDescriptor]

'map' @ [144:109] ==> public inline fun <T, R> Iterable<TypeBounds.Bound>.map(transform: (TypeBounds.Bound) -> KotlinType): List<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Bound
    <R> -> KotlinType

'it' @ [144:115] ==> value-parameter it: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.checkOnlyInputTypes.<anonymous>[ValueParameterDescriptorImpl]

'constrainingType' @ [144:118] ==> public final val constrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'toSet' @ [144:137] ==> public fun <T> Iterable<KotlinType>.toSet(): Set<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'typesInBoundsSet' @ [146:13] ==> val typesInBoundsSet: Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.checkOnlyInputTypes[LocalVariableDescriptor]

'any' @ [146:30] ==> public inline fun <T> Iterable<KotlinType>.any(predicate: (KotlinType) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'DEFAULT' @ [146:54] ==> public final val DEFAULT: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaPropertyDescriptor]

'equalTypes' @ [146:62] ==> public abstract fun equalTypes(@NotNull p0: KotlinType, @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaMethodDescriptor]

'it' @ [146:73] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.checkOnlyInputTypes.<anonymous>[ValueParameterDescriptorImpl]

'possibleAnswer' @ [146:77] ==> value-parameter possibleAnswer: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.checkOnlyInputTypes[ValueParameterDescriptorImpl]

'filterBounds' @ [149:33] ==> private final fun filterBounds(bounds: Collection<TypeBounds.Bound>, kind: TypeBounds.BoundKind, errorValues: MutableCollection<KotlinType>? = ...): Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[SimpleFunctionDescriptorImpl]

'bounds' @ [149:46] ==> value-parameter bounds: Collection<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.checkOnlyInputTypes[ValueParameterDescriptorImpl]

'LOWER_BOUND' @ [149:54] ==> enum entry LOWER_BOUND defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[FakeCallableDescriptorForObject]

'filter' @ [149:67] ==> public inline fun <T> Iterable<KotlinType>.filter(predicate: (KotlinType) -> Boolean): List<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'it' @ [149:76] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.checkOnlyInputTypes.<anonymous>[ValueParameterDescriptorImpl]

'constructor' @ [149:79] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'commonSupertypeForNumberTypes' @ [150:44] ==> private final fun commonSupertypeForNumberTypes(numberLowerBounds: Collection<KotlinType>): KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[SimpleFunctionDescriptorImpl]

'numberLowerBounds' @ [150:74] ==> val numberLowerBounds: List<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.checkOnlyInputTypes[LocalVariableDescriptor]

'possibleAnswer' @ [151:13] ==> value-parameter possibleAnswer: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.checkOnlyInputTypes[ValueParameterDescriptorImpl]

'superTypeOfNumberLowerBounds' @ [151:31] ==> val superTypeOfNumberLowerBounds: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.checkOnlyInputTypes[LocalVariableDescriptor]

'possibleAnswer' @ [157:13] ==> value-parameter possibleAnswer: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.tryPossibleAnswer[ValueParameterDescriptorImpl]

'!' @ [159:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'possibleAnswer' @ [159:14] ==> value-parameter possibleAnswer: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.tryPossibleAnswer[ValueParameterDescriptorImpl]

'constructor' @ [159:29] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'isDenotable' @ [159:41] ==> public final val TypeConstructor.isDenotable: Boolean[MyPropertyDescriptor]

'!' @ [159:56] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'possibleAnswer' @ [159:57] ==> value-parameter possibleAnswer: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.tryPossibleAnswer[ValueParameterDescriptorImpl]

'isCaptured' @ [159:72] ==> public fun KotlinType.isCaptured(): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference[DeserializedSimpleFunctionDescriptor]

'!' @ [161:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'checkOnlyInputTypes' @ [161:14] ==> private final fun checkOnlyInputTypes(bounds: Collection<TypeBounds.Bound>, possibleAnswer: KotlinType): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[SimpleFunctionDescriptorImpl]

'bounds' @ [161:34] ==> value-parameter bounds: Collection<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.tryPossibleAnswer[ValueParameterDescriptorImpl]

'possibleAnswer' @ [161:42] ==> value-parameter possibleAnswer: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.tryPossibleAnswer[ValueParameterDescriptorImpl]

'bounds' @ [163:23] ==> value-parameter bounds: Collection<TypeBounds.Bound> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.tryPossibleAnswer[ValueParameterDescriptorImpl]

'when (bound.kind) {
                LOWER_BOUND -> if (!KotlinTypeChecker.DEFAULT.isSubtypeOf(bound.constrainingType, possibleAnswer)) {
                    return false
                }

                UPPER_BOUND -> if (!KotlinTypeChecker.DEFAULT.isSubtypeOf(possibleAnswer, bound.constrainingType)) {
                    return false
                }

                EXACT_BOUND -> if (!KotlinTypeChecker.DEFAULT.equalTypes(bound.constrainingType, possibleAnswer)) {
                    return false
                }
            }' @ [164:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'bound' @ [164:19] ==> val bound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.tryPossibleAnswer[LocalVariableDescriptor]

'kind' @ [164:25] ==> public final val kind: TypeBounds.BoundKind defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'LOWER_BOUND' @ [165:17] ==> enum entry LOWER_BOUND defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[FakeCallableDescriptorForObject]

'!' @ [165:36] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'DEFAULT' @ [165:55] ==> public final val DEFAULT: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaPropertyDescriptor]

'isSubtypeOf' @ [165:63] ==> public abstract fun isSubtypeOf(@NotNull p0: KotlinType, @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaMethodDescriptor]

'bound' @ [165:75] ==> val bound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.tryPossibleAnswer[LocalVariableDescriptor]

'constrainingType' @ [165:81] ==> public final val constrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'possibleAnswer' @ [165:99] ==> value-parameter possibleAnswer: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.tryPossibleAnswer[ValueParameterDescriptorImpl]

'UPPER_BOUND' @ [169:17] ==> enum entry UPPER_BOUND defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[FakeCallableDescriptorForObject]

'!' @ [169:36] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'DEFAULT' @ [169:55] ==> public final val DEFAULT: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaPropertyDescriptor]

'isSubtypeOf' @ [169:63] ==> public abstract fun isSubtypeOf(@NotNull p0: KotlinType, @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaMethodDescriptor]

'possibleAnswer' @ [169:75] ==> value-parameter possibleAnswer: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.tryPossibleAnswer[ValueParameterDescriptorImpl]

'bound' @ [169:91] ==> val bound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.tryPossibleAnswer[LocalVariableDescriptor]

'constrainingType' @ [169:97] ==> public final val constrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'EXACT_BOUND' @ [173:17] ==> enum entry EXACT_BOUND defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.BoundKind[FakeCallableDescriptorForObject]

'!' @ [173:36] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'DEFAULT' @ [173:55] ==> public final val DEFAULT: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaPropertyDescriptor]

'equalTypes' @ [173:63] ==> public abstract fun equalTypes(@NotNull p0: KotlinType, @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaMethodDescriptor]

'bound' @ [173:74] ==> val bound: TypeBounds.Bound defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.tryPossibleAnswer[LocalVariableDescriptor]

'constrainingType' @ [173:80] ==> public final val constrainingType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds.Bound[PropertyDescriptorImpl]

'possibleAnswer' @ [173:98] ==> value-parameter possibleAnswer: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.tryPossibleAnswer[ValueParameterDescriptorImpl]

'numberLowerBounds' @ [182:13] ==> value-parameter numberLowerBounds: Collection<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.commonSupertypeForNumberTypes[ValueParameterDescriptorImpl]

'isEmpty' @ [182:31] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.Collection[DeserializedSimpleFunctionDescriptor]

'getIntersectionOfSupertypes' @ [183:40] ==> private final fun getIntersectionOfSupertypes(types: Collection<KotlinType>): Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl[SimpleFunctionDescriptorImpl]

'numberLowerBounds' @ [183:68] ==> value-parameter numberLowerBounds: Collection<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.commonSupertypeForNumberTypes[ValueParameterDescriptorImpl]

'?:' @ [184:16] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KotlinType?, right: KotlinType?): KotlinType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KotlinType?

'getDefaultPrimitiveNumberType' @ [184:26] ==> @Nullable public open fun getDefaultPrimitiveNumberType(@NotNull p0: (MutableCollection<(KotlinType..KotlinType?)>..Collection<(KotlinType..KotlinType?)>)): KotlinType? defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'intersectionOfSupertypes' @ [184:56] ==> val intersectionOfSupertypes: Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.commonSupertypeForNumberTypes[LocalVariableDescriptor]

'commonSupertype' @ [185:34] ==> @NotNull public open fun commonSupertype(@NotNull types: (MutableCollection<(KotlinType..KotlinType?)>..Collection<(KotlinType..KotlinType?)>)): KotlinType defined in org.jetbrains.kotlin.types.CommonSupertypes[JavaMethodDescriptor]

'numberLowerBounds' @ [185:50] ==> value-parameter numberLowerBounds: Collection<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.commonSupertypeForNumberTypes[ValueParameterDescriptorImpl]

'HashSet' @ [189:27] ==> public constructor HashSet<E : (Any..Any?)>() defined in java.util.HashSet[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> KotlinType

'types' @ [190:22] ==> value-parameter types: Collection<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.getIntersectionOfSupertypes[ValueParameterDescriptorImpl]

'type' @ [191:30] ==> val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.getIntersectionOfSupertypes[LocalVariableDescriptor]

'constructor' @ [191:35] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'supertypes' @ [191:47] ==> public final val TypeConstructor.supertypes: Collection<(KotlinType..KotlinType?)>[MyPropertyDescriptor]

'if (upperBounds.isEmpty()) {
                upperBounds.addAll(supertypes)
            }
            else {
                upperBounds.retainAll(supertypes)
            }' @ [192:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Boolean, elseBranch: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Boolean

'upperBounds' @ [192:17] ==> val upperBounds: HashSet<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.getIntersectionOfSupertypes[LocalVariableDescriptor]

'isEmpty' @ [192:29] ==> public open fun isEmpty(): Boolean defined in java.util.HashSet[JavaMethodDescriptor]

'upperBounds' @ [193:17] ==> val upperBounds: HashSet<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.getIntersectionOfSupertypes[LocalVariableDescriptor]

'addAll' @ [193:29] ==> public open fun addAll(elements: Collection<KotlinType>): Boolean defined in java.util.HashSet[JavaMethodDescriptor]

'supertypes' @ [193:36] ==> val supertypes: Collection<(KotlinType..KotlinType?)> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.getIntersectionOfSupertypes[LocalVariableDescriptor]

'upperBounds' @ [196:17] ==> val upperBounds: HashSet<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.getIntersectionOfSupertypes[LocalVariableDescriptor]

'retainAll' @ [196:29] ==> public open fun retainAll(elements: Collection<KotlinType>): Boolean defined in java.util.HashSet[JavaMethodDescriptor]

'supertypes' @ [196:39] ==> val supertypes: Collection<(KotlinType..KotlinType?)> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.getIntersectionOfSupertypes[LocalVariableDescriptor]

'upperBounds' @ [199:16] ==> val upperBounds: HashSet<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBoundsImpl.getIntersectionOfSupertypes[LocalVariableDescriptor]

