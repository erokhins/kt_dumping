'ExpressionTypingVisitor' @ [57:76] ==> protected/*protected and package*/ constructor ExpressionTypingVisitor(@NotNull facade: ExpressionTypingInternals) defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingVisitor[JavaClassConstructorDescriptor]

'facade' @ [57:100] ==> value-parameter facade: ExpressionTypingInternals defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.<init>[ValueParameterDescriptorImpl]

'visitNamedFunction' @ [60:16] ==> public final fun visitNamedFunction(function: KtNamedFunction, context: ExpressionTypingContext, isDeclaration: Boolean, statementScope: LexicalWritableScope?): KotlinTypeInfo defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[SimpleFunctionDescriptorImpl]

'function' @ [60:35] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'data' @ [60:45] ==> value-parameter data: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'!' @ [69:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isDeclaration' @ [69:14] ==> value-parameter isDeclaration: Boolean defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'!' @ [71:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'function' @ [71:18] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'typeParameters' @ [71:27] ==> public final val KtNamedFunction.typeParameters: (MutableList<(KtTypeParameter..KtTypeParameter?)>..List<(KtTypeParameter..KtTypeParameter?)>)[MyPropertyDescriptor]

'isEmpty' @ [71:42] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'context' @ [72:17] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'trace' @ [72:25] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'report' @ [72:31] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'TYPE_PARAMETERS_NOT_ALLOWED' @ [72:38] ==> public final val TYPE_PARAMETERS_NOT_ALLOWED: (DiagnosticFactory0<(KtDeclaration..KtDeclaration?)>..DiagnosticFactory0<(KtDeclaration..KtDeclaration?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [72:66] ==> @NotNull public open fun on(@NotNull element: KtDeclaration): SimpleDiagnostic<(KtDeclaration..KtDeclaration?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'function' @ [72:69] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'function' @ [75:17] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'name' @ [75:26] ==> public final val KtNamedFunction.name: String?[MyPropertyDescriptor]

'context' @ [76:17] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'trace' @ [76:25] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'report' @ [76:31] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'ANONYMOUS_FUNCTION_WITH_NAME' @ [76:38] ==> public final val ANONYMOUS_FUNCTION_WITH_NAME: (DiagnosticFactory0<(PsiElement..PsiElement?)>..DiagnosticFactory0<(PsiElement..PsiElement?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [76:67] ==> @NotNull public open fun on(@NotNull element: PsiElement): SimpleDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'function' @ [76:70] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'nameIdentifier' @ [76:79] ==> public final val KtNamedFunction.nameIdentifier: PsiElement?[MyPropertyDescriptor]

'function' @ [79:31] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'valueParameters' @ [79:40] ==> public final val KtNamedFunction.valueParameters: (MutableList<(KtParameter..KtParameter?)>..List<(KtParameter..KtParameter?)>)[MyPropertyDescriptor]

'parameter' @ [80:21] ==> val parameter: (KtParameter..KtParameter?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[LocalVariableDescriptor]

'hasDefaultValue' @ [80:31] ==> public open fun hasDefaultValue(): Boolean defined in org.jetbrains.kotlin.psi.KtParameter[JavaMethodDescriptor]

'context' @ [81:21] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'trace' @ [81:29] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'report' @ [81:35] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'ANONYMOUS_FUNCTION_PARAMETER_WITH_DEFAULT_VALUE' @ [81:42] ==> public final val ANONYMOUS_FUNCTION_PARAMETER_WITH_DEFAULT_VALUE: (DiagnosticFactory0<(KtParameter..KtParameter?)>..DiagnosticFactory0<(KtParameter..KtParameter?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [81:90] ==> @NotNull public open fun on(@NotNull element: KtParameter): SimpleDiagnostic<(KtParameter..KtParameter?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'parameter' @ [81:93] ==> val parameter: (KtParameter..KtParameter?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[LocalVariableDescriptor]

'parameter' @ [83:21] ==> val parameter: (KtParameter..KtParameter?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[LocalVariableDescriptor]

'isVarArg' @ [83:31] ==> public final val KtParameter.isVarArg: Boolean[MyPropertyDescriptor]

'context' @ [84:21] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'trace' @ [84:29] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'report' @ [84:35] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'USELESS_VARARG_ON_PARAMETER' @ [84:42] ==> public final val USELESS_VARARG_ON_PARAMETER: (DiagnosticFactory0<(KtParameter..KtParameter?)>..DiagnosticFactory0<(KtParameter..KtParameter?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [84:70] ==> @NotNull public open fun on(@NotNull element: KtParameter): SimpleDiagnostic<(KtParameter..KtParameter?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'parameter' @ [84:73] ==> val parameter: (KtParameter..KtParameter?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[LocalVariableDescriptor]

'if (isDeclaration) {
            functionDescriptor = components.functionDescriptorResolver.resolveFunctionDescriptor(
                    context.scope.ownerDescriptor, context.scope, function, context.trace, context.dataFlowInfo)
            assert(statementScope != null) {
                "statementScope must be not null for function: " + function.name + " at location " + DiagnosticUtils.atLocation(function)
            }
            statementScope!!.addFunctionDescriptor(functionDescriptor)
        }
        else {
            functionDescriptor = components.functionDescriptorResolver.resolveFunctionExpressionDescriptor(
                    context.scope.ownerDescriptor, context.scope, function,
                    context.trace, context.dataFlowInfo, context.expectedType
            )
        }' @ [90:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'isDeclaration' @ [90:13] ==> value-parameter isDeclaration: Boolean defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'functionDescriptor' @ [91:13] ==> val functionDescriptor: SimpleFunctionDescriptor defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[LocalVariableDescriptor]

'components' @ [91:34] ==> protected/*protected and package*/ final val components: (ExpressionTypingComponents..ExpressionTypingComponents?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[JavaPropertyDescriptor]

'functionDescriptorResolver' @ [91:45] ==> public/*package*/ final var functionDescriptorResolver: (FunctionDescriptorResolver..FunctionDescriptorResolver?) defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingComponents[JavaPropertyDescriptor]

'resolveFunctionDescriptor' @ [91:72] ==> public final fun resolveFunctionDescriptor(containingDescriptor: DeclarationDescriptor, scope: LexicalScope, function: KtNamedFunction, trace: BindingTrace, dataFlowInfo: DataFlowInfo): SimpleFunctionDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[SimpleFunctionDescriptorImpl]

'context' @ [92:21] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'scope' @ [92:29] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'ownerDescriptor' @ [92:35] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'context' @ [92:52] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'scope' @ [92:60] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'function' @ [92:67] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'context' @ [92:77] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'trace' @ [92:85] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'context' @ [92:92] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [92:100] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'assert' @ [93:13] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'statementScope' @ [93:20] ==> value-parameter statementScope: LexicalWritableScope? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'+' @ [94:17] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'function' @ [94:68] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'name' @ [94:77] ==> public final val KtNamedFunction.name: String?[MyPropertyDescriptor]

'atLocation' @ [94:118] ==> public open fun atLocation(expression: (KtExpression..KtExpression?)): (String..String?) defined in org.jetbrains.kotlin.diagnostics.DiagnosticUtils[JavaMethodDescriptor]

'function' @ [94:129] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'statementScope' @ [96:13] ==> value-parameter statementScope: LexicalWritableScope? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'addFunctionDescriptor' @ [96:30] ==> public final fun addFunctionDescriptor(functionDescriptor: FunctionDescriptor): Unit defined in org.jetbrains.kotlin.resolve.scopes.LexicalWritableScope[DeserializedSimpleFunctionDescriptor]

'functionDescriptor' @ [96:52] ==> val functionDescriptor: SimpleFunctionDescriptor defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[LocalVariableDescriptor]

'functionDescriptor' @ [99:13] ==> val functionDescriptor: SimpleFunctionDescriptor defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[LocalVariableDescriptor]

'components' @ [99:34] ==> protected/*protected and package*/ final val components: (ExpressionTypingComponents..ExpressionTypingComponents?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[JavaPropertyDescriptor]

'functionDescriptorResolver' @ [99:45] ==> public/*package*/ final var functionDescriptorResolver: (FunctionDescriptorResolver..FunctionDescriptorResolver?) defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingComponents[JavaPropertyDescriptor]

'resolveFunctionExpressionDescriptor' @ [99:72] ==> public final fun resolveFunctionExpressionDescriptor(containingDescriptor: DeclarationDescriptor, scope: LexicalScope, function: KtNamedFunction, trace: BindingTrace, dataFlowInfo: DataFlowInfo, expectedFunctionType: KotlinType): SimpleFunctionDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[SimpleFunctionDescriptorImpl]

'context' @ [100:21] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'scope' @ [100:29] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'ownerDescriptor' @ [100:35] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'context' @ [100:52] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'scope' @ [100:60] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'function' @ [100:67] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'context' @ [101:21] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'trace' @ [101:29] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'context' @ [101:36] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [101:44] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'context' @ [101:58] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'expectedType' @ [101:66] ==> @NotNull public final val expectedType: KotlinType defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'forceResolveAllContents' @ [105:26] ==> public open fun forceResolveAllContents(@NotNull annotations: Annotations): Unit defined in org.jetbrains.kotlin.resolve.lazy.ForceResolveUtil[JavaMethodDescriptor]

'functionDescriptor' @ [105:50] ==> val functionDescriptor: SimpleFunctionDescriptor defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[LocalVariableDescriptor]

'annotations' @ [105:69] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.descriptors.SimpleFunctionDescriptor[DeserializedPropertyDescriptor]

'getFunctionInnerScope' @ [107:57] ==> @NotNull public open fun getFunctionInnerScope(@NotNull outerScope: LexicalScope, @NotNull descriptor: FunctionDescriptor, @NotNull trace: BindingTrace, @NotNull overloadChecker: OverloadChecker): LexicalScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorUtil[JavaMethodDescriptor]

'context' @ [107:79] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'scope' @ [107:87] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'functionDescriptor' @ [107:94] ==> val functionDescriptor: SimpleFunctionDescriptor defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[LocalVariableDescriptor]

'context' @ [107:114] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'trace' @ [107:122] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'components' @ [107:129] ==> protected/*protected and package*/ final val components: (ExpressionTypingComponents..ExpressionTypingComponents?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[JavaPropertyDescriptor]

'overloadChecker' @ [107:140] ==> public/*package*/ final var overloadChecker: (OverloadChecker..OverloadChecker?) defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingComponents[JavaPropertyDescriptor]

'if (!function.hasDeclaredReturnType() && !function.hasBlockBody()) {
            ForceResolveUtil.forceResolveAllContents(functionDescriptor.returnType)
        }
        else {
            components.expressionTypingServices.checkFunctionReturnType(
                    functionInnerScope, function, functionDescriptor, context.dataFlowInfo, null, context.trace
            )
        }' @ [108:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any?, elseBranch: Any?): Any?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any?

'!' @ [108:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'function' @ [108:14] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'hasDeclaredReturnType' @ [108:23] ==> @Override public open fun hasDeclaredReturnType(): Boolean defined in org.jetbrains.kotlin.psi.KtNamedFunction[JavaMethodDescriptor]

'!' @ [108:50] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'function' @ [108:51] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'hasBlockBody' @ [108:60] ==> @Override public open fun hasBlockBody(): Boolean defined in org.jetbrains.kotlin.psi.KtNamedFunction[JavaMethodDescriptor]

'forceResolveAllContents' @ [109:30] ==> @Nullable public open fun forceResolveAllContents(@Nullable type: KotlinType?): KotlinType? defined in org.jetbrains.kotlin.resolve.lazy.ForceResolveUtil[JavaMethodDescriptor]

'functionDescriptor' @ [109:54] ==> val functionDescriptor: SimpleFunctionDescriptor defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[LocalVariableDescriptor]

'returnType' @ [109:73] ==> public final val SimpleFunctionDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'components' @ [112:13] ==> protected/*protected and package*/ final val components: (ExpressionTypingComponents..ExpressionTypingComponents?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[JavaPropertyDescriptor]

'expressionTypingServices' @ [112:24] ==> public/*package*/ final var expressionTypingServices: (ExpressionTypingServices..ExpressionTypingServices?) defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingComponents[JavaPropertyDescriptor]

'checkFunctionReturnType' @ [112:49] ==> public open fun checkFunctionReturnType(@NotNull functionInnerScope: LexicalScope, @NotNull function: KtDeclarationWithBody, @NotNull functionDescriptor: FunctionDescriptor, @NotNull dataFlowInfo: DataFlowInfo, @Nullable expectedReturnType: KotlinType?, trace: (BindingTrace..BindingTrace?)): Unit defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingServices[JavaMethodDescriptor]

'functionInnerScope' @ [113:21] ==> val functionInnerScope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[LocalVariableDescriptor]

'function' @ [113:41] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'functionDescriptor' @ [113:51] ==> val functionDescriptor: SimpleFunctionDescriptor defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[LocalVariableDescriptor]

'context' @ [113:71] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [113:79] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'context' @ [113:99] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'trace' @ [113:107] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'components' @ [117:9] ==> protected/*protected and package*/ final val components: (ExpressionTypingComponents..ExpressionTypingComponents?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[JavaPropertyDescriptor]

'valueParameterResolver' @ [117:20] ==> public/*package*/ final var valueParameterResolver: (ValueParameterResolver..ValueParameterResolver?) defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingComponents[JavaPropertyDescriptor]

'resolveValueParameters' @ [117:43] ==> public final fun resolveValueParameters(valueParameters: List<KtParameter>, valueParameterDescriptors: List<ValueParameterDescriptor>, declaringScope: LexicalScope, dataFlowInfo: DataFlowInfo, trace: BindingTrace): Unit defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver[SimpleFunctionDescriptorImpl]

'function' @ [118:17] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'valueParameters' @ [118:26] ==> public final val KtNamedFunction.valueParameters: (MutableList<(KtParameter..KtParameter?)>..List<(KtParameter..KtParameter?)>)[MyPropertyDescriptor]

'functionDescriptor' @ [118:43] ==> val functionDescriptor: SimpleFunctionDescriptor defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[LocalVariableDescriptor]

'valueParameters' @ [118:62] ==> public final val SimpleFunctionDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'functionInnerScope' @ [118:79] ==> val functionInnerScope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[LocalVariableDescriptor]

'context' @ [118:99] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [118:107] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'context' @ [118:121] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'trace' @ [118:129] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'components' @ [121:9] ==> protected/*protected and package*/ final val components: (ExpressionTypingComponents..ExpressionTypingComponents?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[JavaPropertyDescriptor]

'modifiersChecker' @ [121:20] ==> public/*package*/ final var modifiersChecker: (ModifiersChecker..ModifiersChecker?) defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingComponents[JavaPropertyDescriptor]

'withTrace' @ [121:37] ==> @NotNull public open fun withTrace(@NotNull trace: BindingTrace): ModifiersChecker.ModifiersCheckingProcedure defined in org.jetbrains.kotlin.resolve.ModifiersChecker[JavaMethodDescriptor]

'context' @ [121:47] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'trace' @ [121:55] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'checkModifiersForLocalDeclaration' @ [121:62] ==> public open fun checkModifiersForLocalDeclaration(@NotNull modifierListOwner: KtDeclaration, @NotNull descriptor: DeclarationDescriptor): Unit defined in org.jetbrains.kotlin.resolve.ModifiersChecker.ModifiersCheckingProcedure[JavaMethodDescriptor]

'function' @ [121:96] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'functionDescriptor' @ [121:106] ==> val functionDescriptor: SimpleFunctionDescriptor defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[LocalVariableDescriptor]

'components' @ [122:9] ==> protected/*protected and package*/ final val components: (ExpressionTypingComponents..ExpressionTypingComponents?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[JavaPropertyDescriptor]

'identifierChecker' @ [122:20] ==> public/*package*/ final var identifierChecker: (IdentifierChecker..IdentifierChecker?) defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingComponents[JavaPropertyDescriptor]

'checkDeclaration' @ [122:38] ==> public abstract fun checkDeclaration(declaration: KtDeclaration, diagnosticHolder: DiagnosticSink): Unit defined in org.jetbrains.kotlin.resolve.IdentifierChecker[SimpleFunctionDescriptorImpl]

'function' @ [122:55] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'context' @ [122:65] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'trace' @ [122:73] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'components' @ [123:9] ==> protected/*protected and package*/ final val components: (ExpressionTypingComponents..ExpressionTypingComponents?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[JavaPropertyDescriptor]

'declarationsCheckerBuilder' @ [123:20] ==> public/*package*/ final var declarationsCheckerBuilder: (DeclarationsCheckerBuilder..DeclarationsCheckerBuilder?) defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingComponents[JavaPropertyDescriptor]

'withTrace' @ [123:47] ==> public final fun withTrace(trace: BindingTrace): DeclarationsChecker defined in org.jetbrains.kotlin.resolve.DeclarationsCheckerBuilder[SimpleFunctionDescriptorImpl]

'context' @ [123:57] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'trace' @ [123:65] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'checkFunction' @ [123:72] ==> public final fun checkFunction(function: KtNamedFunction, functionDescriptor: SimpleFunctionDescriptor): Unit defined in org.jetbrains.kotlin.resolve.DeclarationsChecker[SimpleFunctionDescriptorImpl]

'function' @ [123:86] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'functionDescriptor' @ [123:96] ==> val functionDescriptor: SimpleFunctionDescriptor defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[LocalVariableDescriptor]

'if (isDeclaration) {
            createTypeInfo(components.dataFlowAnalyzer.checkStatementType(function, context), context)
        }
        else {
            val expectedType = context.expectedType

            val functionalTypeExpected = expectedType.isBuiltinFunctionalType()
            val suspendFunctionTypeExpected = expectedType.isSuspendFunctionType()

            val resultType = functionDescriptor.createFunctionType(suspendFunctionTypeExpected)

            if (USE_NEW_INFERENCE && functionalTypeExpected)
                createTypeInfo(resultType, context)
            else
                components.dataFlowAnalyzer.createCheckedTypeInfo(resultType, context, function)
        }' @ [125:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinTypeInfo, elseBranch: KotlinTypeInfo): KotlinTypeInfo[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinTypeInfo

'isDeclaration' @ [125:20] ==> value-parameter isDeclaration: Boolean defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'createTypeInfo' @ [126:13] ==> public fun createTypeInfo(type: KotlinType?, context: ResolutionContext<*>): KotlinTypeInfo defined in org.jetbrains.kotlin.types.expressions.typeInfoFactory in file TypeInfoFactory.kt[SimpleFunctionDescriptorImpl]

'components' @ [126:28] ==> protected/*protected and package*/ final val components: (ExpressionTypingComponents..ExpressionTypingComponents?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[JavaPropertyDescriptor]

'dataFlowAnalyzer' @ [126:39] ==> public/*package*/ final var dataFlowAnalyzer: (DataFlowAnalyzer..DataFlowAnalyzer?) defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingComponents[JavaPropertyDescriptor]

'checkStatementType' @ [126:56] ==> @Nullable public open fun checkStatementType(@NotNull expression: KtExpression, @NotNull context: raw (ResolutionContext<(ResolutionContext<*>..ResolutionContext<*>?)>..ResolutionContext<out (ResolutionContext<*>..ResolutionContext<*>?)>)): KotlinType? defined in org.jetbrains.kotlin.types.expressions.DataFlowAnalyzer[JavaMethodDescriptor]

'function' @ [126:75] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'context' @ [126:85] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'context' @ [126:95] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'context' @ [129:32] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'expectedType' @ [129:40] ==> @NotNull public final val expectedType: KotlinType defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'expectedType' @ [131:42] ==> val expectedType: KotlinType defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[LocalVariableDescriptor]

'isBuiltinFunctionalType' @ [131:55] ==> private final fun KotlinType.isBuiltinFunctionalType(): Boolean defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[SimpleFunctionDescriptorImpl]

'expectedType' @ [132:47] ==> val expectedType: KotlinType defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[LocalVariableDescriptor]

'isSuspendFunctionType' @ [132:60] ==> private final fun KotlinType.isSuspendFunctionType(): Boolean defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[SimpleFunctionDescriptorImpl]

'functionDescriptor' @ [134:30] ==> val functionDescriptor: SimpleFunctionDescriptor defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[LocalVariableDescriptor]

'createFunctionType' @ [134:49] ==> private final fun SimpleFunctionDescriptor.createFunctionType(suspendFunction: Boolean = ...): KotlinType? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[SimpleFunctionDescriptorImpl]

'suspendFunctionTypeExpected' @ [134:68] ==> val suspendFunctionTypeExpected: Boolean defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[LocalVariableDescriptor]

'if (USE_NEW_INFERENCE && functionalTypeExpected)
                createTypeInfo(resultType, context)
            else
                components.dataFlowAnalyzer.createCheckedTypeInfo(resultType, context, function)' @ [136:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinTypeInfo, elseBranch: KotlinTypeInfo): KotlinTypeInfo[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinTypeInfo

'USE_NEW_INFERENCE' @ [136:17] ==> public val USE_NEW_INFERENCE: Boolean defined in org.jetbrains.kotlin.resolve.calls[DeserializedPropertyDescriptor]

'functionalTypeExpected' @ [136:38] ==> val functionalTypeExpected: Boolean defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[LocalVariableDescriptor]

'createTypeInfo' @ [137:17] ==> public fun createTypeInfo(type: KotlinType?, context: ResolutionContext<*>): KotlinTypeInfo defined in org.jetbrains.kotlin.types.expressions.typeInfoFactory in file TypeInfoFactory.kt[SimpleFunctionDescriptorImpl]

'resultType' @ [137:32] ==> val resultType: KotlinType? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[LocalVariableDescriptor]

'context' @ [137:44] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'components' @ [139:17] ==> protected/*protected and package*/ final val components: (ExpressionTypingComponents..ExpressionTypingComponents?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[JavaPropertyDescriptor]

'dataFlowAnalyzer' @ [139:28] ==> public/*package*/ final var dataFlowAnalyzer: (DataFlowAnalyzer..DataFlowAnalyzer?) defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingComponents[JavaPropertyDescriptor]

'createCheckedTypeInfo' @ [139:45] ==> @NotNull public open fun createCheckedTypeInfo(@Nullable type: KotlinType?, @NotNull context: ResolutionContext<*>, @NotNull expression: KtExpression): KotlinTypeInfo defined in org.jetbrains.kotlin.types.expressions.DataFlowAnalyzer[JavaMethodDescriptor]

'resultType' @ [139:67] ==> val resultType: KotlinType? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[LocalVariableDescriptor]

'context' @ [139:79] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'function' @ [139:88] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitNamedFunction[ValueParameterDescriptorImpl]

'createFunctionType' @ [144:16] ==> @JvmOverloads public fun createFunctionType(builtIns: KotlinBuiltIns, annotations: Annotations, receiverType: KotlinType?, parameterTypes: List<KotlinType>, parameterNames: List<Name>?, returnType: KotlinType, suspendFunction: Boolean = ...): SimpleType defined in org.jetbrains.kotlin.builtins[DeserializedSimpleFunctionDescriptor]

'components' @ [145:17] ==> protected/*protected and package*/ final val components: (ExpressionTypingComponents..ExpressionTypingComponents?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[JavaPropertyDescriptor]

'builtIns' @ [145:28] ==> public/*package*/ final var builtIns: (KotlinBuiltIns..KotlinBuiltIns?) defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingComponents[JavaPropertyDescriptor]

'EMPTY' @ [146:29] ==> public final val EMPTY: Annotations defined in org.jetbrains.kotlin.descriptors.annotations.Annotations.Companion[DeserializedPropertyDescriptor]

'extensionReceiverParameter' @ [147:17] ==> public final val SimpleFunctionDescriptor.extensionReceiverParameter: ReceiverParameterDescriptor?[MyPropertyDescriptor]

'type' @ [147:45] ==> public final val ReceiverParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'valueParameters' @ [148:17] ==> public final val SimpleFunctionDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'map' @ [148:33] ==> public inline fun <T, R> Iterable<(ValueParameterDescriptor..ValueParameterDescriptor?)>.map(transform: ((ValueParameterDescriptor..ValueParameterDescriptor?)) -> KotlinType): List<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)
    <R> -> KotlinType

'it' @ [148:39] ==> value-parameter it: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.createFunctionType.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [148:42] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'returnType' @ [150:17] ==> public final val SimpleFunctionDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'suspendFunction' @ [151:35] ==> value-parameter suspendFunction: Boolean = ... defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.createFunctionType[ValueParameterDescriptorImpl]

'checkReservedYieldBeforeLambda' @ [156:9] ==> public fun checkReservedYieldBeforeLambda(element: PsiElement, sink: DiagnosticSink): Unit defined in org.jetbrains.kotlin.psi.psiUtil in file ktPsiUtil.kt[SimpleFunctionDescriptorImpl]

'expression' @ [156:40] ==> value-parameter expression: KtLambdaExpression defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[ValueParameterDescriptorImpl]

'context' @ [156:52] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[ValueParameterDescriptorImpl]

'trace' @ [156:60] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'!' @ [157:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'expression' @ [157:14] ==> value-parameter expression: KtLambdaExpression defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[ValueParameterDescriptorImpl]

'functionLiteral' @ [157:25] ==> public final val KtLambdaExpression.functionLiteral: KtFunctionLiteral[MyPropertyDescriptor]

'hasBody' @ [157:41] ==> @Override public open fun hasBody(): Boolean defined in org.jetbrains.kotlin.psi.KtFunctionLiteral[JavaMethodDescriptor]

'context' @ [159:28] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[ValueParameterDescriptorImpl]

'expectedType' @ [159:36] ==> @NotNull public final val expectedType: KotlinType defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'expectedType' @ [160:36] ==> val expectedType: KotlinType defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[LocalVariableDescriptor]

'isBuiltinFunctionalType' @ [160:49] ==> private final fun KotlinType.isBuiltinFunctionalType(): Boolean defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[SimpleFunctionDescriptorImpl]

'expectedType' @ [161:43] ==> val expectedType: KotlinType defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[LocalVariableDescriptor]

'isSuspendFunctionType' @ [161:56] ==> private final fun KotlinType.isSuspendFunctionType(): Boolean defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[SimpleFunctionDescriptorImpl]

'createFunctionLiteralDescriptor' @ [163:34] ==> private final fun createFunctionLiteralDescriptor(expression: KtLambdaExpression, context: ExpressionTypingContext): AnonymousFunctionDescriptor defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[SimpleFunctionDescriptorImpl]

'expression' @ [163:66] ==> value-parameter expression: KtLambdaExpression defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[ValueParameterDescriptorImpl]

'context' @ [163:78] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[ValueParameterDescriptorImpl]

'expression' @ [164:9] ==> value-parameter expression: KtLambdaExpression defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[ValueParameterDescriptorImpl]

'valueParameters' @ [164:20] ==> public final val KtLambdaExpression.valueParameters: (MutableList<(KtParameter..KtParameter?)>..List<(KtParameter..KtParameter?)>)[MyPropertyDescriptor]

'forEach' @ [164:36] ==> @HidesMembers public inline fun <T> Iterable<(KtParameter..KtParameter?)>.forEach(action: ((KtParameter..KtParameter?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtParameter..org.jetbrains.kotlin.psi.KtParameter?)

'components' @ [165:13] ==> protected/*protected and package*/ final val components: (ExpressionTypingComponents..ExpressionTypingComponents?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[JavaPropertyDescriptor]

'identifierChecker' @ [165:24] ==> public/*package*/ final var identifierChecker: (IdentifierChecker..IdentifierChecker?) defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingComponents[JavaPropertyDescriptor]

'checkDeclaration' @ [165:42] ==> public abstract fun checkDeclaration(declaration: KtDeclaration, diagnosticHolder: DiagnosticSink): Unit defined in org.jetbrains.kotlin.resolve.IdentifierChecker[SimpleFunctionDescriptorImpl]

'it' @ [165:59] ==> value-parameter it: (KtParameter..KtParameter?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression.<anonymous>[ValueParameterDescriptorImpl]

'context' @ [165:63] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[ValueParameterDescriptorImpl]

'trace' @ [165:71] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'UnderscoreChecker' @ [166:13] ==> public object UnderscoreChecker : DeclarationChecker defined in org.jetbrains.kotlin.resolve.checkers in file UnderscoreChecker.kt[FakeCallableDescriptorForObject]

'checkNamed' @ [166:31] ==> @JvmOverloads public final fun checkNamed(declaration: KtNamedDeclaration, diagnosticHolder: DiagnosticSink, languageVersionSettings: LanguageVersionSettings, allowSingleUnderscore: Boolean = ...): Unit defined in org.jetbrains.kotlin.resolve.checkers.UnderscoreChecker[SimpleFunctionDescriptorImpl]

'it' @ [166:42] ==> value-parameter it: (KtParameter..KtParameter?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression.<anonymous>[ValueParameterDescriptorImpl]

'context' @ [166:46] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[ValueParameterDescriptorImpl]

'trace' @ [166:54] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'components' @ [166:61] ==> protected/*protected and package*/ final val components: (ExpressionTypingComponents..ExpressionTypingComponents?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[JavaPropertyDescriptor]

'languageVersionSettings' @ [166:72] ==> public/*package*/ final var languageVersionSettings: (LanguageVersionSettings..LanguageVersionSettings?) defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingComponents[JavaPropertyDescriptor]

'computeReturnType' @ [168:30] ==> private final fun computeReturnType(expression: KtLambdaExpression, context: ExpressionTypingContext, functionDescriptor: SimpleFunctionDescriptorImpl, functionTypeExpected: Boolean): KotlinType defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[SimpleFunctionDescriptorImpl]

'expression' @ [168:48] ==> value-parameter expression: KtLambdaExpression defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[ValueParameterDescriptorImpl]

'context' @ [168:60] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[ValueParameterDescriptorImpl]

'functionDescriptor' @ [168:69] ==> val functionDescriptor: AnonymousFunctionDescriptor defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[LocalVariableDescriptor]

'functionTypeExpected' @ [168:89] ==> val functionTypeExpected: Boolean defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[LocalVariableDescriptor]

'functionDescriptor' @ [169:9] ==> val functionDescriptor: AnonymousFunctionDescriptor defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[LocalVariableDescriptor]

'setReturnType' @ [169:28] ==> public open fun setReturnType(@NotNull p0: KotlinType): Unit defined in org.jetbrains.kotlin.descriptors.impl.AnonymousFunctionDescriptor[JavaMethodDescriptor]

'safeReturnType' @ [169:42] ==> val safeReturnType: KotlinType defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[LocalVariableDescriptor]

'functionDescriptor' @ [171:26] ==> val functionDescriptor: AnonymousFunctionDescriptor defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[LocalVariableDescriptor]

'createFunctionType' @ [171:45] ==> private final fun SimpleFunctionDescriptor.createFunctionType(suspendFunction: Boolean = ...): KotlinType? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[SimpleFunctionDescriptorImpl]

'suspendFunctionTypeExpected' @ [171:64] ==> val suspendFunctionTypeExpected: Boolean defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[LocalVariableDescriptor]

'functionTypeExpected' @ [172:13] ==> val functionTypeExpected: Boolean defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[LocalVariableDescriptor]

'createTypeInfo' @ [174:20] ==> public fun createTypeInfo(type: KotlinType?, context: ResolutionContext<*>): KotlinTypeInfo defined in org.jetbrains.kotlin.types.expressions.typeInfoFactory in file TypeInfoFactory.kt[SimpleFunctionDescriptorImpl]

'resultType' @ [174:35] ==> val resultType: KotlinType defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[LocalVariableDescriptor]

'context' @ [174:47] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[ValueParameterDescriptorImpl]

'components' @ [177:16] ==> protected/*protected and package*/ final val components: (ExpressionTypingComponents..ExpressionTypingComponents?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[JavaPropertyDescriptor]

'dataFlowAnalyzer' @ [177:27] ==> public/*package*/ final var dataFlowAnalyzer: (DataFlowAnalyzer..DataFlowAnalyzer?) defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingComponents[JavaPropertyDescriptor]

'createCheckedTypeInfo' @ [177:44] ==> @NotNull public open fun createCheckedTypeInfo(@Nullable type: KotlinType?, @NotNull context: ResolutionContext<*>, @NotNull expression: KtExpression): KotlinTypeInfo defined in org.jetbrains.kotlin.types.expressions.DataFlowAnalyzer[JavaMethodDescriptor]

'resultType' @ [177:66] ==> val resultType: KotlinType defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[LocalVariableDescriptor]

'context' @ [177:78] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[ValueParameterDescriptorImpl]

'expression' @ [177:87] ==> value-parameter expression: KtLambdaExpression defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.visitLambdaExpression[ValueParameterDescriptorImpl]

'checkReservedPrefixWord' @ [181:9] ==> public fun checkReservedPrefixWord(sink: DiagnosticSink, element: PsiElement, word: String, message: String): Unit defined in org.jetbrains.kotlin.psi.psiUtil in file ktPsiUtil.kt[SimpleFunctionDescriptorImpl]

'context' @ [181:33] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.checkReservedYield[ValueParameterDescriptorImpl]

'trace' @ [181:41] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'expression' @ [181:48] ==> value-parameter expression: PsiElement defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.checkReservedYield[ValueParameterDescriptorImpl]

'expression' @ [188:31] ==> value-parameter expression: KtLambdaExpression defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.createFunctionLiteralDescriptor[ValueParameterDescriptorImpl]

'functionLiteral' @ [188:42] ==> public final val KtLambdaExpression.functionLiteral: KtFunctionLiteral[MyPropertyDescriptor]

'AnonymousFunctionDescriptor' @ [189:34] ==> public constructor AnonymousFunctionDescriptor(@NotNull containingDeclaration: DeclarationDescriptor, @NotNull annotations: Annotations, @NotNull kind: CallableMemberDescriptor.Kind, @NotNull source: SourceElement, isSuspend: Boolean) defined in org.jetbrains.kotlin.descriptors.impl.AnonymousFunctionDescriptor[JavaClassConstructorDescriptor]

'context' @ [190:17] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.createFunctionLiteralDescriptor[ValueParameterDescriptorImpl]

'scope' @ [190:25] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'ownerDescriptor' @ [190:31] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'components' @ [191:17] ==> protected/*protected and package*/ final val components: (ExpressionTypingComponents..ExpressionTypingComponents?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[JavaPropertyDescriptor]

'annotationResolver' @ [191:28] ==> public/*package*/ final var annotationResolver: (AnnotationResolver..AnnotationResolver?) defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingComponents[JavaPropertyDescriptor]

'resolveAnnotationsWithArguments' @ [191:47] ==> public final fun resolveAnnotationsWithArguments(scope: LexicalScope, annotationEntries: @JvmSuppressWildcards List<KtAnnotationEntry>, trace: BindingTrace): Annotations defined in org.jetbrains.kotlin.resolve.AnnotationResolver[SimpleFunctionDescriptorImpl]

'context' @ [191:79] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.createFunctionLiteralDescriptor[ValueParameterDescriptorImpl]

'scope' @ [191:87] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'expression' @ [191:94] ==> value-parameter expression: KtLambdaExpression defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.createFunctionLiteralDescriptor[ValueParameterDescriptorImpl]

'getAnnotationEntries' @ [191:105] ==> public fun KtExpression.getAnnotationEntries(): List<KtAnnotationEntry> defined in org.jetbrains.kotlin.psi.psiUtil in file ktPsiUtil.kt[SimpleFunctionDescriptorImpl]

'context' @ [191:129] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.createFunctionLiteralDescriptor[ValueParameterDescriptorImpl]

'trace' @ [191:137] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'DECLARATION' @ [192:47] ==> enum entry DECLARATION defined in org.jetbrains.kotlin.descriptors.CallableMemberDescriptor.Kind[FakeCallableDescriptorForObject]

'functionLiteral' @ [192:60] ==> val functionLiteral: KtFunctionLiteral defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.createFunctionLiteralDescriptor[LocalVariableDescriptor]

'toSourceElement' @ [192:76] ==> public fun KtPureElement?.toSourceElement(): SourceElement defined in org.jetbrains.kotlin.resolve.source in file KotlinSourceElement.kt[SimpleFunctionDescriptorImpl]

'context' @ [193:17] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.createFunctionLiteralDescriptor[ValueParameterDescriptorImpl]

'expectedType' @ [193:25] ==> @NotNull public final val expectedType: KotlinType defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'isSuspendFunctionType' @ [193:38] ==> private final fun KotlinType.isSuspendFunctionType(): Boolean defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[SimpleFunctionDescriptorImpl]

'components' @ [195:9] ==> protected/*protected and package*/ final val components: (ExpressionTypingComponents..ExpressionTypingComponents?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[JavaPropertyDescriptor]

'functionDescriptorResolver' @ [195:20] ==> public/*package*/ final var functionDescriptorResolver: (FunctionDescriptorResolver..FunctionDescriptorResolver?) defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingComponents[JavaPropertyDescriptor]

'initializeFunctionDescriptorAndExplicitReturnType' @ [196:17] ==> public final fun initializeFunctionDescriptorAndExplicitReturnType(containingDescriptor: DeclarationDescriptor, scope: LexicalScope, function: KtFunction, functionDescriptor: SimpleFunctionDescriptorImpl, trace: BindingTrace, expectedFunctionType: KotlinType): Unit defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[SimpleFunctionDescriptorImpl]

'context' @ [196:67] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.createFunctionLiteralDescriptor[ValueParameterDescriptorImpl]

'scope' @ [196:75] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'ownerDescriptor' @ [196:81] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'context' @ [196:98] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.createFunctionLiteralDescriptor[ValueParameterDescriptorImpl]

'scope' @ [196:106] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'functionLiteral' @ [196:113] ==> val functionLiteral: KtFunctionLiteral defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.createFunctionLiteralDescriptor[LocalVariableDescriptor]

'functionDescriptor' @ [197:67] ==> val functionDescriptor: AnonymousFunctionDescriptor defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.createFunctionLiteralDescriptor[LocalVariableDescriptor]

'context' @ [197:87] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.createFunctionLiteralDescriptor[ValueParameterDescriptorImpl]

'trace' @ [197:95] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'context' @ [197:102] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.createFunctionLiteralDescriptor[ValueParameterDescriptorImpl]

'expectedType' @ [197:110] ==> @NotNull public final val expectedType: KotlinType defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'functionDescriptor' @ [198:37] ==> val functionDescriptor: AnonymousFunctionDescriptor defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.createFunctionLiteralDescriptor[LocalVariableDescriptor]

'valueParameters' @ [198:56] ==> public final val AnonymousFunctionDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'forceResolveAllContents' @ [199:30] ==> public open fun forceResolveAllContents(@NotNull annotations: Annotations): Unit defined in org.jetbrains.kotlin.resolve.lazy.ForceResolveUtil[JavaMethodDescriptor]

'parameterDescriptor' @ [199:54] ==> val parameterDescriptor: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.createFunctionLiteralDescriptor[LocalVariableDescriptor]

'annotations' @ [199:74] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'recordFunctionDeclarationToDescriptor' @ [201:29] ==> public open fun recordFunctionDeclarationToDescriptor(@NotNull trace: BindingTrace, @NotNull psiElement: PsiElement, @NotNull function: SimpleFunctionDescriptor): Unit defined in org.jetbrains.kotlin.resolve.BindingContextUtils[JavaMethodDescriptor]

'context' @ [201:67] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.createFunctionLiteralDescriptor[ValueParameterDescriptorImpl]

'trace' @ [201:75] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'functionLiteral' @ [201:82] ==> val functionLiteral: KtFunctionLiteral defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.createFunctionLiteralDescriptor[LocalVariableDescriptor]

'functionDescriptor' @ [201:99] ==> val functionDescriptor: AnonymousFunctionDescriptor defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.createFunctionLiteralDescriptor[LocalVariableDescriptor]

'functionDescriptor' @ [202:16] ==> val functionDescriptor: AnonymousFunctionDescriptor defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.createFunctionLiteralDescriptor[LocalVariableDescriptor]

'!' @ [206:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'noExpectedType' @ [206:14] ==> public open fun noExpectedType(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'this' @ [206:29] ==> <this> defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.isBuiltinFunctionalType[ReceiverParameterDescriptorImpl]

'isBuiltinFunctionalType' @ [206:38] ==> public val KotlinType.isBuiltinFunctionalType: Boolean defined in org.jetbrains.kotlin.builtins[DeserializedPropertyDescriptor]

'!' @ [209:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'noExpectedType' @ [209:14] ==> public open fun noExpectedType(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'this' @ [209:29] ==> <this> defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.isSuspendFunctionType[ReceiverParameterDescriptorImpl]

'isSuspendFunctionType' @ [209:38] ==> public val KotlinType.isSuspendFunctionType: Boolean defined in org.jetbrains.kotlin.builtins[DeserializedPropertyDescriptor]

'if (functionTypeExpected) context.expectedType.getReturnTypeFromFunctionType() else null' @ [217:34] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType?, elseBranch: KotlinType?): KotlinType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType?

'functionTypeExpected' @ [217:38] ==> value-parameter functionTypeExpected: Boolean defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnType[ValueParameterDescriptorImpl]

'context' @ [217:60] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnType[ValueParameterDescriptorImpl]

'expectedType' @ [217:68] ==> @NotNull public final val expectedType: KotlinType defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'getReturnTypeFromFunctionType' @ [217:81] ==> public fun KotlinType.getReturnTypeFromFunctionType(): KotlinType defined in org.jetbrains.kotlin.builtins[DeserializedSimpleFunctionDescriptor]

'computeUnsafeReturnType' @ [218:26] ==> private final fun computeUnsafeReturnType(expression: KtLambdaExpression, context: ExpressionTypingContext, functionDescriptor: SimpleFunctionDescriptorImpl, expectedReturnType: KotlinType?): KotlinType? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[SimpleFunctionDescriptorImpl]

'expression' @ [218:50] ==> value-parameter expression: KtLambdaExpression defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnType[ValueParameterDescriptorImpl]

'context' @ [218:62] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnType[ValueParameterDescriptorImpl]

'functionDescriptor' @ [218:71] ==> value-parameter functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnType[ValueParameterDescriptorImpl]

'expectedReturnType' @ [218:91] ==> val expectedReturnType: KotlinType? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnType[LocalVariableDescriptor]

'!' @ [220:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'expression' @ [220:14] ==> value-parameter expression: KtLambdaExpression defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnType[ValueParameterDescriptorImpl]

'functionLiteral' @ [220:25] ==> public final val KtLambdaExpression.functionLiteral: KtFunctionLiteral[MyPropertyDescriptor]

'hasDeclaredReturnType' @ [220:41] ==> @Override public open fun hasDeclaredReturnType(): Boolean defined in org.jetbrains.kotlin.psi.KtFunctionLiteral[JavaMethodDescriptor]

'functionTypeExpected' @ [220:68] ==> value-parameter functionTypeExpected: Boolean defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnType[ValueParameterDescriptorImpl]

'!' @ [221:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'noExpectedType' @ [221:28] ==> public open fun noExpectedType(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'expectedReturnType' @ [221:43] ==> val expectedReturnType: KotlinType? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnType[LocalVariableDescriptor]

'isUnit' @ [221:83] ==> public open fun isUnit(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'expectedReturnType' @ [221:90] ==> val expectedReturnType: KotlinType? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnType[LocalVariableDescriptor]

'components' @ [222:24] ==> protected/*protected and package*/ final val components: (ExpressionTypingComponents..ExpressionTypingComponents?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[JavaPropertyDescriptor]

'builtIns' @ [222:35] ==> public/*package*/ final var builtIns: (KotlinBuiltIns..KotlinBuiltIns?) defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingComponents[JavaPropertyDescriptor]

'unitType' @ [222:44] ==> public final val KotlinBuiltIns.unitType: SimpleType[MyPropertyDescriptor]

'returnType' @ [225:16] ==> val returnType: KotlinType? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnType[LocalVariableDescriptor]

'CANT_INFER_FUNCTION_PARAM_TYPE' @ [225:30] ==> public final val CANT_INFER_FUNCTION_PARAM_TYPE: (SimpleType..SimpleType?) defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'expression' @ [234:31] ==> value-parameter expression: KtLambdaExpression defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeUnsafeReturnType[ValueParameterDescriptorImpl]

'functionLiteral' @ [234:42] ==> public final val KtLambdaExpression.functionLiteral: KtFunctionLiteral[MyPropertyDescriptor]

'expectedReturnType' @ [236:28] ==> value-parameter expectedReturnType: KotlinType? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeUnsafeReturnType[ValueParameterDescriptorImpl]

'NO_EXPECTED_TYPE' @ [236:50] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'getFunctionInnerScope' @ [237:57] ==> @NotNull public open fun getFunctionInnerScope(@NotNull outerScope: LexicalScope, @NotNull descriptor: FunctionDescriptor, @NotNull trace: BindingTrace, @NotNull overloadChecker: OverloadChecker): LexicalScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorUtil[JavaMethodDescriptor]

'context' @ [237:79] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeUnsafeReturnType[ValueParameterDescriptorImpl]

'scope' @ [237:87] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'functionDescriptor' @ [237:94] ==> value-parameter functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeUnsafeReturnType[ValueParameterDescriptorImpl]

'context' @ [237:114] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeUnsafeReturnType[ValueParameterDescriptorImpl]

'trace' @ [237:122] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'components' @ [237:129] ==> protected/*protected and package*/ final val components: (ExpressionTypingComponents..ExpressionTypingComponents?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[JavaPropertyDescriptor]

'overloadChecker' @ [237:140] ==> public/*package*/ final var overloadChecker: (OverloadChecker..OverloadChecker?) defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingComponents[JavaPropertyDescriptor]

'context' @ [238:26] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeUnsafeReturnType[ValueParameterDescriptorImpl]

'replaceScope' @ [238:34] ==> @NotNull public open fun replaceScope(@NotNull newScope: LexicalScope): ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaMethodDescriptor]

'functionInnerScope' @ [238:47] ==> val functionInnerScope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeUnsafeReturnType[LocalVariableDescriptor]

'replaceExpectedType' @ [238:67] ==> @NotNull public open fun replaceExpectedType(@Nullable newExpectedType: KotlinType?): ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaMethodDescriptor]

'expectedType' @ [238:87] ==> val expectedType: KotlinType defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeUnsafeReturnType[LocalVariableDescriptor]

'context' @ [241:9] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeUnsafeReturnType[ValueParameterDescriptorImpl]

'trace' @ [241:17] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'record' @ [241:23] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(KtFunction..KtFunction?), (KotlinType..KotlinType?)>..WritableSlice<(KtFunction..KtFunction?), (KotlinType..KotlinType?)>?), key: (KtFunction..KtFunction?), value: (KotlinType..KotlinType?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtFunction..org.jetbrains.kotlin.psi.KtFunction?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)

'EXPECTED_RETURN_TYPE' @ [241:30] ==> public final val EXPECTED_RETURN_TYPE: (WritableSlice<(KtFunction..KtFunction?), (KotlinType..KotlinType?)>..WritableSlice<(KtFunction..KtFunction?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'functionLiteral' @ [241:52] ==> val functionLiteral: KtFunctionLiteral defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeUnsafeReturnType[LocalVariableDescriptor]

'expectedType' @ [241:69] ==> val expectedType: KotlinType defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeUnsafeReturnType[LocalVariableDescriptor]

'isLambdaUnderNewInferenceResolution' @ [243:51] ==> public fun isLambdaUnderNewInferenceResolution(functionLiteral: KtFunctionLiteral, context: BindingContext): Boolean defined in org.jetbrains.kotlin.resolve.calls.tower in file NewInferenceLastBlockExpressionHelper.kt[SimpleFunctionDescriptorImpl]

'functionLiteral' @ [243:87] ==> val functionLiteral: KtFunctionLiteral defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeUnsafeReturnType[LocalVariableDescriptor]

'context' @ [243:104] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeUnsafeReturnType[ValueParameterDescriptorImpl]

'trace' @ [243:112] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'bindingContext' @ [243:118] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'components' @ [246:33] ==> protected/*protected and package*/ final val components: (ExpressionTypingComponents..ExpressionTypingComponents?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[JavaPropertyDescriptor]

'expressionTypingServices' @ [246:44] ==> public/*package*/ final var expressionTypingServices: (ExpressionTypingServices..ExpressionTypingServices?) defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingComponents[JavaPropertyDescriptor]

'getBlockReturnedType' @ [246:69] ==> @NotNull public open fun getBlockReturnedType(@NotNull expression: KtBlockExpression, @NotNull coercionStrategyForLastExpression: CoercionStrategy, @NotNull context: ExpressionTypingContext): KotlinTypeInfo defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingServices[JavaMethodDescriptor]

'functionLiteral' @ [246:90] ==> val functionLiteral: KtFunctionLiteral defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeUnsafeReturnType[LocalVariableDescriptor]

'bodyExpression' @ [246:106] ==> public final val KtFunctionLiteral.bodyExpression: KtBlockExpression?[MyPropertyDescriptor]

'COERCION_TO_UNIT' @ [246:124] ==> enum entry COERCION_TO_UNIT defined in org.jetbrains.kotlin.types.expressions.CoercionStrategy[FakeCallableDescriptorForObject]

'newContext' @ [246:142] ==> val newContext: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeUnsafeReturnType[LocalVariableDescriptor]

'blockReturnedType' @ [247:36] ==> val blockReturnedType: KotlinTypeInfo defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeUnsafeReturnType[LocalVariableDescriptor]

'type' @ [247:54] ==> public final val type: KotlinType? defined in org.jetbrains.kotlin.types.expressions.KotlinTypeInfo[PropertyDescriptorImpl]

'isLambdaUnderNewInferenceResolution' @ [249:13] ==> val isLambdaUnderNewInferenceResolution: Boolean defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeUnsafeReturnType[LocalVariableDescriptor]

'computeReturnTypeBasedOnReturnExpressions' @ [253:16] ==> private final fun computeReturnTypeBasedOnReturnExpressions(functionLiteral: KtFunctionLiteral, context: ExpressionTypingContext, typeOfBodyExpression: KotlinType?): KotlinType? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[SimpleFunctionDescriptorImpl]

'functionLiteral' @ [253:58] ==> val functionLiteral: KtFunctionLiteral defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeUnsafeReturnType[LocalVariableDescriptor]

'context' @ [253:75] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeUnsafeReturnType[ValueParameterDescriptorImpl]

'typeOfBodyExpression' @ [253:84] ==> val typeOfBodyExpression: KotlinType? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeUnsafeReturnType[LocalVariableDescriptor]

'newArrayList' @ [261:45] ==> @GwtCompatible public open fun <E : (Any..Any?)> newArrayList(): (ArrayList<(KotlinType..KotlinType?)>..ArrayList<(KotlinType..KotlinType?)>?) defined in com.google.common.collect.Lists[JavaMethodDescriptor]
Inferred types:
    <E : (Any..Any?)> -> KotlinType

'collectReturns' @ [264:33] ==> private final fun collectReturns(functionLiteral: KtFunctionLiteral, trace: BindingTrace): Collection<KtReturnExpression> defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[SimpleFunctionDescriptorImpl]

'functionLiteral' @ [264:48] ==> value-parameter functionLiteral: KtFunctionLiteral defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnTypeBasedOnReturnExpressions[ValueParameterDescriptorImpl]

'context' @ [264:65] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnTypeBasedOnReturnExpressions[ValueParameterDescriptorImpl]

'trace' @ [264:73] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'returnExpressions' @ [265:34] ==> val returnExpressions: Collection<KtReturnExpression> defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnTypeBasedOnReturnExpressions[LocalVariableDescriptor]

'returnExpression' @ [266:38] ==> val returnExpression: KtReturnExpression defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnTypeBasedOnReturnExpressions[LocalVariableDescriptor]

'returnedExpression' @ [266:55] ==> public final val KtReturnExpression.returnedExpression: KtExpression?[MyPropertyDescriptor]

'if (returnedExpression == null) {
                hasEmptyReturn = true
            }
            else {
                // the type should have been computed by getBlockReturnedType() above, but can be null, if returnExpression contains some error
                returnedExpressionTypes.addIfNotNull(context.trace.getType(returnedExpression))
            }' @ [267:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'returnedExpression' @ [267:17] ==> val returnedExpression: KtExpression? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnTypeBasedOnReturnExpressions[LocalVariableDescriptor]

'hasEmptyReturn' @ [268:17] ==> var hasEmptyReturn: Boolean defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnTypeBasedOnReturnExpressions[LocalVariableDescriptor]

'returnedExpressionTypes' @ [272:17] ==> val returnedExpressionTypes: (ArrayList<(KotlinType..KotlinType?)>..ArrayList<(KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnTypeBasedOnReturnExpressions[LocalVariableDescriptor]

'addIfNotNull' @ [272:41] ==> public fun <T : Any> MutableCollection<(KotlinType..KotlinType?)>.addIfNotNull(t: KotlinType?): Unit defined in org.jetbrains.kotlin.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)

'context' @ [272:54] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnTypeBasedOnReturnExpressions[ValueParameterDescriptorImpl]

'trace' @ [272:62] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'getType' @ [272:68] ==> @Nullable public abstract fun getType(@NotNull expression: KtExpression): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'returnedExpression' @ [272:76] ==> val returnedExpression: KtExpression? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnTypeBasedOnReturnExpressions[LocalVariableDescriptor]

'hasEmptyReturn' @ [276:13] ==> var hasEmptyReturn: Boolean defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnTypeBasedOnReturnExpressions[LocalVariableDescriptor]

'returnExpressions' @ [277:38] ==> val returnExpressions: Collection<KtReturnExpression> defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnTypeBasedOnReturnExpressions[LocalVariableDescriptor]

'returnExpression' @ [278:42] ==> val returnExpression: KtReturnExpression defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnTypeBasedOnReturnExpressions[LocalVariableDescriptor]

'returnedExpression' @ [278:59] ==> public final val KtReturnExpression.returnedExpression: KtExpression?[MyPropertyDescriptor]

'returnedExpression' @ [279:21] ==> val returnedExpression: KtExpression? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnTypeBasedOnReturnExpressions[LocalVariableDescriptor]

'context' @ [280:32] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnTypeBasedOnReturnExpressions[ValueParameterDescriptorImpl]

'trace' @ [280:40] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'getType' @ [280:46] ==> @Nullable public abstract fun getType(@NotNull expression: KtExpression): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'returnedExpression' @ [280:54] ==> val returnedExpression: KtExpression? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnTypeBasedOnReturnExpressions[LocalVariableDescriptor]

'type' @ [281:25] ==> val type: KotlinType? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnTypeBasedOnReturnExpressions[LocalVariableDescriptor]

'!' @ [281:41] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isUnit' @ [281:57] ==> public open fun isUnit(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'type' @ [281:64] ==> val type: KotlinType? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnTypeBasedOnReturnExpressions[LocalVariableDescriptor]

'context' @ [282:25] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnTypeBasedOnReturnExpressions[ValueParameterDescriptorImpl]

'trace' @ [282:33] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'report' @ [282:39] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'RETURN_TYPE_MISMATCH' @ [282:46] ==> public final val RETURN_TYPE_MISMATCH: (DiagnosticFactory1<(KtExpression..KtExpression?), (KotlinType..KotlinType?)>..DiagnosticFactory1<(KtExpression..KtExpression?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [282:67] ==> @NotNull public open fun on(@NotNull element: KtExpression, @NotNull argument: KotlinType): ParametrizedDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory1[JavaMethodDescriptor]

'returnedExpression' @ [282:70] ==> val returnedExpression: KtExpression? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnTypeBasedOnReturnExpressions[LocalVariableDescriptor]

'components' @ [282:90] ==> protected/*protected and package*/ final val components: (ExpressionTypingComponents..ExpressionTypingComponents?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[JavaPropertyDescriptor]

'builtIns' @ [282:101] ==> public/*package*/ final var builtIns: (KotlinBuiltIns..KotlinBuiltIns?) defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingComponents[JavaPropertyDescriptor]

'unitType' @ [282:110] ==> public final val KotlinBuiltIns.unitType: SimpleType[MyPropertyDescriptor]

'components' @ [286:20] ==> protected/*protected and package*/ final val components: (ExpressionTypingComponents..ExpressionTypingComponents?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[JavaPropertyDescriptor]

'builtIns' @ [286:31] ==> public/*package*/ final var builtIns: (KotlinBuiltIns..KotlinBuiltIns?) defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingComponents[JavaPropertyDescriptor]

'unitType' @ [286:40] ==> public final val KotlinBuiltIns.unitType: SimpleType[MyPropertyDescriptor]

'returnedExpressionTypes' @ [288:9] ==> val returnedExpressionTypes: (ArrayList<(KotlinType..KotlinType?)>..ArrayList<(KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnTypeBasedOnReturnExpressions[LocalVariableDescriptor]

'addIfNotNull' @ [288:33] ==> public fun <T : Any> MutableCollection<(KotlinType..KotlinType?)>.addIfNotNull(t: KotlinType?): Unit defined in org.jetbrains.kotlin.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)

'typeOfBodyExpression' @ [288:46] ==> value-parameter typeOfBodyExpression: KotlinType? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnTypeBasedOnReturnExpressions[ValueParameterDescriptorImpl]

'returnedExpressionTypes' @ [290:13] ==> val returnedExpressionTypes: (ArrayList<(KotlinType..KotlinType?)>..ArrayList<(KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnTypeBasedOnReturnExpressions[LocalVariableDescriptor]

'isEmpty' @ [290:37] ==> public open fun isEmpty(): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'commonSupertype' @ [291:33] ==> @NotNull public open fun commonSupertype(@NotNull types: (MutableCollection<(KotlinType..KotlinType?)>..Collection<(KotlinType..KotlinType?)>)): KotlinType defined in org.jetbrains.kotlin.types.CommonSupertypes[JavaMethodDescriptor]

'returnedExpressionTypes' @ [291:49] ==> val returnedExpressionTypes: (ArrayList<(KotlinType..KotlinType?)>..ArrayList<(KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.computeReturnTypeBasedOnReturnExpressions[LocalVariableDescriptor]

'newArrayList' @ [295:28] ==> @GwtCompatible public open fun <E : (Any..Any?)> newArrayList(): (ArrayList<(KtReturnExpression..KtReturnExpression?)>..ArrayList<(KtReturnExpression..KtReturnExpression?)>?) defined in com.google.common.collect.Lists[JavaMethodDescriptor]
Inferred types:
    <E : (Any..Any?)> -> KtReturnExpression

'functionLiteral' @ [296:30] ==> value-parameter functionLiteral: KtFunctionLiteral defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns[ValueParameterDescriptorImpl]

'bodyExpression' @ [296:46] ==> public final val KtFunctionLiteral.bodyExpression: KtBlockExpression?[MyPropertyDescriptor]

'bodyExpression' @ [297:9] ==> val bodyExpression: KtBlockExpression? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns[LocalVariableDescriptor]

'accept' @ [297:25] ==> @Override public open fun <R : (Any..Any?), D : (Any..Any?)> accept(@NotNull visitor: KtVisitor<(Void..Void?), (MutableList<KtReturnExpression>..MutableList<KtReturnExpression>?)>, data: (MutableList<KtReturnExpression>..MutableList<KtReturnExpression>?)): (Void..Void?) defined in org.jetbrains.kotlin.psi.KtBlockExpression[JavaMethodDescriptor]
Inferred types:
    <R : (Any..Any?)> -> (java.lang.Void..java.lang.Void?)
    <D : (Any..Any?)> -> (kotlin.collections.MutableList<org.jetbrains.kotlin.psi.KtReturnExpression>..kotlin.collections.MutableList<org.jetbrains.kotlin.psi.KtReturnExpression>?)

'KtTreeVisitor<MutableList<KtReturnExpression>>' @ [297:41] ==> public constructor KtTreeVisitor<D : (Any..Any?)>() defined in org.jetbrains.kotlin.psi.KtTreeVisitor[JavaClassConstructorDescriptor]
Inferred types:
    <D : (Any..Any?)> -> MutableList<KtReturnExpression>

'insideActualFunction' @ [299:17] ==> value-parameter insideActualFunction: MutableList<KtReturnExpression> defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns.<no name provided>.visitReturnExpression[ValueParameterDescriptorImpl]

'add' @ [299:38] ==> public abstract fun add(element: KtReturnExpression): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'expression' @ [299:42] ==> value-parameter expression: KtReturnExpression defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns.<no name provided>.visitReturnExpression[ValueParameterDescriptorImpl]

'result' @ [302:12] ==> val result: (ArrayList<(KtReturnExpression..KtReturnExpression?)>..ArrayList<(KtReturnExpression..KtReturnExpression?)>?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns[LocalVariableDescriptor]

'result' @ [303:16] ==> val result: (ArrayList<(KtReturnExpression..KtReturnExpression?)>..ArrayList<(KtReturnExpression..KtReturnExpression?)>?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns[LocalVariableDescriptor]

'filter' @ [303:23] ==> public inline fun <T> Iterable<(KtReturnExpression..KtReturnExpression?)>.filter(predicate: ((KtReturnExpression..KtReturnExpression?)) -> Boolean): List<(KtReturnExpression..KtReturnExpression?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtReturnExpression..org.jetbrains.kotlin.psi.KtReturnExpression?)

'it' @ [306:13] ==> value-parameter it: (KtReturnExpression..KtReturnExpression?) defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns.<anonymous>[ValueParameterDescriptorImpl]

'getTargetLabel' @ [306:16] ==> public final fun getTargetLabel(): KtSimpleNameExpression? defined in org.jetbrains.kotlin.psi.KtReturnExpression[SimpleFunctionDescriptorImpl]

'let' @ [306:34] ==> @InlineOnly public inline fun <T, R> KtSimpleNameExpression.let(block: (KtSimpleNameExpression) -> PsiElement?): PsiElement? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtSimpleNameExpression
    <R> -> PsiElement?

'trace' @ [306:40] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns[ValueParameterDescriptorImpl]

'get' @ [306:46] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(slice: (ReadOnlySlice<(KtReferenceExpression..KtReferenceExpression?), (PsiElement..PsiElement?)>..ReadOnlySlice<(KtReferenceExpression..KtReferenceExpression?), (PsiElement..PsiElement?)>?), key: (KtReferenceExpression..KtReferenceExpression?)): PsiElement? defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtReferenceExpression..org.jetbrains.kotlin.psi.KtReferenceExpression?)
    <V : (Any..Any?)> -> (com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)

'LABEL_TARGET' @ [306:65] ==> public final val LABEL_TARGET: (WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (PsiElement..PsiElement?)>..WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (PsiElement..PsiElement?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'it' @ [306:79] ==> value-parameter it: KtSimpleNameExpression defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'functionLiteral' @ [306:88] ==> value-parameter functionLiteral: KtFunctionLiteral defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns[ValueParameterDescriptorImpl]

'function' @ [311:13] ==> value-parameter function: KtDeclarationWithBody defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.checkTypesForReturnStatements[ValueParameterDescriptorImpl]

'hasBlockBody' @ [311:22] ==> public abstract fun hasBlockBody(): Boolean defined in org.jetbrains.kotlin.psi.KtDeclarationWithBody[JavaMethodDescriptor]

'function' @ [312:14] ==> value-parameter function: KtDeclarationWithBody defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.checkTypesForReturnStatements[ValueParameterDescriptorImpl]

'function' @ [312:46] ==> value-parameter function: KtDeclarationWithBody defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.checkTypesForReturnStatements[ValueParameterDescriptorImpl]

'typeReference' @ [312:55] ==> public final var KtNamedFunction.typeReference: KtTypeReference?[MyPropertyDescriptor]

'function' @ [313:17] ==> value-parameter function: KtDeclarationWithBody defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.checkTypesForReturnStatements[ValueParameterDescriptorImpl]

'function' @ [313:52] ==> value-parameter function: KtDeclarationWithBody defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.checkTypesForReturnStatements[ValueParameterDescriptorImpl]

'returnTypeReference' @ [313:61] ==> public final val KtPropertyAccessor.returnTypeReference: KtTypeReference?[MyPropertyDescriptor]

'collectReturns' @ [315:32] ==> private final fun collectReturns(function: KtDeclarationWithBody, trace: BindingTrace): List<KtReturnExpression> defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor[SimpleFunctionDescriptorImpl]

'function' @ [315:47] ==> value-parameter function: KtDeclarationWithBody defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.checkTypesForReturnStatements[ValueParameterDescriptorImpl]

'trace' @ [315:57] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.checkTypesForReturnStatements[ValueParameterDescriptorImpl]

'returnForCheck' @ [316:30] ==> val returnForCheck: KtReturnExpression defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.checkTypesForReturnStatements[LocalVariableDescriptor]

'returnedExpression' @ [316:45] ==> public final val KtReturnExpression.returnedExpression: KtExpression?[MyPropertyDescriptor]

'expression' @ [317:17] ==> val expression: KtExpression? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.checkTypesForReturnStatements[LocalVariableDescriptor]

'!' @ [318:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'actualReturnType' @ [318:22] ==> value-parameter actualReturnType: KotlinType defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.checkTypesForReturnStatements[ValueParameterDescriptorImpl]

'isUnit' @ [318:39] ==> public fun KotlinType.isUnit(): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'trace' @ [319:21] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.checkTypesForReturnStatements[ValueParameterDescriptorImpl]

'report' @ [319:27] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'RETURN_TYPE_MISMATCH' @ [319:41] ==> public final val RETURN_TYPE_MISMATCH: (DiagnosticFactory1<(KtExpression..KtExpression?), (KotlinType..KotlinType?)>..DiagnosticFactory1<(KtExpression..KtExpression?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [319:62] ==> @NotNull public open fun on(@NotNull element: KtExpression, @NotNull argument: KotlinType): ParametrizedDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory1[JavaMethodDescriptor]

'returnForCheck' @ [319:65] ==> val returnForCheck: KtReturnExpression defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.checkTypesForReturnStatements[LocalVariableDescriptor]

'actualReturnType' @ [319:81] ==> value-parameter actualReturnType: KotlinType defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.checkTypesForReturnStatements[ValueParameterDescriptorImpl]

'trace' @ [324:34] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.checkTypesForReturnStatements[ValueParameterDescriptorImpl]

'getType' @ [324:40] ==> @Nullable public abstract fun getType(@NotNull expression: KtExpression): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'expression' @ [324:48] ==> val expression: KtExpression? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.checkTypesForReturnStatements[LocalVariableDescriptor]

'!' @ [325:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'DEFAULT' @ [325:36] ==> public final val DEFAULT: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaPropertyDescriptor]

'isSubtypeOf' @ [325:44] ==> public abstract fun isSubtypeOf(@NotNull p0: KotlinType, @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaMethodDescriptor]

'expressionType' @ [325:56] ==> val expressionType: KotlinType defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.checkTypesForReturnStatements[LocalVariableDescriptor]

'actualReturnType' @ [325:72] ==> value-parameter actualReturnType: KotlinType defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.checkTypesForReturnStatements[ValueParameterDescriptorImpl]

'trace' @ [326:17] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.checkTypesForReturnStatements[ValueParameterDescriptorImpl]

'report' @ [326:23] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'TYPE_MISMATCH' @ [326:37] ==> public final val TYPE_MISMATCH: (DiagnosticFactory2<(KtExpression..KtExpression?), (KotlinType..KotlinType?), (KotlinType..KotlinType?)>..DiagnosticFactory2<(KtExpression..KtExpression?), (KotlinType..KotlinType?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [326:51] ==> @NotNull public open fun on(@NotNull element: KtExpression, @NotNull a: KotlinType, @NotNull b: KotlinType): ParametrizedDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'expression' @ [326:54] ==> val expression: KtExpression? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.checkTypesForReturnStatements[LocalVariableDescriptor]

'expressionType' @ [326:66] ==> val expressionType: KotlinType defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.checkTypesForReturnStatements[LocalVariableDescriptor]

'actualReturnType' @ [326:82] ==> value-parameter actualReturnType: KotlinType defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.checkTypesForReturnStatements[ValueParameterDescriptorImpl]

'function' @ [332:30] ==> value-parameter function: KtDeclarationWithBody defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns[ValueParameterDescriptorImpl]

'bodyExpression' @ [332:39] ==> public final val KtDeclarationWithBody.bodyExpression: KtExpression?[MyPropertyDescriptor]

'emptyList' @ [332:64] ==> public fun <T> emptyList(): List<KtReturnExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtReturnExpression

'ArrayList' @ [333:23] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> KtReturnExpression

'bodyExpression' @ [335:9] ==> val bodyExpression: KtExpression defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns[LocalVariableDescriptor]

'accept' @ [335:24] ==> @Override public abstract fun <R : (Any..Any?), D : (Any..Any?)> accept(@NotNull visitor: KtVisitor<(Void..Void?), (Boolean..Boolean?)>, data: (Boolean..Boolean?)): (Void..Void?) defined in org.jetbrains.kotlin.psi.KtExpression[JavaMethodDescriptor]
Inferred types:
    <R : (Any..Any?)> -> (java.lang.Void..java.lang.Void?)
    <D : (Any..Any?)> -> (kotlin.Boolean..kotlin.Boolean?)

'KtTreeVisitor<Boolean>' @ [335:40] ==> public constructor KtTreeVisitor<D : (Any..Any?)>() defined in org.jetbrains.kotlin.psi.KtTreeVisitor[JavaClassConstructorDescriptor]
Inferred types:
    <D : (Any..Any?)> -> Boolean

'expression' @ [337:35] ==> value-parameter expression: KtReturnExpression defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns.<no name provided>.visitReturnExpression[ValueParameterDescriptorImpl]

'getTargetLabel' @ [337:46] ==> public final fun getTargetLabel(): KtSimpleNameExpression? defined in org.jetbrains.kotlin.psi.KtReturnExpression[SimpleFunctionDescriptorImpl]

'let' @ [337:64] ==> @InlineOnly public inline fun <T, R> KtSimpleNameExpression.let(block: (KtSimpleNameExpression) -> PsiElement?): PsiElement? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtSimpleNameExpression
    <R> -> PsiElement?

'trace' @ [337:70] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns[ValueParameterDescriptorImpl]

'LABEL_TARGET' @ [337:91] ==> public final val LABEL_TARGET: (WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (PsiElement..PsiElement?)>..WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (PsiElement..PsiElement?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'it' @ [337:105] ==> value-parameter it: KtSimpleNameExpression defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns.<no name provided>.visitReturnExpression.<anonymous>[ValueParameterDescriptorImpl]

'labelTarget' @ [338:21] ==> val labelTarget: PsiElement? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns.<no name provided>.visitReturnExpression[LocalVariableDescriptor]

'function' @ [338:36] ==> value-parameter function: KtDeclarationWithBody defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns[ValueParameterDescriptorImpl]

'labelTarget' @ [338:49] ==> val labelTarget: PsiElement? defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns.<no name provided>.visitReturnExpression[LocalVariableDescriptor]

'insideActualFunction' @ [338:72] ==> value-parameter insideActualFunction: Boolean defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns.<no name provided>.visitReturnExpression[ValueParameterDescriptorImpl]

'returns' @ [339:21] ==> val returns: ArrayList<KtReturnExpression> defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns[LocalVariableDescriptor]

'add' @ [339:29] ==> public open fun add(element: KtReturnExpression): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'expression' @ [339:33] ==> value-parameter expression: KtReturnExpression defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns.<no name provided>.visitReturnExpression[ValueParameterDescriptorImpl]

'super' @ [342:24] ==> <this> defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns.<no name provided>[LazyClassReceiverParameterDescriptor]

'visitReturnExpression' @ [342:30] ==> public open fun visitReturnExpression(@NotNull expression: KtReturnExpression, data: (Boolean..Boolean?)): (Void..Void?) defined in org.jetbrains.kotlin.psi.KtTreeVisitor[JavaMethodDescriptor]

'expression' @ [342:52] ==> value-parameter expression: KtReturnExpression defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns.<no name provided>.visitReturnExpression[ValueParameterDescriptorImpl]

'insideActualFunction' @ [342:64] ==> value-parameter insideActualFunction: Boolean defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns.<no name provided>.visitReturnExpression[ValueParameterDescriptorImpl]

'super' @ [346:24] ==> <this> defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns.<no name provided>[LazyClassReceiverParameterDescriptor]

'visitNamedFunction' @ [346:30] ==> public open fun visitNamedFunction(@NotNull function: KtNamedFunction, data: (Boolean..Boolean?)): (Void..Void?) defined in org.jetbrains.kotlin.psi.KtTreeVisitor[JavaMethodDescriptor]

'function' @ [346:49] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns.<no name provided>.visitNamedFunction[ValueParameterDescriptorImpl]

'super' @ [350:24] ==> <this> defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns.<no name provided>[LazyClassReceiverParameterDescriptor]

'visitPropertyAccessor' @ [350:30] ==> public open fun visitPropertyAccessor(@NotNull accessor: KtPropertyAccessor, data: (Boolean..Boolean?)): (Void..Void?) defined in org.jetbrains.kotlin.psi.KtTreeVisitor[JavaMethodDescriptor]

'accessor' @ [350:52] ==> value-parameter accessor: KtPropertyAccessor defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns.<no name provided>.visitPropertyAccessor[ValueParameterDescriptorImpl]

'super' @ [354:24] ==> <this> defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns.<no name provided>[LazyClassReceiverParameterDescriptor]

'visitAnonymousInitializer' @ [354:30] ==> public open fun visitAnonymousInitializer(@NotNull initializer: KtAnonymousInitializer, data: (Boolean..Boolean?)): (Void..Void?) defined in org.jetbrains.kotlin.psi.KtTreeVisitor[JavaMethodDescriptor]

'initializer' @ [354:56] ==> value-parameter initializer: KtAnonymousInitializer defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns.<no name provided>.visitAnonymousInitializer[ValueParameterDescriptorImpl]

'returns' @ [358:16] ==> val returns: ArrayList<KtReturnExpression> defined in org.jetbrains.kotlin.types.expressions.FunctionsTypingVisitor.collectReturns[LocalVariableDescriptor]

