'resolvedCall' @ [42:34] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[ValueParameterDescriptorImpl]

'resultingDescriptor' @ [42:47] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.resultingDescriptor: (CallableDescriptor..CallableDescriptor?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(*)

'!' @ [43:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'checkNotErrorOrDynamic' @ [43:14] ==> private final fun checkNotErrorOrDynamic(functionDescriptor: FunctionDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.Companion[SimpleFunctionDescriptorImpl]

'functionDescriptor' @ [43:37] ==> val functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[LocalVariableDescriptor]

'resolvedCall' @ [45:23] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[ValueParameterDescriptorImpl]

'call' @ [45:36] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(*)

'calleeExpression' @ [45:41] ==> public final val Call.calleeExpression: KtExpression?[MyPropertyDescriptor]

'resolvedCall' @ [45:61] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[ValueParameterDescriptorImpl]

'call' @ [45:74] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(*)

'callElement' @ [45:79] ==> public final val Call.callElement: KtElement[MyPropertyDescriptor]

'resolvedCall' @ [46:20] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[ValueParameterDescriptorImpl]

'call' @ [46:33] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(*)

'resolvedCall' @ [48:13] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[ValueParameterDescriptorImpl]

'call' @ [49:13] ==> val call: Call defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[LocalVariableDescriptor]

'call' @ [49:62] ==> val call: Call defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[LocalVariableDescriptor]

'itIsVariableAsFunctionCall' @ [49:67] ==> public final val itIsVariableAsFunctionCall: Boolean defined in org.jetbrains.kotlin.resolve.calls.CallTransformer.CallForImplicitInvoke[JavaPropertyDescriptor]

'call' @ [50:29] ==> val call: Call defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[LocalVariableDescriptor]

'outerCall' @ [50:34] ==> public final val CallTransformer.CallForImplicitInvoke.outerCall: Call[MyPropertyDescriptor]

'isConventionCall' @ [51:17] ==> public fun isConventionCall(call: Call): Boolean defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil in file CallResolverUtil.kt[SimpleFunctionDescriptorImpl]

'outerCall' @ [51:34] ==> val outerCall: Call defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[LocalVariableDescriptor]

'isWrongCallWithExplicitTypeArguments' @ [51:48] ==> private final fun isWrongCallWithExplicitTypeArguments(resolvedCall: VariableAsFunctionResolvedCall, outerCall: Call): Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.Companion[SimpleFunctionDescriptorImpl]

'resolvedCall' @ [51:85] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[ValueParameterDescriptorImpl]

'outerCall' @ [51:99] ==> val outerCall: Call defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[LocalVariableDescriptor]

'AssertionError' @ [52:23] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'+' @ [52:38] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'outerCall' @ [52:90] ==> val outerCall: Call defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[LocalVariableDescriptor]

'resolvedCall' @ [53:51] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[ValueParameterDescriptorImpl]

'variableCall' @ [53:64] ==> public abstract val variableCall: ResolvedCall<VariableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.model.VariableAsFunctionResolvedCall[PropertyDescriptorImpl]

'resultingDescriptor' @ [53:77] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<VariableDescriptor>.resultingDescriptor: VariableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> VariableDescriptor

'resolvedCall' @ [54:49] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[ValueParameterDescriptorImpl]

'functionCall' @ [54:62] ==> public abstract val functionCall: ResolvedCall<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.calls.model.VariableAsFunctionResolvedCall[PropertyDescriptorImpl]

'resultingDescriptor' @ [54:75] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<FunctionDescriptor>.resultingDescriptor: FunctionDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'call' @ [58:13] ==> val call: Call defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[LocalVariableDescriptor]

'callElement' @ [58:18] ==> public final val Call.callElement: KtElement[MyPropertyDescriptor]

'call' @ [58:68] ==> val call: Call defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[LocalVariableDescriptor]

'!' @ [59:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'functionDescriptor' @ [59:18] ==> val functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[LocalVariableDescriptor]

'isOperator' @ [59:37] ==> public final val FunctionDescriptor.isOperator: Boolean[MyPropertyDescriptor]

'report' @ [60:17] ==> public final fun report(reportOn: PsiElement, descriptor: FunctionDescriptor, sink: DiagnosticSink): Unit defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.Companion[SimpleFunctionDescriptorImpl]

'reportOn' @ [60:24] ==> value-parameter reportOn: PsiElement defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[ValueParameterDescriptorImpl]

'functionDescriptor' @ [60:34] ==> val functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[LocalVariableDescriptor]

'context' @ [60:54] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[ValueParameterDescriptorImpl]

'trace' @ [60:62] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[PropertyDescriptorImpl]

'element' @ [65:36] ==> val element: KtElement defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[LocalVariableDescriptor]

'element' @ [65:81] ==> val element: KtElement defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[LocalVariableDescriptor]

'isConventionOperator' @ [65:89] ==> public final fun isConventionOperator(): Boolean defined in org.jetbrains.kotlin.psi.KtOperationReferenceExpression[SimpleFunctionDescriptorImpl]

'isConventionOperator' @ [67:13] ==> val isConventionOperator: Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[LocalVariableDescriptor]

'checkModConvention' @ [68:13] ==> private fun checkModConvention(descriptor: FunctionDescriptor, languageVersionSettings: LanguageVersionSettings, diagnosticHolder: DiagnosticSink, modifier: PsiElement): Unit defined in org.jetbrains.kotlin.resolve.calls.checkers in file OperatorCallChecker.kt[SimpleFunctionDescriptorImpl]

'functionDescriptor' @ [68:32] ==> val functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[LocalVariableDescriptor]

'context' @ [68:52] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[ValueParameterDescriptorImpl]

'languageVersionSettings' @ [68:60] ==> public final val languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[PropertyDescriptorImpl]

'context' @ [68:85] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[ValueParameterDescriptorImpl]

'trace' @ [68:93] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[PropertyDescriptorImpl]

'reportOn' @ [68:100] ==> value-parameter reportOn: PsiElement defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[ValueParameterDescriptorImpl]

'isConventionOperator' @ [71:13] ==> val isConventionOperator: Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[LocalVariableDescriptor]

'element' @ [71:37] ==> val element: KtElement defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[LocalVariableDescriptor]

'!' @ [72:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'functionDescriptor' @ [72:18] ==> val functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[LocalVariableDescriptor]

'isOperator' @ [72:37] ==> public final val FunctionDescriptor.isOperator: Boolean[MyPropertyDescriptor]

'report' @ [73:17] ==> public final fun report(reportOn: PsiElement, descriptor: FunctionDescriptor, sink: DiagnosticSink): Unit defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.Companion[SimpleFunctionDescriptorImpl]

'reportOn' @ [73:24] ==> value-parameter reportOn: PsiElement defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[ValueParameterDescriptorImpl]

'functionDescriptor' @ [73:34] ==> val functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[LocalVariableDescriptor]

'context' @ [73:54] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.check[ValueParameterDescriptorImpl]

'trace' @ [73:62] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[PropertyDescriptorImpl]

'!' @ [80:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'checkNotErrorOrDynamic' @ [80:18] ==> private final fun checkNotErrorOrDynamic(functionDescriptor: FunctionDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.Companion[SimpleFunctionDescriptorImpl]

'descriptor' @ [80:41] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.Companion.report[ValueParameterDescriptorImpl]

'descriptor' @ [82:41] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.Companion.report[ValueParameterDescriptorImpl]

'containingDeclaration' @ [82:52] ==> public final val FunctionDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'containingDeclaration' @ [83:45] ==> val containingDeclaration: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.Companion.report[LocalVariableDescriptor]

'fqNameUnsafe' @ [83:67] ==> public val DeclarationDescriptor.fqNameUnsafe: FqNameUnsafe defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'asString' @ [83:80] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqNameUnsafe[JavaMethodDescriptor]

'sink' @ [84:13] ==> value-parameter sink: DiagnosticSink defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.Companion.report[ValueParameterDescriptorImpl]

'report' @ [84:18] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'OPERATOR_MODIFIER_REQUIRED' @ [84:32] ==> public final val OPERATOR_MODIFIER_REQUIRED: (DiagnosticFactory2<(PsiElement..PsiElement?), (FunctionDescriptor..FunctionDescriptor?), (String..String?)>..DiagnosticFactory2<(PsiElement..PsiElement?), (FunctionDescriptor..FunctionDescriptor?), (String..String?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [84:59] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull a: FunctionDescriptor, @NotNull b: String): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'reportOn' @ [84:62] ==> value-parameter reportOn: PsiElement defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.Companion.report[ValueParameterDescriptorImpl]

'descriptor' @ [84:72] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.Companion.report[ValueParameterDescriptorImpl]

'containingDeclarationName' @ [84:84] ==> val containingDeclarationName: String defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.Companion.report[LocalVariableDescriptor]

'!' @ [88:20] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'functionDescriptor' @ [88:21] ==> value-parameter functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.Companion.checkNotErrorOrDynamic[ValueParameterDescriptorImpl]

'isDynamic' @ [88:40] ==> public fun DeclarationDescriptor.isDynamic(): Boolean defined in org.jetbrains.kotlin.resolve.calls.tasks in file dynamicCalls.kt[SimpleFunctionDescriptorImpl]

'!' @ [88:55] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isError' @ [88:67] ==> public open fun isError(@Nullable p0: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.types.ErrorUtils[JavaMethodDescriptor]

'functionDescriptor' @ [88:75] ==> value-parameter functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.Companion.checkNotErrorOrDynamic[ValueParameterDescriptorImpl]

'outerCall' @ [95:47] ==> value-parameter outerCall: Call defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.Companion.isWrongCallWithExplicitTypeArguments[ValueParameterDescriptorImpl]

'typeArguments' @ [95:57] ==> public final val Call.typeArguments: List<(KtTypeProjection..KtTypeProjection?)>[MyPropertyDescriptor]

'isNotEmpty' @ [95:71] ==> @InlineOnly public inline fun <T> Collection<(KtTypeProjection..KtTypeProjection?)>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtTypeProjection..org.jetbrains.kotlin.psi.KtTypeProjection?)

'resolvedCall' @ [96:47] ==> value-parameter resolvedCall: VariableAsFunctionResolvedCall defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.Companion.isWrongCallWithExplicitTypeArguments[ValueParameterDescriptorImpl]

'functionCall' @ [96:60] ==> public abstract val functionCall: ResolvedCall<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.calls.model.VariableAsFunctionResolvedCall[PropertyDescriptorImpl]

'candidateDescriptor' @ [96:73] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<FunctionDescriptor>.candidateDescriptor: FunctionDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'typeParameters' @ [96:93] ==> public final val FunctionDescriptor.typeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'isNotEmpty' @ [96:108] ==> @InlineOnly public inline fun <T> Collection<(TypeParameterDescriptor..TypeParameterDescriptor?)>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)

'passedTypeArgumentsToInvoke' @ [97:20] ==> val passedTypeArgumentsToInvoke: Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.Companion.isWrongCallWithExplicitTypeArguments[LocalVariableDescriptor]

'resolvedCall' @ [97:51] ==> value-parameter resolvedCall: VariableAsFunctionResolvedCall defined in org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker.Companion.isWrongCallWithExplicitTypeArguments[ValueParameterDescriptorImpl]

'variableCall' @ [97:64] ==> public abstract val variableCall: ResolvedCall<VariableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.model.VariableAsFunctionResolvedCall[PropertyDescriptorImpl]

'candidateDescriptor' @ [97:77] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<VariableDescriptor>.candidateDescriptor: VariableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> VariableDescriptor

'typeParameters' @ [97:97] ==> public final val VariableDescriptor.typeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'isNotEmpty' @ [97:112] ==> @InlineOnly public inline fun <T> Collection<(TypeParameterDescriptor..TypeParameterDescriptor?)>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)

'this' @ [103:12] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.checkers.isOperatorMod[ReceiverParameterDescriptorImpl]

'isOperator' @ [103:17] ==> public final val FunctionDescriptor.isOperator: Boolean[MyPropertyDescriptor]

'name' @ [103:31] ==> public final val FunctionDescriptor.name: Name[MyPropertyDescriptor]

'REM_TO_MOD_OPERATION_NAMES' @ [103:59] ==> public final val REM_TO_MOD_OPERATION_NAMES: (ImmutableBiMap<(Name..Name?), (Name..Name?)>..ImmutableBiMap<(Name..Name?), (Name..Name?)>?) defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaPropertyDescriptor]

'values' @ [103:86] ==> public open val values: ImmutableSet<(Name..Name?)> defined in com.google.common.collect.ImmutableBiMap[JavaPropertyDescriptor]

'languageVersionSettings' @ [107:12] ==> value-parameter languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.calls.checkers.shouldWarnAboutDeprecatedModFromBuiltIns[ValueParameterDescriptorImpl]

'supportsFeature' @ [107:36] ==> public open fun supportsFeature(feature: LanguageFeature): Boolean defined in org.jetbrains.kotlin.config.LanguageVersionSettings[DeserializedSimpleFunctionDescriptor]

'OperatorRem' @ [107:68] ==> enum entry OperatorRem defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'languageVersionSettings' @ [107:84] ==> value-parameter languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.calls.checkers.shouldWarnAboutDeprecatedModFromBuiltIns[ValueParameterDescriptorImpl]

'apiVersion' @ [107:108] ==> public abstract val apiVersion: ApiVersion defined in org.jetbrains.kotlin.config.LanguageVersionSettings[DeserializedPropertyDescriptor]

'KOTLIN_1_1' @ [107:133] ==> @field:JvmField public final val KOTLIN_1_1: ApiVersion defined in org.jetbrains.kotlin.config.ApiVersion.Companion[DeserializedPropertyDescriptor]

'!' @ [114:9] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'descriptor' @ [114:10] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.checkModConvention[ValueParameterDescriptorImpl]

'isOperatorMod' @ [114:21] ==> public fun FunctionDescriptor.isOperatorMod(): Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers in file OperatorCallChecker.kt[SimpleFunctionDescriptorImpl]

'if (KotlinBuiltIns.isUnderKotlinPackage(descriptor)) {
        if (shouldWarnAboutDeprecatedModFromBuiltIns(languageVersionSettings)) {
            addWarningAboutDeprecatedMod(descriptor, diagnosticHolder, modifier)
        }
    }
    else {
        if (languageVersionSettings.supportsFeature(LanguageFeature.OperatorRem)) {
            addWarningAboutDeprecatedMod(descriptor, diagnosticHolder, modifier)
        }
    }' @ [116:5] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'isUnderKotlinPackage' @ [116:24] ==> public open fun isUnderKotlinPackage(@NotNull p0: DeclarationDescriptor): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'descriptor' @ [116:45] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.checkModConvention[ValueParameterDescriptorImpl]

'shouldWarnAboutDeprecatedModFromBuiltIns' @ [117:13] ==> public fun shouldWarnAboutDeprecatedModFromBuiltIns(languageVersionSettings: LanguageVersionSettings): Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers in file OperatorCallChecker.kt[SimpleFunctionDescriptorImpl]

'languageVersionSettings' @ [117:54] ==> value-parameter languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.calls.checkers.checkModConvention[ValueParameterDescriptorImpl]

'addWarningAboutDeprecatedMod' @ [118:13] ==> private fun addWarningAboutDeprecatedMod(descriptor: FunctionDescriptor, diagnosticHolder: DiagnosticSink, reportOn: PsiElement): Unit defined in org.jetbrains.kotlin.resolve.calls.checkers in file OperatorCallChecker.kt[SimpleFunctionDescriptorImpl]

'descriptor' @ [118:42] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.checkModConvention[ValueParameterDescriptorImpl]

'diagnosticHolder' @ [118:54] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.calls.checkers.checkModConvention[ValueParameterDescriptorImpl]

'modifier' @ [118:72] ==> value-parameter modifier: PsiElement defined in org.jetbrains.kotlin.resolve.calls.checkers.checkModConvention[ValueParameterDescriptorImpl]

'languageVersionSettings' @ [122:13] ==> value-parameter languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.calls.checkers.checkModConvention[ValueParameterDescriptorImpl]

'supportsFeature' @ [122:37] ==> public open fun supportsFeature(feature: LanguageFeature): Boolean defined in org.jetbrains.kotlin.config.LanguageVersionSettings[DeserializedSimpleFunctionDescriptor]

'OperatorRem' @ [122:69] ==> enum entry OperatorRem defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'addWarningAboutDeprecatedMod' @ [123:13] ==> private fun addWarningAboutDeprecatedMod(descriptor: FunctionDescriptor, diagnosticHolder: DiagnosticSink, reportOn: PsiElement): Unit defined in org.jetbrains.kotlin.resolve.calls.checkers in file OperatorCallChecker.kt[SimpleFunctionDescriptorImpl]

'descriptor' @ [123:42] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.checkModConvention[ValueParameterDescriptorImpl]

'diagnosticHolder' @ [123:54] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.calls.checkers.checkModConvention[ValueParameterDescriptorImpl]

'modifier' @ [123:72] ==> value-parameter modifier: PsiElement defined in org.jetbrains.kotlin.resolve.calls.checkers.checkModConvention[ValueParameterDescriptorImpl]

'OperatorConventions.REM_TO_MOD_OPERATION_NAMES.inverse()[descriptor.name]' @ [129:29] ==> public abstract fun get(@Nullable key: Name?): Name? defined in com.google.common.collect.ImmutableBiMap[JavaMethodDescriptor]

'REM_TO_MOD_OPERATION_NAMES' @ [129:49] ==> public final val REM_TO_MOD_OPERATION_NAMES: (ImmutableBiMap<(Name..Name?), (Name..Name?)>..ImmutableBiMap<(Name..Name?), (Name..Name?)>?) defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaPropertyDescriptor]

'inverse' @ [129:76] ==> public abstract fun inverse(): (ImmutableBiMap<(Name..Name?), (Name..Name?)>..ImmutableBiMap<(Name..Name?), (Name..Name?)>?) defined in com.google.common.collect.ImmutableBiMap[JavaMethodDescriptor]

'descriptor' @ [129:86] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.addWarningAboutDeprecatedMod[ValueParameterDescriptorImpl]

'name' @ [129:97] ==> public final val FunctionDescriptor.name: Name[MyPropertyDescriptor]

'diagnosticHolder' @ [130:5] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.calls.checkers.addWarningAboutDeprecatedMod[ValueParameterDescriptorImpl]

'report' @ [130:22] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'DEPRECATED_BINARY_MOD_AS_REM' @ [130:36] ==> public final val DEPRECATED_BINARY_MOD_AS_REM: (DiagnosticFactory2<(PsiElement..PsiElement?), (FunctionDescriptor..FunctionDescriptor?), (String..String?)>..DiagnosticFactory2<(PsiElement..PsiElement?), (FunctionDescriptor..FunctionDescriptor?), (String..String?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [130:65] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull a: FunctionDescriptor, @NotNull b: String): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'reportOn' @ [130:68] ==> value-parameter reportOn: PsiElement defined in org.jetbrains.kotlin.resolve.calls.checkers.addWarningAboutDeprecatedMod[ValueParameterDescriptorImpl]

'descriptor' @ [130:78] ==> value-parameter descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.addWarningAboutDeprecatedMod[ValueParameterDescriptorImpl]

'newNameConvention' @ [130:90] ==> val newNameConvention: Name? defined in org.jetbrains.kotlin.resolve.calls.checkers.addWarningAboutDeprecatedMod[LocalVariableDescriptor]

'asString' @ [130:110] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

