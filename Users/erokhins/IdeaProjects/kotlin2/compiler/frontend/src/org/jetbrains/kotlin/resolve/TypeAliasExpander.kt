'expandRecursively' @ [34:13] ==> private final fun expandRecursively(typeAliasExpansion: TypeAliasExpansion, annotations: Annotations, isNullable: Boolean, recursionDepth: Int, withAbbreviatedType: Boolean): SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[SimpleFunctionDescriptorImpl]

'typeAliasExpansion' @ [34:31] ==> value-parameter typeAliasExpansion: TypeAliasExpansion defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expand[ValueParameterDescriptorImpl]

'annotations' @ [34:51] ==> value-parameter annotations: Annotations defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expand[ValueParameterDescriptorImpl]

'expandRecursively' @ [38:13] ==> private final fun expandRecursively(typeAliasExpansion: TypeAliasExpansion, annotations: Annotations, isNullable: Boolean, recursionDepth: Int, withAbbreviatedType: Boolean): SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[SimpleFunctionDescriptorImpl]

'typeAliasExpansion' @ [38:31] ==> value-parameter typeAliasExpansion: TypeAliasExpansion defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandWithoutAbbreviation[ValueParameterDescriptorImpl]

'annotations' @ [38:51] ==> value-parameter annotations: Annotations defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandWithoutAbbreviation[ValueParameterDescriptorImpl]

'TypeProjectionImpl' @ [48:36] ==> public constructor TypeProjectionImpl(@NotNull p0: Variance, @NotNull p1: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'INVARIANT' @ [48:64] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'typeAliasExpansion' @ [48:75] ==> value-parameter typeAliasExpansion: TypeAliasExpansion defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandRecursively[ValueParameterDescriptorImpl]

'descriptor' @ [48:94] ==> public final val descriptor: TypeAliasDescriptor defined in org.jetbrains.kotlin.resolve.TypeAliasExpansion[PropertyDescriptorImpl]

'underlyingType' @ [48:105] ==> public abstract val underlyingType: SimpleType defined in org.jetbrains.kotlin.descriptors.TypeAliasDescriptor[DeserializedPropertyDescriptor]

'expandTypeProjection' @ [49:34] ==> private final fun expandTypeProjection(underlyingProjection: TypeProjection, typeAliasExpansion: TypeAliasExpansion, typeParameterDescriptor: TypeParameterDescriptor?, recursionDepth: Int): TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[SimpleFunctionDescriptorImpl]

'underlyingProjection' @ [49:55] ==> val underlyingProjection: TypeProjectionImpl defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandRecursively[LocalVariableDescriptor]

'typeAliasExpansion' @ [49:77] ==> value-parameter typeAliasExpansion: TypeAliasExpansion defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandRecursively[ValueParameterDescriptorImpl]

'recursionDepth' @ [49:103] ==> value-parameter recursionDepth: Int defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandRecursively[ValueParameterDescriptorImpl]

'expandedProjection' @ [50:28] ==> val expandedProjection: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandRecursively[LocalVariableDescriptor]

'type' @ [50:47] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'asSimpleType' @ [50:52] ==> public fun KotlinType.asSimpleType(): SimpleType defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'expandedType' @ [52:13] ==> val expandedType: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandRecursively[LocalVariableDescriptor]

'isError' @ [52:26] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types[DeserializedPropertyDescriptor]

'expandedType' @ [52:42] ==> val expandedType: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandRecursively[LocalVariableDescriptor]

'assert' @ [54:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'expandedProjection' @ [54:16] ==> val expandedProjection: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandRecursively[LocalVariableDescriptor]

'projectionKind' @ [54:35] ==> public final val TypeProjection.projectionKind: Variance[MyPropertyDescriptor]

'INVARIANT' @ [54:62] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'typeAliasExpansion' @ [55:49] ==> value-parameter typeAliasExpansion: TypeAliasExpansion defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandRecursively[ValueParameterDescriptorImpl]

'descriptor' @ [55:68] ==> public final val descriptor: TypeAliasDescriptor defined in org.jetbrains.kotlin.resolve.TypeAliasExpansion[PropertyDescriptorImpl]

'expandedProjection' @ [55:85] ==> val expandedProjection: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandRecursively[LocalVariableDescriptor]

'projectionKind' @ [55:104] ==> public final val TypeProjection.projectionKind: Variance[MyPropertyDescriptor]

'checkRepeatedAnnotations' @ [58:9] ==> private final fun checkRepeatedAnnotations(existingAnnotations: Annotations, newAnnotations: Annotations): Unit defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[SimpleFunctionDescriptorImpl]

'expandedType' @ [58:34] ==> val expandedType: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandRecursively[LocalVariableDescriptor]

'annotations' @ [58:47] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'annotations' @ [58:60] ==> value-parameter annotations: Annotations defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandRecursively[ValueParameterDescriptorImpl]

'expandedType' @ [59:48] ==> val expandedType: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandRecursively[LocalVariableDescriptor]

'combineAnnotations' @ [59:61] ==> private final fun SimpleType.combineAnnotations(newAnnotations: Annotations): SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[SimpleFunctionDescriptorImpl]

'annotations' @ [59:80] ==> value-parameter annotations: Annotations defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandRecursively[ValueParameterDescriptorImpl]

'let' @ [59:93] ==> @InlineOnly public inline fun <T, R> SimpleType.let(block: (SimpleType) -> SimpleType): SimpleType defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SimpleType
    <R> -> SimpleType

'makeNullableIfNeeded' @ [59:109] ==> @NotNull public open fun makeNullableIfNeeded(@NotNull p0: SimpleType, p1: Boolean): SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'it' @ [59:130] ==> value-parameter it: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandRecursively.<anonymous>[ValueParameterDescriptorImpl]

'isNullable' @ [59:134] ==> value-parameter isNullable: Boolean defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandRecursively[ValueParameterDescriptorImpl]

'if (withAbbreviatedType)
            expandedTypeWithExtraAnnotations.withAbbreviation(typeAliasExpansion.createAbbreviation(annotations, isNullable))
        else
            expandedTypeWithExtraAnnotations' @ [61:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: SimpleType, elseBranch: SimpleType): SimpleType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> SimpleType

'withAbbreviatedType' @ [61:20] ==> value-parameter withAbbreviatedType: Boolean defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandRecursively[ValueParameterDescriptorImpl]

'expandedTypeWithExtraAnnotations' @ [62:13] ==> val expandedTypeWithExtraAnnotations: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandRecursively[LocalVariableDescriptor]

'withAbbreviation' @ [62:46] ==> public fun SimpleType.withAbbreviation(abbreviatedType: SimpleType): SimpleType defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'typeAliasExpansion' @ [62:63] ==> value-parameter typeAliasExpansion: TypeAliasExpansion defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandRecursively[ValueParameterDescriptorImpl]

'createAbbreviation' @ [62:82] ==> private final fun TypeAliasExpansion.createAbbreviation(annotations: Annotations, isNullable: Boolean): SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[SimpleFunctionDescriptorImpl]

'annotations' @ [62:101] ==> value-parameter annotations: Annotations defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandRecursively[ValueParameterDescriptorImpl]

'isNullable' @ [62:114] ==> value-parameter isNullable: Boolean defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandRecursively[ValueParameterDescriptorImpl]

'expandedTypeWithExtraAnnotations' @ [64:13] ==> val expandedTypeWithExtraAnnotations: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandRecursively[LocalVariableDescriptor]

'KotlinTypeFactory' @ [68:13] ==> public object KotlinTypeFactory defined in org.jetbrains.kotlin.types[FakeCallableDescriptorForObject]

'simpleType' @ [68:31] ==> @JvmStatic public final fun simpleType(annotations: Annotations, constructor: TypeConstructor, arguments: List<TypeProjection>, nullable: Boolean, memberScope: MemberScope): SimpleType defined in org.jetbrains.kotlin.types.KotlinTypeFactory[DeserializedSimpleFunctionDescriptor]

'annotations' @ [69:21] ==> value-parameter annotations: Annotations defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.createAbbreviation[ValueParameterDescriptorImpl]

'descriptor' @ [70:21] ==> public final val descriptor: TypeAliasDescriptor defined in org.jetbrains.kotlin.resolve.TypeAliasExpansion[PropertyDescriptorImpl]

'typeConstructor' @ [70:32] ==> public final val TypeAliasDescriptor.typeConstructor: TypeConstructor[MyPropertyDescriptor]

'arguments' @ [71:21] ==> public final val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.resolve.TypeAliasExpansion[PropertyDescriptorImpl]

'isNullable' @ [72:21] ==> value-parameter isNullable: Boolean defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.createAbbreviation[ValueParameterDescriptorImpl]

'Empty' @ [73:33] ==> public object Empty : MemberScopeImpl defined in org.jetbrains.kotlin.resolve.scopes.MemberScope[FakeCallableDescriptorForObject]

'assertRecursionDepth' @ [83:9] ==> private final fun assertRecursionDepth(recursionDepth: Int, typeAliasDescriptor: TypeAliasDescriptor): Unit defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.Companion[SimpleFunctionDescriptorImpl]

'recursionDepth' @ [83:30] ==> value-parameter recursionDepth: Int defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[ValueParameterDescriptorImpl]

'typeAliasExpansion' @ [83:46] ==> value-parameter typeAliasExpansion: TypeAliasExpansion defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[ValueParameterDescriptorImpl]

'descriptor' @ [83:65] ==> public final val descriptor: TypeAliasDescriptor defined in org.jetbrains.kotlin.resolve.TypeAliasExpansion[PropertyDescriptorImpl]

'underlyingProjection' @ [85:13] ==> value-parameter underlyingProjection: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[ValueParameterDescriptorImpl]

'isStarProjection' @ [85:34] ==> public final val TypeProjection.isStarProjection: Boolean[MyPropertyDescriptor]

'makeStarProjection' @ [85:69] ==> @NotNull public open fun makeStarProjection(@NotNull p0: TypeParameterDescriptor): TypeProjection defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'typeParameterDescriptor' @ [85:88] ==> value-parameter typeParameterDescriptor: TypeParameterDescriptor? defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[ValueParameterDescriptorImpl]

'underlyingProjection' @ [87:30] ==> value-parameter underlyingProjection: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[ValueParameterDescriptorImpl]

'type' @ [87:51] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'typeAliasExpansion' @ [88:24] ==> value-parameter typeAliasExpansion: TypeAliasExpansion defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[ValueParameterDescriptorImpl]

'getReplacement' @ [88:43] ==> public final fun getReplacement(constructor: TypeConstructor): TypeProjection? defined in org.jetbrains.kotlin.resolve.TypeAliasExpansion[SimpleFunctionDescriptorImpl]

'underlyingType' @ [88:58] ==> val underlyingType: KotlinType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[LocalVariableDescriptor]

'constructor' @ [88:73] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'expandNonArgumentTypeProjection' @ [89:31] ==> private final fun expandNonArgumentTypeProjection(originalProjection: TypeProjection, typeAliasExpansion: TypeAliasExpansion, recursionDepth: Int): TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[SimpleFunctionDescriptorImpl]

'underlyingProjection' @ [89:63] ==> value-parameter underlyingProjection: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[ValueParameterDescriptorImpl]

'typeAliasExpansion' @ [89:85] ==> value-parameter typeAliasExpansion: TypeAliasExpansion defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[ValueParameterDescriptorImpl]

'recursionDepth' @ [89:105] ==> value-parameter recursionDepth: Int defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[ValueParameterDescriptorImpl]

'argument' @ [91:13] ==> val argument: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[LocalVariableDescriptor]

'isStarProjection' @ [91:22] ==> public final val TypeProjection.isStarProjection: Boolean[MyPropertyDescriptor]

'makeStarProjection' @ [91:57] ==> @NotNull public open fun makeStarProjection(@NotNull p0: TypeParameterDescriptor): TypeProjection defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'typeParameterDescriptor' @ [91:76] ==> value-parameter typeParameterDescriptor: TypeParameterDescriptor? defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[ValueParameterDescriptorImpl]

'argument' @ [93:28] ==> val argument: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[LocalVariableDescriptor]

'type' @ [93:37] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'unwrap' @ [93:42] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'run' @ [95:33] ==> @InlineOnly public inline fun <T, R> TypeAliasExpander.run(block: TypeAliasExpander.() -> Variance): Variance defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeAliasExpander
    <R> -> Variance

'argument' @ [96:36] ==> val argument: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[LocalVariableDescriptor]

'projectionKind' @ [96:45] ==> public final val TypeProjection.projectionKind: Variance[MyPropertyDescriptor]

'underlyingProjection' @ [97:38] ==> value-parameter underlyingProjection: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[ValueParameterDescriptorImpl]

'projectionKind' @ [97:59] ==> public final val TypeProjection.projectionKind: Variance[MyPropertyDescriptor]

'when {
                        underlyingVariance == argumentVariance -> argumentVariance
                        underlyingVariance == Variance.INVARIANT -> argumentVariance
                        argumentVariance == Variance.INVARIANT -> underlyingVariance
                        else -> {
                            reportStrategy.conflictingProjection(typeAliasExpansion.descriptor, typeParameterDescriptor, argumentType)
                            argumentVariance
                        }
                    }' @ [100:21] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Variance, entry1: Variance, entry2: Variance, entry3: Variance): Variance[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Variance

'underlyingVariance' @ [101:25] ==> val underlyingVariance: Variance defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection.<anonymous>[LocalVariableDescriptor]

'argumentVariance' @ [101:47] ==> val argumentVariance: Variance defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection.<anonymous>[LocalVariableDescriptor]

'argumentVariance' @ [101:67] ==> val argumentVariance: Variance defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection.<anonymous>[LocalVariableDescriptor]

'underlyingVariance' @ [102:25] ==> val underlyingVariance: Variance defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection.<anonymous>[LocalVariableDescriptor]

'INVARIANT' @ [102:56] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'argumentVariance' @ [102:69] ==> val argumentVariance: Variance defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection.<anonymous>[LocalVariableDescriptor]

'argumentVariance' @ [103:25] ==> val argumentVariance: Variance defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection.<anonymous>[LocalVariableDescriptor]

'INVARIANT' @ [103:54] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'underlyingVariance' @ [103:67] ==> val underlyingVariance: Variance defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection.<anonymous>[LocalVariableDescriptor]

'reportStrategy' @ [105:29] ==> private final val reportStrategy: TypeAliasExpansionReportStrategy defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[PropertyDescriptorImpl]

'conflictingProjection' @ [105:44] ==> public abstract fun conflictingProjection(typeAlias: TypeAliasDescriptor, typeParameter: TypeParameterDescriptor?, substitutedArgument: KotlinType): Unit defined in org.jetbrains.kotlin.resolve.TypeAliasExpansionReportStrategy[SimpleFunctionDescriptorImpl]

'typeAliasExpansion' @ [105:66] ==> value-parameter typeAliasExpansion: TypeAliasExpansion defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[ValueParameterDescriptorImpl]

'descriptor' @ [105:85] ==> public final val descriptor: TypeAliasDescriptor defined in org.jetbrains.kotlin.resolve.TypeAliasExpansion[PropertyDescriptorImpl]

'typeParameterDescriptor' @ [105:97] ==> value-parameter typeParameterDescriptor: TypeParameterDescriptor? defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[ValueParameterDescriptorImpl]

'argumentType' @ [105:122] ==> val argumentType: UnwrappedType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[LocalVariableDescriptor]

'argumentVariance' @ [106:29] ==> val argumentVariance: Variance defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection.<anonymous>[LocalVariableDescriptor]

'typeParameterDescriptor' @ [110:37] ==> value-parameter typeParameterDescriptor: TypeParameterDescriptor? defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[ValueParameterDescriptorImpl]

'variance' @ [110:62] ==> public final val TypeParameterDescriptor.variance: Variance[MyPropertyDescriptor]

'INVARIANT' @ [110:83] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'when {
                parameterVariance == substitutionVariance -> substitutionVariance
                parameterVariance == Variance.INVARIANT -> substitutionVariance
                substitutionVariance == Variance.INVARIANT -> Variance.INVARIANT
                else -> {
                    reportStrategy.conflictingProjection(typeAliasExpansion.descriptor, typeParameterDescriptor, argumentType)
                    substitutionVariance
                }
            }' @ [112:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Variance, entry1: Variance, entry2: Variance, entry3: Variance): Variance[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Variance

'parameterVariance' @ [113:17] ==> val parameterVariance: Variance defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection.<anonymous>[LocalVariableDescriptor]

'substitutionVariance' @ [113:38] ==> val substitutionVariance: Variance defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection.<anonymous>[LocalVariableDescriptor]

'substitutionVariance' @ [113:62] ==> val substitutionVariance: Variance defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection.<anonymous>[LocalVariableDescriptor]

'parameterVariance' @ [114:17] ==> val parameterVariance: Variance defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection.<anonymous>[LocalVariableDescriptor]

'INVARIANT' @ [114:47] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'substitutionVariance' @ [114:60] ==> val substitutionVariance: Variance defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection.<anonymous>[LocalVariableDescriptor]

'substitutionVariance' @ [115:17] ==> val substitutionVariance: Variance defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection.<anonymous>[LocalVariableDescriptor]

'INVARIANT' @ [115:50] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'INVARIANT' @ [115:72] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'reportStrategy' @ [117:21] ==> private final val reportStrategy: TypeAliasExpansionReportStrategy defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[PropertyDescriptorImpl]

'conflictingProjection' @ [117:36] ==> public abstract fun conflictingProjection(typeAlias: TypeAliasDescriptor, typeParameter: TypeParameterDescriptor?, substitutedArgument: KotlinType): Unit defined in org.jetbrains.kotlin.resolve.TypeAliasExpansionReportStrategy[SimpleFunctionDescriptorImpl]

'typeAliasExpansion' @ [117:58] ==> value-parameter typeAliasExpansion: TypeAliasExpansion defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[ValueParameterDescriptorImpl]

'descriptor' @ [117:77] ==> public final val descriptor: TypeAliasDescriptor defined in org.jetbrains.kotlin.resolve.TypeAliasExpansion[PropertyDescriptorImpl]

'typeParameterDescriptor' @ [117:89] ==> value-parameter typeParameterDescriptor: TypeParameterDescriptor? defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[ValueParameterDescriptorImpl]

'argumentType' @ [117:114] ==> val argumentType: UnwrappedType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[LocalVariableDescriptor]

'substitutionVariance' @ [118:21] ==> val substitutionVariance: Variance defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection.<anonymous>[LocalVariableDescriptor]

'checkRepeatedAnnotations' @ [123:9] ==> private final fun checkRepeatedAnnotations(existingAnnotations: Annotations, newAnnotations: Annotations): Unit defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[SimpleFunctionDescriptorImpl]

'underlyingType' @ [123:34] ==> val underlyingType: KotlinType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[LocalVariableDescriptor]

'annotations' @ [123:49] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'argumentType' @ [123:62] ==> val argumentType: UnwrappedType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[LocalVariableDescriptor]

'annotations' @ [123:75] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.types.UnwrappedType[DeserializedPropertyDescriptor]

'if (argumentType is DynamicType)
                    argumentType.combineAnnotations(underlyingType.annotations)
                else
                    argumentType.asSimpleType().combineNullabilityAndAnnotations(underlyingType)' @ [126:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: UnwrappedType, elseBranch: UnwrappedType): UnwrappedType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> UnwrappedType

'argumentType' @ [126:21] ==> val argumentType: UnwrappedType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[LocalVariableDescriptor]

'argumentType' @ [127:21] ==> val argumentType: UnwrappedType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[LocalVariableDescriptor]

'combineAnnotations' @ [127:34] ==> private final fun DynamicType.combineAnnotations(newAnnotations: Annotations): DynamicType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[SimpleFunctionDescriptorImpl]

'underlyingType' @ [127:53] ==> val underlyingType: KotlinType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[LocalVariableDescriptor]

'annotations' @ [127:68] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'argumentType' @ [129:21] ==> val argumentType: UnwrappedType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[LocalVariableDescriptor]

'asSimpleType' @ [129:34] ==> public fun KotlinType.asSimpleType(): SimpleType defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'combineNullabilityAndAnnotations' @ [129:49] ==> private final fun SimpleType.combineNullabilityAndAnnotations(fromType: KotlinType): SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[SimpleFunctionDescriptorImpl]

'underlyingType' @ [129:82] ==> val underlyingType: KotlinType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[LocalVariableDescriptor]

'TypeProjectionImpl' @ [131:16] ==> public constructor TypeProjectionImpl(@NotNull p0: Variance, @NotNull p1: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'resultingVariance' @ [131:35] ==> val resultingVariance: Variance defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[LocalVariableDescriptor]

'substitutedType' @ [131:54] ==> val substitutedType: UnwrappedType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandTypeProjection[LocalVariableDescriptor]

'replaceAnnotations' @ [135:13] ==> public open fun replaceAnnotations(newAnnotations: Annotations): DynamicType defined in org.jetbrains.kotlin.types.DynamicType[DeserializedSimpleFunctionDescriptor]

'createCombinedAnnotations' @ [135:32] ==> private final fun KotlinType.createCombinedAnnotations(newAnnotations: Annotations): Annotations defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[SimpleFunctionDescriptorImpl]

'newAnnotations' @ [135:58] ==> value-parameter newAnnotations: Annotations defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.combineAnnotations[ValueParameterDescriptorImpl]

'if (isError) this else replace(newAnnotations = createCombinedAnnotations(newAnnotations))' @ [138:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: SimpleType, elseBranch: SimpleType): SimpleType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> SimpleType

'isError' @ [138:17] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types[DeserializedPropertyDescriptor]

'this' @ [138:26] ==> <this> defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.combineAnnotations[ReceiverParameterDescriptorImpl]

'replace' @ [138:36] ==> @JvmOverloads public fun SimpleType.replace(newArguments: List<TypeProjection> = ..., newAnnotations: Annotations = ...): SimpleType defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'createCombinedAnnotations' @ [138:61] ==> private final fun KotlinType.createCombinedAnnotations(newAnnotations: Annotations): Annotations defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[SimpleFunctionDescriptorImpl]

'newAnnotations' @ [138:87] ==> value-parameter newAnnotations: Annotations defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.combineAnnotations[ValueParameterDescriptorImpl]

'isError' @ [141:13] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types[DeserializedPropertyDescriptor]

'annotations' @ [141:29] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'composeAnnotations' @ [143:16] ==> public fun composeAnnotations(first: Annotations, second: Annotations): Annotations defined in org.jetbrains.kotlin.descriptors.annotations[DeserializedSimpleFunctionDescriptor]

'newAnnotations' @ [143:35] ==> value-parameter newAnnotations: Annotations defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.createCombinedAnnotations[ValueParameterDescriptorImpl]

'annotations' @ [143:51] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'existingAnnotations' @ [147:41] ==> value-parameter existingAnnotations: Annotations defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.checkRepeatedAnnotations[ValueParameterDescriptorImpl]

'mapTo' @ [147:61] ==> public inline fun <T, R, C : MutableCollection<in FqName?>> Iterable<AnnotationDescriptor>.mapTo(destination: HashSet<FqName?> /* = HashSet<FqName?> */, transform: (AnnotationDescriptor) -> FqName?): HashSet<FqName?> /* = HashSet<FqName?> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> AnnotationDescriptor
    <R> -> FqName?
    <C : MutableCollection<in R>> -> HashSet<FqName?>

'hashSetOf' @ [147:67] ==> @SinceKotlin @InlineOnly public inline fun <T> hashSetOf(): HashSet<FqName?> /* = HashSet<FqName?> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FqName?

'it' @ [147:82] ==> value-parameter it: AnnotationDescriptor defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.checkRepeatedAnnotations.<anonymous>[ValueParameterDescriptorImpl]

'fqName' @ [147:85] ==> public open val fqName: FqName? defined in org.jetbrains.kotlin.descriptors.annotations.AnnotationDescriptor[DeserializedPropertyDescriptor]

'newAnnotations' @ [149:28] ==> value-parameter newAnnotations: Annotations defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.checkRepeatedAnnotations[ValueParameterDescriptorImpl]

'annotation' @ [150:17] ==> val annotation: AnnotationDescriptor defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.checkRepeatedAnnotations[LocalVariableDescriptor]

'fqName' @ [150:28] ==> public open val fqName: FqName? defined in org.jetbrains.kotlin.descriptors.annotations.AnnotationDescriptor[DeserializedPropertyDescriptor]

'existingAnnotationFqNames' @ [150:38] ==> val existingAnnotationFqNames: HashSet<FqName?> /* = HashSet<FqName?> */ defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.checkRepeatedAnnotations[LocalVariableDescriptor]

'reportStrategy' @ [151:17] ==> private final val reportStrategy: TypeAliasExpansionReportStrategy defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[PropertyDescriptorImpl]

'repeatedAnnotation' @ [151:32] ==> public abstract fun repeatedAnnotation(annotation: AnnotationDescriptor): Unit defined in org.jetbrains.kotlin.resolve.TypeAliasExpansionReportStrategy[SimpleFunctionDescriptorImpl]

'annotation' @ [151:51] ==> val annotation: AnnotationDescriptor defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.checkRepeatedAnnotations[LocalVariableDescriptor]

'makeNullableIfNeeded' @ [157:23] ==> @NotNull public open fun makeNullableIfNeeded(@NotNull p0: SimpleType, p1: Boolean): SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'this' @ [157:44] ==> <this> defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.combineNullability[ReceiverParameterDescriptorImpl]

'fromType' @ [157:50] ==> value-parameter fromType: KotlinType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.combineNullability[ValueParameterDescriptorImpl]

'isMarkedNullable' @ [157:59] ==> public abstract val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'combineNullability' @ [160:13] ==> private final fun SimpleType.combineNullability(fromType: KotlinType): SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[SimpleFunctionDescriptorImpl]

'fromType' @ [160:32] ==> value-parameter fromType: KotlinType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.combineNullabilityAndAnnotations[ValueParameterDescriptorImpl]

'combineAnnotations' @ [160:42] ==> private final fun SimpleType.combineAnnotations(newAnnotations: Annotations): SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[SimpleFunctionDescriptorImpl]

'fromType' @ [160:61] ==> value-parameter fromType: KotlinType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.combineNullabilityAndAnnotations[ValueParameterDescriptorImpl]

'annotations' @ [160:70] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'originalProjection' @ [167:28] ==> value-parameter originalProjection: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[ValueParameterDescriptorImpl]

'type' @ [167:47] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'unwrap' @ [167:52] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'originalType' @ [169:13] ==> val originalType: UnwrappedType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'isDynamic' @ [169:26] ==> public fun KotlinType.isDynamic(): Boolean defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'originalProjection' @ [169:46] ==> value-parameter originalProjection: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[ValueParameterDescriptorImpl]

'originalType' @ [171:20] ==> val originalType: UnwrappedType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'asSimpleType' @ [171:33] ==> public fun KotlinType.asSimpleType(): SimpleType defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'type' @ [173:13] ==> val type: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'isError' @ [173:18] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types[DeserializedPropertyDescriptor]

'!' @ [173:29] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'type' @ [173:30] ==> val type: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'requiresTypeAliasExpansion' @ [173:35] ==> public fun KotlinType.requiresTypeAliasExpansion(): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'originalProjection' @ [174:20] ==> value-parameter originalProjection: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[ValueParameterDescriptorImpl]

'type' @ [177:31] ==> val type: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'constructor' @ [177:36] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'typeConstructor' @ [178:30] ==> val typeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'declarationDescriptor' @ [178:46] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'assert' @ [180:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'typeConstructor' @ [180:16] ==> val typeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'parameters' @ [180:32] ==> public final val TypeConstructor.parameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'size' @ [180:43] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'type' @ [180:51] ==> val type: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'arguments' @ [180:56] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'size' @ [180:66] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'type' @ [180:103] ==> val type: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'when (typeDescriptor) {
            is TypeParameterDescriptor -> {
                originalProjection
            }
            is TypeAliasDescriptor -> {
                if (typeAliasExpansion.isRecursion(typeDescriptor)) {
                    reportStrategy.recursiveTypeAlias(typeDescriptor)
                    return TypeProjectionImpl(Variance.INVARIANT, ErrorUtils.createErrorType("Recursive type alias: ${typeDescriptor.name}"))
                }

                val expandedArguments = type.arguments.mapIndexed { i, typeAliasArgument ->
                    expandTypeProjection(typeAliasArgument, typeAliasExpansion, typeConstructor.parameters[i], recursionDepth + 1)
                }

                val nestedExpansion = TypeAliasExpansion.create(typeAliasExpansion, typeDescriptor, expandedArguments)

                val nestedExpandedType = expandRecursively(nestedExpansion, type.annotations,
                                                           isNullable = type.isMarkedNullable,
                                                           recursionDepth = recursionDepth + 1,
                                                           withAbbreviatedType = false)

                // 'dynamic' type can't be abbreviated - will be reported separately
                val typeWithAbbreviation = if (nestedExpandedType.isDynamic()) nestedExpandedType else nestedExpandedType.withAbbreviation(type)

                TypeProjectionImpl(originalProjection.projectionKind, typeWithAbbreviation)
            }
            else -> {
                val substitutedArguments = type.arguments.mapIndexed { i, originalArgument ->
                    val projection = expandTypeProjection(
                            originalArgument, typeAliasExpansion, typeConstructor.parameters[i], recursionDepth + 1)
                    if (projection.isStarProjection) projection
                    else TypeProjectionImpl(projection.projectionKind,
                                            TypeUtils.makeNullableIfNeeded(projection.type, originalArgument.type.isMarkedNullable))
                }

                val substitutedType = type.replace(newArguments = substitutedArguments)

                checkTypeArgumentsSubstitution(type, substitutedType)

                TypeProjectionImpl(originalProjection.projectionKind, substitutedType)
            }
        }' @ [182:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: TypeProjection, entry1: TypeProjection, entry2: TypeProjection): TypeProjection[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> TypeProjection

'typeDescriptor' @ [182:22] ==> val typeDescriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'originalProjection' @ [184:17] ==> value-parameter originalProjection: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[ValueParameterDescriptorImpl]

'typeAliasExpansion' @ [187:21] ==> value-parameter typeAliasExpansion: TypeAliasExpansion defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[ValueParameterDescriptorImpl]

'isRecursion' @ [187:40] ==> public final fun isRecursion(descriptor: TypeAliasDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.TypeAliasExpansion[SimpleFunctionDescriptorImpl]

'typeDescriptor' @ [187:52] ==> val typeDescriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'reportStrategy' @ [188:21] ==> private final val reportStrategy: TypeAliasExpansionReportStrategy defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[PropertyDescriptorImpl]

'recursiveTypeAlias' @ [188:36] ==> public abstract fun recursiveTypeAlias(typeAlias: TypeAliasDescriptor): Unit defined in org.jetbrains.kotlin.resolve.TypeAliasExpansionReportStrategy[SimpleFunctionDescriptorImpl]

'typeDescriptor' @ [188:55] ==> val typeDescriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'TypeProjectionImpl' @ [189:28] ==> public constructor TypeProjectionImpl(@NotNull p0: Variance, @NotNull p1: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'INVARIANT' @ [189:56] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'createErrorType' @ [189:78] ==> @NotNull public open fun createErrorType(@NotNull p0: String): SimpleType defined in org.jetbrains.kotlin.types.ErrorUtils[JavaMethodDescriptor]

'typeDescriptor' @ [189:119] ==> val typeDescriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'name' @ [189:134] ==> public final val TypeAliasDescriptor.name: Name[MyPropertyDescriptor]

'type' @ [192:41] ==> val type: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'arguments' @ [192:46] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'mapIndexed' @ [192:56] ==> public inline fun <T, R> Iterable<TypeProjection>.mapIndexed(transform: (index: Int, TypeProjection) -> TypeProjection): List<TypeProjection> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection
    <R> -> TypeProjection

'expandTypeProjection' @ [193:21] ==> private final fun expandTypeProjection(underlyingProjection: TypeProjection, typeAliasExpansion: TypeAliasExpansion, typeParameterDescriptor: TypeParameterDescriptor?, recursionDepth: Int): TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[SimpleFunctionDescriptorImpl]

'typeAliasArgument' @ [193:42] ==> value-parameter typeAliasArgument: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection.<anonymous>[ValueParameterDescriptorImpl]

'typeAliasExpansion' @ [193:61] ==> value-parameter typeAliasExpansion: TypeAliasExpansion defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[ValueParameterDescriptorImpl]

'typeConstructor' @ [193:81] ==> val typeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'parameters' @ [193:97] ==> public final val TypeConstructor.parameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'i' @ [193:108] ==> value-parameter i: Int defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection.<anonymous>[ValueParameterDescriptorImpl]

'recursionDepth' @ [193:112] ==> value-parameter recursionDepth: Int defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[ValueParameterDescriptorImpl]

'TypeAliasExpansion' @ [196:39] ==> public companion object defined in org.jetbrains.kotlin.resolve.TypeAliasExpansion[FakeCallableDescriptorForObject]

'create' @ [196:58] ==> public final fun create(parent: TypeAliasExpansion?, typeAliasDescriptor: TypeAliasDescriptor, arguments: List<TypeProjection>): TypeAliasExpansion defined in org.jetbrains.kotlin.resolve.TypeAliasExpansion.Companion[SimpleFunctionDescriptorImpl]

'typeAliasExpansion' @ [196:65] ==> value-parameter typeAliasExpansion: TypeAliasExpansion defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[ValueParameterDescriptorImpl]

'typeDescriptor' @ [196:85] ==> val typeDescriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'expandedArguments' @ [196:101] ==> val expandedArguments: List<TypeProjection> defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'expandRecursively' @ [198:42] ==> private final fun expandRecursively(typeAliasExpansion: TypeAliasExpansion, annotations: Annotations, isNullable: Boolean, recursionDepth: Int, withAbbreviatedType: Boolean): SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[SimpleFunctionDescriptorImpl]

'nestedExpansion' @ [198:60] ==> val nestedExpansion: TypeAliasExpansion defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'type' @ [198:77] ==> val type: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'annotations' @ [198:82] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'type' @ [199:73] ==> val type: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'isMarkedNullable' @ [199:78] ==> public abstract val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'recursionDepth' @ [200:77] ==> value-parameter recursionDepth: Int defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[ValueParameterDescriptorImpl]

'if (nestedExpandedType.isDynamic()) nestedExpandedType else nestedExpandedType.withAbbreviation(type)' @ [204:44] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: SimpleType, elseBranch: SimpleType): SimpleType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> SimpleType

'nestedExpandedType' @ [204:48] ==> val nestedExpandedType: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'isDynamic' @ [204:67] ==> public fun KotlinType.isDynamic(): Boolean defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'nestedExpandedType' @ [204:80] ==> val nestedExpandedType: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'nestedExpandedType' @ [204:104] ==> val nestedExpandedType: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'withAbbreviation' @ [204:123] ==> public fun SimpleType.withAbbreviation(abbreviatedType: SimpleType): SimpleType defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'type' @ [204:140] ==> val type: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'TypeProjectionImpl' @ [206:17] ==> public constructor TypeProjectionImpl(@NotNull p0: Variance, @NotNull p1: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'originalProjection' @ [206:36] ==> value-parameter originalProjection: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[ValueParameterDescriptorImpl]

'projectionKind' @ [206:55] ==> public final val TypeProjection.projectionKind: Variance[MyPropertyDescriptor]

'typeWithAbbreviation' @ [206:71] ==> val typeWithAbbreviation: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'type' @ [209:44] ==> val type: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'arguments' @ [209:49] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'mapIndexed' @ [209:59] ==> public inline fun <T, R> Iterable<TypeProjection>.mapIndexed(transform: (index: Int, TypeProjection) -> TypeProjection): List<TypeProjection> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection
    <R> -> TypeProjection

'expandTypeProjection' @ [210:38] ==> private final fun expandTypeProjection(underlyingProjection: TypeProjection, typeAliasExpansion: TypeAliasExpansion, typeParameterDescriptor: TypeParameterDescriptor?, recursionDepth: Int): TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[SimpleFunctionDescriptorImpl]

'originalArgument' @ [211:29] ==> value-parameter originalArgument: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection.<anonymous>[ValueParameterDescriptorImpl]

'typeAliasExpansion' @ [211:47] ==> value-parameter typeAliasExpansion: TypeAliasExpansion defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[ValueParameterDescriptorImpl]

'typeConstructor' @ [211:67] ==> val typeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'parameters' @ [211:83] ==> public final val TypeConstructor.parameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'i' @ [211:94] ==> value-parameter i: Int defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection.<anonymous>[ValueParameterDescriptorImpl]

'recursionDepth' @ [211:98] ==> value-parameter recursionDepth: Int defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[ValueParameterDescriptorImpl]

'if (projection.isStarProjection) projection
                    else TypeProjectionImpl(projection.projectionKind,
                                            TypeUtils.makeNullableIfNeeded(projection.type, originalArgument.type.isMarkedNullable))' @ [212:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: TypeProjection, elseBranch: TypeProjection): TypeProjection[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> TypeProjection

'projection' @ [212:25] ==> val projection: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection.<anonymous>[LocalVariableDescriptor]

'isStarProjection' @ [212:36] ==> public final val TypeProjection.isStarProjection: Boolean[MyPropertyDescriptor]

'projection' @ [212:54] ==> val projection: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection.<anonymous>[LocalVariableDescriptor]

'TypeProjectionImpl' @ [213:26] ==> public constructor TypeProjectionImpl(@NotNull p0: Variance, @NotNull p1: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'projection' @ [213:45] ==> val projection: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection.<anonymous>[LocalVariableDescriptor]

'projectionKind' @ [213:56] ==> public final val TypeProjection.projectionKind: Variance[MyPropertyDescriptor]

'makeNullableIfNeeded' @ [214:55] ==> @NotNull public open fun makeNullableIfNeeded(@NotNull p0: KotlinType, p1: Boolean): KotlinType defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'projection' @ [214:76] ==> val projection: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection.<anonymous>[LocalVariableDescriptor]

'type' @ [214:87] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'originalArgument' @ [214:93] ==> value-parameter originalArgument: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [214:110] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'isMarkedNullable' @ [214:115] ==> public abstract val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'type' @ [217:39] ==> val type: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'replace' @ [217:44] ==> @JvmOverloads public fun SimpleType.replace(newArguments: List<TypeProjection> = ..., newAnnotations: Annotations = ...): SimpleType defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'substitutedArguments' @ [217:67] ==> val substitutedArguments: List<TypeProjection> defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'checkTypeArgumentsSubstitution' @ [219:17] ==> private final fun checkTypeArgumentsSubstitution(unsubstitutedType: KotlinType, substitutedType: KotlinType): Unit defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[SimpleFunctionDescriptorImpl]

'type' @ [219:48] ==> val type: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'substitutedType' @ [219:54] ==> val substitutedType: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'TypeProjectionImpl' @ [221:17] ==> public constructor TypeProjectionImpl(@NotNull p0: Variance, @NotNull p1: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'originalProjection' @ [221:36] ==> value-parameter originalProjection: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[ValueParameterDescriptorImpl]

'projectionKind' @ [221:55] ==> public final val TypeProjection.projectionKind: Variance[MyPropertyDescriptor]

'substitutedType' @ [221:71] ==> val substitutedType: SimpleType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.expandNonArgumentTypeProjection[LocalVariableDescriptor]

'create' @ [227:47] ==> @NotNull public open fun create(@NotNull p0: KotlinType): TypeSubstitutor defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'substitutedType' @ [227:54] ==> value-parameter substitutedType: KotlinType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.checkTypeArgumentsSubstitution[ValueParameterDescriptorImpl]

'substitutedType' @ [229:9] ==> value-parameter substitutedType: KotlinType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.checkTypeArgumentsSubstitution[ValueParameterDescriptorImpl]

'arguments' @ [229:25] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'forEachIndexed' @ [229:35] ==> public inline fun <T> Iterable<TypeProjection>.forEachIndexed(action: (index: Int, TypeProjection) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection

'!' @ [230:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'substitutedArgument' @ [230:18] ==> value-parameter substitutedArgument: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.checkTypeArgumentsSubstitution.<anonymous>[ValueParameterDescriptorImpl]

'isStarProjection' @ [230:38] ==> public final val TypeProjection.isStarProjection: Boolean[MyPropertyDescriptor]

'!' @ [230:58] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'substitutedArgument' @ [230:59] ==> value-parameter substitutedArgument: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.checkTypeArgumentsSubstitution.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [230:79] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'containsTypeAliasParameters' @ [230:84] ==> public fun KotlinType.containsTypeAliasParameters(): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'unsubstitutedType' @ [231:45] ==> value-parameter unsubstitutedType: KotlinType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.checkTypeArgumentsSubstitution[ValueParameterDescriptorImpl]

'arguments' @ [231:63] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'i' @ [231:73] ==> value-parameter i: Int defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.checkTypeArgumentsSubstitution.<anonymous>[ValueParameterDescriptorImpl]

'unsubstitutedType' @ [232:37] ==> value-parameter unsubstitutedType: KotlinType defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.checkTypeArgumentsSubstitution[ValueParameterDescriptorImpl]

'constructor' @ [232:55] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'parameters' @ [232:67] ==> public final val TypeConstructor.parameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'i' @ [232:78] ==> value-parameter i: Int defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.checkTypeArgumentsSubstitution.<anonymous>[ValueParameterDescriptorImpl]

'shouldCheckBounds' @ [233:21] ==> private final val shouldCheckBounds: Boolean defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[PropertyDescriptorImpl]

'checkBoundsInTypeAlias' @ [234:40] ==> public open fun checkBoundsInTypeAlias(@NotNull reportStrategy: TypeAliasExpansionReportStrategy, @NotNull unsubstitutedArgument: KotlinType, @NotNull typeArgument: KotlinType, @NotNull typeParameterDescriptor: TypeParameterDescriptor, @NotNull substitutor: TypeSubstitutor): Unit defined in org.jetbrains.kotlin.resolve.DescriptorResolver[JavaMethodDescriptor]

'reportStrategy' @ [234:63] ==> private final val reportStrategy: TypeAliasExpansionReportStrategy defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[PropertyDescriptorImpl]

'unsubstitutedArgument' @ [234:79] ==> val unsubstitutedArgument: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.checkTypeArgumentsSubstitution.<anonymous>[LocalVariableDescriptor]

'type' @ [234:101] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'substitutedArgument' @ [234:107] ==> value-parameter substitutedArgument: TypeProjection defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.checkTypeArgumentsSubstitution.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [234:127] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'typeParameter' @ [234:133] ==> val typeParameter: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.checkTypeArgumentsSubstitution.<anonymous>[LocalVariableDescriptor]

'typeSubstitutor' @ [234:148] ==> val typeSubstitutor: TypeSubstitutor defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.checkTypeArgumentsSubstitution[LocalVariableDescriptor]

'recursionDepth' @ [244:17] ==> value-parameter recursionDepth: Int defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.Companion.assertRecursionDepth[ValueParameterDescriptorImpl]

'MAX_RECURSION_DEPTH' @ [244:34] ==> private const final val MAX_RECURSION_DEPTH: Int defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.Companion[PropertyDescriptorImpl]

'AssertionError' @ [245:23] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'typeAliasDescriptor' @ [245:87] ==> value-parameter typeAliasDescriptor: TypeAliasDescriptor defined in org.jetbrains.kotlin.resolve.TypeAliasExpander.Companion.assertRecursionDepth[ValueParameterDescriptorImpl]

'name' @ [245:107] ==> public final val TypeAliasDescriptor.name: Name[MyPropertyDescriptor]

'TypeAliasExpander' @ [249:29] ==> public constructor TypeAliasExpander(reportStrategy: TypeAliasExpansionReportStrategy, shouldCheckBounds: Boolean) defined in org.jetbrains.kotlin.resolve.TypeAliasExpander[ClassConstructorDescriptorImpl]

'DO_NOTHING' @ [249:80] ==> public object DO_NOTHING : TypeAliasExpansionReportStrategy defined in org.jetbrains.kotlin.resolve.TypeAliasExpansionReportStrategy[FakeCallableDescriptorForObject]

