'of' @ [55:52] ==> @SafeVarargs public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?), vararg p1: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'CLASS_ONLY' @ [55:55] ==> enum entry CLASS_ONLY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'OBJECT' @ [55:67] ==> enum entry OBJECT defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'INTERFACE' @ [55:75] ==> enum entry INTERFACE defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ENUM_CLASS' @ [55:86] ==> enum entry ENUM_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ANNOTATION_CLASS' @ [55:98] ==> enum entry ANNOTATION_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'MEMBER_FUNCTION' @ [56:55] ==> enum entry MEMBER_FUNCTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'TOP_LEVEL_FUNCTION' @ [56:72] ==> enum entry TOP_LEVEL_FUNCTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'PROPERTY_GETTER' @ [56:92] ==> enum entry PROPERTY_GETTER defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'PROPERTY_SETTER' @ [56:109] ==> enum entry PROPERTY_SETTER defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'MEMBER_PROPERTY' @ [57:55] ==> enum entry MEMBER_PROPERTY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'TOP_LEVEL_PROPERTY' @ [57:72] ==> enum entry TOP_LEVEL_PROPERTY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'CONSTRUCTOR' @ [57:92] ==> enum entry CONSTRUCTOR defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'TYPEALIAS' @ [57:105] ==> enum entry TYPEALIAS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'mapOf' @ [59:29] ==> public fun <K, V> mapOf(vararg pairs: Pair<KtModifierKeywordToken, Set<KotlinTarget>>): Map<KtModifierKeywordToken, Set<KotlinTarget>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> KtModifierKeywordToken
    <V> -> Set<KotlinTarget>

'ENUM_KEYWORD' @ [60:13] ==> public final val ENUM_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [60:42] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'ENUM_CLASS' @ [60:45] ==> enum entry ENUM_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ABSTRACT_KEYWORD' @ [61:13] ==> public final val ABSTRACT_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [61:42] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?), p1: (KotlinTarget..KotlinTarget?), p2: (KotlinTarget..KotlinTarget?), p3: (KotlinTarget..KotlinTarget?), p4: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'CLASS_ONLY' @ [61:45] ==> enum entry CLASS_ONLY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'LOCAL_CLASS' @ [61:57] ==> enum entry LOCAL_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'INTERFACE' @ [61:70] ==> enum entry INTERFACE defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'MEMBER_PROPERTY' @ [61:81] ==> enum entry MEMBER_PROPERTY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'MEMBER_FUNCTION' @ [61:98] ==> enum entry MEMBER_FUNCTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'OPEN_KEYWORD' @ [62:13] ==> public final val OPEN_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [62:42] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?), p1: (KotlinTarget..KotlinTarget?), p2: (KotlinTarget..KotlinTarget?), p3: (KotlinTarget..KotlinTarget?), p4: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'CLASS_ONLY' @ [62:45] ==> enum entry CLASS_ONLY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'LOCAL_CLASS' @ [62:57] ==> enum entry LOCAL_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'INTERFACE' @ [62:70] ==> enum entry INTERFACE defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'MEMBER_PROPERTY' @ [62:81] ==> enum entry MEMBER_PROPERTY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'MEMBER_FUNCTION' @ [62:98] ==> enum entry MEMBER_FUNCTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'FINAL_KEYWORD' @ [63:13] ==> public final val FINAL_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [63:42] ==> @SafeVarargs public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?), vararg p1: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'CLASS_ONLY' @ [63:45] ==> enum entry CLASS_ONLY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'LOCAL_CLASS' @ [63:57] ==> enum entry LOCAL_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ENUM_CLASS' @ [63:70] ==> enum entry ENUM_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'OBJECT' @ [63:82] ==> enum entry OBJECT defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'MEMBER_PROPERTY' @ [63:90] ==> enum entry MEMBER_PROPERTY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'MEMBER_FUNCTION' @ [63:107] ==> enum entry MEMBER_FUNCTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'SEALED_KEYWORD' @ [64:13] ==> public final val SEALED_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [64:42] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'CLASS_ONLY' @ [64:45] ==> enum entry CLASS_ONLY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'INNER_KEYWORD' @ [65:13] ==> public final val INNER_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [65:42] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'CLASS_ONLY' @ [65:45] ==> enum entry CLASS_ONLY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'OVERRIDE_KEYWORD' @ [66:13] ==> public final val OVERRIDE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [66:42] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?), p1: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'MEMBER_PROPERTY' @ [66:45] ==> enum entry MEMBER_PROPERTY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'MEMBER_FUNCTION' @ [66:62] ==> enum entry MEMBER_FUNCTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'PRIVATE_KEYWORD' @ [67:13] ==> public final val PRIVATE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'defaultVisibilityTargets' @ [67:34] ==> private final val defaultVisibilityTargets: (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[PropertyDescriptorImpl]

'PUBLIC_KEYWORD' @ [68:13] ==> public final val PUBLIC_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'defaultVisibilityTargets' @ [68:34] ==> private final val defaultVisibilityTargets: (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[PropertyDescriptorImpl]

'INTERNAL_KEYWORD' @ [69:13] ==> public final val INTERNAL_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'defaultVisibilityTargets' @ [69:34] ==> private final val defaultVisibilityTargets: (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[PropertyDescriptorImpl]

'PROTECTED_KEYWORD' @ [70:13] ==> public final val PROTECTED_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [70:42] ==> @SafeVarargs public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?), vararg p1: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'CLASS_ONLY' @ [70:45] ==> enum entry CLASS_ONLY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'OBJECT' @ [70:57] ==> enum entry OBJECT defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'INTERFACE' @ [70:65] ==> enum entry INTERFACE defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ENUM_CLASS' @ [70:76] ==> enum entry ENUM_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ANNOTATION_CLASS' @ [70:88] ==> enum entry ANNOTATION_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'MEMBER_FUNCTION' @ [71:45] ==> enum entry MEMBER_FUNCTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'PROPERTY_GETTER' @ [71:62] ==> enum entry PROPERTY_GETTER defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'PROPERTY_SETTER' @ [71:79] ==> enum entry PROPERTY_SETTER defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'MEMBER_PROPERTY' @ [71:96] ==> enum entry MEMBER_PROPERTY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'CONSTRUCTOR' @ [71:113] ==> enum entry CONSTRUCTOR defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'TYPEALIAS' @ [71:126] ==> enum entry TYPEALIAS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'IN_KEYWORD' @ [72:13] ==> public final val IN_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [72:42] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?), p1: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'TYPE_PARAMETER' @ [72:45] ==> enum entry TYPE_PARAMETER defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'TYPE_PROJECTION' @ [72:61] ==> enum entry TYPE_PROJECTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'OUT_KEYWORD' @ [73:13] ==> public final val OUT_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [73:42] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?), p1: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'TYPE_PARAMETER' @ [73:45] ==> enum entry TYPE_PARAMETER defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'TYPE_PROJECTION' @ [73:61] ==> enum entry TYPE_PROJECTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'REIFIED_KEYWORD' @ [74:13] ==> public final val REIFIED_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [74:42] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'TYPE_PARAMETER' @ [74:45] ==> enum entry TYPE_PARAMETER defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'VARARG_KEYWORD' @ [75:13] ==> public final val VARARG_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [75:42] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?), p1: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'VALUE_PARAMETER' @ [75:45] ==> enum entry VALUE_PARAMETER defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'PROPERTY_PARAMETER' @ [75:62] ==> enum entry PROPERTY_PARAMETER defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'COMPANION_KEYWORD' @ [76:13] ==> public final val COMPANION_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [76:42] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'OBJECT' @ [76:45] ==> enum entry OBJECT defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'LATEINIT_KEYWORD' @ [77:13] ==> public final val LATEINIT_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [77:41] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'MEMBER_PROPERTY' @ [77:44] ==> enum entry MEMBER_PROPERTY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'DATA_KEYWORD' @ [78:13] ==> public final val DATA_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [78:42] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?), p1: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'CLASS_ONLY' @ [78:45] ==> enum entry CLASS_ONLY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'LOCAL_CLASS' @ [78:57] ==> enum entry LOCAL_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'INLINE_KEYWORD' @ [79:13] ==> public final val INLINE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [79:42] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?), p1: (KotlinTarget..KotlinTarget?), p2: (KotlinTarget..KotlinTarget?), p3: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'FUNCTION' @ [79:45] ==> enum entry FUNCTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'PROPERTY' @ [79:55] ==> enum entry PROPERTY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'PROPERTY_GETTER' @ [79:65] ==> enum entry PROPERTY_GETTER defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'PROPERTY_SETTER' @ [79:82] ==> enum entry PROPERTY_SETTER defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'NOINLINE_KEYWORD' @ [80:13] ==> public final val NOINLINE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [80:42] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'VALUE_PARAMETER' @ [80:45] ==> enum entry VALUE_PARAMETER defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'TAILREC_KEYWORD' @ [81:13] ==> public final val TAILREC_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [81:42] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'FUNCTION' @ [81:45] ==> enum entry FUNCTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'SUSPEND_KEYWORD' @ [82:13] ==> public final val SUSPEND_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [82:42] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?), p1: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'MEMBER_FUNCTION' @ [82:45] ==> enum entry MEMBER_FUNCTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'TOP_LEVEL_FUNCTION' @ [82:62] ==> enum entry TOP_LEVEL_FUNCTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'EXTERNAL_KEYWORD' @ [83:13] ==> public final val EXTERNAL_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [83:42] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?), p1: (KotlinTarget..KotlinTarget?), p2: (KotlinTarget..KotlinTarget?), p3: (KotlinTarget..KotlinTarget?), p4: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'FUNCTION' @ [83:45] ==> enum entry FUNCTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'PROPERTY' @ [83:55] ==> enum entry PROPERTY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'PROPERTY_GETTER' @ [83:65] ==> enum entry PROPERTY_GETTER defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'PROPERTY_SETTER' @ [83:82] ==> enum entry PROPERTY_SETTER defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'CLASS' @ [83:99] ==> enum entry CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ANNOTATION_KEYWORD' @ [84:13] ==> public final val ANNOTATION_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [84:43] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'ANNOTATION_CLASS' @ [84:46] ==> enum entry ANNOTATION_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'CROSSINLINE_KEYWORD' @ [85:13] ==> public final val CROSSINLINE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [85:44] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'VALUE_PARAMETER' @ [85:47] ==> enum entry VALUE_PARAMETER defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'CONST_KEYWORD' @ [86:13] ==> public final val CONST_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [86:42] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?), p1: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'MEMBER_PROPERTY' @ [86:45] ==> enum entry MEMBER_PROPERTY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'TOP_LEVEL_PROPERTY' @ [86:62] ==> enum entry TOP_LEVEL_PROPERTY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'OPERATOR_KEYWORD' @ [87:13] ==> public final val OPERATOR_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [87:42] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'FUNCTION' @ [87:45] ==> enum entry FUNCTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'INFIX_KEYWORD' @ [88:13] ==> public final val INFIX_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [88:42] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'FUNCTION' @ [88:45] ==> enum entry FUNCTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'HEADER_KEYWORD' @ [89:13] ==> public final val HEADER_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [89:42] ==> @SafeVarargs public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?), vararg p1: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'TOP_LEVEL_FUNCTION' @ [89:45] ==> enum entry TOP_LEVEL_FUNCTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'TOP_LEVEL_PROPERTY_WITHOUT_FIELD_OR_DELEGATE' @ [89:65] ==> enum entry TOP_LEVEL_PROPERTY_WITHOUT_FIELD_OR_DELEGATE defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'CLASS_ONLY' @ [89:111] ==> enum entry CLASS_ONLY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'OBJECT' @ [89:123] ==> enum entry OBJECT defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'INTERFACE' @ [89:131] ==> enum entry INTERFACE defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ENUM_CLASS' @ [89:142] ==> enum entry ENUM_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ANNOTATION_CLASS' @ [89:154] ==> enum entry ANNOTATION_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'IMPL_KEYWORD' @ [90:13] ==> public final val IMPL_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [90:42] ==> @SafeVarargs public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?), vararg p1: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'TOP_LEVEL_FUNCTION' @ [90:45] ==> enum entry TOP_LEVEL_FUNCTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'MEMBER_FUNCTION' @ [90:65] ==> enum entry MEMBER_FUNCTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'TOP_LEVEL_PROPERTY' @ [90:82] ==> enum entry TOP_LEVEL_PROPERTY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'MEMBER_PROPERTY' @ [90:102] ==> enum entry MEMBER_PROPERTY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'CONSTRUCTOR' @ [90:119] ==> enum entry CONSTRUCTOR defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'CLASS_ONLY' @ [90:132] ==> enum entry CLASS_ONLY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'OBJECT' @ [90:144] ==> enum entry OBJECT defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'INTERFACE' @ [90:152] ==> enum entry INTERFACE defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ENUM_CLASS' @ [90:163] ==> enum entry ENUM_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ANNOTATION_CLASS' @ [90:175] ==> enum entry ANNOTATION_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'TYPEALIAS' @ [90:193] ==> enum entry TYPEALIAS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'mapOf' @ [93:39] ==> public fun <K, V> mapOf(vararg pairs: Pair<(KtModifierKeywordToken..KtModifierKeywordToken?), LanguageFeature>): Map<(KtModifierKeywordToken..KtModifierKeywordToken?), LanguageFeature> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.lexer.KtModifierKeywordToken..org.jetbrains.kotlin.lexer.KtModifierKeywordToken?)
    <V> -> LanguageFeature

'SUSPEND_KEYWORD' @ [94:13] ==> public final val SUSPEND_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'Coroutines' @ [94:50] ==> enum entry Coroutines defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'INLINE_KEYWORD' @ [95:13] ==> public final val INLINE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'InlineProperties' @ [95:50] ==> enum entry InlineProperties defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'HEADER_KEYWORD' @ [96:13] ==> public final val HEADER_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'MultiPlatformProjects' @ [96:50] ==> enum entry MultiPlatformProjects defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'IMPL_KEYWORD' @ [97:13] ==> public final val IMPL_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'MultiPlatformProjects' @ [97:50] ==> enum entry MultiPlatformProjects defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'mapOf' @ [100:46] ==> public fun <K, V> mapOf(pair: Pair<LanguageFeature, Set<KotlinTarget>>): Map<LanguageFeature, Set<KotlinTarget>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> LanguageFeature
    <V> -> Set<KotlinTarget>

'LanguageFeature' @ [101:13] ==> public companion object defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'InlineProperties' @ [101:29] ==> enum entry InlineProperties defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'setOf' @ [101:49] ==> public fun <T> setOf(vararg elements: KotlinTarget): Set<KotlinTarget> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'PROPERTY' @ [101:55] ==> enum entry PROPERTY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'PROPERTY_GETTER' @ [101:65] ==> enum entry PROPERTY_GETTER defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'PROPERTY_SETTER' @ [101:82] ==> enum entry PROPERTY_SETTER defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'mapOf' @ [105:39] ==> @InlineOnly public inline fun <K, V> mapOf(): Map<KtModifierKeywordToken, Set<KotlinTarget>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> KtModifierKeywordToken
    <V> -> Set<KotlinTarget>

'mapOf' @ [108:38] ==> public fun <K, V> mapOf(pair: Pair<KtModifierKeywordToken, Set<KotlinTarget>>): Map<KtModifierKeywordToken, Set<KotlinTarget>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> KtModifierKeywordToken
    <V> -> Set<KotlinTarget>

'OPEN_KEYWORD' @ [109:13] ==> public final val OPEN_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [109:38] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'INTERFACE' @ [109:41] ==> enum entry INTERFACE defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'mapOf' @ [112:35] ==> public fun <K, V> mapOf(vararg pairs: Pair<KtModifierKeywordToken, Set<KotlinTarget>>): Map<KtModifierKeywordToken, Set<KotlinTarget>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> KtModifierKeywordToken
    <V> -> Set<KotlinTarget>

'INNER_KEYWORD' @ [113:13] ==> public final val INNER_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [113:42] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?), p1: (KotlinTarget..KotlinTarget?), p2: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'CLASS_ONLY' @ [113:45] ==> enum entry CLASS_ONLY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'LOCAL_CLASS' @ [113:57] ==> enum entry LOCAL_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ENUM_CLASS' @ [113:70] ==> enum entry ENUM_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'OVERRIDE_KEYWORD' @ [114:13] ==> public final val OVERRIDE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [114:42] ==> @SafeVarargs public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?), vararg p1: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'CLASS_ONLY' @ [114:45] ==> enum entry CLASS_ONLY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'LOCAL_CLASS' @ [114:58] ==> enum entry LOCAL_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'OBJECT' @ [114:71] ==> enum entry OBJECT defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'OBJECT_LITERAL' @ [114:79] ==> enum entry OBJECT_LITERAL defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'INTERFACE' @ [115:45] ==> enum entry INTERFACE defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ENUM_CLASS' @ [115:56] ==> enum entry ENUM_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ENUM_ENTRY' @ [115:68] ==> enum entry ENUM_ENTRY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'PROTECTED_KEYWORD' @ [116:13] ==> public final val PROTECTED_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [116:42] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?), p1: (KotlinTarget..KotlinTarget?), p2: (KotlinTarget..KotlinTarget?), p3: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'CLASS_ONLY' @ [116:45] ==> enum entry CLASS_ONLY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'LOCAL_CLASS' @ [116:57] ==> enum entry LOCAL_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ENUM_CLASS' @ [116:70] ==> enum entry ENUM_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'COMPANION_OBJECT' @ [116:82] ==> enum entry COMPANION_OBJECT defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'INTERNAL_KEYWORD' @ [117:13] ==> public final val INTERNAL_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [117:42] ==> @SafeVarargs public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?), vararg p1: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'CLASS_ONLY' @ [117:45] ==> enum entry CLASS_ONLY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'LOCAL_CLASS' @ [117:57] ==> enum entry LOCAL_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'OBJECT' @ [117:70] ==> enum entry OBJECT defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'OBJECT_LITERAL' @ [117:78] ==> enum entry OBJECT_LITERAL defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ENUM_CLASS' @ [118:45] ==> enum entry ENUM_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ENUM_ENTRY' @ [118:57] ==> enum entry ENUM_ENTRY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'FILE' @ [118:69] ==> enum entry FILE defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'PRIVATE_KEYWORD' @ [119:13] ==> public final val PRIVATE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [119:42] ==> @SafeVarargs public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?), vararg p1: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'CLASS_ONLY' @ [119:45] ==> enum entry CLASS_ONLY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'LOCAL_CLASS' @ [119:57] ==> enum entry LOCAL_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'OBJECT' @ [119:70] ==> enum entry OBJECT defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'OBJECT_LITERAL' @ [119:78] ==> enum entry OBJECT_LITERAL defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'INTERFACE' @ [120:45] ==> enum entry INTERFACE defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ENUM_CLASS' @ [120:56] ==> enum entry ENUM_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ENUM_ENTRY' @ [120:68] ==> enum entry ENUM_ENTRY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'FILE' @ [120:80] ==> enum entry FILE defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'COMPANION_KEYWORD' @ [121:13] ==> public final val COMPANION_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [121:42] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?), p1: (KotlinTarget..KotlinTarget?), p2: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'CLASS_ONLY' @ [121:45] ==> enum entry CLASS_ONLY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ENUM_CLASS' @ [121:57] ==> enum entry ENUM_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'INTERFACE' @ [121:69] ==> enum entry INTERFACE defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'FINAL_KEYWORD' @ [122:13] ==> public final val FINAL_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [122:42] ==> @SafeVarargs public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?), vararg p1: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'CLASS_ONLY' @ [122:45] ==> enum entry CLASS_ONLY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'LOCAL_CLASS' @ [122:57] ==> enum entry LOCAL_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'OBJECT' @ [122:70] ==> enum entry OBJECT defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'OBJECT_LITERAL' @ [122:78] ==> enum entry OBJECT_LITERAL defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ENUM_CLASS' @ [123:45] ==> enum entry ENUM_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ENUM_ENTRY' @ [123:57] ==> enum entry ENUM_ENTRY defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'ANNOTATION_CLASS' @ [123:69] ==> enum entry ANNOTATION_CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'FILE' @ [123:87] ==> enum entry FILE defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'VARARG_KEYWORD' @ [124:13] ==> public final val VARARG_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'of' @ [124:42] ==> public open fun <E : (Enum<(KotlinTarget..KotlinTarget?)>..Enum<(KotlinTarget..KotlinTarget?)>?)> of(p0: (KotlinTarget..KotlinTarget?), p1: (KotlinTarget..KotlinTarget?), p2: (KotlinTarget..KotlinTarget?)): (EnumSet<(KotlinTarget..KotlinTarget?)>..EnumSet<(KotlinTarget..KotlinTarget?)>?) defined in java.util.EnumSet[JavaMethodDescriptor]
Inferred types:
    <E : (Enum<(E..E?)>..Enum<(E..E?)>?)> -> (org.jetbrains.kotlin.descriptors.annotations.KotlinTarget..org.jetbrains.kotlin.descriptors.annotations.KotlinTarget?)

'CONSTRUCTOR' @ [124:45] ==> enum entry CONSTRUCTOR defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'FUNCTION' @ [124:58] ==> enum entry FUNCTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'CLASS' @ [124:68] ==> enum entry CLASS defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'mapOf' @ [127:37] ==> @InlineOnly public inline fun <K, V> mapOf(): Map<KtModifierKeywordToken, Set<KotlinTarget>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> KtModifierKeywordToken
    <V> -> Set<KotlinTarget>

'buildCompatibilityMap' @ [130:39] ==> private final fun buildCompatibilityMap(): Map<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'hashMapOf' @ [133:22] ==> @SinceKotlin @InlineOnly public inline fun <K, V> hashMapOf(): HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> /* = HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Pair<KtModifierKeywordToken, KtModifierKeywordToken>
    <V> -> Compatibility

'result' @ [135:9] ==> val result: HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> /* = HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.buildCompatibilityMap[LocalVariableDescriptor]

'incompatibilityRegister' @ [135:19] ==> private final fun incompatibilityRegister(vararg list: KtModifierKeywordToken): Map<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'IN_KEYWORD' @ [135:43] ==> public final val IN_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'OUT_KEYWORD' @ [135:55] ==> public final val OUT_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'result' @ [137:9] ==> val result: HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> /* = HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.buildCompatibilityMap[LocalVariableDescriptor]

'incompatibilityRegister' @ [137:19] ==> private final fun incompatibilityRegister(vararg list: KtModifierKeywordToken): Map<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'PRIVATE_KEYWORD' @ [137:43] ==> public final val PRIVATE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'PROTECTED_KEYWORD' @ [137:60] ==> public final val PROTECTED_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'PUBLIC_KEYWORD' @ [137:79] ==> public final val PUBLIC_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'INTERNAL_KEYWORD' @ [137:95] ==> public final val INTERNAL_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'result' @ [139:9] ==> val result: HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> /* = HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.buildCompatibilityMap[LocalVariableDescriptor]

'incompatibilityRegister' @ [139:19] ==> private final fun incompatibilityRegister(vararg list: KtModifierKeywordToken): Map<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'ABSTRACT_KEYWORD' @ [139:43] ==> public final val ABSTRACT_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'OPEN_KEYWORD' @ [139:61] ==> public final val OPEN_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'FINAL_KEYWORD' @ [139:75] ==> public final val FINAL_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'SEALED_KEYWORD' @ [139:90] ==> public final val SEALED_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'result' @ [141:9] ==> val result: HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> /* = HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.buildCompatibilityMap[LocalVariableDescriptor]

'incompatibilityRegister' @ [141:19] ==> private final fun incompatibilityRegister(vararg list: KtModifierKeywordToken): Map<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'DATA_KEYWORD' @ [141:43] ==> public final val DATA_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'OPEN_KEYWORD' @ [141:57] ==> public final val OPEN_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'result' @ [142:9] ==> val result: HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> /* = HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.buildCompatibilityMap[LocalVariableDescriptor]

'incompatibilityRegister' @ [142:19] ==> private final fun incompatibilityRegister(vararg list: KtModifierKeywordToken): Map<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'DATA_KEYWORD' @ [142:43] ==> public final val DATA_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'INNER_KEYWORD' @ [142:57] ==> public final val INNER_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'result' @ [143:9] ==> val result: HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> /* = HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.buildCompatibilityMap[LocalVariableDescriptor]

'incompatibilityRegister' @ [143:19] ==> private final fun incompatibilityRegister(vararg list: KtModifierKeywordToken): Map<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'DATA_KEYWORD' @ [143:43] ==> public final val DATA_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'ABSTRACT_KEYWORD' @ [143:57] ==> public final val ABSTRACT_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'result' @ [144:9] ==> val result: HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> /* = HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.buildCompatibilityMap[LocalVariableDescriptor]

'incompatibilityRegister' @ [144:19] ==> private final fun incompatibilityRegister(vararg list: KtModifierKeywordToken): Map<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'DATA_KEYWORD' @ [144:43] ==> public final val DATA_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'SEALED_KEYWORD' @ [144:57] ==> public final val SEALED_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'result' @ [146:9] ==> val result: HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> /* = HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.buildCompatibilityMap[LocalVariableDescriptor]

'redundantRegister' @ [146:19] ==> private final fun redundantRegister(sufficient: KtModifierKeywordToken, redundant: KtModifierKeywordToken): Map<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'ABSTRACT_KEYWORD' @ [146:37] ==> public final val ABSTRACT_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'OPEN_KEYWORD' @ [146:55] ==> public final val OPEN_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'result' @ [148:9] ==> val result: HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> /* = HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.buildCompatibilityMap[LocalVariableDescriptor]

'redundantRegister' @ [148:19] ==> private final fun redundantRegister(sufficient: KtModifierKeywordToken, redundant: KtModifierKeywordToken): Map<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'SEALED_KEYWORD' @ [148:37] ==> public final val SEALED_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'ABSTRACT_KEYWORD' @ [148:53] ==> public final val ABSTRACT_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'result' @ [151:9] ==> val result: HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> /* = HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.buildCompatibilityMap[LocalVariableDescriptor]

'incompatibilityRegister' @ [151:19] ==> private final fun incompatibilityRegister(vararg list: KtModifierKeywordToken): Map<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'CONST_KEYWORD' @ [151:43] ==> public final val CONST_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'ABSTRACT_KEYWORD' @ [151:58] ==> public final val ABSTRACT_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'result' @ [152:9] ==> val result: HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> /* = HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.buildCompatibilityMap[LocalVariableDescriptor]

'incompatibilityRegister' @ [152:19] ==> private final fun incompatibilityRegister(vararg list: KtModifierKeywordToken): Map<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'CONST_KEYWORD' @ [152:43] ==> public final val CONST_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'OPEN_KEYWORD' @ [152:58] ==> public final val OPEN_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'result' @ [153:9] ==> val result: HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> /* = HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.buildCompatibilityMap[LocalVariableDescriptor]

'incompatibilityRegister' @ [153:19] ==> private final fun incompatibilityRegister(vararg list: KtModifierKeywordToken): Map<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'CONST_KEYWORD' @ [153:43] ==> public final val CONST_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'OVERRIDE_KEYWORD' @ [153:58] ==> public final val OVERRIDE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'result' @ [156:9] ==> val result: HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> /* = HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.buildCompatibilityMap[LocalVariableDescriptor]

'incompatibilityRegister' @ [156:19] ==> private final fun incompatibilityRegister(vararg list: KtModifierKeywordToken): Map<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'PRIVATE_KEYWORD' @ [156:43] ==> public final val PRIVATE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'OVERRIDE_KEYWORD' @ [156:60] ==> public final val OVERRIDE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'result' @ [158:9] ==> val result: HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> /* = HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.buildCompatibilityMap[LocalVariableDescriptor]

'compatibilityForClassesRegister' @ [158:19] ==> private final fun compatibilityForClassesRegister(vararg list: KtModifierKeywordToken): Map<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'PRIVATE_KEYWORD' @ [158:51] ==> public final val PRIVATE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'OPEN_KEYWORD' @ [158:68] ==> public final val OPEN_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'result' @ [159:9] ==> val result: HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> /* = HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.buildCompatibilityMap[LocalVariableDescriptor]

'compatibilityForClassesRegister' @ [159:19] ==> private final fun compatibilityForClassesRegister(vararg list: KtModifierKeywordToken): Map<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'PRIVATE_KEYWORD' @ [159:51] ==> public final val PRIVATE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'ABSTRACT_KEYWORD' @ [159:68] ==> public final val ABSTRACT_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'result' @ [161:9] ==> val result: HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> /* = HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.buildCompatibilityMap[LocalVariableDescriptor]

'incompatibilityRegister' @ [161:19] ==> private final fun incompatibilityRegister(vararg list: KtModifierKeywordToken): Map<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'CROSSINLINE_KEYWORD' @ [161:43] ==> public final val CROSSINLINE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'NOINLINE_KEYWORD' @ [161:64] ==> public final val NOINLINE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'result' @ [167:9] ==> val result: HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> /* = HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.buildCompatibilityMap[LocalVariableDescriptor]

'incompatibilityRegister' @ [167:19] ==> private final fun incompatibilityRegister(vararg list: KtModifierKeywordToken): Map<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'SEALED_KEYWORD' @ [167:43] ==> public final val SEALED_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'INNER_KEYWORD' @ [167:59] ==> public final val INNER_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'result' @ [169:16] ==> val result: HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> /* = HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.buildCompatibilityMap[LocalVariableDescriptor]

'mapOf' @ [176:16] ==> public fun <K, V> mapOf(vararg pairs: Pair<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility>): Map<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Pair<KtModifierKeywordToken, KtModifierKeywordToken>
    <V> -> Compatibility

'Pair' @ [176:22] ==> public constructor Pair<out A, out B>(first: KtModifierKeywordToken, second: KtModifierKeywordToken) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> KtModifierKeywordToken
    <out B> -> KtModifierKeywordToken

'sufficient' @ [176:27] ==> value-parameter sufficient: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.redundantRegister[ValueParameterDescriptorImpl]

'redundant' @ [176:39] ==> value-parameter redundant: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.redundantRegister[ValueParameterDescriptorImpl]

'REDUNDANT' @ [176:67] ==> enum entry REDUNDANT defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.Compatibility[FakeCallableDescriptorForObject]

'Pair' @ [177:22] ==> public constructor Pair<out A, out B>(first: KtModifierKeywordToken, second: KtModifierKeywordToken) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> KtModifierKeywordToken
    <out B> -> KtModifierKeywordToken

'redundant' @ [177:27] ==> value-parameter redundant: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.redundantRegister[ValueParameterDescriptorImpl]

'sufficient' @ [177:38] ==> value-parameter sufficient: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.redundantRegister[ValueParameterDescriptorImpl]

'REVERSE_REDUNDANT' @ [177:67] ==> enum entry REVERSE_REDUNDANT defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.Compatibility[FakeCallableDescriptorForObject]

'hashMapOf' @ [183:22] ==> @SinceKotlin @InlineOnly public inline fun <K, V> hashMapOf(): HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> /* = HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Pair<KtModifierKeywordToken, KtModifierKeywordToken>
    <V> -> Compatibility

'list' @ [184:23] ==> value-parameter vararg list: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.compatibilityRegister[ValueParameterDescriptorImpl]

'list' @ [185:28] ==> value-parameter vararg list: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.compatibilityRegister[ValueParameterDescriptorImpl]

'first' @ [186:21] ==> val first: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.compatibilityRegister[LocalVariableDescriptor]

'second' @ [186:30] ==> val second: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.compatibilityRegister[LocalVariableDescriptor]

'result' @ [187:21] ==> val result: HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> /* = HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.compatibilityRegister[LocalVariableDescriptor]

'Pair' @ [187:28] ==> public constructor Pair<out A, out B>(first: KtModifierKeywordToken, second: KtModifierKeywordToken) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> KtModifierKeywordToken
    <out B> -> KtModifierKeywordToken

'first' @ [187:33] ==> val first: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.compatibilityRegister[LocalVariableDescriptor]

'second' @ [187:40] ==> val second: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.compatibilityRegister[LocalVariableDescriptor]

'compatibility' @ [187:51] ==> value-parameter compatibility: ModifierCheckerCore.Compatibility defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.compatibilityRegister[ValueParameterDescriptorImpl]

'result' @ [191:16] ==> val result: HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> /* = HashMap<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.compatibilityRegister[LocalVariableDescriptor]

'compatibilityRegister' @ [195:13] ==> private final fun compatibilityRegister(compatibility: ModifierCheckerCore.Compatibility, vararg list: KtModifierKeywordToken): Map<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'COMPATIBLE_FOR_CLASSES_ONLY' @ [195:49] ==> enum entry COMPATIBLE_FOR_CLASSES_ONLY defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.Compatibility[FakeCallableDescriptorForObject]

'list' @ [195:79] ==> value-parameter vararg list: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.compatibilityForClassesRegister[ValueParameterDescriptorImpl]

'compatibilityRegister' @ [197:80] ==> private final fun compatibilityRegister(compatibility: ModifierCheckerCore.Compatibility, vararg list: KtModifierKeywordToken): Map<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'INCOMPATIBLE' @ [197:116] ==> enum entry INCOMPATIBLE defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.Compatibility[FakeCallableDescriptorForObject]

'list' @ [197:131] ==> value-parameter vararg list: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.incompatibilityRegister[ValueParameterDescriptorImpl]

'compatibilityRegister' @ [199:76] ==> private final fun compatibilityRegister(compatibility: ModifierCheckerCore.Compatibility, vararg list: KtModifierKeywordToken): Map<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'DEPRECATED' @ [199:112] ==> enum entry DEPRECATED defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.Compatibility[FakeCallableDescriptorForObject]

'list' @ [199:125] ==> value-parameter vararg list: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.deprecationRegister[ValueParameterDescriptorImpl]

'if (first == second) {
            Compatibility.REPEATED
        }
        else {
            mutualCompatibility[Pair(first, second)] ?: Compatibility.COMPATIBLE
        }' @ [202:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: ModifierCheckerCore.Compatibility, elseBranch: ModifierCheckerCore.Compatibility): ModifierCheckerCore.Compatibility[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Compatibility

'first' @ [202:20] ==> value-parameter first: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.compatibility[ValueParameterDescriptorImpl]

'second' @ [202:29] ==> value-parameter second: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.compatibility[ValueParameterDescriptorImpl]

'REPEATED' @ [203:27] ==> enum entry REPEATED defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.Compatibility[FakeCallableDescriptorForObject]

'mutualCompatibility' @ [206:13] ==> private final val mutualCompatibility: Map<Pair<KtModifierKeywordToken, KtModifierKeywordToken>, ModifierCheckerCore.Compatibility> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[PropertyDescriptorImpl]

'Pair' @ [206:33] ==> public constructor Pair<out A, out B>(first: KtModifierKeywordToken, second: KtModifierKeywordToken) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> KtModifierKeywordToken
    <out B> -> KtModifierKeywordToken

'first' @ [206:38] ==> value-parameter first: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.compatibility[ValueParameterDescriptorImpl]

'second' @ [206:45] ==> value-parameter second: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.compatibility[ValueParameterDescriptorImpl]

'COMPATIBLE' @ [206:71] ==> enum entry COMPATIBLE defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.Compatibility[FakeCallableDescriptorForObject]

'firstNode' @ [215:21] ==> value-parameter firstNode: ASTNode defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[ValueParameterDescriptorImpl]

'elementType' @ [215:31] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'secondNode' @ [216:22] ==> value-parameter secondNode: ASTNode defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[ValueParameterDescriptorImpl]

'elementType' @ [216:33] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'compatibility' @ [217:29] ==> private final fun compatibility(first: KtModifierKeywordToken, second: KtModifierKeywordToken): ModifierCheckerCore.Compatibility defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'first' @ [217:43] ==> val first: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[LocalVariableDescriptor]

'second' @ [217:50] ==> val second: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[LocalVariableDescriptor]

'when (compatibility) {
            Compatibility.COMPATIBLE -> {}
            Compatibility.REPEATED -> if (incorrectNodes.add(secondNode)) {
                trace.report(Errors.REPEATED_MODIFIER.on (secondNode.psi, first))
            }
            Compatibility.REDUNDANT ->
                trace.report(Errors.REDUNDANT_MODIFIER.on(secondNode.psi, second, first))
            Compatibility.REVERSE_REDUNDANT ->
                trace.report(Errors.REDUNDANT_MODIFIER.on(firstNode.psi,  first, second))
            Compatibility.DEPRECATED -> {
                trace.report(Errors.DEPRECATED_MODIFIER_PAIR.on(firstNode.psi, first, second))
                trace.report(Errors.DEPRECATED_MODIFIER_PAIR.on(secondNode.psi, second, first))
            }
            Compatibility.COMPATIBLE_FOR_CLASSES_ONLY, Compatibility.INCOMPATIBLE -> {
                if (compatibility == Compatibility.COMPATIBLE_FOR_CLASSES_ONLY) {
                    if (owner is KtClassOrObject) return
                }
                if (incorrectNodes.add(firstNode)) {
                    trace.report(Errors.INCOMPATIBLE_MODIFIERS.on(firstNode.psi, first, second))
                }
                if (incorrectNodes.add(secondNode)) {
                    trace.report(Errors.INCOMPATIBLE_MODIFIERS.on(secondNode.psi, second, first))
                }
            }
        }' @ [218:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit, entry3: Unit, entry4: Unit, entry5: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'compatibility' @ [218:15] ==> val compatibility: ModifierCheckerCore.Compatibility defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[LocalVariableDescriptor]

'COMPATIBLE' @ [219:27] ==> enum entry COMPATIBLE defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.Compatibility[FakeCallableDescriptorForObject]

'REPEATED' @ [220:27] ==> enum entry REPEATED defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.Compatibility[FakeCallableDescriptorForObject]

'incorrectNodes' @ [220:43] ==> value-parameter incorrectNodes: MutableSet<ASTNode> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[ValueParameterDescriptorImpl]

'add' @ [220:58] ==> public abstract fun add(element: ASTNode): Boolean defined in kotlin.collections.MutableSet[DeserializedSimpleFunctionDescriptor]

'secondNode' @ [220:62] ==> value-parameter secondNode: ASTNode defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[ValueParameterDescriptorImpl]

'trace' @ [221:17] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[ValueParameterDescriptorImpl]

'report' @ [221:23] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'REPEATED_MODIFIER' @ [221:37] ==> public final val REPEATED_MODIFIER: (DiagnosticFactory1<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [221:55] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull argument: KtModifierKeywordToken): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory1[JavaMethodDescriptor]

'secondNode' @ [221:59] ==> value-parameter secondNode: ASTNode defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[ValueParameterDescriptorImpl]

'psi' @ [221:70] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'first' @ [221:75] ==> val first: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[LocalVariableDescriptor]

'REDUNDANT' @ [223:27] ==> enum entry REDUNDANT defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.Compatibility[FakeCallableDescriptorForObject]

'trace' @ [224:17] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[ValueParameterDescriptorImpl]

'report' @ [224:23] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'REDUNDANT_MODIFIER' @ [224:37] ==> public final val REDUNDANT_MODIFIER: (DiagnosticFactory2<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?), (KtModifierKeywordToken..KtModifierKeywordToken?)>..DiagnosticFactory2<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?), (KtModifierKeywordToken..KtModifierKeywordToken?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [224:56] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull a: KtModifierKeywordToken, @NotNull b: KtModifierKeywordToken): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'secondNode' @ [224:59] ==> value-parameter secondNode: ASTNode defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[ValueParameterDescriptorImpl]

'psi' @ [224:70] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'second' @ [224:75] ==> val second: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[LocalVariableDescriptor]

'first' @ [224:83] ==> val first: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[LocalVariableDescriptor]

'REVERSE_REDUNDANT' @ [225:27] ==> enum entry REVERSE_REDUNDANT defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.Compatibility[FakeCallableDescriptorForObject]

'trace' @ [226:17] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[ValueParameterDescriptorImpl]

'report' @ [226:23] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'REDUNDANT_MODIFIER' @ [226:37] ==> public final val REDUNDANT_MODIFIER: (DiagnosticFactory2<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?), (KtModifierKeywordToken..KtModifierKeywordToken?)>..DiagnosticFactory2<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?), (KtModifierKeywordToken..KtModifierKeywordToken?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [226:56] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull a: KtModifierKeywordToken, @NotNull b: KtModifierKeywordToken): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'firstNode' @ [226:59] ==> value-parameter firstNode: ASTNode defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[ValueParameterDescriptorImpl]

'psi' @ [226:69] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'first' @ [226:75] ==> val first: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[LocalVariableDescriptor]

'second' @ [226:82] ==> val second: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[LocalVariableDescriptor]

'DEPRECATED' @ [227:27] ==> enum entry DEPRECATED defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.Compatibility[FakeCallableDescriptorForObject]

'trace' @ [228:17] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[ValueParameterDescriptorImpl]

'report' @ [228:23] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'DEPRECATED_MODIFIER_PAIR' @ [228:37] ==> public final val DEPRECATED_MODIFIER_PAIR: (DiagnosticFactory2<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?), (KtModifierKeywordToken..KtModifierKeywordToken?)>..DiagnosticFactory2<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?), (KtModifierKeywordToken..KtModifierKeywordToken?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [228:62] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull a: KtModifierKeywordToken, @NotNull b: KtModifierKeywordToken): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'firstNode' @ [228:65] ==> value-parameter firstNode: ASTNode defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[ValueParameterDescriptorImpl]

'psi' @ [228:75] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'first' @ [228:80] ==> val first: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[LocalVariableDescriptor]

'second' @ [228:87] ==> val second: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[LocalVariableDescriptor]

'trace' @ [229:17] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[ValueParameterDescriptorImpl]

'report' @ [229:23] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'DEPRECATED_MODIFIER_PAIR' @ [229:37] ==> public final val DEPRECATED_MODIFIER_PAIR: (DiagnosticFactory2<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?), (KtModifierKeywordToken..KtModifierKeywordToken?)>..DiagnosticFactory2<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?), (KtModifierKeywordToken..KtModifierKeywordToken?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [229:62] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull a: KtModifierKeywordToken, @NotNull b: KtModifierKeywordToken): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'secondNode' @ [229:65] ==> value-parameter secondNode: ASTNode defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[ValueParameterDescriptorImpl]

'psi' @ [229:76] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'second' @ [229:81] ==> val second: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[LocalVariableDescriptor]

'first' @ [229:89] ==> val first: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[LocalVariableDescriptor]

'COMPATIBLE_FOR_CLASSES_ONLY' @ [231:27] ==> enum entry COMPATIBLE_FOR_CLASSES_ONLY defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.Compatibility[FakeCallableDescriptorForObject]

'INCOMPATIBLE' @ [231:70] ==> enum entry INCOMPATIBLE defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.Compatibility[FakeCallableDescriptorForObject]

'compatibility' @ [232:21] ==> val compatibility: ModifierCheckerCore.Compatibility defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[LocalVariableDescriptor]

'COMPATIBLE_FOR_CLASSES_ONLY' @ [232:52] ==> enum entry COMPATIBLE_FOR_CLASSES_ONLY defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.Compatibility[FakeCallableDescriptorForObject]

'owner' @ [233:25] ==> value-parameter owner: PsiElement defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[ValueParameterDescriptorImpl]

'incorrectNodes' @ [235:21] ==> value-parameter incorrectNodes: MutableSet<ASTNode> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[ValueParameterDescriptorImpl]

'add' @ [235:36] ==> public abstract fun add(element: ASTNode): Boolean defined in kotlin.collections.MutableSet[DeserializedSimpleFunctionDescriptor]

'firstNode' @ [235:40] ==> value-parameter firstNode: ASTNode defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[ValueParameterDescriptorImpl]

'trace' @ [236:21] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[ValueParameterDescriptorImpl]

'report' @ [236:27] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'INCOMPATIBLE_MODIFIERS' @ [236:41] ==> public final val INCOMPATIBLE_MODIFIERS: (DiagnosticFactory2<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?), (KtModifierKeywordToken..KtModifierKeywordToken?)>..DiagnosticFactory2<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?), (KtModifierKeywordToken..KtModifierKeywordToken?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [236:64] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull a: KtModifierKeywordToken, @NotNull b: KtModifierKeywordToken): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'firstNode' @ [236:67] ==> value-parameter firstNode: ASTNode defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[ValueParameterDescriptorImpl]

'psi' @ [236:77] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'first' @ [236:82] ==> val first: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[LocalVariableDescriptor]

'second' @ [236:89] ==> val second: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[LocalVariableDescriptor]

'incorrectNodes' @ [238:21] ==> value-parameter incorrectNodes: MutableSet<ASTNode> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[ValueParameterDescriptorImpl]

'add' @ [238:36] ==> public abstract fun add(element: ASTNode): Boolean defined in kotlin.collections.MutableSet[DeserializedSimpleFunctionDescriptor]

'secondNode' @ [238:40] ==> value-parameter secondNode: ASTNode defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[ValueParameterDescriptorImpl]

'trace' @ [239:21] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[ValueParameterDescriptorImpl]

'report' @ [239:27] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'INCOMPATIBLE_MODIFIERS' @ [239:41] ==> public final val INCOMPATIBLE_MODIFIERS: (DiagnosticFactory2<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?), (KtModifierKeywordToken..KtModifierKeywordToken?)>..DiagnosticFactory2<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?), (KtModifierKeywordToken..KtModifierKeywordToken?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [239:64] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull a: KtModifierKeywordToken, @NotNull b: KtModifierKeywordToken): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'secondNode' @ [239:67] ==> value-parameter secondNode: ASTNode defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[ValueParameterDescriptorImpl]

'psi' @ [239:78] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'second' @ [239:83] ==> val second: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[LocalVariableDescriptor]

'first' @ [239:91] ==> val first: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkCompatibility[LocalVariableDescriptor]

'node' @ [247:24] ==> value-parameter node: ASTNode defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget[ValueParameterDescriptorImpl]

'elementType' @ [247:29] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'possibleTargetMap' @ [248:31] ==> public final val possibleTargetMap: Map<KtModifierKeywordToken, Set<KotlinTarget>> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[PropertyDescriptorImpl]

'modifier' @ [248:49] ==> val modifier: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget[LocalVariableDescriptor]

'emptySet' @ [248:62] ==> public fun <T> emptySet(): Set<KotlinTarget> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'!' @ [249:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'actualTargets' @ [249:14] ==> value-parameter actualTargets: List<KotlinTarget> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget[ValueParameterDescriptorImpl]

'any' @ [249:28] ==> public inline fun <T> Iterable<KotlinTarget>.any(predicate: (KotlinTarget) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'it' @ [249:34] ==> value-parameter it: KotlinTarget defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget.<anonymous>[ValueParameterDescriptorImpl]

'possibleTargets' @ [249:40] ==> val possibleTargets: Set<KotlinTarget> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget[LocalVariableDescriptor]

'trace' @ [250:13] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget[ValueParameterDescriptorImpl]

'report' @ [250:19] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'WRONG_MODIFIER_TARGET' @ [250:33] ==> public final val WRONG_MODIFIER_TARGET: (DiagnosticFactory2<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?), (String..String?)>..DiagnosticFactory2<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?), (String..String?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [250:55] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull a: KtModifierKeywordToken, @NotNull b: String): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'node' @ [250:58] ==> value-parameter node: ASTNode defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget[ValueParameterDescriptorImpl]

'psi' @ [250:63] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'modifier' @ [250:68] ==> val modifier: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget[LocalVariableDescriptor]

'actualTargets' @ [250:78] ==> value-parameter actualTargets: List<KotlinTarget> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget[ValueParameterDescriptorImpl]

'firstOrNull' @ [250:92] ==> public fun <T> List<KotlinTarget>.firstOrNull(): KotlinTarget? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'description' @ [250:107] ==> public final val description: String defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[DeserializedPropertyDescriptor]

'deprecatedTargetMap' @ [253:33] ==> private final val deprecatedTargetMap: Map<KtModifierKeywordToken, Set<KotlinTarget>> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[PropertyDescriptorImpl]

'modifier' @ [253:53] ==> val modifier: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget[LocalVariableDescriptor]

'emptySet' @ [253:66] ==> public fun <T> emptySet(): Set<KotlinTarget> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'redundantTargetMap' @ [254:32] ==> private final val redundantTargetMap: Map<KtModifierKeywordToken, Set<KotlinTarget>> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[PropertyDescriptorImpl]

'modifier' @ [254:51] ==> val modifier: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget[LocalVariableDescriptor]

'emptySet' @ [254:64] ==> public fun <T> emptySet(): Set<KotlinTarget> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'if (actualTargets.any { it in deprecatedTargets }) {
            trace.report(Errors.DEPRECATED_MODIFIER_FOR_TARGET.on(node.psi, modifier, actualTargets.firstOrNull()?.description ?: "this"))
        }
        else if (actualTargets.any { it in redundantTargets }) {
            trace.report(Errors.REDUNDANT_MODIFIER_FOR_TARGET.on(node.psi, modifier, actualTargets.firstOrNull()?.description ?: "this"))
        }' @ [255:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'actualTargets' @ [255:13] ==> value-parameter actualTargets: List<KotlinTarget> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget[ValueParameterDescriptorImpl]

'any' @ [255:27] ==> public inline fun <T> Iterable<KotlinTarget>.any(predicate: (KotlinTarget) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'it' @ [255:33] ==> value-parameter it: KotlinTarget defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget.<anonymous>[ValueParameterDescriptorImpl]

'deprecatedTargets' @ [255:39] ==> val deprecatedTargets: Set<KotlinTarget> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget[LocalVariableDescriptor]

'trace' @ [256:13] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget[ValueParameterDescriptorImpl]

'report' @ [256:19] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'DEPRECATED_MODIFIER_FOR_TARGET' @ [256:33] ==> public final val DEPRECATED_MODIFIER_FOR_TARGET: (DiagnosticFactory2<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?), (String..String?)>..DiagnosticFactory2<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?), (String..String?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [256:64] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull a: KtModifierKeywordToken, @NotNull b: String): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'node' @ [256:67] ==> value-parameter node: ASTNode defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget[ValueParameterDescriptorImpl]

'psi' @ [256:72] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'modifier' @ [256:77] ==> val modifier: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget[LocalVariableDescriptor]

'actualTargets' @ [256:87] ==> value-parameter actualTargets: List<KotlinTarget> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget[ValueParameterDescriptorImpl]

'firstOrNull' @ [256:101] ==> public fun <T> List<KotlinTarget>.firstOrNull(): KotlinTarget? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'description' @ [256:116] ==> public final val description: String defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[DeserializedPropertyDescriptor]

'actualTargets' @ [258:18] ==> value-parameter actualTargets: List<KotlinTarget> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget[ValueParameterDescriptorImpl]

'any' @ [258:32] ==> public inline fun <T> Iterable<KotlinTarget>.any(predicate: (KotlinTarget) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'it' @ [258:38] ==> value-parameter it: KotlinTarget defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget.<anonymous>[ValueParameterDescriptorImpl]

'redundantTargets' @ [258:44] ==> val redundantTargets: Set<KotlinTarget> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget[LocalVariableDescriptor]

'trace' @ [259:13] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget[ValueParameterDescriptorImpl]

'report' @ [259:19] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'REDUNDANT_MODIFIER_FOR_TARGET' @ [259:33] ==> public final val REDUNDANT_MODIFIER_FOR_TARGET: (DiagnosticFactory2<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?), (String..String?)>..DiagnosticFactory2<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?), (String..String?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [259:63] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull a: KtModifierKeywordToken, @NotNull b: String): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'node' @ [259:66] ==> value-parameter node: ASTNode defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget[ValueParameterDescriptorImpl]

'psi' @ [259:71] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'modifier' @ [259:76] ==> val modifier: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget[LocalVariableDescriptor]

'actualTargets' @ [259:86] ==> value-parameter actualTargets: List<KotlinTarget> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkTarget[ValueParameterDescriptorImpl]

'firstOrNull' @ [259:100] ==> public fun <T> List<KotlinTarget>.firstOrNull(): KotlinTarget? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'description' @ [259:115] ==> public final val description: String defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[DeserializedPropertyDescriptor]

'node' @ [270:24] ==> value-parameter node: ASTNode defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkLanguageLevelSupport[ValueParameterDescriptorImpl]

'elementType' @ [270:29] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'featureDependencies' @ [272:26] ==> private final val featureDependencies: Map<(KtModifierKeywordToken..KtModifierKeywordToken?), LanguageFeature> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[PropertyDescriptorImpl]

'modifier' @ [272:46] ==> val modifier: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkLanguageLevelSupport[LocalVariableDescriptor]

'languageVersionSettings' @ [274:30] ==> value-parameter languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkLanguageLevelSupport[ValueParameterDescriptorImpl]

'getFeatureSupport' @ [274:54] ==> public abstract fun getFeatureSupport(feature: LanguageFeature): LanguageFeature.State defined in org.jetbrains.kotlin.config.LanguageVersionSettings[DeserializedSimpleFunctionDescriptor]

'dependency' @ [274:72] ==> val dependency: LanguageFeature defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkLanguageLevelSupport[LocalVariableDescriptor]

'dependency' @ [276:30] ==> val dependency: LanguageFeature defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkLanguageLevelSupport[LocalVariableDescriptor]

'languageVersionSettings' @ [276:44] ==> value-parameter languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkLanguageLevelSupport[ValueParameterDescriptorImpl]

'featureSupport' @ [277:13] ==> val featureSupport: LanguageFeature.State defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkLanguageLevelSupport[LocalVariableDescriptor]

'ENABLED_WITH_ERROR' @ [277:53] ==> enum entry ENABLED_WITH_ERROR defined in org.jetbrains.kotlin.config.LanguageFeature.State[FakeCallableDescriptorForObject]

'featureSupport' @ [277:75] ==> val featureSupport: LanguageFeature.State defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkLanguageLevelSupport[LocalVariableDescriptor]

'DISABLED' @ [277:115] ==> enum entry DISABLED defined in org.jetbrains.kotlin.config.LanguageFeature.State[FakeCallableDescriptorForObject]

'featureDependenciesTargets' @ [278:37] ==> private final val featureDependenciesTargets: Map<LanguageFeature, Set<KotlinTarget>> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[PropertyDescriptorImpl]

'dependency' @ [278:64] ==> val dependency: LanguageFeature defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkLanguageLevelSupport[LocalVariableDescriptor]

'restrictedTargets' @ [279:17] ==> val restrictedTargets: Set<KotlinTarget>? defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkLanguageLevelSupport[LocalVariableDescriptor]

'actualTargets' @ [279:46] ==> value-parameter actualTargets: List<KotlinTarget> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkLanguageLevelSupport[ValueParameterDescriptorImpl]

'intersect' @ [279:60] ==> public infix fun <T> Iterable<KotlinTarget>.intersect(other: Iterable<KotlinTarget>): Set<KotlinTarget> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'restrictedTargets' @ [279:70] ==> val restrictedTargets: Set<KotlinTarget>? defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkLanguageLevelSupport[LocalVariableDescriptor]

'isEmpty' @ [279:89] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.Set[DeserializedSimpleFunctionDescriptor]

'if (featureSupport == LanguageFeature.State.DISABLED) {
                trace.report(Errors.UNSUPPORTED_FEATURE.on(node.psi, diagnosticData))
            }
            else {
                trace.report(Errors.EXPERIMENTAL_FEATURE_ERROR.on(node.psi, diagnosticData))
            }' @ [283:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'featureSupport' @ [283:17] ==> val featureSupport: LanguageFeature.State defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkLanguageLevelSupport[LocalVariableDescriptor]

'DISABLED' @ [283:57] ==> enum entry DISABLED defined in org.jetbrains.kotlin.config.LanguageFeature.State[FakeCallableDescriptorForObject]

'trace' @ [284:17] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkLanguageLevelSupport[ValueParameterDescriptorImpl]

'report' @ [284:23] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'UNSUPPORTED_FEATURE' @ [284:37] ==> public final val UNSUPPORTED_FEATURE: (DiagnosticFactory1<(PsiElement..PsiElement?), (Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>..Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>..Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [284:57] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull argument: Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory1[JavaMethodDescriptor]

'node' @ [284:60] ==> value-parameter node: ASTNode defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkLanguageLevelSupport[ValueParameterDescriptorImpl]

'psi' @ [284:65] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'diagnosticData' @ [284:70] ==> val diagnosticData: Pair<LanguageFeature, LanguageVersionSettings> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkLanguageLevelSupport[LocalVariableDescriptor]

'trace' @ [287:17] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkLanguageLevelSupport[ValueParameterDescriptorImpl]

'report' @ [287:23] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'EXPERIMENTAL_FEATURE_ERROR' @ [287:37] ==> public final val EXPERIMENTAL_FEATURE_ERROR: (DiagnosticFactory1<(PsiElement..PsiElement?), (Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>..Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>..Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [287:64] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull argument: Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory1[JavaMethodDescriptor]

'node' @ [287:67] ==> value-parameter node: ASTNode defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkLanguageLevelSupport[ValueParameterDescriptorImpl]

'psi' @ [287:72] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'diagnosticData' @ [287:77] ==> val diagnosticData: Pair<LanguageFeature, LanguageVersionSettings> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkLanguageLevelSupport[LocalVariableDescriptor]

'featureSupport' @ [292:13] ==> val featureSupport: LanguageFeature.State defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkLanguageLevelSupport[LocalVariableDescriptor]

'ENABLED_WITH_WARNING' @ [292:53] ==> enum entry ENABLED_WITH_WARNING defined in org.jetbrains.kotlin.config.LanguageFeature.State[FakeCallableDescriptorForObject]

'trace' @ [293:13] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkLanguageLevelSupport[ValueParameterDescriptorImpl]

'report' @ [293:19] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'EXPERIMENTAL_FEATURE_WARNING' @ [293:33] ==> public final val EXPERIMENTAL_FEATURE_WARNING: (DiagnosticFactory1<(PsiElement..PsiElement?), (Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>..Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>..Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [293:62] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull argument: Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory1[JavaMethodDescriptor]

'node' @ [293:65] ==> value-parameter node: ASTNode defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkLanguageLevelSupport[ValueParameterDescriptorImpl]

'psi' @ [293:70] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'diagnosticData' @ [293:75] ==> val diagnosticData: Pair<LanguageFeature, LanguageVersionSettings> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkLanguageLevelSupport[LocalVariableDescriptor]

'node' @ [302:24] ==> value-parameter node: ASTNode defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkParent[ValueParameterDescriptorImpl]

'elementType' @ [302:29] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'when (parentDescriptor) {
            is ClassDescriptor -> KotlinTarget.classActualTargets(parentDescriptor)
            is PropertySetterDescriptor -> listOf(PROPERTY_SETTER)
            is PropertyGetterDescriptor -> listOf(PROPERTY_GETTER)
            is FunctionDescriptor -> listOf(FUNCTION)
            else -> listOf(FILE)
        }' @ [303:49] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: List<KotlinTarget>, entry1: List<KotlinTarget>, entry2: List<KotlinTarget>, entry3: List<KotlinTarget>, entry4: List<KotlinTarget>): List<KotlinTarget>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> List<KotlinTarget>

'parentDescriptor' @ [303:55] ==> value-parameter parentDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkParent[ValueParameterDescriptorImpl]

'classActualTargets' @ [304:48] ==> public final fun classActualTargets(descriptor: ClassDescriptor): List<KotlinTarget> defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget.Companion[DeserializedSimpleFunctionDescriptor]

'parentDescriptor' @ [304:67] ==> value-parameter parentDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkParent[ValueParameterDescriptorImpl]

'listOf' @ [305:44] ==> public fun <T> listOf(element: KotlinTarget): List<KotlinTarget> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'PROPERTY_SETTER' @ [305:51] ==> enum entry PROPERTY_SETTER defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'listOf' @ [306:44] ==> public fun <T> listOf(element: KotlinTarget): List<KotlinTarget> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'PROPERTY_GETTER' @ [306:51] ==> enum entry PROPERTY_GETTER defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'listOf' @ [307:38] ==> public fun <T> listOf(element: KotlinTarget): List<KotlinTarget> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'FUNCTION' @ [307:45] ==> enum entry FUNCTION defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'listOf' @ [308:21] ==> public fun <T> listOf(element: KotlinTarget): List<KotlinTarget> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'FILE' @ [308:28] ==> enum entry FILE defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[FakeCallableDescriptorForObject]

'deprecatedParentTargetMap' @ [310:33] ==> public final val deprecatedParentTargetMap: Map<KtModifierKeywordToken, Set<KotlinTarget>> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[PropertyDescriptorImpl]

'modifier' @ [310:59] ==> val modifier: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkParent[LocalVariableDescriptor]

'deprecatedParents' @ [311:13] ==> val deprecatedParents: Set<KotlinTarget>? defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkParent[LocalVariableDescriptor]

'actualParents' @ [311:42] ==> val actualParents: List<KotlinTarget> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkParent[LocalVariableDescriptor]

'any' @ [311:56] ==> public inline fun <T> Iterable<KotlinTarget>.any(predicate: (KotlinTarget) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'it' @ [311:62] ==> value-parameter it: KotlinTarget defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkParent.<anonymous>[ValueParameterDescriptorImpl]

'deprecatedParents' @ [311:68] ==> val deprecatedParents: Set<KotlinTarget>? defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkParent[LocalVariableDescriptor]

'trace' @ [312:13] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkParent[ValueParameterDescriptorImpl]

'report' @ [312:19] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'DEPRECATED_MODIFIER_CONTAINING_DECLARATION' @ [312:33] ==> public final val DEPRECATED_MODIFIER_CONTAINING_DECLARATION: (DiagnosticFactory2<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?), (String..String?)>..DiagnosticFactory2<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?), (String..String?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [312:76] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull a: KtModifierKeywordToken, @NotNull b: String): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'node' @ [312:79] ==> value-parameter node: ASTNode defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkParent[ValueParameterDescriptorImpl]

'psi' @ [312:84] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'modifier' @ [312:89] ==> val modifier: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkParent[LocalVariableDescriptor]

'actualParents' @ [312:99] ==> val actualParents: List<KotlinTarget> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkParent[LocalVariableDescriptor]

'firstOrNull' @ [312:113] ==> public fun <T> List<KotlinTarget>.firstOrNull(): KotlinTarget? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'description' @ [312:128] ==> public final val description: String defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[DeserializedPropertyDescriptor]

'possibleParentTargetMap' @ [315:31] ==> public final val possibleParentTargetMap: Map<KtModifierKeywordToken, Set<KotlinTarget>> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[PropertyDescriptorImpl]

'modifier' @ [315:55] ==> val modifier: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkParent[LocalVariableDescriptor]

'possibleParents' @ [316:13] ==> val possibleParents: Set<KotlinTarget> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkParent[LocalVariableDescriptor]

'ALL_TARGET_SET' @ [316:45] ==> public final val ALL_TARGET_SET: Set<KotlinTarget> defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget.Companion[DeserializedPropertyDescriptor]

'actualParents' @ [317:13] ==> val actualParents: List<KotlinTarget> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkParent[LocalVariableDescriptor]

'any' @ [317:27] ==> public inline fun <T> Iterable<KotlinTarget>.any(predicate: (KotlinTarget) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'it' @ [317:33] ==> value-parameter it: KotlinTarget defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkParent.<anonymous>[ValueParameterDescriptorImpl]

'possibleParents' @ [317:39] ==> val possibleParents: Set<KotlinTarget> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkParent[LocalVariableDescriptor]

'trace' @ [318:9] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkParent[ValueParameterDescriptorImpl]

'report' @ [318:15] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'WRONG_MODIFIER_CONTAINING_DECLARATION' @ [318:29] ==> public final val WRONG_MODIFIER_CONTAINING_DECLARATION: (DiagnosticFactory2<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?), (String..String?)>..DiagnosticFactory2<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?), (String..String?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [318:67] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull a: KtModifierKeywordToken, @NotNull b: String): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'node' @ [318:70] ==> value-parameter node: ASTNode defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkParent[ValueParameterDescriptorImpl]

'psi' @ [318:75] ==> public final val ASTNode.psi: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'modifier' @ [318:80] ==> val modifier: KtModifierKeywordToken defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkParent[LocalVariableDescriptor]

'actualParents' @ [318:90] ==> val actualParents: List<KotlinTarget> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkParent[LocalVariableDescriptor]

'firstOrNull' @ [318:104] ==> public fun <T> List<KotlinTarget>.firstOrNull(): KotlinTarget? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinTarget

'description' @ [318:119] ==> public final val description: String defined in org.jetbrains.kotlin.descriptors.annotations.KotlinTarget[DeserializedPropertyDescriptor]

'orSet' @ [322:49] ==> @NotNull public open fun orSet(@NotNull vararg p0: (TokenSet..TokenSet?)): TokenSet defined in com.intellij.psi.tree.TokenSet[JavaMethodDescriptor]

'SOFT_KEYWORDS' @ [322:64] ==> public final val SOFT_KEYWORDS: (TokenSet..TokenSet?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'create' @ [322:88] ==> @NotNull public open fun create(@NotNull vararg p0: (IElementType..IElementType?)): TokenSet defined in com.intellij.psi.tree.TokenSet[JavaMethodDescriptor]

'IN_KEYWORD' @ [322:104] ==> public final val IN_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'hashSetOf' @ [333:30] ==> @SinceKotlin @InlineOnly public inline fun <T> hashSetOf(): HashSet<ASTNode> /* = HashSet<ASTNode> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ASTNode

'list' @ [334:24] ==> value-parameter list: KtModifierList defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[ValueParameterDescriptorImpl]

'node' @ [334:29] ==> public final var KtModifierList.node: ASTNode[MyPropertyDescriptor]

'getChildren' @ [334:34] ==> @NotNull public abstract fun getChildren(@Nullable p0: TokenSet?): (Array<(ASTNode..ASTNode?)>..Array<out (ASTNode..ASTNode?)>) defined in com.intellij.lang.ASTNode[JavaMethodDescriptor]

'MODIFIER_KEYWORD_SET' @ [334:46] ==> private final val MODIFIER_KEYWORD_SET: TokenSet defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[PropertyDescriptorImpl]

'children' @ [335:24] ==> val children: (Array<(ASTNode..ASTNode?)>..Array<out (ASTNode..ASTNode?)>) defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[LocalVariableDescriptor]

'children' @ [336:27] ==> val children: (Array<(ASTNode..ASTNode?)>..Array<out (ASTNode..ASTNode?)>) defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[LocalVariableDescriptor]

'first' @ [337:21] ==> val first: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[LocalVariableDescriptor]

'second' @ [337:30] ==> val second: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[LocalVariableDescriptor]

'checkCompatibility' @ [340:17] ==> private final fun checkCompatibility(trace: BindingTrace, firstNode: ASTNode, secondNode: ASTNode, owner: PsiElement, incorrectNodes: MutableSet<ASTNode>): Unit defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'trace' @ [340:36] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[ValueParameterDescriptorImpl]

'first' @ [340:43] ==> val first: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[LocalVariableDescriptor]

'second' @ [340:50] ==> val second: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[LocalVariableDescriptor]

'list' @ [340:58] ==> value-parameter list: KtModifierList defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[ValueParameterDescriptorImpl]

'owner' @ [340:63] ==> public final val KtModifierList.owner: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'incorrectNodes' @ [340:70] ==> val incorrectNodes: HashSet<ASTNode> /* = HashSet<ASTNode> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[LocalVariableDescriptor]

'second' @ [342:17] ==> val second: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[LocalVariableDescriptor]

'incorrectNodes' @ [342:28] ==> val incorrectNodes: HashSet<ASTNode> /* = HashSet<ASTNode> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[LocalVariableDescriptor]

'when {
                    !checkTarget(trace, second, actualTargets) -> incorrectNodes += second
                    !checkParent(trace, second, parentDescriptor) -> incorrectNodes += second
                    !checkLanguageLevelSupport(trace, second, languageVersionSettings, actualTargets) -> incorrectNodes += second
                }' @ [343:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'!' @ [344:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'checkTarget' @ [344:22] ==> private final fun checkTarget(trace: BindingTrace, node: ASTNode, actualTargets: List<KotlinTarget>): Boolean defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'trace' @ [344:34] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[ValueParameterDescriptorImpl]

'second' @ [344:41] ==> val second: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[LocalVariableDescriptor]

'actualTargets' @ [344:49] ==> value-parameter actualTargets: List<KotlinTarget> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[ValueParameterDescriptorImpl]

'incorrectNodes' @ [344:67] ==> val incorrectNodes: HashSet<ASTNode> /* = HashSet<ASTNode> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[LocalVariableDescriptor]

'second' @ [344:85] ==> val second: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[LocalVariableDescriptor]

'!' @ [345:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'checkParent' @ [345:22] ==> private final fun checkParent(trace: BindingTrace, node: ASTNode, parentDescriptor: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'trace' @ [345:34] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[ValueParameterDescriptorImpl]

'second' @ [345:41] ==> val second: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[LocalVariableDescriptor]

'parentDescriptor' @ [345:49] ==> value-parameter parentDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[ValueParameterDescriptorImpl]

'incorrectNodes' @ [345:70] ==> val incorrectNodes: HashSet<ASTNode> /* = HashSet<ASTNode> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[LocalVariableDescriptor]

'second' @ [345:88] ==> val second: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[LocalVariableDescriptor]

'!' @ [346:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'checkLanguageLevelSupport' @ [346:22] ==> private final fun checkLanguageLevelSupport(trace: BindingTrace, node: ASTNode, languageVersionSettings: LanguageVersionSettings, actualTargets: List<KotlinTarget>): Boolean defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'trace' @ [346:48] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[ValueParameterDescriptorImpl]

'second' @ [346:55] ==> val second: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[LocalVariableDescriptor]

'languageVersionSettings' @ [346:63] ==> value-parameter languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[ValueParameterDescriptorImpl]

'actualTargets' @ [346:88] ==> value-parameter actualTargets: List<KotlinTarget> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[ValueParameterDescriptorImpl]

'incorrectNodes' @ [346:106] ==> val incorrectNodes: HashSet<ASTNode> /* = HashSet<ASTNode> */ defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[LocalVariableDescriptor]

'second' @ [346:124] ==> val second: (ASTNode..ASTNode?) defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.checkModifierList[LocalVariableDescriptor]

'listOwner' @ [358:13] ==> value-parameter listOwner: KtModifierListOwner defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.check[ValueParameterDescriptorImpl]

'listOwner' @ [360:31] ==> value-parameter listOwner: KtModifierListOwner defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.check[ValueParameterDescriptorImpl]

'valueParameters' @ [360:41] ==> public final val KtDeclarationWithBody.valueParameters: (MutableList<(KtParameter..KtParameter?)>..List<(KtParameter..KtParameter?)>)[MyPropertyDescriptor]

'!' @ [361:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'parameter' @ [361:22] ==> val parameter: (KtParameter..KtParameter?) defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.check[LocalVariableDescriptor]

'hasValOrVar' @ [361:32] ==> public open fun hasValOrVar(): Boolean defined in org.jetbrains.kotlin.psi.KtParameter[JavaMethodDescriptor]

'check' @ [362:21] ==> public final fun check(listOwner: KtModifierListOwner, trace: BindingTrace, descriptor: DeclarationDescriptor?, languageVersionSettings: LanguageVersionSettings): Unit defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'parameter' @ [362:27] ==> val parameter: (KtParameter..KtParameter?) defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.check[LocalVariableDescriptor]

'trace' @ [362:38] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.check[ValueParameterDescriptorImpl]

'trace' @ [362:45] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.check[ValueParameterDescriptorImpl]

'VALUE_PARAMETER' @ [362:66] ==> public final val VALUE_PARAMETER: (WritableSlice<(KtParameter..KtParameter?), (VariableDescriptor..VariableDescriptor?)>..WritableSlice<(KtParameter..KtParameter?), (VariableDescriptor..VariableDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'parameter' @ [362:83] ==> val parameter: (KtParameter..KtParameter?) defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.check[LocalVariableDescriptor]

'languageVersionSettings' @ [362:95] ==> value-parameter languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.check[ValueParameterDescriptorImpl]

'AnnotationChecker' @ [366:29] ==> public companion object defined in org.jetbrains.kotlin.resolve.AnnotationChecker[FakeCallableDescriptorForObject]

'getDeclarationSiteActualTargetList' @ [366:47] ==> public final fun getDeclarationSiteActualTargetList(annotated: KtElement, descriptor: ClassDescriptor?, trace: BindingTrace): List<KotlinTarget> defined in org.jetbrains.kotlin.resolve.AnnotationChecker.Companion[SimpleFunctionDescriptorImpl]

'listOwner' @ [366:82] ==> value-parameter listOwner: KtModifierListOwner defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.check[ValueParameterDescriptorImpl]

'descriptor' @ [366:93] ==> value-parameter descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.check[ValueParameterDescriptorImpl]

'trace' @ [366:125] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.check[ValueParameterDescriptorImpl]

'listOwner' @ [367:20] ==> value-parameter listOwner: KtModifierListOwner defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.check[ValueParameterDescriptorImpl]

'modifierList' @ [367:30] ==> public final val KtModifierListOwner.modifierList: KtModifierList?[MyPropertyDescriptor]

'checkModifierList' @ [368:9] ==> private final fun checkModifierList(list: KtModifierList, trace: BindingTrace, parentDescriptor: DeclarationDescriptor?, actualTargets: List<KotlinTarget>, languageVersionSettings: LanguageVersionSettings): Unit defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'list' @ [368:27] ==> val list: KtModifierList defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.check[LocalVariableDescriptor]

'trace' @ [368:33] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.check[ValueParameterDescriptorImpl]

'descriptor' @ [368:40] ==> value-parameter descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.check[ValueParameterDescriptorImpl]

'containingDeclaration' @ [368:52] ==> public final val DeclarationDescriptor.containingDeclaration: DeclarationDescriptor?[MyPropertyDescriptor]

'actualTargets' @ [368:75] ==> val actualTargets: List<KotlinTarget> defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.check[LocalVariableDescriptor]

'languageVersionSettings' @ [368:90] ==> value-parameter languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore.check[ValueParameterDescriptorImpl]

