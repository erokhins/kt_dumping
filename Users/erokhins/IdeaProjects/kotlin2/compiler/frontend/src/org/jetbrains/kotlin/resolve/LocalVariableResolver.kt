'typingContext' @ [56:23] ==> value-parameter typingContext: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[ValueParameterDescriptorImpl]

'replaceContextDependency' @ [56:37] ==> @NotNull public open fun replaceContextDependency(@NotNull newContextDependency: ContextDependency): ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaMethodDescriptor]

'INDEPENDENT' @ [56:80] ==> enum entry INDEPENDENT defined in org.jetbrains.kotlin.resolve.calls.context.ContextDependency[FakeCallableDescriptorForObject]

'replaceScope' @ [56:93] ==> @NotNull public open fun replaceScope(@NotNull newScope: LexicalScope): ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaMethodDescriptor]

'scope' @ [56:106] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[ValueParameterDescriptorImpl]

'property' @ [57:31] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[ValueParameterDescriptorImpl]

'receiverTypeReference' @ [57:40] ==> public final val KtProperty.receiverTypeReference: KtTypeReference?[MyPropertyDescriptor]

'receiverTypeRef' @ [58:13] ==> val receiverTypeRef: KtTypeReference? defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'context' @ [59:13] ==> val context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'trace' @ [59:21] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'report' @ [59:27] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'LOCAL_EXTENSION_PROPERTY' @ [59:34] ==> public final val LOCAL_EXTENSION_PROPERTY: (DiagnosticFactory0<(KtTypeReference..KtTypeReference?)>..DiagnosticFactory0<(KtTypeReference..KtTypeReference?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [59:59] ==> @NotNull public open fun on(@NotNull element: KtTypeReference): SimpleDiagnostic<(KtTypeReference..KtTypeReference?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'receiverTypeRef' @ [59:62] ==> val receiverTypeRef: KtTypeReference? defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'property' @ [62:22] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[ValueParameterDescriptorImpl]

'getter' @ [62:31] ==> public final val KtProperty.getter: KtPropertyAccessor?[MyPropertyDescriptor]

'getter' @ [63:13] ==> val getter: KtPropertyAccessor? defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'context' @ [64:13] ==> val context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'trace' @ [64:21] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'report' @ [64:27] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'LOCAL_VARIABLE_WITH_GETTER' @ [64:34] ==> public final val LOCAL_VARIABLE_WITH_GETTER: (DiagnosticFactory0<(KtPropertyAccessor..KtPropertyAccessor?)>..DiagnosticFactory0<(KtPropertyAccessor..KtPropertyAccessor?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [64:61] ==> @NotNull public open fun on(@NotNull element: KtPropertyAccessor): SimpleDiagnostic<(KtPropertyAccessor..KtPropertyAccessor?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'getter' @ [64:64] ==> val getter: KtPropertyAccessor? defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'property' @ [67:22] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[ValueParameterDescriptorImpl]

'setter' @ [67:31] ==> public final val KtProperty.setter: KtPropertyAccessor?[MyPropertyDescriptor]

'setter' @ [68:13] ==> val setter: KtPropertyAccessor? defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'context' @ [69:13] ==> val context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'trace' @ [69:21] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'report' @ [69:27] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'LOCAL_VARIABLE_WITH_SETTER' @ [69:34] ==> public final val LOCAL_VARIABLE_WITH_SETTER: (DiagnosticFactory0<(KtPropertyAccessor..KtPropertyAccessor?)>..DiagnosticFactory0<(KtPropertyAccessor..KtPropertyAccessor?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [69:61] ==> @NotNull public open fun on(@NotNull element: KtPropertyAccessor): SimpleDiagnostic<(KtPropertyAccessor..KtPropertyAccessor?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'setter' @ [69:64] ==> val setter: KtPropertyAccessor? defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'resolveLocalVariableDescriptor' @ [72:34] ==> private final fun resolveLocalVariableDescriptor(scope: LexicalScope, variable: KtVariableDeclaration, dataFlowInfo: DataFlowInfo, trace: BindingTrace): VariableDescriptor defined in org.jetbrains.kotlin.resolve.LocalVariableResolver[SimpleFunctionDescriptorImpl]

'scope' @ [72:65] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[ValueParameterDescriptorImpl]

'property' @ [72:72] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[ValueParameterDescriptorImpl]

'context' @ [72:82] ==> val context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'dataFlowInfo' @ [72:90] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'context' @ [72:104] ==> val context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'trace' @ [72:112] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'property' @ [74:34] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[ValueParameterDescriptorImpl]

'delegateExpression' @ [74:43] ==> public final val KtProperty.delegateExpression: KtExpression?[MyPropertyDescriptor]

'delegateExpression' @ [75:13] ==> val delegateExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'!' @ [76:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'languageVersionSettings' @ [76:18] ==> private final val languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.LocalVariableResolver[PropertyDescriptorImpl]

'supportsFeature' @ [76:42] ==> public open fun supportsFeature(feature: LanguageFeature): Boolean defined in org.jetbrains.kotlin.config.LanguageVersionSettings[DeserializedSimpleFunctionDescriptor]

'LocalDelegatedProperties' @ [76:74] ==> enum entry LocalDelegatedProperties defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'context' @ [77:17] ==> val context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'trace' @ [77:25] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'report' @ [77:31] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'UNSUPPORTED_FEATURE' @ [77:38] ==> public final val UNSUPPORTED_FEATURE: (DiagnosticFactory1<(PsiElement..PsiElement?), (Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>..Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>..Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [77:58] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull argument: Pair<(LanguageFeature..LanguageFeature?), (LanguageVersionSettings..LanguageVersionSettings?)>): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory1[JavaMethodDescriptor]

'property' @ [77:61] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[ValueParameterDescriptorImpl]

'delegate' @ [77:70] ==> public final val KtProperty.delegate: KtPropertyDelegate?[MyPropertyDescriptor]

'LanguageFeature' @ [77:82] ==> public companion object defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'LocalDelegatedProperties' @ [77:98] ==> enum entry LocalDelegatedProperties defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'languageVersionSettings' @ [77:126] ==> private final val languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.LocalVariableResolver[PropertyDescriptorImpl]

'propertyDescriptor' @ [80:17] ==> val propertyDescriptor: VariableDescriptor defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'delegatedPropertyResolver' @ [81:17] ==> private final val delegatedPropertyResolver: DelegatedPropertyResolver defined in org.jetbrains.kotlin.resolve.LocalVariableResolver[PropertyDescriptorImpl]

'resolvePropertyDelegate' @ [81:43] ==> public final fun resolvePropertyDelegate(outerDataFlowInfo: DataFlowInfo, property: KtProperty, variableDescriptor: VariableDescriptorWithAccessors, delegateExpression: KtExpression, propertyHeaderScope: LexicalScope, trace: BindingTrace): Unit defined in org.jetbrains.kotlin.resolve.DelegatedPropertyResolver[SimpleFunctionDescriptorImpl]

'typingContext' @ [81:67] ==> value-parameter typingContext: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [81:81] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'property' @ [82:67] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[ValueParameterDescriptorImpl]

'propertyDescriptor' @ [83:67] ==> val propertyDescriptor: VariableDescriptor defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'delegateExpression' @ [84:67] ==> val delegateExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'typingContext' @ [85:67] ==> value-parameter typingContext: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[ValueParameterDescriptorImpl]

'scope' @ [85:81] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'typingContext' @ [86:67] ==> value-parameter typingContext: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[ValueParameterDescriptorImpl]

'trace' @ [86:81] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'propertyDescriptor' @ [87:17] ==> val propertyDescriptor: VariableDescriptor defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'getter' @ [87:36] ==> public abstract val getter: VariableAccessorDescriptor? defined in org.jetbrains.kotlin.descriptors.VariableDescriptorWithAccessors[DeserializedPropertyDescriptor]

'updateAccessorFlagsFromResolvedCallForDelegatedProperty' @ [87:44] ==> private final fun VariableAccessorDescriptor.updateAccessorFlagsFromResolvedCallForDelegatedProperty(trace: BindingTrace): Unit defined in org.jetbrains.kotlin.resolve.LocalVariableResolver[SimpleFunctionDescriptorImpl]

'typingContext' @ [87:100] ==> value-parameter typingContext: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[ValueParameterDescriptorImpl]

'trace' @ [87:114] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'propertyDescriptor' @ [88:17] ==> val propertyDescriptor: VariableDescriptor defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'setter' @ [88:36] ==> public abstract val setter: VariableAccessorDescriptor? defined in org.jetbrains.kotlin.descriptors.VariableDescriptorWithAccessors[DeserializedPropertyDescriptor]

'updateAccessorFlagsFromResolvedCallForDelegatedProperty' @ [88:44] ==> private final fun VariableAccessorDescriptor.updateAccessorFlagsFromResolvedCallForDelegatedProperty(trace: BindingTrace): Unit defined in org.jetbrains.kotlin.resolve.LocalVariableResolver[SimpleFunctionDescriptorImpl]

'typingContext' @ [88:100] ==> value-parameter typingContext: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[ValueParameterDescriptorImpl]

'trace' @ [88:114] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'property' @ [92:27] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[ValueParameterDescriptorImpl]

'initializer' @ [92:36] ==> public final var KtProperty.initializer: KtExpression?[MyPropertyDescriptor]

'if (initializer != null) {
            val outType = propertyDescriptor.type
            typeInfo = facade.getTypeInfo(initializer, context.replaceExpectedType(outType))
            val dataFlowInfo = typeInfo.dataFlowInfo
            val type = typeInfo.type
            if (type != null) {
                val initializerDataFlowValue = DataFlowValueFactory.createDataFlowValue(initializer, type, context)
                if (!propertyDescriptor.isVar && initializerDataFlowValue.canBeBound) {
                    context.trace.record(BindingContext.BOUND_INITIALIZER_VALUE, propertyDescriptor, initializerDataFlowValue)
                }
                // At this moment we do not take initializer value into account if type is given for a property
                // We can comment this condition to take them into account, like here: var s: String? = "xyz"
                // In this case s will be not-nullable until it is changed
                if (property.typeReference == null) {
                    val variableDataFlowValue = DataFlowValueFactory.createDataFlowValueForProperty(
                            property, propertyDescriptor, context.trace.bindingContext,
                            DescriptorUtils.getContainingModuleOrNull(scope.ownerDescriptor))
                    // We cannot say here anything new about initializerDataFlowValue
                    // except it has the same value as variableDataFlowValue
                    typeInfo = typeInfo.replaceDataFlowInfo(dataFlowInfo.assign(variableDataFlowValue, initializerDataFlowValue,
                                                                                languageVersionSettings))
                }
            }
        }
        else {
            typeInfo = noTypeInfo(context)
        }' @ [94:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'initializer' @ [94:13] ==> val initializer: KtExpression? defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'propertyDescriptor' @ [95:27] ==> val propertyDescriptor: VariableDescriptor defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'type' @ [95:46] ==> public final val VariableDescriptor.type: KotlinType[MyPropertyDescriptor]

'typeInfo' @ [96:13] ==> var typeInfo: KotlinTypeInfo defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'facade' @ [96:24] ==> value-parameter facade: ExpressionTypingFacade defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[ValueParameterDescriptorImpl]

'getTypeInfo' @ [96:31] ==> @NotNull public abstract fun getTypeInfo(@NotNull expression: KtExpression, context: (ExpressionTypingContext..ExpressionTypingContext?)): KotlinTypeInfo defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingFacade[JavaMethodDescriptor]

'initializer' @ [96:43] ==> val initializer: KtExpression? defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'context' @ [96:56] ==> val context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'replaceExpectedType' @ [96:64] ==> @NotNull public open fun replaceExpectedType(@Nullable newExpectedType: KotlinType?): ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaMethodDescriptor]

'outType' @ [96:84] ==> val outType: KotlinType defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'typeInfo' @ [97:32] ==> var typeInfo: KotlinTypeInfo defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'dataFlowInfo' @ [97:41] ==> public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.types.expressions.KotlinTypeInfo[PropertyDescriptorImpl]

'typeInfo' @ [98:24] ==> var typeInfo: KotlinTypeInfo defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'type' @ [98:33] ==> public final val type: KotlinType? defined in org.jetbrains.kotlin.types.expressions.KotlinTypeInfo[PropertyDescriptorImpl]

'type' @ [99:17] ==> val type: KotlinType? defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'DataFlowValueFactory' @ [100:48] ==> public object DataFlowValueFactory defined in org.jetbrains.kotlin.resolve.calls.smartcasts in file DataFlowValueFactory.kt[FakeCallableDescriptorForObject]

'createDataFlowValue' @ [100:69] ==> @JvmStatic public final fun createDataFlowValue(expression: KtExpression, type: KotlinType, resolutionContext: ResolutionContext<*>): DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValueFactory[SimpleFunctionDescriptorImpl]

'initializer' @ [100:89] ==> val initializer: KtExpression? defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'type' @ [100:102] ==> val type: KotlinType? defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'context' @ [100:108] ==> val context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'!' @ [101:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'propertyDescriptor' @ [101:22] ==> val propertyDescriptor: VariableDescriptor defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'isVar' @ [101:41] ==> public final val VariableDescriptor.isVar: Boolean[MyPropertyDescriptor]

'initializerDataFlowValue' @ [101:50] ==> val initializerDataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'canBeBound' @ [101:75] ==> public final val canBeBound: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'context' @ [102:21] ==> val context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'trace' @ [102:29] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'record' @ [102:35] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(VariableDescriptor..VariableDescriptor?), (DataFlowValue..DataFlowValue?)>..WritableSlice<(VariableDescriptor..VariableDescriptor?), (DataFlowValue..DataFlowValue?)>?), key: (VariableDescriptor..VariableDescriptor?), value: (DataFlowValue..DataFlowValue?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.descriptors.VariableDescriptor..org.jetbrains.kotlin.descriptors.VariableDescriptor?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue..org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue?)

'BOUND_INITIALIZER_VALUE' @ [102:57] ==> public final val BOUND_INITIALIZER_VALUE: (WritableSlice<(VariableDescriptor..VariableDescriptor?), (DataFlowValue..DataFlowValue?)>..WritableSlice<(VariableDescriptor..VariableDescriptor?), (DataFlowValue..DataFlowValue?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'propertyDescriptor' @ [102:82] ==> val propertyDescriptor: VariableDescriptor defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'initializerDataFlowValue' @ [102:102] ==> val initializerDataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'property' @ [107:21] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[ValueParameterDescriptorImpl]

'typeReference' @ [107:30] ==> public final var KtProperty.typeReference: KtTypeReference?[MyPropertyDescriptor]

'DataFlowValueFactory' @ [108:49] ==> public object DataFlowValueFactory defined in org.jetbrains.kotlin.resolve.calls.smartcasts in file DataFlowValueFactory.kt[FakeCallableDescriptorForObject]

'createDataFlowValueForProperty' @ [108:70] ==> @JvmStatic public final fun createDataFlowValueForProperty(property: KtProperty, variableDescriptor: VariableDescriptor, bindingContext: BindingContext, usageContainingModule: ModuleDescriptor?): DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValueFactory[SimpleFunctionDescriptorImpl]

'property' @ [109:29] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[ValueParameterDescriptorImpl]

'propertyDescriptor' @ [109:39] ==> val propertyDescriptor: VariableDescriptor defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'context' @ [109:59] ==> val context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'trace' @ [109:67] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'bindingContext' @ [109:73] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'getContainingModuleOrNull' @ [110:45] ==> @Nullable public open fun getContainingModuleOrNull(@NotNull p0: DeclarationDescriptor): ModuleDescriptor? defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'scope' @ [110:71] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[ValueParameterDescriptorImpl]

'ownerDescriptor' @ [110:77] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'typeInfo' @ [113:21] ==> var typeInfo: KotlinTypeInfo defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'typeInfo' @ [113:32] ==> var typeInfo: KotlinTypeInfo defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'replaceDataFlowInfo' @ [113:41] ==> public final fun replaceDataFlowInfo(dataFlowInfo: DataFlowInfo): KotlinTypeInfo defined in org.jetbrains.kotlin.types.expressions.KotlinTypeInfo[SimpleFunctionDescriptorImpl]

'dataFlowInfo' @ [113:61] ==> val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'assign' @ [113:74] ==> public abstract fun assign(a: DataFlowValue, b: DataFlowValue, languageVersionSettings: LanguageVersionSettings): DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo[SimpleFunctionDescriptorImpl]

'variableDataFlowValue' @ [113:81] ==> val variableDataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'initializerDataFlowValue' @ [113:104] ==> val initializerDataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'languageVersionSettings' @ [114:81] ==> private final val languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.LocalVariableResolver[PropertyDescriptorImpl]

'typeInfo' @ [119:13] ==> var typeInfo: KotlinTypeInfo defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'noTypeInfo' @ [119:24] ==> public fun noTypeInfo(context: ResolutionContext<*>): KotlinTypeInfo defined in org.jetbrains.kotlin.types.expressions.typeInfoFactory in file TypeInfoFactory.kt[SimpleFunctionDescriptorImpl]

'context' @ [119:35] ==> val context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'checkVariableShadowing' @ [122:31] ==> public open fun checkVariableShadowing(@NotNull scope: LexicalScope, @NotNull trace: BindingTrace, @NotNull variableDescriptor: VariableDescriptor): Unit defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingUtils[JavaMethodDescriptor]

'context' @ [122:54] ==> val context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'scope' @ [122:62] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'context' @ [122:69] ==> val context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'trace' @ [122:77] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'propertyDescriptor' @ [122:84] ==> val propertyDescriptor: VariableDescriptor defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'modifiersChecker' @ [124:9] ==> private final val modifiersChecker: ModifiersChecker defined in org.jetbrains.kotlin.resolve.LocalVariableResolver[PropertyDescriptorImpl]

'withTrace' @ [124:26] ==> @NotNull public open fun withTrace(@NotNull trace: BindingTrace): ModifiersChecker.ModifiersCheckingProcedure defined in org.jetbrains.kotlin.resolve.ModifiersChecker[JavaMethodDescriptor]

'context' @ [124:36] ==> val context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'trace' @ [124:44] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'checkModifiersForLocalDeclaration' @ [124:51] ==> public open fun checkModifiersForLocalDeclaration(@NotNull modifierListOwner: KtDeclaration, @NotNull descriptor: DeclarationDescriptor): Unit defined in org.jetbrains.kotlin.resolve.ModifiersChecker.ModifiersCheckingProcedure[JavaMethodDescriptor]

'property' @ [124:85] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[ValueParameterDescriptorImpl]

'propertyDescriptor' @ [124:95] ==> val propertyDescriptor: VariableDescriptor defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'identifierChecker' @ [125:9] ==> private final val identifierChecker: IdentifierChecker defined in org.jetbrains.kotlin.resolve.LocalVariableResolver[PropertyDescriptorImpl]

'checkDeclaration' @ [125:27] ==> public abstract fun checkDeclaration(declaration: KtDeclaration, diagnosticHolder: DiagnosticSink): Unit defined in org.jetbrains.kotlin.resolve.IdentifierChecker[SimpleFunctionDescriptorImpl]

'property' @ [125:44] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[ValueParameterDescriptorImpl]

'context' @ [125:54] ==> val context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'trace' @ [125:62] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'Pair' @ [126:16] ==> public constructor Pair<out A, out B>(first: KotlinTypeInfo, second: VariableDescriptor) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> KotlinTypeInfo
    <out B> -> VariableDescriptor

'typeInfo' @ [126:21] ==> var typeInfo: KotlinTypeInfo defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'replaceType' @ [126:30] ==> public final fun replaceType(type: KotlinType?): KotlinTypeInfo defined in org.jetbrains.kotlin.types.expressions.KotlinTypeInfo[SimpleFunctionDescriptorImpl]

'dataFlowAnalyzer' @ [126:42] ==> private final val dataFlowAnalyzer: DataFlowAnalyzer defined in org.jetbrains.kotlin.resolve.LocalVariableResolver[PropertyDescriptorImpl]

'checkStatementType' @ [126:59] ==> @Nullable public open fun checkStatementType(@NotNull expression: KtExpression, @NotNull context: raw (ResolutionContext<(ResolutionContext<*>..ResolutionContext<*>?)>..ResolutionContext<out (ResolutionContext<*>..ResolutionContext<*>?)>)): KotlinType? defined in org.jetbrains.kotlin.types.expressions.DataFlowAnalyzer[JavaMethodDescriptor]

'property' @ [126:78] ==> value-parameter property: KtProperty defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[ValueParameterDescriptorImpl]

'context' @ [126:88] ==> val context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'propertyDescriptor' @ [126:99] ==> val propertyDescriptor: VariableDescriptor defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.process[LocalVariableDescriptor]

'scope' @ [135:37] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'ownerDescriptor' @ [135:43] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'if (KtPsiUtil.isScriptDeclaration(variable)) {
            val propertyDescriptor = PropertyDescriptorImpl.create(
                    containingDeclaration,
                    annotationResolver.resolveAnnotationsWithArguments(scope, variable.modifierList, trace),
                    Modality.FINAL,
                    Visibilities.INTERNAL,
                    variable.isVar,
                    KtPsiUtil.safeName(variable.name),
                    CallableMemberDescriptor.Kind.DECLARATION,
                    variable.toSourceElement(),
                    /* lateInit = */ false,
                    /* isConst = */ false,
                    /* isHeader = */ false,
                    /* isImpl = */ false,
                    /* isExternal = */ false,
                    variable is KtProperty && variable.hasDelegate()
            )
            // For a local variable the type must not be deferred
            type = variableTypeAndInitializerResolver.resolveType(propertyDescriptor, scope, variable, dataFlowInfo, trace, local = true)

            val receiverParameter = (containingDeclaration as ScriptDescriptor).thisAsReceiverParameter
            propertyDescriptor.setType(type, emptyList<TypeParameterDescriptor>(), receiverParameter, null as KotlinType?)
            initializeWithDefaultGetterSetter(propertyDescriptor)
            trace.record(BindingContext.VARIABLE, variable, propertyDescriptor)
            result = propertyDescriptor
        }
        else {
            val variableDescriptor = resolveLocalVariableDescriptorWithType(scope, variable, null, trace)
            // For a local variable the type must not be deferred
            type = variableTypeAndInitializerResolver.resolveType(variableDescriptor, scope, variable, dataFlowInfo, trace, local = true)
            variableDescriptor.setOutType(type)
            result = variableDescriptor
        }' @ [138:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'isScriptDeclaration' @ [138:23] ==> public open fun isScriptDeclaration(@NotNull namedDeclaration: KtDeclaration): Boolean defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'variable' @ [138:43] ==> value-parameter variable: KtVariableDeclaration defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'create' @ [139:61] ==> @NotNull public open fun create(@NotNull p0: DeclarationDescriptor, @NotNull p1: Annotations, @NotNull p2: Modality, @NotNull p3: Visibility, p4: Boolean, @NotNull p5: Name, @NotNull p6: CallableMemberDescriptor.Kind, @NotNull p7: SourceElement, p8: Boolean, p9: Boolean, p10: Boolean, p11: Boolean, p12: Boolean, p13: Boolean): PropertyDescriptorImpl defined in org.jetbrains.kotlin.descriptors.impl.PropertyDescriptorImpl[JavaMethodDescriptor]

'containingDeclaration' @ [140:21] ==> val containingDeclaration: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[LocalVariableDescriptor]

'annotationResolver' @ [141:21] ==> private final val annotationResolver: AnnotationResolver defined in org.jetbrains.kotlin.resolve.LocalVariableResolver[PropertyDescriptorImpl]

'resolveAnnotationsWithArguments' @ [141:40] ==> public final fun resolveAnnotationsWithArguments(scope: LexicalScope, modifierList: KtModifierList?, trace: BindingTrace): Annotations defined in org.jetbrains.kotlin.resolve.AnnotationResolver[SimpleFunctionDescriptorImpl]

'scope' @ [141:72] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'variable' @ [141:79] ==> value-parameter variable: KtVariableDeclaration defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'modifierList' @ [141:88] ==> public final val KtVariableDeclaration.modifierList: KtModifierList?[MyPropertyDescriptor]

'trace' @ [141:102] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'FINAL' @ [142:30] ==> enum entry FINAL defined in org.jetbrains.kotlin.descriptors.Modality[FakeCallableDescriptorForObject]

'INTERNAL' @ [143:34] ==> @NotNull public final val INTERNAL: Visibility defined in org.jetbrains.kotlin.descriptors.Visibilities[JavaPropertyDescriptor]

'variable' @ [144:21] ==> value-parameter variable: KtVariableDeclaration defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'isVar' @ [144:30] ==> public final val KtVariableDeclaration.isVar: Boolean[MyPropertyDescriptor]

'safeName' @ [145:31] ==> @NotNull public open fun safeName(@Nullable name: String?): Name defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'variable' @ [145:40] ==> value-parameter variable: KtVariableDeclaration defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'name' @ [145:49] ==> public final val KtVariableDeclaration.name: String?[MyPropertyDescriptor]

'DECLARATION' @ [146:51] ==> enum entry DECLARATION defined in org.jetbrains.kotlin.descriptors.CallableMemberDescriptor.Kind[FakeCallableDescriptorForObject]

'variable' @ [147:21] ==> value-parameter variable: KtVariableDeclaration defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'toSourceElement' @ [147:30] ==> public fun KtPureElement?.toSourceElement(): SourceElement defined in org.jetbrains.kotlin.resolve.source in file KotlinSourceElement.kt[SimpleFunctionDescriptorImpl]

'variable' @ [153:21] ==> value-parameter variable: KtVariableDeclaration defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'variable' @ [153:47] ==> value-parameter variable: KtVariableDeclaration defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'hasDelegate' @ [153:56] ==> public open fun hasDelegate(): Boolean defined in org.jetbrains.kotlin.psi.KtProperty[JavaMethodDescriptor]

'type' @ [156:13] ==> val type: KotlinType defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[LocalVariableDescriptor]

'variableTypeAndInitializerResolver' @ [156:20] ==> private final val variableTypeAndInitializerResolver: VariableTypeAndInitializerResolver defined in org.jetbrains.kotlin.resolve.LocalVariableResolver[PropertyDescriptorImpl]

'resolveType' @ [156:55] ==> public final fun resolveType(variableDescriptor: VariableDescriptorWithInitializerImpl, scopeForInitializer: LexicalScope, variable: KtVariableDeclaration, dataFlowInfo: DataFlowInfo, trace: BindingTrace, local: Boolean): KotlinType defined in org.jetbrains.kotlin.resolve.VariableTypeAndInitializerResolver[SimpleFunctionDescriptorImpl]

'propertyDescriptor' @ [156:67] ==> val propertyDescriptor: PropertyDescriptorImpl defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[LocalVariableDescriptor]

'scope' @ [156:87] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'variable' @ [156:94] ==> value-parameter variable: KtVariableDeclaration defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [156:104] ==> value-parameter dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'trace' @ [156:118] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'containingDeclaration' @ [158:38] ==> val containingDeclaration: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[LocalVariableDescriptor]

'thisAsReceiverParameter' @ [158:81] ==> public final val ScriptDescriptor.thisAsReceiverParameter: ReceiverParameterDescriptor[MyPropertyDescriptor]

'propertyDescriptor' @ [159:13] ==> val propertyDescriptor: PropertyDescriptorImpl defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[LocalVariableDescriptor]

'setType' @ [159:32] ==> public open fun setType(@NotNull p0: KotlinType, @ReadOnly @NotNull p1: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>, @Nullable p2: ReceiverParameterDescriptor?, @Nullable p3: KotlinType?): Unit defined in org.jetbrains.kotlin.descriptors.impl.PropertyDescriptorImpl[JavaMethodDescriptor]

'type' @ [159:40] ==> val type: KotlinType defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[LocalVariableDescriptor]

'emptyList' @ [159:46] ==> public fun <T> emptyList(): List<TypeParameterDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeParameterDescriptor

'receiverParameter' @ [159:84] ==> val receiverParameter: ReceiverParameterDescriptor defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[LocalVariableDescriptor]

'initializeWithDefaultGetterSetter' @ [160:13] ==> private final fun initializeWithDefaultGetterSetter(propertyDescriptor: PropertyDescriptorImpl): Unit defined in org.jetbrains.kotlin.resolve.LocalVariableResolver[SimpleFunctionDescriptorImpl]

'propertyDescriptor' @ [160:47] ==> val propertyDescriptor: PropertyDescriptorImpl defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[LocalVariableDescriptor]

'trace' @ [161:13] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'record' @ [161:19] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(PsiElement..PsiElement?), (VariableDescriptor..VariableDescriptor?)>..WritableSlice<(PsiElement..PsiElement?), (VariableDescriptor..VariableDescriptor?)>?), key: (PsiElement..PsiElement?), value: (VariableDescriptor..VariableDescriptor?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.descriptors.VariableDescriptor..org.jetbrains.kotlin.descriptors.VariableDescriptor?)

'VARIABLE' @ [161:41] ==> public final val VARIABLE: (WritableSlice<(PsiElement..PsiElement?), (VariableDescriptor..VariableDescriptor?)>..WritableSlice<(PsiElement..PsiElement?), (VariableDescriptor..VariableDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'variable' @ [161:51] ==> value-parameter variable: KtVariableDeclaration defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'propertyDescriptor' @ [161:61] ==> val propertyDescriptor: PropertyDescriptorImpl defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[LocalVariableDescriptor]

'result' @ [162:13] ==> val result: VariableDescriptorWithInitializerImpl defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[LocalVariableDescriptor]

'propertyDescriptor' @ [162:22] ==> val propertyDescriptor: PropertyDescriptorImpl defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[LocalVariableDescriptor]

'resolveLocalVariableDescriptorWithType' @ [165:38] ==> internal final fun resolveLocalVariableDescriptorWithType(scope: LexicalScope, variable: KtVariableDeclaration, type: KotlinType?, trace: BindingTrace): LocalVariableDescriptor defined in org.jetbrains.kotlin.resolve.LocalVariableResolver[SimpleFunctionDescriptorImpl]

'scope' @ [165:77] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'variable' @ [165:84] ==> value-parameter variable: KtVariableDeclaration defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'trace' @ [165:100] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'type' @ [167:13] ==> val type: KotlinType defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[LocalVariableDescriptor]

'variableTypeAndInitializerResolver' @ [167:20] ==> private final val variableTypeAndInitializerResolver: VariableTypeAndInitializerResolver defined in org.jetbrains.kotlin.resolve.LocalVariableResolver[PropertyDescriptorImpl]

'resolveType' @ [167:55] ==> public final fun resolveType(variableDescriptor: VariableDescriptorWithInitializerImpl, scopeForInitializer: LexicalScope, variable: KtVariableDeclaration, dataFlowInfo: DataFlowInfo, trace: BindingTrace, local: Boolean): KotlinType defined in org.jetbrains.kotlin.resolve.VariableTypeAndInitializerResolver[SimpleFunctionDescriptorImpl]

'variableDescriptor' @ [167:67] ==> val variableDescriptor: LocalVariableDescriptor defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[LocalVariableDescriptor]

'scope' @ [167:87] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'variable' @ [167:94] ==> value-parameter variable: KtVariableDeclaration defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [167:104] ==> value-parameter dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'trace' @ [167:118] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'variableDescriptor' @ [168:13] ==> val variableDescriptor: LocalVariableDescriptor defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[LocalVariableDescriptor]

'setOutType' @ [168:32] ==> @Override public open fun setOutType(outType: (KotlinType..KotlinType?)): Unit defined in org.jetbrains.kotlin.descriptors.impl.LocalVariableDescriptor[JavaMethodDescriptor]

'type' @ [168:43] ==> val type: KotlinType defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[LocalVariableDescriptor]

'result' @ [169:13] ==> val result: VariableDescriptorWithInitializerImpl defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[LocalVariableDescriptor]

'variableDescriptor' @ [169:22] ==> val variableDescriptor: LocalVariableDescriptor defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[LocalVariableDescriptor]

'variableTypeAndInitializerResolver' @ [171:9] ==> private final val variableTypeAndInitializerResolver: VariableTypeAndInitializerResolver defined in org.jetbrains.kotlin.resolve.LocalVariableResolver[PropertyDescriptorImpl]

'setConstantForVariableIfNeeded' @ [171:44] ==> public final fun setConstantForVariableIfNeeded(variableDescriptor: VariableDescriptorWithInitializerImpl, scope: LexicalScope, variable: KtVariableDeclaration, dataFlowInfo: DataFlowInfo, variableType: KotlinType, trace: BindingTrace): Unit defined in org.jetbrains.kotlin.resolve.VariableTypeAndInitializerResolver[SimpleFunctionDescriptorImpl]

'result' @ [171:75] ==> val result: VariableDescriptorWithInitializerImpl defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[LocalVariableDescriptor]

'scope' @ [171:83] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'variable' @ [171:90] ==> value-parameter variable: KtVariableDeclaration defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [171:100] ==> value-parameter dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'type' @ [171:114] ==> val type: KotlinType defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[LocalVariableDescriptor]

'trace' @ [171:120] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[ValueParameterDescriptorImpl]

'forceResolveAllContents' @ [173:26] ==> public open fun forceResolveAllContents(@NotNull annotations: Annotations): Unit defined in org.jetbrains.kotlin.resolve.lazy.ForceResolveUtil[JavaMethodDescriptor]

'type' @ [173:50] ==> val type: KotlinType defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[LocalVariableDescriptor]

'annotations' @ [173:55] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'result' @ [174:16] ==> val result: VariableDescriptorWithInitializerImpl defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptor[LocalVariableDescriptor]

'propertyDescriptor' @ [178:22] ==> value-parameter propertyDescriptor: PropertyDescriptorImpl defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.initializeWithDefaultGetterSetter[ValueParameterDescriptorImpl]

'getter' @ [178:41] ==> public open val getter: PropertyGetterDescriptorImpl? defined in org.jetbrains.kotlin.descriptors.impl.PropertyDescriptorImpl[JavaPropertyDescriptor]

'getter' @ [179:13] ==> var getter: PropertyGetterDescriptorImpl? defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.initializeWithDefaultGetterSetter[LocalVariableDescriptor]

'!' @ [179:31] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isPrivate' @ [179:45] ==> public open fun isPrivate(@NotNull p0: Visibility): Boolean defined in org.jetbrains.kotlin.descriptors.Visibilities[JavaMethodDescriptor]

'propertyDescriptor' @ [179:55] ==> value-parameter propertyDescriptor: PropertyDescriptorImpl defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.initializeWithDefaultGetterSetter[ValueParameterDescriptorImpl]

'visibility' @ [179:74] ==> public final var PropertyDescriptorImpl.visibility: Visibility[MyPropertyDescriptor]

'getter' @ [180:13] ==> var getter: PropertyGetterDescriptorImpl? defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.initializeWithDefaultGetterSetter[LocalVariableDescriptor]

'createDefaultGetter' @ [180:40] ==> @NotNull public open fun createDefaultGetter(@NotNull p0: PropertyDescriptor, @NotNull p1: Annotations): PropertyGetterDescriptorImpl defined in org.jetbrains.kotlin.resolve.DescriptorFactory[JavaMethodDescriptor]

'propertyDescriptor' @ [180:60] ==> value-parameter propertyDescriptor: PropertyDescriptorImpl defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.initializeWithDefaultGetterSetter[ValueParameterDescriptorImpl]

'EMPTY' @ [180:92] ==> public final val EMPTY: Annotations defined in org.jetbrains.kotlin.descriptors.annotations.Annotations.Companion[DeserializedPropertyDescriptor]

'getter' @ [181:13] ==> var getter: PropertyGetterDescriptorImpl? defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.initializeWithDefaultGetterSetter[LocalVariableDescriptor]

'initialize' @ [181:20] ==> public open fun initialize(p0: (KotlinType..KotlinType?)): Unit defined in org.jetbrains.kotlin.descriptors.impl.PropertyGetterDescriptorImpl[JavaMethodDescriptor]

'propertyDescriptor' @ [181:31] ==> value-parameter propertyDescriptor: PropertyDescriptorImpl defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.initializeWithDefaultGetterSetter[ValueParameterDescriptorImpl]

'type' @ [181:50] ==> public final val PropertyDescriptorImpl.type: KotlinType[MyPropertyDescriptor]

'propertyDescriptor' @ [184:22] ==> value-parameter propertyDescriptor: PropertyDescriptorImpl defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.initializeWithDefaultGetterSetter[ValueParameterDescriptorImpl]

'setter' @ [184:41] ==> public open val setter: PropertySetterDescriptor? defined in org.jetbrains.kotlin.descriptors.impl.PropertyDescriptorImpl[JavaPropertyDescriptor]

'setter' @ [185:13] ==> var setter: PropertySetterDescriptor? defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.initializeWithDefaultGetterSetter[LocalVariableDescriptor]

'propertyDescriptor' @ [185:31] ==> value-parameter propertyDescriptor: PropertyDescriptorImpl defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.initializeWithDefaultGetterSetter[ValueParameterDescriptorImpl]

'isVar' @ [185:50] ==> public final val PropertyDescriptorImpl.isVar: Boolean[MyPropertyDescriptor]

'setter' @ [186:13] ==> var setter: PropertySetterDescriptor? defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.initializeWithDefaultGetterSetter[LocalVariableDescriptor]

'createDefaultSetter' @ [186:40] ==> @NotNull public open fun createDefaultSetter(@NotNull p0: PropertyDescriptor, @NotNull p1: Annotations): PropertySetterDescriptorImpl defined in org.jetbrains.kotlin.resolve.DescriptorFactory[JavaMethodDescriptor]

'propertyDescriptor' @ [186:60] ==> value-parameter propertyDescriptor: PropertyDescriptorImpl defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.initializeWithDefaultGetterSetter[ValueParameterDescriptorImpl]

'EMPTY' @ [186:92] ==> public final val EMPTY: Annotations defined in org.jetbrains.kotlin.descriptors.annotations.Annotations.Companion[DeserializedPropertyDescriptor]

'propertyDescriptor' @ [188:9] ==> value-parameter propertyDescriptor: PropertyDescriptorImpl defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.initializeWithDefaultGetterSetter[ValueParameterDescriptorImpl]

'initialize' @ [188:28] ==> public open fun initialize(@Nullable p0: PropertyGetterDescriptorImpl?, @Nullable p1: PropertySetterDescriptor?): Unit defined in org.jetbrains.kotlin.descriptors.impl.PropertyDescriptorImpl[JavaMethodDescriptor]

'getter' @ [188:39] ==> var getter: PropertyGetterDescriptorImpl? defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.initializeWithDefaultGetterSetter[LocalVariableDescriptor]

'setter' @ [188:47] ==> var setter: PropertySetterDescriptor? defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.initializeWithDefaultGetterSetter[LocalVariableDescriptor]

'variable' @ [197:27] ==> value-parameter variable: KtVariableDeclaration defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptorWithType[ValueParameterDescriptorImpl]

'variable' @ [197:53] ==> value-parameter variable: KtVariableDeclaration defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptorWithType[ValueParameterDescriptorImpl]

'hasDelegate' @ [197:62] ==> public open fun hasDelegate(): Boolean defined in org.jetbrains.kotlin.psi.KtProperty[JavaMethodDescriptor]

'LocalVariableDescriptor' @ [198:34] ==> public constructor LocalVariableDescriptor(@NotNull containingDeclaration: DeclarationDescriptor, @NotNull annotations: Annotations, @NotNull name: Name, @Nullable type: KotlinType?, mutable: Boolean, isDelegated: Boolean, @NotNull source: SourceElement) defined in org.jetbrains.kotlin.descriptors.impl.LocalVariableDescriptor[JavaClassConstructorDescriptor]

'scope' @ [199:17] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptorWithType[ValueParameterDescriptorImpl]

'ownerDescriptor' @ [199:23] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'annotationResolver' @ [200:17] ==> private final val annotationResolver: AnnotationResolver defined in org.jetbrains.kotlin.resolve.LocalVariableResolver[PropertyDescriptorImpl]

'resolveAnnotationsWithArguments' @ [200:36] ==> public final fun resolveAnnotationsWithArguments(scope: LexicalScope, modifierList: KtModifierList?, trace: BindingTrace): Annotations defined in org.jetbrains.kotlin.resolve.AnnotationResolver[SimpleFunctionDescriptorImpl]

'scope' @ [200:68] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptorWithType[ValueParameterDescriptorImpl]

'variable' @ [200:75] ==> value-parameter variable: KtVariableDeclaration defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptorWithType[ValueParameterDescriptorImpl]

'modifierList' @ [200:84] ==> public final val KtVariableDeclaration.modifierList: KtModifierList?[MyPropertyDescriptor]

'trace' @ [200:98] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptorWithType[ValueParameterDescriptorImpl]

'if (variable.isSingleUnderscore)
                    Name.special("<underscore local var>")
                else
                    KtPsiUtil.safeName(variable.name)' @ [203:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Name, elseBranch: Name): Name[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Name

'variable' @ [203:21] ==> value-parameter variable: KtVariableDeclaration defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptorWithType[ValueParameterDescriptorImpl]

'isSingleUnderscore' @ [203:30] ==> public val KtNamedDeclaration.isSingleUnderscore: Boolean defined in org.jetbrains.kotlin.resolve.calls.util in file underscoreUtil.kt[PropertyDescriptorImpl]

'special' @ [204:26] ==> @NotNull public open fun special(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'safeName' @ [206:31] ==> @NotNull public open fun safeName(@Nullable name: String?): Name defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'variable' @ [206:40] ==> value-parameter variable: KtVariableDeclaration defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptorWithType[ValueParameterDescriptorImpl]

'name' @ [206:49] ==> public final val KtVariableDeclaration.name: String?[MyPropertyDescriptor]

'type' @ [207:17] ==> value-parameter type: KotlinType? defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptorWithType[ValueParameterDescriptorImpl]

'variable' @ [208:17] ==> value-parameter variable: KtVariableDeclaration defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptorWithType[ValueParameterDescriptorImpl]

'isVar' @ [208:26] ==> public final val KtVariableDeclaration.isVar: Boolean[MyPropertyDescriptor]

'hasDelegate' @ [209:17] ==> val hasDelegate: Boolean defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptorWithType[LocalVariableDescriptor]

'variable' @ [210:17] ==> value-parameter variable: KtVariableDeclaration defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptorWithType[ValueParameterDescriptorImpl]

'toSourceElement' @ [210:26] ==> public fun KtPureElement?.toSourceElement(): SourceElement defined in org.jetbrains.kotlin.resolve.source in file KotlinSourceElement.kt[SimpleFunctionDescriptorImpl]

'trace' @ [212:9] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptorWithType[ValueParameterDescriptorImpl]

'record' @ [212:15] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(PsiElement..PsiElement?), (VariableDescriptor..VariableDescriptor?)>..WritableSlice<(PsiElement..PsiElement?), (VariableDescriptor..VariableDescriptor?)>?), key: (PsiElement..PsiElement?), value: (VariableDescriptor..VariableDescriptor?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.descriptors.VariableDescriptor..org.jetbrains.kotlin.descriptors.VariableDescriptor?)

'VARIABLE' @ [212:37] ==> public final val VARIABLE: (WritableSlice<(PsiElement..PsiElement?), (VariableDescriptor..VariableDescriptor?)>..WritableSlice<(PsiElement..PsiElement?), (VariableDescriptor..VariableDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'variable' @ [212:47] ==> value-parameter variable: KtVariableDeclaration defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptorWithType[ValueParameterDescriptorImpl]

'variableDescriptor' @ [212:57] ==> val variableDescriptor: LocalVariableDescriptor defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptorWithType[LocalVariableDescriptor]

'variableDescriptor' @ [213:16] ==> val variableDescriptor: LocalVariableDescriptor defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.resolveLocalVariableDescriptorWithType[LocalVariableDescriptor]

'this' @ [217:13] ==> <this> defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.updateAccessorFlagsFromResolvedCallForDelegatedProperty[ReceiverParameterDescriptorImpl]

'trace' @ [218:39] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.updateAccessorFlagsFromResolvedCallForDelegatedProperty[ValueParameterDescriptorImpl]

'bindingContext' @ [218:45] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'get' @ [218:60] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(slice: (ReadOnlySlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>..ReadOnlySlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>?), key: (VariableAccessorDescriptor..VariableAccessorDescriptor?)): ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.descriptors.VariableAccessorDescriptor..org.jetbrains.kotlin.descriptors.VariableAccessorDescriptor?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedCall<(org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)>..org.jetbrains.kotlin.resolve.calls.model.ResolvedCall<(org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)>?)

'DELEGATED_PROPERTY_RESOLVED_CALL' @ [218:79] ==> public final val DELEGATED_PROPERTY_RESOLVED_CALL: (WritableSlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>..WritableSlice<(VariableAccessorDescriptor..VariableAccessorDescriptor?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'this' @ [218:113] ==> <this> defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.updateAccessorFlagsFromResolvedCallForDelegatedProperty[ReceiverParameterDescriptorImpl]

'resultingDescriptor' @ [218:120] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>.resultingDescriptor: FunctionDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)

'resultingDescriptor' @ [219:17] ==> val resultingDescriptor: FunctionDescriptor? defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.updateAccessorFlagsFromResolvedCallForDelegatedProperty[LocalVariableDescriptor]

'setSuspend' @ [220:17] ==> public open fun setSuspend(p0: Boolean): Unit defined in org.jetbrains.kotlin.descriptors.impl.FunctionDescriptorImpl[JavaMethodDescriptor]

'resultingDescriptor' @ [220:28] ==> val resultingDescriptor: FunctionDescriptor? defined in org.jetbrains.kotlin.resolve.LocalVariableResolver.updateAccessorFlagsFromResolvedCallForDelegatedProperty[LocalVariableDescriptor]

'isSuspend' @ [220:48] ==> public final val FunctionDescriptor.isSuspend: Boolean[MyPropertyDescriptor]

