'classDescriptor' @ [55:30] ==> private final val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'isFinalClass' @ [55:46] ==> public val ClassDescriptor.isFinalClass: Boolean defined in org.jetbrains.kotlin.descriptors[DeserializedPropertyDescriptor]

'reference' @ [58:22] ==> value-parameter reference: KtReferenceExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.insideLValue[ValueParameterDescriptorImpl]

'getStrictParentOfType' @ [58:32] ==> public inline fun <reified T : PsiElement> PsiElement.getStrictParentOfType(): KtBinaryExpression? defined in org.jetbrains.kotlin.psi.psiUtil[SimpleFunctionDescriptorImpl]
Inferred types:
    <reified T : PsiElement> -> KtBinaryExpression

'binary' @ [59:13] ==> val binary: KtBinaryExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.insideLValue[LocalVariableDescriptor]

'operationToken' @ [59:20] ==> public final val KtBinaryExpression.operationToken: IElementType[MyPropertyDescriptor]

'ALL_ASSIGNMENTS' @ [59:47] ==> public final val ALL_ASSIGNMENTS: (TokenSet..TokenSet?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'binary' @ [60:30] ==> val binary: KtBinaryExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.insideLValue[LocalVariableDescriptor]

'left' @ [60:37] ==> public final val KtBinaryExpression.left: KtExpression?[MyPropertyDescriptor]

'reference' @ [61:39] ==> value-parameter reference: KtReferenceExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.insideLValue[ValueParameterDescriptorImpl]

'current' @ [62:20] ==> var current: PsiElement defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.insideLValue[LocalVariableDescriptor]

'binaryLeft' @ [62:32] ==> val binaryLeft: KtExpression? defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.insideLValue[LocalVariableDescriptor]

'current' @ [62:46] ==> var current: PsiElement defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.insideLValue[LocalVariableDescriptor]

'binary' @ [62:58] ==> val binary: KtBinaryExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.insideLValue[LocalVariableDescriptor]

'current' @ [63:17] ==> var current: PsiElement defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.insideLValue[LocalVariableDescriptor]

'current' @ [63:27] ==> var current: PsiElement defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.insideLValue[LocalVariableDescriptor]

'parent' @ [63:35] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'current' @ [65:20] ==> var current: PsiElement defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.insideLValue[LocalVariableDescriptor]

'binaryLeft' @ [65:32] ==> val binaryLeft: KtExpression? defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.insideLValue[LocalVariableDescriptor]

'trace' @ [71:26] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'get' @ [71:32] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(slice: (ReadOnlySlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?), key: (KtReferenceExpression..KtReferenceExpression?)): DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtReferenceExpression..org.jetbrains.kotlin.psi.KtReferenceExpression?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.descriptors.DeclarationDescriptor..org.jetbrains.kotlin.descriptors.DeclarationDescriptor?)

'REFERENCE_TARGET' @ [71:51] ==> public final val REFERENCE_TARGET: (WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'reference' @ [71:69] ==> value-parameter reference: KtReferenceExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeReferenceUsage[ValueParameterDescriptorImpl]

'descriptor' @ [72:13] ==> val descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeReferenceUsage[LocalVariableDescriptor]

'!' @ [73:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'finalClass' @ [73:18] ==> private final val finalClass: Boolean defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'descriptor' @ [73:32] ==> val descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeReferenceUsage[LocalVariableDescriptor]

'isOverridable' @ [73:43] ==> public val CallableMemberDescriptor.isOverridable: Boolean defined in org.jetbrains.kotlin.descriptors[DeserializedPropertyDescriptor]

'trace' @ [74:17] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'record' @ [74:23] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(KtExpression..KtExpression?), (LeakingThisDescriptor..LeakingThisDescriptor?)>..WritableSlice<(KtExpression..KtExpression?), (LeakingThisDescriptor..LeakingThisDescriptor?)>?), key: (KtExpression..KtExpression?), value: (LeakingThisDescriptor..LeakingThisDescriptor?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.cfg.LeakingThisDescriptor..org.jetbrains.kotlin.cfg.LeakingThisDescriptor?)

'LEAKING_THIS' @ [74:45] ==> public final val LEAKING_THIS: (WritableSlice<(KtExpression..KtExpression?), (LeakingThisDescriptor..LeakingThisDescriptor?)>..WritableSlice<(KtExpression..KtExpression?), (LeakingThisDescriptor..LeakingThisDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'reference' @ [74:59] ==> value-parameter reference: KtReferenceExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeReferenceUsage[ValueParameterDescriptorImpl]

'NonFinalProperty' @ [74:92] ==> public constructor NonFinalProperty(property: PropertyDescriptor, classOrObject: KtClassOrObject) defined in org.jetbrains.kotlin.cfg.LeakingThisDescriptor.NonFinalProperty[ClassConstructorDescriptorImpl]

'descriptor' @ [74:109] ==> val descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeReferenceUsage[LocalVariableDescriptor]

'classOrObject' @ [74:121] ==> private final val classOrObject: KtClassOrObject defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'descriptor' @ [77:17] ==> val descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeReferenceUsage[LocalVariableDescriptor]

'containingDeclaration' @ [77:28] ==> public final val PropertyDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'classDescriptor' @ [77:53] ==> private final val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'if (insideLValue(reference)) descriptor.setter?.isDefault != false else descriptor.getter?.isDefault != false' @ [78:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Boolean, elseBranch: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Boolean

'insideLValue' @ [78:24] ==> private final fun insideLValue(reference: KtReferenceExpression): Boolean defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[SimpleFunctionDescriptorImpl]

'reference' @ [78:37] ==> value-parameter reference: KtReferenceExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeReferenceUsage[ValueParameterDescriptorImpl]

'descriptor' @ [78:49] ==> val descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeReferenceUsage[LocalVariableDescriptor]

'setter' @ [78:60] ==> public abstract val setter: PropertySetterDescriptor? defined in org.jetbrains.kotlin.descriptors.PropertyDescriptor[JavaPropertyDescriptor]

'isDefault' @ [78:68] ==> public final val PropertySetterDescriptor.isDefault: Boolean[MyPropertyDescriptor]

'descriptor' @ [78:92] ==> val descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeReferenceUsage[LocalVariableDescriptor]

'getter' @ [78:103] ==> public abstract val getter: PropertyGetterDescriptor? defined in org.jetbrains.kotlin.descriptors.PropertyDescriptor[JavaPropertyDescriptor]

'isDefault' @ [78:111] ==> public final val PropertyGetterDescriptor.isDefault: Boolean[MyPropertyDescriptor]

'trace' @ [84:35] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'get' @ [84:41] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(slice: (ReadOnlySlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?), key: (KtReferenceExpression..KtReferenceExpression?)): DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtReferenceExpression..org.jetbrains.kotlin.psi.KtReferenceExpression?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.descriptors.DeclarationDescriptor..org.jetbrains.kotlin.descriptors.DeclarationDescriptor?)

'REFERENCE_TARGET' @ [84:60] ==> public final val REFERENCE_TARGET: (WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'expression' @ [84:78] ==> value-parameter expression: KtThisExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeThisUsage[ValueParameterDescriptorImpl]

'instanceReference' @ [84:89] ==> public final val KtThisExpression.instanceReference: KtReferenceExpression[MyPropertyDescriptor]

'referenceDescriptor' @ [85:13] ==> val referenceDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeThisUsage[LocalVariableDescriptor]

'classDescriptor' @ [85:36] ==> private final val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'expression' @ [86:22] ==> value-parameter expression: KtThisExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeThisUsage[ValueParameterDescriptorImpl]

'parent' @ [86:33] ==> public final val KtThisExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'when (parent) {
            is KtQualifiedExpression -> (parent.selectorExpression as? KtSimpleNameExpression)?.let { safeReferenceUsage(it) } ?: false
            is KtBinaryExpression -> OperatorConventions.IDENTITY_EQUALS_OPERATIONS.contains(parent.operationToken)
            else -> false
        }' @ [87:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean, entry2: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'parent' @ [87:22] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeThisUsage[LocalVariableDescriptor]

'?:' @ [88:41] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: Boolean?, right: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> Boolean

'parent' @ [88:42] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeThisUsage[LocalVariableDescriptor]

'selectorExpression' @ [88:49] ==> public open val selectorExpression: KtExpression? defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[PropertyDescriptorImpl]

'let' @ [88:97] ==> @InlineOnly public inline fun <T, R> KtSimpleNameExpression.let(block: (KtSimpleNameExpression) -> Boolean): Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtSimpleNameExpression
    <R> -> Boolean

'safeReferenceUsage' @ [88:103] ==> private final fun safeReferenceUsage(reference: KtReferenceExpression): Boolean defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[SimpleFunctionDescriptorImpl]

'it' @ [88:122] ==> value-parameter it: KtSimpleNameExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeThisUsage.<anonymous>[ValueParameterDescriptorImpl]

'IDENTITY_EQUALS_OPERATIONS' @ [89:58] ==> public final val IDENTITY_EQUALS_OPERATIONS: (ImmutableSet<(KtSingleValueToken..KtSingleValueToken?)>..ImmutableSet<(KtSingleValueToken..KtSingleValueToken?)>?) defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaPropertyDescriptor]

'contains' @ [89:85] ==> public operator fun <@OnlyInputTypes T> Iterable<(IElementType..IElementType?)>.contains(element: (IElementType..IElementType?)): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <@OnlyInputTypes T> -> (com.intellij.psi.tree.IElementType..com.intellij.psi.tree.IElementType?)

'parent' @ [89:94] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeThisUsage[LocalVariableDescriptor]

'operationToken' @ [89:101] ==> public final val KtBinaryExpression.operationToken: IElementType[MyPropertyDescriptor]

'expression' @ [95:22] ==> value-parameter expression: KtCallExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeCallUsage[ValueParameterDescriptorImpl]

'calleeExpression' @ [95:33] ==> public final val KtCallExpression.calleeExpression: KtExpression?[MyPropertyDescriptor]

'callee' @ [96:13] ==> val callee: KtExpression? defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeCallUsage[LocalVariableDescriptor]

'trace' @ [97:30] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'get' @ [97:36] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(slice: (ReadOnlySlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?), key: (KtReferenceExpression..KtReferenceExpression?)): DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtReferenceExpression..org.jetbrains.kotlin.psi.KtReferenceExpression?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.descriptors.DeclarationDescriptor..org.jetbrains.kotlin.descriptors.DeclarationDescriptor?)

'REFERENCE_TARGET' @ [97:55] ==> public final val REFERENCE_TARGET: (WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'callee' @ [97:73] ==> val callee: KtExpression? defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeCallUsage[LocalVariableDescriptor]

'descriptor' @ [98:17] ==> val descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeCallUsage[LocalVariableDescriptor]

'descriptor' @ [99:44] ==> val descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeCallUsage[LocalVariableDescriptor]

'containingDeclaration' @ [99:55] ==> public final val FunctionDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'containingDescriptor' @ [100:21] ==> val containingDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeCallUsage[LocalVariableDescriptor]

'classDescriptor' @ [100:45] ==> private final val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'!' @ [101:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'finalClass' @ [101:22] ==> private final val finalClass: Boolean defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'descriptor' @ [101:36] ==> val descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeCallUsage[LocalVariableDescriptor]

'isOverridable' @ [101:47] ==> public val CallableMemberDescriptor.isOverridable: Boolean defined in org.jetbrains.kotlin.descriptors[DeserializedPropertyDescriptor]

'trace' @ [102:21] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'record' @ [102:27] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(KtExpression..KtExpression?), (LeakingThisDescriptor..LeakingThisDescriptor?)>..WritableSlice<(KtExpression..KtExpression?), (LeakingThisDescriptor..LeakingThisDescriptor?)>?), key: (KtExpression..KtExpression?), value: (LeakingThisDescriptor..LeakingThisDescriptor?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.cfg.LeakingThisDescriptor..org.jetbrains.kotlin.cfg.LeakingThisDescriptor?)

'LEAKING_THIS' @ [102:49] ==> public final val LEAKING_THIS: (WritableSlice<(KtExpression..KtExpression?), (LeakingThisDescriptor..LeakingThisDescriptor?)>..WritableSlice<(KtExpression..KtExpression?), (LeakingThisDescriptor..LeakingThisDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'callee' @ [102:63] ==> val callee: KtExpression? defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeCallUsage[LocalVariableDescriptor]

'NonFinalFunction' @ [102:93] ==> public constructor NonFinalFunction(function: FunctionDescriptor, classOrObject: KtClassOrObject) defined in org.jetbrains.kotlin.cfg.LeakingThisDescriptor.NonFinalFunction[ClassConstructorDescriptorImpl]

'descriptor' @ [102:110] ==> val descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.safeCallUsage[LocalVariableDescriptor]

'classOrObject' @ [102:122] ==> private final val classOrObject: KtClassOrObject defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'variablesData' @ [112:35] ==> private final val variablesData: PseudocodeVariablesData defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'getDeclaredVariables' @ [112:49] ==> public final fun getDeclaredVariables(pseudocode: Pseudocode, includeInsideLocalDeclarations: Boolean): Set<VariableDescriptor> defined in org.jetbrains.kotlin.cfg.PseudocodeVariablesData[SimpleFunctionDescriptorImpl]

'pseudocode' @ [112:70] ==> private final val pseudocode: Pseudocode defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'filterIsInstance' @ [113:18] ==> public inline fun <reified R> Iterable<*>.filterIsInstance(): List<PropertyDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified R> -> PropertyDescriptor

'filter' @ [114:18] ==> public inline fun <T> Iterable<PropertyDescriptor>.filter(predicate: (PropertyDescriptor) -> Boolean): List<PropertyDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PropertyDescriptor

'trace' @ [114:27] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'get' @ [114:33] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(slice: (ReadOnlySlice<(PropertyDescriptor..PropertyDescriptor?), (Boolean..Boolean?)>..ReadOnlySlice<(PropertyDescriptor..PropertyDescriptor?), (Boolean..Boolean?)>?), key: (PropertyDescriptor..PropertyDescriptor?)): Boolean? defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.descriptors.PropertyDescriptor..org.jetbrains.kotlin.descriptors.PropertyDescriptor?)
    <V : (Any..Any?)> -> (kotlin.Boolean..kotlin.Boolean?)

'BACKING_FIELD_REQUIRED' @ [114:52] ==> public final val BACKING_FIELD_REQUIRED: (WritableSlice<(PropertyDescriptor..PropertyDescriptor?), (Boolean..Boolean?)>..WritableSlice<(PropertyDescriptor..PropertyDescriptor?), (Boolean..Boolean?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'it' @ [114:76] ==> value-parameter it: PropertyDescriptor defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>[ValueParameterDescriptorImpl]

'pseudocode' @ [115:9] ==> private final val pseudocode: Pseudocode defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'traverse' @ [115:20] ==> public fun <D> Pseudocode.traverse(traversalOrder: TraversalOrder, edgesMap: Map<Instruction, Edges<InitControlFlowInfo>>, analyzeInstruction: (Instruction, InitControlFlowInfo, InitControlFlowInfo) -> Unit): Unit defined in org.jetbrains.kotlin.cfg.pseudocodeTraverser[SimpleFunctionDescriptorImpl]
Inferred types:
    <D> -> InitControlFlowInfo

'FORWARD' @ [116:32] ==> enum entry FORWARD defined in org.jetbrains.kotlin.cfg.pseudocodeTraverser.TraversalOrder[FakeCallableDescriptorForObject]

'variablesData' @ [116:41] ==> private final val variablesData: PseudocodeVariablesData defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'variableInitializers' @ [116:55] ==> public final val variableInitializers: Map<Instruction, Edges<InitControlFlowInfo>> defined in org.jetbrains.kotlin.cfg.PseudocodeVariablesData[PropertyDescriptorImpl]

'propertyDescriptors' @ [118:55] ==> val propertyDescriptors: List<PropertyDescriptor> defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check[LocalVariableDescriptor]

'firstOrNull' @ [118:75] ==> public inline fun <T> Iterable<PropertyDescriptor>.firstOrNull(predicate: (PropertyDescriptor) -> Boolean): PropertyDescriptor? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PropertyDescriptor

'!' @ [119:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'it' @ [119:18] ==> value-parameter it: PropertyDescriptor defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>.firstUninitializedNotNullProperty.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [119:21] ==> public final val PropertyDescriptor.type: KotlinType[MyPropertyDescriptor]

'isMarkedNullable' @ [119:26] ==> public abstract val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'!' @ [119:46] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isPrimitiveType' @ [119:62] ==> public open fun isPrimitiveType(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'it' @ [119:78] ==> value-parameter it: PropertyDescriptor defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>.firstUninitializedNotNullProperty.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [119:81] ==> public final val PropertyDescriptor.type: KotlinType[MyPropertyDescriptor]

'!' @ [120:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'it' @ [120:18] ==> value-parameter it: PropertyDescriptor defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>.firstUninitializedNotNullProperty.<anonymous>[ValueParameterDescriptorImpl]

'isLateInit' @ [120:21] ==> public final val PropertyDescriptor.isLateInit: Boolean[MyPropertyDescriptor]

'!' @ [120:35] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'enterData' @ [120:37] ==> value-parameter enterData: InitControlFlowInfo defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>[ValueParameterDescriptorImpl]

'getOrNull' @ [120:47] ==> public fun <K, V> ImmutableMap<VariableDescriptor, VariableControlFlowState> /* = Map<VariableDescriptor, VariableControlFlowState> */.getOrNull(k: VariableDescriptor): VariableControlFlowState? defined in org.jetbrains.kotlin.cfg[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> VariableDescriptor
    <V> -> VariableControlFlowState

'it' @ [120:57] ==> value-parameter it: PropertyDescriptor defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>.firstUninitializedNotNullProperty.<anonymous>[ValueParameterDescriptorImpl]

'definitelyInitialized' @ [120:62] ==> public final fun definitelyInitialized(): Boolean defined in org.jetbrains.kotlin.cfg.VariableControlFlowState[SimpleFunctionDescriptorImpl]

'if (!finalClass) {
                    trace.record(BindingContext.LEAKING_THIS, target(expression),
                                 LeakingThisDescriptor.NonFinalClass(classDescriptor, classOrObject))
                }
                else {
                    val uninitializedProperty = firstUninitializedNotNullProperty()
                    if (uninitializedProperty != null) {
                        trace.record(BindingContext.LEAKING_THIS, target(expression),
                                     LeakingThisDescriptor.PropertyIsNull(uninitializedProperty, classOrObject))
                    }
                }' @ [124:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'!' @ [124:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'finalClass' @ [124:22] ==> private final val finalClass: Boolean defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'trace' @ [125:21] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'record' @ [125:27] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(KtExpression..KtExpression?), (LeakingThisDescriptor..LeakingThisDescriptor?)>..WritableSlice<(KtExpression..KtExpression?), (LeakingThisDescriptor..LeakingThisDescriptor?)>?), key: (KtExpression..KtExpression?), value: (LeakingThisDescriptor..LeakingThisDescriptor?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.cfg.LeakingThisDescriptor..org.jetbrains.kotlin.cfg.LeakingThisDescriptor?)

'LEAKING_THIS' @ [125:49] ==> public final val LEAKING_THIS: (WritableSlice<(KtExpression..KtExpression?), (LeakingThisDescriptor..LeakingThisDescriptor?)>..WritableSlice<(KtExpression..KtExpression?), (LeakingThisDescriptor..LeakingThisDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'target' @ [125:63] ==> private final fun target(expression: KtExpression): KtExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion[SimpleFunctionDescriptorImpl]

'expression' @ [125:70] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>.handleLeakingThis[ValueParameterDescriptorImpl]

'NonFinalClass' @ [126:56] ==> public constructor NonFinalClass(klass: ClassDescriptor, classOrObject: KtClassOrObject) defined in org.jetbrains.kotlin.cfg.LeakingThisDescriptor.NonFinalClass[ClassConstructorDescriptorImpl]

'classDescriptor' @ [126:70] ==> private final val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'classOrObject' @ [126:87] ==> private final val classOrObject: KtClassOrObject defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'firstUninitializedNotNullProperty' @ [129:49] ==> local final fun firstUninitializedNotNullProperty(): PropertyDescriptor? defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>[SimpleFunctionDescriptorImpl]

'uninitializedProperty' @ [130:25] ==> val uninitializedProperty: PropertyDescriptor? defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>.handleLeakingThis[LocalVariableDescriptor]

'trace' @ [131:25] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'record' @ [131:31] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(KtExpression..KtExpression?), (LeakingThisDescriptor..LeakingThisDescriptor?)>..WritableSlice<(KtExpression..KtExpression?), (LeakingThisDescriptor..LeakingThisDescriptor?)>?), key: (KtExpression..KtExpression?), value: (LeakingThisDescriptor..LeakingThisDescriptor?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.cfg.LeakingThisDescriptor..org.jetbrains.kotlin.cfg.LeakingThisDescriptor?)

'LEAKING_THIS' @ [131:53] ==> public final val LEAKING_THIS: (WritableSlice<(KtExpression..KtExpression?), (LeakingThisDescriptor..LeakingThisDescriptor?)>..WritableSlice<(KtExpression..KtExpression?), (LeakingThisDescriptor..LeakingThisDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'target' @ [131:67] ==> private final fun target(expression: KtExpression): KtExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion[SimpleFunctionDescriptorImpl]

'expression' @ [131:74] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>.handleLeakingThis[ValueParameterDescriptorImpl]

'PropertyIsNull' @ [132:60] ==> public constructor PropertyIsNull(property: PropertyDescriptor, classOrObject: KtClassOrObject) defined in org.jetbrains.kotlin.cfg.LeakingThisDescriptor.PropertyIsNull[ClassConstructorDescriptorImpl]

'uninitializedProperty' @ [132:75] ==> val uninitializedProperty: PropertyDescriptor? defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>.handleLeakingThis[LocalVariableDescriptor]

'classOrObject' @ [132:98] ==> private final val classOrObject: KtClassOrObject defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'instruction' @ [137:17] ==> value-parameter instruction: Instruction defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>[ValueParameterDescriptorImpl]

'owner' @ [137:29] ==> public abstract var owner: Pseudocode defined in org.jetbrains.kotlin.cfg.pseudocode.instructions.Instruction[PropertyDescriptorImpl]

'pseudocode' @ [137:38] ==> private final val pseudocode: Pseudocode defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[PropertyDescriptorImpl]

'instruction' @ [141:17] ==> value-parameter instruction: Instruction defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>[ValueParameterDescriptorImpl]

'instruction' @ [142:31] ==> value-parameter instruction: Instruction defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>[ValueParameterDescriptorImpl]

'element' @ [142:43] ==> public abstract val element: KtElement defined in org.jetbrains.kotlin.cfg.pseudocode.instructions.KtElementInstruction[PropertyDescriptorImpl]

'when (instruction) {
                    is ReadValueInstruction ->
                        if (element is KtThisExpression) {
                            if (!safeThisUsage(element)) {
                                handleLeakingThis(element)
                            }
                        }
                    is MagicInstruction ->
                        if (instruction.kind == MagicKind.IMPLICIT_RECEIVER) {
                            if (element is KtCallExpression) {
                                if (!safeCallUsage(element)) {
                                    handleLeakingThis(element)
                                }
                            }
                            else if (element is KtReferenceExpression) {
                                if (!safeReferenceUsage(element)) {
                                    handleLeakingThis(element)
                                }
                            }
                        }
                }' @ [143:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'instruction' @ [143:23] ==> value-parameter instruction: Instruction defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>[ValueParameterDescriptorImpl]

'element' @ [145:29] ==> val element: KtElement defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>[LocalVariableDescriptor]

'!' @ [146:33] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'safeThisUsage' @ [146:34] ==> private final fun safeThisUsage(expression: KtThisExpression): Boolean defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[SimpleFunctionDescriptorImpl]

'element' @ [146:48] ==> val element: KtElement defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>[LocalVariableDescriptor]

'handleLeakingThis' @ [147:33] ==> local final fun handleLeakingThis(expression: KtExpression): Unit defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>[SimpleFunctionDescriptorImpl]

'element' @ [147:51] ==> val element: KtElement defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>[LocalVariableDescriptor]

'instruction' @ [151:29] ==> value-parameter instruction: Instruction defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>[ValueParameterDescriptorImpl]

'kind' @ [151:41] ==> public final val kind: MagicKind defined in org.jetbrains.kotlin.cfg.pseudocode.instructions.eval.MagicInstruction[PropertyDescriptorImpl]

'IMPLICIT_RECEIVER' @ [151:59] ==> enum entry IMPLICIT_RECEIVER defined in org.jetbrains.kotlin.cfg.pseudocode.instructions.eval.MagicKind[FakeCallableDescriptorForObject]

'if (element is KtCallExpression) {
                                if (!safeCallUsage(element)) {
                                    handleLeakingThis(element)
                                }
                            }
                            else if (element is KtReferenceExpression) {
                                if (!safeReferenceUsage(element)) {
                                    handleLeakingThis(element)
                                }
                            }' @ [152:29] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'element' @ [152:33] ==> val element: KtElement defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>[LocalVariableDescriptor]

'!' @ [153:37] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'safeCallUsage' @ [153:38] ==> private final fun safeCallUsage(expression: KtCallExpression): Boolean defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[SimpleFunctionDescriptorImpl]

'element' @ [153:52] ==> val element: KtElement defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>[LocalVariableDescriptor]

'handleLeakingThis' @ [154:37] ==> local final fun handleLeakingThis(expression: KtExpression): Unit defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>[SimpleFunctionDescriptorImpl]

'element' @ [154:55] ==> val element: KtElement defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>[LocalVariableDescriptor]

'element' @ [157:38] ==> val element: KtElement defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>[LocalVariableDescriptor]

'!' @ [158:37] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'safeReferenceUsage' @ [158:38] ==> private final fun safeReferenceUsage(reference: KtReferenceExpression): Boolean defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[SimpleFunctionDescriptorImpl]

'element' @ [158:57] ==> val element: KtElement defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>[LocalVariableDescriptor]

'handleLeakingThis' @ [159:37] ==> local final fun handleLeakingThis(expression: KtExpression): Unit defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>[SimpleFunctionDescriptorImpl]

'element' @ [159:55] ==> val element: KtElement defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.check.<anonymous>[LocalVariableDescriptor]

'JvmStatic' @ [170:9] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'check' @ [176:13] ==> @JvmStatic public final fun check(classOrObject: KtClassOrObject, trace: BindingTrace, pseudocode: Pseudocode, pseudocodeVariablesData: PseudocodeVariablesData): Unit defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion[SimpleFunctionDescriptorImpl]

'constructor' @ [176:19] ==> value-parameter constructor: KtSecondaryConstructor defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.check[ValueParameterDescriptorImpl]

'getContainingClassOrObject' @ [176:31] ==> public open fun getContainingClassOrObject(): KtClassOrObject defined in org.jetbrains.kotlin.psi.KtSecondaryConstructor[SimpleFunctionDescriptorImpl]

'trace' @ [176:61] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.check[ValueParameterDescriptorImpl]

'pseudocode' @ [176:68] ==> value-parameter pseudocode: Pseudocode defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.check[ValueParameterDescriptorImpl]

'pseudocodeVariablesData' @ [176:80] ==> value-parameter pseudocodeVariablesData: PseudocodeVariablesData defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.check[ValueParameterDescriptorImpl]

'JvmStatic' @ [178:9] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'trace' @ [185:35] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.check[ValueParameterDescriptorImpl]

'get' @ [185:41] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(slice: (ReadOnlySlice<(PsiElement..PsiElement?), (ClassDescriptor..ClassDescriptor?)>..ReadOnlySlice<(PsiElement..PsiElement?), (ClassDescriptor..ClassDescriptor?)>?), key: (PsiElement..PsiElement?)): ClassDescriptor? defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.descriptors.ClassDescriptor..org.jetbrains.kotlin.descriptors.ClassDescriptor?)

'CLASS' @ [185:60] ==> public final val CLASS: (WritableSlice<(PsiElement..PsiElement?), (ClassDescriptor..ClassDescriptor?)>..WritableSlice<(PsiElement..PsiElement?), (ClassDescriptor..ClassDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'classOrObject' @ [185:67] ==> value-parameter classOrObject: KtClassOrObject defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.check[ValueParameterDescriptorImpl]

'ConstructorConsistencyChecker' @ [186:13] ==> private constructor ConstructorConsistencyChecker(classOrObject: KtClassOrObject, classDescriptor: ClassDescriptor, trace: BindingTrace, pseudocode: Pseudocode, variablesData: PseudocodeVariablesData) defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[ClassConstructorDescriptorImpl]

'classOrObject' @ [186:43] ==> value-parameter classOrObject: KtClassOrObject defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.check[ValueParameterDescriptorImpl]

'classDescriptor' @ [186:58] ==> val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.check[LocalVariableDescriptor]

'trace' @ [186:75] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.check[ValueParameterDescriptorImpl]

'pseudocode' @ [186:82] ==> value-parameter pseudocode: Pseudocode defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.check[ValueParameterDescriptorImpl]

'pseudocodeVariablesData' @ [186:94] ==> value-parameter pseudocodeVariablesData: PseudocodeVariablesData defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.check[ValueParameterDescriptorImpl]

'check' @ [186:119] ==> public final fun check(): Unit defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker[SimpleFunctionDescriptorImpl]

'when (expression) {
            is KtThisExpression -> {
                val selectorOrThis = (expression.parent as? KtQualifiedExpression)?.let {
                    if (it.receiverExpression === expression) it.selectorExpression else null
                } ?: expression
                if (selectorOrThis === expression) selectorOrThis else target(selectorOrThis)
            }
            is KtCallExpression -> expression.let { it.calleeExpression ?: it }
            else -> expression
        }' @ [189:70] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KtExpression, entry1: KtExpression, entry2: KtExpression): KtExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KtExpression

'expression' @ [189:76] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.target[ValueParameterDescriptorImpl]

'?:' @ [191:38] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtExpression?, right: KtExpression): KtExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtExpression

'expression' @ [191:39] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.target[ValueParameterDescriptorImpl]

'parent' @ [191:50] ==> public final val KtThisExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'let' @ [191:85] ==> @InlineOnly public inline fun <T, R> KtQualifiedExpression.let(block: (KtQualifiedExpression) -> KtExpression?): KtExpression? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtQualifiedExpression
    <R> -> KtExpression?

'if (it.receiverExpression === expression) it.selectorExpression else null' @ [192:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtExpression?, elseBranch: KtExpression?): KtExpression?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtExpression?

'it' @ [192:25] ==> value-parameter it: KtQualifiedExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.target.<anonymous>[ValueParameterDescriptorImpl]

'receiverExpression' @ [192:28] ==> public open val receiverExpression: KtExpression defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[PropertyDescriptorImpl]

'expression' @ [192:51] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.target[ValueParameterDescriptorImpl]

'it' @ [192:63] ==> value-parameter it: KtQualifiedExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.target.<anonymous>[ValueParameterDescriptorImpl]

'selectorExpression' @ [192:66] ==> public open val selectorExpression: KtExpression? defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[PropertyDescriptorImpl]

'expression' @ [193:22] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.target[ValueParameterDescriptorImpl]

'if (selectorOrThis === expression) selectorOrThis else target(selectorOrThis)' @ [194:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtExpression, elseBranch: KtExpression): KtExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtExpression

'selectorOrThis' @ [194:21] ==> val selectorOrThis: KtExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.target[LocalVariableDescriptor]

'expression' @ [194:40] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.target[ValueParameterDescriptorImpl]

'selectorOrThis' @ [194:52] ==> val selectorOrThis: KtExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.target[LocalVariableDescriptor]

'target' @ [194:72] ==> private final fun target(expression: KtExpression): KtExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion[SimpleFunctionDescriptorImpl]

'selectorOrThis' @ [194:79] ==> val selectorOrThis: KtExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.target[LocalVariableDescriptor]

'expression' @ [196:36] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.target[ValueParameterDescriptorImpl]

'let' @ [196:47] ==> @InlineOnly public inline fun <T, R> KtCallExpression.let(block: (KtCallExpression) -> KtExpression): KtExpression defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtCallExpression
    <R> -> KtExpression

'it' @ [196:53] ==> value-parameter it: KtCallExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.target.<anonymous>[ValueParameterDescriptorImpl]

'calleeExpression' @ [196:56] ==> public final val KtCallExpression.calleeExpression: KtExpression?[MyPropertyDescriptor]

'it' @ [196:76] ==> value-parameter it: KtCallExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.target.<anonymous>[ValueParameterDescriptorImpl]

'expression' @ [197:21] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.cfg.ConstructorConsistencyChecker.Companion.target[ValueParameterDescriptorImpl]

