'resolvedCall' @ [31:34] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.calls.checkers.InfixCallChecker.check[ValueParameterDescriptorImpl]

'resultingDescriptor' @ [31:47] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.resultingDescriptor: (CallableDescriptor..CallableDescriptor?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(*)

'functionDescriptor' @ [32:13] ==> val functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InfixCallChecker.check[LocalVariableDescriptor]

'isInfix' @ [32:32] ==> public final val FunctionDescriptor.isInfix: Boolean[MyPropertyDescriptor]

'functionDescriptor' @ [32:43] ==> val functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InfixCallChecker.check[LocalVariableDescriptor]

'isDynamic' @ [32:62] ==> public fun DeclarationDescriptor.isDynamic(): Boolean defined in org.jetbrains.kotlin.resolve.calls.tasks in file dynamicCalls.kt[SimpleFunctionDescriptorImpl]

'isError' @ [32:88] ==> public open fun isError(@Nullable p0: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.types.ErrorUtils[JavaMethodDescriptor]

'functionDescriptor' @ [32:96] ==> val functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InfixCallChecker.check[LocalVariableDescriptor]

'?:' @ [33:21] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>?, right: ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>): ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> ResolvedCall<out (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)>

'resolvedCall' @ [33:22] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.calls.checkers.InfixCallChecker.check[ValueParameterDescriptorImpl]

'variableCall' @ [33:72] ==> public abstract val variableCall: ResolvedCall<VariableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.model.VariableAsFunctionResolvedCall[PropertyDescriptorImpl]

'resolvedCall' @ [33:88] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.calls.checkers.InfixCallChecker.check[ValueParameterDescriptorImpl]

'call' @ [33:102] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?))

'isInfixCall' @ [34:13] ==> public fun isInfixCall(call: Call): Boolean defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil in file CallResolverUtil.kt[SimpleFunctionDescriptorImpl]

'call' @ [34:25] ==> val call: Call defined in org.jetbrains.kotlin.resolve.calls.checkers.InfixCallChecker.check[LocalVariableDescriptor]

'functionDescriptor' @ [35:45] ==> val functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InfixCallChecker.check[LocalVariableDescriptor]

'containingDeclaration' @ [35:64] ==> public final val FunctionDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'fqNameUnsafe' @ [35:86] ==> public val DeclarationDescriptor.fqNameUnsafe: FqNameUnsafe defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'asString' @ [35:99] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqNameUnsafe[JavaMethodDescriptor]

'context' @ [36:13] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InfixCallChecker.check[ValueParameterDescriptorImpl]

'trace' @ [36:21] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[PropertyDescriptorImpl]

'report' @ [36:27] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'INFIX_MODIFIER_REQUIRED' @ [36:41] ==> public final val INFIX_MODIFIER_REQUIRED: (DiagnosticFactory2<(PsiElement..PsiElement?), (FunctionDescriptor..FunctionDescriptor?), (String..String?)>..DiagnosticFactory2<(PsiElement..PsiElement?), (FunctionDescriptor..FunctionDescriptor?), (String..String?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [36:65] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull a: FunctionDescriptor, @NotNull b: String): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'reportOn' @ [36:68] ==> value-parameter reportOn: PsiElement defined in org.jetbrains.kotlin.resolve.calls.checkers.InfixCallChecker.check[ValueParameterDescriptorImpl]

'functionDescriptor' @ [36:78] ==> val functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InfixCallChecker.check[LocalVariableDescriptor]

'containingDeclarationName' @ [36:98] ==> val containingDeclarationName: String defined in org.jetbrains.kotlin.resolve.calls.checkers.InfixCallChecker.check[LocalVariableDescriptor]

