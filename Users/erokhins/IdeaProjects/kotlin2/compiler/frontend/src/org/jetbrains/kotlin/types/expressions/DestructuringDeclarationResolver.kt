'arrayListOf' @ [50:22] ==> @SinceKotlin @InlineOnly public inline fun <T> arrayListOf(): ArrayList<VariableDescriptor> /* = ArrayList<VariableDescriptor> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> VariableDescriptor

'component1' @ [51:15] ==> public final operator fun component1(): Int defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'component2' @ [51:31] ==> public final operator fun component2(): (KtDestructuringDeclarationEntry..KtDestructuringDeclarationEntry?) defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'destructuringDeclaration' @ [51:41] ==> value-parameter destructuringDeclaration: KtDestructuringDeclaration defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveLocalVariablesFromDestructuringDeclaration[ValueParameterDescriptorImpl]

'entries' @ [51:66] ==> public final val KtDestructuringDeclaration.entries: (MutableList<(KtDestructuringDeclarationEntry..KtDestructuringDeclarationEntry?)>..List<(KtDestructuringDeclarationEntry..KtDestructuringDeclarationEntry?)>)[MyPropertyDescriptor]

'withIndex' @ [51:74] ==> public fun <T> Iterable<(KtDestructuringDeclarationEntry..KtDestructuringDeclarationEntry?)>.withIndex(): Iterable<IndexedValue<(KtDestructuringDeclarationEntry..KtDestructuringDeclarationEntry?)>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtDestructuringDeclarationEntry..org.jetbrains.kotlin.psi.KtDestructuringDeclarationEntry?)

'resolveInitializer' @ [52:33] ==> public final fun resolveInitializer(entry: KtDestructuringDeclarationEntry, receiver: ReceiverValue?, initializer: KtExpression?, context: ExpressionTypingContext, componentIndex: Int): KotlinType defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver[SimpleFunctionDescriptorImpl]

'entry' @ [52:52] ==> val entry: (KtDestructuringDeclarationEntry..KtDestructuringDeclarationEntry?) defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveLocalVariablesFromDestructuringDeclaration[LocalVariableDescriptor]

'receiver' @ [52:59] ==> value-parameter receiver: ReceiverValue? defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveLocalVariablesFromDestructuringDeclaration[ValueParameterDescriptorImpl]

'initializer' @ [52:69] ==> value-parameter initializer: KtExpression? defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveLocalVariablesFromDestructuringDeclaration[ValueParameterDescriptorImpl]

'context' @ [52:82] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveLocalVariablesFromDestructuringDeclaration[ValueParameterDescriptorImpl]

'componentIndex' @ [52:91] ==> val componentIndex: Int defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveLocalVariablesFromDestructuringDeclaration[LocalVariableDescriptor]

'localVariableResolver' @ [53:38] ==> private final val localVariableResolver: LocalVariableResolver defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver[PropertyDescriptorImpl]

'resolveLocalVariableDescriptorWithType' @ [53:60] ==> internal final fun resolveLocalVariableDescriptorWithType(scope: LexicalScope, variable: KtVariableDeclaration, type: KotlinType?, trace: BindingTrace): LocalVariableDescriptor defined in org.jetbrains.kotlin.resolve.LocalVariableResolver[SimpleFunctionDescriptorImpl]

'scope' @ [53:99] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveLocalVariablesFromDestructuringDeclaration[ValueParameterDescriptorImpl]

'entry' @ [53:106] ==> val entry: (KtDestructuringDeclarationEntry..KtDestructuringDeclarationEntry?) defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveLocalVariablesFromDestructuringDeclaration[LocalVariableDescriptor]

'componentType' @ [53:113] ==> val componentType: KotlinType defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveLocalVariablesFromDestructuringDeclaration[LocalVariableDescriptor]

'context' @ [53:128] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveLocalVariablesFromDestructuringDeclaration[ValueParameterDescriptorImpl]

'trace' @ [53:136] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'result' @ [55:13] ==> val result: ArrayList<VariableDescriptor> /* = ArrayList<VariableDescriptor> */ defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveLocalVariablesFromDestructuringDeclaration[LocalVariableDescriptor]

'add' @ [55:20] ==> public open fun add(element: VariableDescriptor): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'variableDescriptor' @ [55:24] ==> val variableDescriptor: LocalVariableDescriptor defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveLocalVariablesFromDestructuringDeclaration[LocalVariableDescriptor]

'result' @ [58:16] ==> val result: ArrayList<VariableDescriptor> /* = ArrayList<VariableDescriptor> */ defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveLocalVariablesFromDestructuringDeclaration[LocalVariableDescriptor]

'resolveLocalVariablesFromDestructuringDeclaration' @ [67:9] ==> public final fun resolveLocalVariablesFromDestructuringDeclaration(scope: LexicalScope, destructuringDeclaration: KtDestructuringDeclaration, receiver: ReceiverValue?, initializer: KtExpression?, context: ExpressionTypingContext): List<VariableDescriptor> defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver[SimpleFunctionDescriptorImpl]

'writableScope' @ [68:13] ==> value-parameter writableScope: LexicalWritableScope defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.defineLocalVariablesFromDestructuringDeclaration[ValueParameterDescriptorImpl]

'destructuringDeclaration' @ [68:28] ==> value-parameter destructuringDeclaration: KtDestructuringDeclaration defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.defineLocalVariablesFromDestructuringDeclaration[ValueParameterDescriptorImpl]

'receiver' @ [68:54] ==> value-parameter receiver: ReceiverValue? defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.defineLocalVariablesFromDestructuringDeclaration[ValueParameterDescriptorImpl]

'initializer' @ [68:64] ==> value-parameter initializer: KtExpression? defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.defineLocalVariablesFromDestructuringDeclaration[ValueParameterDescriptorImpl]

'context' @ [68:77] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.defineLocalVariablesFromDestructuringDeclaration[ValueParameterDescriptorImpl]

'forEach' @ [69:7] ==> @HidesMembers public inline fun <T> Iterable<VariableDescriptor>.forEach(action: (VariableDescriptor) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> VariableDescriptor

'checkVariableShadowing' @ [70:31] ==> public open fun checkVariableShadowing(@NotNull scope: LexicalScope, @NotNull trace: BindingTrace, @NotNull variableDescriptor: VariableDescriptor): Unit defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingUtils[JavaMethodDescriptor]

'writableScope' @ [70:54] ==> value-parameter writableScope: LexicalWritableScope defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.defineLocalVariablesFromDestructuringDeclaration[ValueParameterDescriptorImpl]

'context' @ [70:69] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.defineLocalVariablesFromDestructuringDeclaration[ValueParameterDescriptorImpl]

'trace' @ [70:77] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'it' @ [70:84] ==> value-parameter it: VariableDescriptor defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.defineLocalVariablesFromDestructuringDeclaration.<anonymous>[ValueParameterDescriptorImpl]

'writableScope' @ [71:9] ==> value-parameter writableScope: LexicalWritableScope defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.defineLocalVariablesFromDestructuringDeclaration[ValueParameterDescriptorImpl]

'addVariableDescriptor' @ [71:23] ==> public final fun addVariableDescriptor(variableDescriptor: VariableDescriptor): Unit defined in org.jetbrains.kotlin.resolve.scopes.LexicalWritableScope[DeserializedSimpleFunctionDescriptor]

'it' @ [71:45] ==> value-parameter it: VariableDescriptor defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.defineLocalVariablesFromDestructuringDeclaration.<anonymous>[ValueParameterDescriptorImpl]

'DataClassDescriptorResolver' @ [81:29] ==> public object DataClassDescriptorResolver defined in org.jetbrains.kotlin.resolve in file DataClassDescriptorResolver.kt[FakeCallableDescriptorForObject]

'createComponentName' @ [81:57] ==> public final fun createComponentName(index: Int): Name defined in org.jetbrains.kotlin.resolve.DataClassDescriptorResolver[SimpleFunctionDescriptorImpl]

'componentIndex' @ [81:77] ==> value-parameter componentIndex: Int defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveInitializer[ValueParameterDescriptorImpl]

'resolveComponentFunctionAndGetType' @ [82:16] ==> private final fun resolveComponentFunctionAndGetType(componentName: Name, context: ExpressionTypingContext, entry: KtDestructuringDeclarationEntry, receiver: ReceiverValue?, initializer: KtExpression?): KotlinType defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver[SimpleFunctionDescriptorImpl]

'componentName' @ [82:51] ==> val componentName: Name defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveInitializer[LocalVariableDescriptor]

'context' @ [82:66] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveInitializer[ValueParameterDescriptorImpl]

'entry' @ [82:75] ==> value-parameter entry: KtDestructuringDeclarationEntry defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveInitializer[ValueParameterDescriptorImpl]

'receiver' @ [82:82] ==> value-parameter receiver: ReceiverValue? defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveInitializer[ValueParameterDescriptorImpl]

'initializer' @ [82:92] ==> value-parameter initializer: KtExpression? defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveInitializer[ValueParameterDescriptorImpl]

'createErrorType' @ [92:38] ==> @NotNull public open fun createErrorType(@NotNull p0: String): SimpleType defined in org.jetbrains.kotlin.types.ErrorUtils[JavaMethodDescriptor]

'componentName' @ [92:56] ==> value-parameter componentName: Name defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[ValueParameterDescriptorImpl]

'receiver' @ [94:13] ==> value-parameter receiver: ReceiverValue? defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[ValueParameterDescriptorImpl]

'errorType' @ [94:38] ==> local final fun errorType(): SimpleType defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[SimpleFunctionDescriptorImpl]

'getExpectedTypeForComponent' @ [96:28] ==> private final fun getExpectedTypeForComponent(context: ExpressionTypingContext, entry: KtDestructuringDeclarationEntry): KotlinType defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver[SimpleFunctionDescriptorImpl]

'context' @ [96:56] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[ValueParameterDescriptorImpl]

'entry' @ [96:65] ==> value-parameter entry: KtDestructuringDeclarationEntry defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[ValueParameterDescriptorImpl]

'context' @ [97:26] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[ValueParameterDescriptorImpl]

'replaceExpectedType' @ [97:34] ==> @NotNull public open fun replaceExpectedType(@Nullable newExpectedType: KotlinType?): ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaMethodDescriptor]

'expectedType' @ [97:54] ==> val expectedType: KotlinType defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[LocalVariableDescriptor]

'replaceContextDependency' @ [97:68] ==> @NotNull public open fun replaceContextDependency(@NotNull newContextDependency: ContextDependency): ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaMethodDescriptor]

'INDEPENDENT' @ [97:111] ==> enum entry INDEPENDENT defined in org.jetbrains.kotlin.resolve.calls.context.ContextDependency[FakeCallableDescriptorForObject]

'fakeCallResolver' @ [98:23] ==> private final val fakeCallResolver: FakeCallResolver defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver[PropertyDescriptorImpl]

'resolveFakeCall' @ [98:40] ==> public final fun resolveFakeCall(context: ResolutionContext<*>, receiver: ReceiverValue?, name: Name, callElement: KtExpression, reportErrorsOn: KtExpression, callKind: FakeCallKind, valueArguments: List<KtExpression>): OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.types.expressions.FakeCallResolver[SimpleFunctionDescriptorImpl]

'newContext' @ [99:17] ==> val newContext: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[LocalVariableDescriptor]

'receiver' @ [99:29] ==> value-parameter receiver: ReceiverValue? defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[ValueParameterDescriptorImpl]

'componentName' @ [99:39] ==> value-parameter componentName: Name defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[ValueParameterDescriptorImpl]

'entry' @ [100:17] ==> value-parameter entry: KtDestructuringDeclarationEntry defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[ValueParameterDescriptorImpl]

'initializer' @ [100:24] ==> value-parameter initializer: KtExpression? defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[ValueParameterDescriptorImpl]

'entry' @ [100:39] ==> value-parameter entry: KtDestructuringDeclarationEntry defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[ValueParameterDescriptorImpl]

'COMPONENT' @ [100:59] ==> enum entry COMPONENT defined in org.jetbrains.kotlin.types.expressions.FakeCallKind[FakeCallableDescriptorForObject]

'emptyList' @ [100:70] ==> public fun <T> emptyList(): List<KtExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'!' @ [103:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'results' @ [103:14] ==> val results: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[LocalVariableDescriptor]

'isSuccess' @ [103:22] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<FunctionDescriptor>.isSuccess: Boolean[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'errorType' @ [104:20] ==> local final fun errorType(): SimpleType defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[SimpleFunctionDescriptorImpl]

'context' @ [107:9] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[ValueParameterDescriptorImpl]

'trace' @ [107:17] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'record' @ [107:23] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(KtDestructuringDeclarationEntry..KtDestructuringDeclarationEntry?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>..WritableSlice<(KtDestructuringDeclarationEntry..KtDestructuringDeclarationEntry?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>?), key: (KtDestructuringDeclarationEntry..KtDestructuringDeclarationEntry?), value: (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtDestructuringDeclarationEntry..org.jetbrains.kotlin.psi.KtDestructuringDeclarationEntry?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedCall<(org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)>..org.jetbrains.kotlin.resolve.calls.model.ResolvedCall<(org.jetbrains.kotlin.descriptors.FunctionDescriptor..org.jetbrains.kotlin.descriptors.FunctionDescriptor?)>?)

'COMPONENT_RESOLVED_CALL' @ [107:45] ==> public final val COMPONENT_RESOLVED_CALL: (WritableSlice<(KtDestructuringDeclarationEntry..KtDestructuringDeclarationEntry?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>..WritableSlice<(KtDestructuringDeclarationEntry..KtDestructuringDeclarationEntry?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'entry' @ [107:70] ==> value-parameter entry: KtDestructuringDeclarationEntry defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[ValueParameterDescriptorImpl]

'results' @ [107:77] ==> val results: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[LocalVariableDescriptor]

'resultingCall' @ [107:85] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<FunctionDescriptor>.resultingCall: ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'results' @ [109:34] ==> val results: OverloadResolutionResults<FunctionDescriptor> defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[LocalVariableDescriptor]

'resultingDescriptor' @ [109:42] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> OverloadResolutionResults<FunctionDescriptor>.resultingDescriptor: FunctionDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> FunctionDescriptor

'returnType' @ [109:62] ==> public final val FunctionDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'functionReturnType' @ [110:13] ==> val functionReturnType: KotlinType? defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[LocalVariableDescriptor]

'!' @ [110:43] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'noExpectedType' @ [110:54] ==> public open fun noExpectedType(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'expectedType' @ [110:69] ==> val expectedType: KotlinType defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[LocalVariableDescriptor]

'!' @ [111:16] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'DEFAULT' @ [111:35] ==> public final val DEFAULT: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaPropertyDescriptor]

'isSubtypeOf' @ [111:43] ==> public abstract fun isSubtypeOf(@NotNull p0: KotlinType, @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaMethodDescriptor]

'functionReturnType' @ [111:55] ==> val functionReturnType: KotlinType? defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[LocalVariableDescriptor]

'expectedType' @ [111:75] ==> val expectedType: KotlinType defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[LocalVariableDescriptor]

'context' @ [112:13] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[ValueParameterDescriptorImpl]

'trace' @ [112:21] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'report' @ [112:27] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'COMPONENT_FUNCTION_RETURN_TYPE_MISMATCH' @ [113:28] ==> public final val COMPONENT_FUNCTION_RETURN_TYPE_MISMATCH: (DiagnosticFactory3<(KtExpression..KtExpression?), (Name..Name?), (KotlinType..KotlinType?), (KotlinType..KotlinType?)>..DiagnosticFactory3<(KtExpression..KtExpression?), (Name..Name?), (KotlinType..KotlinType?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [113:68] ==> @NotNull public open fun on(@NotNull element: KtExpression, @NotNull a: Name, @NotNull b: KotlinType, @NotNull c: KotlinType): ParametrizedDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory3[JavaMethodDescriptor]

'initializer' @ [114:29] ==> value-parameter initializer: KtExpression? defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[ValueParameterDescriptorImpl]

'entry' @ [114:44] ==> value-parameter entry: KtDestructuringDeclarationEntry defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[ValueParameterDescriptorImpl]

'componentName' @ [114:51] ==> value-parameter componentName: Name defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[ValueParameterDescriptorImpl]

'functionReturnType' @ [114:66] ==> val functionReturnType: KotlinType? defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[LocalVariableDescriptor]

'expectedType' @ [114:86] ==> val expectedType: KotlinType defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[LocalVariableDescriptor]

'functionReturnType' @ [116:16] ==> val functionReturnType: KotlinType? defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[LocalVariableDescriptor]

'errorType' @ [116:38] ==> local final fun errorType(): SimpleType defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.resolveComponentFunctionAndGetType[SimpleFunctionDescriptorImpl]

'entry' @ [120:28] ==> value-parameter entry: KtDestructuringDeclarationEntry defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.getExpectedTypeForComponent[ValueParameterDescriptorImpl]

'typeReference' @ [120:34] ==> public final var KtDestructuringDeclarationEntry.typeReference: KtTypeReference?[MyPropertyDescriptor]

'NO_EXPECTED_TYPE' @ [120:68] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'typeResolver' @ [121:16] ==> private final val typeResolver: TypeResolver defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver[PropertyDescriptorImpl]

'resolveType' @ [121:29] ==> public final fun resolveType(scope: LexicalScope, typeReference: KtTypeReference, trace: BindingTrace, checkBounds: Boolean): KotlinType defined in org.jetbrains.kotlin.resolve.TypeResolver[SimpleFunctionDescriptorImpl]

'context' @ [121:41] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.getExpectedTypeForComponent[ValueParameterDescriptorImpl]

'scope' @ [121:49] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'entryTypeRef' @ [121:56] ==> val entryTypeRef: KtTypeReference defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.getExpectedTypeForComponent[LocalVariableDescriptor]

'context' @ [121:70] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.DestructuringDeclarationResolver.getExpectedTypeForComponent[ValueParameterDescriptorImpl]

'trace' @ [121:78] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

