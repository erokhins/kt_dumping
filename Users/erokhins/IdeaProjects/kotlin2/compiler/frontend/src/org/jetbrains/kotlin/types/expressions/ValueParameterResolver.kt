'LexicalScopeImpl' @ [45:36] ==> @JvmOverloads public constructor LexicalScopeImpl(parent: HierarchicalScope, ownerDescriptor: DeclarationDescriptor, isOwnerDescriptorAccessibleByLabel: Boolean, implicitReceiver: ReceiverParameterDescriptor?, kind: LexicalScopeKind, redeclarationChecker: LocalRedeclarationChecker = ..., initialize: LexicalScopeImpl.InitializeHandler.() -> Unit = ...) defined in org.jetbrains.kotlin.resolve.scopes.LexicalScopeImpl[DeserializedClassConstructorDescriptor]

'declaringScope' @ [45:53] ==> value-parameter declaringScope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'declaringScope' @ [45:69] ==> value-parameter declaringScope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'ownerDescriptor' @ [45:84] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'DEFAULT_VALUE' @ [45:131] ==> enum entry DEFAULT_VALUE defined in org.jetbrains.kotlin.resolve.scopes.LexicalScopeKind[FakeCallableDescriptorForObject]

'newContext' @ [47:62] ==> @NotNull public open fun newContext(@NotNull trace: BindingTrace, @NotNull scope: LexicalScope, @NotNull dataFlowInfo: DataFlowInfo, @NotNull expectedType: KotlinType): ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaMethodDescriptor]

'trace' @ [47:73] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'scopeForDefaultValue' @ [47:80] ==> val scopeForDefaultValue: LexicalScopeImpl defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver.resolveValueParameters[LocalVariableDescriptor]

'dataFlowInfo' @ [47:102] ==> value-parameter dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'NO_EXPECTED_TYPE' @ [47:126] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'component1' @ [49:15] ==> public final operator fun component1(): ValueParameterDescriptor defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [49:27] ==> public final operator fun component2(): KtParameter defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'valueParameterDescriptors' @ [49:41] ==> value-parameter valueParameterDescriptors: List<ValueParameterDescriptor> defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'zip' @ [49:67] ==> public infix fun <T, R> Iterable<ValueParameterDescriptor>.zip(other: Iterable<KtParameter>): List<Pair<ValueParameterDescriptor, KtParameter>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ValueParameterDescriptor
    <R> -> KtParameter

'valueParameters' @ [49:71] ==> value-parameter valueParameters: List<KtParameter> defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'forceResolveAllContents' @ [50:30] ==> public open fun forceResolveAllContents(@NotNull annotations: Annotations): Unit defined in org.jetbrains.kotlin.resolve.lazy.ForceResolveUtil[JavaMethodDescriptor]

'descriptor' @ [50:54] ==> val descriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver.resolveValueParameters[LocalVariableDescriptor]

'annotations' @ [50:65] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'resolveDefaultValue' @ [51:13] ==> private final fun resolveDefaultValue(valueParameterDescriptor: ValueParameterDescriptor, jetParameter: KtParameter, context: ExpressionTypingContext): Unit defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver[SimpleFunctionDescriptorImpl]

'descriptor' @ [51:33] ==> val descriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver.resolveValueParameters[LocalVariableDescriptor]

'parameter' @ [51:45] ==> val parameter: KtParameter defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver.resolveValueParameters[LocalVariableDescriptor]

'contextForDefaultValue' @ [51:56] ==> val contextForDefaultValue: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver.resolveValueParameters[LocalVariableDescriptor]

'!' @ [60:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'valueParameterDescriptor' @ [60:14] ==> value-parameter valueParameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver.resolveDefaultValue[ValueParameterDescriptorImpl]

'declaresDefaultValue' @ [60:39] ==> public abstract fun declaresDefaultValue(): Boolean defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedSimpleFunctionDescriptor]

'jetParameter' @ [61:28] ==> value-parameter jetParameter: KtParameter defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver.resolveDefaultValue[ValueParameterDescriptorImpl]

'defaultValue' @ [61:41] ==> public final val KtParameter.defaultValue: KtExpression?[MyPropertyDescriptor]

'expressionTypingServices' @ [62:9] ==> private final val expressionTypingServices: ExpressionTypingServices defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver[PropertyDescriptorImpl]

'getTypeInfo' @ [62:34] ==> @NotNull public open fun getTypeInfo(@NotNull expression: KtExpression, @NotNull resolutionContext: raw (ResolutionContext<(ResolutionContext<*>..ResolutionContext<*>?)>..ResolutionContext<out (ResolutionContext<*>..ResolutionContext<*>?)>)): KotlinTypeInfo defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingServices[JavaMethodDescriptor]

'defaultValue' @ [62:46] ==> val defaultValue: KtExpression defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver.resolveDefaultValue[LocalVariableDescriptor]

'context' @ [62:60] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver.resolveDefaultValue[ValueParameterDescriptorImpl]

'replaceExpectedType' @ [62:68] ==> @NotNull public open fun replaceExpectedType(@Nullable newExpectedType: KotlinType?): ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaMethodDescriptor]

'valueParameterDescriptor' @ [62:88] ==> value-parameter valueParameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver.resolveDefaultValue[ValueParameterDescriptorImpl]

'type' @ [62:113] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'isAnnotationClass' @ [63:29] ==> public open fun isAnnotationClass(@Nullable p0: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'getContainingClass' @ [63:66] ==> @Nullable public open fun getContainingClass(@NotNull scope: LexicalScope): ClassDescriptor? defined in org.jetbrains.kotlin.resolve.DescriptorResolver[JavaMethodDescriptor]

'context' @ [63:85] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver.resolveDefaultValue[ValueParameterDescriptorImpl]

'scope' @ [63:93] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'constantExpressionEvaluator' @ [64:28] ==> private final val constantExpressionEvaluator: ConstantExpressionEvaluator defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver[PropertyDescriptorImpl]

'evaluateExpression' @ [64:56] ==> public final fun evaluateExpression(expression: KtExpression, trace: BindingTrace, expectedType: KotlinType? = ...): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[SimpleFunctionDescriptorImpl]

'defaultValue' @ [64:75] ==> val defaultValue: KtExpression defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver.resolveDefaultValue[LocalVariableDescriptor]

'context' @ [64:89] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver.resolveDefaultValue[ValueParameterDescriptorImpl]

'trace' @ [64:97] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'valueParameterDescriptor' @ [64:104] ==> value-parameter valueParameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver.resolveDefaultValue[ValueParameterDescriptorImpl]

'type' @ [64:129] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'constant' @ [65:17] ==> val constant: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver.resolveDefaultValue[LocalVariableDescriptor]

'constant' @ [65:37] ==> val constant: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver.resolveDefaultValue[LocalVariableDescriptor]

'usesNonConstValAsConstant' @ [65:46] ==> public open val usesNonConstValAsConstant: Boolean defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant[DeserializedPropertyDescriptor]

'context' @ [66:17] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver.resolveDefaultValue[ValueParameterDescriptorImpl]

'trace' @ [66:25] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'report' @ [66:31] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT' @ [66:45] ==> public final val ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT: (DiagnosticFactory0<(KtExpression..KtExpression?)>..DiagnosticFactory0<(KtExpression..KtExpression?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [66:97] ==> @NotNull public open fun on(@NotNull element: KtExpression): SimpleDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'defaultValue' @ [66:100] ==> val defaultValue: KtExpression defined in org.jetbrains.kotlin.types.expressions.ValueParameterResolver.resolveDefaultValue[LocalVariableDescriptor]

