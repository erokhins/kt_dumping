'assert' @ [47:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'isInline' @ [47:27] ==> public open fun isInline(@Nullable descriptor: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.resolve.inline.InlineUtil[JavaMethodDescriptor]

'descriptor' @ [47:36] ==> private final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'descriptor' @ [47:113] ==> private final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'descriptor' @ [50:48] ==> private final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'effectiveVisibility' @ [50:59] ==> public fun DeclarationDescriptorWithVisibility.effectiveVisibility(visibility: Visibility = ..., checkPublishedApi: Boolean = ...): EffectiveVisibility defined in org.jetbrains.kotlin.descriptors[DeserializedSimpleFunctionDescriptor]

'descriptor' @ [50:79] ==> private final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'visibility' @ [50:90] ==> public final val FunctionDescriptor.visibility: Visibility[MyPropertyDescriptor]

'descriptor' @ [52:51] ==> private final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'isEffectivelyPrivateApi' @ [52:62] ==> public val DeclarationDescriptorWithVisibility.isEffectivelyPrivateApi: Boolean defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'descriptor' @ [54:39] ==> private final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'valueParameters' @ [54:50] ==> public final val FunctionDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'filter' @ [54:66] ==> public inline fun <T> Iterable<(ValueParameterDescriptor..ValueParameterDescriptor?)>.filter(predicate: ((ValueParameterDescriptor..ValueParameterDescriptor?)) -> Boolean): List<(ValueParameterDescriptor..ValueParameterDescriptor?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)

'isInlineParameter' @ [54:86] ==> public open fun isInlineParameter(@NotNull valueParameterOrReceiver: ParameterDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.inline.InlineUtil[JavaMethodDescriptor]

'it' @ [54:104] ==> value-parameter it: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.inlinableParameters.<anonymous>[ValueParameterDescriptorImpl]

'inlinableParameters' @ [56:41] ==> private final val inlinableParameters: List<(ValueParameterDescriptor..ValueParameterDescriptor?)> defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'mapNotNull' @ [56:61] ==> public inline fun <T, R : Any> Iterable<(ValueParameterDescriptor..ValueParameterDescriptor?)>.mapNotNull(transform: ((ValueParameterDescriptor..ValueParameterDescriptor?)) -> KtElement?): List<KtElement> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)
    <R : Any> -> KtElement

'it' @ [56:75] ==> value-parameter it: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.inlinableKtParameters.<anonymous>[ValueParameterDescriptorImpl]

'source' @ [56:78] ==> public final val ValueParameterDescriptor.source: SourceElement[MyPropertyDescriptor]

'psi' @ [56:111] ==> public open val psi: KtElement defined in org.jetbrains.kotlin.resolve.source.KotlinSourceElement[PropertyDescriptorImpl]

'Delegates' @ [58:46] ==> public object Delegates defined in kotlin.properties[FakeCallableDescriptorForObject]

'notNull' @ [58:56] ==> public final fun <T : Any> notNull(): ReadWriteProperty<Any?, Boolean> defined in kotlin.properties.Delegates[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> Boolean

'resolvedCall' @ [61:26] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[ValueParameterDescriptorImpl]

'call' @ [61:39] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'calleeExpression' @ [61:44] ==> public final val Call.calleeExpression: KtExpression?[MyPropertyDescriptor]

'supportDefaultValueInline' @ [62:9] ==> private final var supportDefaultValueInline: Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'context' @ [62:37] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[ValueParameterDescriptorImpl]

'languageVersionSettings' @ [62:45] ==> public final val languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[PropertyDescriptorImpl]

'supportsFeature' @ [62:69] ==> public open fun supportsFeature(feature: LanguageFeature): Boolean defined in org.jetbrains.kotlin.config.LanguageVersionSettings[DeserializedSimpleFunctionDescriptor]

'LanguageFeature' @ [62:85] ==> public companion object defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'InlineDefaultFunctionalParameters' @ [62:101] ==> enum entry InlineDefaultFunctionalParameters defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'resolvedCall' @ [65:32] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[ValueParameterDescriptorImpl]

'resultingDescriptor' @ [65:45] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.resultingDescriptor: (CallableDescriptor..CallableDescriptor?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'checkCallWithReceiver' @ [66:9] ==> private final fun checkCallWithReceiver(context: CallCheckerContext, targetDescriptor: CallableDescriptor, receiver: ReceiverValue?, expression: KtExpression?): Unit defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[SimpleFunctionDescriptorImpl]

'context' @ [66:31] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[ValueParameterDescriptorImpl]

'targetDescriptor' @ [66:40] ==> val targetDescriptor: (CallableDescriptor..CallableDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[LocalVariableDescriptor]

'resolvedCall' @ [66:58] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[ValueParameterDescriptorImpl]

'dispatchReceiver' @ [66:71] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.dispatchReceiver: ReceiverValue?[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'expression' @ [66:89] ==> val expression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[LocalVariableDescriptor]

'checkCallWithReceiver' @ [67:9] ==> private final fun checkCallWithReceiver(context: CallCheckerContext, targetDescriptor: CallableDescriptor, receiver: ReceiverValue?, expression: KtExpression?): Unit defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[SimpleFunctionDescriptorImpl]

'context' @ [67:31] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[ValueParameterDescriptorImpl]

'targetDescriptor' @ [67:40] ==> val targetDescriptor: (CallableDescriptor..CallableDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[LocalVariableDescriptor]

'resolvedCall' @ [67:58] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[ValueParameterDescriptorImpl]

'extensionReceiver' @ [67:71] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.extensionReceiver: ReceiverValue?[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'expression' @ [67:90] ==> val expression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[LocalVariableDescriptor]

'inlinableParameters' @ [69:13] ==> private final val inlinableParameters: List<(ValueParameterDescriptor..ValueParameterDescriptor?)> defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'contains' @ [69:33] ==> public operator fun <@OnlyInputTypes T> Iterable<(CallableDescriptor..CallableDescriptor?)>.contains(element: (CallableDescriptor..CallableDescriptor?)): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <@OnlyInputTypes T> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'targetDescriptor' @ [69:42] ==> val targetDescriptor: (CallableDescriptor..CallableDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[LocalVariableDescriptor]

'when {
                !checkNotInDefaultParameter(context, targetDescriptor, expression) -> { /*error*/ }
                !isInsideCall(expression) -> context.trace.report(USAGE_IS_NOT_INLINABLE.on(expression, expression, descriptor))
            }' @ [70:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'!' @ [71:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'checkNotInDefaultParameter' @ [71:18] ==> private final fun checkNotInDefaultParameter(context: CallCheckerContext, targetDescriptor: CallableDescriptor, expression: KtExpression): Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[SimpleFunctionDescriptorImpl]

'context' @ [71:45] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[ValueParameterDescriptorImpl]

'targetDescriptor' @ [71:54] ==> val targetDescriptor: (CallableDescriptor..CallableDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[LocalVariableDescriptor]

'expression' @ [71:72] ==> val expression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[LocalVariableDescriptor]

'!' @ [72:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isInsideCall' @ [72:18] ==> private final fun isInsideCall(expression: KtExpression): Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[SimpleFunctionDescriptorImpl]

'expression' @ [72:31] ==> val expression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[LocalVariableDescriptor]

'context' @ [72:46] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[ValueParameterDescriptorImpl]

'trace' @ [72:54] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[PropertyDescriptorImpl]

'report' @ [72:60] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'USAGE_IS_NOT_INLINABLE' @ [72:67] ==> public final val USAGE_IS_NOT_INLINABLE: (DiagnosticFactory2<(KtElement..KtElement?), (KtExpression..KtExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..DiagnosticFactory2<(KtElement..KtElement?), (KtExpression..KtExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [72:90] ==> @NotNull public open fun on(@NotNull element: KtElement, @NotNull a: KtExpression, @NotNull b: DeclarationDescriptor): ParametrizedDiagnostic<(KtElement..KtElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'expression' @ [72:93] ==> val expression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[LocalVariableDescriptor]

'expression' @ [72:105] ==> val expression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[LocalVariableDescriptor]

'descriptor' @ [72:117] ==> private final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'component1' @ [76:15] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>.component1(): (ValueParameterDescriptor..ValueParameterDescriptor?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)
    <V> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument..org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument?)

'component2' @ [76:32] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>.component2(): (ResolvedValueArgument..ResolvedValueArgument?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)
    <V> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument..org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument?)

'resolvedCall' @ [76:42] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[ValueParameterDescriptorImpl]

'valueArguments' @ [76:55] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.valueArguments: (MutableMap<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>..Map<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'value' @ [77:17] ==> val value: (ResolvedValueArgument..ResolvedValueArgument?) defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[LocalVariableDescriptor]

'value' @ [78:34] ==> val value: (ResolvedValueArgument..ResolvedValueArgument?) defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[LocalVariableDescriptor]

'arguments' @ [78:40] ==> public final val ResolvedValueArgument.arguments: (MutableList<(ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>)[MyPropertyDescriptor]

'checkValueParameter' @ [79:21] ==> private final fun checkValueParameter(context: CallCheckerContext, targetDescriptor: CallableDescriptor, targetArgument: ValueArgument, targetParameterDescriptor: ValueParameterDescriptor): Unit defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[SimpleFunctionDescriptorImpl]

'context' @ [79:41] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[ValueParameterDescriptorImpl]

'targetDescriptor' @ [79:50] ==> val targetDescriptor: (CallableDescriptor..CallableDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[LocalVariableDescriptor]

'argument' @ [79:68] ==> val argument: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[LocalVariableDescriptor]

'valueDescriptor' @ [79:78] ==> val valueDescriptor: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[LocalVariableDescriptor]

'checkVisibilityAndAccess' @ [84:9] ==> private final fun checkVisibilityAndAccess(calledDescriptor: CallableDescriptor, expression: KtElement, context: CallCheckerContext): Unit defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[SimpleFunctionDescriptorImpl]

'targetDescriptor' @ [84:34] ==> val targetDescriptor: (CallableDescriptor..CallableDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[LocalVariableDescriptor]

'expression' @ [84:52] ==> val expression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[LocalVariableDescriptor]

'context' @ [84:64] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[ValueParameterDescriptorImpl]

'checkRecursion' @ [85:9] ==> private final fun checkRecursion(context: CallCheckerContext, targetDescriptor: CallableDescriptor, expression: KtElement): Unit defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[SimpleFunctionDescriptorImpl]

'context' @ [85:24] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[ValueParameterDescriptorImpl]

'targetDescriptor' @ [85:33] ==> val targetDescriptor: (CallableDescriptor..CallableDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[LocalVariableDescriptor]

'expression' @ [85:51] ==> val expression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.check[LocalVariableDescriptor]

'!' @ [89:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'supportDefaultValueInline' @ [89:14] ==> private final var supportDefaultValueInline: Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'expression' @ [89:43] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkNotInDefaultParameter[ValueParameterDescriptorImpl]

'getParentOfType' @ [89:54] ==> public inline fun <reified T : PsiElement> PsiElement.getParentOfType(strict: Boolean): KtParameter? defined in org.jetbrains.kotlin.psi.psiUtil[SimpleFunctionDescriptorImpl]
Inferred types:
    <reified T : PsiElement> -> KtParameter

'let' @ [89:90] ==> @InlineOnly public inline fun <T, R> KtParameter.let(block: (KtParameter) -> Boolean): Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtParameter
    <R> -> Boolean

'it' @ [90:29] ==> value-parameter it: KtParameter defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkNotInDefaultParameter.<anonymous>[ValueParameterDescriptorImpl]

'inlinableKtParameters' @ [90:36] ==> private final val inlinableKtParameters: List<KtElement> defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'!' @ [91:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'allow' @ [91:22] ==> val allow: Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkNotInDefaultParameter.<anonymous>[LocalVariableDescriptor]

'context' @ [92:21] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkNotInDefaultParameter[ValueParameterDescriptorImpl]

'trace' @ [92:29] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[PropertyDescriptorImpl]

'report' @ [92:35] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'NOT_SUPPORTED_INLINE_PARAMETER_IN_INLINE_PARAMETER_DEFAULT_VALUE' @ [92:42] ==> public final val NOT_SUPPORTED_INLINE_PARAMETER_IN_INLINE_PARAMETER_DEFAULT_VALUE: (DiagnosticFactory2<(KtElement..KtElement?), (KtExpression..KtExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..DiagnosticFactory2<(KtElement..KtElement?), (KtExpression..KtExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [92:107] ==> @NotNull public open fun on(@NotNull element: KtElement, @NotNull a: KtExpression, @NotNull b: DeclarationDescriptor): ParametrizedDiagnostic<(KtElement..KtElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'expression' @ [92:110] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkNotInDefaultParameter[ValueParameterDescriptorImpl]

'expression' @ [92:122] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkNotInDefaultParameter[ValueParameterDescriptorImpl]

'descriptor' @ [92:134] ==> private final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'allow' @ [94:17] ==> val allow: Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkNotInDefaultParameter.<anonymous>[LocalVariableDescriptor]

'getParentCallIfPresent' @ [98:32] ==> @Nullable public open fun getParentCallIfPresent(@NotNull expression: KtExpression): KtExpression? defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'expression' @ [98:55] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isInsideCall[ValueParameterDescriptorImpl]

'parent' @ [99:13] ==> val parent: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isInsideCall[LocalVariableDescriptor]

'getOperationToken' @ [100:35] ==> @Nullable public open fun getOperationToken(@NotNull expression: KtOperationExpression): KtToken? defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'!!' @ [100:53] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: KtOperationExpression?): KtOperationExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> KtOperationExpression

'parent' @ [100:54] ==> val parent: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isInsideCall[LocalVariableDescriptor]

'token' @ [101:17] ==> val token: KtToken? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isInsideCall[LocalVariableDescriptor]

'EQ' @ [101:36] ==> public final val EQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'token' @ [101:42] ==> val token: KtToken? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isInsideCall[LocalVariableDescriptor]

'ANDAND' @ [101:61] ==> public final val ANDAND: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'token' @ [101:71] ==> val token: KtToken? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isInsideCall[LocalVariableDescriptor]

'OROR' @ [101:90] ==> public final val OROR: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'parent' @ [107:13] ==> val parent: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isInsideCall[LocalVariableDescriptor]

'expression' @ [110:39] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isInsideCall[ValueParameterDescriptorImpl]

'current' @ [111:20] ==> var current: PsiElement defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isInsideCall[LocalVariableDescriptor]

'parent' @ [111:32] ==> val parent: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isInsideCall[LocalVariableDescriptor]

'current' @ [112:21] ==> var current: PsiElement defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isInsideCall[LocalVariableDescriptor]

'current' @ [115:17] ==> var current: PsiElement defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isInsideCall[LocalVariableDescriptor]

'current' @ [115:27] ==> var current: PsiElement defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isInsideCall[LocalVariableDescriptor]

'parent' @ [115:35] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [119:16] ==> val parent: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isInsideCall[LocalVariableDescriptor]

'targetArgument' @ [128:34] ==> value-parameter targetArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkValueParameter[ValueParameterDescriptorImpl]

'getArgumentExpression' @ [128:49] ==> @IfNotParsed public abstract fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.ValueArgument[SimpleFunctionDescriptorImpl]

'getCalleeDescriptor' @ [129:30] ==> private final fun getCalleeDescriptor(context: CallCheckerContext, expression: KtExpression, unwrapVariableAsFunction: Boolean): CallableDescriptor? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[SimpleFunctionDescriptorImpl]

'context' @ [129:50] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkValueParameter[ValueParameterDescriptorImpl]

'argumentExpression' @ [129:59] ==> val argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkValueParameter[LocalVariableDescriptor]

'argumentCallee' @ [131:13] ==> val argumentCallee: CallableDescriptor? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkValueParameter[LocalVariableDescriptor]

'inlinableParameters' @ [131:39] ==> private final val inlinableParameters: List<(ValueParameterDescriptor..ValueParameterDescriptor?)> defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'contains' @ [131:59] ==> public operator fun <@OnlyInputTypes T> Iterable<(CallableDescriptor..CallableDescriptor?)>.contains(element: (CallableDescriptor..CallableDescriptor?)): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <@OnlyInputTypes T> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'argumentCallee' @ [131:68] ==> val argumentCallee: CallableDescriptor? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkValueParameter[LocalVariableDescriptor]

'when {
                !checkNotInDefaultParameter(context, argumentCallee, argumentExpression) -> { /*error*/ }

                InlineUtil.isInline(targetDescriptor) && InlineUtil.isInlineParameter(targetParameterDescriptor) ->
                    if (allowsNonLocalReturns(argumentCallee) && !allowsNonLocalReturns(targetParameterDescriptor)) {
                        context.trace.report(NON_LOCAL_RETURN_NOT_ALLOWED.on(argumentExpression, argumentExpression))
                    }
                    else {
                        checkNonLocalReturn(context, argumentCallee, argumentExpression)
                    }

                else -> context.trace.report(USAGE_IS_NOT_INLINABLE.on(argumentExpression, argumentExpression, descriptor))
            }' @ [132:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'!' @ [133:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'checkNotInDefaultParameter' @ [133:18] ==> private final fun checkNotInDefaultParameter(context: CallCheckerContext, targetDescriptor: CallableDescriptor, expression: KtExpression): Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[SimpleFunctionDescriptorImpl]

'context' @ [133:45] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkValueParameter[ValueParameterDescriptorImpl]

'argumentCallee' @ [133:54] ==> val argumentCallee: CallableDescriptor? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkValueParameter[LocalVariableDescriptor]

'argumentExpression' @ [133:70] ==> val argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkValueParameter[LocalVariableDescriptor]

'isInline' @ [135:28] ==> public open fun isInline(@Nullable descriptor: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.resolve.inline.InlineUtil[JavaMethodDescriptor]

'targetDescriptor' @ [135:37] ==> value-parameter targetDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkValueParameter[ValueParameterDescriptorImpl]

'isInlineParameter' @ [135:69] ==> public open fun isInlineParameter(@NotNull valueParameterOrReceiver: ParameterDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.inline.InlineUtil[JavaMethodDescriptor]

'targetParameterDescriptor' @ [135:87] ==> value-parameter targetParameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkValueParameter[ValueParameterDescriptorImpl]

'if (allowsNonLocalReturns(argumentCallee) && !allowsNonLocalReturns(targetParameterDescriptor)) {
                        context.trace.report(NON_LOCAL_RETURN_NOT_ALLOWED.on(argumentExpression, argumentExpression))
                    }
                    else {
                        checkNonLocalReturn(context, argumentCallee, argumentExpression)
                    }' @ [136:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'allowsNonLocalReturns' @ [136:25] ==> public open fun allowsNonLocalReturns(@NotNull lambda: CallableDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.inline.InlineUtil[JavaMethodDescriptor]

'argumentCallee' @ [136:47] ==> val argumentCallee: CallableDescriptor? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkValueParameter[LocalVariableDescriptor]

'!' @ [136:66] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'allowsNonLocalReturns' @ [136:67] ==> public open fun allowsNonLocalReturns(@NotNull lambda: CallableDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.inline.InlineUtil[JavaMethodDescriptor]

'targetParameterDescriptor' @ [136:89] ==> value-parameter targetParameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkValueParameter[ValueParameterDescriptorImpl]

'context' @ [137:25] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkValueParameter[ValueParameterDescriptorImpl]

'trace' @ [137:33] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[PropertyDescriptorImpl]

'report' @ [137:39] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'NON_LOCAL_RETURN_NOT_ALLOWED' @ [137:46] ==> public final val NON_LOCAL_RETURN_NOT_ALLOWED: (DiagnosticFactory1<(KtElement..KtElement?), (KtElement..KtElement?)>..DiagnosticFactory1<(KtElement..KtElement?), (KtElement..KtElement?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [137:75] ==> @NotNull public open fun on(@NotNull element: KtElement, @NotNull argument: KtElement): ParametrizedDiagnostic<(KtElement..KtElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory1[JavaMethodDescriptor]

'argumentExpression' @ [137:78] ==> val argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkValueParameter[LocalVariableDescriptor]

'argumentExpression' @ [137:98] ==> val argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkValueParameter[LocalVariableDescriptor]

'checkNonLocalReturn' @ [140:25] ==> private final fun checkNonLocalReturn(context: CallCheckerContext, inlinableParameterDescriptor: CallableDescriptor, parameterUsage: KtExpression): Unit defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[SimpleFunctionDescriptorImpl]

'context' @ [140:45] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkValueParameter[ValueParameterDescriptorImpl]

'argumentCallee' @ [140:54] ==> val argumentCallee: CallableDescriptor? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkValueParameter[LocalVariableDescriptor]

'argumentExpression' @ [140:70] ==> val argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkValueParameter[LocalVariableDescriptor]

'context' @ [143:25] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkValueParameter[ValueParameterDescriptorImpl]

'trace' @ [143:33] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[PropertyDescriptorImpl]

'report' @ [143:39] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'USAGE_IS_NOT_INLINABLE' @ [143:46] ==> public final val USAGE_IS_NOT_INLINABLE: (DiagnosticFactory2<(KtElement..KtElement?), (KtExpression..KtExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..DiagnosticFactory2<(KtElement..KtElement?), (KtExpression..KtExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [143:69] ==> @NotNull public open fun on(@NotNull element: KtElement, @NotNull a: KtExpression, @NotNull b: DeclarationDescriptor): ParametrizedDiagnostic<(KtElement..KtElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'argumentExpression' @ [143:72] ==> val argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkValueParameter[LocalVariableDescriptor]

'argumentExpression' @ [143:92] ==> val argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkValueParameter[LocalVariableDescriptor]

'descriptor' @ [143:112] ==> private final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'receiver' @ [154:13] ==> value-parameter receiver: ReceiverValue? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkCallWithReceiver[ValueParameterDescriptorImpl]

'when (receiver) {
            is ExpressionReceiver -> {
                receiverExpression = receiver.expression
                varDescriptor = getCalleeDescriptor(context, receiverExpression, true)
            }
            is ExtensionReceiver -> {
                val extension = receiver.declarationDescriptor

                varDescriptor = extension.extensionReceiverParameter
                assert(varDescriptor != null) { "Extension should have receiverParameterDescriptor: " + extension }

                receiverExpression = expression
            }
            else -> {
                varDescriptor = null
                receiverExpression = null
            }
        }' @ [158:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'receiver' @ [158:15] ==> value-parameter receiver: ReceiverValue? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkCallWithReceiver[ValueParameterDescriptorImpl]

'receiverExpression' @ [160:17] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkCallWithReceiver[LocalVariableDescriptor]

'receiver' @ [160:38] ==> value-parameter receiver: ReceiverValue? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkCallWithReceiver[ValueParameterDescriptorImpl]

'expression' @ [160:47] ==> public abstract val expression: KtExpression defined in org.jetbrains.kotlin.resolve.scopes.receivers.ExpressionReceiver[PropertyDescriptorImpl]

'varDescriptor' @ [161:17] ==> val varDescriptor: CallableDescriptor? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkCallWithReceiver[LocalVariableDescriptor]

'getCalleeDescriptor' @ [161:33] ==> private final fun getCalleeDescriptor(context: CallCheckerContext, expression: KtExpression, unwrapVariableAsFunction: Boolean): CallableDescriptor? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[SimpleFunctionDescriptorImpl]

'context' @ [161:53] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkCallWithReceiver[ValueParameterDescriptorImpl]

'receiverExpression' @ [161:62] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkCallWithReceiver[LocalVariableDescriptor]

'receiver' @ [164:33] ==> value-parameter receiver: ReceiverValue? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkCallWithReceiver[ValueParameterDescriptorImpl]

'declarationDescriptor' @ [164:42] ==> public open val declarationDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.scopes.receivers.ExtensionReceiver[JavaPropertyDescriptor]

'varDescriptor' @ [166:17] ==> val varDescriptor: CallableDescriptor? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkCallWithReceiver[LocalVariableDescriptor]

'extension' @ [166:33] ==> val extension: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkCallWithReceiver[LocalVariableDescriptor]

'extensionReceiverParameter' @ [166:43] ==> public final val CallableDescriptor.extensionReceiverParameter: ReceiverParameterDescriptor?[MyPropertyDescriptor]

'assert' @ [167:17] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'varDescriptor' @ [167:24] ==> val varDescriptor: CallableDescriptor? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkCallWithReceiver[LocalVariableDescriptor]

'+' @ [167:49] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'extension' @ [167:105] ==> val extension: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkCallWithReceiver[LocalVariableDescriptor]

'receiverExpression' @ [169:17] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkCallWithReceiver[LocalVariableDescriptor]

'expression' @ [169:38] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkCallWithReceiver[ValueParameterDescriptorImpl]

'varDescriptor' @ [172:17] ==> val varDescriptor: CallableDescriptor? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkCallWithReceiver[LocalVariableDescriptor]

'receiverExpression' @ [173:17] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkCallWithReceiver[LocalVariableDescriptor]

'inlinableParameters' @ [177:13] ==> private final val inlinableParameters: List<(ValueParameterDescriptor..ValueParameterDescriptor?)> defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'contains' @ [177:33] ==> public operator fun <@OnlyInputTypes T> Iterable<CallableDescriptor?>.contains(element: CallableDescriptor?): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <@OnlyInputTypes T> -> CallableDescriptor?

'varDescriptor' @ [177:42] ==> val varDescriptor: CallableDescriptor? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkCallWithReceiver[LocalVariableDescriptor]

'checkLambdaInvokeOrExtensionCall' @ [179:13] ==> private final fun checkLambdaInvokeOrExtensionCall(context: CallCheckerContext, lambdaDescriptor: CallableDescriptor, callDescriptor: CallableDescriptor, receiverExpression: KtExpression): Unit defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[SimpleFunctionDescriptorImpl]

'context' @ [179:46] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkCallWithReceiver[ValueParameterDescriptorImpl]

'varDescriptor' @ [179:55] ==> val varDescriptor: CallableDescriptor? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkCallWithReceiver[LocalVariableDescriptor]

'targetDescriptor' @ [179:72] ==> value-parameter targetDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkCallWithReceiver[ValueParameterDescriptorImpl]

'receiverExpression' @ [179:90] ==> val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkCallWithReceiver[LocalVariableDescriptor]

'!' @ [188:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'expression' @ [188:15] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.getCalleeDescriptor[ValueParameterDescriptorImpl]

'expression' @ [188:55] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.getCalleeDescriptor[ValueParameterDescriptorImpl]

'expression' @ [190:24] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.getCalleeDescriptor[ValueParameterDescriptorImpl]

'getResolvedCall' @ [190:35] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[SimpleFunctionDescriptorImpl]

'context' @ [190:51] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.getCalleeDescriptor[ValueParameterDescriptorImpl]

'trace' @ [190:59] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[PropertyDescriptorImpl]

'bindingContext' @ [190:65] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'unwrapVariableAsFunction' @ [191:13] ==> value-parameter unwrapVariableAsFunction: Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.getCalleeDescriptor[ValueParameterDescriptorImpl]

'thisCall' @ [191:41] ==> val thisCall: ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.getCalleeDescriptor[LocalVariableDescriptor]

'thisCall' @ [192:21] ==> val thisCall: ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.getCalleeDescriptor[LocalVariableDescriptor]

'variableCall' @ [192:65] ==> public abstract val variableCall: ResolvedCall<VariableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.model.VariableAsFunctionResolvedCall[PropertyDescriptorImpl]

'resultingDescriptor' @ [192:78] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<VariableDescriptor>.resultingDescriptor: VariableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> VariableDescriptor

'thisCall' @ [194:16] ==> val thisCall: ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.getCalleeDescriptor[LocalVariableDescriptor]

'resultingDescriptor' @ [194:26] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.resultingDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'isInvokeOrInlineExtension' @ [203:29] ==> private final fun isInvokeOrInlineExtension(descriptor: CallableDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[SimpleFunctionDescriptorImpl]

'callDescriptor' @ [203:55] ==> value-parameter callDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkLambdaInvokeOrExtensionCall[ValueParameterDescriptorImpl]

'if (!inlinableCall) {
            context.trace.report(USAGE_IS_NOT_INLINABLE.on(receiverExpression, receiverExpression, descriptor))
        }
        else {
            checkNonLocalReturn(context, lambdaDescriptor, receiverExpression)
        }' @ [204:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'!' @ [204:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'inlinableCall' @ [204:14] ==> val inlinableCall: Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkLambdaInvokeOrExtensionCall[LocalVariableDescriptor]

'context' @ [205:13] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkLambdaInvokeOrExtensionCall[ValueParameterDescriptorImpl]

'trace' @ [205:21] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[PropertyDescriptorImpl]

'report' @ [205:27] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'USAGE_IS_NOT_INLINABLE' @ [205:34] ==> public final val USAGE_IS_NOT_INLINABLE: (DiagnosticFactory2<(KtElement..KtElement?), (KtExpression..KtExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..DiagnosticFactory2<(KtElement..KtElement?), (KtExpression..KtExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [205:57] ==> @NotNull public open fun on(@NotNull element: KtElement, @NotNull a: KtExpression, @NotNull b: DeclarationDescriptor): ParametrizedDiagnostic<(KtElement..KtElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'receiverExpression' @ [205:60] ==> value-parameter receiverExpression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkLambdaInvokeOrExtensionCall[ValueParameterDescriptorImpl]

'receiverExpression' @ [205:80] ==> value-parameter receiverExpression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkLambdaInvokeOrExtensionCall[ValueParameterDescriptorImpl]

'descriptor' @ [205:100] ==> private final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'checkNonLocalReturn' @ [208:13] ==> private final fun checkNonLocalReturn(context: CallCheckerContext, inlinableParameterDescriptor: CallableDescriptor, parameterUsage: KtExpression): Unit defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[SimpleFunctionDescriptorImpl]

'context' @ [208:33] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkLambdaInvokeOrExtensionCall[ValueParameterDescriptorImpl]

'lambdaDescriptor' @ [208:42] ==> value-parameter lambdaDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkLambdaInvokeOrExtensionCall[ValueParameterDescriptorImpl]

'receiverExpression' @ [208:60] ==> value-parameter receiverExpression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkLambdaInvokeOrExtensionCall[ValueParameterDescriptorImpl]

'targetDescriptor' @ [217:13] ==> value-parameter targetDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkRecursion[ValueParameterDescriptorImpl]

'original' @ [217:30] ==> public final val CallableDescriptor.original: CallableDescriptor[MyPropertyDescriptor]

'descriptor' @ [217:43] ==> private final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'context' @ [218:13] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkRecursion[ValueParameterDescriptorImpl]

'trace' @ [218:21] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[PropertyDescriptorImpl]

'report' @ [218:27] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'RECURSION_IN_INLINE' @ [218:41] ==> public final val RECURSION_IN_INLINE: (DiagnosticFactory2<(KtElement..KtElement?), (KtElement..KtElement?), (DeclarationDescriptor..DeclarationDescriptor?)>..DiagnosticFactory2<(KtElement..KtElement?), (KtElement..KtElement?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [218:61] ==> @NotNull public open fun on(@NotNull element: KtElement, @NotNull a: KtElement, @NotNull b: DeclarationDescriptor): ParametrizedDiagnostic<(KtElement..KtElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'expression' @ [218:64] ==> value-parameter expression: KtElement defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkRecursion[ValueParameterDescriptorImpl]

'expression' @ [218:76] ==> value-parameter expression: KtElement defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkRecursion[ValueParameterDescriptorImpl]

'descriptor' @ [218:88] ==> private final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'descriptor' @ [223:13] ==> value-parameter descriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isInvokeOrInlineExtension[ValueParameterDescriptorImpl]

'descriptor' @ [227:37] ==> value-parameter descriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isInvokeOrInlineExtension[ValueParameterDescriptorImpl]

'getContainingDeclaration' @ [227:48] ==> @NotNull public abstract fun getContainingDeclaration(): DeclarationDescriptor defined in org.jetbrains.kotlin.descriptors.CallableDescriptor[JavaMethodDescriptor]

'descriptor' @ [228:24] ==> value-parameter descriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isInvokeOrInlineExtension[ValueParameterDescriptorImpl]

'getName' @ [228:35] ==> @NotNull public abstract fun getName(): Name defined in org.jetbrains.kotlin.descriptors.CallableDescriptor[JavaMethodDescriptor]

'OperatorNameConventions' @ [228:48] ==> public object OperatorNameConventions defined in org.jetbrains.kotlin.util[FakeCallableDescriptorForObject]

'INVOKE' @ [228:72] ==> @field:JvmField public final val INVOKE: Name defined in org.jetbrains.kotlin.util.OperatorNameConventions[DeserializedPropertyDescriptor]

'containingDeclaration' @ [229:24] ==> val containingDeclaration: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isInvokeOrInlineExtension[LocalVariableDescriptor]

'containingDeclaration' @ [230:24] ==> val containingDeclaration: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isInvokeOrInlineExtension[LocalVariableDescriptor]

'defaultType' @ [230:46] ==> public final val ClassDescriptor.defaultType: SimpleType[MyPropertyDescriptor]

'isFunctionType' @ [230:58] ==> public val KotlinType.isFunctionType: Boolean defined in org.jetbrains.kotlin.builtins[DeserializedPropertyDescriptor]

'isInvoke' @ [232:16] ==> val isInvoke: Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isInvokeOrInlineExtension[LocalVariableDescriptor]

'isInline' @ [232:39] ==> public open fun isInline(@Nullable descriptor: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.resolve.inline.InlineUtil[JavaMethodDescriptor]

'descriptor' @ [232:48] ==> value-parameter descriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isInvokeOrInlineExtension[ValueParameterDescriptorImpl]

'if (isDefinedInInlineFunction(calledDescriptor))
            EffectiveVisibility.Public
        else
            calledDescriptor.effectiveVisibility(calledDescriptor.visibility, true)' @ [240:44] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: EffectiveVisibility, elseBranch: EffectiveVisibility): EffectiveVisibility[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> EffectiveVisibility

'isDefinedInInlineFunction' @ [240:48] ==> private final fun isDefinedInInlineFunction(startDescriptor: DeclarationDescriptorWithVisibility): Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[SimpleFunctionDescriptorImpl]

'calledDescriptor' @ [240:74] ==> value-parameter calledDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkVisibilityAndAccess[ValueParameterDescriptorImpl]

'Public' @ [241:33] ==> public object Public : EffectiveVisibility defined in org.jetbrains.kotlin.descriptors.EffectiveVisibility[FakeCallableDescriptorForObject]

'calledDescriptor' @ [243:13] ==> value-parameter calledDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkVisibilityAndAccess[ValueParameterDescriptorImpl]

'effectiveVisibility' @ [243:30] ==> public fun DeclarationDescriptorWithVisibility.effectiveVisibility(visibility: Visibility = ..., checkPublishedApi: Boolean = ...): EffectiveVisibility defined in org.jetbrains.kotlin.descriptors[DeserializedSimpleFunctionDescriptor]

'calledDescriptor' @ [243:50] ==> value-parameter calledDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkVisibilityAndAccess[ValueParameterDescriptorImpl]

'visibility' @ [243:67] ==> public final val CallableDescriptor.visibility: Visibility[MyPropertyDescriptor]

'calledFunEffectiveVisibility' @ [245:47] ==> val calledFunEffectiveVisibility: EffectiveVisibility defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkVisibilityAndAccess[LocalVariableDescriptor]

'publicApi' @ [245:76] ==> public final val publicApi: Boolean defined in org.jetbrains.kotlin.descriptors.EffectiveVisibility[DeserializedPropertyDescriptor]

'inlineFunEffectiveVisibility' @ [246:47] ==> private final val inlineFunEffectiveVisibility: EffectiveVisibility defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'publicApi' @ [246:76] ==> public final val publicApi: Boolean defined in org.jetbrains.kotlin.descriptors.EffectiveVisibility[DeserializedPropertyDescriptor]

'if (isInlineFunPublicOrPublishedApi &&
            !isCalledFunPublicOrPublishedApi &&
            calledDescriptor.visibility !== Visibilities.LOCAL) {
            context.trace.report(Errors.NON_PUBLIC_CALL_FROM_PUBLIC_INLINE.on(expression, calledDescriptor, descriptor))
        }
        else {
            checkPrivateClassMemberAccess(calledDescriptor, expression, context)
        }' @ [247:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'isInlineFunPublicOrPublishedApi' @ [247:13] ==> val isInlineFunPublicOrPublishedApi: Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkVisibilityAndAccess[LocalVariableDescriptor]

'!' @ [248:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isCalledFunPublicOrPublishedApi' @ [248:14] ==> val isCalledFunPublicOrPublishedApi: Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkVisibilityAndAccess[LocalVariableDescriptor]

'calledDescriptor' @ [249:13] ==> value-parameter calledDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkVisibilityAndAccess[ValueParameterDescriptorImpl]

'visibility' @ [249:30] ==> public final val CallableDescriptor.visibility: Visibility[MyPropertyDescriptor]

'LOCAL' @ [249:58] ==> @NotNull public final val LOCAL: Visibility defined in org.jetbrains.kotlin.descriptors.Visibilities[JavaPropertyDescriptor]

'context' @ [250:13] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkVisibilityAndAccess[ValueParameterDescriptorImpl]

'trace' @ [250:21] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[PropertyDescriptorImpl]

'report' @ [250:27] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'NON_PUBLIC_CALL_FROM_PUBLIC_INLINE' @ [250:41] ==> public final val NON_PUBLIC_CALL_FROM_PUBLIC_INLINE: (DiagnosticFactory2<(KtElement..KtElement?), (DeclarationDescriptor..DeclarationDescriptor?), (DeclarationDescriptor..DeclarationDescriptor?)>..DiagnosticFactory2<(KtElement..KtElement?), (DeclarationDescriptor..DeclarationDescriptor?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [250:76] ==> @NotNull public open fun on(@NotNull element: KtElement, @NotNull a: DeclarationDescriptor, @NotNull b: DeclarationDescriptor): ParametrizedDiagnostic<(KtElement..KtElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'expression' @ [250:79] ==> value-parameter expression: KtElement defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkVisibilityAndAccess[ValueParameterDescriptorImpl]

'calledDescriptor' @ [250:91] ==> value-parameter calledDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkVisibilityAndAccess[ValueParameterDescriptorImpl]

'descriptor' @ [250:109] ==> private final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'checkPrivateClassMemberAccess' @ [253:13] ==> private final fun checkPrivateClassMemberAccess(declarationDescriptor: DeclarationDescriptor, expression: KtElement, context: CallCheckerContext): Unit defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[SimpleFunctionDescriptorImpl]

'calledDescriptor' @ [253:43] ==> value-parameter calledDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkVisibilityAndAccess[ValueParameterDescriptorImpl]

'expression' @ [253:61] ==> value-parameter expression: KtElement defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkVisibilityAndAccess[ValueParameterDescriptorImpl]

'context' @ [253:73] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkVisibilityAndAccess[ValueParameterDescriptorImpl]

'calledDescriptor' @ [256:13] ==> value-parameter calledDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkVisibilityAndAccess[ValueParameterDescriptorImpl]

'isInlineFunPublicOrPublishedApi' @ [257:13] ==> val isInlineFunPublicOrPublishedApi: Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkVisibilityAndAccess[LocalVariableDescriptor]

'inlineFunEffectiveVisibility' @ [258:13] ==> private final val inlineFunEffectiveVisibility: EffectiveVisibility defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'toVisibility' @ [258:42] ==> public abstract fun toVisibility(): Visibility defined in org.jetbrains.kotlin.descriptors.EffectiveVisibility[DeserializedSimpleFunctionDescriptor]

'PROTECTED' @ [258:74] ==> @NotNull public final val PROTECTED: Visibility defined in org.jetbrains.kotlin.descriptors.Visibilities[JavaPropertyDescriptor]

'calledFunEffectiveVisibility' @ [259:13] ==> val calledFunEffectiveVisibility: EffectiveVisibility defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkVisibilityAndAccess[LocalVariableDescriptor]

'toVisibility' @ [259:42] ==> public abstract fun toVisibility(): Visibility defined in org.jetbrains.kotlin.descriptors.EffectiveVisibility[DeserializedSimpleFunctionDescriptor]

'PROTECTED' @ [259:74] ==> @NotNull public final val PROTECTED: Visibility defined in org.jetbrains.kotlin.descriptors.Visibilities[JavaPropertyDescriptor]

'context' @ [260:13] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkVisibilityAndAccess[ValueParameterDescriptorImpl]

'trace' @ [260:21] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[PropertyDescriptorImpl]

'report' @ [260:27] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'PROTECTED_CALL_FROM_PUBLIC_INLINE' @ [260:41] ==> public final val PROTECTED_CALL_FROM_PUBLIC_INLINE: (DiagnosticFactory1<(PsiElement..PsiElement?), (CallableDescriptor..CallableDescriptor?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (CallableDescriptor..CallableDescriptor?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [260:75] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull argument: CallableDescriptor): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory1[JavaMethodDescriptor]

'expression' @ [260:78] ==> value-parameter expression: KtElement defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkVisibilityAndAccess[ValueParameterDescriptorImpl]

'calledDescriptor' @ [260:90] ==> value-parameter calledDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkVisibilityAndAccess[ValueParameterDescriptorImpl]

'!' @ [269:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isEffectivelyPrivateApiFunction' @ [269:14] ==> private final val isEffectivelyPrivateApiFunction: Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'declarationDescriptor' @ [270:17] ==> value-parameter declarationDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkPrivateClassMemberAccess[ValueParameterDescriptorImpl]

'isInsidePrivateClass' @ [270:39] ==> public val DeclarationDescriptor.isInsidePrivateClass: Boolean defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'context' @ [271:17] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkPrivateClassMemberAccess[ValueParameterDescriptorImpl]

'trace' @ [271:25] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[PropertyDescriptorImpl]

'report' @ [271:31] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'PRIVATE_CLASS_MEMBER_FROM_INLINE' @ [271:45] ==> public final val PRIVATE_CLASS_MEMBER_FROM_INLINE: (DiagnosticFactory2<(KtElement..KtElement?), (DeclarationDescriptor..DeclarationDescriptor?), (DeclarationDescriptor..DeclarationDescriptor?)>..DiagnosticFactory2<(KtElement..KtElement?), (DeclarationDescriptor..DeclarationDescriptor?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [271:78] ==> @NotNull public open fun on(@NotNull element: KtElement, @NotNull a: DeclarationDescriptor, @NotNull b: DeclarationDescriptor): ParametrizedDiagnostic<(KtElement..KtElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'expression' @ [271:81] ==> value-parameter expression: KtElement defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkPrivateClassMemberAccess[ValueParameterDescriptorImpl]

'declarationDescriptor' @ [271:93] ==> value-parameter declarationDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkPrivateClassMemberAccess[ValueParameterDescriptorImpl]

'descriptor' @ [271:116] ==> private final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'startDescriptor' @ [277:60] ==> value-parameter startDescriptor: DeclarationDescriptorWithVisibility defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isDefinedInInlineFunction[ValueParameterDescriptorImpl]

'parent' @ [279:16] ==> var parent: DeclarationDescriptorWithVisibility? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isDefinedInInlineFunction[LocalVariableDescriptor]

'parent' @ [280:17] ==> var parent: DeclarationDescriptorWithVisibility? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isDefinedInInlineFunction[LocalVariableDescriptor]

'containingDeclaration' @ [280:24] ==> public final val DeclarationDescriptorWithVisibility.containingDeclaration: DeclarationDescriptor?[MyPropertyDescriptor]

'descriptor' @ [280:50] ==> private final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'parent' @ [282:13] ==> var parent: DeclarationDescriptorWithVisibility? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isDefinedInInlineFunction[LocalVariableDescriptor]

'getParentOfType' @ [282:38] ==> @Nullable public open fun <D : (DeclarationDescriptor..DeclarationDescriptor?)> getParentOfType(@Nullable p0: DeclarationDescriptor?, @NotNull p1: Class<(DeclarationDescriptorWithVisibility..DeclarationDescriptorWithVisibility?)>): DeclarationDescriptorWithVisibility? defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]
Inferred types:
    <D : (DeclarationDescriptor..DeclarationDescriptor?)> -> DeclarationDescriptorWithVisibility

'parent' @ [282:54] ==> var parent: DeclarationDescriptorWithVisibility? defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.isDefinedInInlineFunction[LocalVariableDescriptor]

'java' @ [282:105] ==> public val <T> KClass<DeclarationDescriptorWithVisibility>.java: Class<DeclarationDescriptorWithVisibility> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> DeclarationDescriptorWithVisibility

'!' @ [293:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'allowsNonLocalReturns' @ [293:14] ==> public open fun allowsNonLocalReturns(@NotNull lambda: CallableDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.inline.InlineUtil[JavaMethodDescriptor]

'inlinableParameterDescriptor' @ [293:36] ==> value-parameter inlinableParameterDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkNonLocalReturn[ValueParameterDescriptorImpl]

'!' @ [295:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'checkNonLocalReturnUsage' @ [295:14] ==> public open fun checkNonLocalReturnUsage(@NotNull fromFunction: DeclarationDescriptor, @NotNull startExpression: KtExpression, @NotNull context: ResolutionContext<*>): Boolean defined in org.jetbrains.kotlin.resolve.inline.InlineUtil[JavaMethodDescriptor]

'descriptor' @ [295:39] ==> private final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker[PropertyDescriptorImpl]

'parameterUsage' @ [295:51] ==> value-parameter parameterUsage: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkNonLocalReturn[ValueParameterDescriptorImpl]

'context' @ [295:67] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkNonLocalReturn[ValueParameterDescriptorImpl]

'resolutionContext' @ [295:75] ==> public final val resolutionContext: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[PropertyDescriptorImpl]

'context' @ [296:13] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkNonLocalReturn[ValueParameterDescriptorImpl]

'trace' @ [296:21] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[PropertyDescriptorImpl]

'report' @ [296:27] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'NON_LOCAL_RETURN_NOT_ALLOWED' @ [296:34] ==> public final val NON_LOCAL_RETURN_NOT_ALLOWED: (DiagnosticFactory1<(KtElement..KtElement?), (KtElement..KtElement?)>..DiagnosticFactory1<(KtElement..KtElement?), (KtElement..KtElement?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [296:63] ==> @NotNull public open fun on(@NotNull element: KtElement, @NotNull argument: KtElement): ParametrizedDiagnostic<(KtElement..KtElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory1[JavaMethodDescriptor]

'parameterUsage' @ [296:66] ==> value-parameter parameterUsage: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkNonLocalReturn[ValueParameterDescriptorImpl]

'parameterUsage' @ [296:82] ==> value-parameter parameterUsage: KtExpression defined in org.jetbrains.kotlin.resolve.calls.checkers.InlineChecker.checkNonLocalReturn[ValueParameterDescriptorImpl]

