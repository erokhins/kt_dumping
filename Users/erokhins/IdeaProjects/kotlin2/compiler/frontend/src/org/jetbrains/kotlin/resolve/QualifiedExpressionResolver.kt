'packageDirective' @ [48:28] ==> value-parameter packageDirective: KtPackageDirective defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolvePackageHeader[ValueParameterDescriptorImpl]

'packageNames' @ [48:45] ==> public final val KtPackageDirective.packageNames: (MutableList<(KtSimpleNameExpression..KtSimpleNameExpression?)>..List<(KtSimpleNameExpression..KtSimpleNameExpression?)>)[MyPropertyDescriptor]

'component1' @ [49:15] ==> public final operator fun component1(): Int defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'component2' @ [49:22] ==> public final operator fun component2(): (KtSimpleNameExpression..KtSimpleNameExpression?) defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'packageNames' @ [49:41] ==> val packageNames: (MutableList<(KtSimpleNameExpression..KtSimpleNameExpression?)>..List<(KtSimpleNameExpression..KtSimpleNameExpression?)>) defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolvePackageHeader[LocalVariableDescriptor]

'withIndex' @ [49:54] ==> public fun <T> Iterable<(KtSimpleNameExpression..KtSimpleNameExpression?)>.withIndex(): Iterable<IndexedValue<(KtSimpleNameExpression..KtSimpleNameExpression?)>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtSimpleNameExpression..org.jetbrains.kotlin.psi.KtSimpleNameExpression?)

'storeResult' @ [50:13] ==> private final fun storeResult(trace: BindingTrace, referenceExpression: KtSimpleNameExpression, descriptor: DeclarationDescriptor?, shouldBeVisibleFrom: DeclarationDescriptor?, position: QualifierPosition, isQualifier: Boolean = ...): Qualifier? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'trace' @ [50:25] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolvePackageHeader[ValueParameterDescriptorImpl]

'nameExpression' @ [50:32] ==> val nameExpression: (KtSimpleNameExpression..KtSimpleNameExpression?) defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolvePackageHeader[LocalVariableDescriptor]

'module' @ [50:48] ==> value-parameter module: ModuleDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolvePackageHeader[ValueParameterDescriptorImpl]

'getPackage' @ [50:55] ==> public abstract fun getPackage(fqName: FqName): PackageViewDescriptor defined in org.jetbrains.kotlin.descriptors.ModuleDescriptor[DeserializedSimpleFunctionDescriptor]

'packageDirective' @ [50:66] ==> value-parameter packageDirective: KtPackageDirective defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolvePackageHeader[ValueParameterDescriptorImpl]

'getFqName' @ [50:83] ==> @NotNull public open fun getFqName(nameExpression: (KtSimpleNameExpression..KtSimpleNameExpression?)): FqName defined in org.jetbrains.kotlin.psi.KtPackageDirective[JavaMethodDescriptor]

'nameExpression' @ [50:93] ==> val nameExpression: (KtSimpleNameExpression..KtSimpleNameExpression?) defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolvePackageHeader[LocalVariableDescriptor]

'PACKAGE_HEADER' @ [51:82] ==> enum entry PACKAGE_HEADER defined in org.jetbrains.kotlin.resolve.QualifierPosition[FakeCallableDescriptorForObject]

'index' @ [51:112] ==> val index: Int defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolvePackageHeader[LocalVariableDescriptor]

'packageNames' @ [51:121] ==> val packageNames: (MutableList<(KtSimpleNameExpression..KtSimpleNameExpression?)>..List<(KtSimpleNameExpression..KtSimpleNameExpression?)>) defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolvePackageHeader[LocalVariableDescriptor]

'lastIndex' @ [51:134] ==> public val <T> List<(KtSimpleNameExpression..KtSimpleNameExpression?)>.lastIndex: Int defined in kotlin.collections[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtSimpleNameExpression..org.jetbrains.kotlin.psi.KtSimpleNameExpression?)

'qualifierParts' @ [60:21] ==> public final val qualifierParts: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.TypeQualifierResolutionResult[PropertyDescriptorImpl]

'flatMap' @ [60:36] ==> public inline fun <T, R> Iterable<QualifiedExpressionResolver.QualifierPart>.flatMap(transform: (QualifiedExpressionResolver.QualifierPart) -> Iterable<(KtTypeProjection..KtTypeProjection?)>): List<(KtTypeProjection..KtTypeProjection?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> QualifierPart
    <R> -> (org.jetbrains.kotlin.psi.KtTypeProjection..org.jetbrains.kotlin.psi.KtTypeProjection?)

'it' @ [60:46] ==> value-parameter it: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.TypeQualifierResolutionResult.<get-allProjections>.<anonymous>[ValueParameterDescriptorImpl]

'typeArguments' @ [60:49] ==> public final val typeArguments: KtTypeArgumentList? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'arguments' @ [60:64] ==> public final val KtTypeArgumentList.arguments: (MutableList<(KtTypeProjection..KtTypeProjection?)>..List<(KtTypeProjection..KtTypeProjection?)>)[MyPropertyDescriptor]

'orEmpty' @ [60:74] ==> @InlineOnly public inline fun <T> List<(KtTypeProjection..KtTypeProjection?)>?.orEmpty(): List<(KtTypeProjection..KtTypeProjection?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtTypeProjection..org.jetbrains.kotlin.psi.KtTypeProjection?)

'if (!isDebuggerContext) scope.ownerDescriptor else null' @ [69:31] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: DeclarationDescriptor?, elseBranch: DeclarationDescriptor?): DeclarationDescriptor?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> DeclarationDescriptor?

'!' @ [69:35] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isDebuggerContext' @ [69:36] ==> value-parameter isDebuggerContext: Boolean defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType[ValueParameterDescriptorImpl]

'scope' @ [69:55] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType[ValueParameterDescriptorImpl]

'ownerDescriptor' @ [69:61] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'userType' @ [70:13] ==> value-parameter userType: KtUserType defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType[ValueParameterDescriptorImpl]

'qualifier' @ [70:22] ==> public final val KtUserType.qualifier: KtUserType?[MyPropertyDescriptor]

'userType' @ [71:30] ==> value-parameter userType: KtUserType defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType[ValueParameterDescriptorImpl]

'referenceExpression' @ [71:39] ==> public final val KtUserType.referenceExpression: KtSimpleNameExpression?[MyPropertyDescriptor]

'let' @ [71:60] ==> @InlineOnly public inline fun <T, R> KtSimpleNameExpression.let(block: (KtSimpleNameExpression) -> ClassifierDescriptor?): ClassifierDescriptor? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtSimpleNameExpression
    <R> -> ClassifierDescriptor?

'scope' @ [72:34] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType[ValueParameterDescriptorImpl]

'findClassifier' @ [72:40] ==> public fun HierarchicalScope.findClassifier(name: Name, location: LookupLocation): ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.scopes.utils[DeserializedSimpleFunctionDescriptor]

'expression' @ [72:55] ==> value-parameter expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType.<anonymous>[ValueParameterDescriptorImpl]

'getReferencedNameAsName' @ [72:66] ==> public abstract fun getReferencedNameAsName(): Name defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[SimpleFunctionDescriptorImpl]

'KotlinLookupLocation' @ [72:93] ==> public constructor KotlinLookupLocation(element: KtElement) defined in org.jetbrains.kotlin.incremental.KotlinLookupLocation[ClassConstructorDescriptorImpl]

'expression' @ [72:114] ==> value-parameter expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType.<anonymous>[ValueParameterDescriptorImpl]

'checkNotEnumEntry' @ [73:17] ==> private final fun checkNotEnumEntry(descriptor: DeclarationDescriptor?, trace: BindingTrace, expression: KtSimpleNameExpression): Unit defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'classifier' @ [73:35] ==> val classifier: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType.<anonymous>[LocalVariableDescriptor]

'trace' @ [73:47] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType[ValueParameterDescriptorImpl]

'expression' @ [73:54] ==> value-parameter expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType.<anonymous>[ValueParameterDescriptorImpl]

'storeResult' @ [74:17] ==> private final fun storeResult(trace: BindingTrace, referenceExpression: KtSimpleNameExpression, descriptor: DeclarationDescriptor?, shouldBeVisibleFrom: DeclarationDescriptor?, position: QualifierPosition, isQualifier: Boolean = ...): Qualifier? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'trace' @ [74:29] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType[ValueParameterDescriptorImpl]

'expression' @ [74:36] ==> value-parameter expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType.<anonymous>[ValueParameterDescriptorImpl]

'classifier' @ [74:48] ==> val classifier: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType.<anonymous>[LocalVariableDescriptor]

'ownerDescriptor' @ [74:60] ==> val ownerDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType[LocalVariableDescriptor]

'TYPE' @ [74:106] ==> enum entry TYPE defined in org.jetbrains.kotlin.resolve.QualifierPosition[FakeCallableDescriptorForObject]

'classifier' @ [75:17] ==> val classifier: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType.<anonymous>[LocalVariableDescriptor]

'TypeQualifierResolutionResult' @ [78:20] ==> public constructor TypeQualifierResolutionResult(qualifierParts: List<QualifiedExpressionResolver.QualifierPart>, classifierDescriptor: ClassifierDescriptor? = ...) defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.TypeQualifierResolutionResult[ClassConstructorDescriptorImpl]

'userType' @ [78:50] ==> value-parameter userType: KtUserType defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType[ValueParameterDescriptorImpl]

'asQualifierPartList' @ [78:59] ==> private final fun KtUserType.asQualifierPartList(): Pair<List<QualifiedExpressionResolver.QualifierPart>, Boolean> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'first' @ [78:81] ==> public final val first: List<QualifiedExpressionResolver.QualifierPart> defined in kotlin.Pair[DeserializedPropertyDescriptor]

'descriptor' @ [78:88] ==> val descriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType[LocalVariableDescriptor]

'component1' @ [81:14] ==> public final operator fun component1(): List<QualifiedExpressionResolver.QualifierPart> defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [81:33] ==> public final operator fun component2(): Boolean defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'userType' @ [81:45] ==> value-parameter userType: KtUserType defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType[ValueParameterDescriptorImpl]

'asQualifierPartList' @ [81:54] ==> private final fun KtUserType.asQualifierPartList(): Pair<List<QualifiedExpressionResolver.QualifierPart>, Boolean> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'hasError' @ [82:13] ==> val hasError: Boolean defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType[LocalVariableDescriptor]

'resolveToPackageOrClass' @ [83:30] ==> private final fun resolveToPackageOrClass(path: List<QualifiedExpressionResolver.QualifierPart>, moduleDescriptor: ModuleDescriptor, trace: BindingTrace, shouldBeVisibleFrom: DeclarationDescriptor?, scopeForFirstPart: LexicalScope?, position: QualifierPosition): DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'qualifierPartList' @ [84:21] ==> val qualifierPartList: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType[LocalVariableDescriptor]

'scope' @ [84:40] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType[ValueParameterDescriptorImpl]

'ownerDescriptor' @ [84:46] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'module' @ [84:62] ==> public val DeclarationDescriptor.module: ModuleDescriptor defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'trace' @ [84:70] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType[ValueParameterDescriptorImpl]

'ownerDescriptor' @ [84:77] ==> val ownerDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType[LocalVariableDescriptor]

'scope' @ [84:94] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType[ValueParameterDescriptorImpl]

'TYPE' @ [84:130] ==> enum entry TYPE defined in org.jetbrains.kotlin.resolve.QualifierPosition[FakeCallableDescriptorForObject]

'TypeQualifierResolutionResult' @ [86:20] ==> public constructor TypeQualifierResolutionResult(qualifierParts: List<QualifiedExpressionResolver.QualifierPart>, classifierDescriptor: ClassifierDescriptor? = ...) defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.TypeQualifierResolutionResult[ClassConstructorDescriptorImpl]

'qualifierPartList' @ [86:50] ==> val qualifierPartList: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType[LocalVariableDescriptor]

'descriptor' @ [86:69] ==> val descriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType[LocalVariableDescriptor]

'resolveQualifierPartListForType' @ [89:16] ==> private final fun resolveQualifierPartListForType(qualifierPartList: List<QualifiedExpressionResolver.QualifierPart>, ownerDescriptor: DeclarationDescriptor?, scope: LexicalScope, trace: BindingTrace, isQualifier: Boolean): QualifiedExpressionResolver.TypeQualifierResolutionResult defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'qualifierPartList' @ [89:48] ==> val qualifierPartList: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType[LocalVariableDescriptor]

'ownerDescriptor' @ [89:67] ==> val ownerDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType[LocalVariableDescriptor]

'scope' @ [89:84] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType[ValueParameterDescriptorImpl]

'trace' @ [89:91] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForType[ValueParameterDescriptorImpl]

'assert' @ [99:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'qualifierPartList' @ [99:16] ==> value-parameter qualifierPartList: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[ValueParameterDescriptorImpl]

'isNotEmpty' @ [99:34] ==> @InlineOnly public inline fun <T> Collection<QualifiedExpressionResolver.QualifierPart>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> QualifierPart

'resolveToPackageOrClass' @ [101:25] ==> private final fun resolveToPackageOrClass(path: List<QualifiedExpressionResolver.QualifierPart>, moduleDescriptor: ModuleDescriptor, trace: BindingTrace, shouldBeVisibleFrom: DeclarationDescriptor?, scopeForFirstPart: LexicalScope?, position: QualifierPosition): DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'qualifierPartList' @ [102:17] ==> value-parameter qualifierPartList: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[ValueParameterDescriptorImpl]

'subList' @ [102:35] ==> public abstract fun subList(fromIndex: Int, toIndex: Int): List<QualifiedExpressionResolver.QualifierPart> defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'qualifierPartList' @ [102:46] ==> value-parameter qualifierPartList: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[ValueParameterDescriptorImpl]

'size' @ [102:64] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'scope' @ [103:17] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[ValueParameterDescriptorImpl]

'ownerDescriptor' @ [103:23] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'module' @ [103:39] ==> public val DeclarationDescriptor.module: ModuleDescriptor defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'trace' @ [103:47] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[ValueParameterDescriptorImpl]

'ownerDescriptor' @ [103:54] ==> value-parameter ownerDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[ValueParameterDescriptorImpl]

'scope' @ [103:71] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[ValueParameterDescriptorImpl]

'TYPE' @ [104:46] ==> enum entry TYPE defined in org.jetbrains.kotlin.resolve.QualifierPosition[FakeCallableDescriptorForObject]

'TypeQualifierResolutionResult' @ [105:21] ==> public constructor TypeQualifierResolutionResult(qualifierParts: List<QualifiedExpressionResolver.QualifierPart>, classifierDescriptor: ClassifierDescriptor? = ...) defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.TypeQualifierResolutionResult[ClassConstructorDescriptorImpl]

'qualifierPartList' @ [105:51] ==> value-parameter qualifierPartList: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[ValueParameterDescriptorImpl]

'qualifierPartList' @ [107:24] ==> value-parameter qualifierPartList: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[ValueParameterDescriptorImpl]

'last' @ [107:42] ==> public fun <T> List<QualifiedExpressionResolver.QualifierPart>.last(): QualifiedExpressionResolver.QualifierPart defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> QualifierPart

'when (qualifier) {
            is PackageViewDescriptor -> qualifier.memberScope.getContributedClassifier(lastPart.name, lastPart.location)
            is ClassDescriptor -> {
                val descriptor = qualifier.unsubstitutedInnerClassesScope.getContributedClassifier(lastPart.name, lastPart.location)
                checkNotEnumEntry(descriptor, trace, lastPart.expression)
                descriptor
            }
            else -> null
        }' @ [108:26] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: ClassifierDescriptor?, entry1: ClassifierDescriptor?, entry2: ClassifierDescriptor?): ClassifierDescriptor?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> ClassifierDescriptor?

'qualifier' @ [108:32] ==> val qualifier: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[LocalVariableDescriptor]

'qualifier' @ [109:41] ==> val qualifier: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[LocalVariableDescriptor]

'memberScope' @ [109:51] ==> public abstract val memberScope: MemberScope defined in org.jetbrains.kotlin.descriptors.PackageViewDescriptor[DeserializedPropertyDescriptor]

'getContributedClassifier' @ [109:63] ==> public abstract fun getContributedClassifier(name: Name, location: LookupLocation): ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.scopes.MemberScope[DeserializedSimpleFunctionDescriptor]

'lastPart' @ [109:88] ==> val lastPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[LocalVariableDescriptor]

'name' @ [109:97] ==> public final val name: Name defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'lastPart' @ [109:103] ==> val lastPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[LocalVariableDescriptor]

'location' @ [109:112] ==> public final val location: KotlinLookupLocation defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'qualifier' @ [111:34] ==> val qualifier: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[LocalVariableDescriptor]

'unsubstitutedInnerClassesScope' @ [111:44] ==> public final val ClassDescriptor.unsubstitutedInnerClassesScope: MemberScope[MyPropertyDescriptor]

'getContributedClassifier' @ [111:75] ==> public abstract fun getContributedClassifier(name: Name, location: LookupLocation): ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.scopes.MemberScope[DeserializedSimpleFunctionDescriptor]

'lastPart' @ [111:100] ==> val lastPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[LocalVariableDescriptor]

'name' @ [111:109] ==> public final val name: Name defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'lastPart' @ [111:115] ==> val lastPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[LocalVariableDescriptor]

'location' @ [111:124] ==> public final val location: KotlinLookupLocation defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'checkNotEnumEntry' @ [112:17] ==> private final fun checkNotEnumEntry(descriptor: DeclarationDescriptor?, trace: BindingTrace, expression: KtSimpleNameExpression): Unit defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'descriptor' @ [112:35] ==> val descriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[LocalVariableDescriptor]

'trace' @ [112:47] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[ValueParameterDescriptorImpl]

'lastPart' @ [112:54] ==> val lastPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[LocalVariableDescriptor]

'expression' @ [112:63] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'descriptor' @ [113:17] ==> val descriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[LocalVariableDescriptor]

'storeResult' @ [117:9] ==> private final fun storeResult(trace: BindingTrace, referenceExpression: KtSimpleNameExpression, descriptor: DeclarationDescriptor?, shouldBeVisibleFrom: DeclarationDescriptor?, position: QualifierPosition, isQualifier: Boolean = ...): Qualifier? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'trace' @ [117:21] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[ValueParameterDescriptorImpl]

'lastPart' @ [117:28] ==> val lastPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[LocalVariableDescriptor]

'expression' @ [117:37] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'classifier' @ [117:49] ==> val classifier: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[LocalVariableDescriptor]

'ownerDescriptor' @ [117:61] ==> value-parameter ownerDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[ValueParameterDescriptorImpl]

'TYPE' @ [117:107] ==> enum entry TYPE defined in org.jetbrains.kotlin.resolve.QualifierPosition[FakeCallableDescriptorForObject]

'isQualifier' @ [117:127] ==> value-parameter isQualifier: Boolean defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[ValueParameterDescriptorImpl]

'TypeQualifierResolutionResult' @ [118:16] ==> public constructor TypeQualifierResolutionResult(qualifierParts: List<QualifiedExpressionResolver.QualifierPart>, classifierDescriptor: ClassifierDescriptor? = ...) defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.TypeQualifierResolutionResult[ClassConstructorDescriptorImpl]

'qualifierPartList' @ [118:46] ==> value-parameter qualifierPartList: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[ValueParameterDescriptorImpl]

'classifier' @ [118:65] ==> val classifier: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierPartListForType[LocalVariableDescriptor]

'descriptor' @ [122:13] ==> value-parameter descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.checkNotEnumEntry[ValueParameterDescriptorImpl]

'isEnumEntry' @ [122:51] ==> public open fun isEnumEntry(@NotNull p0: DeclarationDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'descriptor' @ [122:63] ==> value-parameter descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.checkNotEnumEntry[ValueParameterDescriptorImpl]

'expression' @ [123:35] ==> value-parameter expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.checkNotEnumEntry[ValueParameterDescriptorImpl]

'getTopmostParentQualifiedExpressionForSelector' @ [123:46] ==> public fun KtSimpleNameExpression.getTopmostParentQualifiedExpressionForSelector(): KtQualifiedExpression? defined in org.jetbrains.kotlin.psi.psiUtil in file ktPsiUtil.kt[SimpleFunctionDescriptorImpl]

'qualifiedParent' @ [124:17] ==> val qualifiedParent: KtQualifiedExpression? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.checkNotEnumEntry[LocalVariableDescriptor]

'qualifiedParent' @ [124:44] ==> val qualifiedParent: KtQualifiedExpression? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.checkNotEnumEntry[LocalVariableDescriptor]

'parent' @ [124:60] ==> public final val KtQualifiedExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'trace' @ [125:17] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.checkNotEnumEntry[ValueParameterDescriptorImpl]

'report' @ [125:23] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'ENUM_ENTRY_AS_TYPE' @ [125:37] ==> public final val ENUM_ENTRY_AS_TYPE: (DiagnosticFactory0<(KtSimpleNameExpression..KtSimpleNameExpression?)>..DiagnosticFactory0<(KtSimpleNameExpression..KtSimpleNameExpression?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [125:56] ==> @NotNull public open fun on(@NotNull element: KtSimpleNameExpression): SimpleDiagnostic<(KtSimpleNameExpression..KtSimpleNameExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'expression' @ [125:59] ==> value-parameter expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.checkNotEnumEntry[ValueParameterDescriptorImpl]

'if (!isDebuggerContext) scope.ownerDescriptor else null' @ [136:31] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: DeclarationDescriptor?, elseBranch: DeclarationDescriptor?): DeclarationDescriptor?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> DeclarationDescriptor?

'!' @ [136:35] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isDebuggerContext' @ [136:36] ==> value-parameter isDebuggerContext: Boolean defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForDoubleColonLHS[ValueParameterDescriptorImpl]

'scope' @ [136:55] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForDoubleColonLHS[ValueParameterDescriptorImpl]

'ownerDescriptor' @ [136:61] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'expression' @ [138:33] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForDoubleColonLHS[ValueParameterDescriptorImpl]

'asQualifierPartList' @ [138:44] ==> private final fun KtExpression.asQualifierPartList(doubleColonLHS: Boolean = ...): List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'qualifierPartList' @ [139:13] ==> val qualifierPartList: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForDoubleColonLHS[LocalVariableDescriptor]

'isEmpty' @ [139:31] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'TypeQualifierResolutionResult' @ [140:20] ==> public constructor TypeQualifierResolutionResult(qualifierParts: List<QualifiedExpressionResolver.QualifierPart>, classifierDescriptor: ClassifierDescriptor? = ...) defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.TypeQualifierResolutionResult[ClassConstructorDescriptorImpl]

'qualifierPartList' @ [140:50] ==> val qualifierPartList: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForDoubleColonLHS[LocalVariableDescriptor]

'qualifierPartList' @ [143:13] ==> val qualifierPartList: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForDoubleColonLHS[LocalVariableDescriptor]

'size' @ [143:31] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'component1' @ [144:18] ==> public final operator fun component1(): Name defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[SimpleFunctionDescriptorImpl]

'component2' @ [144:24] ==> public final operator fun component2(): KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[SimpleFunctionDescriptorImpl]

'qualifierPartList' @ [144:38] ==> val qualifierPartList: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForDoubleColonLHS[LocalVariableDescriptor]

'single' @ [144:56] ==> public fun <T> List<QualifiedExpressionResolver.QualifierPart>.single(): QualifiedExpressionResolver.QualifierPart defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> QualifierPart

'scope' @ [145:30] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForDoubleColonLHS[ValueParameterDescriptorImpl]

'findClassifier' @ [145:36] ==> public fun HierarchicalScope.findClassifier(name: Name, location: LookupLocation): ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.scopes.utils[DeserializedSimpleFunctionDescriptor]

'name' @ [145:51] ==> val name: Name defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForDoubleColonLHS[LocalVariableDescriptor]

'KotlinLookupLocation' @ [145:57] ==> public constructor KotlinLookupLocation(element: KtElement) defined in org.jetbrains.kotlin.incremental.KotlinLookupLocation[ClassConstructorDescriptorImpl]

'simpleName' @ [145:78] ==> val simpleName: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForDoubleColonLHS[LocalVariableDescriptor]

'storeResult' @ [146:13] ==> private final fun storeResult(trace: BindingTrace, referenceExpression: KtSimpleNameExpression, descriptor: DeclarationDescriptor?, shouldBeVisibleFrom: DeclarationDescriptor?, position: QualifierPosition, isQualifier: Boolean = ...): Qualifier? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'trace' @ [146:25] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForDoubleColonLHS[ValueParameterDescriptorImpl]

'simpleName' @ [146:32] ==> val simpleName: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForDoubleColonLHS[LocalVariableDescriptor]

'descriptor' @ [146:44] ==> val descriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForDoubleColonLHS[LocalVariableDescriptor]

'ownerDescriptor' @ [146:56] ==> val ownerDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForDoubleColonLHS[LocalVariableDescriptor]

'TYPE' @ [146:102] ==> enum entry TYPE defined in org.jetbrains.kotlin.resolve.QualifierPosition[FakeCallableDescriptorForObject]

'TypeQualifierResolutionResult' @ [147:20] ==> public constructor TypeQualifierResolutionResult(qualifierParts: List<QualifiedExpressionResolver.QualifierPart>, classifierDescriptor: ClassifierDescriptor? = ...) defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.TypeQualifierResolutionResult[ClassConstructorDescriptorImpl]

'qualifierPartList' @ [147:50] ==> val qualifierPartList: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForDoubleColonLHS[LocalVariableDescriptor]

'descriptor' @ [147:69] ==> val descriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForDoubleColonLHS[LocalVariableDescriptor]

'resolveQualifierPartListForType' @ [150:16] ==> private final fun resolveQualifierPartListForType(qualifierPartList: List<QualifiedExpressionResolver.QualifierPart>, ownerDescriptor: DeclarationDescriptor?, scope: LexicalScope, trace: BindingTrace, isQualifier: Boolean): QualifiedExpressionResolver.TypeQualifierResolutionResult defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'qualifierPartList' @ [150:48] ==> val qualifierPartList: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForDoubleColonLHS[LocalVariableDescriptor]

'ownerDescriptor' @ [150:67] ==> val ownerDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForDoubleColonLHS[LocalVariableDescriptor]

'scope' @ [150:84] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForDoubleColonLHS[ValueParameterDescriptorImpl]

'trace' @ [150:91] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveDescriptorForDoubleColonLHS[ValueParameterDescriptorImpl]

'SmartList' @ [155:22] ==> public constructor SmartList<E : (Any..Any?)>() defined in com.intellij.util.SmartList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> QualifierPart

'this' @ [156:37] ==> <this> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[ReceiverParameterDescriptorImpl]

'userType' @ [157:16] ==> var userType: KtUserType? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[LocalVariableDescriptor]

'userType' @ [158:39] ==> var userType: KtUserType? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[LocalVariableDescriptor]

'referenceExpression' @ [158:48] ==> public final val KtUserType.referenceExpression: KtSimpleNameExpression?[MyPropertyDescriptor]

'if (referenceExpression != null) {
                result.add(QualifierPart(referenceExpression.getReferencedNameAsName(), referenceExpression, userType.typeArgumentList))
            }
            else {
                hasError = true
            }' @ [159:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any, elseBranch: Any): Any[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any

'referenceExpression' @ [159:17] ==> val referenceExpression: KtSimpleNameExpression? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[LocalVariableDescriptor]

'result' @ [160:17] ==> val result: SmartList<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[LocalVariableDescriptor]

'add' @ [160:24] ==> public open fun add(element: (QualifiedExpressionResolver.QualifierPart..QualifiedExpressionResolver.QualifierPart?)): Boolean defined in com.intellij.util.SmartList[JavaMethodDescriptor]

'QualifierPart' @ [160:28] ==> public constructor QualifierPart(name: Name, expression: KtSimpleNameExpression, typeArguments: KtTypeArgumentList? = ...) defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[ClassConstructorDescriptorImpl]

'referenceExpression' @ [160:42] ==> val referenceExpression: KtSimpleNameExpression? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[LocalVariableDescriptor]

'getReferencedNameAsName' @ [160:62] ==> public abstract fun getReferencedNameAsName(): Name defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[SimpleFunctionDescriptorImpl]

'referenceExpression' @ [160:89] ==> val referenceExpression: KtSimpleNameExpression? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[LocalVariableDescriptor]

'userType' @ [160:110] ==> var userType: KtUserType? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[LocalVariableDescriptor]

'typeArgumentList' @ [160:119] ==> public final val KtUserType.typeArgumentList: KtTypeArgumentList?[MyPropertyDescriptor]

'hasError' @ [163:17] ==> var hasError: Boolean defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[LocalVariableDescriptor]

'userType' @ [165:13] ==> var userType: KtUserType? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[LocalVariableDescriptor]

'userType' @ [165:24] ==> var userType: KtUserType? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[LocalVariableDescriptor]

'qualifier' @ [165:33] ==> public final val KtUserType.qualifier: KtUserType?[MyPropertyDescriptor]

'result' @ [167:16] ==> val result: SmartList<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[LocalVariableDescriptor]

'asReversed' @ [167:23] ==> @JvmName public fun <T> MutableList<(QualifiedExpressionResolver.QualifierPart..QualifiedExpressionResolver.QualifierPart?)>.asReversed(): MutableList<(QualifiedExpressionResolver.QualifierPart..QualifiedExpressionResolver.QualifierPart?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart..org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart?)

'hasError' @ [167:39] ==> var hasError: Boolean defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[LocalVariableDescriptor]

'importDirective' @ [177:33] ==> value-parameter importDirective: KtImportDirective defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[ValueParameterDescriptorImpl]

'importedReference' @ [177:49] ==> public final val KtImportDirective.importedReference: KtExpression?[MyPropertyDescriptor]

'importedReference' @ [178:20] ==> val importedReference: KtExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[LocalVariableDescriptor]

'asQualifierPartList' @ [178:38] ==> private final fun KtExpression.asQualifierPartList(doubleColonLHS: Boolean = ...): List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'path' @ [179:24] ==> val path: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[LocalVariableDescriptor]

'lastOrNull' @ [179:29] ==> public fun <T> List<QualifiedExpressionResolver.QualifierPart>.lastOrNull(): QualifiedExpressionResolver.QualifierPart? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> QualifierPart

'when {
                    importDirective.suppressDiagnosticsInDebugMode() -> null
                    packageFragmentForVisibilityCheck is DeclarationDescriptorWithSource && packageFragmentForVisibilityCheck.source == SourceElement.NO_SOURCE -> {
                        PackageFragmentWithCustomSource(packageFragmentForVisibilityCheck, KotlinSourceElement(importDirective.containingKtFile))
                    }
                    else -> packageFragmentForVisibilityCheck
                }' @ [181:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: PackageFragmentDescriptor?, entry1: PackageFragmentDescriptor?, entry2: PackageFragmentDescriptor?): PackageFragmentDescriptor?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> PackageFragmentDescriptor?

'importDirective' @ [182:21] ==> value-parameter importDirective: KtImportDirective defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[ValueParameterDescriptorImpl]

'suppressDiagnosticsInDebugMode' @ [182:37] ==> public fun KtElement.suppressDiagnosticsInDebugMode(): Boolean defined in org.jetbrains.kotlin.psi.codeFragmentUtil in file codeFragmentUtil.kt[SimpleFunctionDescriptorImpl]

'packageFragmentForVisibilityCheck' @ [183:21] ==> value-parameter packageFragmentForVisibilityCheck: PackageFragmentDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[ValueParameterDescriptorImpl]

'packageFragmentForVisibilityCheck' @ [183:93] ==> value-parameter packageFragmentForVisibilityCheck: PackageFragmentDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[ValueParameterDescriptorImpl]

'source' @ [183:127] ==> public final val PackageFragmentDescriptor.source: SourceElement[MyPropertyDescriptor]

'NO_SOURCE' @ [183:151] ==> public final val NO_SOURCE: (SourceElement..SourceElement?) defined in org.jetbrains.kotlin.descriptors.SourceElement[JavaPropertyDescriptor]

'PackageFragmentWithCustomSource' @ [184:25] ==> public constructor PackageFragmentWithCustomSource(original: PackageFragmentDescriptor, source: SourceElement) defined in org.jetbrains.kotlin.resolve.PackageFragmentWithCustomSource[ClassConstructorDescriptorImpl]

'packageFragmentForVisibilityCheck' @ [184:57] ==> value-parameter packageFragmentForVisibilityCheck: PackageFragmentDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[ValueParameterDescriptorImpl]

'KotlinSourceElement' @ [184:92] ==> public constructor KotlinSourceElement(psi: KtElement) defined in org.jetbrains.kotlin.resolve.source.KotlinSourceElement[ClassConstructorDescriptorImpl]

'importDirective' @ [184:112] ==> value-parameter importDirective: KtImportDirective defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[ValueParameterDescriptorImpl]

'containingKtFile' @ [184:128] ==> public final val KtImportDirective.containingKtFile: KtFile[MyPropertyDescriptor]

'packageFragmentForVisibilityCheck' @ [186:29] ==> value-parameter packageFragmentForVisibilityCheck: PackageFragmentDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[ValueParameterDescriptorImpl]

'if (importDirective.isAllUnder) {
            val packageOrClassDescriptor = resolveToPackageOrClass(path, moduleDescriptor, trace, packageFragmentForCheck,
                                                                   scopeForFirstPart = null, position = QualifierPosition.IMPORT) ?: return null

            if (packageOrClassDescriptor is ClassDescriptor && packageOrClassDescriptor.kind.isSingleton) {
                trace.report(Errors.CANNOT_ALL_UNDER_IMPORT_FROM_SINGLETON.on(lastPart.expression, packageOrClassDescriptor)) // todo report on star
                return null
            }

            return AllUnderImportScope(packageOrClassDescriptor, excludedImportNames)
        }
        else {
            return processSingleImport(moduleDescriptor, trace, importDirective, path, lastPart, packageFragmentForCheck)
        }' @ [189:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nothing, elseBranch: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nothing

'importDirective' @ [189:13] ==> value-parameter importDirective: KtImportDirective defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[ValueParameterDescriptorImpl]

'isAllUnder' @ [189:29] ==> public final val KtImportDirective.isAllUnder: Boolean[MyPropertyDescriptor]

'resolveToPackageOrClass' @ [190:44] ==> private final fun resolveToPackageOrClass(path: List<QualifiedExpressionResolver.QualifierPart>, moduleDescriptor: ModuleDescriptor, trace: BindingTrace, shouldBeVisibleFrom: DeclarationDescriptor?, scopeForFirstPart: LexicalScope?, position: QualifierPosition): DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'path' @ [190:68] ==> val path: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[LocalVariableDescriptor]

'moduleDescriptor' @ [190:74] ==> value-parameter moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[ValueParameterDescriptorImpl]

'trace' @ [190:92] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[ValueParameterDescriptorImpl]

'packageFragmentForCheck' @ [190:99] ==> val packageFragmentForCheck: PackageFragmentDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[LocalVariableDescriptor]

'IMPORT' @ [191:123] ==> enum entry IMPORT defined in org.jetbrains.kotlin.resolve.QualifierPosition[FakeCallableDescriptorForObject]

'packageOrClassDescriptor' @ [193:17] ==> val packageOrClassDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[LocalVariableDescriptor]

'packageOrClassDescriptor' @ [193:64] ==> val packageOrClassDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[LocalVariableDescriptor]

'kind' @ [193:89] ==> public final val ClassDescriptor.kind: ClassKind[MyPropertyDescriptor]

'isSingleton' @ [193:94] ==> public final val ClassKind.isSingleton: Boolean[MyPropertyDescriptor]

'trace' @ [194:17] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[ValueParameterDescriptorImpl]

'report' @ [194:23] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'CANNOT_ALL_UNDER_IMPORT_FROM_SINGLETON' @ [194:37] ==> public final val CANNOT_ALL_UNDER_IMPORT_FROM_SINGLETON: (DiagnosticFactory1<(KtSimpleNameExpression..KtSimpleNameExpression?), (ClassDescriptor..ClassDescriptor?)>..DiagnosticFactory1<(KtSimpleNameExpression..KtSimpleNameExpression?), (ClassDescriptor..ClassDescriptor?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [194:76] ==> @NotNull public open fun on(@NotNull element: KtSimpleNameExpression, @NotNull argument: ClassDescriptor): ParametrizedDiagnostic<(KtSimpleNameExpression..KtSimpleNameExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory1[JavaMethodDescriptor]

'lastPart' @ [194:79] ==> val lastPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[LocalVariableDescriptor]

'expression' @ [194:88] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'packageOrClassDescriptor' @ [194:100] ==> val packageOrClassDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[LocalVariableDescriptor]

'AllUnderImportScope' @ [198:20] ==> public constructor AllUnderImportScope(descriptor: DeclarationDescriptor, excludedImportNames: Collection<FqName>) defined in org.jetbrains.kotlin.resolve.AllUnderImportScope[ClassConstructorDescriptorImpl]

'packageOrClassDescriptor' @ [198:40] ==> val packageOrClassDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[LocalVariableDescriptor]

'excludedImportNames' @ [198:66] ==> value-parameter excludedImportNames: Collection<FqName> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[ValueParameterDescriptorImpl]

'processSingleImport' @ [201:20] ==> private final fun processSingleImport(moduleDescriptor: ModuleDescriptor, trace: BindingTrace, importDirective: KtImportDirective, path: List<QualifiedExpressionResolver.QualifierPart>, lastPart: QualifiedExpressionResolver.QualifierPart, packageFragmentForVisibilityCheck: PackageFragmentDescriptor?): ImportingScope? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'moduleDescriptor' @ [201:40] ==> value-parameter moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[ValueParameterDescriptorImpl]

'trace' @ [201:58] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[ValueParameterDescriptorImpl]

'importDirective' @ [201:65] ==> value-parameter importDirective: KtImportDirective defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[ValueParameterDescriptorImpl]

'path' @ [201:82] ==> val path: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[LocalVariableDescriptor]

'lastPart' @ [201:88] ==> val lastPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[LocalVariableDescriptor]

'packageFragmentForCheck' @ [201:98] ==> val packageFragmentForCheck: PackageFragmentDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processImportReference[LocalVariableDescriptor]

'getAliasName' @ [213:35] ==> @Nullable public open fun getAliasName(@NotNull importDirective: KtImportDirective): Name? defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'importDirective' @ [213:48] ==> value-parameter importDirective: KtImportDirective defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport[ValueParameterDescriptorImpl]

'aliasName' @ [214:13] ==> val aliasName: Name? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport[LocalVariableDescriptor]

'resolveToPackageOrClass' @ [216:13] ==> private final fun resolveToPackageOrClass(path: List<QualifiedExpressionResolver.QualifierPart>, moduleDescriptor: ModuleDescriptor, trace: BindingTrace, shouldBeVisibleFrom: DeclarationDescriptor?, scopeForFirstPart: LexicalScope?, position: QualifierPosition): DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'path' @ [216:37] ==> value-parameter path: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport[ValueParameterDescriptorImpl]

'moduleDescriptor' @ [216:43] ==> value-parameter moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport[ValueParameterDescriptorImpl]

'trace' @ [216:61] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport[ValueParameterDescriptorImpl]

'packageFragmentForVisibilityCheck' @ [216:68] ==> value-parameter packageFragmentForVisibilityCheck: PackageFragmentDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport[ValueParameterDescriptorImpl]

'IMPORT' @ [216:158] ==> enum entry IMPORT defined in org.jetbrains.kotlin.resolve.QualifierPosition[FakeCallableDescriptorForObject]

'resolveToPackageOrClass' @ [220:34] ==> private final fun resolveToPackageOrClass(path: List<QualifiedExpressionResolver.QualifierPart>, moduleDescriptor: ModuleDescriptor, trace: BindingTrace, shouldBeVisibleFrom: DeclarationDescriptor?, scopeForFirstPart: LexicalScope?, position: QualifierPosition): DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'path' @ [221:17] ==> value-parameter path: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport[ValueParameterDescriptorImpl]

'subList' @ [221:22] ==> public abstract fun subList(fromIndex: Int, toIndex: Int): List<QualifiedExpressionResolver.QualifierPart> defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'path' @ [221:33] ==> value-parameter path: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport[ValueParameterDescriptorImpl]

'size' @ [221:38] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'moduleDescriptor' @ [221:49] ==> value-parameter moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport[ValueParameterDescriptorImpl]

'trace' @ [221:67] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport[ValueParameterDescriptorImpl]

'packageFragmentForVisibilityCheck' @ [222:17] ==> value-parameter packageFragmentForVisibilityCheck: PackageFragmentDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport[ValueParameterDescriptorImpl]

'IMPORT' @ [222:107] ==> enum entry IMPORT defined in org.jetbrains.kotlin.resolve.QualifierPosition[FakeCallableDescriptorForObject]

'?:' @ [225:40] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: DeclarationDescriptor?, right: DeclarationDescriptor): DeclarationDescriptor[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> DeclarationDescriptor

'resolvedDescriptor' @ [225:41] ==> val resolvedDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport[LocalVariableDescriptor]

'let' @ [225:86] ==> @InlineOnly public inline fun <T, R> TypeAliasDescriptor.let(block: (TypeAliasDescriptor) -> ClassDescriptor): ClassDescriptor defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeAliasDescriptor
    <R> -> ClassDescriptor

'it' @ [225:92] ==> value-parameter it: TypeAliasDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport.<anonymous>[ValueParameterDescriptorImpl]

'classDescriptor' @ [225:95] ==> public abstract val classDescriptor: ClassDescriptor? defined in org.jetbrains.kotlin.descriptors.TypeAliasDescriptor[DeserializedPropertyDescriptor]

'resolvedDescriptor' @ [225:131] ==> val resolvedDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport[LocalVariableDescriptor]

'LazyExplicitImportScope' @ [227:16] ==> public constructor LazyExplicitImportScope(packageOrClassDescriptor: DeclarationDescriptor, packageFragmentForVisibilityCheck: PackageFragmentDescriptor?, declaredName: Name, aliasName: Name, storeReferences: (Collection<DeclarationDescriptor>) -> Unit) defined in org.jetbrains.kotlin.resolve.LazyExplicitImportScope[ClassConstructorDescriptorImpl]

'packageOrClassDescriptor' @ [227:40] ==> val packageOrClassDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport[LocalVariableDescriptor]

'packageFragmentForVisibilityCheck' @ [227:66] ==> value-parameter packageFragmentForVisibilityCheck: PackageFragmentDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport[ValueParameterDescriptorImpl]

'lastPart' @ [227:101] ==> value-parameter lastPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport[ValueParameterDescriptorImpl]

'name' @ [227:110] ==> public final val name: Name defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'aliasName' @ [227:116] ==> val aliasName: Name? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport[LocalVariableDescriptor]

'if (candidates.isNotEmpty()) {
                storeResult(trace, lastPart.expression, candidates, packageFragmentForVisibilityCheck, position = QualifierPosition.IMPORT, isQualifier = false)
            }
            else {
                tryResolveDescriptorsWhichCannotBeImported(trace, moduleDescriptor, packageOrClassDescriptor, lastPart)
            }' @ [230:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'candidates' @ [230:17] ==> value-parameter candidates: Collection<DeclarationDescriptor> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport.<anonymous>[ValueParameterDescriptorImpl]

'isNotEmpty' @ [230:28] ==> @InlineOnly public inline fun <T> Collection<DeclarationDescriptor>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DeclarationDescriptor

'storeResult' @ [231:17] ==> private final fun storeResult(trace: BindingTrace, referenceExpression: KtSimpleNameExpression, descriptors: Collection<DeclarationDescriptor>, shouldBeVisibleFrom: DeclarationDescriptor?, position: QualifierPosition, isQualifier: Boolean = ...): Unit defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'trace' @ [231:29] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport[ValueParameterDescriptorImpl]

'lastPart' @ [231:36] ==> value-parameter lastPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport[ValueParameterDescriptorImpl]

'expression' @ [231:45] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'candidates' @ [231:57] ==> value-parameter candidates: Collection<DeclarationDescriptor> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport.<anonymous>[ValueParameterDescriptorImpl]

'packageFragmentForVisibilityCheck' @ [231:69] ==> value-parameter packageFragmentForVisibilityCheck: PackageFragmentDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport[ValueParameterDescriptorImpl]

'IMPORT' @ [231:133] ==> enum entry IMPORT defined in org.jetbrains.kotlin.resolve.QualifierPosition[FakeCallableDescriptorForObject]

'tryResolveDescriptorsWhichCannotBeImported' @ [234:17] ==> private final fun tryResolveDescriptorsWhichCannotBeImported(trace: BindingTrace, moduleDescriptor: ModuleDescriptor, packageOrClassDescriptor: DeclarationDescriptor, lastPart: QualifiedExpressionResolver.QualifierPart): Unit defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'trace' @ [234:60] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport[ValueParameterDescriptorImpl]

'moduleDescriptor' @ [234:67] ==> value-parameter moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport[ValueParameterDescriptorImpl]

'packageOrClassDescriptor' @ [234:85] ==> val packageOrClassDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport[LocalVariableDescriptor]

'lastPart' @ [234:111] ==> value-parameter lastPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.processSingleImport[ValueParameterDescriptorImpl]

'SmartList' @ [245:27] ==> public constructor SmartList<E : (Any..Any?)>() defined in com.intellij.util.SmartList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> DeclarationDescriptor

'lastPart' @ [246:24] ==> value-parameter lastPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[ValueParameterDescriptorImpl]

'name' @ [246:33] ==> public final val name: Name defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'when (packageOrClassDescriptor) {
            is PackageViewDescriptor -> {
                val packageDescriptor = moduleDescriptor.getPackage(packageOrClassDescriptor.fqName.child(lastName))
                if (!packageDescriptor.isEmpty()) {
                    trace.report(Errors.PACKAGE_CANNOT_BE_IMPORTED.on(lastPart.expression))
                    descriptors.add(packageOrClassDescriptor)
                }
            }

            is ClassDescriptor -> {
                val memberScope = packageOrClassDescriptor.unsubstitutedMemberScope
                descriptors.addAll(memberScope.getContributedFunctions(lastName, lastPart.location))
                descriptors.addAll(memberScope.getContributedVariables(lastName, lastPart.location))
                if (descriptors.isNotEmpty()) {
                    trace.report(Errors.CANNOT_BE_IMPORTED.on(lastPart.expression, lastName))
                }
            }

            else -> throw IllegalStateException("Should be class or package: $packageOrClassDescriptor")
        }' @ [247:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'packageOrClassDescriptor' @ [247:15] ==> value-parameter packageOrClassDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[ValueParameterDescriptorImpl]

'moduleDescriptor' @ [249:41] ==> value-parameter moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[ValueParameterDescriptorImpl]

'getPackage' @ [249:58] ==> public abstract fun getPackage(fqName: FqName): PackageViewDescriptor defined in org.jetbrains.kotlin.descriptors.ModuleDescriptor[DeserializedSimpleFunctionDescriptor]

'packageOrClassDescriptor' @ [249:69] ==> value-parameter packageOrClassDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[ValueParameterDescriptorImpl]

'fqName' @ [249:94] ==> public abstract val fqName: FqName defined in org.jetbrains.kotlin.descriptors.PackageViewDescriptor[DeserializedPropertyDescriptor]

'child' @ [249:101] ==> @NotNull public open fun child(@NotNull p0: Name): FqName defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'lastName' @ [249:107] ==> val lastName: Name defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[LocalVariableDescriptor]

'!' @ [250:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'packageDescriptor' @ [250:22] ==> val packageDescriptor: PackageViewDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[LocalVariableDescriptor]

'isEmpty' @ [250:40] ==> public open fun isEmpty(): Boolean defined in org.jetbrains.kotlin.descriptors.PackageViewDescriptor[DeserializedSimpleFunctionDescriptor]

'trace' @ [251:21] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[ValueParameterDescriptorImpl]

'report' @ [251:27] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'PACKAGE_CANNOT_BE_IMPORTED' @ [251:41] ==> public final val PACKAGE_CANNOT_BE_IMPORTED: (DiagnosticFactory0<(KtSimpleNameExpression..KtSimpleNameExpression?)>..DiagnosticFactory0<(KtSimpleNameExpression..KtSimpleNameExpression?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [251:68] ==> @NotNull public open fun on(@NotNull element: KtSimpleNameExpression): SimpleDiagnostic<(KtSimpleNameExpression..KtSimpleNameExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'lastPart' @ [251:71] ==> value-parameter lastPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[ValueParameterDescriptorImpl]

'expression' @ [251:80] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'descriptors' @ [252:21] ==> val descriptors: SmartList<DeclarationDescriptor> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[LocalVariableDescriptor]

'add' @ [252:33] ==> public open fun add(element: (DeclarationDescriptor..DeclarationDescriptor?)): Boolean defined in com.intellij.util.SmartList[JavaMethodDescriptor]

'packageOrClassDescriptor' @ [252:37] ==> value-parameter packageOrClassDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[ValueParameterDescriptorImpl]

'packageOrClassDescriptor' @ [257:35] ==> value-parameter packageOrClassDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[ValueParameterDescriptorImpl]

'unsubstitutedMemberScope' @ [257:60] ==> public final val ClassDescriptor.unsubstitutedMemberScope: MemberScope[MyPropertyDescriptor]

'descriptors' @ [258:17] ==> val descriptors: SmartList<DeclarationDescriptor> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[LocalVariableDescriptor]

'addAll' @ [258:29] ==> public open fun addAll(elements: Collection<(DeclarationDescriptor..DeclarationDescriptor?)>): Boolean defined in com.intellij.util.SmartList[JavaMethodDescriptor]

'memberScope' @ [258:36] ==> val memberScope: MemberScope defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[LocalVariableDescriptor]

'getContributedFunctions' @ [258:48] ==> public abstract fun getContributedFunctions(name: Name, location: LookupLocation): Collection<SimpleFunctionDescriptor> defined in org.jetbrains.kotlin.resolve.scopes.MemberScope[DeserializedSimpleFunctionDescriptor]

'lastName' @ [258:72] ==> val lastName: Name defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[LocalVariableDescriptor]

'lastPart' @ [258:82] ==> value-parameter lastPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[ValueParameterDescriptorImpl]

'location' @ [258:91] ==> public final val location: KotlinLookupLocation defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'descriptors' @ [259:17] ==> val descriptors: SmartList<DeclarationDescriptor> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[LocalVariableDescriptor]

'addAll' @ [259:29] ==> public open fun addAll(elements: Collection<(DeclarationDescriptor..DeclarationDescriptor?)>): Boolean defined in com.intellij.util.SmartList[JavaMethodDescriptor]

'memberScope' @ [259:36] ==> val memberScope: MemberScope defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[LocalVariableDescriptor]

'getContributedVariables' @ [259:48] ==> public abstract fun getContributedVariables(name: Name, location: LookupLocation): Collection<PropertyDescriptor> defined in org.jetbrains.kotlin.resolve.scopes.MemberScope[DeserializedSimpleFunctionDescriptor]

'lastName' @ [259:72] ==> val lastName: Name defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[LocalVariableDescriptor]

'lastPart' @ [259:82] ==> value-parameter lastPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[ValueParameterDescriptorImpl]

'location' @ [259:91] ==> public final val location: KotlinLookupLocation defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'descriptors' @ [260:21] ==> val descriptors: SmartList<DeclarationDescriptor> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[LocalVariableDescriptor]

'isNotEmpty' @ [260:33] ==> @InlineOnly public inline fun <T> Collection<(DeclarationDescriptor..DeclarationDescriptor?)>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.DeclarationDescriptor..org.jetbrains.kotlin.descriptors.DeclarationDescriptor?)

'trace' @ [261:21] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[ValueParameterDescriptorImpl]

'report' @ [261:27] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'CANNOT_BE_IMPORTED' @ [261:41] ==> public final val CANNOT_BE_IMPORTED: (DiagnosticFactory1<(KtSimpleNameExpression..KtSimpleNameExpression?), (Name..Name?)>..DiagnosticFactory1<(KtSimpleNameExpression..KtSimpleNameExpression?), (Name..Name?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [261:60] ==> @NotNull public open fun on(@NotNull element: KtSimpleNameExpression, @NotNull argument: Name): ParametrizedDiagnostic<(KtSimpleNameExpression..KtSimpleNameExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory1[JavaMethodDescriptor]

'lastPart' @ [261:63] ==> value-parameter lastPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[ValueParameterDescriptorImpl]

'expression' @ [261:72] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'lastName' @ [261:84] ==> val lastName: Name defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[LocalVariableDescriptor]

'IllegalStateException' @ [265:27] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'packageOrClassDescriptor' @ [265:79] ==> value-parameter packageOrClassDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[ValueParameterDescriptorImpl]

'storeResult' @ [267:9] ==> private final fun storeResult(trace: BindingTrace, referenceExpression: KtSimpleNameExpression, descriptors: Collection<DeclarationDescriptor>, shouldBeVisibleFrom: DeclarationDescriptor?, position: QualifierPosition, isQualifier: Boolean = ...): Unit defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'trace' @ [267:21] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[ValueParameterDescriptorImpl]

'lastPart' @ [267:28] ==> value-parameter lastPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[ValueParameterDescriptorImpl]

'expression' @ [267:37] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'descriptors' @ [267:49] ==> val descriptors: SmartList<DeclarationDescriptor> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.tryResolveDescriptorsWhichCannotBeImported[LocalVariableDescriptor]

'IMPORT' @ [267:119] ==> enum entry IMPORT defined in org.jetbrains.kotlin.resolve.QualifierPosition[FakeCallableDescriptorForObject]

'SmartList' @ [271:22] ==> public constructor SmartList<E : (Any..Any?)>() defined in com.intellij.util.SmartList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> QualifierPart

'expression' @ [274:17] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList.addQualifierPart[ValueParameterDescriptorImpl]

'result' @ [275:17] ==> val result: SmartList<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[LocalVariableDescriptor]

'add' @ [275:24] ==> public open fun add(element: (QualifiedExpressionResolver.QualifierPart..QualifiedExpressionResolver.QualifierPart?)): Boolean defined in com.intellij.util.SmartList[JavaMethodDescriptor]

'QualifierPart' @ [275:28] ==> public constructor QualifierPart(expression: KtSimpleNameExpression) defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[ClassConstructorDescriptorImpl]

'expression' @ [275:42] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList.addQualifierPart[ValueParameterDescriptorImpl]

'doubleColonLHS' @ [278:17] ==> value-parameter doubleColonLHS: Boolean = ... defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[ValueParameterDescriptorImpl]

'expression' @ [278:35] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList.addQualifierPart[ValueParameterDescriptorImpl]

'expression' @ [278:69] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList.addQualifierPart[ValueParameterDescriptorImpl]

'isWithoutValueArguments' @ [278:80] ==> internal val KtCallExpression.isWithoutValueArguments: Boolean defined in org.jetbrains.kotlin.types.expressions in file DoubleColonExpressionResolver.kt[PropertyDescriptorImpl]

'expression' @ [279:34] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList.addQualifierPart[ValueParameterDescriptorImpl]

'calleeExpression' @ [279:45] ==> public final val KtCallExpression.calleeExpression: KtExpression?[MyPropertyDescriptor]

'simpleName' @ [280:21] ==> val simpleName: KtExpression? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList.addQualifierPart[LocalVariableDescriptor]

'result' @ [281:21] ==> val result: SmartList<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[LocalVariableDescriptor]

'add' @ [281:28] ==> public open fun add(element: (QualifiedExpressionResolver.QualifierPart..QualifiedExpressionResolver.QualifierPart?)): Boolean defined in com.intellij.util.SmartList[JavaMethodDescriptor]

'QualifierPart' @ [281:32] ==> public constructor QualifierPart(name: Name, expression: KtSimpleNameExpression, typeArguments: KtTypeArgumentList? = ...) defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[ClassConstructorDescriptorImpl]

'simpleName' @ [281:46] ==> val simpleName: KtExpression? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList.addQualifierPart[LocalVariableDescriptor]

'getReferencedNameAsName' @ [281:57] ==> public abstract fun getReferencedNameAsName(): Name defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[SimpleFunctionDescriptorImpl]

'simpleName' @ [281:84] ==> val simpleName: KtExpression? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList.addQualifierPart[LocalVariableDescriptor]

'expression' @ [281:96] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList.addQualifierPart[ValueParameterDescriptorImpl]

'typeArgumentList' @ [281:107] ==> public final val KtCallExpression.typeArgumentList: KtTypeArgumentList?[MyPropertyDescriptor]

'this' @ [288:41] ==> <this> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[ReceiverParameterDescriptorImpl]

'addQualifierPart' @ [290:17] ==> local final fun addQualifierPart(expression: KtExpression?): Boolean defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[SimpleFunctionDescriptorImpl]

'expression' @ [290:34] ==> var expression: KtExpression? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[LocalVariableDescriptor]

'expression' @ [291:17] ==> var expression: KtExpression? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[LocalVariableDescriptor]

'addQualifierPart' @ [293:13] ==> local final fun addQualifierPart(expression: KtExpression?): Boolean defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[SimpleFunctionDescriptorImpl]

'expression' @ [293:30] ==> var expression: KtExpression? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[LocalVariableDescriptor]

'selectorExpression' @ [293:41] ==> public open val selectorExpression: KtExpression? defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[PropertyDescriptorImpl]

'expression' @ [295:13] ==> var expression: KtExpression? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[LocalVariableDescriptor]

'expression' @ [295:26] ==> var expression: KtExpression? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[LocalVariableDescriptor]

'receiverExpression' @ [295:37] ==> public open val receiverExpression: KtExpression defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[PropertyDescriptorImpl]

'result' @ [298:16] ==> val result: SmartList<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.asQualifierPartList[LocalVariableDescriptor]

'asReversed' @ [298:23] ==> @JvmName public fun <T> MutableList<(QualifiedExpressionResolver.QualifierPart..QualifiedExpressionResolver.QualifierPart?)>.asReversed(): MutableList<(QualifiedExpressionResolver.QualifierPart..QualifiedExpressionResolver.QualifierPart?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart..org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart?)

'this' @ [306:60] ==> public constructor QualifierPart(name: Name, expression: KtSimpleNameExpression, typeArguments: KtTypeArgumentList? = ...) defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[ClassConstructorDescriptorImpl]

'expression' @ [306:65] ==> value-parameter expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart.<init>[ValueParameterDescriptorImpl]

'getReferencedNameAsName' @ [306:76] ==> public abstract fun getReferencedNameAsName(): Name defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[SimpleFunctionDescriptorImpl]

'expression' @ [306:103] ==> value-parameter expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart.<init>[ValueParameterDescriptorImpl]

'KotlinLookupLocation' @ [308:24] ==> public constructor KotlinLookupLocation(element: KtElement) defined in org.jetbrains.kotlin.incremental.KotlinLookupLocation[ClassConstructorDescriptorImpl]

'expression' @ [308:45] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'component1' @ [320:14] ==> public final operator fun component1(): DeclarationDescriptor? defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [320:40] ==> public final operator fun component2(): Int defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'resolveToPackageOrClassPrefix' @ [321:17] ==> private final fun resolveToPackageOrClassPrefix(path: List<QualifiedExpressionResolver.QualifierPart>, moduleDescriptor: ModuleDescriptor, trace: BindingTrace, shouldBeVisibleFrom: DeclarationDescriptor?, scopeForFirstPart: LexicalScope?, position: QualifierPosition, isValue: ((KtSimpleNameExpression) -> Boolean)? = ...): Pair<DeclarationDescriptor?, Int> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'path' @ [321:47] ==> value-parameter path: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClass[ValueParameterDescriptorImpl]

'moduleDescriptor' @ [321:53] ==> value-parameter moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClass[ValueParameterDescriptorImpl]

'trace' @ [321:71] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClass[ValueParameterDescriptorImpl]

'shouldBeVisibleFrom' @ [321:78] ==> value-parameter shouldBeVisibleFrom: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClass[ValueParameterDescriptorImpl]

'scopeForFirstPart' @ [321:99] ==> value-parameter scopeForFirstPart: LexicalScope? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClass[ValueParameterDescriptorImpl]

'position' @ [321:118] ==> value-parameter position: QualifierPosition defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClass[ValueParameterDescriptorImpl]

'endIndex' @ [323:13] ==> val endIndex: Int defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClass[LocalVariableDescriptor]

'path' @ [323:25] ==> value-parameter path: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClass[ValueParameterDescriptorImpl]

'size' @ [323:30] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'packageOrClassDescriptor' @ [327:16] ==> val packageOrClassDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClass[LocalVariableDescriptor]

'path' @ [339:13] ==> value-parameter path: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[ValueParameterDescriptorImpl]

'isEmpty' @ [339:18] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'Pair' @ [340:20] ==> public constructor Pair<out A, out B>(first: PackageViewDescriptor, second: Int) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> PackageViewDescriptor
    <out B> -> Int

'moduleDescriptor' @ [340:25] ==> value-parameter moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[ValueParameterDescriptorImpl]

'getPackage' @ [340:42] ==> public abstract fun getPackage(fqName: FqName): PackageViewDescriptor defined in org.jetbrains.kotlin.descriptors.ModuleDescriptor[DeserializedSimpleFunctionDescriptor]

'ROOT' @ [340:60] ==> public final val ROOT: (FqName..FqName?) defined in org.jetbrains.kotlin.name.FqName[JavaPropertyDescriptor]

'path' @ [343:25] ==> value-parameter path: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[ValueParameterDescriptorImpl]

'first' @ [343:30] ==> public fun <T> List<QualifiedExpressionResolver.QualifierPart>.first(): QualifiedExpressionResolver.QualifierPart defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> QualifierPart

'position' @ [345:13] ==> value-parameter position: QualifierPosition defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[ValueParameterDescriptorImpl]

'EXPRESSION' @ [345:43] ==> enum entry EXPRESSION defined in org.jetbrains.kotlin.resolve.QualifierPosition[FakeCallableDescriptorForObject]

'scopeForFirstPart' @ [349:17] ==> value-parameter scopeForFirstPart: LexicalScope? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[ValueParameterDescriptorImpl]

'isValue' @ [349:46] ==> value-parameter isValue: ((KtSimpleNameExpression) -> Boolean)? = ... defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[ValueParameterDescriptorImpl]

'invoke' @ [349:65] ==> public abstract operator fun invoke(p1: KtSimpleNameExpression): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'firstPart' @ [349:73] ==> val firstPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'expression' @ [349:83] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'Pair' @ [350:24] ==> public constructor Pair<out A, out B>(first: Nothing?, second: Int) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> Nothing?
    <out B> -> Int

'scopeForFirstPart' @ [354:36] ==> value-parameter scopeForFirstPart: LexicalScope? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[ValueParameterDescriptorImpl]

'findClassifier' @ [354:55] ==> public fun HierarchicalScope.findClassifier(name: Name, location: LookupLocation): ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.scopes.utils[DeserializedSimpleFunctionDescriptor]

'firstPart' @ [354:70] ==> val firstPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'name' @ [354:80] ==> public final val name: Name defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'firstPart' @ [354:86] ==> val firstPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'location' @ [354:96] ==> public final val location: KotlinLookupLocation defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'classifierDescriptor' @ [356:13] ==> val classifierDescriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'storeResult' @ [357:13] ==> private final fun storeResult(trace: BindingTrace, referenceExpression: KtSimpleNameExpression, descriptor: DeclarationDescriptor?, shouldBeVisibleFrom: DeclarationDescriptor?, position: QualifierPosition, isQualifier: Boolean = ...): Qualifier? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'trace' @ [357:25] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[ValueParameterDescriptorImpl]

'firstPart' @ [357:32] ==> val firstPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'expression' @ [357:42] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'classifierDescriptor' @ [357:54] ==> val classifierDescriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'shouldBeVisibleFrom' @ [357:76] ==> value-parameter shouldBeVisibleFrom: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[ValueParameterDescriptorImpl]

'position' @ [357:97] ==> value-parameter position: QualifierPosition defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[ValueParameterDescriptorImpl]

'component1' @ [360:14] ==> public final operator fun component1(): DeclarationDescriptor defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [360:32] ==> public final operator fun component2(): Int defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'if (classifierDescriptor != null)
                    Pair(classifierDescriptor, 1)
                else
                    moduleDescriptor.quickResolveToPackage(path, trace, position)' @ [361:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Pair<DeclarationDescriptor, Int>, elseBranch: Pair<DeclarationDescriptor, Int>): Pair<DeclarationDescriptor, Int>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Pair<DeclarationDescriptor, Int>

'classifierDescriptor' @ [361:21] ==> val classifierDescriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'Pair' @ [362:21] ==> public constructor Pair<out A, out B>(first: ClassifierDescriptor, second: Int) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> ClassifierDescriptor
    <out B> -> Int

'classifierDescriptor' @ [362:26] ==> val classifierDescriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'moduleDescriptor' @ [364:21] ==> value-parameter moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[ValueParameterDescriptorImpl]

'quickResolveToPackage' @ [364:38] ==> private final fun ModuleDescriptor.quickResolveToPackage(path: List<QualifiedExpressionResolver.QualifierPart>, trace: BindingTrace, position: QualifierPosition): Pair<PackageViewDescriptor, Int> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'path' @ [364:60] ==> value-parameter path: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[ValueParameterDescriptorImpl]

'trace' @ [364:66] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[ValueParameterDescriptorImpl]

'position' @ [364:73] ==> value-parameter position: QualifierPosition defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[ValueParameterDescriptorImpl]

'prefixDescriptor' @ [366:57] ==> val prefixDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'nextIndexAfterPrefix' @ [367:36] ==> val nextIndexAfterPrefix: Int defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'path' @ [367:58] ==> value-parameter path: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[ValueParameterDescriptorImpl]

'size' @ [367:63] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'path' @ [368:33] ==> value-parameter path: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[ValueParameterDescriptorImpl]

'qualifierPartIndex' @ [368:38] ==> val qualifierPartIndex: Int defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'when (currentDescriptor) {
                        is TypeAliasDescriptor -> // TODO type aliases as qualifiers? (would break some assumptions in TypeResolver)
                            null
                        is ClassDescriptor ->
                            currentDescriptor.getContributedClassifier(qualifierPart)
                        is PackageViewDescriptor -> {
                            val packageView =
                                    if (qualifierPart.typeArguments == null) {
                                        moduleDescriptor.getPackage(currentDescriptor.fqName.child(qualifierPart.name))
                                    }
                                    else null
                            if (packageView != null && !packageView.isEmpty()) {
                                packageView
                            }
                            else {
                                currentDescriptor.memberScope.getContributedClassifier(qualifierPart.name, qualifierPart.location)
                            }
                        }
                        else ->
                            null
                    }' @ [371:21] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: DeclarationDescriptor?, entry1: DeclarationDescriptor?, entry2: DeclarationDescriptor?, entry3: DeclarationDescriptor?): DeclarationDescriptor?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> DeclarationDescriptor?

'currentDescriptor' @ [371:27] ==> var currentDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'currentDescriptor' @ [375:29] ==> var currentDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'getContributedClassifier' @ [375:47] ==> public final fun ClassDescriptor.getContributedClassifier(qualifierPart: QualifiedExpressionResolver.QualifierPart): ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'qualifierPart' @ [375:72] ==> val qualifierPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'if (qualifierPart.typeArguments == null) {
                                        moduleDescriptor.getPackage(currentDescriptor.fqName.child(qualifierPart.name))
                                    }
                                    else null' @ [378:37] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: PackageViewDescriptor?, elseBranch: PackageViewDescriptor?): PackageViewDescriptor?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> PackageViewDescriptor?

'qualifierPart' @ [378:41] ==> val qualifierPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'typeArguments' @ [378:55] ==> public final val typeArguments: KtTypeArgumentList? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'moduleDescriptor' @ [379:41] ==> value-parameter moduleDescriptor: ModuleDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[ValueParameterDescriptorImpl]

'getPackage' @ [379:58] ==> public abstract fun getPackage(fqName: FqName): PackageViewDescriptor defined in org.jetbrains.kotlin.descriptors.ModuleDescriptor[DeserializedSimpleFunctionDescriptor]

'currentDescriptor' @ [379:69] ==> var currentDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'fqName' @ [379:87] ==> public abstract val fqName: FqName defined in org.jetbrains.kotlin.descriptors.PackageViewDescriptor[DeserializedPropertyDescriptor]

'child' @ [379:94] ==> @NotNull public open fun child(@NotNull p0: Name): FqName defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'qualifierPart' @ [379:100] ==> val qualifierPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'name' @ [379:114] ==> public final val name: Name defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'if (packageView != null && !packageView.isEmpty()) {
                                packageView
                            }
                            else {
                                currentDescriptor.memberScope.getContributedClassifier(qualifierPart.name, qualifierPart.location)
                            }' @ [382:29] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: DeclarationDescriptor?, elseBranch: DeclarationDescriptor?): DeclarationDescriptor?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> DeclarationDescriptor?

'packageView' @ [382:33] ==> val packageView: PackageViewDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'!' @ [382:56] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'packageView' @ [382:57] ==> val packageView: PackageViewDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'isEmpty' @ [382:69] ==> public open fun isEmpty(): Boolean defined in org.jetbrains.kotlin.descriptors.PackageViewDescriptor[DeserializedSimpleFunctionDescriptor]

'packageView' @ [383:33] ==> val packageView: PackageViewDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'currentDescriptor' @ [386:33] ==> var currentDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'memberScope' @ [386:51] ==> public abstract val memberScope: MemberScope defined in org.jetbrains.kotlin.descriptors.PackageViewDescriptor[DeserializedPropertyDescriptor]

'getContributedClassifier' @ [386:63] ==> public abstract fun getContributedClassifier(name: Name, location: LookupLocation): ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.scopes.MemberScope[DeserializedSimpleFunctionDescriptor]

'qualifierPart' @ [386:88] ==> val qualifierPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'name' @ [386:102] ==> public final val name: Name defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'qualifierPart' @ [386:108] ==> val qualifierPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'location' @ [386:122] ==> public final val location: KotlinLookupLocation defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'!' @ [394:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'position' @ [394:19] ==> value-parameter position: QualifierPosition defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[ValueParameterDescriptorImpl]

'EXPRESSION' @ [394:49] ==> enum entry EXPRESSION defined in org.jetbrains.kotlin.resolve.QualifierPosition[FakeCallableDescriptorForObject]

'nextPackageOrClassDescriptor' @ [394:63] ==> val nextPackageOrClassDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'storeResult' @ [395:17] ==> private final fun storeResult(trace: BindingTrace, referenceExpression: KtSimpleNameExpression, descriptor: DeclarationDescriptor?, shouldBeVisibleFrom: DeclarationDescriptor?, position: QualifierPosition, isQualifier: Boolean = ...): Qualifier? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'trace' @ [395:29] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[ValueParameterDescriptorImpl]

'qualifierPart' @ [395:36] ==> val qualifierPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'expression' @ [395:50] ==> public final val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'nextPackageOrClassDescriptor' @ [395:62] ==> val nextPackageOrClassDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'shouldBeVisibleFrom' @ [395:92] ==> value-parameter shouldBeVisibleFrom: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[ValueParameterDescriptorImpl]

'position' @ [395:113] ==> value-parameter position: QualifierPosition defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[ValueParameterDescriptorImpl]

'nextPackageOrClassDescriptor' @ [398:17] ==> val nextPackageOrClassDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'Pair' @ [399:24] ==> public constructor Pair<out A, out B>(first: DeclarationDescriptor?, second: Int) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> DeclarationDescriptor?
    <out B> -> Int

'currentDescriptor' @ [399:29] ==> var currentDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'qualifierPartIndex' @ [399:48] ==> val qualifierPartIndex: Int defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'currentDescriptor' @ [402:13] ==> var currentDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'nextPackageOrClassDescriptor' @ [402:33] ==> val nextPackageOrClassDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'Pair' @ [405:16] ==> public constructor Pair<out A, out B>(first: DeclarationDescriptor?, second: Int) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> DeclarationDescriptor?
    <out B> -> Int

'currentDescriptor' @ [405:21] ==> var currentDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[LocalVariableDescriptor]

'path' @ [405:40] ==> value-parameter path: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveToPackageOrClassPrefix[ValueParameterDescriptorImpl]

'size' @ [405:45] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'unsubstitutedInnerClassesScope' @ [409:13] ==> public final val ClassDescriptor.unsubstitutedInnerClassesScope: MemberScope[MyPropertyDescriptor]

'getContributedClassifier' @ [409:44] ==> public abstract fun getContributedClassifier(name: Name, location: LookupLocation): ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.scopes.MemberScope[DeserializedSimpleFunctionDescriptor]

'qualifierPart' @ [409:69] ==> value-parameter qualifierPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.getContributedClassifier[ValueParameterDescriptorImpl]

'name' @ [409:83] ==> public final val name: Name defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'qualifierPart' @ [409:89] ==> value-parameter qualifierPart: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.getContributedClassifier[ValueParameterDescriptorImpl]

'location' @ [409:103] ==> public final val location: KotlinLookupLocation defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'expression' @ [416:20] ==> value-parameter expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[ValueParameterDescriptorImpl]

'getReferencedNameAsName' @ [416:31] ==> public abstract fun getReferencedNameAsName(): Name defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[SimpleFunctionDescriptorImpl]

'KotlinLookupLocation' @ [418:24] ==> public constructor KotlinLookupLocation(element: KtElement) defined in org.jetbrains.kotlin.incremental.KotlinLookupLocation[ClassConstructorDescriptorImpl]

'expression' @ [418:45] ==> value-parameter expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[ValueParameterDescriptorImpl]

'when (receiver) {
            is PackageQualifier -> {
                val childPackageFQN = receiver.descriptor.fqName.child(name)
                receiver.descriptor.module.getPackage(childPackageFQN).takeUnless { it.isEmpty() } ?:
                receiver.descriptor.memberScope.getContributedClassifier(name, location)
            }
            is ClassQualifier -> receiver.staticScope.getContributedClassifier(name, location)
            null -> context.scope.findClassifier(name, location) ?:
                    context.scope.ownerDescriptor.module.getPackage(FqName.ROOT.child(name)).takeUnless { it.isEmpty() }
            is ReceiverValue -> receiver.type.memberScope.memberScopeAsImportingScope().findClassifier(name, location)
            else -> null
        }' @ [419:35] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: DeclarationDescriptor?, entry1: DeclarationDescriptor?, entry2: DeclarationDescriptor?, entry3: DeclarationDescriptor?, entry4: DeclarationDescriptor?): DeclarationDescriptor?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> DeclarationDescriptor?

'receiver' @ [419:41] ==> value-parameter receiver: Receiver? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[ValueParameterDescriptorImpl]

'receiver' @ [421:39] ==> value-parameter receiver: Receiver? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[ValueParameterDescriptorImpl]

'descriptor' @ [421:48] ==> public open val descriptor: PackageViewDescriptor defined in org.jetbrains.kotlin.resolve.scopes.receivers.PackageQualifier[PropertyDescriptorImpl]

'fqName' @ [421:59] ==> public abstract val fqName: FqName defined in org.jetbrains.kotlin.descriptors.PackageViewDescriptor[DeserializedPropertyDescriptor]

'child' @ [421:66] ==> @NotNull public open fun child(@NotNull p0: Name): FqName defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'name' @ [421:72] ==> val name: Name defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[LocalVariableDescriptor]

'receiver' @ [422:17] ==> value-parameter receiver: Receiver? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[ValueParameterDescriptorImpl]

'descriptor' @ [422:26] ==> public open val descriptor: PackageViewDescriptor defined in org.jetbrains.kotlin.resolve.scopes.receivers.PackageQualifier[PropertyDescriptorImpl]

'module' @ [422:37] ==> public abstract val module: ModuleDescriptor defined in org.jetbrains.kotlin.descriptors.PackageViewDescriptor[DeserializedPropertyDescriptor]

'getPackage' @ [422:44] ==> public abstract fun getPackage(fqName: FqName): PackageViewDescriptor defined in org.jetbrains.kotlin.descriptors.ModuleDescriptor[DeserializedSimpleFunctionDescriptor]

'childPackageFQN' @ [422:55] ==> val childPackageFQN: FqName defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[LocalVariableDescriptor]

'takeUnless' @ [422:72] ==> @InlineOnly @SinceKotlin public inline fun <T> PackageViewDescriptor.takeUnless(predicate: (PackageViewDescriptor) -> Boolean): PackageViewDescriptor? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PackageViewDescriptor

'it' @ [422:85] ==> value-parameter it: PackageViewDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics.<anonymous>[ValueParameterDescriptorImpl]

'isEmpty' @ [422:88] ==> public open fun isEmpty(): Boolean defined in org.jetbrains.kotlin.descriptors.PackageViewDescriptor[DeserializedSimpleFunctionDescriptor]

'receiver' @ [423:17] ==> value-parameter receiver: Receiver? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[ValueParameterDescriptorImpl]

'descriptor' @ [423:26] ==> public open val descriptor: PackageViewDescriptor defined in org.jetbrains.kotlin.resolve.scopes.receivers.PackageQualifier[PropertyDescriptorImpl]

'memberScope' @ [423:37] ==> public abstract val memberScope: MemberScope defined in org.jetbrains.kotlin.descriptors.PackageViewDescriptor[DeserializedPropertyDescriptor]

'getContributedClassifier' @ [423:49] ==> public abstract fun getContributedClassifier(name: Name, location: LookupLocation): ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.scopes.MemberScope[DeserializedSimpleFunctionDescriptor]

'name' @ [423:74] ==> val name: Name defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[LocalVariableDescriptor]

'location' @ [423:80] ==> val location: KotlinLookupLocation defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[LocalVariableDescriptor]

'receiver' @ [425:34] ==> value-parameter receiver: Receiver? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[ValueParameterDescriptorImpl]

'staticScope' @ [425:43] ==> public open val staticScope: MemberScope defined in org.jetbrains.kotlin.resolve.scopes.receivers.ClassQualifier[PropertyDescriptorImpl]

'getContributedClassifier' @ [425:55] ==> public abstract fun getContributedClassifier(name: Name, location: LookupLocation): ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.scopes.MemberScope[DeserializedSimpleFunctionDescriptor]

'name' @ [425:80] ==> val name: Name defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[LocalVariableDescriptor]

'location' @ [425:86] ==> val location: KotlinLookupLocation defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[LocalVariableDescriptor]

'context' @ [426:21] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[ValueParameterDescriptorImpl]

'scope' @ [426:29] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'findClassifier' @ [426:35] ==> public fun HierarchicalScope.findClassifier(name: Name, location: LookupLocation): ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.scopes.utils[DeserializedSimpleFunctionDescriptor]

'name' @ [426:50] ==> val name: Name defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[LocalVariableDescriptor]

'location' @ [426:56] ==> val location: KotlinLookupLocation defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[LocalVariableDescriptor]

'context' @ [427:21] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[ValueParameterDescriptorImpl]

'scope' @ [427:29] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'ownerDescriptor' @ [427:35] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'module' @ [427:51] ==> public val DeclarationDescriptor.module: ModuleDescriptor defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'getPackage' @ [427:58] ==> public abstract fun getPackage(fqName: FqName): PackageViewDescriptor defined in org.jetbrains.kotlin.descriptors.ModuleDescriptor[DeserializedSimpleFunctionDescriptor]

'ROOT' @ [427:76] ==> public final val ROOT: (FqName..FqName?) defined in org.jetbrains.kotlin.name.FqName[JavaPropertyDescriptor]

'child' @ [427:81] ==> @NotNull public open fun child(@NotNull p0: Name): FqName defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'name' @ [427:87] ==> val name: Name defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[LocalVariableDescriptor]

'takeUnless' @ [427:94] ==> @InlineOnly @SinceKotlin public inline fun <T> PackageViewDescriptor.takeUnless(predicate: (PackageViewDescriptor) -> Boolean): PackageViewDescriptor? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PackageViewDescriptor

'it' @ [427:107] ==> value-parameter it: PackageViewDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics.<anonymous>[ValueParameterDescriptorImpl]

'isEmpty' @ [427:110] ==> public open fun isEmpty(): Boolean defined in org.jetbrains.kotlin.descriptors.PackageViewDescriptor[DeserializedSimpleFunctionDescriptor]

'receiver' @ [428:33] ==> value-parameter receiver: Receiver? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[ValueParameterDescriptorImpl]

'type' @ [428:42] ==> public final val ReceiverValue.type: KotlinType[MyPropertyDescriptor]

'memberScope' @ [428:47] ==> public abstract val memberScope: MemberScope defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'memberScopeAsImportingScope' @ [428:59] ==> @JvmOverloads public fun MemberScope.memberScopeAsImportingScope(parentScope: ImportingScope? = ...): ImportingScope defined in org.jetbrains.kotlin.resolve.scopes.utils[DeserializedSimpleFunctionDescriptor]

'findClassifier' @ [428:89] ==> public fun HierarchicalScope.findClassifier(name: Name, location: LookupLocation): ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.scopes.utils[DeserializedSimpleFunctionDescriptor]

'name' @ [428:104] ==> val name: Name defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[LocalVariableDescriptor]

'location' @ [428:110] ==> val location: KotlinLookupLocation defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[LocalVariableDescriptor]

'qualifierDescriptor' @ [432:13] ==> val qualifierDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[LocalVariableDescriptor]

'storeResult' @ [433:20] ==> private final fun storeResult(trace: BindingTrace, referenceExpression: KtSimpleNameExpression, descriptor: DeclarationDescriptor?, shouldBeVisibleFrom: DeclarationDescriptor?, position: QualifierPosition, isQualifier: Boolean = ...): Qualifier? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'context' @ [433:32] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[ValueParameterDescriptorImpl]

'trace' @ [433:40] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'expression' @ [433:47] ==> value-parameter expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[ValueParameterDescriptorImpl]

'qualifierDescriptor' @ [433:59] ==> val qualifierDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[LocalVariableDescriptor]

'context' @ [433:80] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveNameExpressionAsQualifierForDiagnostics[ValueParameterDescriptorImpl]

'scope' @ [433:88] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'ownerDescriptor' @ [433:94] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'EXPRESSION' @ [433:129] ==> enum entry EXPRESSION defined in org.jetbrains.kotlin.resolve.QualifierPosition[FakeCallableDescriptorForObject]

'QualifiedExpressionResolveResult' @ [442:30] ==> public constructor QualifiedExpressionResolveResult(classOrPackage: DeclarationDescriptor?, memberName: Name?) defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifiedExpressionResolveResult[ClassConstructorDescriptorImpl]

'unrollToLeftMostQualifiedExpression' @ [449:36] ==> public fun unrollToLeftMostQualifiedExpression(expression: KtQualifiedExpression): List<KtQualifiedExpression> defined in org.jetbrains.kotlin.resolve.calls[SimpleFunctionDescriptorImpl]

'expression' @ [449:72] ==> value-parameter expression: KtQualifiedExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveClassOrPackageInQualifiedExpression[ValueParameterDescriptorImpl]

'mapToQualifierParts' @ [450:20] ==> private final fun mapToQualifierParts(qualifiedExpressions: List<KtQualifiedExpression>, skipLast: Int): List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'qualifiedExpressions' @ [450:40] ==> val qualifiedExpressions: List<KtQualifiedExpression> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveClassOrPackageInQualifiedExpression[LocalVariableDescriptor]

'DelegatingBindingTrace' @ [451:21] ==> public constructor DelegatingBindingTrace(parentContext: BindingContext, name: String, withParentDiagnostics: Boolean = ..., filter: BindingTraceFilter = ..., allowSliceRewrite: Boolean = ...) defined in org.jetbrains.kotlin.resolve.DelegatingBindingTrace[ClassConstructorDescriptorImpl]

'context' @ [451:44] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveClassOrPackageInQualifiedExpression[ValueParameterDescriptorImpl]

'component1' @ [453:14] ==> public final operator fun component1(): DeclarationDescriptor? defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [453:22] ==> public final operator fun component2(): Int defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'resolveToPackageOrClassPrefix' @ [453:31] ==> private final fun resolveToPackageOrClassPrefix(path: List<QualifiedExpressionResolver.QualifierPart>, moduleDescriptor: ModuleDescriptor, trace: BindingTrace, shouldBeVisibleFrom: DeclarationDescriptor?, scopeForFirstPart: LexicalScope?, position: QualifierPosition, isValue: ((KtSimpleNameExpression) -> Boolean)? = ...): Pair<DeclarationDescriptor?, Int> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'path' @ [454:24] ==> val path: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveClassOrPackageInQualifiedExpression[LocalVariableDescriptor]

'scope' @ [455:36] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveClassOrPackageInQualifiedExpression[ValueParameterDescriptorImpl]

'ownerDescriptor' @ [455:42] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'module' @ [455:58] ==> public val DeclarationDescriptor.module: ModuleDescriptor defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'trace' @ [456:25] ==> val trace: DelegatingBindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveClassOrPackageInQualifiedExpression[LocalVariableDescriptor]

'scope' @ [457:39] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveClassOrPackageInQualifiedExpression[ValueParameterDescriptorImpl]

'ownerDescriptor' @ [457:45] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'scope' @ [458:37] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveClassOrPackageInQualifiedExpression[ValueParameterDescriptorImpl]

'EXPRESSION' @ [459:46] ==> enum entry EXPRESSION defined in org.jetbrains.kotlin.resolve.QualifierPosition[FakeCallableDescriptorForObject]

'result' @ [462:13] ==> val result: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveClassOrPackageInQualifiedExpression[LocalVariableDescriptor]

'QualifiedExpressionResolveResult' @ [462:36] ==> public companion object defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifiedExpressionResolveResult[FakeCallableDescriptorForObject]

'UNRESOLVED' @ [462:69] ==> public final val UNRESOLVED: QualifiedExpressionResolver.QualifiedExpressionResolveResult defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifiedExpressionResolveResult.Companion[PropertyDescriptorImpl]

'when (index) {
            path.size -> QualifiedExpressionResolveResult(result, null)
            path.size - 1 -> QualifiedExpressionResolveResult(result, path[index].name)
            else -> QualifiedExpressionResolveResult.UNRESOLVED
        }' @ [463:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: QualifiedExpressionResolver.QualifiedExpressionResolveResult, entry1: QualifiedExpressionResolver.QualifiedExpressionResolveResult, entry2: QualifiedExpressionResolver.QualifiedExpressionResolveResult): QualifiedExpressionResolver.QualifiedExpressionResolveResult[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> QualifiedExpressionResolveResult

'index' @ [463:22] ==> val index: Int defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveClassOrPackageInQualifiedExpression[LocalVariableDescriptor]

'path' @ [464:13] ==> val path: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveClassOrPackageInQualifiedExpression[LocalVariableDescriptor]

'size' @ [464:18] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'QualifiedExpressionResolveResult' @ [464:26] ==> public constructor QualifiedExpressionResolveResult(classOrPackage: DeclarationDescriptor?, memberName: Name?) defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifiedExpressionResolveResult[ClassConstructorDescriptorImpl]

'result' @ [464:59] ==> val result: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveClassOrPackageInQualifiedExpression[LocalVariableDescriptor]

'path' @ [465:13] ==> val path: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveClassOrPackageInQualifiedExpression[LocalVariableDescriptor]

'size' @ [465:18] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'QualifiedExpressionResolveResult' @ [465:30] ==> public constructor QualifiedExpressionResolveResult(classOrPackage: DeclarationDescriptor?, memberName: Name?) defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifiedExpressionResolveResult[ClassConstructorDescriptorImpl]

'result' @ [465:63] ==> val result: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveClassOrPackageInQualifiedExpression[LocalVariableDescriptor]

'path' @ [465:71] ==> val path: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveClassOrPackageInQualifiedExpression[LocalVariableDescriptor]

'index' @ [465:76] ==> val index: Int defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveClassOrPackageInQualifiedExpression[LocalVariableDescriptor]

'name' @ [465:83] ==> public final val name: Name defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'QualifiedExpressionResolveResult' @ [466:21] ==> public companion object defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifiedExpressionResolveResult[FakeCallableDescriptorForObject]

'UNRESOLVED' @ [466:54] ==> public final val UNRESOLVED: QualifiedExpressionResolver.QualifiedExpressionResolveResult defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifiedExpressionResolveResult.Companion[PropertyDescriptorImpl]

'unrollToLeftMostQualifiedExpression' @ [475:36] ==> public fun unrollToLeftMostQualifiedExpression(expression: KtQualifiedExpression): List<KtQualifiedExpression> defined in org.jetbrains.kotlin.resolve.calls[SimpleFunctionDescriptorImpl]

'expression' @ [475:72] ==> value-parameter expression: KtQualifiedExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierInExpressionAndUnroll[ValueParameterDescriptorImpl]

'mapToQualifierParts' @ [476:42] ==> private final fun mapToQualifierParts(qualifiedExpressions: List<KtQualifiedExpression>, skipLast: Int): List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'qualifiedExpressions' @ [476:62] ==> val qualifiedExpressions: List<KtQualifiedExpression> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierInExpressionAndUnroll[LocalVariableDescriptor]

'resolveToPackageOrClassPrefix' @ [478:36] ==> private final fun resolveToPackageOrClassPrefix(path: List<QualifiedExpressionResolver.QualifierPart>, moduleDescriptor: ModuleDescriptor, trace: BindingTrace, shouldBeVisibleFrom: DeclarationDescriptor?, scopeForFirstPart: LexicalScope?, position: QualifierPosition, isValue: ((KtSimpleNameExpression) -> Boolean)? = ...): Pair<DeclarationDescriptor?, Int> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'maxPossibleQualifierPrefix' @ [479:24] ==> val maxPossibleQualifierPrefix: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierInExpressionAndUnroll[LocalVariableDescriptor]

'context' @ [480:36] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierInExpressionAndUnroll[ValueParameterDescriptorImpl]

'scope' @ [480:44] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'ownerDescriptor' @ [480:50] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'module' @ [480:66] ==> public val DeclarationDescriptor.module: ModuleDescriptor defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'context' @ [481:25] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierInExpressionAndUnroll[ValueParameterDescriptorImpl]

'trace' @ [481:33] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'context' @ [482:39] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierInExpressionAndUnroll[ValueParameterDescriptorImpl]

'scope' @ [482:47] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'ownerDescriptor' @ [482:53] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'context' @ [483:37] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierInExpressionAndUnroll[ValueParameterDescriptorImpl]

'scope' @ [483:45] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'EXPRESSION' @ [484:46] ==> enum entry EXPRESSION defined in org.jetbrains.kotlin.resolve.QualifierPosition[FakeCallableDescriptorForObject]

'isValue' @ [485:27] ==> value-parameter isValue: (KtSimpleNameExpression) -> Boolean defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierInExpressionAndUnroll[ValueParameterDescriptorImpl]

'second' @ [486:11] ==> public final val second: Int defined in kotlin.Pair[DeserializedPropertyDescriptor]

'if (nextIndexAfterPrefix == 0) 0 else nextIndexAfterPrefix - 1' @ [489:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Int, elseBranch: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Int

'nextIndexAfterPrefix' @ [489:21] ==> val nextIndexAfterPrefix: Int defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierInExpressionAndUnroll[LocalVariableDescriptor]

'nextIndexAfterPrefix' @ [489:55] ==> val nextIndexAfterPrefix: Int defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierInExpressionAndUnroll[LocalVariableDescriptor]

'qualifiedExpressions' @ [491:16] ==> val qualifiedExpressions: List<KtQualifiedExpression> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierInExpressionAndUnroll[LocalVariableDescriptor]

'subList' @ [492:18] ==> public abstract fun subList(fromIndex: Int, toIndex: Int): List<KtQualifiedExpression> defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'nextExpressionIndexAfterQualifier' @ [492:26] ==> val nextExpressionIndexAfterQualifier: Int defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierInExpressionAndUnroll[LocalVariableDescriptor]

'qualifiedExpressions' @ [492:61] ==> val qualifiedExpressions: List<KtQualifiedExpression> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.resolveQualifierInExpressionAndUnroll[LocalVariableDescriptor]

'size' @ [492:82] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'map' @ [493:18] ==> public inline fun <T, R> Iterable<KtQualifiedExpression>.map(transform: (KtQualifiedExpression) -> CallExpressionElement): List<CallExpressionElement> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtQualifiedExpression
    <R> -> CallExpressionElement

'qualifiedExpressions' @ [498:13] ==> value-parameter qualifiedExpressions: List<KtQualifiedExpression> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.mapToQualifierParts[ValueParameterDescriptorImpl]

'isEmpty' @ [498:34] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'emptyList' @ [498:52] ==> public fun <T> emptyList(): List<QualifiedExpressionResolver.QualifierPart> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> QualifierPart

'qualifiedExpressions' @ [500:21] ==> value-parameter qualifiedExpressions: List<KtQualifiedExpression> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.mapToQualifierParts[ValueParameterDescriptorImpl]

'first' @ [500:42] ==> public fun <T> List<KtQualifiedExpression>.first(): KtQualifiedExpression defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtQualifiedExpression

'first' @ [501:13] ==> val first: KtQualifiedExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.mapToQualifierParts[LocalVariableDescriptor]

'emptyList' @ [501:56] ==> public fun <T> emptyList(): List<QualifiedExpressionResolver.QualifierPart> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> QualifierPart

'first' @ [502:29] ==> val first: KtQualifiedExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.mapToQualifierParts[LocalVariableDescriptor]

'receiverExpression' @ [502:35] ==> public open val receiverExpression: KtExpression defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[PropertyDescriptorImpl]

'firstReceiver' @ [503:13] ==> val firstReceiver: KtExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.mapToQualifierParts[LocalVariableDescriptor]

'emptyList' @ [503:62] ==> public fun <T> emptyList(): List<QualifiedExpressionResolver.QualifierPart> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> QualifierPart

'arrayListOf' @ [513:30] ==> @SinceKotlin @InlineOnly public inline fun <T> arrayListOf(): ArrayList<QualifiedExpressionResolver.QualifierPart> /* = ArrayList<QualifiedExpressionResolver.QualifierPart> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> QualifierPart

'qualifierParts' @ [514:9] ==> val qualifierParts: ArrayList<QualifiedExpressionResolver.QualifierPart> /* = ArrayList<QualifiedExpressionResolver.QualifierPart> */ defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.mapToQualifierParts[LocalVariableDescriptor]

'add' @ [514:24] ==> public open fun add(element: QualifiedExpressionResolver.QualifierPart): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'QualifierPart' @ [514:28] ==> public constructor QualifierPart(expression: KtSimpleNameExpression) defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[ClassConstructorDescriptorImpl]

'firstReceiver' @ [514:42] ==> val firstReceiver: KtExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.mapToQualifierParts[LocalVariableDescriptor]

'qualifiedExpressions' @ [516:37] ==> value-parameter qualifiedExpressions: List<KtQualifiedExpression> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.mapToQualifierParts[ValueParameterDescriptorImpl]

'dropLast' @ [516:58] ==> public fun <T> List<KtQualifiedExpression>.dropLast(n: Int): List<KtQualifiedExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtQualifiedExpression

'skipLast' @ [516:67] ==> value-parameter skipLast: Int defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.mapToQualifierParts[ValueParameterDescriptorImpl]

'qualifiedExpression' @ [517:17] ==> val qualifiedExpression: KtQualifiedExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.mapToQualifierParts[LocalVariableDescriptor]

'qualifiedExpression' @ [518:28] ==> val qualifiedExpression: KtQualifiedExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.mapToQualifierParts[LocalVariableDescriptor]

'selectorExpression' @ [518:48] ==> public open val selectorExpression: KtExpression? defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[PropertyDescriptorImpl]

'selector' @ [519:17] ==> val selector: KtExpression? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.mapToQualifierParts[LocalVariableDescriptor]

'qualifierParts' @ [520:13] ==> val qualifierParts: ArrayList<QualifiedExpressionResolver.QualifierPart> /* = ArrayList<QualifiedExpressionResolver.QualifierPart> */ defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.mapToQualifierParts[LocalVariableDescriptor]

'add' @ [520:28] ==> public open fun add(element: QualifiedExpressionResolver.QualifierPart): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'QualifierPart' @ [520:32] ==> public constructor QualifierPart(expression: KtSimpleNameExpression) defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[ClassConstructorDescriptorImpl]

'selector' @ [520:46] ==> val selector: KtExpression? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.mapToQualifierParts[LocalVariableDescriptor]

'qualifierParts' @ [523:16] ==> val qualifierParts: ArrayList<QualifiedExpressionResolver.QualifierPart> /* = ArrayList<QualifiedExpressionResolver.QualifierPart> */ defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.mapToQualifierParts[LocalVariableDescriptor]

'path' @ [531:41] ==> value-parameter path: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.quickResolveToPackage[ValueParameterDescriptorImpl]

'indexOfFirst' @ [531:46] ==> public inline fun <T> List<QualifiedExpressionResolver.QualifierPart>.indexOfFirst(predicate: (QualifiedExpressionResolver.QualifierPart) -> Boolean): Int defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> QualifierPart

'it' @ [531:61] ==> value-parameter it: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.quickResolveToPackage.<anonymous>[ValueParameterDescriptorImpl]

'typeArguments' @ [531:64] ==> public final val typeArguments: KtTypeArgumentList? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'let' @ [531:88] ==> @InlineOnly public inline fun <T, R> Int.let(block: (Int) -> Int): Int defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Int
    <R> -> Int

'if (it == -1) path.size else it + 1' @ [531:94] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Int, elseBranch: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Int

'it' @ [531:98] ==> value-parameter it: Int defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.quickResolveToPackage.<anonymous>[ValueParameterDescriptorImpl]

'-' @ [531:104] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'path' @ [531:108] ==> value-parameter path: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.quickResolveToPackage[ValueParameterDescriptorImpl]

'size' @ [531:113] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'it' @ [531:123] ==> value-parameter it: Int defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.quickResolveToPackage.<anonymous>[ValueParameterDescriptorImpl]

'fromSegments' @ [532:29] ==> @NotNull public open fun fromSegments(@NotNull p0: (MutableList<(String..String?)>..List<(String..String?)>)): FqName defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'path' @ [532:42] ==> value-parameter path: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.quickResolveToPackage[ValueParameterDescriptorImpl]

'subList' @ [532:47] ==> public abstract fun subList(fromIndex: Int, toIndex: Int): List<QualifiedExpressionResolver.QualifierPart> defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'possiblePackagePrefixSize' @ [532:58] ==> val possiblePackagePrefixSize: Int defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.quickResolveToPackage[LocalVariableDescriptor]

'map' @ [532:85] ==> public inline fun <T, R> Iterable<QualifiedExpressionResolver.QualifierPart>.map(transform: (QualifiedExpressionResolver.QualifierPart) -> String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> QualifierPart
    <R> -> String

'it' @ [532:91] ==> value-parameter it: QualifiedExpressionResolver.QualifierPart defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.quickResolveToPackage.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [532:94] ==> public final val name: Name defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[PropertyDescriptorImpl]

'asString' @ [532:99] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'possiblePackagePrefixSize' @ [534:26] ==> val possiblePackagePrefixSize: Int defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.quickResolveToPackage[LocalVariableDescriptor]

'!' @ [535:16] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'fqName' @ [535:17] ==> var fqName: FqName defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.quickResolveToPackage[LocalVariableDescriptor]

'isRoot' @ [535:24] ==> public final val FqName.isRoot: Boolean[MyPropertyDescriptor]

'getPackage' @ [536:37] ==> public abstract fun getPackage(fqName: FqName): PackageViewDescriptor defined in org.jetbrains.kotlin.descriptors.ModuleDescriptor[DeserializedSimpleFunctionDescriptor]

'fqName' @ [536:48] ==> var fqName: FqName defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.quickResolveToPackage[LocalVariableDescriptor]

'!' @ [537:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'packageDescriptor' @ [537:18] ==> val packageDescriptor: PackageViewDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.quickResolveToPackage[LocalVariableDescriptor]

'isEmpty' @ [537:36] ==> public open fun isEmpty(): Boolean defined in org.jetbrains.kotlin.descriptors.PackageViewDescriptor[DeserializedSimpleFunctionDescriptor]

'recordPackageViews' @ [538:17] ==> private final fun recordPackageViews(path: List<QualifiedExpressionResolver.QualifierPart>, packageView: PackageViewDescriptor, trace: BindingTrace, position: QualifierPosition): Unit defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'path' @ [538:36] ==> value-parameter path: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.quickResolveToPackage[ValueParameterDescriptorImpl]

'subList' @ [538:41] ==> public abstract fun subList(fromIndex: Int, toIndex: Int): List<QualifiedExpressionResolver.QualifierPart> defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'prefixSize' @ [538:52] ==> var prefixSize: Int defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.quickResolveToPackage[LocalVariableDescriptor]

'packageDescriptor' @ [538:65] ==> val packageDescriptor: PackageViewDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.quickResolveToPackage[LocalVariableDescriptor]

'trace' @ [538:84] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.quickResolveToPackage[ValueParameterDescriptorImpl]

'position' @ [538:91] ==> value-parameter position: QualifierPosition defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.quickResolveToPackage[ValueParameterDescriptorImpl]

'Pair' @ [539:24] ==> public constructor Pair<out A, out B>(first: PackageViewDescriptor, second: Int) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> PackageViewDescriptor
    <out B> -> Int

'packageDescriptor' @ [539:29] ==> val packageDescriptor: PackageViewDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.quickResolveToPackage[LocalVariableDescriptor]

'prefixSize' @ [539:48] ==> var prefixSize: Int defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.quickResolveToPackage[LocalVariableDescriptor]

'fqName' @ [541:13] ==> var fqName: FqName defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.quickResolveToPackage[LocalVariableDescriptor]

'fqName' @ [541:22] ==> var fqName: FqName defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.quickResolveToPackage[LocalVariableDescriptor]

'parent' @ [541:29] ==> @NotNull public open fun parent(): FqName defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'prefixSize' @ [542:13] ==> var prefixSize: Int defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.quickResolveToPackage[LocalVariableDescriptor]

'Pair' @ [544:16] ==> public constructor Pair<out A, out B>(first: PackageViewDescriptor, second: Int) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> PackageViewDescriptor
    <out B> -> Int

'getPackage' @ [544:21] ==> public abstract fun getPackage(fqName: FqName): PackageViewDescriptor defined in org.jetbrains.kotlin.descriptors.ModuleDescriptor[DeserializedSimpleFunctionDescriptor]

'ROOT' @ [544:39] ==> public final val ROOT: (FqName..FqName?) defined in org.jetbrains.kotlin.name.FqName[JavaPropertyDescriptor]

'path' @ [553:9] ==> value-parameter path: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.recordPackageViews[ValueParameterDescriptorImpl]

'foldRight' @ [553:14] ==> public inline fun <T, R> List<QualifiedExpressionResolver.QualifierPart>.foldRight(initial: PackageViewDescriptor, operation: (QualifiedExpressionResolver.QualifierPart, PackageViewDescriptor) -> PackageViewDescriptor): PackageViewDescriptor defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> QualifierPart
    <R> -> PackageViewDescriptor

'packageView' @ [553:24] ==> value-parameter packageView: PackageViewDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.recordPackageViews[ValueParameterDescriptorImpl]

'component1' @ [553:40] ==> public final operator fun component1(): Name defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[SimpleFunctionDescriptorImpl]

'component2' @ [553:43] ==> public final operator fun component2(): KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.QualifierPart[SimpleFunctionDescriptorImpl]

'storeResult' @ [554:13] ==> private final fun storeResult(trace: BindingTrace, referenceExpression: KtSimpleNameExpression, descriptor: DeclarationDescriptor?, shouldBeVisibleFrom: DeclarationDescriptor?, position: QualifierPosition, isQualifier: Boolean = ...): Qualifier? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'trace' @ [554:25] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.recordPackageViews[ValueParameterDescriptorImpl]

'expression' @ [554:32] ==> val expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.recordPackageViews.<anonymous>[LocalVariableDescriptor]

'currentView' @ [554:44] ==> value-parameter currentView: PackageViewDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.recordPackageViews.<anonymous>[ValueParameterDescriptorImpl]

'position' @ [554:96] ==> value-parameter position: QualifierPosition defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.recordPackageViews[ValueParameterDescriptorImpl]

'currentView' @ [555:13] ==> value-parameter currentView: PackageViewDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.recordPackageViews.<anonymous>[ValueParameterDescriptorImpl]

'containingDeclaration' @ [555:25] ==> public final val PackageViewDescriptor.containingDeclaration: PackageViewDescriptor?[MyPropertyDescriptor]

'error' @ [556:16] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'+' @ [556:22] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'currentView' @ [556:90] ==> value-parameter currentView: PackageViewDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.recordPackageViews.<anonymous>[ValueParameterDescriptorImpl]

'fqName' @ [556:102] ==> public abstract val fqName: FqName defined in org.jetbrains.kotlin.descriptors.PackageViewDescriptor[DeserializedPropertyDescriptor]

'path' @ [557:31] ==> value-parameter path: List<QualifiedExpressionResolver.QualifierPart> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.recordPackageViews[ValueParameterDescriptorImpl]

'joinToString' @ [557:36] ==> public fun <T> Iterable<QualifiedExpressionResolver.QualifierPart>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((QualifiedExpressionResolver.QualifierPart) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> QualifierPart

'packageView' @ [557:75] ==> value-parameter packageView: PackageViewDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.recordPackageViews[ValueParameterDescriptorImpl]

'fqName' @ [557:87] ==> public abstract val fqName: FqName defined in org.jetbrains.kotlin.descriptors.PackageViewDescriptor[DeserializedPropertyDescriptor]

'if (descriptors.size > 1) {
            val visibleDescriptors = descriptors.filter { isVisible(it, shouldBeVisibleFrom, position) }
            when {
                visibleDescriptors.isEmpty() -> {
                    val descriptor = descriptors.first() as DeclarationDescriptorWithVisibility
                    trace.report(Errors.INVISIBLE_REFERENCE.on(referenceExpression, descriptor, descriptor.visibility, descriptor))
                }
                visibleDescriptors.size > 1 -> {
                    trace.record(BindingContext.AMBIGUOUS_REFERENCE_TARGET, referenceExpression, visibleDescriptors)
                }
                else -> {
                    storeResult(trace, referenceExpression, visibleDescriptors.single(), null, position, isQualifier)
                }
            }
        }
        else {
            storeResult(trace, referenceExpression, descriptors.singleOrNull(), shouldBeVisibleFrom, position, isQualifier)
        }' @ [569:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any?, elseBranch: Any?): Any?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any?

'descriptors' @ [569:13] ==> value-parameter descriptors: Collection<DeclarationDescriptor> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'size' @ [569:25] ==> public abstract val size: Int defined in kotlin.collections.Collection[DeserializedPropertyDescriptor]

'descriptors' @ [570:38] ==> value-parameter descriptors: Collection<DeclarationDescriptor> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'filter' @ [570:50] ==> public inline fun <T> Iterable<DeclarationDescriptor>.filter(predicate: (DeclarationDescriptor) -> Boolean): List<DeclarationDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DeclarationDescriptor

'isVisible' @ [570:59] ==> internal fun isVisible(descriptor: DeclarationDescriptor, shouldBeVisibleFrom: DeclarationDescriptor?, position: QualifierPosition): Boolean defined in org.jetbrains.kotlin.resolve in file QualifiedExpressionResolver.kt[SimpleFunctionDescriptorImpl]

'it' @ [570:69] ==> value-parameter it: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult.<anonymous>[ValueParameterDescriptorImpl]

'shouldBeVisibleFrom' @ [570:73] ==> value-parameter shouldBeVisibleFrom: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'position' @ [570:94] ==> value-parameter position: QualifierPosition defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'when {
                visibleDescriptors.isEmpty() -> {
                    val descriptor = descriptors.first() as DeclarationDescriptorWithVisibility
                    trace.report(Errors.INVISIBLE_REFERENCE.on(referenceExpression, descriptor, descriptor.visibility, descriptor))
                }
                visibleDescriptors.size > 1 -> {
                    trace.record(BindingContext.AMBIGUOUS_REFERENCE_TARGET, referenceExpression, visibleDescriptors)
                }
                else -> {
                    storeResult(trace, referenceExpression, visibleDescriptors.single(), null, position, isQualifier)
                }
            }' @ [571:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Any?, entry1: Any?, entry2: Any?): Any?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Any?

'visibleDescriptors' @ [572:17] ==> val visibleDescriptors: List<DeclarationDescriptor> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[LocalVariableDescriptor]

'isEmpty' @ [572:36] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'descriptors' @ [573:38] ==> value-parameter descriptors: Collection<DeclarationDescriptor> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'first' @ [573:50] ==> public fun <T> Iterable<DeclarationDescriptor>.first(): DeclarationDescriptor defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DeclarationDescriptor

'trace' @ [574:21] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'report' @ [574:27] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'INVISIBLE_REFERENCE' @ [574:41] ==> public final val INVISIBLE_REFERENCE: (DiagnosticFactory3<(KtSimpleNameExpression..KtSimpleNameExpression?), (DeclarationDescriptor..DeclarationDescriptor?), (Visibility..Visibility?), (DeclarationDescriptor..DeclarationDescriptor?)>..DiagnosticFactory3<(KtSimpleNameExpression..KtSimpleNameExpression?), (DeclarationDescriptor..DeclarationDescriptor?), (Visibility..Visibility?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [574:61] ==> @NotNull public open fun on(@NotNull element: KtSimpleNameExpression, @NotNull a: DeclarationDescriptor, @NotNull b: Visibility, @NotNull c: DeclarationDescriptor): ParametrizedDiagnostic<(KtSimpleNameExpression..KtSimpleNameExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory3[JavaMethodDescriptor]

'referenceExpression' @ [574:64] ==> value-parameter referenceExpression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'descriptor' @ [574:85] ==> val descriptor: DeclarationDescriptorWithVisibility defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[LocalVariableDescriptor]

'descriptor' @ [574:97] ==> val descriptor: DeclarationDescriptorWithVisibility defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[LocalVariableDescriptor]

'visibility' @ [574:108] ==> public final val DeclarationDescriptorWithVisibility.visibility: Visibility[MyPropertyDescriptor]

'descriptor' @ [574:120] ==> val descriptor: DeclarationDescriptorWithVisibility defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[LocalVariableDescriptor]

'visibleDescriptors' @ [576:17] ==> val visibleDescriptors: List<DeclarationDescriptor> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[LocalVariableDescriptor]

'size' @ [576:36] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'trace' @ [577:21] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'record' @ [577:27] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(KtExpression..KtExpression?), (Collection<DeclarationDescriptor>..Collection<(DeclarationDescriptor..DeclarationDescriptor?)>?)>..WritableSlice<(KtExpression..KtExpression?), (Collection<DeclarationDescriptor>..Collection<(DeclarationDescriptor..DeclarationDescriptor?)>?)>?), key: (KtExpression..KtExpression?), value: (Collection<DeclarationDescriptor>..Collection<(DeclarationDescriptor..DeclarationDescriptor?)>?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> KtExpression
    <V : (Any..Any?)> -> (kotlin.collections.Collection<org.jetbrains.kotlin.descriptors.DeclarationDescriptor>..kotlin.collections.Collection<(org.jetbrains.kotlin.descriptors.DeclarationDescriptor..org.jetbrains.kotlin.descriptors.DeclarationDescriptor?)>)

'AMBIGUOUS_REFERENCE_TARGET' @ [577:49] ==> public final val AMBIGUOUS_REFERENCE_TARGET: (WritableSlice<(KtExpression..KtExpression?), (MutableCollection<out (DeclarationDescriptor..DeclarationDescriptor?)>..Collection<(DeclarationDescriptor..DeclarationDescriptor?)>?)>..WritableSlice<(KtExpression..KtExpression?), (MutableCollection<out (DeclarationDescriptor..DeclarationDescriptor?)>..Collection<(DeclarationDescriptor..DeclarationDescriptor?)>?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'referenceExpression' @ [577:77] ==> value-parameter referenceExpression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'visibleDescriptors' @ [577:98] ==> val visibleDescriptors: List<DeclarationDescriptor> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[LocalVariableDescriptor]

'storeResult' @ [580:21] ==> private final fun storeResult(trace: BindingTrace, referenceExpression: KtSimpleNameExpression, descriptor: DeclarationDescriptor?, shouldBeVisibleFrom: DeclarationDescriptor?, position: QualifierPosition, isQualifier: Boolean = ...): Qualifier? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'trace' @ [580:33] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'referenceExpression' @ [580:40] ==> value-parameter referenceExpression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'visibleDescriptors' @ [580:61] ==> val visibleDescriptors: List<DeclarationDescriptor> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[LocalVariableDescriptor]

'single' @ [580:80] ==> public fun <T> List<DeclarationDescriptor>.single(): DeclarationDescriptor defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DeclarationDescriptor

'position' @ [580:96] ==> value-parameter position: QualifierPosition defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'isQualifier' @ [580:106] ==> value-parameter isQualifier: Boolean = ... defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'storeResult' @ [585:13] ==> private final fun storeResult(trace: BindingTrace, referenceExpression: KtSimpleNameExpression, descriptor: DeclarationDescriptor?, shouldBeVisibleFrom: DeclarationDescriptor?, position: QualifierPosition, isQualifier: Boolean = ...): Qualifier? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'trace' @ [585:25] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'referenceExpression' @ [585:32] ==> value-parameter referenceExpression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'descriptors' @ [585:53] ==> value-parameter descriptors: Collection<DeclarationDescriptor> defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'singleOrNull' @ [585:65] ==> public fun <T> Iterable<DeclarationDescriptor>.singleOrNull(): DeclarationDescriptor? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DeclarationDescriptor

'shouldBeVisibleFrom' @ [585:81] ==> value-parameter shouldBeVisibleFrom: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'position' @ [585:102] ==> value-parameter position: QualifierPosition defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'isQualifier' @ [585:112] ==> value-parameter isQualifier: Boolean = ... defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'descriptor' @ [597:13] ==> value-parameter descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'trace' @ [598:13] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'report' @ [598:19] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'UNRESOLVED_REFERENCE' @ [598:33] ==> public final val UNRESOLVED_REFERENCE: (DiagnosticFactory1<(KtReferenceExpression..KtReferenceExpression?), (KtReferenceExpression..KtReferenceExpression?)>..DiagnosticFactory1<(KtReferenceExpression..KtReferenceExpression?), (KtReferenceExpression..KtReferenceExpression?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [598:54] ==> @NotNull public open fun on(@NotNull element: KtReferenceExpression, @NotNull argument: KtReferenceExpression): ParametrizedDiagnostic<(KtReferenceExpression..KtReferenceExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory1[JavaMethodDescriptor]

'referenceExpression' @ [598:57] ==> value-parameter referenceExpression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'referenceExpression' @ [598:78] ==> value-parameter referenceExpression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'trace' @ [602:9] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'record' @ [602:15] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?), key: (KtReferenceExpression..KtReferenceExpression?), value: (DeclarationDescriptor..DeclarationDescriptor?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> KtReferenceExpression
    <V : (Any..Any?)> -> DeclarationDescriptor

'REFERENCE_TARGET' @ [602:37] ==> public final val REFERENCE_TARGET: (WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'referenceExpression' @ [602:55] ==> value-parameter referenceExpression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'descriptor' @ [602:76] ==> value-parameter descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'UnderscoreUsageChecker' @ [604:9] ==> public object UnderscoreUsageChecker : CallChecker defined in org.jetbrains.kotlin.resolve.calls.checkers in file UnderscoreUsageChecker.kt[FakeCallableDescriptorForObject]

'checkSimpleNameUsage' @ [604:32] ==> public final fun checkSimpleNameUsage(descriptor: DeclarationDescriptor, ktName: KtSimpleNameExpression, trace: BindingTrace): Unit defined in org.jetbrains.kotlin.resolve.calls.checkers.UnderscoreUsageChecker[SimpleFunctionDescriptorImpl]

'descriptor' @ [604:53] ==> value-parameter descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'referenceExpression' @ [604:65] ==> value-parameter referenceExpression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'trace' @ [604:86] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'descriptor' @ [606:13] ==> value-parameter descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'if (shouldBeVisibleFrom is PackageFragmentDescriptor && shouldBeVisibleFrom.source == SourceElement.NO_SOURCE && referenceExpression.containingFile !is DummyHolder) {
                        PackageFragmentWithCustomSource(shouldBeVisibleFrom, KotlinSourceElement(referenceExpression.containingKtFile))
                    }
                    else {
                        shouldBeVisibleFrom
                    }' @ [608:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: DeclarationDescriptor?, elseBranch: DeclarationDescriptor?): DeclarationDescriptor?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> DeclarationDescriptor?

'shouldBeVisibleFrom' @ [608:25] ==> value-parameter shouldBeVisibleFrom: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'shouldBeVisibleFrom' @ [608:77] ==> value-parameter shouldBeVisibleFrom: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'source' @ [608:97] ==> public final val PackageFragmentDescriptor.source: SourceElement[MyPropertyDescriptor]

'NO_SOURCE' @ [608:121] ==> public final val NO_SOURCE: (SourceElement..SourceElement?) defined in org.jetbrains.kotlin.descriptors.SourceElement[JavaPropertyDescriptor]

'referenceExpression' @ [608:134] ==> value-parameter referenceExpression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'containingFile' @ [608:154] ==> public final val KtSimpleNameExpression.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'PackageFragmentWithCustomSource' @ [609:25] ==> public constructor PackageFragmentWithCustomSource(original: PackageFragmentDescriptor, source: SourceElement) defined in org.jetbrains.kotlin.resolve.PackageFragmentWithCustomSource[ClassConstructorDescriptorImpl]

'shouldBeVisibleFrom' @ [609:57] ==> value-parameter shouldBeVisibleFrom: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'KotlinSourceElement' @ [609:78] ==> public constructor KotlinSourceElement(psi: KtElement) defined in org.jetbrains.kotlin.resolve.source.KotlinSourceElement[ClassConstructorDescriptorImpl]

'referenceExpression' @ [609:98] ==> value-parameter referenceExpression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'containingKtFile' @ [609:118] ==> public final val KtSimpleNameExpression.containingKtFile: KtFile[MyPropertyDescriptor]

'shouldBeVisibleFrom' @ [612:25] ==> value-parameter shouldBeVisibleFrom: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'!' @ [614:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isVisible' @ [614:18] ==> internal fun isVisible(descriptor: DeclarationDescriptor, shouldBeVisibleFrom: DeclarationDescriptor?, position: QualifierPosition): Boolean defined in org.jetbrains.kotlin.resolve in file QualifiedExpressionResolver.kt[SimpleFunctionDescriptorImpl]

'descriptor' @ [614:28] ==> value-parameter descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'fromToCheck' @ [614:40] ==> val fromToCheck: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[LocalVariableDescriptor]

'position' @ [614:53] ==> value-parameter position: QualifierPosition defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'trace' @ [615:17] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'report' @ [615:23] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'INVISIBLE_REFERENCE' @ [615:37] ==> public final val INVISIBLE_REFERENCE: (DiagnosticFactory3<(KtSimpleNameExpression..KtSimpleNameExpression?), (DeclarationDescriptor..DeclarationDescriptor?), (Visibility..Visibility?), (DeclarationDescriptor..DeclarationDescriptor?)>..DiagnosticFactory3<(KtSimpleNameExpression..KtSimpleNameExpression?), (DeclarationDescriptor..DeclarationDescriptor?), (Visibility..Visibility?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [615:57] ==> @NotNull public open fun on(@NotNull element: KtSimpleNameExpression, @NotNull a: DeclarationDescriptor, @NotNull b: Visibility, @NotNull c: DeclarationDescriptor): ParametrizedDiagnostic<(KtSimpleNameExpression..KtSimpleNameExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory3[JavaMethodDescriptor]

'referenceExpression' @ [615:60] ==> value-parameter referenceExpression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'descriptor' @ [615:81] ==> value-parameter descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'descriptor' @ [615:93] ==> value-parameter descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'visibility' @ [615:104] ==> public final val DeclarationDescriptorWithVisibility.visibility: Visibility[MyPropertyDescriptor]

'descriptor' @ [615:116] ==> value-parameter descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'if (isQualifier) storeQualifier(trace, referenceExpression, descriptor) else null' @ [619:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Qualifier?, elseBranch: Qualifier?): Qualifier?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Qualifier?

'isQualifier' @ [619:20] ==> value-parameter isQualifier: Boolean = ... defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'storeQualifier' @ [619:33] ==> private final fun storeQualifier(trace: BindingTrace, referenceExpression: KtSimpleNameExpression, descriptor: DeclarationDescriptor): Qualifier? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver[SimpleFunctionDescriptorImpl]

'trace' @ [619:48] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'referenceExpression' @ [619:55] ==> value-parameter referenceExpression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'descriptor' @ [619:76] ==> value-parameter descriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeResult[ValueParameterDescriptorImpl]

'when (descriptor) {
                    is PackageViewDescriptor -> PackageQualifier(referenceExpression, descriptor)
                    is ClassDescriptor -> ClassQualifier(referenceExpression, descriptor)
                    is TypeParameterDescriptor -> TypeParameterQualifier(referenceExpression, descriptor)
                    is TypeAliasDescriptor -> {
                        val classDescriptor = descriptor.classDescriptor ?: return null
                        TypeAliasQualifier(referenceExpression, descriptor, classDescriptor)
                    }
                    else -> return null
                }' @ [624:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Qualifier, entry1: Qualifier, entry2: Qualifier, entry3: Qualifier, entry4: Qualifier): Qualifier[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Qualifier

'descriptor' @ [624:23] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeQualifier[ValueParameterDescriptorImpl]

'PackageQualifier' @ [625:49] ==> public constructor PackageQualifier(referenceExpression: KtSimpleNameExpression, descriptor: PackageViewDescriptor) defined in org.jetbrains.kotlin.resolve.scopes.receivers.PackageQualifier[ClassConstructorDescriptorImpl]

'referenceExpression' @ [625:66] ==> value-parameter referenceExpression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeQualifier[ValueParameterDescriptorImpl]

'descriptor' @ [625:87] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeQualifier[ValueParameterDescriptorImpl]

'ClassQualifier' @ [626:43] ==> public constructor ClassQualifier(referenceExpression: KtSimpleNameExpression, descriptor: ClassDescriptor) defined in org.jetbrains.kotlin.resolve.scopes.receivers.ClassQualifier[ClassConstructorDescriptorImpl]

'referenceExpression' @ [626:58] ==> value-parameter referenceExpression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeQualifier[ValueParameterDescriptorImpl]

'descriptor' @ [626:79] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeQualifier[ValueParameterDescriptorImpl]

'TypeParameterQualifier' @ [627:51] ==> public constructor TypeParameterQualifier(referenceExpression: KtSimpleNameExpression, descriptor: TypeParameterDescriptor) defined in org.jetbrains.kotlin.resolve.scopes.receivers.TypeParameterQualifier[ClassConstructorDescriptorImpl]

'referenceExpression' @ [627:74] ==> value-parameter referenceExpression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeQualifier[ValueParameterDescriptorImpl]

'descriptor' @ [627:95] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeQualifier[ValueParameterDescriptorImpl]

'descriptor' @ [629:47] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeQualifier[ValueParameterDescriptorImpl]

'classDescriptor' @ [629:58] ==> public abstract val classDescriptor: ClassDescriptor? defined in org.jetbrains.kotlin.descriptors.TypeAliasDescriptor[DeserializedPropertyDescriptor]

'TypeAliasQualifier' @ [630:25] ==> public constructor TypeAliasQualifier(referenceExpression: KtSimpleNameExpression, descriptor: TypeAliasDescriptor, classDescriptor: ClassDescriptor) defined in org.jetbrains.kotlin.resolve.scopes.receivers.TypeAliasQualifier[ClassConstructorDescriptorImpl]

'referenceExpression' @ [630:44] ==> value-parameter referenceExpression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeQualifier[ValueParameterDescriptorImpl]

'descriptor' @ [630:65] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeQualifier[ValueParameterDescriptorImpl]

'classDescriptor' @ [630:77] ==> val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeQualifier[LocalVariableDescriptor]

'trace' @ [635:9] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeQualifier[ValueParameterDescriptorImpl]

'record' @ [635:15] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(KtExpression..KtExpression?), (Qualifier..Qualifier?)>..WritableSlice<(KtExpression..KtExpression?), (Qualifier..Qualifier?)>?), key: (KtExpression..KtExpression?), value: (Qualifier..Qualifier?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> KtExpression
    <V : (Any..Any?)> -> Qualifier

'QUALIFIER' @ [635:37] ==> public final val QUALIFIER: (WritableSlice<(KtExpression..KtExpression?), (Qualifier..Qualifier?)>..WritableSlice<(KtExpression..KtExpression?), (Qualifier..Qualifier?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'qualifier' @ [635:48] ==> val qualifier: Qualifier defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeQualifier[LocalVariableDescriptor]

'expression' @ [635:58] ==> public val Qualifier.expression: KtExpression defined in org.jetbrains.kotlin.resolve.scopes.receivers in file Qualifier.kt[PropertyDescriptorImpl]

'qualifier' @ [635:70] ==> val qualifier: Qualifier defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeQualifier[LocalVariableDescriptor]

'qualifier' @ [637:16] ==> val qualifier: Qualifier defined in org.jetbrains.kotlin.resolve.QualifiedExpressionResolver.storeQualifier[LocalVariableDescriptor]

'descriptor' @ [646:9] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.isVisible[ValueParameterDescriptorImpl]

'shouldBeVisibleFrom' @ [646:63] ==> value-parameter shouldBeVisibleFrom: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.isVisible[ValueParameterDescriptorImpl]

'descriptor' @ [648:22] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.isVisible[ValueParameterDescriptorImpl]

'visibility' @ [648:33] ==> public final val DeclarationDescriptorWithVisibility.visibility: Visibility[MyPropertyDescriptor]

'position' @ [649:9] ==> value-parameter position: QualifierPosition defined in org.jetbrains.kotlin.resolve.isVisible[ValueParameterDescriptorImpl]

'IMPORT' @ [649:39] ==> enum entry IMPORT defined in org.jetbrains.kotlin.resolve.QualifierPosition[FakeCallableDescriptorForObject]

'isPrivate' @ [650:26] ==> public open fun isPrivate(@NotNull p0: Visibility): Boolean defined in org.jetbrains.kotlin.descriptors.Visibilities[JavaMethodDescriptor]

'visibility' @ [650:36] ==> val visibility: Visibility defined in org.jetbrains.kotlin.resolve.isVisible[LocalVariableDescriptor]

'inSameFile' @ [650:69] ==> public open fun inSameFile(@NotNull p0: DeclarationDescriptor, @NotNull p1: DeclarationDescriptor): Boolean defined in org.jetbrains.kotlin.descriptors.Visibilities[JavaMethodDescriptor]

'descriptor' @ [650:80] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.isVisible[ValueParameterDescriptorImpl]

'shouldBeVisibleFrom' @ [650:92] ==> value-parameter shouldBeVisibleFrom: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.isVisible[ValueParameterDescriptorImpl]

'!' @ [651:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'visibility' @ [651:14] ==> val visibility: Visibility defined in org.jetbrains.kotlin.resolve.isVisible[LocalVariableDescriptor]

'mustCheckInImports' @ [651:25] ==> public abstract fun mustCheckInImports(): Boolean defined in org.jetbrains.kotlin.descriptors.Visibility[DeserializedSimpleFunctionDescriptor]

'isVisibleIgnoringReceiver' @ [653:25] ==> public open fun isVisibleIgnoringReceiver(@NotNull p0: DeclarationDescriptorWithVisibility, @NotNull p1: DeclarationDescriptor): Boolean defined in org.jetbrains.kotlin.descriptors.Visibilities[JavaMethodDescriptor]

'descriptor' @ [653:51] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.isVisible[ValueParameterDescriptorImpl]

'shouldBeVisibleFrom' @ [653:63] ==> value-parameter shouldBeVisibleFrom: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.isVisible[ValueParameterDescriptorImpl]

'original' @ [664:162] ==> value-parameter original: PackageFragmentDescriptor defined in org.jetbrains.kotlin.resolve.PackageFragmentWithCustomSource.<init>[ValueParameterDescriptorImpl]

'source' @ [665:47] ==> private final val source: SourceElement defined in org.jetbrains.kotlin.resolve.PackageFragmentWithCustomSource[PropertyDescriptorImpl]

