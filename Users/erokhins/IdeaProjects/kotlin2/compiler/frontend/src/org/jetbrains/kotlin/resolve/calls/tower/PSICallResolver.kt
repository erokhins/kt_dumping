'special' @ [78:46] ==> @NotNull public open fun special(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'isBinaryRemOperator' @ [86:35] ==> public fun isBinaryRemOperator(call: Call): Boolean defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil in file CallResolverUtil.kt[SimpleFunctionDescriptorImpl]

'context' @ [86:55] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[ValueParameterDescriptorImpl]

'call' @ [86:63] ==> @NotNull public final val call: Call defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'refineNameForRemOperator' @ [87:27] ==> private final fun refineNameForRemOperator(isBinaryRemOperator: Boolean, name: Name): Name defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'isBinaryRemOperator' @ [87:52] ==> val isBinaryRemOperator: Boolean defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[LocalVariableDescriptor]

'name' @ [87:73] ==> value-parameter name: Name defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[ValueParameterDescriptorImpl]

'toKotlinCall' @ [89:26] ==> private final fun toKotlinCall(context: BasicCallResolutionContext, kotlinCallKind: KotlinCallKind, oldCall: Call, name: Name, tracingStrategy: TracingStrategy, forcedExplicitReceiver: Receiver? = ...): PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'context' @ [89:39] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[ValueParameterDescriptorImpl]

'resolutionKind' @ [89:48] ==> value-parameter resolutionKind: NewResolutionOldInference.ResolutionKind<D> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[ValueParameterDescriptorImpl]

'kotlinCallKind' @ [89:63] ==> public final val kotlinCallKind: KotlinCallKind defined in org.jetbrains.kotlin.resolve.calls.tower.NewResolutionOldInference.ResolutionKind[PropertyDescriptorImpl]

'context' @ [89:79] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[ValueParameterDescriptorImpl]

'call' @ [89:87] ==> @NotNull public final val call: Call defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'refinedName' @ [89:93] ==> val refinedName: Name defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[LocalVariableDescriptor]

'tracingStrategy' @ [89:106] ==> value-parameter tracingStrategy: TracingStrategy defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[ValueParameterDescriptorImpl]

'ASTScopeTower' @ [90:26] ==> public constructor ASTScopeTower(context: ResolutionContext<*>, call: Call) defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.ASTScopeTower[ClassConstructorDescriptorImpl]

'context' @ [90:40] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[ValueParameterDescriptorImpl]

'context' @ [90:49] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[ValueParameterDescriptorImpl]

'call' @ [90:57] ==> @NotNull public final val call: Call defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'createResolutionCallbacks' @ [91:35] ==> private final fun createResolutionCallbacks(context: BasicCallResolutionContext): KotlinResolutionCallbacksImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'context' @ [91:61] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[ValueParameterDescriptorImpl]

'FactoryProviderForInvoke' @ [93:40] ==> public constructor FactoryProviderForInvoke(context: BasicCallResolutionContext, scopeTower: ImplicitScopeTower, kotlinCall: PSIKotlinCallImpl) defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke[ClassConstructorDescriptorImpl]

'context' @ [93:65] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[ValueParameterDescriptorImpl]

'scopeTower' @ [93:74] ==> val scopeTower: PSICallResolver.ASTScopeTower defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[LocalVariableDescriptor]

'kotlinCall' @ [93:86] ==> val kotlinCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[LocalVariableDescriptor]

'calculateExpectedType' @ [95:28] ==> private final fun calculateExpectedType(context: BasicCallResolutionContext): UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'context' @ [95:50] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[ValueParameterDescriptorImpl]

'kotlinCallResolver' @ [96:22] ==> private final val kotlinCallResolver: KotlinCallResolver defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[PropertyDescriptorImpl]

'resolveCall' @ [96:41] ==> public final fun resolveCall(scopeTower: ImplicitScopeTower, resolutionCallbacks: KotlinResolutionCallbacks, kotlinCall: KotlinCall, expectedType: UnwrappedType?, factoryProviderForInvoke: CandidateFactoryProviderForInvoke<KotlinResolutionCandidate>, collectAllCandidates: Boolean): CallResolutionResult defined in org.jetbrains.kotlin.resolve.calls.KotlinCallResolver[DeserializedSimpleFunctionDescriptor]

'scopeTower' @ [97:17] ==> val scopeTower: PSICallResolver.ASTScopeTower defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[LocalVariableDescriptor]

'resolutionCallbacks' @ [97:29] ==> val resolutionCallbacks: KotlinResolutionCallbacksImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[LocalVariableDescriptor]

'kotlinCall' @ [97:50] ==> val kotlinCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[LocalVariableDescriptor]

'expectedType' @ [97:62] ==> val expectedType: UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[LocalVariableDescriptor]

'factoryProviderForInvoke' @ [97:76] ==> val factoryProviderForInvoke: PSICallResolver.FactoryProviderForInvoke defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[LocalVariableDescriptor]

'context' @ [97:102] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[ValueParameterDescriptorImpl]

'collectAllCandidates' @ [97:110] ==> public final val collectAllCandidates: Boolean defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'languageVersionSettings' @ [99:36] ==> private final val languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[PropertyDescriptorImpl]

'supportsFeature' @ [99:60] ==> public open fun supportsFeature(feature: LanguageFeature): Boolean defined in org.jetbrains.kotlin.config.LanguageVersionSettings[DeserializedSimpleFunctionDescriptor]

'OperatorRem' @ [99:92] ==> enum entry OperatorRem defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'isBinaryRemOperator' @ [100:13] ==> val isBinaryRemOperator: Boolean defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[LocalVariableDescriptor]

'shouldUseOperatorRem' @ [100:36] ==> val shouldUseOperatorRem: Boolean defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[LocalVariableDescriptor]

'result' @ [100:61] ==> var result: CallResolutionResult defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[LocalVariableDescriptor]

'isEmpty' @ [100:68] ==> private final fun CallResolutionResult.isEmpty(): Boolean defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'result' @ [100:81] ==> var result: CallResolutionResult defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[LocalVariableDescriptor]

'areAllInapplicable' @ [100:88] ==> private final fun CallResolutionResult.areAllInapplicable(): Boolean defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'result' @ [101:13] ==> var result: CallResolutionResult defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[LocalVariableDescriptor]

'resolveToDeprecatedMod' @ [101:22] ==> private final fun <D : CallableDescriptor> resolveToDeprecatedMod(remOperatorName: Name, context: BasicCallResolutionContext, resolutionKind: NewResolutionOldInference.ResolutionKind<D>, tracingStrategy: TracingStrategy, scopeTower: ImplicitScopeTower, resolutionCallbacks: KotlinResolutionCallbacksImpl, expectedType: UnwrappedType?): CallResolutionResult defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]
Inferred types:
    <D : CallableDescriptor> -> D

'name' @ [101:45] ==> value-parameter name: Name defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[ValueParameterDescriptorImpl]

'context' @ [101:51] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[ValueParameterDescriptorImpl]

'resolutionKind' @ [101:60] ==> value-parameter resolutionKind: NewResolutionOldInference.ResolutionKind<D> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[ValueParameterDescriptorImpl]

'tracingStrategy' @ [101:76] ==> value-parameter tracingStrategy: TracingStrategy defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[ValueParameterDescriptorImpl]

'scopeTower' @ [101:93] ==> val scopeTower: PSICallResolver.ASTScopeTower defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[LocalVariableDescriptor]

'resolutionCallbacks' @ [101:105] ==> val resolutionCallbacks: KotlinResolutionCallbacksImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[LocalVariableDescriptor]

'expectedType' @ [101:126] ==> val expectedType: UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[LocalVariableDescriptor]

'result' @ [104:13] ==> var result: CallResolutionResult defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[LocalVariableDescriptor]

'isEmpty' @ [104:20] ==> private final fun CallResolutionResult.isEmpty(): Boolean defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'reportAdditionalDiagnosticIfNoCandidates' @ [104:33] ==> private final fun reportAdditionalDiagnosticIfNoCandidates(context: BasicCallResolutionContext, scopeTower: ImplicitScopeTower, kind: KotlinCallKind, kotlinCall: KotlinCall): Boolean defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'context' @ [104:74] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[ValueParameterDescriptorImpl]

'scopeTower' @ [104:83] ==> val scopeTower: PSICallResolver.ASTScopeTower defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[LocalVariableDescriptor]

'resolutionKind' @ [104:95] ==> value-parameter resolutionKind: NewResolutionOldInference.ResolutionKind<D> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[ValueParameterDescriptorImpl]

'kotlinCallKind' @ [104:110] ==> public final val kotlinCallKind: KotlinCallKind defined in org.jetbrains.kotlin.resolve.calls.tower.NewResolutionOldInference.ResolutionKind[PropertyDescriptorImpl]

'kotlinCall' @ [104:126] ==> val kotlinCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[LocalVariableDescriptor]

'nameNotFound' @ [105:50] ==> public open fun <D : (CallableDescriptor..CallableDescriptor?)> nameNotFound(): (OverloadResolutionResultsImpl<(D..D?)>..OverloadResolutionResultsImpl<(D..D?)>?) defined in org.jetbrains.kotlin.resolve.calls.results.OverloadResolutionResultsImpl[JavaMethodDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (D..D?)

'convertToOverloadResolutionResults' @ [108:16] ==> private final fun <D : CallableDescriptor> convertToOverloadResolutionResults(context: BasicCallResolutionContext, result: CallResolutionResult, tracingStrategy: TracingStrategy): OverloadResolutionResults<D> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]
Inferred types:
    <D : CallableDescriptor> -> D

'context' @ [108:51] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[ValueParameterDescriptorImpl]

'result' @ [108:60] ==> var result: CallResolutionResult defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[LocalVariableDescriptor]

'tracingStrategy' @ [108:68] ==> value-parameter tracingStrategy: TracingStrategy defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInference[ValueParameterDescriptorImpl]

'resolutionCandidates' @ [117:32] ==> value-parameter resolutionCandidates: Collection<ResolutionCandidate<D>> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInferenceForGivenCandidates[ValueParameterDescriptorImpl]

'firstNotNullResult' @ [117:53] ==> public inline fun <T, R : Any> Iterable<ResolutionCandidate<D>>.firstNotNullResult(transform: (ResolutionCandidate<D>) -> ReceiverValue?): ReceiverValue? defined in org.jetbrains.kotlin.utils.addToStdlib[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ResolutionCandidate<D>
    <R : Any> -> ReceiverValue

'it' @ [117:74] ==> value-parameter it: ResolutionCandidate<D> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInferenceForGivenCandidates.<anonymous>[ValueParameterDescriptorImpl]

'dispatchReceiver' @ [117:77] ==> public final var <D : (CallableDescriptor..CallableDescriptor?)> ResolutionCandidate<D>.dispatchReceiver: ReceiverValue?[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> D

'toKotlinCall' @ [119:26] ==> private final fun toKotlinCall(context: BasicCallResolutionContext, kotlinCallKind: KotlinCallKind, oldCall: Call, name: Name, tracingStrategy: TracingStrategy, forcedExplicitReceiver: Receiver? = ...): PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'context' @ [119:39] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInferenceForGivenCandidates[ValueParameterDescriptorImpl]

'FUNCTION' @ [119:63] ==> enum entry FUNCTION defined in org.jetbrains.kotlin.resolve.calls.model.KotlinCallKind[FakeCallableDescriptorForObject]

'context' @ [119:73] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInferenceForGivenCandidates[ValueParameterDescriptorImpl]

'call' @ [119:81] ==> @NotNull public final val call: Call defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'GIVEN_CANDIDATES_NAME' @ [119:87] ==> private final val GIVEN_CANDIDATES_NAME: Name defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[PropertyDescriptorImpl]

'tracingStrategy' @ [119:110] ==> value-parameter tracingStrategy: TracingStrategy defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInferenceForGivenCandidates[ValueParameterDescriptorImpl]

'dispatchReceiver' @ [119:127] ==> val dispatchReceiver: ReceiverValue? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInferenceForGivenCandidates[LocalVariableDescriptor]

'ASTScopeTower' @ [120:26] ==> public constructor ASTScopeTower(context: ResolutionContext<*>, call: Call) defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.ASTScopeTower[ClassConstructorDescriptorImpl]

'context' @ [120:40] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInferenceForGivenCandidates[ValueParameterDescriptorImpl]

'context' @ [120:49] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInferenceForGivenCandidates[ValueParameterDescriptorImpl]

'call' @ [120:57] ==> @NotNull public final val call: Call defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'createResolutionCallbacks' @ [121:35] ==> private final fun createResolutionCallbacks(context: BasicCallResolutionContext): KotlinResolutionCallbacksImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'context' @ [121:61] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInferenceForGivenCandidates[ValueParameterDescriptorImpl]

'resolutionCandidates' @ [123:31] ==> value-parameter resolutionCandidates: Collection<ResolutionCandidate<D>> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInferenceForGivenCandidates[ValueParameterDescriptorImpl]

'map' @ [123:52] ==> public inline fun <T, R> Iterable<ResolutionCandidate<D>>.map(transform: (ResolutionCandidate<D>) -> GivenCandidate): List<GivenCandidate> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ResolutionCandidate<D>
    <R> -> GivenCandidate

'GivenCandidate' @ [124:13] ==> public constructor GivenCandidate(descriptor: FunctionDescriptor, dispatchReceiver: ReceiverValueWithSmartCastInfo?, knownTypeParametersResultingSubstitutor: TypeSubstitutor?) defined in org.jetbrains.kotlin.resolve.calls.model.GivenCandidate[DeserializedClassConstructorDescriptor]

'it' @ [124:28] ==> value-parameter it: ResolutionCandidate<D> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInferenceForGivenCandidates.<anonymous>[ValueParameterDescriptorImpl]

'descriptor' @ [124:31] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolutionCandidate<D>.descriptor: D[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> D

'it' @ [125:28] ==> value-parameter it: ResolutionCandidate<D> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInferenceForGivenCandidates.<anonymous>[ValueParameterDescriptorImpl]

'dispatchReceiver' @ [125:31] ==> public final var <D : (CallableDescriptor..CallableDescriptor?)> ResolutionCandidate<D>.dispatchReceiver: ReceiverValue?[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> D

'let' @ [125:49] ==> @InlineOnly public inline fun <T, R> ReceiverValue.let(block: (ReceiverValue) -> ReceiverValueWithSmartCastInfo): ReceiverValueWithSmartCastInfo defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ReceiverValue
    <R> -> ReceiverValueWithSmartCastInfo

'context' @ [125:55] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInferenceForGivenCandidates[ValueParameterDescriptorImpl]

'transformToReceiverWithSmartCastInfo' @ [125:63] ==> public fun ResolutionContext<*>.transformToReceiverWithSmartCastInfo(receiver: ReceiverValue): ReceiverValueWithSmartCastInfo defined in org.jetbrains.kotlin.resolve.calls.tower in file NewResolutionOldInference.kt[SimpleFunctionDescriptorImpl]

'it' @ [125:100] ==> value-parameter it: ReceiverValue defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInferenceForGivenCandidates.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [126:28] ==> value-parameter it: ResolutionCandidate<D> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInferenceForGivenCandidates.<anonymous>[ValueParameterDescriptorImpl]

'knownTypeParametersResultingSubstitutor' @ [126:31] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolutionCandidate<D>.knownTypeParametersResultingSubstitutor: TypeSubstitutor?[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> D

'kotlinCallResolver' @ [129:22] ==> private final val kotlinCallResolver: KotlinCallResolver defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[PropertyDescriptorImpl]

'resolveGivenCandidates' @ [129:41] ==> public final fun resolveGivenCandidates(scopeTower: ImplicitScopeTower, resolutionCallbacks: KotlinResolutionCallbacks, kotlinCall: KotlinCall, expectedType: UnwrappedType?, givenCandidates: Collection<GivenCandidate>, collectAllCandidates: Boolean): CallResolutionResult defined in org.jetbrains.kotlin.resolve.calls.KotlinCallResolver[DeserializedSimpleFunctionDescriptor]

'scopeTower' @ [130:17] ==> val scopeTower: PSICallResolver.ASTScopeTower defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInferenceForGivenCandidates[LocalVariableDescriptor]

'resolutionCallbacks' @ [130:29] ==> val resolutionCallbacks: KotlinResolutionCallbacksImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInferenceForGivenCandidates[LocalVariableDescriptor]

'kotlinCall' @ [130:50] ==> val kotlinCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInferenceForGivenCandidates[LocalVariableDescriptor]

'calculateExpectedType' @ [130:62] ==> private final fun calculateExpectedType(context: BasicCallResolutionContext): UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'context' @ [130:84] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInferenceForGivenCandidates[ValueParameterDescriptorImpl]

'givenCandidates' @ [130:94] ==> val givenCandidates: List<GivenCandidate> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInferenceForGivenCandidates[LocalVariableDescriptor]

'context' @ [130:111] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInferenceForGivenCandidates[ValueParameterDescriptorImpl]

'collectAllCandidates' @ [130:119] ==> public final val collectAllCandidates: Boolean defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'convertToOverloadResolutionResults' @ [131:16] ==> private final fun <D : CallableDescriptor> convertToOverloadResolutionResults(context: BasicCallResolutionContext, result: CallResolutionResult, tracingStrategy: TracingStrategy): OverloadResolutionResults<D> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]
Inferred types:
    <D : CallableDescriptor> -> D

'context' @ [131:51] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInferenceForGivenCandidates[ValueParameterDescriptorImpl]

'result' @ [131:60] ==> val result: CallResolutionResult defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInferenceForGivenCandidates[LocalVariableDescriptor]

'tracingStrategy' @ [131:68] ==> value-parameter tracingStrategy: TracingStrategy defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.runResolutionAndInferenceForGivenCandidates[ValueParameterDescriptorImpl]

'OperatorConventions.REM_TO_MOD_OPERATION_NAMES[remOperatorName]' @ [144:30] ==> public abstract fun get(@Nullable key: Name?): Name? defined in com.google.common.collect.ImmutableBiMap[JavaMethodDescriptor]

'REM_TO_MOD_OPERATION_NAMES' @ [144:50] ==> public final val REM_TO_MOD_OPERATION_NAMES: (ImmutableBiMap<(Name..Name?), (Name..Name?)>..ImmutableBiMap<(Name..Name?), (Name..Name?)>?) defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaPropertyDescriptor]

'remOperatorName' @ [144:77] ==> value-parameter remOperatorName: Name defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveToDeprecatedMod[ValueParameterDescriptorImpl]

'toKotlinCall' @ [145:38] ==> private final fun toKotlinCall(context: BasicCallResolutionContext, kotlinCallKind: KotlinCallKind, oldCall: Call, name: Name, tracingStrategy: TracingStrategy, forcedExplicitReceiver: Receiver? = ...): PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'context' @ [145:51] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveToDeprecatedMod[ValueParameterDescriptorImpl]

'resolutionKind' @ [145:60] ==> value-parameter resolutionKind: NewResolutionOldInference.ResolutionKind<D> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveToDeprecatedMod[ValueParameterDescriptorImpl]

'kotlinCallKind' @ [145:75] ==> public final val kotlinCallKind: KotlinCallKind defined in org.jetbrains.kotlin.resolve.calls.tower.NewResolutionOldInference.ResolutionKind[PropertyDescriptorImpl]

'context' @ [145:91] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveToDeprecatedMod[ValueParameterDescriptorImpl]

'call' @ [145:99] ==> @NotNull public final val call: Call defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'deprecatedName' @ [145:105] ==> val deprecatedName: Name defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveToDeprecatedMod[LocalVariableDescriptor]

'tracingStrategy' @ [145:121] ==> value-parameter tracingStrategy: TracingStrategy defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveToDeprecatedMod[ValueParameterDescriptorImpl]

'FactoryProviderForInvoke' @ [146:47] ==> public constructor FactoryProviderForInvoke(context: BasicCallResolutionContext, scopeTower: ImplicitScopeTower, kotlinCall: PSIKotlinCallImpl) defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke[ClassConstructorDescriptorImpl]

'context' @ [146:72] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveToDeprecatedMod[ValueParameterDescriptorImpl]

'scopeTower' @ [146:81] ==> value-parameter scopeTower: ImplicitScopeTower defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveToDeprecatedMod[ValueParameterDescriptorImpl]

'callWithDeprecatedName' @ [146:93] ==> val callWithDeprecatedName: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveToDeprecatedMod[LocalVariableDescriptor]

'kotlinCallResolver' @ [147:16] ==> private final val kotlinCallResolver: KotlinCallResolver defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[PropertyDescriptorImpl]

'resolveCall' @ [147:35] ==> public final fun resolveCall(scopeTower: ImplicitScopeTower, resolutionCallbacks: KotlinResolutionCallbacks, kotlinCall: KotlinCall, expectedType: UnwrappedType?, factoryProviderForInvoke: CandidateFactoryProviderForInvoke<KotlinResolutionCandidate>, collectAllCandidates: Boolean): CallResolutionResult defined in org.jetbrains.kotlin.resolve.calls.KotlinCallResolver[DeserializedSimpleFunctionDescriptor]

'scopeTower' @ [147:47] ==> value-parameter scopeTower: ImplicitScopeTower defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveToDeprecatedMod[ValueParameterDescriptorImpl]

'resolutionCallbacks' @ [147:59] ==> value-parameter resolutionCallbacks: KotlinResolutionCallbacksImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveToDeprecatedMod[ValueParameterDescriptorImpl]

'callWithDeprecatedName' @ [147:80] ==> val callWithDeprecatedName: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveToDeprecatedMod[LocalVariableDescriptor]

'expectedType' @ [147:104] ==> value-parameter expectedType: UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveToDeprecatedMod[ValueParameterDescriptorImpl]

'refinedProviderForInvokeFactory' @ [148:47] ==> val refinedProviderForInvokeFactory: PSICallResolver.FactoryProviderForInvoke defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveToDeprecatedMod[LocalVariableDescriptor]

'context' @ [148:80] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveToDeprecatedMod[ValueParameterDescriptorImpl]

'collectAllCandidates' @ [148:88] ==> public final val collectAllCandidates: Boolean defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'languageVersionSettings' @ [152:36] ==> private final val languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[PropertyDescriptorImpl]

'supportsFeature' @ [152:60] ==> public open fun supportsFeature(feature: LanguageFeature): Boolean defined in org.jetbrains.kotlin.config.LanguageVersionSettings[DeserializedSimpleFunctionDescriptor]

'OperatorRem' @ [152:92] ==> enum entry OperatorRem defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'if (isBinaryRemOperator && !shouldUseOperatorRem) OperatorConventions.REM_TO_MOD_OPERATION_NAMES[name]!! else name' @ [153:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Name, elseBranch: Name): Name[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Name

'isBinaryRemOperator' @ [153:20] ==> value-parameter isBinaryRemOperator: Boolean defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.refineNameForRemOperator[ValueParameterDescriptorImpl]

'!' @ [153:43] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'shouldUseOperatorRem' @ [153:44] ==> val shouldUseOperatorRem: Boolean defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.refineNameForRemOperator[LocalVariableDescriptor]

'OperatorConventions.REM_TO_MOD_OPERATION_NAMES[name]' @ [153:66] ==> public abstract fun get(@Nullable key: Name?): Name? defined in com.google.common.collect.ImmutableBiMap[JavaMethodDescriptor]

'REM_TO_MOD_OPERATION_NAMES' @ [153:86] ==> public final val REM_TO_MOD_OPERATION_NAMES: (ImmutableBiMap<(Name..Name?), (Name..Name?)>..ImmutableBiMap<(Name..Name?), (Name..Name?)>?) defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaPropertyDescriptor]

'name' @ [153:113] ==> value-parameter name: Name defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.refineNameForRemOperator[ValueParameterDescriptorImpl]

'name' @ [153:126] ==> value-parameter name: Name defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.refineNameForRemOperator[ValueParameterDescriptorImpl]

'KotlinResolutionCallbacksImpl' @ [157:13] ==> public constructor KotlinResolutionCallbacksImpl(topLevelCallContext: BasicCallResolutionContext, expressionTypingServices: ExpressionTypingServices, typeApproximator: TypeApproximator, argumentTypeResolver: ArgumentTypeResolver, languageVersionSettings: LanguageVersionSettings, kotlinToResolvedCallTransformer: KotlinToResolvedCallTransformer, psiCallResolver: PSICallResolver) defined in org.jetbrains.kotlin.resolve.calls.tower.KotlinResolutionCallbacksImpl[ClassConstructorDescriptorImpl]

'context' @ [157:43] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createResolutionCallbacks[ValueParameterDescriptorImpl]

'expressionTypingServices' @ [157:52] ==> private final val expressionTypingServices: ExpressionTypingServices defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[PropertyDescriptorImpl]

'typeApproximator' @ [157:78] ==> private final val typeApproximator: TypeApproximator defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[PropertyDescriptorImpl]

'argumentTypeResolver' @ [158:43] ==> private final val argumentTypeResolver: ArgumentTypeResolver defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[PropertyDescriptorImpl]

'languageVersionSettings' @ [158:65] ==> private final val languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[PropertyDescriptorImpl]

'kotlinToResolvedCallTransformer' @ [158:90] ==> private final val kotlinToResolvedCallTransformer: KotlinToResolvedCallTransformer defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[PropertyDescriptorImpl]

'this' @ [158:123] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[LazyClassReceiverParameterDescriptor]

'context' @ [161:28] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.calculateExpectedType[ValueParameterDescriptorImpl]

'expectedType' @ [161:36] ==> @NotNull public final val expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'unwrap' @ [161:49] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'if (context.contextDependency == ContextDependency.DEPENDENT) {
            assert(TypeUtils.noExpectedType(expectedType)) {
                "Should have no expected type, got: $expectedType"
            }
            null
        }
        else {
            if (expectedType.isError) TypeUtils.NO_EXPECTED_TYPE else expectedType
        }' @ [163:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: UnwrappedType?, elseBranch: UnwrappedType?): UnwrappedType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> UnwrappedType?

'context' @ [163:20] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.calculateExpectedType[ValueParameterDescriptorImpl]

'contextDependency' @ [163:28] ==> @NotNull public final val contextDependency: ContextDependency defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'DEPENDENT' @ [163:67] ==> enum entry DEPENDENT defined in org.jetbrains.kotlin.resolve.calls.context.ContextDependency[FakeCallableDescriptorForObject]

'assert' @ [164:13] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'noExpectedType' @ [164:30] ==> public open fun noExpectedType(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'expectedType' @ [164:45] ==> val expectedType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.calculateExpectedType[LocalVariableDescriptor]

'expectedType' @ [165:54] ==> val expectedType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.calculateExpectedType[LocalVariableDescriptor]

'if (expectedType.isError) TypeUtils.NO_EXPECTED_TYPE else expectedType' @ [170:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: UnwrappedType, elseBranch: UnwrappedType): UnwrappedType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> UnwrappedType

'expectedType' @ [170:17] ==> val expectedType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.calculateExpectedType[LocalVariableDescriptor]

'isError' @ [170:30] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types[DeserializedPropertyDescriptor]

'NO_EXPECTED_TYPE' @ [170:49] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'expectedType' @ [170:71] ==> val expectedType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.calculateExpectedType[LocalVariableDescriptor]

'result' @ [179:13] ==> value-parameter result: CallResolutionResult defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[ValueParameterDescriptorImpl]

'type' @ [179:20] ==> public final val type: CallResolutionResult.Type defined in org.jetbrains.kotlin.resolve.calls.model.CallResolutionResult[DeserializedPropertyDescriptor]

'ALL_CANDIDATES' @ [179:54] ==> enum entry ALL_CANDIDATES defined in org.jetbrains.kotlin.resolve.calls.model.CallResolutionResult.Type[FakeCallableDescriptorForObject]

'result' @ [180:33] ==> value-parameter result: CallResolutionResult defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[ValueParameterDescriptorImpl]

'allCandidates' @ [180:40] ==> public final val allCandidates: Collection<KotlinResolutionCandidate>? defined in org.jetbrains.kotlin.resolve.calls.model.CallResolutionResult[DeserializedPropertyDescriptor]

'map' @ [180:55] ==> public inline fun <T, R> Iterable<KotlinResolutionCandidate>.map(transform: (KotlinResolutionCandidate) -> ResolvedCall<D>): List<ResolvedCall<D>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinResolutionCandidate
    <R> -> ResolvedCall<D>

'it' @ [181:44] ==> value-parameter it: KotlinResolutionCandidate defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults.<anonymous>[ValueParameterDescriptorImpl]

'getSystem' @ [181:47] ==> public final fun getSystem(): NewConstraintSystem defined in org.jetbrains.kotlin.resolve.calls.model.KotlinResolutionCandidate[DeserializedSimpleFunctionDescriptor]

'asReadOnlyStorage' @ [181:59] ==> public abstract fun asReadOnlyStorage(): ConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.NewConstraintSystem[DeserializedSimpleFunctionDescriptor]

'buildResultingSubstitutor' @ [181:79] ==> public fun ConstraintStorage.buildResultingSubstitutor(): NewTypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.inference[DeserializedSimpleFunctionDescriptor]

'kotlinToResolvedCallTransformer' @ [182:17] ==> private final val kotlinToResolvedCallTransformer: KotlinToResolvedCallTransformer defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[PropertyDescriptorImpl]

'transformToResolvedCall' @ [182:49] ==> public final fun <D : CallableDescriptor> transformToResolvedCall(completedCallAtom: ResolvedCallAtom, trace: BindingTrace?, resultSubstitutor: NewTypeSubstitutor? = ...): ResolvedCall<D> defined in org.jetbrains.kotlin.resolve.calls.tower.KotlinToResolvedCallTransformer[SimpleFunctionDescriptorImpl]
Inferred types:
    <D : CallableDescriptor> -> D

'it' @ [182:76] ==> value-parameter it: KotlinResolutionCandidate defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults.<anonymous>[ValueParameterDescriptorImpl]

'resolvedCall' @ [182:79] ==> public final val resolvedCall: MutableResolvedCallAtom defined in org.jetbrains.kotlin.resolve.calls.model.KotlinResolutionCandidate[DeserializedPropertyDescriptor]

'resultingSubstitutor' @ [182:99] ==> val resultingSubstitutor: NewTypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults.<anonymous>[LocalVariableDescriptor]

'AllCandidates' @ [185:20] ==> public constructor AllCandidates<D : CallableDescriptor>(allCandidates: Collection<ResolvedCall<D>>) defined in org.jetbrains.kotlin.resolve.calls.results.AllCandidates[ClassConstructorDescriptorImpl]
Inferred types:
    <D : CallableDescriptor> -> D

'resolvedCalls' @ [185:34] ==> val resolvedCalls: List<ResolvedCall<D>>? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[LocalVariableDescriptor]

'emptyList' @ [185:51] ==> public fun <T> emptyList(): List<ResolvedCall<D>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ResolvedCall<D>

'context' @ [188:21] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[ValueParameterDescriptorImpl]

'trace' @ [188:29] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'result' @ [190:9] ==> value-parameter result: CallResolutionResult defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[ValueParameterDescriptorImpl]

'diagnostics' @ [190:16] ==> public final lateinit var diagnostics: Collection<KotlinCallDiagnostic> defined in org.jetbrains.kotlin.resolve.calls.model.CallResolutionResult[DeserializedPropertyDescriptor]

'firstIsInstanceOrNull' @ [190:28] ==> public inline fun <reified T : Any> Iterable<*>.firstIsInstanceOrNull(): NoneCandidatesCallDiagnostic? defined in org.jetbrains.kotlin.utils.addToStdlib[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : Any> -> NoneCandidatesCallDiagnostic

'let' @ [190:83] ==> @InlineOnly public inline fun <T, R> NoneCandidatesCallDiagnostic.let(block: (NoneCandidatesCallDiagnostic) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> NoneCandidatesCallDiagnostic
    <R> -> Nothing

'tracingStrategy' @ [191:13] ==> value-parameter tracingStrategy: TracingStrategy defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[ValueParameterDescriptorImpl]

'unresolvedReference' @ [191:29] ==> public abstract fun unresolvedReference(@NotNull trace: BindingTrace): Unit defined in org.jetbrains.kotlin.resolve.calls.tasks.TracingStrategy[JavaMethodDescriptor]

'trace' @ [191:49] ==> val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[LocalVariableDescriptor]

'nameNotFound' @ [192:50] ==> public open fun <D : (CallableDescriptor..CallableDescriptor?)> nameNotFound(): (OverloadResolutionResultsImpl<(D..D?)>..OverloadResolutionResultsImpl<(D..D?)>?) defined in org.jetbrains.kotlin.resolve.calls.results.OverloadResolutionResultsImpl[JavaMethodDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (D..D?)

'result' @ [195:9] ==> value-parameter result: CallResolutionResult defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[ValueParameterDescriptorImpl]

'diagnostics' @ [195:16] ==> public final lateinit var diagnostics: Collection<KotlinCallDiagnostic> defined in org.jetbrains.kotlin.resolve.calls.model.CallResolutionResult[DeserializedPropertyDescriptor]

'firstIsInstanceOrNull' @ [195:28] ==> public inline fun <reified T : Any> Iterable<*>.firstIsInstanceOrNull(): ManyCandidatesCallDiagnostic? defined in org.jetbrains.kotlin.utils.addToStdlib[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : Any> -> ManyCandidatesCallDiagnostic

'let' @ [195:83] ==> @InlineOnly public inline fun <T, R> ManyCandidatesCallDiagnostic.let(block: (ManyCandidatesCallDiagnostic) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ManyCandidatesCallDiagnostic
    <R> -> Nothing

'it' @ [196:33] ==> value-parameter it: ManyCandidatesCallDiagnostic defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults.<anonymous>[ValueParameterDescriptorImpl]

'candidates' @ [196:36] ==> public final val candidates: Collection<KotlinResolutionCandidate> defined in org.jetbrains.kotlin.resolve.calls.model.ManyCandidatesCallDiagnostic[DeserializedPropertyDescriptor]

'map' @ [196:47] ==> public inline fun <T, R> Iterable<KotlinResolutionCandidate>.map(transform: (KotlinResolutionCandidate) -> ResolvedCall<D>): List<ResolvedCall<D>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinResolutionCandidate
    <R> -> ResolvedCall<D>

'kotlinToResolvedCallTransformer' @ [196:53] ==> private final val kotlinToResolvedCallTransformer: KotlinToResolvedCallTransformer defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[PropertyDescriptorImpl]

'onlyTransform' @ [196:85] ==> public final fun <D : CallableDescriptor> onlyTransform(resolvedCallAtom: ResolvedCallAtom): ResolvedCall<D> defined in org.jetbrains.kotlin.resolve.calls.tower.KotlinToResolvedCallTransformer[SimpleFunctionDescriptorImpl]
Inferred types:
    <D : CallableDescriptor> -> D

'it' @ [196:102] ==> value-parameter it: KotlinResolutionCandidate defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'resolvedCall' @ [196:105] ==> public final val resolvedCall: MutableResolvedCallAtom defined in org.jetbrains.kotlin.resolve.calls.model.KotlinResolutionCandidate[DeserializedPropertyDescriptor]

'if (it.candidates.areAllFailed()) {
                tracingStrategy.noneApplicable(trace, resolvedCalls)
                tracingStrategy.recordAmbiguity(trace, resolvedCalls)
            }
            else {
                tracingStrategy.recordAmbiguity(trace, resolvedCalls)
                if (resolvedCalls.first().status == ResolutionStatus.INCOMPLETE_TYPE_INFERENCE) {
                    tracingStrategy.cannotCompleteResolve(trace, resolvedCalls)
                }
                else {
                    tracingStrategy.ambiguity(trace, resolvedCalls)
                }
            }' @ [197:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'it' @ [197:17] ==> value-parameter it: ManyCandidatesCallDiagnostic defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults.<anonymous>[ValueParameterDescriptorImpl]

'candidates' @ [197:20] ==> public final val candidates: Collection<KotlinResolutionCandidate> defined in org.jetbrains.kotlin.resolve.calls.model.ManyCandidatesCallDiagnostic[DeserializedPropertyDescriptor]

'areAllFailed' @ [197:31] ==> private final fun Collection<KotlinResolutionCandidate>.areAllFailed(): Boolean defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'tracingStrategy' @ [198:17] ==> value-parameter tracingStrategy: TracingStrategy defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[ValueParameterDescriptorImpl]

'noneApplicable' @ [198:33] ==> public abstract fun <D : (CallableDescriptor..CallableDescriptor?)> noneApplicable(@NotNull trace: BindingTrace, @NotNull descriptors: (MutableCollection<out (ResolvedCall<(D..D?)>..ResolvedCall<(D..D?)>?)>..Collection<(ResolvedCall<(D..D?)>..ResolvedCall<(D..D?)>?)>)): Unit defined in org.jetbrains.kotlin.resolve.calls.tasks.TracingStrategy[JavaMethodDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (D..D?)

'trace' @ [198:48] ==> val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[LocalVariableDescriptor]

'resolvedCalls' @ [198:55] ==> val resolvedCalls: List<ResolvedCall<D>> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults.<anonymous>[LocalVariableDescriptor]

'tracingStrategy' @ [199:17] ==> value-parameter tracingStrategy: TracingStrategy defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[ValueParameterDescriptorImpl]

'recordAmbiguity' @ [199:33] ==> public abstract fun <D : (CallableDescriptor..CallableDescriptor?)> recordAmbiguity(@NotNull trace: BindingTrace, @NotNull candidates: (MutableCollection<out (ResolvedCall<(D..D?)>..ResolvedCall<(D..D?)>?)>..Collection<(ResolvedCall<(D..D?)>..ResolvedCall<(D..D?)>?)>)): Unit defined in org.jetbrains.kotlin.resolve.calls.tasks.TracingStrategy[JavaMethodDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (D..D?)

'trace' @ [199:49] ==> val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[LocalVariableDescriptor]

'resolvedCalls' @ [199:56] ==> val resolvedCalls: List<ResolvedCall<D>> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults.<anonymous>[LocalVariableDescriptor]

'tracingStrategy' @ [202:17] ==> value-parameter tracingStrategy: TracingStrategy defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[ValueParameterDescriptorImpl]

'recordAmbiguity' @ [202:33] ==> public abstract fun <D : (CallableDescriptor..CallableDescriptor?)> recordAmbiguity(@NotNull trace: BindingTrace, @NotNull candidates: (MutableCollection<out (ResolvedCall<(D..D?)>..ResolvedCall<(D..D?)>?)>..Collection<(ResolvedCall<(D..D?)>..ResolvedCall<(D..D?)>?)>)): Unit defined in org.jetbrains.kotlin.resolve.calls.tasks.TracingStrategy[JavaMethodDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (D..D?)

'trace' @ [202:49] ==> val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[LocalVariableDescriptor]

'resolvedCalls' @ [202:56] ==> val resolvedCalls: List<ResolvedCall<D>> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults.<anonymous>[LocalVariableDescriptor]

'if (resolvedCalls.first().status == ResolutionStatus.INCOMPLETE_TYPE_INFERENCE) {
                    tracingStrategy.cannotCompleteResolve(trace, resolvedCalls)
                }
                else {
                    tracingStrategy.ambiguity(trace, resolvedCalls)
                }' @ [203:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'resolvedCalls' @ [203:21] ==> val resolvedCalls: List<ResolvedCall<D>> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults.<anonymous>[LocalVariableDescriptor]

'first' @ [203:35] ==> public fun <T> List<ResolvedCall<D>>.first(): ResolvedCall<D> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ResolvedCall<D>

'status' @ [203:43] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<D>.status: ResolutionStatus[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> D

'INCOMPLETE_TYPE_INFERENCE' @ [203:70] ==> enum entry INCOMPLETE_TYPE_INFERENCE defined in org.jetbrains.kotlin.resolve.calls.results.ResolutionStatus[FakeCallableDescriptorForObject]

'tracingStrategy' @ [204:21] ==> value-parameter tracingStrategy: TracingStrategy defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[ValueParameterDescriptorImpl]

'cannotCompleteResolve' @ [204:37] ==> public abstract fun <D : (CallableDescriptor..CallableDescriptor?)> cannotCompleteResolve(@NotNull trace: BindingTrace, @NotNull descriptors: (MutableCollection<out (ResolvedCall<(D..D?)>..ResolvedCall<(D..D?)>?)>..Collection<(ResolvedCall<(D..D?)>..ResolvedCall<(D..D?)>?)>)): Unit defined in org.jetbrains.kotlin.resolve.calls.tasks.TracingStrategy[JavaMethodDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (D..D?)

'trace' @ [204:59] ==> val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[LocalVariableDescriptor]

'resolvedCalls' @ [204:66] ==> val resolvedCalls: List<ResolvedCall<D>> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults.<anonymous>[LocalVariableDescriptor]

'tracingStrategy' @ [207:21] ==> value-parameter tracingStrategy: TracingStrategy defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[ValueParameterDescriptorImpl]

'ambiguity' @ [207:37] ==> public abstract fun <D : (CallableDescriptor..CallableDescriptor?)> ambiguity(@NotNull trace: BindingTrace, @NotNull descriptors: (MutableCollection<out (ResolvedCall<(D..D?)>..ResolvedCall<(D..D?)>?)>..Collection<(ResolvedCall<(D..D?)>..ResolvedCall<(D..D?)>?)>)): Unit defined in org.jetbrains.kotlin.resolve.calls.tasks.TracingStrategy[JavaMethodDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (D..D?)

'trace' @ [207:47] ==> val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[LocalVariableDescriptor]

'resolvedCalls' @ [207:54] ==> val resolvedCalls: List<ResolvedCall<D>> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults.<anonymous>[LocalVariableDescriptor]

'ManyCandidates' @ [210:20] ==> public constructor ManyCandidates<D : CallableDescriptor>(candidates: Collection<ResolvedCall<D>>) defined in org.jetbrains.kotlin.resolve.calls.results.ManyCandidates[ClassConstructorDescriptorImpl]
Inferred types:
    <D : CallableDescriptor> -> D

'resolvedCalls' @ [210:35] ==> val resolvedCalls: List<ResolvedCall<D>> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults.<anonymous>[LocalVariableDescriptor]

'result' @ [213:31] ==> value-parameter result: CallResolutionResult defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[ValueParameterDescriptorImpl]

'resultCallAtom' @ [213:38] ==> public final val resultCallAtom: ResolvedCallAtom? defined in org.jetbrains.kotlin.resolve.calls.model.CallResolutionResult[DeserializedPropertyDescriptor]

'error' @ [213:56] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'result' @ [213:95] ==> value-parameter result: CallResolutionResult defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[ValueParameterDescriptorImpl]

'getResultApplicability' @ [214:38] ==> public fun getResultApplicability(diagnostics: Collection<KotlinCallDiagnostic>): ResolutionCandidateApplicability defined in org.jetbrains.kotlin.resolve.calls.tower[DeserializedSimpleFunctionDescriptor]

'singleCandidate' @ [214:61] ==> val singleCandidate: ResolvedCallAtom defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[LocalVariableDescriptor]

'diagnostics' @ [214:77] ==> public final lateinit var diagnostics: Collection<KotlinCallDiagnostic> defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCallAtom[DeserializedPropertyDescriptor]

'INAPPLICABLE_WRONG_RECEIVER' @ [214:126] ==> enum entry INAPPLICABLE_WRONG_RECEIVER defined in org.jetbrains.kotlin.resolve.calls.tower.ResolutionCandidateApplicability[FakeCallableDescriptorForObject]

'if (isInapplicableReceiver) {
            kotlinToResolvedCallTransformer.onlyTransform<D>(singleCandidate).also {
                tracingStrategy.unresolvedReferenceWrongReceiver(trace, listOf(it))
            }
        }
        else {
            kotlinToResolvedCallTransformer.transformAndReport<D>(result, context)
        }' @ [216:28] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: ResolvedCall<D>, elseBranch: ResolvedCall<D>): ResolvedCall<D>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> ResolvedCall<D>

'isInapplicableReceiver' @ [216:32] ==> val isInapplicableReceiver: Boolean defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[LocalVariableDescriptor]

'kotlinToResolvedCallTransformer' @ [217:13] ==> private final val kotlinToResolvedCallTransformer: KotlinToResolvedCallTransformer defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[PropertyDescriptorImpl]

'onlyTransform' @ [217:45] ==> public final fun <D : CallableDescriptor> onlyTransform(resolvedCallAtom: ResolvedCallAtom): ResolvedCall<D> defined in org.jetbrains.kotlin.resolve.calls.tower.KotlinToResolvedCallTransformer[SimpleFunctionDescriptorImpl]
Inferred types:
    <D : CallableDescriptor> -> D

'singleCandidate' @ [217:62] ==> val singleCandidate: ResolvedCallAtom defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[LocalVariableDescriptor]

'also' @ [217:79] ==> @InlineOnly @SinceKotlin public inline fun <T> ResolvedCall<D>.also(block: (ResolvedCall<D>) -> Unit): ResolvedCall<D> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ResolvedCall<D>

'tracingStrategy' @ [218:17] ==> value-parameter tracingStrategy: TracingStrategy defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[ValueParameterDescriptorImpl]

'unresolvedReferenceWrongReceiver' @ [218:33] ==> public abstract fun <D : (CallableDescriptor..CallableDescriptor?)> unresolvedReferenceWrongReceiver(@NotNull trace: BindingTrace, @NotNull candidates: (MutableCollection<out (ResolvedCall<(D..D?)>..ResolvedCall<(D..D?)>?)>..Collection<(ResolvedCall<(D..D?)>..ResolvedCall<(D..D?)>?)>)): Unit defined in org.jetbrains.kotlin.resolve.calls.tasks.TracingStrategy[JavaMethodDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (D..D?)

'trace' @ [218:66] ==> val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[LocalVariableDescriptor]

'listOf' @ [218:73] ==> public fun <T> listOf(element: ResolvedCall<D>): List<ResolvedCall<D>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ResolvedCall<D>

'it' @ [218:80] ==> value-parameter it: ResolvedCall<D> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults.<anonymous>[ValueParameterDescriptorImpl]

'kotlinToResolvedCallTransformer' @ [222:13] ==> private final val kotlinToResolvedCallTransformer: KotlinToResolvedCallTransformer defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[PropertyDescriptorImpl]

'transformAndReport' @ [222:45] ==> public final fun <D : CallableDescriptor> transformAndReport(baseResolvedCall: CallResolutionResult, context: BasicCallResolutionContext): ResolvedCall<D> defined in org.jetbrains.kotlin.resolve.calls.tower.KotlinToResolvedCallTransformer[SimpleFunctionDescriptorImpl]
Inferred types:
    <D : CallableDescriptor> -> D

'result' @ [222:67] ==> value-parameter result: CallResolutionResult defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[ValueParameterDescriptorImpl]

'context' @ [222:75] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[ValueParameterDescriptorImpl]

'SingleOverloadResolutionResult' @ [224:16] ==> public constructor SingleOverloadResolutionResult<D : CallableDescriptor>(result: ResolvedCall<D>) defined in org.jetbrains.kotlin.resolve.calls.results.SingleOverloadResolutionResult[ClassConstructorDescriptorImpl]
Inferred types:
    <D : CallableDescriptor> -> D

'resolvedCall' @ [224:47] ==> val resolvedCall: ResolvedCall<D> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.convertToOverloadResolutionResults[LocalVariableDescriptor]

'diagnostics' @ [228:13] ==> public final lateinit var diagnostics: Collection<KotlinCallDiagnostic> defined in org.jetbrains.kotlin.resolve.calls.model.CallResolutionResult[DeserializedPropertyDescriptor]

'firstIsInstanceOrNull' @ [228:25] ==> public inline fun <reified T : Any> Iterable<*>.firstIsInstanceOrNull(): NoneCandidatesCallDiagnostic? defined in org.jetbrains.kotlin.utils.addToStdlib[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : Any> -> NoneCandidatesCallDiagnostic

'all' @ [231:13] ==> public inline fun <T> Iterable<KotlinResolutionCandidate>.all(predicate: (KotlinResolutionCandidate) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinResolutionCandidate

'!' @ [232:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'it' @ [232:18] ==> value-parameter it: KotlinResolutionCandidate defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.areAllFailed.<anonymous>[ValueParameterDescriptorImpl]

'resultingApplicability' @ [232:21] ==> public open val resultingApplicability: ResolutionCandidateApplicability defined in org.jetbrains.kotlin.resolve.calls.model.KotlinResolutionCandidate[DeserializedPropertyDescriptor]

'isSuccess' @ [232:44] ==> public val ResolutionCandidateApplicability.isSuccess: Boolean defined in org.jetbrains.kotlin.resolve.calls.tower[DeserializedPropertyDescriptor]

'diagnostics' @ [236:26] ==> public final lateinit var diagnostics: Collection<KotlinCallDiagnostic> defined in org.jetbrains.kotlin.resolve.calls.model.CallResolutionResult[DeserializedPropertyDescriptor]

'firstIsInstanceOrNull' @ [236:38] ==> public inline fun <reified T : Any> Iterable<*>.firstIsInstanceOrNull(): ManyCandidatesCallDiagnostic? defined in org.jetbrains.kotlin.utils.addToStdlib[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : Any> -> ManyCandidatesCallDiagnostic

'candidates' @ [236:93] ==> public final val candidates: Collection<KotlinResolutionCandidate> defined in org.jetbrains.kotlin.resolve.calls.model.ManyCandidatesCallDiagnostic[DeserializedPropertyDescriptor]

'map' @ [236:105] ==> public inline fun <T, R> Iterable<KotlinResolutionCandidate>.map(transform: (KotlinResolutionCandidate) -> MutableResolvedCallAtom): List<MutableResolvedCallAtom> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinResolutionCandidate
    <R> -> MutableResolvedCallAtom

'it' @ [236:111] ==> value-parameter it: KotlinResolutionCandidate defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.areAllInapplicable.<anonymous>[ValueParameterDescriptorImpl]

'resolvedCall' @ [236:114] ==> public final val resolvedCall: MutableResolvedCallAtom defined in org.jetbrains.kotlin.resolve.calls.model.KotlinResolutionCandidate[DeserializedPropertyDescriptor]

'listOfNotNull' @ [237:29] ==> public fun <T : Any> listOfNotNull(element: ResolvedCallAtom?): List<ResolvedCallAtom> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> ResolvedCallAtom

'resultCallAtom' @ [237:43] ==> public final val resultCallAtom: ResolvedCallAtom? defined in org.jetbrains.kotlin.resolve.calls.model.CallResolutionResult[DeserializedPropertyDescriptor]

'candidates' @ [239:16] ==> val candidates: List<ResolvedCallAtom> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.areAllInapplicable[LocalVariableDescriptor]

'all' @ [239:27] ==> public inline fun <T> Iterable<ResolvedCallAtom>.all(predicate: (ResolvedCallAtom) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ResolvedCallAtom

'getResultApplicability' @ [240:33] ==> public fun getResultApplicability(diagnostics: Collection<KotlinCallDiagnostic>): ResolutionCandidateApplicability defined in org.jetbrains.kotlin.resolve.calls.tower[DeserializedSimpleFunctionDescriptor]

'it' @ [240:56] ==> value-parameter it: ResolvedCallAtom defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.areAllInapplicable.<anonymous>[ValueParameterDescriptorImpl]

'diagnostics' @ [240:59] ==> public final lateinit var diagnostics: Collection<KotlinCallDiagnostic> defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCallAtom[DeserializedPropertyDescriptor]

'applicability' @ [241:13] ==> val applicability: ResolutionCandidateApplicability defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.areAllInapplicable.<anonymous>[LocalVariableDescriptor]

'INAPPLICABLE' @ [241:63] ==> enum entry INAPPLICABLE defined in org.jetbrains.kotlin.resolve.calls.tower.ResolutionCandidateApplicability[FakeCallableDescriptorForObject]

'applicability' @ [242:13] ==> val applicability: ResolutionCandidateApplicability defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.areAllInapplicable.<anonymous>[LocalVariableDescriptor]

'INAPPLICABLE_WRONG_RECEIVER' @ [242:63] ==> enum entry INAPPLICABLE_WRONG_RECEIVER defined in org.jetbrains.kotlin.resolve.calls.tower.ResolutionCandidateApplicability[FakeCallableDescriptorForObject]

'applicability' @ [243:13] ==> val applicability: ResolutionCandidateApplicability defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.areAllInapplicable.<anonymous>[LocalVariableDescriptor]

'HIDDEN' @ [243:63] ==> enum entry HIDDEN defined in org.jetbrains.kotlin.resolve.calls.tower.ResolutionCandidateApplicability[FakeCallableDescriptorForObject]

'context' @ [254:25] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.reportAdditionalDiagnosticIfNoCandidates[ValueParameterDescriptorImpl]

'call' @ [254:33] ==> @NotNull public final val call: Call defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'calleeExpression' @ [254:38] ==> public final val Call.calleeExpression: KtExpression?[MyPropertyDescriptor]

'when (kind) {
            KotlinCallKind.FUNCTION ->
                collectErrorCandidatesForFunction(scopeTower, kotlinCall.name, kotlinCall.explicitReceiver?.receiver)
            KotlinCallKind.VARIABLE ->
                collectErrorCandidatesForVariable(scopeTower, kotlinCall.name, kotlinCall.explicitReceiver?.receiver)
            else -> emptyList()
        }' @ [256:31] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Collection<ErrorCandidate<*>>, entry1: Collection<ErrorCandidate<*>>, entry2: Collection<ErrorCandidate<*>>): Collection<ErrorCandidate<*>>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Collection<ErrorCandidate<*>>

'kind' @ [256:37] ==> value-parameter kind: KotlinCallKind defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.reportAdditionalDiagnosticIfNoCandidates[ValueParameterDescriptorImpl]

'FUNCTION' @ [257:28] ==> enum entry FUNCTION defined in org.jetbrains.kotlin.resolve.calls.model.KotlinCallKind[FakeCallableDescriptorForObject]

'collectErrorCandidatesForFunction' @ [258:17] ==> public fun collectErrorCandidatesForFunction(scopeTower: ImplicitScopeTower, name: Name, explicitReceiver: DetailedReceiver?): Collection<ErrorCandidate<*>> defined in org.jetbrains.kotlin.resolve.calls.tower[DeserializedSimpleFunctionDescriptor]

'scopeTower' @ [258:51] ==> value-parameter scopeTower: ImplicitScopeTower defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.reportAdditionalDiagnosticIfNoCandidates[ValueParameterDescriptorImpl]

'kotlinCall' @ [258:63] ==> value-parameter kotlinCall: KotlinCall defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.reportAdditionalDiagnosticIfNoCandidates[ValueParameterDescriptorImpl]

'name' @ [258:74] ==> public abstract val name: Name defined in org.jetbrains.kotlin.resolve.calls.model.KotlinCall[DeserializedPropertyDescriptor]

'kotlinCall' @ [258:80] ==> value-parameter kotlinCall: KotlinCall defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.reportAdditionalDiagnosticIfNoCandidates[ValueParameterDescriptorImpl]

'explicitReceiver' @ [258:91] ==> public abstract val explicitReceiver: ReceiverKotlinCallArgument? defined in org.jetbrains.kotlin.resolve.calls.model.KotlinCall[DeserializedPropertyDescriptor]

'receiver' @ [258:109] ==> public abstract val receiver: DetailedReceiver defined in org.jetbrains.kotlin.resolve.calls.model.ReceiverKotlinCallArgument[DeserializedPropertyDescriptor]

'VARIABLE' @ [259:28] ==> enum entry VARIABLE defined in org.jetbrains.kotlin.resolve.calls.model.KotlinCallKind[FakeCallableDescriptorForObject]

'collectErrorCandidatesForVariable' @ [260:17] ==> public fun collectErrorCandidatesForVariable(scopeTower: ImplicitScopeTower, name: Name, explicitReceiver: DetailedReceiver?): Collection<ErrorCandidate<*>> defined in org.jetbrains.kotlin.resolve.calls.tower[DeserializedSimpleFunctionDescriptor]

'scopeTower' @ [260:51] ==> value-parameter scopeTower: ImplicitScopeTower defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.reportAdditionalDiagnosticIfNoCandidates[ValueParameterDescriptorImpl]

'kotlinCall' @ [260:63] ==> value-parameter kotlinCall: KotlinCall defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.reportAdditionalDiagnosticIfNoCandidates[ValueParameterDescriptorImpl]

'name' @ [260:74] ==> public abstract val name: Name defined in org.jetbrains.kotlin.resolve.calls.model.KotlinCall[DeserializedPropertyDescriptor]

'kotlinCall' @ [260:80] ==> value-parameter kotlinCall: KotlinCall defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.reportAdditionalDiagnosticIfNoCandidates[ValueParameterDescriptorImpl]

'explicitReceiver' @ [260:91] ==> public abstract val explicitReceiver: ReceiverKotlinCallArgument? defined in org.jetbrains.kotlin.resolve.calls.model.KotlinCall[DeserializedPropertyDescriptor]

'receiver' @ [260:109] ==> public abstract val receiver: DetailedReceiver defined in org.jetbrains.kotlin.resolve.calls.model.ReceiverKotlinCallArgument[DeserializedPropertyDescriptor]

'emptyList' @ [261:21] ==> public fun <T> emptyList(): List<ErrorCandidate<*>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ErrorCandidate<*>

'errorCandidates' @ [264:27] ==> val errorCandidates: Collection<ErrorCandidate<*>> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.reportAdditionalDiagnosticIfNoCandidates[LocalVariableDescriptor]

'candidate' @ [265:17] ==> val candidate: ErrorCandidate<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.reportAdditionalDiagnosticIfNoCandidates[LocalVariableDescriptor]

'context' @ [266:17] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.reportAdditionalDiagnosticIfNoCandidates[ValueParameterDescriptorImpl]

'trace' @ [266:25] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'record' @ [266:31] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?), key: (KtReferenceExpression..KtReferenceExpression?), value: (DeclarationDescriptor..DeclarationDescriptor?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtReferenceExpression..org.jetbrains.kotlin.psi.KtReferenceExpression?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.descriptors.DeclarationDescriptor..org.jetbrains.kotlin.descriptors.DeclarationDescriptor?)

'REFERENCE_TARGET' @ [266:53] ==> public final val REFERENCE_TARGET: (WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'reference' @ [266:71] ==> val reference: KtReferenceExpression defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.reportAdditionalDiagnosticIfNoCandidates[LocalVariableDescriptor]

'candidate' @ [266:82] ==> val candidate: ErrorCandidate<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.reportAdditionalDiagnosticIfNoCandidates[LocalVariableDescriptor]

'descriptor' @ [266:92] ==> public final val descriptor: ClassifierDescriptor defined in org.jetbrains.kotlin.resolve.calls.tower.ErrorCandidate.Classifier[DeserializedPropertyDescriptor]

'context' @ [267:17] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.reportAdditionalDiagnosticIfNoCandidates[ValueParameterDescriptorImpl]

'trace' @ [267:25] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'report' @ [267:31] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'RESOLUTION_TO_CLASSIFIER' @ [267:45] ==> public final val RESOLUTION_TO_CLASSIFIER: (DiagnosticFactory3<(KtReferenceExpression..KtReferenceExpression?), (ClassifierDescriptor..ClassifierDescriptor?), (WrongResolutionToClassifier..WrongResolutionToClassifier?), (String..String?)>..DiagnosticFactory3<(KtReferenceExpression..KtReferenceExpression?), (ClassifierDescriptor..ClassifierDescriptor?), (WrongResolutionToClassifier..WrongResolutionToClassifier?), (String..String?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [267:70] ==> @NotNull public open fun on(@NotNull element: KtReferenceExpression, @NotNull a: ClassifierDescriptor, @NotNull b: WrongResolutionToClassifier, @NotNull c: String): ParametrizedDiagnostic<(KtReferenceExpression..KtReferenceExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory3[JavaMethodDescriptor]

'reference' @ [267:73] ==> val reference: KtReferenceExpression defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.reportAdditionalDiagnosticIfNoCandidates[LocalVariableDescriptor]

'candidate' @ [267:84] ==> val candidate: ErrorCandidate<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.reportAdditionalDiagnosticIfNoCandidates[LocalVariableDescriptor]

'descriptor' @ [267:94] ==> public final val descriptor: ClassifierDescriptor defined in org.jetbrains.kotlin.resolve.calls.tower.ErrorCandidate.Classifier[DeserializedPropertyDescriptor]

'candidate' @ [267:106] ==> val candidate: ErrorCandidate<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.reportAdditionalDiagnosticIfNoCandidates[LocalVariableDescriptor]

'kind' @ [267:116] ==> public final val kind: WrongResolutionToClassifier defined in org.jetbrains.kotlin.resolve.calls.tower.ErrorCandidate.Classifier[DeserializedPropertyDescriptor]

'candidate' @ [267:122] ==> val candidate: ErrorCandidate<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.reportAdditionalDiagnosticIfNoCandidates[LocalVariableDescriptor]

'errorMessage' @ [267:132] ==> public final val errorMessage: String defined in org.jetbrains.kotlin.resolve.calls.tower.ErrorCandidate.Classifier[DeserializedPropertyDescriptor]

'dynamicCallableDescriptors' @ [280:50] ==> private final val dynamicCallableDescriptors: DynamicCallableDescriptors defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[PropertyDescriptorImpl]

'createDynamicDescriptorScope' @ [280:77] ==> public final fun createDynamicDescriptorScope(call: Call, owner: DeclarationDescriptor): MemberScopeImpl defined in org.jetbrains.kotlin.resolve.calls.tasks.DynamicCallableDescriptors[SimpleFunctionDescriptorImpl]

'call' @ [280:106] ==> value-parameter call: Call defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.ASTScopeTower.<init>[ValueParameterDescriptorImpl]

'context' @ [280:112] ==> public final val context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.ASTScopeTower[PropertyDescriptorImpl]

'scope' @ [280:120] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'ownerDescriptor' @ [280:126] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'call' @ [282:49] ==> value-parameter call: Call defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.ASTScopeTower.<init>[ValueParameterDescriptorImpl]

'createLookupLocation' @ [282:54] ==> public fun Call.createLookupLocation(): KotlinLookupLocation defined in org.jetbrains.kotlin.resolve.calls.callUtil in file callUtil.kt[SimpleFunctionDescriptorImpl]

'this@PSICallResolver' @ [284:63] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[LazyClassReceiverParameterDescriptor]

'syntheticScopes' @ [284:84] ==> private final val syntheticScopes: SyntheticScopes defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[PropertyDescriptorImpl]

'context' @ [285:57] ==> public final val context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.ASTScopeTower[PropertyDescriptorImpl]

'isDebuggerContext' @ [285:65] ==> public final val isDebuggerContext: Boolean defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'context' @ [286:57] ==> public final val context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.ASTScopeTower[PropertyDescriptorImpl]

'scope' @ [286:65] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'HashMap' @ [287:29] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> ReceiverParameterDescriptor
    <V : (Any..Any?)> -> ReceiverValueWithSmartCastInfo

'scope' @ [290:36] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.ASTScopeTower.getImplicitReceiver[ValueParameterDescriptorImpl]

'implicitReceiver' @ [290:42] ==> public abstract val implicitReceiver: ReceiverParameterDescriptor? defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'cache' @ [292:20] ==> private final val cache: HashMap<ReceiverParameterDescriptor, ReceiverValueWithSmartCastInfo> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.ASTScopeTower[PropertyDescriptorImpl]

'getOrPut' @ [292:26] ==> public inline fun <K, V> MutableMap<ReceiverParameterDescriptor, ReceiverValueWithSmartCastInfo>.getOrPut(key: ReceiverParameterDescriptor, defaultValue: () -> ReceiverValueWithSmartCastInfo): ReceiverValueWithSmartCastInfo defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> ReceiverParameterDescriptor
    <V> -> ReceiverValueWithSmartCastInfo

'implicitReceiver' @ [292:35] ==> val implicitReceiver: ReceiverParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.ASTScopeTower.getImplicitReceiver[LocalVariableDescriptor]

'context' @ [293:17] ==> public final val context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.ASTScopeTower[PropertyDescriptorImpl]

'transformToReceiverWithSmartCastInfo' @ [293:25] ==> public fun ResolutionContext<*>.transformToReceiverWithSmartCastInfo(receiver: ReceiverValue): ReceiverValueWithSmartCastInfo defined in org.jetbrains.kotlin.resolve.calls.tower in file NewResolutionOldInference.kt[SimpleFunctionDescriptorImpl]

'implicitReceiver' @ [293:62] ==> val implicitReceiver: ReceiverParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.ASTScopeTower.getImplicitReceiver[LocalVariableDescriptor]

'value' @ [293:79] ==> public final val ReceiverParameterDescriptor.value: ReceiverValue[MyPropertyDescriptor]

'assert' @ [305:13] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'kotlinCall' @ [305:20] ==> public final val kotlinCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke[PropertyDescriptorImpl]

'dispatchReceiverForInvokeExtension' @ [305:31] ==> public open val dispatchReceiverForInvokeExtension: ReceiverKotlinCallArgument? defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallImpl[DeserializedPropertyDescriptor]

'kotlinCall' @ [305:77] ==> public final val kotlinCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke[PropertyDescriptorImpl]

'invoke' @ [311:13] ==> value-parameter invoke: KotlinResolutionCandidate defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.transformCandidate[ValueParameterDescriptorImpl]

'if (stripExplicitReceiver) null else kotlinCall.explicitReceiver' @ [314:36] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: ReceiverKotlinCallArgument?, elseBranch: ReceiverKotlinCallArgument?): ReceiverKotlinCallArgument?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> ReceiverKotlinCallArgument?

'stripExplicitReceiver' @ [314:40] ==> value-parameter stripExplicitReceiver: Boolean defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.factoryForVariable[ValueParameterDescriptorImpl]

'kotlinCall' @ [314:73] ==> public final val kotlinCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke[PropertyDescriptorImpl]

'explicitReceiver' @ [314:84] ==> public open val explicitReceiver: ReceiverKotlinCallArgument? defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallImpl[PropertyDescriptorImpl]

'PSIKotlinCallForVariable' @ [315:32] ==> public constructor PSIKotlinCallForVariable(baseCall: PSIKotlinCallImpl, explicitReceiver: ReceiverKotlinCallArgument?, name: Name) defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForVariable[ClassConstructorDescriptorImpl]

'kotlinCall' @ [315:57] ==> public final val kotlinCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke[PropertyDescriptorImpl]

'explicitReceiver' @ [315:69] ==> val explicitReceiver: ReceiverKotlinCallArgument? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.factoryForVariable[LocalVariableDescriptor]

'kotlinCall' @ [315:87] ==> public final val kotlinCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke[PropertyDescriptorImpl]

'name' @ [315:98] ==> public open val name: Name defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallImpl[PropertyDescriptorImpl]

'SimpleCandidateFactory' @ [316:20] ==> public constructor SimpleCandidateFactory(callComponents: KotlinCallComponents, scopeTower: ImplicitScopeTower, kotlinCall: KotlinCall) defined in org.jetbrains.kotlin.resolve.calls.model.SimpleCandidateFactory[DeserializedClassConstructorDescriptor]

'callComponents' @ [316:43] ==> private final val callComponents: KotlinCallComponents defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[PropertyDescriptorImpl]

'scopeTower' @ [316:59] ==> public final val scopeTower: ImplicitScopeTower defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke[PropertyDescriptorImpl]

'variableCall' @ [316:71] ==> val variableCall: PSIKotlinCallForVariable defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.factoryForVariable[LocalVariableDescriptor]

'isRecursiveVariableResolution' @ [321:17] ==> private final fun isRecursiveVariableResolution(variable: KotlinResolutionCandidate): Boolean defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke[SimpleFunctionDescriptorImpl]

'variable' @ [321:47] ==> value-parameter variable: KotlinResolutionCandidate defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.factoryForInvoke[ValueParameterDescriptorImpl]

'assert' @ [323:13] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'variable' @ [323:20] ==> value-parameter variable: KotlinResolutionCandidate defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.factoryForInvoke[ValueParameterDescriptorImpl]

'isSuccessful' @ [323:29] ==> public open val isSuccessful: Boolean defined in org.jetbrains.kotlin.resolve.calls.model.KotlinResolutionCandidate[DeserializedPropertyDescriptor]

'+' @ [324:17] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'variable' @ [324:55] ==> value-parameter variable: KotlinResolutionCandidate defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.factoryForInvoke[ValueParameterDescriptorImpl]

'variable' @ [325:32] ==> value-parameter variable: KotlinResolutionCandidate defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.factoryForInvoke[ValueParameterDescriptorImpl]

'resolvedCall' @ [325:41] ==> public final val resolvedCall: MutableResolvedCallAtom defined in org.jetbrains.kotlin.resolve.calls.model.KotlinResolutionCandidate[DeserializedPropertyDescriptor]

'candidateDescriptor' @ [325:54] ==> public open val candidateDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.model.MutableResolvedCallAtom[DeserializedPropertyDescriptor]

'createReceiverCallArgument' @ [327:40] ==> private final fun createReceiverCallArgument(variable: KotlinResolutionCandidate): SimpleKotlinCallArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke[SimpleFunctionDescriptorImpl]

'variable' @ [327:67] ==> value-parameter variable: KotlinResolutionCandidate defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.factoryForInvoke[ValueParameterDescriptorImpl]

'kotlinCall' @ [329:36] ==> public final val kotlinCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke[PropertyDescriptorImpl]

'explicitReceiver' @ [329:47] ==> public open val explicitReceiver: ReceiverKotlinCallArgument? defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallImpl[PropertyDescriptorImpl]

'if (useExplicitReceiver && explicitReceiver != null) {
                PSIKotlinCallForInvoke(kotlinCall, variable, explicitReceiver, variableCallArgument)
            }
            else {
                PSIKotlinCallForInvoke(kotlinCall, variable, variableCallArgument, null)
            }' @ [330:33] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: PSIKotlinCallForInvoke, elseBranch: PSIKotlinCallForInvoke): PSIKotlinCallForInvoke[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> PSIKotlinCallForInvoke

'useExplicitReceiver' @ [330:37] ==> value-parameter useExplicitReceiver: Boolean defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.factoryForInvoke[ValueParameterDescriptorImpl]

'explicitReceiver' @ [330:60] ==> val explicitReceiver: ReceiverKotlinCallArgument? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.factoryForInvoke[LocalVariableDescriptor]

'PSIKotlinCallForInvoke' @ [331:17] ==> public constructor PSIKotlinCallForInvoke(baseCall: PSIKotlinCallImpl, variableCall: KotlinResolutionCandidate, explicitReceiver: ReceiverKotlinCallArgument, dispatchReceiverForInvokeExtension: SimpleKotlinCallArgument?) defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForInvoke[ClassConstructorDescriptorImpl]

'kotlinCall' @ [331:40] ==> public final val kotlinCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke[PropertyDescriptorImpl]

'variable' @ [331:52] ==> value-parameter variable: KotlinResolutionCandidate defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.factoryForInvoke[ValueParameterDescriptorImpl]

'explicitReceiver' @ [331:62] ==> val explicitReceiver: ReceiverKotlinCallArgument? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.factoryForInvoke[LocalVariableDescriptor]

'variableCallArgument' @ [331:80] ==> val variableCallArgument: SimpleKotlinCallArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.factoryForInvoke[LocalVariableDescriptor]

'PSIKotlinCallForInvoke' @ [334:17] ==> public constructor PSIKotlinCallForInvoke(baseCall: PSIKotlinCallImpl, variableCall: KotlinResolutionCandidate, explicitReceiver: ReceiverKotlinCallArgument, dispatchReceiverForInvokeExtension: SimpleKotlinCallArgument?) defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForInvoke[ClassConstructorDescriptorImpl]

'kotlinCall' @ [334:40] ==> public final val kotlinCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke[PropertyDescriptorImpl]

'variable' @ [334:52] ==> value-parameter variable: KotlinResolutionCandidate defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.factoryForInvoke[ValueParameterDescriptorImpl]

'variableCallArgument' @ [334:62] ==> val variableCallArgument: SimpleKotlinCallArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.factoryForInvoke[LocalVariableDescriptor]

'variableCallArgument' @ [337:20] ==> val variableCallArgument: SimpleKotlinCallArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.factoryForInvoke[LocalVariableDescriptor]

'receiver' @ [337:41] ==> public abstract val receiver: ReceiverValueWithSmartCastInfo defined in org.jetbrains.kotlin.resolve.calls.model.SimpleKotlinCallArgument[DeserializedPropertyDescriptor]

'SimpleCandidateFactory' @ [337:53] ==> public constructor SimpleCandidateFactory(callComponents: KotlinCallComponents, scopeTower: ImplicitScopeTower, kotlinCall: KotlinCall) defined in org.jetbrains.kotlin.resolve.calls.model.SimpleCandidateFactory[DeserializedClassConstructorDescriptor]

'callComponents' @ [337:76] ==> private final val callComponents: KotlinCallComponents defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[PropertyDescriptorImpl]

'scopeTower' @ [337:92] ==> public final val scopeTower: ImplicitScopeTower defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke[PropertyDescriptorImpl]

'callForInvoke' @ [337:104] ==> val callForInvoke: PSIKotlinCallForInvoke defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.factoryForInvoke[LocalVariableDescriptor]

'variable' @ [342:32] ==> value-parameter variable: KotlinResolutionCandidate defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.isRecursiveVariableResolution[ValueParameterDescriptorImpl]

'resolvedCall' @ [342:41] ==> public final val resolvedCall: MutableResolvedCallAtom defined in org.jetbrains.kotlin.resolve.calls.model.KotlinResolutionCandidate[DeserializedPropertyDescriptor]

'candidateDescriptor' @ [342:54] ==> public open val candidateDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.model.MutableResolvedCallAtom[DeserializedPropertyDescriptor]

'returnType' @ [342:74] ==> public final val CallableDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'variableType' @ [343:20] ==> val variableType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.isRecursiveVariableResolution[LocalVariableDescriptor]

'variableType' @ [343:52] ==> val variableType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.isRecursiveVariableResolution[LocalVariableDescriptor]

'isComputing' @ [343:65] ==> public final val DeferredType.isComputing: Boolean[MyPropertyDescriptor]

'variable' @ [348:13] ==> value-parameter variable: KotlinResolutionCandidate defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverCallArgument[ValueParameterDescriptorImpl]

'forceResolution' @ [348:22] ==> public fun <C : Candidate> KotlinResolutionCandidate.forceResolution(): KotlinResolutionCandidate defined in org.jetbrains.kotlin.resolve.calls.tower[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <C : Candidate> -> KotlinResolutionCandidate

'createReceiverValueWithSmartCastInfo' @ [349:36] ==> private final fun createReceiverValueWithSmartCastInfo(variable: KotlinResolutionCandidate): ReceiverValueWithSmartCastInfo defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke[SimpleFunctionDescriptorImpl]

'variable' @ [349:73] ==> value-parameter variable: KotlinResolutionCandidate defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverCallArgument[ValueParameterDescriptorImpl]

'variableReceiver' @ [350:17] ==> val variableReceiver: ReceiverValueWithSmartCastInfo defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverCallArgument[LocalVariableDescriptor]

'possibleTypes' @ [350:34] ==> public final val possibleTypes: Set<KotlinType> defined in org.jetbrains.kotlin.resolve.scopes.receivers.ReceiverValueWithSmartCastInfo[DeserializedPropertyDescriptor]

'isNotEmpty' @ [350:48] ==> @InlineOnly public inline fun <T> Collection<KotlinType>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'invoke' @ [351:24] ==> public final operator fun invoke(receiver: ReceiverValueWithSmartCastInfo, isSafeCall: Boolean = ..., isVariableReceiverForInvoke: Boolean = ...): ReceiverExpressionKotlinCallArgument defined in org.jetbrains.kotlin.resolve.calls.model.ReceiverExpressionKotlinCallArgument.Companion[DeserializedSimpleFunctionDescriptor]

'createReceiverValueWithSmartCastInfo' @ [351:61] ==> private final fun createReceiverValueWithSmartCastInfo(variable: KotlinResolutionCandidate): ReceiverValueWithSmartCastInfo defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke[SimpleFunctionDescriptorImpl]

'variable' @ [351:98] ==> value-parameter variable: KotlinResolutionCandidate defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverCallArgument[ValueParameterDescriptorImpl]

'variable' @ [354:33] ==> value-parameter variable: KotlinResolutionCandidate defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverCallArgument[ValueParameterDescriptorImpl]

'resolvedCall' @ [354:42] ==> public final val resolvedCall: MutableResolvedCallAtom defined in org.jetbrains.kotlin.resolve.calls.model.KotlinResolutionCandidate[DeserializedPropertyDescriptor]

'atom' @ [354:55] ==> public open val atom: KotlinCall defined in org.jetbrains.kotlin.resolve.calls.model.MutableResolvedCallAtom[DeserializedPropertyDescriptor]

'psiKotlinCall' @ [354:60] ==> public val KotlinCall.psiKotlinCall: PSIKotlinCall defined in org.jetbrains.kotlin.resolve.calls.tower in file PSIKotlinCalls.kt[PropertyDescriptorImpl]

'CallResolutionResult' @ [356:34] ==> public constructor CallResolutionResult(type: CallResolutionResult.Type, resultCallAtom: ResolvedCallAtom?, diagnostics: List<KotlinCallDiagnostic>, constraintSystem: ConstraintStorage, allCandidates: Collection<KotlinResolutionCandidate>? = ...) defined in org.jetbrains.kotlin.resolve.calls.model.CallResolutionResult[DeserializedClassConstructorDescriptor]

'PARTIAL' @ [356:81] ==> enum entry PARTIAL defined in org.jetbrains.kotlin.resolve.calls.model.CallResolutionResult.Type[FakeCallableDescriptorForObject]

'variable' @ [356:90] ==> value-parameter variable: KotlinResolutionCandidate defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverCallArgument[ValueParameterDescriptorImpl]

'resolvedCall' @ [356:99] ==> public final val resolvedCall: MutableResolvedCallAtom defined in org.jetbrains.kotlin.resolve.calls.model.KotlinResolutionCandidate[DeserializedPropertyDescriptor]

'listOf' @ [356:113] ==> @InlineOnly public inline fun <T> listOf(): List<KotlinCallDiagnostic> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinCallDiagnostic

'variable' @ [356:123] ==> value-parameter variable: KotlinResolutionCandidate defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverCallArgument[ValueParameterDescriptorImpl]

'getSystem' @ [356:132] ==> public final fun getSystem(): NewConstraintSystem defined in org.jetbrains.kotlin.resolve.calls.model.KotlinResolutionCandidate[DeserializedSimpleFunctionDescriptor]

'asReadOnlyStorage' @ [356:144] ==> public abstract fun asReadOnlyStorage(): ConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.NewConstraintSystem[DeserializedSimpleFunctionDescriptor]

'SubKotlinCallArgumentImpl' @ [357:20] ==> public constructor SubKotlinCallArgumentImpl(valueArgument: ValueArgument, dataFlowInfoBeforeThisArgument: DataFlowInfo, dataFlowInfoAfterThisArgument: DataFlowInfo, receiver: ReceiverValueWithSmartCastInfo, callResult: CallResolutionResult) defined in org.jetbrains.kotlin.resolve.calls.tower.SubKotlinCallArgumentImpl[ClassConstructorDescriptorImpl]

'makeExternalValueArgument' @ [357:56] ==> @NotNull public open fun makeExternalValueArgument(@NotNull expression: KtExpression): ValueArgument defined in org.jetbrains.kotlin.resolve.calls.util.CallMaker[JavaMethodDescriptor]

'variableReceiver' @ [357:83] ==> val variableReceiver: ReceiverValueWithSmartCastInfo defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverCallArgument[LocalVariableDescriptor]

'receiverValue' @ [357:100] ==> public final val receiverValue: ReceiverValue defined in org.jetbrains.kotlin.resolve.scopes.receivers.ReceiverValueWithSmartCastInfo[DeserializedPropertyDescriptor]

'expression' @ [357:137] ==> public abstract val expression: KtExpression defined in org.jetbrains.kotlin.resolve.scopes.receivers.ExpressionReceiver[PropertyDescriptorImpl]

'psiKotlinCall' @ [358:39] ==> val psiKotlinCall: PSIKotlinCall defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverCallArgument[LocalVariableDescriptor]

'resultDataFlowInfo' @ [358:53] ==> public abstract val resultDataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCall[PropertyDescriptorImpl]

'psiKotlinCall' @ [358:73] ==> val psiKotlinCall: PSIKotlinCall defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverCallArgument[LocalVariableDescriptor]

'resultDataFlowInfo' @ [358:87] ==> public abstract val resultDataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCall[PropertyDescriptorImpl]

'variableReceiver' @ [358:107] ==> val variableReceiver: ReceiverValueWithSmartCastInfo defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverCallArgument[LocalVariableDescriptor]

'variableResult' @ [359:39] ==> val variableResult: CallResolutionResult defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverCallArgument[LocalVariableDescriptor]

'variable' @ [364:35] ==> value-parameter variable: KotlinResolutionCandidate defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverValueWithSmartCastInfo[ValueParameterDescriptorImpl]

'resolvedCall' @ [364:44] ==> public final val resolvedCall: MutableResolvedCallAtom defined in org.jetbrains.kotlin.resolve.calls.model.KotlinResolutionCandidate[DeserializedPropertyDescriptor]

'atom' @ [364:57] ==> public open val atom: KotlinCall defined in org.jetbrains.kotlin.resolve.calls.model.MutableResolvedCallAtom[DeserializedPropertyDescriptor]

'callForVariable' @ [365:36] ==> val callForVariable: PSIKotlinCallForVariable defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverValueWithSmartCastInfo[LocalVariableDescriptor]

'baseCall' @ [365:52] ==> public final val baseCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForVariable[PropertyDescriptorImpl]

'psiCall' @ [365:61] ==> public open val psiCall: Call defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallImpl[PropertyDescriptorImpl]

'calleeExpression' @ [365:69] ==> public final val Call.calleeExpression: KtExpression?[MyPropertyDescriptor]

'error' @ [366:36] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'callForVariable' @ [366:63] ==> val callForVariable: PSIKotlinCallForVariable defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverValueWithSmartCastInfo[LocalVariableDescriptor]

'baseCall' @ [366:79] ==> public final val baseCall: PSIKotlinCallImpl defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallForVariable[PropertyDescriptorImpl]

'psiCall' @ [366:88] ==> public open val psiCall: Call defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallImpl[PropertyDescriptorImpl]

'create' @ [368:56] ==> @NotNull public open fun create(@NotNull trace: BindingTrace, debugName: (String..String?)): TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.TemporaryBindingTrace[JavaMethodDescriptor]

'context' @ [368:63] ==> public final val context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke[PropertyDescriptorImpl]

'trace' @ [368:71] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'variable' @ [370:24] ==> value-parameter variable: KotlinResolutionCandidate defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverValueWithSmartCastInfo[ValueParameterDescriptorImpl]

'resolvedCall' @ [370:33] ==> public final val resolvedCall: MutableResolvedCallAtom defined in org.jetbrains.kotlin.resolve.calls.model.KotlinResolutionCandidate[DeserializedPropertyDescriptor]

'freshReturnType' @ [370:46] ==> public val ResolvedCallAtom.freshReturnType: UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.model[DeserializedPropertyDescriptor]

'ExpressionReceiver' @ [371:36] ==> public companion object defined in org.jetbrains.kotlin.resolve.scopes.receivers.ExpressionReceiver[FakeCallableDescriptorForObject]

'create' @ [371:55] ==> public final fun create(expression: KtExpression, type: KotlinType, bindingContext: BindingContext): ExpressionReceiver defined in org.jetbrains.kotlin.resolve.scopes.receivers.ExpressionReceiver.Companion[SimpleFunctionDescriptorImpl]

'calleeExpression' @ [371:62] ==> val calleeExpression: KtReferenceExpression defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverValueWithSmartCastInfo[LocalVariableDescriptor]

'type' @ [371:80] ==> val type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverValueWithSmartCastInfo[LocalVariableDescriptor]

'temporaryTrace' @ [371:86] ==> val temporaryTrace: TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverValueWithSmartCastInfo[LocalVariableDescriptor]

'bindingContext' @ [371:101] ==> public final val TemporaryBindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'temporaryTrace' @ [373:13] ==> val temporaryTrace: TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverValueWithSmartCastInfo[LocalVariableDescriptor]

'record' @ [373:28] ==> public open fun <K, V> record(slice: WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>, key: (KtReferenceExpression..KtReferenceExpression?), value: (DeclarationDescriptor..DeclarationDescriptor?)): Unit defined in org.jetbrains.kotlin.resolve.TemporaryBindingTrace[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> (org.jetbrains.kotlin.psi.KtReferenceExpression..org.jetbrains.kotlin.psi.KtReferenceExpression?)
    <V> -> (org.jetbrains.kotlin.descriptors.DeclarationDescriptor..org.jetbrains.kotlin.descriptors.DeclarationDescriptor?)

'REFERENCE_TARGET' @ [373:50] ==> public final val REFERENCE_TARGET: (WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'calleeExpression' @ [373:68] ==> val calleeExpression: KtReferenceExpression defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverValueWithSmartCastInfo[LocalVariableDescriptor]

'variable' @ [373:86] ==> value-parameter variable: KotlinResolutionCandidate defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverValueWithSmartCastInfo[ValueParameterDescriptorImpl]

'resolvedCall' @ [373:95] ==> public final val resolvedCall: MutableResolvedCallAtom defined in org.jetbrains.kotlin.resolve.calls.model.KotlinResolutionCandidate[DeserializedPropertyDescriptor]

'candidateDescriptor' @ [373:108] ==> public open val candidateDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.model.MutableResolvedCallAtom[DeserializedPropertyDescriptor]

'DataFlowValueFactory' @ [374:33] ==> public object DataFlowValueFactory defined in org.jetbrains.kotlin.resolve.calls.smartcasts in file DataFlowValueFactory.kt[FakeCallableDescriptorForObject]

'createDataFlowValue' @ [374:54] ==> @JvmStatic public final fun createDataFlowValue(receiverValue: ReceiverValue, bindingContext: BindingContext, containingDeclarationOrModule: DeclarationDescriptor): DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValueFactory[SimpleFunctionDescriptorImpl]

'variableReceiver' @ [374:74] ==> val variableReceiver: ExpressionReceiver defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverValueWithSmartCastInfo[LocalVariableDescriptor]

'temporaryTrace' @ [374:92] ==> val temporaryTrace: TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverValueWithSmartCastInfo[LocalVariableDescriptor]

'bindingContext' @ [374:107] ==> public final val TemporaryBindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'context' @ [374:123] ==> public final val context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke[PropertyDescriptorImpl]

'scope' @ [374:131] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'ownerDescriptor' @ [374:137] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'ReceiverValueWithSmartCastInfo' @ [375:20] ==> public constructor ReceiverValueWithSmartCastInfo(receiverValue: ReceiverValue, possibleTypes: Set<KotlinType>, isStable: Boolean) defined in org.jetbrains.kotlin.resolve.scopes.receivers.ReceiverValueWithSmartCastInfo[DeserializedClassConstructorDescriptor]

'variableReceiver' @ [375:51] ==> val variableReceiver: ExpressionReceiver defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverValueWithSmartCastInfo[LocalVariableDescriptor]

'context' @ [375:69] ==> public final val context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke[PropertyDescriptorImpl]

'dataFlowInfo' @ [375:77] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'getCollectedTypes' @ [375:90] ==> public abstract fun getCollectedTypes(key: DataFlowValue): Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo[SimpleFunctionDescriptorImpl]

'dataFlowValue' @ [375:108] ==> val dataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverValueWithSmartCastInfo[LocalVariableDescriptor]

'dataFlowValue' @ [375:124] ==> val dataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.FactoryProviderForInvoke.createReceiverValueWithSmartCastInfo[LocalVariableDescriptor]

'isStable' @ [375:138] ==> public final val isStable: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'resolveExplicitReceiver' @ [388:40] ==> private final fun resolveExplicitReceiver(context: BasicCallResolutionContext, oldReceiver: Receiver?, isSafeCall: Boolean): ReceiverKotlinCallArgument? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'context' @ [388:64] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[ValueParameterDescriptorImpl]

'forcedExplicitReceiver' @ [388:73] ==> value-parameter forcedExplicitReceiver: Receiver? = ... defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[ValueParameterDescriptorImpl]

'oldCall' @ [388:98] ==> value-parameter oldCall: Call defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[ValueParameterDescriptorImpl]

'explicitReceiver' @ [388:106] ==> public final val Call.explicitReceiver: Receiver?[MyPropertyDescriptor]

'oldCall' @ [388:124] ==> value-parameter oldCall: Call defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[ValueParameterDescriptorImpl]

'isSafeCall' @ [388:132] ==> public fun Call.isSafeCall(): Boolean defined in org.jetbrains.kotlin.resolve.calls.callUtil in file callUtil.kt[SimpleFunctionDescriptorImpl]

'resolveTypeArguments' @ [389:37] ==> private final fun resolveTypeArguments(context: BasicCallResolutionContext, typeArguments: List<KtTypeProjection>): List<TypeArgument> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'context' @ [389:58] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[ValueParameterDescriptorImpl]

'oldCall' @ [389:67] ==> value-parameter oldCall: Call defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[ValueParameterDescriptorImpl]

'typeArguments' @ [389:75] ==> public final val Call.typeArguments: List<(KtTypeProjection..KtTypeProjection?)>[MyPropertyDescriptor]

'if (oldCall.callType != Call.CallType.ARRAY_SET_METHOD && oldCall.functionLiteralArguments.isEmpty()) {
            oldCall.valueArguments
        }
        else {
            oldCall.valueArguments.dropLast(1)
        }' @ [391:38] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<(ValueArgument..ValueArgument?)>, elseBranch: List<(ValueArgument..ValueArgument?)>): List<(ValueArgument..ValueArgument?)>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<(org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)>

'oldCall' @ [391:42] ==> value-parameter oldCall: Call defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[ValueParameterDescriptorImpl]

'callType' @ [391:50] ==> public final val Call.callType: Call.CallType[MyPropertyDescriptor]

'ARRAY_SET_METHOD' @ [391:76] ==> enum entry ARRAY_SET_METHOD defined in org.jetbrains.kotlin.psi.Call.CallType[FakeCallableDescriptorForObject]

'oldCall' @ [391:96] ==> value-parameter oldCall: Call defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[ValueParameterDescriptorImpl]

'functionLiteralArguments' @ [391:104] ==> public final val Call.functionLiteralArguments: List<(LambdaArgument..LambdaArgument?)>[MyPropertyDescriptor]

'isEmpty' @ [391:129] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'oldCall' @ [392:13] ==> value-parameter oldCall: Call defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[ValueParameterDescriptorImpl]

'valueArguments' @ [392:21] ==> public final val Call.valueArguments: List<(ValueArgument..ValueArgument?)>[MyPropertyDescriptor]

'oldCall' @ [395:13] ==> value-parameter oldCall: Call defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[ValueParameterDescriptorImpl]

'valueArguments' @ [395:21] ==> public final val Call.valueArguments: List<(ValueArgument..ValueArgument?)>[MyPropertyDescriptor]

'dropLast' @ [395:36] ==> public fun <T> List<(ValueArgument..ValueArgument?)>.dropLast(n: Int): List<(ValueArgument..ValueArgument?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)

'oldCall' @ [398:39] ==> value-parameter oldCall: Call defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[ValueParameterDescriptorImpl]

'functionLiteralArguments' @ [398:47] ==> public final val Call.functionLiteralArguments: List<(LambdaArgument..LambdaArgument?)>[MyPropertyDescriptor]

'resolveArgumentsInParenthesis' @ [399:46] ==> private final fun resolveArgumentsInParenthesis(context: BasicCallResolutionContext, arguments: List<ValueArgument>): List<KotlinCallArgument> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'context' @ [399:76] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[ValueParameterDescriptorImpl]

'argumentsInParenthesis' @ [399:85] ==> val argumentsInParenthesis: List<(ValueArgument..ValueArgument?)> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[LocalVariableDescriptor]

'if (oldCall.callType == Call.CallType.ARRAY_SET_METHOD) {
            assert(externalLambdaArguments.isEmpty()) {
                "Unexpected lambda parameters for call $oldCall"
            }
            oldCall.valueArguments.last()
        }
        else {
            if (externalLambdaArguments.size > 2) {
                externalLambdaArguments.drop(1).forEach {
                    context.trace.report(Errors.MANY_LAMBDA_EXPRESSION_ARGUMENTS.on(it.getLambdaExpression()))
                }
            }

            externalLambdaArguments.firstOrNull()
        }' @ [401:32] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: ValueArgument?, elseBranch: ValueArgument?): ValueArgument?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> ValueArgument?

'oldCall' @ [401:36] ==> value-parameter oldCall: Call defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[ValueParameterDescriptorImpl]

'callType' @ [401:44] ==> public final val Call.callType: Call.CallType[MyPropertyDescriptor]

'ARRAY_SET_METHOD' @ [401:70] ==> enum entry ARRAY_SET_METHOD defined in org.jetbrains.kotlin.psi.Call.CallType[FakeCallableDescriptorForObject]

'assert' @ [402:13] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'externalLambdaArguments' @ [402:20] ==> val externalLambdaArguments: List<(LambdaArgument..LambdaArgument?)> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[LocalVariableDescriptor]

'isEmpty' @ [402:44] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'oldCall' @ [403:57] ==> value-parameter oldCall: Call defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[ValueParameterDescriptorImpl]

'oldCall' @ [405:13] ==> value-parameter oldCall: Call defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[ValueParameterDescriptorImpl]

'valueArguments' @ [405:21] ==> public final val Call.valueArguments: List<(ValueArgument..ValueArgument?)>[MyPropertyDescriptor]

'last' @ [405:36] ==> public fun <T> List<(ValueArgument..ValueArgument?)>.last(): (ValueArgument..ValueArgument?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)

'externalLambdaArguments' @ [408:17] ==> val externalLambdaArguments: List<(LambdaArgument..LambdaArgument?)> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[LocalVariableDescriptor]

'size' @ [408:41] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'externalLambdaArguments' @ [409:17] ==> val externalLambdaArguments: List<(LambdaArgument..LambdaArgument?)> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[LocalVariableDescriptor]

'drop' @ [409:41] ==> public fun <T> Iterable<(LambdaArgument..LambdaArgument?)>.drop(n: Int): List<(LambdaArgument..LambdaArgument?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.LambdaArgument..org.jetbrains.kotlin.psi.LambdaArgument?)

'forEach' @ [409:49] ==> @HidesMembers public inline fun <T> Iterable<(LambdaArgument..LambdaArgument?)>.forEach(action: ((LambdaArgument..LambdaArgument?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.LambdaArgument..org.jetbrains.kotlin.psi.LambdaArgument?)

'context' @ [410:21] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[ValueParameterDescriptorImpl]

'trace' @ [410:29] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'report' @ [410:35] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'MANY_LAMBDA_EXPRESSION_ARGUMENTS' @ [410:49] ==> public final val MANY_LAMBDA_EXPRESSION_ARGUMENTS: (DiagnosticFactory0<(KtExpression..KtExpression?)>..DiagnosticFactory0<(KtExpression..KtExpression?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [410:82] ==> @NotNull public open fun on(@NotNull element: KtExpression): SimpleDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'it' @ [410:85] ==> value-parameter it: (LambdaArgument..LambdaArgument?) defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall.<anonymous>[ValueParameterDescriptorImpl]

'getLambdaExpression' @ [410:88] ==> public abstract fun getLambdaExpression(): KtLambdaExpression defined in org.jetbrains.kotlin.psi.LambdaArgument[SimpleFunctionDescriptorImpl]

'externalLambdaArguments' @ [414:13] ==> val externalLambdaArguments: List<(LambdaArgument..LambdaArgument?)> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[LocalVariableDescriptor]

'firstOrNull' @ [414:37] ==> public fun <T> List<(LambdaArgument..LambdaArgument?)>.firstOrNull(): LambdaArgument? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.LambdaArgument..org.jetbrains.kotlin.psi.LambdaArgument?)

'if (externalArgument != null && resolvedArgumentsInParenthesis.isNotEmpty())
                    resolvedArgumentsInParenthesis.last().psiCallArgument.dataFlowInfoAfterThisArgument
                else
                    context.dataFlowInfoForArguments.resultInfo' @ [418:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: DataFlowInfo, elseBranch: DataFlowInfo): DataFlowInfo[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> DataFlowInfo

'externalArgument' @ [418:21] ==> val externalArgument: ValueArgument? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[LocalVariableDescriptor]

'resolvedArgumentsInParenthesis' @ [418:49] ==> val resolvedArgumentsInParenthesis: List<KotlinCallArgument> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[LocalVariableDescriptor]

'isNotEmpty' @ [418:80] ==> @InlineOnly public inline fun <T> Collection<KotlinCallArgument>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinCallArgument

'resolvedArgumentsInParenthesis' @ [419:21] ==> val resolvedArgumentsInParenthesis: List<KotlinCallArgument> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[LocalVariableDescriptor]

'last' @ [419:52] ==> public fun <T> List<KotlinCallArgument>.last(): KotlinCallArgument defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinCallArgument

'psiCallArgument' @ [419:59] ==> public val KotlinCallArgument.psiCallArgument: PSIKotlinCallArgument defined in org.jetbrains.kotlin.resolve.calls.tower in file NewCallArguments.kt[PropertyDescriptorImpl]

'dataFlowInfoAfterThisArgument' @ [419:75] ==> public abstract val dataFlowInfoAfterThisArgument: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallArgument[PropertyDescriptorImpl]

'context' @ [421:21] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[ValueParameterDescriptorImpl]

'dataFlowInfoForArguments' @ [421:29] ==> @NotNull public final val dataFlowInfoForArguments: MutableDataFlowInfoForArguments defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'resultInfo' @ [421:54] ==> public final val MutableDataFlowInfoForArguments.resultInfo: DataFlowInfo[MyPropertyDescriptor]

'externalArgument' @ [423:35] ==> val externalArgument: ValueArgument? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[LocalVariableDescriptor]

'let' @ [423:53] ==> @InlineOnly public inline fun <T, R> ValueArgument.let(block: (ValueArgument) -> PSIKotlinCallArgument): PSIKotlinCallArgument defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ValueArgument
    <R> -> PSIKotlinCallArgument

'resolveValueArgument' @ [423:59] ==> private final fun resolveValueArgument(outerCallContext: BasicCallResolutionContext, startDataFlowInfo: DataFlowInfo, valueArgument: ValueArgument): PSIKotlinCallArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'context' @ [423:80] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[ValueParameterDescriptorImpl]

'dataFlowInfoAfterArgumentsInParenthesis' @ [423:89] ==> val dataFlowInfoAfterArgumentsInParenthesis: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[LocalVariableDescriptor]

'it' @ [423:130] ==> value-parameter it: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall.<anonymous>[ValueParameterDescriptorImpl]

'astExternalArgument' @ [424:34] ==> val astExternalArgument: PSIKotlinCallArgument? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[LocalVariableDescriptor]

'dataFlowInfoAfterThisArgument' @ [424:55] ==> public abstract val dataFlowInfoAfterThisArgument: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallArgument[PropertyDescriptorImpl]

'dataFlowInfoAfterArgumentsInParenthesis' @ [424:88] ==> val dataFlowInfoAfterArgumentsInParenthesis: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[LocalVariableDescriptor]

'PSIKotlinCallImpl' @ [426:16] ==> public constructor PSIKotlinCallImpl(callKind: KotlinCallKind, psiCall: Call, tracingStrategy: TracingStrategy, explicitReceiver: ReceiverKotlinCallArgument?, name: Name, typeArguments: List<TypeArgument>, argumentsInParenthesis: List<KotlinCallArgument>, externalArgument: KotlinCallArgument?, startingDataFlowInfo: DataFlowInfo, resultDataFlowInfo: DataFlowInfo, dataFlowInfoForArguments: DataFlowInfoForArguments) defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallImpl[ClassConstructorDescriptorImpl]

'kotlinCallKind' @ [426:34] ==> value-parameter kotlinCallKind: KotlinCallKind defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[ValueParameterDescriptorImpl]

'oldCall' @ [426:50] ==> value-parameter oldCall: Call defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[ValueParameterDescriptorImpl]

'tracingStrategy' @ [426:59] ==> value-parameter tracingStrategy: TracingStrategy defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[ValueParameterDescriptorImpl]

'resolvedExplicitReceiver' @ [426:76] ==> val resolvedExplicitReceiver: ReceiverKotlinCallArgument? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[LocalVariableDescriptor]

'name' @ [426:102] ==> value-parameter name: Name defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[ValueParameterDescriptorImpl]

'resolvedTypeArguments' @ [426:108] ==> val resolvedTypeArguments: List<TypeArgument> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[LocalVariableDescriptor]

'resolvedArgumentsInParenthesis' @ [426:131] ==> val resolvedArgumentsInParenthesis: List<KotlinCallArgument> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[LocalVariableDescriptor]

'astExternalArgument' @ [427:34] ==> val astExternalArgument: PSIKotlinCallArgument? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[LocalVariableDescriptor]

'context' @ [427:55] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [427:63] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'resultDataFlowInfo' @ [427:77] ==> val resultDataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[LocalVariableDescriptor]

'context' @ [427:97] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.toKotlinCall[ValueParameterDescriptorImpl]

'dataFlowInfoForArguments' @ [427:105] ==> @NotNull public final val dataFlowInfoForArguments: MutableDataFlowInfoForArguments defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'when(oldReceiver) {
                null -> null
                is QualifierReceiver -> QualifierReceiverKotlinCallArgument(oldReceiver) // todo report warning if isSafeCall
                is ReceiverValue -> {
                    val detailedReceiver = context.transformToReceiverWithSmartCastInfo(oldReceiver)

                    var subCallArgument: ReceiverKotlinCallArgument? = null
                    if (oldReceiver is ExpressionReceiver) {
                        val ktExpression = KtPsiUtil.getLastElementDeparenthesized(oldReceiver.expression, context.statementFilter)

                        val bindingContext = context.trace.bindingContext
                        val call = bindingContext[BindingContext.DELEGATE_EXPRESSION_TO_PROVIDE_DELEGATE_CALL, ktExpression]
                                   ?: ktExpression?.getCall(bindingContext)

                        val onlyResolvedCall = call?.let {
                            bindingContext.get(BindingContext.ONLY_RESOLVED_CALL, it)
                        }
                        if (onlyResolvedCall != null) {
                            subCallArgument = SubKotlinCallArgumentImpl(CallMaker.makeExternalValueArgument(oldReceiver.expression),
                                                      context.dataFlowInfo, context.dataFlowInfo, detailedReceiver, onlyResolvedCall)

                        }
                    }

                    subCallArgument ?: ReceiverExpressionKotlinCallArgument(detailedReceiver, isSafeCall)
                }
                else -> error("Incorrect receiver: $oldReceiver")
            }' @ [431:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: ReceiverKotlinCallArgument?, entry1: ReceiverKotlinCallArgument?, entry2: ReceiverKotlinCallArgument?, entry3: ReceiverKotlinCallArgument?): ReceiverKotlinCallArgument?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> ReceiverKotlinCallArgument?

'oldReceiver' @ [431:18] ==> value-parameter oldReceiver: Receiver? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[ValueParameterDescriptorImpl]

'QualifierReceiverKotlinCallArgument' @ [433:41] ==> public constructor QualifierReceiverKotlinCallArgument(receiver: QualifierReceiver) defined in org.jetbrains.kotlin.resolve.calls.model.QualifierReceiverKotlinCallArgument[DeserializedClassConstructorDescriptor]

'oldReceiver' @ [433:77] ==> value-parameter oldReceiver: Receiver? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[ValueParameterDescriptorImpl]

'context' @ [435:44] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[ValueParameterDescriptorImpl]

'transformToReceiverWithSmartCastInfo' @ [435:52] ==> public fun ResolutionContext<*>.transformToReceiverWithSmartCastInfo(receiver: ReceiverValue): ReceiverValueWithSmartCastInfo defined in org.jetbrains.kotlin.resolve.calls.tower in file NewResolutionOldInference.kt[SimpleFunctionDescriptorImpl]

'oldReceiver' @ [435:89] ==> value-parameter oldReceiver: Receiver? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[ValueParameterDescriptorImpl]

'oldReceiver' @ [438:25] ==> value-parameter oldReceiver: Receiver? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[ValueParameterDescriptorImpl]

'getLastElementDeparenthesized' @ [439:54] ==> @Nullable public open fun getLastElementDeparenthesized(@Nullable expression: KtExpression?, @NotNull statementFilter: StatementFilter): KtExpression? defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'oldReceiver' @ [439:84] ==> value-parameter oldReceiver: Receiver? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[ValueParameterDescriptorImpl]

'expression' @ [439:96] ==> public abstract val expression: KtExpression defined in org.jetbrains.kotlin.resolve.scopes.receivers.ExpressionReceiver[PropertyDescriptorImpl]

'context' @ [439:108] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[ValueParameterDescriptorImpl]

'statementFilter' @ [439:116] ==> @NotNull public final val statementFilter: StatementFilter defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'context' @ [441:46] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[ValueParameterDescriptorImpl]

'trace' @ [441:54] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'bindingContext' @ [441:60] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'bindingContext' @ [442:36] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[LocalVariableDescriptor]

'DELEGATE_EXPRESSION_TO_PROVIDE_DELEGATE_CALL' @ [442:66] ==> public final val DELEGATE_EXPRESSION_TO_PROVIDE_DELEGATE_CALL: (WritableSlice<(KtExpression..KtExpression?), (Call..Call?)>..WritableSlice<(KtExpression..KtExpression?), (Call..Call?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'ktExpression' @ [442:112] ==> val ktExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[LocalVariableDescriptor]

'ktExpression' @ [443:39] ==> val ktExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[LocalVariableDescriptor]

'getCall' @ [443:53] ==> public fun KtElement.getCall(context: BindingContext): Call? defined in org.jetbrains.kotlin.resolve.calls.callUtil in file callUtil.kt[SimpleFunctionDescriptorImpl]

'bindingContext' @ [443:61] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[LocalVariableDescriptor]

'call' @ [445:48] ==> val call: Call? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[LocalVariableDescriptor]

'let' @ [445:54] ==> @InlineOnly public inline fun <T, R> Call.let(block: (Call) -> CallResolutionResult?): CallResolutionResult? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Call
    <R> -> CallResolutionResult?

'bindingContext' @ [446:29] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[LocalVariableDescriptor]

'get' @ [446:44] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(slice: (ReadOnlySlice<(Call..Call?), (CallResolutionResult..CallResolutionResult?)>..ReadOnlySlice<(Call..Call?), (CallResolutionResult..CallResolutionResult?)>?), key: (Call..Call?)): CallResolutionResult? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.Call..org.jetbrains.kotlin.psi.Call?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.resolve.calls.model.CallResolutionResult..org.jetbrains.kotlin.resolve.calls.model.CallResolutionResult?)

'ONLY_RESOLVED_CALL' @ [446:63] ==> public final val ONLY_RESOLVED_CALL: (WritableSlice<(Call..Call?), (CallResolutionResult..CallResolutionResult?)>..WritableSlice<(Call..Call?), (CallResolutionResult..CallResolutionResult?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'it' @ [446:83] ==> value-parameter it: Call defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver.<anonymous>[ValueParameterDescriptorImpl]

'onlyResolvedCall' @ [448:29] ==> val onlyResolvedCall: CallResolutionResult? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[LocalVariableDescriptor]

'subCallArgument' @ [449:29] ==> var subCallArgument: ReceiverKotlinCallArgument? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[LocalVariableDescriptor]

'SubKotlinCallArgumentImpl' @ [449:47] ==> public constructor SubKotlinCallArgumentImpl(valueArgument: ValueArgument, dataFlowInfoBeforeThisArgument: DataFlowInfo, dataFlowInfoAfterThisArgument: DataFlowInfo, receiver: ReceiverValueWithSmartCastInfo, callResult: CallResolutionResult) defined in org.jetbrains.kotlin.resolve.calls.tower.SubKotlinCallArgumentImpl[ClassConstructorDescriptorImpl]

'makeExternalValueArgument' @ [449:83] ==> @NotNull public open fun makeExternalValueArgument(@NotNull expression: KtExpression): ValueArgument defined in org.jetbrains.kotlin.resolve.calls.util.CallMaker[JavaMethodDescriptor]

'oldReceiver' @ [449:109] ==> value-parameter oldReceiver: Receiver? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[ValueParameterDescriptorImpl]

'expression' @ [449:121] ==> public abstract val expression: KtExpression defined in org.jetbrains.kotlin.resolve.scopes.receivers.ExpressionReceiver[PropertyDescriptorImpl]

'context' @ [450:55] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [450:63] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'context' @ [450:77] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [450:85] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'detailedReceiver' @ [450:99] ==> val detailedReceiver: ReceiverValueWithSmartCastInfo defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[LocalVariableDescriptor]

'onlyResolvedCall' @ [450:117] ==> val onlyResolvedCall: CallResolutionResult? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[LocalVariableDescriptor]

'subCallArgument' @ [455:21] ==> var subCallArgument: ReceiverKotlinCallArgument? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[LocalVariableDescriptor]

'invoke' @ [455:40] ==> public final operator fun invoke(receiver: ReceiverValueWithSmartCastInfo, isSafeCall: Boolean = ..., isVariableReceiverForInvoke: Boolean = ...): ReceiverExpressionKotlinCallArgument defined in org.jetbrains.kotlin.resolve.calls.model.ReceiverExpressionKotlinCallArgument.Companion[DeserializedSimpleFunctionDescriptor]

'detailedReceiver' @ [455:77] ==> val detailedReceiver: ReceiverValueWithSmartCastInfo defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[LocalVariableDescriptor]

'isSafeCall' @ [455:95] ==> value-parameter isSafeCall: Boolean defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[ValueParameterDescriptorImpl]

'error' @ [457:25] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'oldReceiver' @ [457:53] ==> value-parameter oldReceiver: Receiver? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveExplicitReceiver[ValueParameterDescriptorImpl]

'typeReference' @ [461:13] ==> value-parameter typeReference: KtTypeReference? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveType[ValueParameterDescriptorImpl]

'typeResolver' @ [463:20] ==> private final val typeResolver: TypeResolver defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[PropertyDescriptorImpl]

'resolveType' @ [463:33] ==> public final fun resolveType(scope: LexicalScope, typeReference: KtTypeReference, trace: BindingTrace, checkBounds: Boolean): KotlinType defined in org.jetbrains.kotlin.resolve.TypeResolver[SimpleFunctionDescriptorImpl]

'context' @ [463:45] ==> value-parameter context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveType[ValueParameterDescriptorImpl]

'scope' @ [463:53] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'typeReference' @ [463:60] ==> value-parameter typeReference: KtTypeReference? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveType[ValueParameterDescriptorImpl]

'context' @ [463:75] ==> value-parameter context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveType[ValueParameterDescriptorImpl]

'trace' @ [463:83] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'forceResolveAllContents' @ [464:26] ==> @Nullable public open fun forceResolveAllContents(@Nullable type: KotlinType?): KotlinType? defined in org.jetbrains.kotlin.resolve.lazy.ForceResolveUtil[JavaMethodDescriptor]

'type' @ [464:50] ==> val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveType[LocalVariableDescriptor]

'type' @ [465:16] ==> val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveType[LocalVariableDescriptor]

'unwrap' @ [465:21] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'typeArguments' @ [469:13] ==> value-parameter typeArguments: List<KtTypeProjection> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveTypeArguments[ValueParameterDescriptorImpl]

'map' @ [469:27] ==> public inline fun <T, R> Iterable<KtTypeProjection>.map(transform: (KtTypeProjection) -> TypeArgument): List<TypeArgument> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtTypeProjection
    <R> -> TypeArgument

'projection' @ [470:21] ==> value-parameter projection: KtTypeProjection defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveTypeArguments.<anonymous>[ValueParameterDescriptorImpl]

'projectionKind' @ [470:32] ==> public final val KtTypeProjection.projectionKind: KtProjectionKind[MyPropertyDescriptor]

'NONE' @ [470:67] ==> enum entry NONE defined in org.jetbrains.kotlin.psi.KtProjectionKind[FakeCallableDescriptorForObject]

'context' @ [471:21] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveTypeArguments[ValueParameterDescriptorImpl]

'trace' @ [471:29] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'report' @ [471:35] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'PROJECTION_ON_NON_CLASS_TYPE_ARGUMENT' @ [471:49] ==> public final val PROJECTION_ON_NON_CLASS_TYPE_ARGUMENT: (DiagnosticFactory0<(KtTypeProjection..KtTypeProjection?)>..DiagnosticFactory0<(KtTypeProjection..KtTypeProjection?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [471:87] ==> @NotNull public open fun on(@NotNull element: KtTypeProjection): SimpleDiagnostic<(KtTypeProjection..KtTypeProjection?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'projection' @ [471:90] ==> value-parameter projection: KtTypeProjection defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveTypeArguments.<anonymous>[ValueParameterDescriptorImpl]

'ModifierCheckerCore' @ [473:17] ==> public object ModifierCheckerCore defined in org.jetbrains.kotlin.resolve in file ModifiersChecker.kt[FakeCallableDescriptorForObject]

'check' @ [473:37] ==> public final fun check(listOwner: KtModifierListOwner, trace: BindingTrace, descriptor: DeclarationDescriptor?, languageVersionSettings: LanguageVersionSettings): Unit defined in org.jetbrains.kotlin.resolve.ModifierCheckerCore[SimpleFunctionDescriptorImpl]

'projection' @ [473:43] ==> value-parameter projection: KtTypeProjection defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveTypeArguments.<anonymous>[ValueParameterDescriptorImpl]

'context' @ [473:55] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveTypeArguments[ValueParameterDescriptorImpl]

'trace' @ [473:63] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'languageVersionSettings' @ [473:76] ==> private final val languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[PropertyDescriptorImpl]

'resolveType' @ [475:17] ==> private final fun resolveType(context: ResolutionContext<*>, typeReference: KtTypeReference?): UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'context' @ [475:29] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveTypeArguments[ValueParameterDescriptorImpl]

'projection' @ [475:38] ==> value-parameter projection: KtTypeProjection defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveTypeArguments.<anonymous>[ValueParameterDescriptorImpl]

'typeReference' @ [475:49] ==> public final val KtTypeProjection.typeReference: KtTypeReference?[MyPropertyDescriptor]

'let' @ [475:65] ==> @InlineOnly public inline fun <T, R> UnwrappedType.let(block: (UnwrappedType) -> SimpleTypeArgumentImpl): SimpleTypeArgumentImpl defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> UnwrappedType
    <R> -> SimpleTypeArgumentImpl

'SimpleTypeArgumentImpl' @ [475:71] ==> public constructor SimpleTypeArgumentImpl(typeReference: KtTypeReference, type: UnwrappedType) defined in org.jetbrains.kotlin.resolve.calls.tower.SimpleTypeArgumentImpl[ClassConstructorDescriptorImpl]

'projection' @ [475:94] ==> value-parameter projection: KtTypeProjection defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveTypeArguments.<anonymous>[ValueParameterDescriptorImpl]

'typeReference' @ [475:105] ==> public final val KtTypeProjection.typeReference: KtTypeReference?[MyPropertyDescriptor]

'it' @ [475:122] ==> value-parameter it: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveTypeArguments.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'TypeArgumentPlaceholder' @ [475:132] ==> public object TypeArgumentPlaceholder : TypeArgument defined in org.jetbrains.kotlin.resolve.calls.model[FakeCallableDescriptorForObject]

'context' @ [482:40] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveArgumentsInParenthesis[ValueParameterDescriptorImpl]

'dataFlowInfoForArguments' @ [482:48] ==> @NotNull public final val dataFlowInfoForArguments: MutableDataFlowInfoForArguments defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'arguments' @ [483:16] ==> value-parameter arguments: List<ValueArgument> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveArgumentsInParenthesis[ValueParameterDescriptorImpl]

'map' @ [483:26] ==> public inline fun <T, R> Iterable<ValueArgument>.map(transform: (ValueArgument) -> PSIKotlinCallArgument): List<PSIKotlinCallArgument> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ValueArgument
    <R> -> PSIKotlinCallArgument

'resolveValueArgument' @ [484:13] ==> private final fun resolveValueArgument(outerCallContext: BasicCallResolutionContext, startDataFlowInfo: DataFlowInfo, valueArgument: ValueArgument): PSIKotlinCallArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'context' @ [484:34] ==> value-parameter context: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveArgumentsInParenthesis[ValueParameterDescriptorImpl]

'dataFlowInfoForArguments' @ [484:43] ==> val dataFlowInfoForArguments: MutableDataFlowInfoForArguments defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveArgumentsInParenthesis[LocalVariableDescriptor]

'getInfo' @ [484:68] ==> @NotNull public abstract fun getInfo(@NotNull valueArgument: ValueArgument): DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.model.MutableDataFlowInfoForArguments[JavaMethodDescriptor]

'argument' @ [484:76] ==> value-parameter argument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveArgumentsInParenthesis.<anonymous>[ValueParameterDescriptorImpl]

'argument' @ [484:87] ==> value-parameter argument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveArgumentsInParenthesis.<anonymous>[ValueParameterDescriptorImpl]

'also' @ [484:97] ==> @InlineOnly @SinceKotlin public inline fun <T> PSIKotlinCallArgument.also(block: (PSIKotlinCallArgument) -> Unit): PSIKotlinCallArgument defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PSIKotlinCallArgument

'dataFlowInfoForArguments' @ [485:17] ==> val dataFlowInfoForArguments: MutableDataFlowInfoForArguments defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveArgumentsInParenthesis[LocalVariableDescriptor]

'updateInfo' @ [485:42] ==> public abstract fun updateInfo(@NotNull valueArgument: ValueArgument, @NotNull dataFlowInfo: DataFlowInfo): Unit defined in org.jetbrains.kotlin.resolve.calls.model.MutableDataFlowInfoForArguments[JavaMethodDescriptor]

'argument' @ [485:53] ==> value-parameter argument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveArgumentsInParenthesis.<anonymous>[ValueParameterDescriptorImpl]

'resolvedArgument' @ [485:63] ==> value-parameter resolvedArgument: PSIKotlinCallArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveArgumentsInParenthesis.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'dataFlowInfoAfterThisArgument' @ [485:80] ==> public abstract val dataFlowInfoAfterThisArgument: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.tower.PSIKotlinCallArgument[PropertyDescriptorImpl]

'ParseErrorKotlinCallArgument' @ [495:34] ==> public constructor ParseErrorKotlinCallArgument(valueArgument: ValueArgument, dataFlowInfoAfterThisArgument: DataFlowInfo, builtIns: KotlinBuiltIns) defined in org.jetbrains.kotlin.resolve.calls.tower.ParseErrorKotlinCallArgument[ClassConstructorDescriptorImpl]

'valueArgument' @ [495:63] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveValueArgument[ValueParameterDescriptorImpl]

'startDataFlowInfo' @ [495:78] ==> value-parameter startDataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveValueArgument[ValueParameterDescriptorImpl]

'outerCallContext' @ [495:97] ==> value-parameter outerCallContext: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveValueArgument[ValueParameterDescriptorImpl]

'scope' @ [495:114] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'ownerDescriptor' @ [495:120] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'builtIns' @ [495:136] ==> public val DeclarationDescriptor.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'?:' @ [496:31] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KtExpression?, right: KtExpression): KtExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KtExpression

'deparenthesize' @ [496:41] ==> @Nullable public open fun deparenthesize(@Nullable expression: KtExpression?): KtExpression? defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'valueArgument' @ [496:56] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveValueArgument[ValueParameterDescriptorImpl]

'getArgumentExpression' @ [496:70] ==> @IfNotParsed public abstract fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.ValueArgument[SimpleFunctionDescriptorImpl]

'parseErrorArgument' @ [496:105] ==> val parseErrorArgument: ParseErrorKotlinCallArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveValueArgument[LocalVariableDescriptor]

'outerCallContext' @ [499:45] ==> value-parameter outerCallContext: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveValueArgument[ValueParameterDescriptorImpl]

'replaceContextDependency' @ [499:62] ==> @NotNull public open fun replaceContextDependency(@NotNull newContextDependency: ContextDependency): BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaMethodDescriptor]

'DEPENDENT' @ [499:105] ==> enum entry DEPENDENT defined in org.jetbrains.kotlin.resolve.calls.context.ContextDependency[FakeCallableDescriptorForObject]

'replaceExpectedType' @ [500:18] ==> @NotNull public open fun replaceExpectedType(@Nullable newExpectedType: KotlinType?): BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaMethodDescriptor]

'NO_EXPECTED_TYPE' @ [500:48] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'replaceDataFlowInfo' @ [500:66] ==> @NotNull public open fun replaceDataFlowInfo(@NotNull newDataFlowInfo: DataFlowInfo): BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaMethodDescriptor]

'startDataFlowInfo' @ [500:86] ==> value-parameter startDataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveValueArgument[ValueParameterDescriptorImpl]

'valueExpression' @ [502:13] ==> val valueExpression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveValueArgument[LocalVariableDescriptor]

'initializeBlockInfo' @ [503:29] ==> public fun initializeBlockInfo(blockExpression: KtBlockExpression, trace: BindingTrace): NewInferenceLastBlockExpressionHelper.AdditionalBlockInfo defined in org.jetbrains.kotlin.resolve.calls.tower in file NewInferenceLastBlockExpressionHelper.kt[SimpleFunctionDescriptorImpl]

'valueExpression' @ [503:49] ==> val valueExpression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveValueArgument[LocalVariableDescriptor]

'context' @ [503:66] ==> var context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveValueArgument[LocalVariableDescriptor]

'trace' @ [503:74] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'expressionTypingServices' @ [504:13] ==> private final val expressionTypingServices: ExpressionTypingServices defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[PropertyDescriptorImpl]

'getTypeInfo' @ [504:38] ==> @NotNull public open fun getTypeInfo(@NotNull expression: KtExpression, @NotNull resolutionContext: raw (ResolutionContext<(ResolutionContext<*>..ResolutionContext<*>?)>..ResolutionContext<out (ResolutionContext<*>..ResolutionContext<*>?)>)): KotlinTypeInfo defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingServices[JavaMethodDescriptor]

'valueExpression' @ [504:50] ==> val valueExpression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveValueArgument[LocalVariableDescriptor]

'context' @ [504:67] ==> var context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveValueArgument[LocalVariableDescriptor]

'context' @ [505:13] ==> var context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveValueArgument[LocalVariableDescriptor]

'blockInfo' @ [505:23] ==> val blockInfo: NewInferenceLastBlockExpressionHelper.AdditionalBlockInfo defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveValueArgument[LocalVariableDescriptor]

'lastExpressionContext' @ [505:33] ==> public final var lastExpressionContext: ExpressionTypingContext? defined in org.jetbrains.kotlin.resolve.calls.tower.NewInferenceLastBlockExpressionHelper.AdditionalBlockInfo[PropertyDescriptorImpl]

'context' @ [505:58] ==> var context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveValueArgument[LocalVariableDescriptor]

'createValueArgument' @ [507:16] ==> public final fun createValueArgument(callContext: ResolutionContext<*>, valueArgument: ValueArgument, callForScopeTower: Call): PSIKotlinCallArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'context' @ [507:36] ==> var context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveValueArgument[LocalVariableDescriptor]

'valueArgument' @ [507:45] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveValueArgument[ValueParameterDescriptorImpl]

'outerCallContext' @ [507:60] ==> value-parameter outerCallContext: BasicCallResolutionContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveValueArgument[ValueParameterDescriptorImpl]

'call' @ [507:77] ==> @NotNull public final val call: Call defined in org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext[JavaPropertyDescriptor]

'also' @ [507:83] ==> @InlineOnly @SinceKotlin public inline fun <T> PSIKotlinCallArgument.also(block: (PSIKotlinCallArgument) -> Unit): PSIKotlinCallArgument defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PSIKotlinCallArgument

'it' @ [508:13] ==> value-parameter it: PSIKotlinCallArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveValueArgument.<anonymous>[ValueParameterDescriptorImpl]

'setResultDataFlowInfoIfRelevant' @ [508:16] ==> internal fun KotlinCallArgument.setResultDataFlowInfoIfRelevant(resultDataFlowInfo: DataFlowInfo): Unit defined in org.jetbrains.kotlin.resolve.calls.tower in file NewCallArguments.kt[SimpleFunctionDescriptorImpl]

'context' @ [508:48] ==> var context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveValueArgument[LocalVariableDescriptor]

'dataFlowInfo' @ [508:56] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'callContext' @ [518:24] ==> value-parameter callContext: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'scope' @ [518:36] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'ownerDescriptor' @ [518:42] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'builtIns' @ [518:58] ==> public val DeclarationDescriptor.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'ParseErrorKotlinCallArgument' @ [519:34] ==> public constructor ParseErrorKotlinCallArgument(valueArgument: ValueArgument, dataFlowInfoAfterThisArgument: DataFlowInfo, builtIns: KotlinBuiltIns) defined in org.jetbrains.kotlin.resolve.calls.tower.ParseErrorKotlinCallArgument[ClassConstructorDescriptorImpl]

'valueArgument' @ [519:63] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'callContext' @ [519:78] ==> value-parameter callContext: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [519:90] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'builtIns' @ [519:104] ==> val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'extractArgumentExpression' @ [520:28] ==> public fun extractArgumentExpression(outerCallContext: ResolutionContext<*>, expression: KtExpression?): KtExpression? defined in org.jetbrains.kotlin.resolve.calls.tower in file NewInferenceLastBlockExpressionHelper.kt[SimpleFunctionDescriptorImpl]

'callContext' @ [520:54] ==> value-parameter callContext: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'valueArgument' @ [520:67] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'getArgumentExpression' @ [520:81] ==> @IfNotParsed public abstract fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.ValueArgument[SimpleFunctionDescriptorImpl]

'parseErrorArgument' @ [520:109] ==> val parseErrorArgument: ParseErrorKotlinCallArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'valueArgument' @ [522:28] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'getArgumentName' @ [522:42] ==> public abstract fun getArgumentName(): ValueArgumentName? defined in org.jetbrains.kotlin.psi.ValueArgument[SimpleFunctionDescriptorImpl]

'asName' @ [522:61] ==> public abstract val asName: Name defined in org.jetbrains.kotlin.psi.ValueArgumentName[PropertyDescriptorImpl]

'when (ktExpression) {
            is KtLambdaExpression ->
                LambdaKotlinCallArgumentImpl(callContext, valueArgument, callContext.dataFlowInfo, argumentName, ktExpression,
                                             resolveParametersTypes(callContext, ktExpression.functionLiteral))
            is KtNamedFunction -> {
                val receiverType = resolveType(callContext, ktExpression.receiverTypeReference)
                val parametersTypes = resolveParametersTypes(callContext, ktExpression) ?: emptyArray()
                val returnType = resolveType(callContext, ktExpression.typeReference) ?:
                                 if (ktExpression.hasBlockBody()) builtIns.unitType else null
                FunctionExpressionImpl(callContext, valueArgument, callContext.dataFlowInfo, argumentName, ktExpression, receiverType, parametersTypes, returnType)
            }

            else -> null
        }' @ [524:54] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: PSIKotlinCallArgument?, entry1: PSIKotlinCallArgument?, entry2: PSIKotlinCallArgument?): PSIKotlinCallArgument?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> PSIKotlinCallArgument?

'ktExpression' @ [524:60] ==> val ktExpression: Any defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'LambdaKotlinCallArgumentImpl' @ [526:17] ==> public constructor LambdaKotlinCallArgumentImpl(outerCallContext: ResolutionContext<*>, valueArgument: ValueArgument, dataFlowInfoBeforeThisArgument: DataFlowInfo, argumentName: Name?, ktLambdaExpression: KtLambdaExpression, parametersTypes: Array<UnwrappedType?>?) defined in org.jetbrains.kotlin.resolve.calls.tower.LambdaKotlinCallArgumentImpl[ClassConstructorDescriptorImpl]

'callContext' @ [526:46] ==> value-parameter callContext: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'valueArgument' @ [526:59] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'callContext' @ [526:74] ==> value-parameter callContext: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [526:86] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'argumentName' @ [526:100] ==> val argumentName: Name? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'ktExpression' @ [526:114] ==> val ktExpression: Any defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'resolveParametersTypes' @ [527:46] ==> private final fun resolveParametersTypes(context: ResolutionContext<*>, ktFunction: KtFunction): Array<UnwrappedType?>? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'callContext' @ [527:69] ==> value-parameter callContext: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'ktExpression' @ [527:82] ==> val ktExpression: Any defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'functionLiteral' @ [527:95] ==> public final val KtLambdaExpression.functionLiteral: KtFunctionLiteral[MyPropertyDescriptor]

'resolveType' @ [529:36] ==> private final fun resolveType(context: ResolutionContext<*>, typeReference: KtTypeReference?): UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'callContext' @ [529:48] ==> value-parameter callContext: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'ktExpression' @ [529:61] ==> val ktExpression: Any defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'receiverTypeReference' @ [529:74] ==> public final val KtNamedFunction.receiverTypeReference: KtTypeReference?[MyPropertyDescriptor]

'resolveParametersTypes' @ [530:39] ==> private final fun resolveParametersTypes(context: ResolutionContext<*>, ktFunction: KtFunction): Array<UnwrappedType?>? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'callContext' @ [530:62] ==> value-parameter callContext: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'ktExpression' @ [530:75] ==> val ktExpression: Any defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'emptyArray' @ [530:92] ==> public inline fun <reified @PureReifiable T> emptyArray(): Array<UnwrappedType?> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified @PureReifiable T> -> UnwrappedType?

'resolveType' @ [531:34] ==> private final fun resolveType(context: ResolutionContext<*>, typeReference: KtTypeReference?): UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'callContext' @ [531:46] ==> value-parameter callContext: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'ktExpression' @ [531:59] ==> val ktExpression: Any defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'typeReference' @ [531:72] ==> public final var KtNamedFunction.typeReference: KtTypeReference?[MyPropertyDescriptor]

'if (ktExpression.hasBlockBody()) builtIns.unitType else null' @ [532:34] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: SimpleType?, elseBranch: SimpleType?): SimpleType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> SimpleType?

'ktExpression' @ [532:38] ==> val ktExpression: Any defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'hasBlockBody' @ [532:51] ==> @Override public open fun hasBlockBody(): Boolean defined in org.jetbrains.kotlin.psi.KtNamedFunction[JavaMethodDescriptor]

'builtIns' @ [532:67] ==> val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'unitType' @ [532:76] ==> public final val KotlinBuiltIns.unitType: SimpleType[MyPropertyDescriptor]

'FunctionExpressionImpl' @ [533:17] ==> public constructor FunctionExpressionImpl(outerCallContext: ResolutionContext<*>, valueArgument: ValueArgument, dataFlowInfoBeforeThisArgument: DataFlowInfo, argumentName: Name?, ktFunction: KtNamedFunction, receiverType: UnwrappedType?, parametersTypes: Array<UnwrappedType?>, returnType: UnwrappedType?) defined in org.jetbrains.kotlin.resolve.calls.tower.FunctionExpressionImpl[ClassConstructorDescriptorImpl]

'callContext' @ [533:40] ==> value-parameter callContext: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'valueArgument' @ [533:53] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'callContext' @ [533:68] ==> value-parameter callContext: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [533:80] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'argumentName' @ [533:94] ==> val argumentName: Name? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'ktExpression' @ [533:108] ==> val ktExpression: Any defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'receiverType' @ [533:122] ==> val receiverType: UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'parametersTypes' @ [533:136] ==> val parametersTypes: Array<UnwrappedType?> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'returnType' @ [533:153] ==> val returnType: UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'lambdaArgument' @ [538:13] ==> val lambdaArgument: PSIKotlinCallArgument? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'checkNoSpread' @ [539:13] ==> private final fun checkNoSpread(context: ResolutionContext<*>, valueArgument: ValueArgument): Unit defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'callContext' @ [539:27] ==> value-parameter callContext: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'valueArgument' @ [539:40] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'lambdaArgument' @ [540:20] ==> val lambdaArgument: PSIKotlinCallArgument? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'ktExpression' @ [543:13] ==> val ktExpression: Any defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'CollectionLiteralKotlinCallArgumentImpl' @ [544:20] ==> public constructor CollectionLiteralKotlinCallArgumentImpl(valueArgument: ValueArgument, argumentName: Name?, dataFlowInfoBeforeThisArgument: DataFlowInfo, dataFlowInfoAfterThisArgument: DataFlowInfo, collectionLiteralExpression: KtCollectionLiteralExpression, outerCallContext: ResolutionContext<*>) defined in org.jetbrains.kotlin.resolve.calls.tower.CollectionLiteralKotlinCallArgumentImpl[ClassConstructorDescriptorImpl]

'valueArgument' @ [545:21] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'argumentName' @ [545:36] ==> val argumentName: Name? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'callContext' @ [545:50] ==> value-parameter callContext: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [545:62] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'callContext' @ [545:76] ==> value-parameter callContext: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [545:88] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'ktExpression' @ [545:102] ==> val ktExpression: Any defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'callContext' @ [545:116] ==> value-parameter callContext: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'ktExpression' @ [548:13] ==> val ktExpression: Any defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'checkNoSpread' @ [549:13] ==> private final fun checkNoSpread(context: ResolutionContext<*>, valueArgument: ValueArgument): Unit defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'callContext' @ [549:27] ==> value-parameter callContext: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'valueArgument' @ [549:40] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'newContext' @ [551:67] ==> @NotNull public open fun newContext(@NotNull context: raw (ResolutionContext<(ResolutionContext<*>..ResolutionContext<*>?)>..ResolutionContext<out (ResolutionContext<*>..ResolutionContext<*>?)>)): ExpressionTypingContext defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaMethodDescriptor]

'callContext' @ [551:78] ==> value-parameter callContext: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'if (ktExpression.isEmptyLHS) null else doubleColonExpressionResolver.getOrResolveDoubleColonLHS(ktExpression, expressionTypingContext)' @ [552:29] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: DoubleColonLHS?, elseBranch: DoubleColonLHS?): DoubleColonLHS?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> DoubleColonLHS?

'ktExpression' @ [552:33] ==> val ktExpression: Any defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'isEmptyLHS' @ [552:46] ==> public final val isEmptyLHS: Boolean defined in org.jetbrains.kotlin.psi.KtCallableReferenceExpression[PropertyDescriptorImpl]

'doubleColonExpressionResolver' @ [552:68] ==> private final val doubleColonExpressionResolver: DoubleColonExpressionResolver defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[PropertyDescriptorImpl]

'getOrResolveDoubleColonLHS' @ [552:98] ==> internal final fun getOrResolveDoubleColonLHS(doubleColonExpression: KtDoubleColonExpression, c: ExpressionTypingContext): DoubleColonLHS? defined in org.jetbrains.kotlin.types.expressions.DoubleColonExpressionResolver[SimpleFunctionDescriptorImpl]

'ktExpression' @ [552:125] ==> val ktExpression: Any defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'expressionTypingContext' @ [552:139] ==> val expressionTypingContext: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'?:' @ [553:35] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: DataFlowInfo?, right: DataFlowInfo): DataFlowInfo[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> DataFlowInfo

'lhsResult' @ [553:36] ==> val lhsResult: DoubleColonLHS? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'dataFlowInfo' @ [553:78] ==> public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.types.expressions.DoubleColonLHS.Expression[PropertyDescriptorImpl]

'callContext' @ [553:94] ==> value-parameter callContext: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [553:106] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'ktExpression' @ [554:24] ==> val ktExpression: Any defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'callableReference' @ [554:37] ==> public final val KtCallableReferenceExpression.callableReference: KtSimpleNameExpression[MyPropertyDescriptor]

'getReferencedNameAsName' @ [554:55] ==> public abstract fun getReferencedNameAsName(): Name defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[SimpleFunctionDescriptorImpl]

'when (lhsResult) {
                null -> LHSResult.Empty
                is DoubleColonLHS.Expression -> {
                    if (lhsResult.isObjectQualifier) {
                        val classifier = lhsResult.type.constructor.declarationDescriptor
                        val calleeExpression = ktExpression.receiverExpression?.getCalleeExpressionIfAny()
                        if (calleeExpression is KtSimpleNameExpression && classifier is ClassDescriptor) {
                            LHSResult.Object(ClassQualifier(calleeExpression, classifier))
                        }
                        else {
                            LHSResult.Error
                        }
                    }
                    else {
                        val fakeArgument = FakeValueArgumentForLeftCallableReference(ktExpression)

                        val kotlinCallArgument = createSimplePSICallArgument(callContext, fakeArgument, lhsResult.typeInfo)
                        kotlinCallArgument?.let { LHSResult.Expression(it as SimpleKotlinCallArgument) } ?: LHSResult.Error
                    }
                }
                is DoubleColonLHS.Type -> {
                    val qualifiedExpression = ktExpression.receiverExpression!!.let { it.referenceExpression() ?: it }
                    val qualifier = expressionTypingContext.trace.get(BindingContext.QUALIFIER, qualifiedExpression)
                    if (qualifier is ClassQualifier) {
                        LHSResult.Type(qualifier, lhsResult.type.unwrap())
                    }
                    else {
                        LHSResult.Error
                    }
                }
            }' @ [556:32] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: LHSResult, entry1: LHSResult, entry2: LHSResult): LHSResult[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> LHSResult

'lhsResult' @ [556:38] ==> val lhsResult: DoubleColonLHS? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'Empty' @ [557:35] ==> public object Empty : LHSResult defined in org.jetbrains.kotlin.resolve.calls.model.LHSResult[FakeCallableDescriptorForObject]

'if (lhsResult.isObjectQualifier) {
                        val classifier = lhsResult.type.constructor.declarationDescriptor
                        val calleeExpression = ktExpression.receiverExpression?.getCalleeExpressionIfAny()
                        if (calleeExpression is KtSimpleNameExpression && classifier is ClassDescriptor) {
                            LHSResult.Object(ClassQualifier(calleeExpression, classifier))
                        }
                        else {
                            LHSResult.Error
                        }
                    }
                    else {
                        val fakeArgument = FakeValueArgumentForLeftCallableReference(ktExpression)

                        val kotlinCallArgument = createSimplePSICallArgument(callContext, fakeArgument, lhsResult.typeInfo)
                        kotlinCallArgument?.let { LHSResult.Expression(it as SimpleKotlinCallArgument) } ?: LHSResult.Error
                    }' @ [559:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: LHSResult, elseBranch: LHSResult): LHSResult[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> LHSResult

'lhsResult' @ [559:25] ==> val lhsResult: DoubleColonLHS? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'isObjectQualifier' @ [559:35] ==> public final val isObjectQualifier: Boolean defined in org.jetbrains.kotlin.types.expressions.DoubleColonLHS.Expression[PropertyDescriptorImpl]

'lhsResult' @ [560:42] ==> val lhsResult: DoubleColonLHS? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'type' @ [560:52] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.types.expressions.DoubleColonLHS[PropertyDescriptorImpl]

'constructor' @ [560:57] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'declarationDescriptor' @ [560:69] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'ktExpression' @ [561:48] ==> val ktExpression: Any defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'receiverExpression' @ [561:61] ==> public final val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.psi.KtCallableReferenceExpression[PropertyDescriptorImpl]

'getCalleeExpressionIfAny' @ [561:81] ==> public fun KtElement?.getCalleeExpressionIfAny(): KtExpression? defined in org.jetbrains.kotlin.resolve.calls.callUtil in file callUtil.kt[SimpleFunctionDescriptorImpl]

'if (calleeExpression is KtSimpleNameExpression && classifier is ClassDescriptor) {
                            LHSResult.Object(ClassQualifier(calleeExpression, classifier))
                        }
                        else {
                            LHSResult.Error
                        }' @ [562:25] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: LHSResult, elseBranch: LHSResult): LHSResult[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> LHSResult

'calleeExpression' @ [562:29] ==> val calleeExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'classifier' @ [562:75] ==> val classifier: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'Object' @ [563:39] ==> public constructor Object(qualifier: QualifierReceiver) defined in org.jetbrains.kotlin.resolve.calls.model.LHSResult.Object[DeserializedClassConstructorDescriptor]

'ClassQualifier' @ [563:46] ==> public constructor ClassQualifier(referenceExpression: KtSimpleNameExpression, descriptor: ClassDescriptor) defined in org.jetbrains.kotlin.resolve.scopes.receivers.ClassQualifier[ClassConstructorDescriptorImpl]

'calleeExpression' @ [563:61] ==> val calleeExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'classifier' @ [563:79] ==> val classifier: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'Error' @ [566:39] ==> public object Error : LHSResult defined in org.jetbrains.kotlin.resolve.calls.model.LHSResult[FakeCallableDescriptorForObject]

'FakeValueArgumentForLeftCallableReference' @ [570:44] ==> public constructor FakeValueArgumentForLeftCallableReference(ktExpression: KtCallableReferenceExpression) defined in org.jetbrains.kotlin.resolve.calls.tower.FakeValueArgumentForLeftCallableReference[ClassConstructorDescriptorImpl]

'ktExpression' @ [570:86] ==> val ktExpression: Any defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'createSimplePSICallArgument' @ [572:50] ==> internal fun createSimplePSICallArgument(contextForArgument: ResolutionContext<*>, valueArgument: ValueArgument, typeInfoForArgument: KotlinTypeInfo): SimplePSIKotlinCallArgument? defined in org.jetbrains.kotlin.resolve.calls.tower in file NewCallArguments.kt[SimpleFunctionDescriptorImpl]

'callContext' @ [572:78] ==> value-parameter callContext: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'fakeArgument' @ [572:91] ==> val fakeArgument: FakeValueArgumentForLeftCallableReference defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'lhsResult' @ [572:105] ==> val lhsResult: DoubleColonLHS? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'typeInfo' @ [572:115] ==> public final val typeInfo: KotlinTypeInfo defined in org.jetbrains.kotlin.types.expressions.DoubleColonLHS.Expression[PropertyDescriptorImpl]

'kotlinCallArgument' @ [573:25] ==> val kotlinCallArgument: SimplePSIKotlinCallArgument? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'let' @ [573:45] ==> @InlineOnly public inline fun <T, R> SimplePSIKotlinCallArgument.let(block: (SimplePSIKotlinCallArgument) -> LHSResult.Expression): LHSResult.Expression defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SimplePSIKotlinCallArgument
    <R> -> Expression

'Expression' @ [573:61] ==> public constructor Expression(lshCallArgument: SimpleKotlinCallArgument) defined in org.jetbrains.kotlin.resolve.calls.model.LHSResult.Expression[DeserializedClassConstructorDescriptor]

'it' @ [573:72] ==> value-parameter it: SimplePSIKotlinCallArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument.<anonymous>[ValueParameterDescriptorImpl]

'Error' @ [573:119] ==> public object Error : LHSResult defined in org.jetbrains.kotlin.resolve.calls.model.LHSResult[FakeCallableDescriptorForObject]

'ktExpression' @ [577:47] ==> val ktExpression: Any defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'receiverExpression' @ [577:60] ==> public final val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.psi.KtCallableReferenceExpression[PropertyDescriptorImpl]

'let' @ [577:81] ==> @InlineOnly public inline fun <T, R> KtExpression.let(block: (KtExpression) -> KtExpression): KtExpression defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression
    <R> -> KtExpression

'it' @ [577:87] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument.<anonymous>[ValueParameterDescriptorImpl]

'referenceExpression' @ [577:90] ==> public fun KtExpression.referenceExpression(): KtReferenceExpression? defined in org.jetbrains.kotlin.psi.psiUtil in file ktPsiUtil.kt[SimpleFunctionDescriptorImpl]

'it' @ [577:115] ==> value-parameter it: KtExpression defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument.<anonymous>[ValueParameterDescriptorImpl]

'expressionTypingContext' @ [578:37] ==> val expressionTypingContext: ExpressionTypingContext defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'trace' @ [578:61] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'get' @ [578:67] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(slice: (ReadOnlySlice<(KtExpression..KtExpression?), (Qualifier..Qualifier?)>..ReadOnlySlice<(KtExpression..KtExpression?), (Qualifier..Qualifier?)>?), key: (KtExpression..KtExpression?)): Qualifier? defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtExpression..org.jetbrains.kotlin.psi.KtExpression?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.resolve.scopes.receivers.Qualifier..org.jetbrains.kotlin.resolve.scopes.receivers.Qualifier?)

'QUALIFIER' @ [578:86] ==> public final val QUALIFIER: (WritableSlice<(KtExpression..KtExpression?), (Qualifier..Qualifier?)>..WritableSlice<(KtExpression..KtExpression?), (Qualifier..Qualifier?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'qualifiedExpression' @ [578:97] ==> val qualifiedExpression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'if (qualifier is ClassQualifier) {
                        LHSResult.Type(qualifier, lhsResult.type.unwrap())
                    }
                    else {
                        LHSResult.Error
                    }' @ [579:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: LHSResult, elseBranch: LHSResult): LHSResult[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> LHSResult

'qualifier' @ [579:25] ==> val qualifier: Qualifier? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'Type' @ [580:35] ==> public constructor Type(qualifier: QualifierReceiver, resolvedType: UnwrappedType) defined in org.jetbrains.kotlin.resolve.calls.model.LHSResult.Type[DeserializedClassConstructorDescriptor]

'qualifier' @ [580:40] ==> val qualifier: Qualifier? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'lhsResult' @ [580:51] ==> val lhsResult: DoubleColonLHS? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'type' @ [580:61] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.types.expressions.DoubleColonLHS[PropertyDescriptorImpl]

'unwrap' @ [580:66] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'Error' @ [583:35] ==> public object Error : LHSResult defined in org.jetbrains.kotlin.resolve.calls.model.LHSResult[FakeCallableDescriptorForObject]

'CallableReferenceKotlinCallArgumentImpl' @ [588:20] ==> public constructor CallableReferenceKotlinCallArgumentImpl(scopeTowerForResolution: ImplicitScopeTower, valueArgument: ValueArgument, dataFlowInfoBeforeThisArgument: DataFlowInfo, dataFlowInfoAfterThisArgument: DataFlowInfo, ktCallableReferenceExpression: KtCallableReferenceExpression, argumentName: Name?, lhsResult: LHSResult, rhsName: Name) defined in org.jetbrains.kotlin.resolve.calls.tower.CallableReferenceKotlinCallArgumentImpl[ClassConstructorDescriptorImpl]

'ASTScopeTower' @ [588:60] ==> public constructor ASTScopeTower(context: ResolutionContext<*>, call: Call) defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.ASTScopeTower[ClassConstructorDescriptorImpl]

'callContext' @ [588:74] ==> value-parameter callContext: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'callForScopeTower' @ [588:87] ==> value-parameter callForScopeTower: Call defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'valueArgument' @ [588:107] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'callContext' @ [588:122] ==> value-parameter callContext: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [588:134] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'newDataFlowInfo' @ [588:148] ==> val newDataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'ktExpression' @ [589:60] ==> val ktExpression: Any defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'argumentName' @ [589:74] ==> val argumentName: Name? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'lhsNewResult' @ [589:88] ==> val lhsNewResult: LHSResult defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'name' @ [589:102] ==> val name: Name defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'valueArgument' @ [592:34] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'getArgumentExpression' @ [592:48] ==> @IfNotParsed public abstract fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.ValueArgument[SimpleFunctionDescriptorImpl]

'parseErrorArgument' @ [592:82] ==> val parseErrorArgument: ParseErrorKotlinCallArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'expressionTypingServices' @ [595:24] ==> private final val expressionTypingServices: ExpressionTypingServices defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[PropertyDescriptorImpl]

'getTypeInfo' @ [595:49] ==> @NotNull public open fun getTypeInfo(@NotNull expression: KtExpression, @NotNull resolutionContext: raw (ResolutionContext<(ResolutionContext<*>..ResolutionContext<*>?)>..ResolutionContext<out (ResolutionContext<*>..ResolutionContext<*>?)>)): KotlinTypeInfo defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingServices[JavaMethodDescriptor]

'argumentExpression' @ [595:61] ==> val argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'callContext' @ [595:81] ==> value-parameter callContext: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'createSimplePSICallArgument' @ [596:16] ==> internal fun createSimplePSICallArgument(contextForArgument: ResolutionContext<*>, valueArgument: ValueArgument, typeInfoForArgument: KotlinTypeInfo): SimplePSIKotlinCallArgument? defined in org.jetbrains.kotlin.resolve.calls.tower in file NewCallArguments.kt[SimpleFunctionDescriptorImpl]

'callContext' @ [596:44] ==> value-parameter callContext: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'valueArgument' @ [596:57] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[ValueParameterDescriptorImpl]

'typeInfo' @ [596:72] ==> val typeInfo: KotlinTypeInfo defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'parseErrorArgument' @ [596:85] ==> val parseErrorArgument: ParseErrorKotlinCallArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.createValueArgument[LocalVariableDescriptor]

'valueArgument' @ [600:9] ==> value-parameter valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.checkNoSpread[ValueParameterDescriptorImpl]

'getSpreadElement' @ [600:23] ==> public abstract fun getSpreadElement(): LeafPsiElement? defined in org.jetbrains.kotlin.psi.ValueArgument[SimpleFunctionDescriptorImpl]

'let' @ [600:43] ==> @InlineOnly public inline fun <T, R> LeafPsiElement.let(block: (LeafPsiElement) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> LeafPsiElement
    <R> -> Unit

'context' @ [601:13] ==> value-parameter context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.checkNoSpread[ValueParameterDescriptorImpl]

'trace' @ [601:21] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'report' @ [601:27] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'SPREAD_OF_LAMBDA_OR_CALLABLE_REFERENCE' @ [601:41] ==> public final val SPREAD_OF_LAMBDA_OR_CALLABLE_REFERENCE: (DiagnosticFactory0<(LeafPsiElement..LeafPsiElement?)>..DiagnosticFactory0<(LeafPsiElement..LeafPsiElement?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [601:80] ==> @NotNull public open fun on(@NotNull element: LeafPsiElement): SimpleDiagnostic<(LeafPsiElement..LeafPsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'it' @ [601:83] ==> value-parameter it: LeafPsiElement defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.checkNoSpread.<anonymous>[ValueParameterDescriptorImpl]

'ktFunction' @ [606:29] ==> value-parameter ktFunction: KtFunction defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveParametersTypes[ValueParameterDescriptorImpl]

'valueParameterList' @ [606:40] ==> public final val KtFunction.valueParameterList: KtParameterList?[MyPropertyDescriptor]

'Array' @ [608:16] ==> public constructor Array<T>(size: Int, init: (Int) -> UnwrappedType?) defined in kotlin.Array[DeserializedClassConstructorDescriptor]
Inferred types:
    <T> -> UnwrappedType?

'parameterList' @ [608:22] ==> val parameterList: KtParameterList defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveParametersTypes[LocalVariableDescriptor]

'parameters' @ [608:36] ==> public final val KtParameterList.parameters: (MutableList<(KtParameter..KtParameter?)>..List<(KtParameter..KtParameter?)>)[MyPropertyDescriptor]

'size' @ [608:47] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'parameterList' @ [609:13] ==> val parameterList: KtParameterList defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveParametersTypes[LocalVariableDescriptor]

'parameters' @ [609:27] ==> public final val KtParameterList.parameters: (MutableList<(KtParameter..KtParameter?)>..List<(KtParameter..KtParameter?)>)[MyPropertyDescriptor]

'it' @ [609:38] ==> value-parameter it: Int defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveParametersTypes.<anonymous>[ValueParameterDescriptorImpl]

'typeReference' @ [609:43] ==> public final var KtParameter.typeReference: KtTypeReference?[MyPropertyDescriptor]

'let' @ [609:58] ==> @InlineOnly public inline fun <T, R> KtTypeReference.let(block: (KtTypeReference) -> UnwrappedType?): UnwrappedType? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtTypeReference
    <R> -> UnwrappedType?

'resolveType' @ [609:64] ==> private final fun resolveType(context: ResolutionContext<*>, typeReference: KtTypeReference?): UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver[SimpleFunctionDescriptorImpl]

'context' @ [609:76] ==> value-parameter context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveParametersTypes[ValueParameterDescriptorImpl]

'it' @ [609:85] ==> value-parameter it: KtTypeReference defined in org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver.resolveParametersTypes.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

