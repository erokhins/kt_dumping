'ConstantValueFactory' @ [56:41] ==> public constructor ConstantValueFactory(builtins: KotlinBuiltIns) defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[DeserializedClassConstructorDescriptor]

'builtIns' @ [56:62] ==> internal final val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[PropertyDescriptorImpl]

'expression' @ [64:13] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.updateNumberType[ValueParameterDescriptorImpl]

'updateRecordedType' @ [65:29] ==> @Nullable public open fun updateRecordedType(@Nullable type: KotlinType?, @NotNull expression: KtExpression, @NotNull trace: BindingTrace, shouldBeMadeNullable: Boolean): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingContextUtils[JavaMethodDescriptor]

'numberType' @ [65:48] ==> value-parameter numberType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.updateNumberType[ValueParameterDescriptorImpl]

'expression' @ [65:60] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.updateNumberType[ValueParameterDescriptorImpl]

'trace' @ [65:72] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.updateNumberType[ValueParameterDescriptorImpl]

'expression' @ [67:13] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.updateNumberType[ValueParameterDescriptorImpl]

'getLastElementDeparenthesized' @ [68:45] ==> @Nullable public open fun getLastElementDeparenthesized(@Nullable expression: KtExpression?, @NotNull statementFilter: StatementFilter): KtExpression? defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'expression' @ [68:75] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.updateNumberType[ValueParameterDescriptorImpl]

'statementFilter' @ [68:87] ==> value-parameter statementFilter: StatementFilter defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.updateNumberType[ValueParameterDescriptorImpl]

'deparenthesized' @ [69:17] ==> val deparenthesized: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.updateNumberType[LocalVariableDescriptor]

'expression' @ [69:37] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.updateNumberType[ValueParameterDescriptorImpl]

'updateNumberType' @ [70:17] ==> public final fun updateNumberType(numberType: KotlinType, expression: KtExpression?, statementFilter: StatementFilter, trace: BindingTrace): Unit defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[SimpleFunctionDescriptorImpl]

'numberType' @ [70:34] ==> value-parameter numberType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.updateNumberType[ValueParameterDescriptorImpl]

'deparenthesized' @ [70:46] ==> val deparenthesized: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.updateNumberType[LocalVariableDescriptor]

'statementFilter' @ [70:63] ==> value-parameter statementFilter: StatementFilter defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.updateNumberType[ValueParameterDescriptorImpl]

'trace' @ [70:80] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.updateNumberType[ValueParameterDescriptorImpl]

'evaluateExpression' @ [75:9] ==> public final fun evaluateExpression(expression: KtExpression, trace: BindingTrace, expectedType: KotlinType? = ...): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[SimpleFunctionDescriptorImpl]

'expression' @ [75:28] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.updateNumberType[ValueParameterDescriptorImpl]

'trace' @ [75:40] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.updateNumberType[ValueParameterDescriptorImpl]

'numberType' @ [75:47] ==> value-parameter numberType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.updateNumberType[ValueParameterDescriptorImpl]

'HashMap' @ [82:25] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> Name
    <V : (Any..Any?)> -> ConstantValue<*>

'component1' @ [83:15] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>.component1(): (ValueParameterDescriptor..ValueParameterDescriptor?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)
    <V> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument..org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument?)

'component2' @ [83:36] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>.component2(): (ResolvedValueArgument..ResolvedValueArgument?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)
    <V> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument..org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument?)

'resolvedCall' @ [83:57] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationArguments[ValueParameterDescriptorImpl]

'valueArguments' @ [83:70] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.valueArguments: (MutableMap<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>..Map<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'entries' @ [83:85] ==> public abstract val entries: MutableSet<MutableMap.MutableEntry<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>> defined in kotlin.collections.MutableMap[DeserializedPropertyDescriptor]

'getAnnotationArgumentValue' @ [84:25] ==> public final fun getAnnotationArgumentValue(trace: BindingTrace, parameterDescriptor: ValueParameterDescriptor, resolvedArgument: ResolvedValueArgument): ConstantValue<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[SimpleFunctionDescriptorImpl]

'trace' @ [84:52] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationArguments[ValueParameterDescriptorImpl]

'parameterDescriptor' @ [84:59] ==> val parameterDescriptor: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationArguments[LocalVariableDescriptor]

'resolvedArgument' @ [84:80] ==> val resolvedArgument: (ResolvedValueArgument..ResolvedValueArgument?) defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationArguments[LocalVariableDescriptor]

'value' @ [85:17] ==> val value: ConstantValue<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationArguments[LocalVariableDescriptor]

'arguments' @ [86:17] ==> val arguments: HashMap<Name, ConstantValue<*>> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationArguments[LocalVariableDescriptor]

'put' @ [86:27] ==> public open fun put(key: Name, value: ConstantValue<*>): ConstantValue<*>? defined in java.util.HashMap[JavaMethodDescriptor]

'parameterDescriptor' @ [86:31] ==> val parameterDescriptor: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationArguments[LocalVariableDescriptor]

'name' @ [86:51] ==> public final val ValueParameterDescriptor.name: Name[MyPropertyDescriptor]

'value' @ [86:57] ==> val value: ConstantValue<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationArguments[LocalVariableDescriptor]

'arguments' @ [89:16] ==> val arguments: HashMap<Name, ConstantValue<*>> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationArguments[LocalVariableDescriptor]

'parameterDescriptor' @ [97:33] ==> value-parameter parameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getAnnotationArgumentValue[ValueParameterDescriptorImpl]

'varargElementType' @ [97:53] ==> public abstract val varargElementType: KotlinType? defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'varargElementType' @ [98:33] ==> val varargElementType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getAnnotationArgumentValue[LocalVariableDescriptor]

'!' @ [98:62] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'hasSpread' @ [98:63] ==> private final fun hasSpread(argument: ResolvedValueArgument): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[SimpleFunctionDescriptorImpl]

'resolvedArgument' @ [98:73] ==> value-parameter resolvedArgument: ResolvedValueArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getAnnotationArgumentValue[ValueParameterDescriptorImpl]

'if (argumentsAsVararg) varargElementType else parameterDescriptor.type' @ [99:28] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType?, elseBranch: KotlinType?): KotlinType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType?

'argumentsAsVararg' @ [99:32] ==> val argumentsAsVararg: Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getAnnotationArgumentValue[LocalVariableDescriptor]

'varargElementType' @ [99:51] ==> val varargElementType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getAnnotationArgumentValue[LocalVariableDescriptor]

'parameterDescriptor' @ [99:74] ==> value-parameter parameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getAnnotationArgumentValue[ValueParameterDescriptorImpl]

'type' @ [99:94] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'resolveAnnotationValueArguments' @ [100:36] ==> private final fun resolveAnnotationValueArguments(resolvedValueArgument: ResolvedValueArgument, expectedType: KotlinType, trace: BindingTrace): List<CompileTimeConstant<*>> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[SimpleFunctionDescriptorImpl]

'resolvedArgument' @ [100:68] ==> value-parameter resolvedArgument: ResolvedValueArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getAnnotationArgumentValue[ValueParameterDescriptorImpl]

'constantType' @ [100:86] ==> val constantType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getAnnotationArgumentValue[LocalVariableDescriptor]

'trace' @ [100:102] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getAnnotationArgumentValue[ValueParameterDescriptorImpl]

'compileTimeConstants' @ [101:25] ==> val compileTimeConstants: List<CompileTimeConstant<*>> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getAnnotationArgumentValue[LocalVariableDescriptor]

'map' @ [101:46] ==> public inline fun <T, R> Iterable<CompileTimeConstant<*>>.map(transform: (CompileTimeConstant<*>) -> ConstantValue<Any?>): List<ConstantValue<Any?>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> CompileTimeConstant<*>
    <R> -> ConstantValue<Any?>

'it' @ [101:52] ==> value-parameter it: CompileTimeConstant<*> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getAnnotationArgumentValue.<anonymous>[ValueParameterDescriptorImpl]

'toConstantValue' @ [101:55] ==> public abstract fun toConstantValue(expectedType: KotlinType): ConstantValue<Any?> defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant[DeserializedSimpleFunctionDescriptor]

'constantType' @ [101:71] ==> val constantType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getAnnotationArgumentValue[LocalVariableDescriptor]

'if (argumentsAsVararg) {
            if (parameterDescriptor.declaresDefaultValue() && compileTimeConstants.isEmpty()) return null

            return constantValueFactory.createArrayValue(constants, parameterDescriptor.type)
        }
        else {
            // we should actually get only one element, but just in case of getting many, we take the last one
            return constants.lastOrNull()
        }' @ [103:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nothing, elseBranch: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nothing

'argumentsAsVararg' @ [103:13] ==> val argumentsAsVararg: Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getAnnotationArgumentValue[LocalVariableDescriptor]

'parameterDescriptor' @ [104:17] ==> value-parameter parameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getAnnotationArgumentValue[ValueParameterDescriptorImpl]

'declaresDefaultValue' @ [104:37] ==> public abstract fun declaresDefaultValue(): Boolean defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedSimpleFunctionDescriptor]

'compileTimeConstants' @ [104:63] ==> val compileTimeConstants: List<CompileTimeConstant<*>> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getAnnotationArgumentValue[LocalVariableDescriptor]

'isEmpty' @ [104:84] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'constantValueFactory' @ [106:20] ==> internal final val constantValueFactory: ConstantValueFactory defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[PropertyDescriptorImpl]

'createArrayValue' @ [106:41] ==> public final fun createArrayValue(value: List<ConstantValue<*>>, type: KotlinType): ArrayValue defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[DeserializedSimpleFunctionDescriptor]

'constants' @ [106:58] ==> val constants: List<ConstantValue<Any?>> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getAnnotationArgumentValue[LocalVariableDescriptor]

'parameterDescriptor' @ [106:69] ==> value-parameter parameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getAnnotationArgumentValue[ValueParameterDescriptorImpl]

'type' @ [106:89] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'constants' @ [110:20] ==> val constants: List<ConstantValue<Any?>> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getAnnotationArgumentValue[LocalVariableDescriptor]

'lastOrNull' @ [110:30] ==> public fun <T> List<ConstantValue<Any?>>.lastOrNull(): ConstantValue<Any?>? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ConstantValue<Any?>

'trace' @ [119:30] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'getType' @ [119:36] ==> @Nullable public abstract fun getType(@NotNull expression: KtExpression): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'argumentExpression' @ [119:44] ==> value-parameter argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'expressionType' @ [121:13] ==> val expressionType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[LocalVariableDescriptor]

'!' @ [121:39] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'DEFAULT' @ [121:58] ==> public final val DEFAULT: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaPropertyDescriptor]

'isSubtypeOf' @ [121:66] ==> public abstract fun isSubtypeOf(@NotNull p0: KotlinType, @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaMethodDescriptor]

'expressionType' @ [121:78] ==> val expressionType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[LocalVariableDescriptor]

'expectedType' @ [121:94] ==> value-parameter expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'argumentExpression' @ [127:13] ==> value-parameter argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'getArgumentExpressionsForArrayCall' @ [128:13] ==> private final fun getArgumentExpressionsForArrayCall(expression: KtCallExpression, trace: BindingTrace): Pair<List<KtExpression>, KotlinType?>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[SimpleFunctionDescriptorImpl]

'argumentExpression' @ [128:48] ==> value-parameter argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'trace' @ [128:68] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'let' @ [128:76] ==> @InlineOnly public inline fun <T, R> Pair<List<KtExpression>, KotlinType?>.let(block: (Pair<List<KtExpression>, KotlinType?>) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<List<KtExpression>, KotlinType?>
    <R> -> Unit

'checkArgumentsAreCompileTimeConstants' @ [128:82] ==> private final fun checkArgumentsAreCompileTimeConstants(argumentsWithComponentType: Pair<List<KtExpression>, KotlinType?>, trace: BindingTrace): Unit defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[SimpleFunctionDescriptorImpl]

'it' @ [128:120] ==> value-parameter it: Pair<List<KtExpression>, KotlinType?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant.<anonymous>[ValueParameterDescriptorImpl]

'trace' @ [128:124] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'argumentExpression' @ [130:13] ==> value-parameter argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'getArgumentExpressionsForCollectionLiteralCall' @ [131:13] ==> private final fun getArgumentExpressionsForCollectionLiteralCall(expression: KtCollectionLiteralExpression, trace: BindingTrace): Pair<List<KtExpression>, KotlinType?>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[SimpleFunctionDescriptorImpl]

'argumentExpression' @ [131:60] ==> value-parameter argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'trace' @ [131:80] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'let' @ [131:88] ==> @InlineOnly public inline fun <T, R> Pair<List<KtExpression>, KotlinType?>.let(block: (Pair<List<KtExpression>, KotlinType?>) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<List<KtExpression>, KotlinType?>
    <R> -> Unit

'checkArgumentsAreCompileTimeConstants' @ [131:94] ==> private final fun checkArgumentsAreCompileTimeConstants(argumentsWithComponentType: Pair<List<KtExpression>, KotlinType?>, trace: BindingTrace): Unit defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[SimpleFunctionDescriptorImpl]

'it' @ [131:132] ==> value-parameter it: Pair<List<KtExpression>, KotlinType?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant.<anonymous>[ValueParameterDescriptorImpl]

'trace' @ [131:136] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'ConstantExpressionEvaluator' @ [134:24] ==> public companion object defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[FakeCallableDescriptorForObject]

'getConstant' @ [134:52] ==> @JvmStatic public final fun getConstant(expression: KtExpression, bindingContext: BindingContext): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.Companion[SimpleFunctionDescriptorImpl]

'argumentExpression' @ [134:64] ==> value-parameter argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'trace' @ [134:84] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'bindingContext' @ [134:90] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'constant' @ [135:13] ==> val constant: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[LocalVariableDescriptor]

'constant' @ [135:33] ==> val constant: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[LocalVariableDescriptor]

'canBeUsedInAnnotations' @ [135:42] ==> public open val canBeUsedInAnnotations: Boolean defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant[DeserializedPropertyDescriptor]

'constant' @ [136:17] ==> val constant: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[LocalVariableDescriptor]

'usesNonConstValAsConstant' @ [136:26] ==> public open val usesNonConstValAsConstant: Boolean defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant[DeserializedPropertyDescriptor]

'trace' @ [137:17] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'report' @ [137:23] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION' @ [137:37] ==> public final val NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION: (DiagnosticFactory0<(KtExpression..KtExpression?)>..DiagnosticFactory0<(KtExpression..KtExpression?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [137:79] ==> @NotNull public open fun on(@NotNull element: KtExpression): SimpleDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'argumentExpression' @ [137:82] ==> value-parameter argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'argumentExpression' @ [140:17] ==> value-parameter argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'argumentExpression' @ [141:37] ==> value-parameter argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'receiverExpression' @ [141:56] ==> public final val receiverExpression: KtExpression? defined in org.jetbrains.kotlin.psi.KtClassLiteralExpression[PropertyDescriptorImpl]

'lhsExpression' @ [142:21] ==> val lhsExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[LocalVariableDescriptor]

'trace' @ [143:42] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'bindingContext' @ [143:48] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'get' @ [143:63] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(slice: (ReadOnlySlice<(KtExpression..KtExpression?), (DoubleColonLHS..DoubleColonLHS?)>..ReadOnlySlice<(KtExpression..KtExpression?), (DoubleColonLHS..DoubleColonLHS?)>?), key: (KtExpression..KtExpression?)): DoubleColonLHS? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> KtExpression
    <V : (Any..Any?)> -> DoubleColonLHS

'DOUBLE_COLON_LHS' @ [143:82] ==> public final val DOUBLE_COLON_LHS: (WritableSlice<(KtExpression..KtExpression?), (DoubleColonLHS..DoubleColonLHS?)>..WritableSlice<(KtExpression..KtExpression?), (DoubleColonLHS..DoubleColonLHS?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'lhsExpression' @ [143:100] ==> val lhsExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[LocalVariableDescriptor]

'doubleColonLhs' @ [144:25] ==> val doubleColonLhs: DoubleColonLHS? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[LocalVariableDescriptor]

'!' @ [144:72] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'doubleColonLhs' @ [144:73] ==> val doubleColonLhs: DoubleColonLHS? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[LocalVariableDescriptor]

'isObjectQualifier' @ [144:88] ==> public final val isObjectQualifier: Boolean defined in org.jetbrains.kotlin.types.expressions.DoubleColonLHS.Expression[PropertyDescriptorImpl]

'trace' @ [145:25] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'report' @ [145:31] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'ANNOTATION_PARAMETER_MUST_BE_KCLASS_LITERAL' @ [145:45] ==> public final val ANNOTATION_PARAMETER_MUST_BE_KCLASS_LITERAL: (DiagnosticFactory0<(KtExpression..KtExpression?)>..DiagnosticFactory0<(KtExpression..KtExpression?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [145:89] ==> @NotNull public open fun on(@NotNull element: KtExpression): SimpleDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'argumentExpression' @ [145:92] ==> value-parameter argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'expressionType' @ [153:26] ==> val expressionType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[LocalVariableDescriptor]

'constructor' @ [153:41] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'declarationDescriptor' @ [153:53] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'if (descriptor != null && DescriptorUtils.isEnumClass(descriptor)) {
            trace.report(Errors.ANNOTATION_PARAMETER_MUST_BE_ENUM_CONST.on(argumentExpression))
        }
        else if (descriptor is ClassDescriptor && KotlinBuiltIns.isKClass(descriptor)) {
            trace.report(Errors.ANNOTATION_PARAMETER_MUST_BE_KCLASS_LITERAL.on(argumentExpression))
        }
        else {
            trace.report(Errors.ANNOTATION_PARAMETER_MUST_BE_CONST.on(argumentExpression))
        }' @ [154:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'descriptor' @ [154:13] ==> val descriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[LocalVariableDescriptor]

'isEnumClass' @ [154:51] ==> public open fun isEnumClass(@Nullable p0: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'descriptor' @ [154:63] ==> val descriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[LocalVariableDescriptor]

'trace' @ [155:13] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'report' @ [155:19] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'ANNOTATION_PARAMETER_MUST_BE_ENUM_CONST' @ [155:33] ==> public final val ANNOTATION_PARAMETER_MUST_BE_ENUM_CONST: (DiagnosticFactory0<(KtExpression..KtExpression?)>..DiagnosticFactory0<(KtExpression..KtExpression?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [155:73] ==> @NotNull public open fun on(@NotNull element: KtExpression): SimpleDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'argumentExpression' @ [155:76] ==> value-parameter argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'if (descriptor is ClassDescriptor && KotlinBuiltIns.isKClass(descriptor)) {
            trace.report(Errors.ANNOTATION_PARAMETER_MUST_BE_KCLASS_LITERAL.on(argumentExpression))
        }
        else {
            trace.report(Errors.ANNOTATION_PARAMETER_MUST_BE_CONST.on(argumentExpression))
        }' @ [157:14] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'descriptor' @ [157:18] ==> val descriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[LocalVariableDescriptor]

'isKClass' @ [157:66] ==> public open fun isKClass(@NotNull p0: ClassDescriptor): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'descriptor' @ [157:75] ==> val descriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[LocalVariableDescriptor]

'trace' @ [158:13] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'report' @ [158:19] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'ANNOTATION_PARAMETER_MUST_BE_KCLASS_LITERAL' @ [158:33] ==> public final val ANNOTATION_PARAMETER_MUST_BE_KCLASS_LITERAL: (DiagnosticFactory0<(KtExpression..KtExpression?)>..DiagnosticFactory0<(KtExpression..KtExpression?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [158:77] ==> @NotNull public open fun on(@NotNull element: KtExpression): SimpleDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'argumentExpression' @ [158:80] ==> value-parameter argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'trace' @ [161:13] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'report' @ [161:19] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'ANNOTATION_PARAMETER_MUST_BE_CONST' @ [161:33] ==> public final val ANNOTATION_PARAMETER_MUST_BE_CONST: (DiagnosticFactory0<(KtExpression..KtExpression?)>..DiagnosticFactory0<(KtExpression..KtExpression?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [161:68] ==> @NotNull public open fun on(@NotNull element: KtExpression): SimpleDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'argumentExpression' @ [161:71] ==> value-parameter argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkCompileTimeConstant[ValueParameterDescriptorImpl]

'component1' @ [166:14] ==> public final operator fun component1(): List<KtExpression> defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [166:25] ==> public final operator fun component2(): KotlinType? defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'argumentsWithComponentType' @ [166:42] ==> value-parameter argumentsWithComponentType: Pair<List<KtExpression>, KotlinType?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkArgumentsAreCompileTimeConstants[ValueParameterDescriptorImpl]

'arguments' @ [167:28] ==> val arguments: List<KtExpression> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkArgumentsAreCompileTimeConstants[LocalVariableDescriptor]

'checkCompileTimeConstant' @ [168:13] ==> private final fun checkCompileTimeConstant(argumentExpression: KtExpression, expectedType: KotlinType, trace: BindingTrace): Unit defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[SimpleFunctionDescriptorImpl]

'expression' @ [168:38] ==> val expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkArgumentsAreCompileTimeConstants[LocalVariableDescriptor]

'componentType' @ [168:50] ==> val componentType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkArgumentsAreCompileTimeConstants[LocalVariableDescriptor]

'trace' @ [168:67] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.checkArgumentsAreCompileTimeConstants[ValueParameterDescriptorImpl]

'expression' @ [176:28] ==> value-parameter expression: KtCallExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getArgumentExpressionsForArrayCall[ValueParameterDescriptorImpl]

'getResolvedCall' @ [176:39] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[SimpleFunctionDescriptorImpl]

'trace' @ [176:55] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getArgumentExpressionsForArrayCall[ValueParameterDescriptorImpl]

'bindingContext' @ [176:61] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'getArgumentExpressionsForArrayLikeCall' @ [177:16] ==> private final fun getArgumentExpressionsForArrayLikeCall(resolvedCall: ResolvedCall<*>): Pair<List<KtExpression>, KotlinType>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[SimpleFunctionDescriptorImpl]

'resolvedCall' @ [177:55] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getArgumentExpressionsForArrayCall[LocalVariableDescriptor]

'trace' @ [183:28] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getArgumentExpressionsForCollectionLiteralCall[ValueParameterDescriptorImpl]

'COLLECTION_LITERAL_CALL' @ [183:34] ==> public final val COLLECTION_LITERAL_CALL: (WritableSlice<(KtCollectionLiteralExpression..KtCollectionLiteralExpression?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>..WritableSlice<(KtCollectionLiteralExpression..KtCollectionLiteralExpression?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'expression' @ [183:59] ==> value-parameter expression: KtCollectionLiteralExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getArgumentExpressionsForCollectionLiteralCall[ValueParameterDescriptorImpl]

'getArgumentExpressionsForArrayLikeCall' @ [184:16] ==> private final fun getArgumentExpressionsForArrayLikeCall(resolvedCall: ResolvedCall<*>): Pair<List<KtExpression>, KotlinType>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[SimpleFunctionDescriptorImpl]

'resolvedCall' @ [184:55] ==> val resolvedCall: ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getArgumentExpressionsForCollectionLiteralCall[LocalVariableDescriptor]

'!' @ [188:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isArrayFunctionCall' @ [188:39] ==> public open fun isArrayFunctionCall(@NotNull resolvedCall: ResolvedCall<*>): Boolean defined in org.jetbrains.kotlin.resolve.CompileTimeConstantUtils[JavaMethodDescriptor]

'resolvedCall' @ [188:59] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getArgumentExpressionsForArrayLikeCall[ValueParameterDescriptorImpl]

'resolvedCall' @ [192:26] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getArgumentExpressionsForArrayLikeCall[ValueParameterDescriptorImpl]

'resultingDescriptor' @ [192:39] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.resultingDescriptor: (CallableDescriptor..CallableDescriptor?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'returnType' @ [192:59] ==> public final val CallableDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'builtIns' @ [193:29] ==> internal final val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[PropertyDescriptorImpl]

'getArrayElementType' @ [193:38] ==> @NotNull public open fun getArrayElementType(@NotNull p0: KotlinType): KotlinType defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'returnType' @ [193:58] ==> val returnType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getArgumentExpressionsForArrayLikeCall[LocalVariableDescriptor]

'arrayListOf' @ [195:22] ==> @SinceKotlin @InlineOnly public inline fun <T> arrayListOf(): ArrayList<KtExpression> /* = ArrayList<KtExpression> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'component1' @ [196:15] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>.component1(): (ValueParameterDescriptor..ValueParameterDescriptor?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)
    <V> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument..org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument?)

'component2' @ [196:18] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>.component2(): (ResolvedValueArgument..ResolvedValueArgument?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)
    <V> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument..org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument?)

'resolvedCall' @ [196:44] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getArgumentExpressionsForArrayLikeCall[ValueParameterDescriptorImpl]

'valueArguments' @ [196:57] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.valueArguments: (MutableMap<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>..Map<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'resolvedValueArgument' @ [197:35] ==> val resolvedValueArgument: (ResolvedValueArgument..ResolvedValueArgument?) defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getArgumentExpressionsForArrayLikeCall[LocalVariableDescriptor]

'arguments' @ [197:57] ==> public final val ResolvedValueArgument.arguments: (MutableList<(ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>)[MyPropertyDescriptor]

'valueArgument' @ [198:47] ==> val valueArgument: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getArgumentExpressionsForArrayLikeCall[LocalVariableDescriptor]

'getArgumentExpression' @ [198:61] ==> @IfNotParsed public abstract fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.ValueArgument[SimpleFunctionDescriptorImpl]

'valueArgumentExpression' @ [199:21] ==> val valueArgumentExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getArgumentExpressionsForArrayLikeCall[LocalVariableDescriptor]

'result' @ [200:21] ==> val result: ArrayList<KtExpression> /* = ArrayList<KtExpression> */ defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getArgumentExpressionsForArrayLikeCall[LocalVariableDescriptor]

'add' @ [200:28] ==> public open fun add(element: KtExpression): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'valueArgumentExpression' @ [200:32] ==> val valueArgumentExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getArgumentExpressionsForArrayLikeCall[LocalVariableDescriptor]

'Pair' @ [205:16] ==> public constructor Pair<out A, out B>(first: List<KtExpression>, second: KotlinType) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> List<KtExpression>
    <out B> -> KotlinType

'result' @ [205:53] ==> val result: ArrayList<KtExpression> /* = ArrayList<KtExpression> */ defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getArgumentExpressionsForArrayLikeCall[LocalVariableDescriptor]

'componentType' @ [205:61] ==> val componentType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.getArgumentExpressionsForArrayLikeCall[LocalVariableDescriptor]

'argument' @ [209:25] ==> value-parameter argument: ResolvedValueArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.hasSpread[ValueParameterDescriptorImpl]

'arguments' @ [209:34] ==> public final val ResolvedValueArgument.arguments: (MutableList<(ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>)[MyPropertyDescriptor]

'arguments' @ [210:16] ==> val arguments: (MutableList<(ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>) defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.hasSpread[LocalVariableDescriptor]

'size' @ [210:26] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'arguments' @ [210:39] ==> val arguments: (MutableList<(ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>) defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.hasSpread[LocalVariableDescriptor]

'getSpreadElement' @ [210:52] ==> public abstract fun getSpreadElement(): LeafPsiElement? defined in org.jetbrains.kotlin.psi.ValueArgument[SimpleFunctionDescriptorImpl]

'ArrayList' @ [217:25] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> CompileTimeConstant<*>

'resolvedValueArgument' @ [218:26] ==> value-parameter resolvedValueArgument: ResolvedValueArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationValueArguments[ValueParameterDescriptorImpl]

'arguments' @ [218:48] ==> public final val ResolvedValueArgument.arguments: (MutableList<(ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>)[MyPropertyDescriptor]

'argument' @ [219:38] ==> val argument: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationValueArguments[LocalVariableDescriptor]

'getArgumentExpression' @ [219:47] ==> @IfNotParsed public abstract fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.ValueArgument[SimpleFunctionDescriptorImpl]

'evaluateExpression' @ [220:28] ==> public final fun evaluateExpression(expression: KtExpression, trace: BindingTrace, expectedType: KotlinType? = ...): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[SimpleFunctionDescriptorImpl]

'argumentExpression' @ [220:47] ==> val argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationValueArguments[LocalVariableDescriptor]

'trace' @ [220:67] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationValueArguments[ValueParameterDescriptorImpl]

'expectedType' @ [220:74] ==> value-parameter expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationValueArguments[ValueParameterDescriptorImpl]

'constant' @ [221:17] ==> val constant: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationValueArguments[LocalVariableDescriptor]

'constant' @ [222:35] ==> val constant: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationValueArguments[LocalVariableDescriptor]

'getType' @ [222:44] ==> public final fun getType(expectedType: KotlinType): KotlinType defined in org.jetbrains.kotlin.resolve.constants.IntegerValueTypeConstant[DeserializedSimpleFunctionDescriptor]

'expectedType' @ [222:52] ==> value-parameter expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationValueArguments[ValueParameterDescriptorImpl]

'updateNumberType' @ [223:17] ==> public final fun updateNumberType(numberType: KotlinType, expression: KtExpression?, statementFilter: StatementFilter, trace: BindingTrace): Unit defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[SimpleFunctionDescriptorImpl]

'defaultType' @ [223:34] ==> val defaultType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationValueArguments[LocalVariableDescriptor]

'argumentExpression' @ [223:47] ==> val argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationValueArguments[LocalVariableDescriptor]

'StatementFilter' @ [223:67] ==> public companion object defined in org.jetbrains.kotlin.resolve.StatementFilter[FakeCallableDescriptorForObject]

'NONE' @ [223:83] ==> @JvmField public final val NONE: StatementFilter defined in org.jetbrains.kotlin.resolve.StatementFilter.Companion[PropertyDescriptorImpl]

'trace' @ [223:89] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationValueArguments[ValueParameterDescriptorImpl]

'constant' @ [225:17] ==> val constant: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationValueArguments[LocalVariableDescriptor]

'constants' @ [226:17] ==> val constants: ArrayList<CompileTimeConstant<*>> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationValueArguments[LocalVariableDescriptor]

'add' @ [226:27] ==> public open fun add(element: CompileTimeConstant<*>): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'constant' @ [226:31] ==> val constant: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationValueArguments[LocalVariableDescriptor]

'checkCompileTimeConstant' @ [228:13] ==> private final fun checkCompileTimeConstant(argumentExpression: KtExpression, expectedType: KotlinType, trace: BindingTrace): Unit defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[SimpleFunctionDescriptorImpl]

'argumentExpression' @ [228:38] ==> val argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationValueArguments[LocalVariableDescriptor]

'expectedType' @ [228:58] ==> value-parameter expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationValueArguments[ValueParameterDescriptorImpl]

'trace' @ [228:72] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationValueArguments[ValueParameterDescriptorImpl]

'constants' @ [230:16] ==> val constants: ArrayList<CompileTimeConstant<*>> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.resolveAnnotationValueArguments[LocalVariableDescriptor]

'NO_EXPECTED_TYPE' @ [236:51] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'ConstantExpressionEvaluatorVisitor' @ [238:23] ==> public constructor ConstantExpressionEvaluatorVisitor(constantExpressionEvaluator: ConstantExpressionEvaluator, trace: BindingTrace) defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[ClassConstructorDescriptorImpl]

'this' @ [238:58] ==> <this> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[LazyClassReceiverParameterDescriptor]

'trace' @ [238:64] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.evaluateExpression[ValueParameterDescriptorImpl]

'visitor' @ [239:24] ==> val visitor: ConstantExpressionEvaluatorVisitor defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.evaluateExpression[LocalVariableDescriptor]

'evaluate' @ [239:32] ==> public final fun evaluate(expression: KtExpression, expectedType: KotlinType?): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'expression' @ [239:41] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.evaluateExpression[ValueParameterDescriptorImpl]

'expectedType' @ [239:53] ==> value-parameter expectedType: KotlinType? = ... defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.evaluateExpression[ValueParameterDescriptorImpl]

'if (!constant.isError) constant else null' @ [241:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: CompileTimeConstant<*>?, elseBranch: CompileTimeConstant<*>?): CompileTimeConstant<*>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> CompileTimeConstant<*>?

'!' @ [241:20] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'constant' @ [241:21] ==> val constant: CompileTimeConstant<Any?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.evaluateExpression[LocalVariableDescriptor]

'isError' @ [241:30] ==> public open val isError: Boolean defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant[DeserializedPropertyDescriptor]

'constant' @ [241:39] ==> val constant: CompileTimeConstant<Any?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.evaluateExpression[LocalVariableDescriptor]

'evaluateExpression' @ [249:16] ==> public final fun evaluateExpression(expression: KtExpression, trace: BindingTrace, expectedType: KotlinType? = ...): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[SimpleFunctionDescriptorImpl]

'expression' @ [249:35] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.evaluateToConstantValue[ValueParameterDescriptorImpl]

'trace' @ [249:47] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.evaluateToConstantValue[ValueParameterDescriptorImpl]

'expectedType' @ [249:54] ==> value-parameter expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.evaluateToConstantValue[ValueParameterDescriptorImpl]

'toConstantValue' @ [249:69] ==> public abstract fun toConstantValue(expectedType: KotlinType): ConstantValue<Any?> defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant[DeserializedSimpleFunctionDescriptor]

'expectedType' @ [249:85] ==> value-parameter expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.evaluateToConstantValue[ValueParameterDescriptorImpl]

'JvmStatic' @ [254:9] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'getPossiblyErrorConstant' @ [255:28] ==> @JvmStatic public final fun getPossiblyErrorConstant(expression: KtExpression, bindingContext: BindingContext): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.Companion[SimpleFunctionDescriptorImpl]

'expression' @ [255:53] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.Companion.getConstant[ValueParameterDescriptorImpl]

'bindingContext' @ [255:65] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.Companion.getConstant[ValueParameterDescriptorImpl]

'if (!constant.isError) constant else null' @ [256:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: CompileTimeConstant<*>?, elseBranch: CompileTimeConstant<*>?): CompileTimeConstant<*>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> CompileTimeConstant<*>?

'!' @ [256:24] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'constant' @ [256:25] ==> val constant: CompileTimeConstant<Any?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.Companion.getConstant[LocalVariableDescriptor]

'isError' @ [256:34] ==> public open val isError: Boolean defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant[DeserializedPropertyDescriptor]

'constant' @ [256:43] ==> val constant: CompileTimeConstant<Any?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.Companion.getConstant[LocalVariableDescriptor]

'JvmStatic' @ [259:9] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'bindingContext' @ [261:20] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.Companion.getPossiblyErrorConstant[ValueParameterDescriptorImpl]

'get' @ [261:35] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(slice: (ReadOnlySlice<(KtExpression..KtExpression?), (CompileTimeConstant<*>..CompileTimeConstant<*>?)>..ReadOnlySlice<(KtExpression..KtExpression?), (CompileTimeConstant<*>..CompileTimeConstant<*>?)>?), key: (KtExpression..KtExpression?)): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> KtExpression
    <V : (Any..Any?)> -> CompileTimeConstant<*>

'COMPILE_TIME_VALUE' @ [261:54] ==> public final val COMPILE_TIME_VALUE: (WritableSlice<(KtExpression..KtExpression?), (CompileTimeConstant<*>..CompileTimeConstant<*>?)>..WritableSlice<(KtExpression..KtExpression?), (CompileTimeConstant<*>..CompileTimeConstant<*>?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'expression' @ [261:74] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.Companion.getPossiblyErrorConstant[ValueParameterDescriptorImpl]

'listOf' @ [267:9] ==> public fun <T> listOf(vararg elements: Name): List<Name> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Name

'OperatorNameConventions' @ [267:16] ==> public object OperatorNameConventions defined in org.jetbrains.kotlin.util[FakeCallableDescriptorForObject]

'DIV' @ [267:40] ==> @field:JvmField public final val DIV: Name defined in org.jetbrains.kotlin.util.OperatorNameConventions[DeserializedPropertyDescriptor]

'OperatorNameConventions' @ [267:45] ==> public object OperatorNameConventions defined in org.jetbrains.kotlin.util[FakeCallableDescriptorForObject]

'REM' @ [267:69] ==> @field:JvmField public final val REM: Name defined in org.jetbrains.kotlin.util.OperatorNameConventions[DeserializedPropertyDescriptor]

'OperatorNameConventions' @ [267:74] ==> public object OperatorNameConventions defined in org.jetbrains.kotlin.util[FakeCallableDescriptorForObject]

'MOD' @ [267:98] ==> @field:JvmField public final val MOD: Name defined in org.jetbrains.kotlin.util.OperatorNameConventions[DeserializedPropertyDescriptor]

'map' @ [268:18] ==> public inline fun <T, R> Iterable<Name>.map(transform: (Name) -> String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Name
    <R> -> String

'Name' @ [268:22] ==> private constructor Name(@NotNull p0: String, p1: Boolean) defined in org.jetbrains.kotlin.name.Name[JavaClassConstructorDescriptor]

'toSet' @ [269:18] ==> public fun <T> Iterable<String>.toSet(): Set<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'KtVisitor<CompileTimeConstant<*>?, KotlinType>' @ [274:5] ==> public constructor KtVisitor<R : (Any..Any?), D : (Any..Any?)>() defined in org.jetbrains.kotlin.psi.KtVisitor[JavaClassConstructorDescriptor]
Inferred types:
    <R : (Any..Any?)> -> CompileTimeConstant<*>?
    <D : (Any..Any?)> -> KotlinType

'constantExpressionEvaluator' @ [276:27] ==> private final val constantExpressionEvaluator: ConstantExpressionEvaluator defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'constantValueFactory' @ [276:55] ==> internal final val constantValueFactory: ConstantValueFactory defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[PropertyDescriptorImpl]

'ConstantExpressionEvaluator' @ [279:43] ==> public companion object defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[FakeCallableDescriptorForObject]

'getPossiblyErrorConstant' @ [279:71] ==> @JvmStatic public final fun getPossiblyErrorConstant(expression: KtExpression, bindingContext: BindingContext): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.Companion[SimpleFunctionDescriptorImpl]

'expression' @ [279:96] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluate[ValueParameterDescriptorImpl]

'trace' @ [279:108] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'bindingContext' @ [279:114] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'recordedCompileTimeConstant' @ [280:13] ==> val recordedCompileTimeConstant: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluate[LocalVariableDescriptor]

'recordedCompileTimeConstant' @ [281:20] ==> val recordedCompileTimeConstant: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluate[LocalVariableDescriptor]

'expression' @ [284:35] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluate[ValueParameterDescriptorImpl]

'accept' @ [284:46] ==> @Override public abstract fun <R : (Any..Any?), D : (Any..Any?)> accept(@NotNull visitor: KtVisitor<CompileTimeConstant<*>?, KotlinType>, data: KotlinType): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.psi.KtExpression[JavaMethodDescriptor]
Inferred types:
    <R : (Any..Any?)> -> CompileTimeConstant<*>?
    <D : (Any..Any?)> -> KotlinType

'this' @ [284:53] ==> <this> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[LazyClassReceiverParameterDescriptor]

'expectedType' @ [284:59] ==> value-parameter expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluate[ValueParameterDescriptorImpl]

'NO_EXPECTED_TYPE' @ [284:85] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'compileTimeConstant' @ [285:13] ==> val compileTimeConstant: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluate[LocalVariableDescriptor]

'trace' @ [286:13] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'record' @ [286:19] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(KtExpression..KtExpression?), (CompileTimeConstant<*>..CompileTimeConstant<*>?)>..WritableSlice<(KtExpression..KtExpression?), (CompileTimeConstant<*>..CompileTimeConstant<*>?)>?), key: (KtExpression..KtExpression?), value: (CompileTimeConstant<*>..CompileTimeConstant<*>?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> KtExpression
    <V : (Any..Any?)> -> CompileTimeConstant<*>

'COMPILE_TIME_VALUE' @ [286:41] ==> public final val COMPILE_TIME_VALUE: (WritableSlice<(KtExpression..KtExpression?), (CompileTimeConstant<*>..CompileTimeConstant<*>?)>..WritableSlice<(KtExpression..KtExpression?), (CompileTimeConstant<*>..CompileTimeConstant<*>?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'expression' @ [286:61] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluate[ValueParameterDescriptorImpl]

'compileTimeConstant' @ [286:73] ==> val compileTimeConstant: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluate[LocalVariableDescriptor]

'compileTimeConstant' @ [287:20] ==> val compileTimeConstant: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluate[LocalVariableDescriptor]

'KtVisitor<TypedCompileTimeConstant<String>, Nothing?>' @ [292:54] ==> public constructor KtVisitor<R : (Any..Any?), D : (Any..Any?)>() defined in org.jetbrains.kotlin.psi.KtVisitor[JavaClassConstructorDescriptor]
Inferred types:
    <R : (Any..Any?)> -> TypedCompileTimeConstant<String>
    <D : (Any..Any?)> -> Nothing?

'compileTimeConstant' @ [294:33] ==> value-parameter compileTimeConstant: CompileTimeConstant<*> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.stringExpressionEvaluator.<no name provided>.createStringConstant[ValueParameterDescriptorImpl]

'toConstantValue' @ [294:53] ==> public abstract fun toConstantValue(expectedType: KotlinType): ConstantValue<Any?> defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant[DeserializedSimpleFunctionDescriptor]

'NO_EXPECTED_TYPE' @ [294:79] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'constantValue' @ [295:17] ==> val constantValue: ConstantValue<Any?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.stringExpressionEvaluator.<no name provided>.createStringConstant[LocalVariableDescriptor]

'isStandaloneOnlyConstant' @ [295:31] ==> public fun ConstantValue<*>.isStandaloneOnlyConstant(): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate in file ConstantExpressionEvaluator.kt[SimpleFunctionDescriptorImpl]

'when (constantValue) {
                is ErrorValue, is EnumValue -> return null
                is NullValue -> factory.createStringValue("null")
                else -> factory.createStringValue(constantValue.value.toString())
            }' @ [298:20] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: StringValue, entry1: StringValue, entry2: StringValue): StringValue[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> StringValue

'constantValue' @ [298:26] ==> val constantValue: ConstantValue<Any?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.stringExpressionEvaluator.<no name provided>.createStringConstant[LocalVariableDescriptor]

'factory' @ [300:33] ==> private final val factory: ConstantValueFactory defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'createStringValue' @ [300:41] ==> public final fun createStringValue(value: String): StringValue defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[DeserializedSimpleFunctionDescriptor]

'factory' @ [301:25] ==> private final val factory: ConstantValueFactory defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'createStringValue' @ [301:33] ==> public final fun createStringValue(value: String): StringValue defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[DeserializedSimpleFunctionDescriptor]

'constantValue' @ [301:51] ==> val constantValue: ConstantValue<Any?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.stringExpressionEvaluator.<no name provided>.createStringConstant[LocalVariableDescriptor]

'value' @ [301:65] ==> public open val value: Any? defined in org.jetbrains.kotlin.resolve.constants.ConstantValue[DeserializedPropertyDescriptor]

'toString' @ [301:71] ==> public fun Any?.toString(): String defined in kotlin[DeserializedSimpleFunctionDescriptor]

'wrap' @ [302:15] ==> private final fun <T> ConstantValue<String>.wrap(parameters: CompileTimeConstant.Parameters): TypedCompileTimeConstant<String> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> String

'compileTimeConstant' @ [302:20] ==> value-parameter compileTimeConstant: CompileTimeConstant<*> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.stringExpressionEvaluator.<no name provided>.createStringConstant[ValueParameterDescriptorImpl]

'parameters' @ [302:40] ==> public abstract val parameters: CompileTimeConstant.Parameters defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant[DeserializedPropertyDescriptor]

'entry' @ [306:20] ==> value-parameter entry: KtStringTemplateEntry defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.stringExpressionEvaluator.<no name provided>.evaluate[ValueParameterDescriptorImpl]

'accept' @ [306:26] ==> @Override public open fun <R : (Any..Any?), D : (Any..Any?)> accept(@NotNull visitor: KtVisitor<TypedCompileTimeConstant<String>, Nothing?>, data: Nothing?): TypedCompileTimeConstant<String> defined in org.jetbrains.kotlin.psi.KtStringTemplateEntry[JavaMethodDescriptor]
Inferred types:
    <R : (Any..Any?)> -> TypedCompileTimeConstant<String>
    <D : (Any..Any?)> -> Nothing?

'this' @ [306:33] ==> <this> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.stringExpressionEvaluator.<no name provided>[LazyClassReceiverParameterDescriptor]

'entry' @ [310:30] ==> value-parameter entry: KtStringTemplateEntryWithExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.stringExpressionEvaluator.<no name provided>.visitStringTemplateEntryWithExpression[ValueParameterDescriptorImpl]

'expression' @ [310:36] ==> public final val KtStringTemplateEntryWithExpression.expression: KtExpression?[MyPropertyDescriptor]

'evaluate' @ [312:20] ==> public final fun evaluate(expression: KtExpression, expectedType: KotlinType?): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'expression' @ [312:29] ==> val expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.stringExpressionEvaluator.<no name provided>.visitStringTemplateEntryWithExpression[LocalVariableDescriptor]

'constantExpressionEvaluator' @ [312:41] ==> private final val constantExpressionEvaluator: ConstantExpressionEvaluator defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'builtIns' @ [312:69] ==> internal final val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[PropertyDescriptorImpl]

'stringType' @ [312:78] ==> public final val KotlinBuiltIns.stringType: SimpleType[MyPropertyDescriptor]

'let' @ [312:91] ==> @InlineOnly public inline fun <T, R> CompileTimeConstant<Any?>.let(block: (CompileTimeConstant<Any?>) -> TypedCompileTimeConstant<String>?): TypedCompileTimeConstant<String>? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> CompileTimeConstant<Any?>
    <R> -> TypedCompileTimeConstant<String>?

'createStringConstant' @ [313:17] ==> private final fun createStringConstant(compileTimeConstant: CompileTimeConstant<*>): TypedCompileTimeConstant<String>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.stringExpressionEvaluator.<no name provided>[SimpleFunctionDescriptorImpl]

'it' @ [313:38] ==> value-parameter it: CompileTimeConstant<Any?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.stringExpressionEvaluator.<no name provided>.visitStringTemplateEntryWithExpression.<anonymous>[ValueParameterDescriptorImpl]

'factory' @ [317:109] ==> private final val factory: ConstantValueFactory defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'createStringValue' @ [317:117] ==> public final fun createStringValue(value: String): StringValue defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[DeserializedSimpleFunctionDescriptor]

'entry' @ [317:135] ==> value-parameter entry: KtLiteralStringTemplateEntry defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.stringExpressionEvaluator.<no name provided>.visitLiteralStringTemplateEntry[ValueParameterDescriptorImpl]

'text' @ [317:141] ==> public final val KtLiteralStringTemplateEntry.text: (String..String?)[MyPropertyDescriptor]

'wrap' @ [317:147] ==> private final fun <T> ConstantValue<String>.wrap(canBeUsedInAnnotation: Boolean = ..., isPure: Boolean = ..., usesVariableAsConstant: Boolean = ..., usesNonConstValAsConstant: Boolean = ...): TypedCompileTimeConstant<String> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> String

'factory' @ [319:107] ==> private final val factory: ConstantValueFactory defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'createStringValue' @ [319:115] ==> public final fun createStringValue(value: String): StringValue defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[DeserializedSimpleFunctionDescriptor]

'entry' @ [319:133] ==> value-parameter entry: KtEscapeStringTemplateEntry defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.stringExpressionEvaluator.<no name provided>.visitEscapeStringTemplateEntry[ValueParameterDescriptorImpl]

'unescapedValue' @ [319:139] ==> public final val KtEscapeStringTemplateEntry.unescapedValue: (String..String?)[MyPropertyDescriptor]

'wrap' @ [319:155] ==> private final fun <T> ConstantValue<String>.wrap(canBeUsedInAnnotation: Boolean = ..., isPure: Boolean = ..., usesVariableAsConstant: Boolean = ..., usesNonConstValAsConstant: Boolean = ...): TypedCompileTimeConstant<String> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> String

'expression' @ [323:20] ==> value-parameter expression: KtConstantExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[ValueParameterDescriptorImpl]

'text' @ [323:31] ==> public final val KtConstantExpression.text: (String..String?)[MyPropertyDescriptor]

'expression' @ [325:31] ==> value-parameter expression: KtConstantExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[ValueParameterDescriptorImpl]

'node' @ [325:42] ==> public final val KtConstantExpression.node: ASTNode[MyPropertyDescriptor]

'elementType' @ [325:47] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'nodeElementType' @ [326:13] ==> val nodeElementType: IElementType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[LocalVariableDescriptor]

'NULL' @ [326:44] ==> public final val NULL: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'factory' @ [326:57] ==> private final val factory: ConstantValueFactory defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'createNullValue' @ [326:65] ==> public final fun createNullValue(): NullValue defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[DeserializedSimpleFunctionDescriptor]

'wrap' @ [326:83] ==> private final fun <T> ConstantValue<Void?>.wrap(canBeUsedInAnnotation: Boolean = ..., isPure: Boolean = ..., usesVariableAsConstant: Boolean = ..., usesNonConstValAsConstant: Boolean = ...): TypedCompileTimeConstant<Void?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> Void?

'when (nodeElementType) {
                               KtNodeTypes.INTEGER_CONSTANT, KtNodeTypes.FLOAT_CONSTANT -> parseNumericLiteral(text, nodeElementType)
                               KtNodeTypes.BOOLEAN_CONSTANT -> parseBoolean(text)
                               KtNodeTypes.CHARACTER_CONSTANT -> CompileTimeConstantChecker.parseChar(expression)
                               else -> throw IllegalArgumentException("Unsupported constant: " + expression)
                           }' @ [328:28] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Any?, entry1: Any?, entry2: Any?, entry3: Any?): Any?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Any?

'nodeElementType' @ [328:34] ==> val nodeElementType: IElementType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[LocalVariableDescriptor]

'INTEGER_CONSTANT' @ [329:44] ==> public final val INTEGER_CONSTANT: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'FLOAT_CONSTANT' @ [329:74] ==> public final val FLOAT_CONSTANT: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'parseNumericLiteral' @ [329:92] ==> private fun parseNumericLiteral(text: String, type: IElementType): Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate in file ConstantExpressionEvaluator.kt[SimpleFunctionDescriptorImpl]

'text' @ [329:112] ==> val text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[LocalVariableDescriptor]

'nodeElementType' @ [329:118] ==> val nodeElementType: IElementType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[LocalVariableDescriptor]

'BOOLEAN_CONSTANT' @ [330:44] ==> public final val BOOLEAN_CONSTANT: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'parseBoolean' @ [330:64] ==> private fun parseBoolean(text: String): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate in file ConstantExpressionEvaluator.kt[SimpleFunctionDescriptorImpl]

'text' @ [330:77] ==> val text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[LocalVariableDescriptor]

'CHARACTER_CONSTANT' @ [331:44] ==> public final val CHARACTER_CONSTANT: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'parseChar' @ [331:93] ==> @Nullable public open fun parseChar(@NotNull expression: KtConstantExpression): Char? defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstantChecker[JavaMethodDescriptor]

'expression' @ [331:103] ==> value-parameter expression: KtConstantExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[ValueParameterDescriptorImpl]

'IllegalArgumentException' @ [332:46] ==> public final fun <init>(p0: (String..String?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'+' @ [332:71] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'expression' @ [332:98] ==> value-parameter expression: KtConstantExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[ValueParameterDescriptorImpl]

'result' @ [335:13] ==> val result: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[LocalVariableDescriptor]

'result' @ [336:17] ==> val result: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[LocalVariableDescriptor]

'isInfinite' @ [336:24] ==> @InlineOnly public inline fun Double.isInfinite(): Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor]

'trace' @ [337:17] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'report' @ [337:23] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'FLOAT_LITERAL_CONFORMS_INFINITY' @ [337:37] ==> public final val FLOAT_LITERAL_CONFORMS_INFINITY: (DiagnosticFactory0<(KtConstantExpression..KtConstantExpression?)>..DiagnosticFactory0<(KtConstantExpression..KtConstantExpression?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [337:69] ==> @NotNull public open fun on(@NotNull element: KtConstantExpression): SimpleDiagnostic<(KtConstantExpression..KtConstantExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'expression' @ [337:72] ==> value-parameter expression: KtConstantExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[ValueParameterDescriptorImpl]

'result' @ [339:17] ==> val result: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[LocalVariableDescriptor]

'!' @ [339:34] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isFPZero' @ [339:54] ==> public open fun isFPZero(@NotNull p0: String): Boolean defined in com.intellij.psi.util.TypeConversionUtil[JavaMethodDescriptor]

'text' @ [339:63] ==> val text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[LocalVariableDescriptor]

'trace' @ [340:17] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'report' @ [340:23] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'FLOAT_LITERAL_CONFORMS_ZERO' @ [340:37] ==> public final val FLOAT_LITERAL_CONFORMS_ZERO: (DiagnosticFactory0<(KtConstantExpression..KtConstantExpression?)>..DiagnosticFactory0<(KtConstantExpression..KtConstantExpression?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [340:65] ==> @NotNull public open fun on(@NotNull element: KtConstantExpression): SimpleDiagnostic<(KtConstantExpression..KtConstantExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'expression' @ [340:68] ==> value-parameter expression: KtConstantExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[ValueParameterDescriptorImpl]

'result' @ [344:13] ==> val result: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[LocalVariableDescriptor]

'result' @ [345:17] ==> val result: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[LocalVariableDescriptor]

'isInfinite' @ [345:24] ==> @InlineOnly public inline fun Float.isInfinite(): Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor]

'trace' @ [346:17] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'report' @ [346:23] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'FLOAT_LITERAL_CONFORMS_INFINITY' @ [346:37] ==> public final val FLOAT_LITERAL_CONFORMS_INFINITY: (DiagnosticFactory0<(KtConstantExpression..KtConstantExpression?)>..DiagnosticFactory0<(KtConstantExpression..KtConstantExpression?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [346:69] ==> @NotNull public open fun on(@NotNull element: KtConstantExpression): SimpleDiagnostic<(KtConstantExpression..KtConstantExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'expression' @ [346:72] ==> value-parameter expression: KtConstantExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[ValueParameterDescriptorImpl]

'result' @ [348:17] ==> val result: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[LocalVariableDescriptor]

'!' @ [348:35] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isFPZero' @ [348:55] ==> public open fun isFPZero(@NotNull p0: String): Boolean defined in com.intellij.psi.util.TypeConversionUtil[JavaMethodDescriptor]

'text' @ [348:64] ==> val text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[LocalVariableDescriptor]

'trace' @ [349:17] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'report' @ [349:23] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'FLOAT_LITERAL_CONFORMS_ZERO' @ [349:37] ==> public final val FLOAT_LITERAL_CONFORMS_ZERO: (DiagnosticFactory0<(KtConstantExpression..KtConstantExpression?)>..DiagnosticFactory0<(KtConstantExpression..KtConstantExpression?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [349:65] ==> @NotNull public open fun on(@NotNull element: KtConstantExpression): SimpleDiagnostic<(KtConstantExpression..KtConstantExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'expression' @ [349:68] ==> value-parameter expression: KtConstantExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[ValueParameterDescriptorImpl]

'nodeElementType' @ [353:32] ==> val nodeElementType: IElementType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[LocalVariableDescriptor]

'INTEGER_CONSTANT' @ [353:63] ==> public final val INTEGER_CONSTANT: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'hasLongSuffix' @ [353:83] ==> private fun hasLongSuffix(text: String): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate[SimpleFunctionDescriptorImpl]

'text' @ [353:97] ==> val text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[LocalVariableDescriptor]

'createConstant' @ [354:16] ==> private final fun createConstant(value: Any?, expectedType: KotlinType?, parameters: CompileTimeConstant.Parameters): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'result' @ [354:31] ==> val result: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[LocalVariableDescriptor]

'expectedType' @ [354:39] ==> value-parameter expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[ValueParameterDescriptorImpl]

'Parameters' @ [354:73] ==> public constructor Parameters(canBeUsedInAnnotation: Boolean, isPure: Boolean, usesVariableAsConstant: Boolean, usesNonConstValAsConstant: Boolean) defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant.Parameters[DeserializedClassConstructorDescriptor]

'!' @ [354:90] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isLongWithSuffix' @ [354:91] ==> val isLongWithSuffix: Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitConstantExpression[LocalVariableDescriptor]

'deparenthesize' @ [358:51] ==> @Nullable public open fun deparenthesize(@Nullable expression: KtExpression?): KtExpression? defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'expression' @ [358:66] ==> value-parameter expression: KtParenthesizedExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitParenthesizedExpression[ValueParameterDescriptorImpl]

'deparenthesizedExpression' @ [359:13] ==> val deparenthesizedExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitParenthesizedExpression[LocalVariableDescriptor]

'deparenthesizedExpression' @ [359:50] ==> val deparenthesizedExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitParenthesizedExpression[LocalVariableDescriptor]

'expression' @ [359:79] ==> value-parameter expression: KtParenthesizedExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitParenthesizedExpression[ValueParameterDescriptorImpl]

'evaluate' @ [360:20] ==> public final fun evaluate(expression: KtExpression, expectedType: KotlinType?): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'deparenthesizedExpression' @ [360:29] ==> val deparenthesizedExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitParenthesizedExpression[LocalVariableDescriptor]

'expectedType' @ [360:56] ==> value-parameter expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitParenthesizedExpression[ValueParameterDescriptorImpl]

'expression' @ [366:30] ==> value-parameter expression: KtLabeledExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitLabeledExpression[ValueParameterDescriptorImpl]

'baseExpression' @ [366:41] ==> public final val baseExpression: KtExpression? defined in org.jetbrains.kotlin.psi.KtLabeledExpression[PropertyDescriptorImpl]

'baseExpression' @ [367:13] ==> val baseExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitLabeledExpression[LocalVariableDescriptor]

'evaluate' @ [368:20] ==> public final fun evaluate(expression: KtExpression, expectedType: KotlinType?): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'baseExpression' @ [368:29] ==> val baseExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitLabeledExpression[LocalVariableDescriptor]

'expectedType' @ [368:45] ==> value-parameter expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitLabeledExpression[ValueParameterDescriptorImpl]

'StringBuilder' @ [374:18] ==> public final fun <init>(): StringBuilder /* = StringBuilder */ defined in kotlin.text.StringBuilder[TypeAliasConstructorDescriptorImpl]

'expression' @ [379:23] ==> value-parameter expression: KtStringTemplateExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitStringTemplateExpression[ValueParameterDescriptorImpl]

'entries' @ [379:34] ==> public final val KtStringTemplateExpression.entries: (Array<(KtStringTemplateEntry..KtStringTemplateEntry?)>..Array<out (KtStringTemplateEntry..KtStringTemplateEntry?)>)[MyPropertyDescriptor]

'stringExpressionEvaluator' @ [380:28] ==> private final val stringExpressionEvaluator: <no name provided> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'evaluate' @ [380:54] ==> public final fun evaluate(entry: KtStringTemplateEntry): TypedCompileTimeConstant<String>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.stringExpressionEvaluator.<no name provided>[SimpleFunctionDescriptorImpl]

'entry' @ [380:63] ==> val entry: (KtStringTemplateEntry..KtStringTemplateEntry?) defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitStringTemplateExpression[LocalVariableDescriptor]

'if (constant == null) {
                interupted = true
                break
            }
            else {
                if (!constant.canBeUsedInAnnotations) canBeUsedInAnnotation = false
                if (constant.usesVariableAsConstant) usesVariableAsConstant = true
                if (constant.usesNonConstValAsConstant) usesNonConstantVariableAsConstant = true
                sb.append(constant.constantValue.value)
            }' @ [381:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (StringBuilder..StringBuilder?), elseBranch: (StringBuilder..StringBuilder?)): (StringBuilder..StringBuilder?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (java.lang.StringBuilder..java.lang.StringBuilder?)

'constant' @ [381:17] ==> val constant: TypedCompileTimeConstant<String>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitStringTemplateExpression[LocalVariableDescriptor]

'interupted' @ [382:17] ==> var interupted: Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitStringTemplateExpression[LocalVariableDescriptor]

'!' @ [386:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'constant' @ [386:22] ==> val constant: TypedCompileTimeConstant<String>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitStringTemplateExpression[LocalVariableDescriptor]

'canBeUsedInAnnotations' @ [386:31] ==> public open val canBeUsedInAnnotations: Boolean defined in org.jetbrains.kotlin.resolve.constants.TypedCompileTimeConstant[DeserializedPropertyDescriptor]

'canBeUsedInAnnotation' @ [386:55] ==> var canBeUsedInAnnotation: Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitStringTemplateExpression[LocalVariableDescriptor]

'constant' @ [387:21] ==> val constant: TypedCompileTimeConstant<String>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitStringTemplateExpression[LocalVariableDescriptor]

'usesVariableAsConstant' @ [387:30] ==> public open val usesVariableAsConstant: Boolean defined in org.jetbrains.kotlin.resolve.constants.TypedCompileTimeConstant[DeserializedPropertyDescriptor]

'usesVariableAsConstant' @ [387:54] ==> var usesVariableAsConstant: Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitStringTemplateExpression[LocalVariableDescriptor]

'constant' @ [388:21] ==> val constant: TypedCompileTimeConstant<String>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitStringTemplateExpression[LocalVariableDescriptor]

'usesNonConstValAsConstant' @ [388:30] ==> public open val usesNonConstValAsConstant: Boolean defined in org.jetbrains.kotlin.resolve.constants.TypedCompileTimeConstant[DeserializedPropertyDescriptor]

'usesNonConstantVariableAsConstant' @ [388:57] ==> var usesNonConstantVariableAsConstant: Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitStringTemplateExpression[LocalVariableDescriptor]

'sb' @ [389:17] ==> val sb: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitStringTemplateExpression[LocalVariableDescriptor]

'append' @ [389:20] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'constant' @ [389:27] ==> val constant: TypedCompileTimeConstant<String>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitStringTemplateExpression[LocalVariableDescriptor]

'constantValue' @ [389:36] ==> public final val constantValue: ConstantValue<String> defined in org.jetbrains.kotlin.resolve.constants.TypedCompileTimeConstant[DeserializedPropertyDescriptor]

'value' @ [389:50] ==> public open val value: String defined in org.jetbrains.kotlin.resolve.constants.ConstantValue[DeserializedPropertyDescriptor]

'if (!interupted)
            createConstant(
                    sb.toString(),
                    expectedType,
                    CompileTimeConstant.Parameters(
                            isPure = false,
                            canBeUsedInAnnotation = canBeUsedInAnnotation,
                            usesVariableAsConstant = usesVariableAsConstant,
                            usesNonConstValAsConstant = usesNonConstantVariableAsConstant
                    )
            )
        else null' @ [392:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: CompileTimeConstant<*>?, elseBranch: CompileTimeConstant<*>?): CompileTimeConstant<*>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> CompileTimeConstant<*>?

'!' @ [392:20] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'interupted' @ [392:21] ==> var interupted: Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitStringTemplateExpression[LocalVariableDescriptor]

'createConstant' @ [393:13] ==> private final fun createConstant(value: Any?, expectedType: KotlinType?, parameters: CompileTimeConstant.Parameters): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'sb' @ [394:21] ==> val sb: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitStringTemplateExpression[LocalVariableDescriptor]

'toString' @ [394:24] ==> public open fun toString(): String defined in java.lang.StringBuilder[JavaMethodDescriptor]

'expectedType' @ [395:21] ==> value-parameter expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitStringTemplateExpression[ValueParameterDescriptorImpl]

'Parameters' @ [396:41] ==> public constructor Parameters(canBeUsedInAnnotation: Boolean, isPure: Boolean, usesVariableAsConstant: Boolean, usesNonConstValAsConstant: Boolean) defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant.Parameters[DeserializedClassConstructorDescriptor]

'canBeUsedInAnnotation' @ [398:53] ==> var canBeUsedInAnnotation: Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitStringTemplateExpression[LocalVariableDescriptor]

'usesVariableAsConstant' @ [399:54] ==> var usesVariableAsConstant: Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitStringTemplateExpression[LocalVariableDescriptor]

'usesNonConstantVariableAsConstant' @ [400:57] ==> var usesNonConstantVariableAsConstant: Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitStringTemplateExpression[LocalVariableDescriptor]

'ConstantExpressionEvaluator' @ [407:16] ==> public companion object defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[FakeCallableDescriptorForObject]

'getConstant' @ [407:44] ==> @JvmStatic public final fun getConstant(expression: KtExpression, bindingContext: BindingContext): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.Companion[SimpleFunctionDescriptorImpl]

'expression' @ [407:56] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.isStandaloneOnlyConstant[ValueParameterDescriptorImpl]

'trace' @ [407:68] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'bindingContext' @ [407:74] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'isStandaloneOnlyConstant' @ [407:91] ==> public fun CompileTimeConstant<*>.isStandaloneOnlyConstant(): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate in file ConstantExpressionEvaluator.kt[SimpleFunctionDescriptorImpl]

'evaluate' @ [411:35] ==> public final fun evaluate(expression: KtExpression, expectedType: KotlinType?): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'expression' @ [411:44] ==> value-parameter expression: KtBinaryExpressionWithTypeRHS defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryWithTypeRHSExpression[ValueParameterDescriptorImpl]

'left' @ [411:55] ==> public final val KtBinaryExpressionWithTypeRHS.left: KtExpression[MyPropertyDescriptor]

'expectedType' @ [411:61] ==> value-parameter expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryWithTypeRHSExpression[ValueParameterDescriptorImpl]

'compileTimeConstant' @ [412:13] ==> val compileTimeConstant: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryWithTypeRHSExpression[LocalVariableDescriptor]

'expectedType' @ [413:17] ==> value-parameter expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryWithTypeRHSExpression[ValueParameterDescriptorImpl]

'!' @ [413:41] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'noExpectedType' @ [413:52] ==> public open fun noExpectedType(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'expectedType' @ [413:67] ==> value-parameter expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryWithTypeRHSExpression[ValueParameterDescriptorImpl]

'when(compileTimeConstant) {
                    is TypedCompileTimeConstant<*> ->
                            compileTimeConstant.type
                    is IntegerValueTypeConstant ->
                        compileTimeConstant.getType(expectedType)
                    else ->
                            throw IllegalStateException("Unexpected compileTimeConstant class: ${compileTimeConstant::class.java.canonicalName}")

                }' @ [414:36] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KotlinType, entry1: KotlinType, entry2: KotlinType): KotlinType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KotlinType

'compileTimeConstant' @ [414:41] ==> val compileTimeConstant: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryWithTypeRHSExpression[LocalVariableDescriptor]

'compileTimeConstant' @ [416:29] ==> val compileTimeConstant: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryWithTypeRHSExpression[LocalVariableDescriptor]

'type' @ [416:49] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.constants.TypedCompileTimeConstant[DeserializedPropertyDescriptor]

'compileTimeConstant' @ [418:25] ==> val compileTimeConstant: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryWithTypeRHSExpression[LocalVariableDescriptor]

'getType' @ [418:45] ==> public final fun getType(expectedType: KotlinType): KotlinType defined in org.jetbrains.kotlin.resolve.constants.IntegerValueTypeConstant[DeserializedSimpleFunctionDescriptor]

'expectedType' @ [418:53] ==> value-parameter expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryWithTypeRHSExpression[ValueParameterDescriptorImpl]

'IllegalStateException' @ [420:35] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'compileTimeConstant' @ [420:98] ==> val compileTimeConstant: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryWithTypeRHSExpression[LocalVariableDescriptor]

'java' @ [420:125] ==> public val <T> KClass<out CompileTimeConstant<*>>.java: Class<out CompileTimeConstant<*>> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> CompileTimeConstant<*>

'canonicalName' @ [420:130] ==> public final val <T : (Any..Any?)> Class<out CompileTimeConstant<*>>.canonicalName: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> CompileTimeConstant<*>

'!' @ [423:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'constantType' @ [423:22] ==> val constantType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryWithTypeRHSExpression[LocalVariableDescriptor]

'isSubtypeOf' @ [423:35] ==> public fun KotlinType.isSubtypeOf(superType: KotlinType): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'expectedType' @ [423:47] ==> value-parameter expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryWithTypeRHSExpression[ValueParameterDescriptorImpl]

'compileTimeConstant' @ [428:16] ==> val compileTimeConstant: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryWithTypeRHSExpression[LocalVariableDescriptor]

'expression' @ [432:30] ==> value-parameter expression: KtBinaryExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[ValueParameterDescriptorImpl]

'left' @ [432:41] ==> public final val KtBinaryExpression.left: KtExpression?[MyPropertyDescriptor]

'expression' @ [434:30] ==> value-parameter expression: KtBinaryExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[ValueParameterDescriptorImpl]

'operationToken' @ [434:41] ==> public final val KtBinaryExpression.operationToken: IElementType[MyPropertyDescriptor]

'if (OperatorConventions.BOOLEAN_OPERATIONS.containsKey(operationToken)) {
            val booleanType = constantExpressionEvaluator.builtIns.booleanType
            val leftConstant = evaluate(leftExpression, booleanType) ?: return null

            val rightExpression = expression.right ?: return null

            val rightConstant = evaluate(rightExpression, booleanType) ?: return null

            val leftValue = leftConstant.getValue(booleanType)
            val rightValue = rightConstant.getValue(booleanType)

            if (leftValue !is Boolean || rightValue !is Boolean) return null
            val result = when (operationToken) {
                KtTokens.ANDAND -> leftValue && rightValue
                KtTokens.OROR -> leftValue || rightValue
                else -> throw IllegalArgumentException("Unknown boolean operation token $operationToken")
            }
            return createConstant(
                    result, expectedType,
                    CompileTimeConstant.Parameters(
                            canBeUsedInAnnotation = true,
                            isPure = false,
                            usesVariableAsConstant = leftConstant.usesVariableAsConstant || rightConstant.usesVariableAsConstant,
                            usesNonConstValAsConstant = leftConstant.usesNonConstValAsConstant || rightConstant.usesNonConstValAsConstant
                    )
            )
        }
        else {
            return evaluateCall(expression.operationReference, leftExpression, expectedType)
        }' @ [435:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nothing, elseBranch: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nothing

'BOOLEAN_OPERATIONS' @ [435:33] ==> public final val BOOLEAN_OPERATIONS: (ImmutableBiMap<(KtSingleValueToken..KtSingleValueToken?), (Name..Name?)>..ImmutableBiMap<(KtSingleValueToken..KtSingleValueToken?), (Name..Name?)>?) defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaPropertyDescriptor]

'containsKey' @ [435:52] ==> @InlineOnly public inline fun <@OnlyInputTypes K> Map<out (IElementType..IElementType?), *>.containsKey(key: (IElementType..IElementType?)): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <@OnlyInputTypes K> -> (com.intellij.psi.tree.IElementType..com.intellij.psi.tree.IElementType?)

'operationToken' @ [435:64] ==> val operationToken: IElementType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[LocalVariableDescriptor]

'constantExpressionEvaluator' @ [436:31] ==> private final val constantExpressionEvaluator: ConstantExpressionEvaluator defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'builtIns' @ [436:59] ==> internal final val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[PropertyDescriptorImpl]

'booleanType' @ [436:68] ==> public final val KotlinBuiltIns.booleanType: SimpleType[MyPropertyDescriptor]

'evaluate' @ [437:32] ==> public final fun evaluate(expression: KtExpression, expectedType: KotlinType?): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'leftExpression' @ [437:41] ==> val leftExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[LocalVariableDescriptor]

'booleanType' @ [437:57] ==> val booleanType: SimpleType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[LocalVariableDescriptor]

'expression' @ [439:35] ==> value-parameter expression: KtBinaryExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[ValueParameterDescriptorImpl]

'right' @ [439:46] ==> public final val KtBinaryExpression.right: KtExpression?[MyPropertyDescriptor]

'evaluate' @ [441:33] ==> public final fun evaluate(expression: KtExpression, expectedType: KotlinType?): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'rightExpression' @ [441:42] ==> val rightExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[LocalVariableDescriptor]

'booleanType' @ [441:59] ==> val booleanType: SimpleType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[LocalVariableDescriptor]

'leftConstant' @ [443:29] ==> val leftConstant: CompileTimeConstant<Any?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[LocalVariableDescriptor]

'getValue' @ [443:42] ==> public open fun getValue(expectedType: KotlinType): Any? defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant[DeserializedSimpleFunctionDescriptor]

'booleanType' @ [443:51] ==> val booleanType: SimpleType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[LocalVariableDescriptor]

'rightConstant' @ [444:30] ==> val rightConstant: CompileTimeConstant<Any?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[LocalVariableDescriptor]

'getValue' @ [444:44] ==> public open fun getValue(expectedType: KotlinType): Any? defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant[DeserializedSimpleFunctionDescriptor]

'booleanType' @ [444:53] ==> val booleanType: SimpleType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[LocalVariableDescriptor]

'leftValue' @ [446:17] ==> val leftValue: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[LocalVariableDescriptor]

'rightValue' @ [446:42] ==> val rightValue: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[LocalVariableDescriptor]

'when (operationToken) {
                KtTokens.ANDAND -> leftValue && rightValue
                KtTokens.OROR -> leftValue || rightValue
                else -> throw IllegalArgumentException("Unknown boolean operation token $operationToken")
            }' @ [447:26] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean, entry2: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'operationToken' @ [447:32] ==> val operationToken: IElementType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[LocalVariableDescriptor]

'ANDAND' @ [448:26] ==> public final val ANDAND: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'leftValue' @ [448:36] ==> val leftValue: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[LocalVariableDescriptor]

'rightValue' @ [448:49] ==> val rightValue: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[LocalVariableDescriptor]

'OROR' @ [449:26] ==> public final val OROR: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'leftValue' @ [449:34] ==> val leftValue: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[LocalVariableDescriptor]

'rightValue' @ [449:47] ==> val rightValue: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[LocalVariableDescriptor]

'IllegalArgumentException' @ [450:31] ==> public final fun <init>(p0: (String..String?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'operationToken' @ [450:90] ==> val operationToken: IElementType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[LocalVariableDescriptor]

'createConstant' @ [452:20] ==> private final fun createConstant(value: Any?, expectedType: KotlinType?, parameters: CompileTimeConstant.Parameters): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'result' @ [453:21] ==> val result: Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[LocalVariableDescriptor]

'expectedType' @ [453:29] ==> value-parameter expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[ValueParameterDescriptorImpl]

'Parameters' @ [454:41] ==> public constructor Parameters(canBeUsedInAnnotation: Boolean, isPure: Boolean, usesVariableAsConstant: Boolean, usesNonConstValAsConstant: Boolean) defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant.Parameters[DeserializedClassConstructorDescriptor]

'leftConstant' @ [457:54] ==> val leftConstant: CompileTimeConstant<Any?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[LocalVariableDescriptor]

'usesVariableAsConstant' @ [457:67] ==> public open val usesVariableAsConstant: Boolean defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant[DeserializedPropertyDescriptor]

'rightConstant' @ [457:93] ==> val rightConstant: CompileTimeConstant<Any?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[LocalVariableDescriptor]

'usesVariableAsConstant' @ [457:107] ==> public open val usesVariableAsConstant: Boolean defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant[DeserializedPropertyDescriptor]

'leftConstant' @ [458:57] ==> val leftConstant: CompileTimeConstant<Any?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[LocalVariableDescriptor]

'usesNonConstValAsConstant' @ [458:70] ==> public open val usesNonConstValAsConstant: Boolean defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant[DeserializedPropertyDescriptor]

'rightConstant' @ [458:99] ==> val rightConstant: CompileTimeConstant<Any?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[LocalVariableDescriptor]

'usesNonConstValAsConstant' @ [458:113] ==> public open val usesNonConstValAsConstant: Boolean defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant[DeserializedPropertyDescriptor]

'evaluateCall' @ [463:20] ==> private final fun evaluateCall(callExpression: KtExpression, receiverExpression: KtExpression, expectedType: KotlinType?): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'expression' @ [463:33] ==> value-parameter expression: KtBinaryExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[ValueParameterDescriptorImpl]

'operationReference' @ [463:44] ==> public final val KtBinaryExpression.operationReference: KtOperationReferenceExpression[MyPropertyDescriptor]

'leftExpression' @ [463:64] ==> val leftExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[LocalVariableDescriptor]

'expectedType' @ [463:80] ==> value-parameter expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitBinaryExpression[ValueParameterDescriptorImpl]

'trace' @ [468:28] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'bindingContext' @ [468:34] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'COLLECTION_LITERAL_CALL' @ [468:49] ==> public final val COLLECTION_LITERAL_CALL: (WritableSlice<(KtCollectionLiteralExpression..KtCollectionLiteralExpression?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>..WritableSlice<(KtCollectionLiteralExpression..KtCollectionLiteralExpression?), (ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>..ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)>?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'expression' @ [468:74] ==> value-parameter expression: KtCollectionLiteralExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitCollectionLiteralExpression[ValueParameterDescriptorImpl]

'createConstantValueForArrayFunctionCall' @ [469:16] ==> private final fun createConstantValueForArrayFunctionCall(call: ResolvedCall<*>): TypedCompileTimeConstant<List<ConstantValue<*>>>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'resolvedCall' @ [469:56] ==> val resolvedCall: ResolvedCall<(FunctionDescriptor..FunctionDescriptor?)> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitCollectionLiteralExpression[LocalVariableDescriptor]

'callExpression' @ [473:28] ==> value-parameter callExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[ValueParameterDescriptorImpl]

'getResolvedCall' @ [473:43] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[SimpleFunctionDescriptorImpl]

'trace' @ [473:59] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'bindingContext' @ [473:65] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'!' @ [474:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isUnderKotlinPackage' @ [474:29] ==> public open fun isUnderKotlinPackage(@NotNull p0: DeclarationDescriptor): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'resolvedCall' @ [474:50] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'resultingDescriptor' @ [474:63] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.resultingDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'resolvedCall' @ [476:39] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'resultingDescriptor' @ [476:52] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.resultingDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'name' @ [476:72] ==> public final val CallableDescriptor.name: Name[MyPropertyDescriptor]

'createOperationArgumentForReceiver' @ [478:35] ==> private final fun createOperationArgumentForReceiver(resolvedCall: ResolvedCall<*>, expression: KtExpression): ConstantExpressionEvaluatorVisitor.OperationArgument? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'resolvedCall' @ [478:70] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'receiverExpression' @ [478:84] ==> value-parameter receiverExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[ValueParameterDescriptorImpl]

'isStandaloneOnlyConstant' @ [479:13] ==> private final fun isStandaloneOnlyConstant(expression: KtExpression): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'argumentForReceiver' @ [479:38] ==> val argumentForReceiver: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'expression' @ [479:58] ==> public final val expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'resolvedCall' @ [483:33] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'valueArguments' @ [483:46] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.valueArguments: (MutableMap<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>..Map<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'entries' @ [483:61] ==> public abstract val entries: MutableSet<MutableMap.MutableEntry<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>> defined in kotlin.collections.MutableMap[DeserializedPropertyDescriptor]

'if (argumentsEntrySet.isEmpty()) {
            val result = evaluateUnaryAndCheck(argumentForReceiver, resultingDescriptorName.asString(), callExpression) ?: return null

            val isArgumentPure = isPureConstant(argumentForReceiver.expression)
            val canBeUsedInAnnotation = canBeUsedInAnnotation(argumentForReceiver.expression)
            val usesVariableAsConstant = usesVariableAsConstant(argumentForReceiver.expression)
            val usesNonConstValAsConstant = usesNonConstValAsConstant(argumentForReceiver.expression)
            val isNumberConversionMethod = resultingDescriptorName in OperatorConventions.NUMBER_CONVERSIONS
            return createConstant(
                    result,
                    expectedType,
                    CompileTimeConstant.Parameters(
                            canBeUsedInAnnotation,
                            !isNumberConversionMethod && isArgumentPure,
                            usesVariableAsConstant, usesNonConstValAsConstant)
            )
        }
        else if (argumentsEntrySet.size == 1) {
            val (parameter, argument) = argumentsEntrySet.first()
            val argumentForParameter = createOperationArgumentForFirstParameter(argument, parameter) ?: return null
            if (isStandaloneOnlyConstant(argumentForParameter.expression)) {
                return null
            }

            if (isDivisionByZero(resultingDescriptorName.asString(), argumentForParameter.value)) {
                val parentExpression: KtExpression = PsiTreeUtil.getParentOfType(receiverExpression, KtExpression::class.java)!!
                trace.report(Errors.DIVISION_BY_ZERO.on(parentExpression))

                if ((isIntegerType(argumentForReceiver.value) && isIntegerType(argumentForParameter.value)) ||
                    !constantExpressionEvaluator.languageVersionSettings.supportsFeature(LanguageFeature.DivisionByZeroInConstantExpressions)) {
                    return factory.createErrorValue("Division by zero").wrap()
                }
            }

            val result = evaluateBinaryAndCheck(argumentForReceiver, argumentForParameter, resultingDescriptorName.asString(), callExpression) ?: return null

            val areArgumentsPure = isPureConstant(argumentForReceiver.expression) && isPureConstant(argumentForParameter.expression)
            val canBeUsedInAnnotation = canBeUsedInAnnotation(argumentForReceiver.expression) && canBeUsedInAnnotation(argumentForParameter.expression)
            val usesVariableAsConstant = usesVariableAsConstant(argumentForReceiver.expression) || usesVariableAsConstant(argumentForParameter.expression)
            val usesNonConstValAsConstant = usesNonConstValAsConstant(argumentForReceiver.expression) || usesNonConstValAsConstant(argumentForParameter.expression)
            val parameters = CompileTimeConstant.Parameters(canBeUsedInAnnotation, areArgumentsPure, usesVariableAsConstant, usesNonConstValAsConstant)
            return when (resultingDescriptorName) {
                OperatorNameConventions.COMPARE_TO -> createCompileTimeConstantForCompareTo(result, callExpression, factory)?.wrap(parameters)
                OperatorNameConventions.EQUALS -> createCompileTimeConstantForEquals(result, callExpression, factory)?.wrap(parameters)
                else -> {
                    createConstant(result, expectedType, parameters)
                }
            }
        }' @ [484:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'argumentsEntrySet' @ [484:13] ==> val argumentsEntrySet: MutableSet<MutableMap.MutableEntry<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'isEmpty' @ [484:31] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.MutableSet[DeserializedSimpleFunctionDescriptor]

'evaluateUnaryAndCheck' @ [485:26] ==> private final fun evaluateUnaryAndCheck(receiver: ConstantExpressionEvaluatorVisitor.OperationArgument, name: String, callExpression: KtExpression): Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'argumentForReceiver' @ [485:48] ==> val argumentForReceiver: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'resultingDescriptorName' @ [485:69] ==> val resultingDescriptorName: Name defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'asString' @ [485:93] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'callExpression' @ [485:105] ==> value-parameter callExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[ValueParameterDescriptorImpl]

'isPureConstant' @ [487:34] ==> private final fun isPureConstant(expression: KtExpression): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'argumentForReceiver' @ [487:49] ==> val argumentForReceiver: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'expression' @ [487:69] ==> public final val expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'canBeUsedInAnnotation' @ [488:41] ==> private final fun canBeUsedInAnnotation(expression: KtExpression): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'argumentForReceiver' @ [488:63] ==> val argumentForReceiver: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'expression' @ [488:83] ==> public final val expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'usesVariableAsConstant' @ [489:42] ==> private final fun usesVariableAsConstant(expression: KtExpression): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'argumentForReceiver' @ [489:65] ==> val argumentForReceiver: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'expression' @ [489:85] ==> public final val expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'usesNonConstValAsConstant' @ [490:45] ==> private final fun usesNonConstValAsConstant(expression: KtExpression): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'argumentForReceiver' @ [490:71] ==> val argumentForReceiver: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'expression' @ [490:91] ==> public final val expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'resultingDescriptorName' @ [491:44] ==> val resultingDescriptorName: Name defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'NUMBER_CONVERSIONS' @ [491:91] ==> public final val NUMBER_CONVERSIONS: (ImmutableSet<(Name..Name?)>..ImmutableSet<(Name..Name?)>?) defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaPropertyDescriptor]

'createConstant' @ [492:20] ==> private final fun createConstant(value: Any?, expectedType: KotlinType?, parameters: CompileTimeConstant.Parameters): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'result' @ [493:21] ==> val result: Any defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'expectedType' @ [494:21] ==> value-parameter expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[ValueParameterDescriptorImpl]

'Parameters' @ [495:41] ==> public constructor Parameters(canBeUsedInAnnotation: Boolean, isPure: Boolean, usesVariableAsConstant: Boolean, usesNonConstValAsConstant: Boolean) defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant.Parameters[DeserializedClassConstructorDescriptor]

'canBeUsedInAnnotation' @ [496:29] ==> val canBeUsedInAnnotation: Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'!' @ [497:29] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isNumberConversionMethod' @ [497:30] ==> val isNumberConversionMethod: Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'isArgumentPure' @ [497:58] ==> val isArgumentPure: Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'usesVariableAsConstant' @ [498:29] ==> val usesVariableAsConstant: Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'usesNonConstValAsConstant' @ [498:53] ==> val usesNonConstValAsConstant: Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'argumentsEntrySet' @ [501:18] ==> val argumentsEntrySet: MutableSet<MutableMap.MutableEntry<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'size' @ [501:36] ==> public abstract val size: Int defined in kotlin.collections.MutableSet[DeserializedPropertyDescriptor]

'component1' @ [502:18] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>.component1(): (ValueParameterDescriptor..ValueParameterDescriptor?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)
    <V> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument..org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument?)

'component2' @ [502:29] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>.component2(): (ResolvedValueArgument..ResolvedValueArgument?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)
    <V> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument..org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument?)

'argumentsEntrySet' @ [502:41] ==> val argumentsEntrySet: MutableSet<MutableMap.MutableEntry<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'first' @ [502:59] ==> public fun <T> Iterable<MutableMap.MutableEntry<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>>.first(): MutableMap.MutableEntry<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> MutableEntry<(org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?), (org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument..org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument?)>

'createOperationArgumentForFirstParameter' @ [503:40] ==> private final fun createOperationArgumentForFirstParameter(argument: ResolvedValueArgument, parameter: ValueParameterDescriptor): ConstantExpressionEvaluatorVisitor.OperationArgument? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'argument' @ [503:81] ==> val argument: (ResolvedValueArgument..ResolvedValueArgument?) defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'parameter' @ [503:91] ==> val parameter: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'isStandaloneOnlyConstant' @ [504:17] ==> private final fun isStandaloneOnlyConstant(expression: KtExpression): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'argumentForParameter' @ [504:42] ==> val argumentForParameter: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'expression' @ [504:63] ==> public final val expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'isDivisionByZero' @ [508:17] ==> private final fun isDivisionByZero(name: String, parameter: Any?): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'resultingDescriptorName' @ [508:34] ==> val resultingDescriptorName: Name defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'asString' @ [508:58] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'argumentForParameter' @ [508:70] ==> val argumentForParameter: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'value' @ [508:91] ==> public final val value: Any defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'!!' @ [509:54] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: KtExpression?): KtExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> KtExpression

'getParentOfType' @ [509:66] ==> @Nullable @Contract public open fun <T : (PsiElement..PsiElement?)> getParentOfType(@Nullable p0: PsiElement?, @NotNull p1: Class<(KtExpression..KtExpression?)>): KtExpression? defined in com.intellij.psi.util.PsiTreeUtil[JavaMethodDescriptor]
Inferred types:
    <T : (PsiElement..PsiElement?)> -> KtExpression

'receiverExpression' @ [509:82] ==> value-parameter receiverExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[ValueParameterDescriptorImpl]

'java' @ [509:122] ==> public val <T> KClass<KtExpression>.java: Class<KtExpression> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtExpression

'trace' @ [510:17] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'report' @ [510:23] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'DIVISION_BY_ZERO' @ [510:37] ==> public final val DIVISION_BY_ZERO: (DiagnosticFactory0<(KtExpression..KtExpression?)>..DiagnosticFactory0<(KtExpression..KtExpression?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [510:54] ==> @NotNull public open fun on(@NotNull element: KtExpression): SimpleDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'parentExpression' @ [510:57] ==> val parentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'isIntegerType' @ [512:22] ==> public fun isIntegerType(value: Any?): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate[SimpleFunctionDescriptorImpl]

'argumentForReceiver' @ [512:36] ==> val argumentForReceiver: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'value' @ [512:56] ==> public final val value: Any defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'isIntegerType' @ [512:66] ==> public fun isIntegerType(value: Any?): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate[SimpleFunctionDescriptorImpl]

'argumentForParameter' @ [512:80] ==> val argumentForParameter: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'value' @ [512:101] ==> public final val value: Any defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'!' @ [513:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'constantExpressionEvaluator' @ [513:22] ==> private final val constantExpressionEvaluator: ConstantExpressionEvaluator defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'languageVersionSettings' @ [513:50] ==> internal final val languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[PropertyDescriptorImpl]

'supportsFeature' @ [513:74] ==> public open fun supportsFeature(feature: LanguageFeature): Boolean defined in org.jetbrains.kotlin.config.LanguageVersionSettings[DeserializedSimpleFunctionDescriptor]

'LanguageFeature' @ [513:90] ==> public companion object defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'DivisionByZeroInConstantExpressions' @ [513:106] ==> enum entry DivisionByZeroInConstantExpressions defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'factory' @ [514:28] ==> private final val factory: ConstantValueFactory defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'createErrorValue' @ [514:36] ==> public final fun createErrorValue(message: String): ErrorValue defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[DeserializedSimpleFunctionDescriptor]

'wrap' @ [514:73] ==> private final fun <T> ConstantValue<Unit>.wrap(canBeUsedInAnnotation: Boolean = ..., isPure: Boolean = ..., usesVariableAsConstant: Boolean = ..., usesNonConstValAsConstant: Boolean = ...): TypedCompileTimeConstant<Unit> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> Unit

'evaluateBinaryAndCheck' @ [518:26] ==> private final fun evaluateBinaryAndCheck(receiver: ConstantExpressionEvaluatorVisitor.OperationArgument, parameter: ConstantExpressionEvaluatorVisitor.OperationArgument, name: String, callExpression: KtExpression): Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'argumentForReceiver' @ [518:49] ==> val argumentForReceiver: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'argumentForParameter' @ [518:70] ==> val argumentForParameter: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'resultingDescriptorName' @ [518:92] ==> val resultingDescriptorName: Name defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'asString' @ [518:116] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'callExpression' @ [518:128] ==> value-parameter callExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[ValueParameterDescriptorImpl]

'isPureConstant' @ [520:36] ==> private final fun isPureConstant(expression: KtExpression): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'argumentForReceiver' @ [520:51] ==> val argumentForReceiver: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'expression' @ [520:71] ==> public final val expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'isPureConstant' @ [520:86] ==> private final fun isPureConstant(expression: KtExpression): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'argumentForParameter' @ [520:101] ==> val argumentForParameter: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'expression' @ [520:122] ==> public final val expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'canBeUsedInAnnotation' @ [521:41] ==> private final fun canBeUsedInAnnotation(expression: KtExpression): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'argumentForReceiver' @ [521:63] ==> val argumentForReceiver: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'expression' @ [521:83] ==> public final val expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'canBeUsedInAnnotation' @ [521:98] ==> private final fun canBeUsedInAnnotation(expression: KtExpression): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'argumentForParameter' @ [521:120] ==> val argumentForParameter: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'expression' @ [521:141] ==> public final val expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'usesVariableAsConstant' @ [522:42] ==> private final fun usesVariableAsConstant(expression: KtExpression): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'argumentForReceiver' @ [522:65] ==> val argumentForReceiver: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'expression' @ [522:85] ==> public final val expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'usesVariableAsConstant' @ [522:100] ==> private final fun usesVariableAsConstant(expression: KtExpression): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'argumentForParameter' @ [522:123] ==> val argumentForParameter: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'expression' @ [522:144] ==> public final val expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'usesNonConstValAsConstant' @ [523:45] ==> private final fun usesNonConstValAsConstant(expression: KtExpression): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'argumentForReceiver' @ [523:71] ==> val argumentForReceiver: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'expression' @ [523:91] ==> public final val expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'usesNonConstValAsConstant' @ [523:106] ==> private final fun usesNonConstValAsConstant(expression: KtExpression): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'argumentForParameter' @ [523:132] ==> val argumentForParameter: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'expression' @ [523:153] ==> public final val expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'Parameters' @ [524:50] ==> public constructor Parameters(canBeUsedInAnnotation: Boolean, isPure: Boolean, usesVariableAsConstant: Boolean, usesNonConstValAsConstant: Boolean) defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant.Parameters[DeserializedClassConstructorDescriptor]

'canBeUsedInAnnotation' @ [524:61] ==> val canBeUsedInAnnotation: Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'areArgumentsPure' @ [524:84] ==> val areArgumentsPure: Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'usesVariableAsConstant' @ [524:102] ==> val usesVariableAsConstant: Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'usesNonConstValAsConstant' @ [524:126] ==> val usesNonConstValAsConstant: Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'when (resultingDescriptorName) {
                OperatorNameConventions.COMPARE_TO -> createCompileTimeConstantForCompareTo(result, callExpression, factory)?.wrap(parameters)
                OperatorNameConventions.EQUALS -> createCompileTimeConstantForEquals(result, callExpression, factory)?.wrap(parameters)
                else -> {
                    createConstant(result, expectedType, parameters)
                }
            }' @ [525:20] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: CompileTimeConstant<*>?, entry1: CompileTimeConstant<*>?, entry2: CompileTimeConstant<*>?): CompileTimeConstant<*>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> CompileTimeConstant<*>?

'resultingDescriptorName' @ [525:26] ==> val resultingDescriptorName: Name defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'OperatorNameConventions' @ [526:17] ==> public object OperatorNameConventions defined in org.jetbrains.kotlin.util[FakeCallableDescriptorForObject]

'COMPARE_TO' @ [526:41] ==> @field:JvmField public final val COMPARE_TO: Name defined in org.jetbrains.kotlin.util.OperatorNameConventions[DeserializedPropertyDescriptor]

'createCompileTimeConstantForCompareTo' @ [526:55] ==> private fun createCompileTimeConstantForCompareTo(result: Any?, operationReference: KtExpression, factory: ConstantValueFactory): ConstantValue<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate in file ConstantExpressionEvaluator.kt[SimpleFunctionDescriptorImpl]

'result' @ [526:93] ==> val result: Any defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'callExpression' @ [526:101] ==> value-parameter callExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[ValueParameterDescriptorImpl]

'factory' @ [526:117] ==> private final val factory: ConstantValueFactory defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'wrap' @ [526:127] ==> private final fun <T> ConstantValue<Any?>.wrap(parameters: CompileTimeConstant.Parameters): TypedCompileTimeConstant<Any?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> Any?

'parameters' @ [526:132] ==> val parameters: CompileTimeConstant.Parameters defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'OperatorNameConventions' @ [527:17] ==> public object OperatorNameConventions defined in org.jetbrains.kotlin.util[FakeCallableDescriptorForObject]

'EQUALS' @ [527:41] ==> @field:JvmField public final val EQUALS: Name defined in org.jetbrains.kotlin.util.OperatorNameConventions[DeserializedPropertyDescriptor]

'createCompileTimeConstantForEquals' @ [527:51] ==> private fun createCompileTimeConstantForEquals(result: Any?, operationReference: KtExpression, factory: ConstantValueFactory): ConstantValue<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate in file ConstantExpressionEvaluator.kt[SimpleFunctionDescriptorImpl]

'result' @ [527:86] ==> val result: Any defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'callExpression' @ [527:94] ==> value-parameter callExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[ValueParameterDescriptorImpl]

'factory' @ [527:110] ==> private final val factory: ConstantValueFactory defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'wrap' @ [527:120] ==> private final fun <T> ConstantValue<Any?>.wrap(parameters: CompileTimeConstant.Parameters): TypedCompileTimeConstant<Any?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> Any?

'parameters' @ [527:125] ==> val parameters: CompileTimeConstant.Parameters defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'createConstant' @ [529:21] ==> private final fun createConstant(value: Any?, expectedType: KotlinType?, parameters: CompileTimeConstant.Parameters): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'result' @ [529:36] ==> val result: Any defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'expectedType' @ [529:44] ==> value-parameter expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[ValueParameterDescriptorImpl]

'parameters' @ [529:58] ==> val parameters: CompileTimeConstant.Parameters defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateCall[LocalVariableDescriptor]

'ConstantExpressionEvaluator' @ [537:68] ==> public companion object defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[FakeCallableDescriptorForObject]

'getConstant' @ [537:96] ==> @JvmStatic public final fun getConstant(expression: KtExpression, bindingContext: BindingContext): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.Companion[SimpleFunctionDescriptorImpl]

'expression' @ [537:108] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.usesVariableAsConstant[ValueParameterDescriptorImpl]

'trace' @ [537:120] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'bindingContext' @ [537:126] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'usesVariableAsConstant' @ [537:143] ==> public open val usesVariableAsConstant: Boolean defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant[DeserializedPropertyDescriptor]

'ConstantExpressionEvaluator' @ [539:15] ==> public companion object defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[FakeCallableDescriptorForObject]

'getConstant' @ [539:43] ==> @JvmStatic public final fun getConstant(expression: KtExpression, bindingContext: BindingContext): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.Companion[SimpleFunctionDescriptorImpl]

'expression' @ [539:55] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.usesNonConstValAsConstant[ValueParameterDescriptorImpl]

'trace' @ [539:67] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'bindingContext' @ [539:73] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'usesNonConstValAsConstant' @ [539:90] ==> public open val usesNonConstValAsConstant: Boolean defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant[DeserializedPropertyDescriptor]

'ConstantExpressionEvaluator' @ [541:67] ==> public companion object defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[FakeCallableDescriptorForObject]

'getConstant' @ [541:95] ==> @JvmStatic public final fun getConstant(expression: KtExpression, bindingContext: BindingContext): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.Companion[SimpleFunctionDescriptorImpl]

'expression' @ [541:107] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.canBeUsedInAnnotation[ValueParameterDescriptorImpl]

'trace' @ [541:119] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'bindingContext' @ [541:125] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'canBeUsedInAnnotations' @ [541:142] ==> public open val canBeUsedInAnnotations: Boolean defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant[DeserializedPropertyDescriptor]

'ConstantExpressionEvaluator' @ [543:60] ==> public companion object defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[FakeCallableDescriptorForObject]

'getConstant' @ [543:88] ==> @JvmStatic public final fun getConstant(expression: KtExpression, bindingContext: BindingContext): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator.Companion[SimpleFunctionDescriptorImpl]

'expression' @ [543:100] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.isPureConstant[ValueParameterDescriptorImpl]

'trace' @ [543:112] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'bindingContext' @ [543:118] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'isPure' @ [543:135] ==> public open val isPure: Boolean defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant[DeserializedPropertyDescriptor]

'unaryOperations' @ [546:25] ==> internal val unaryOperations: HashMap<UnaryOperationKey<*>, Pair<(Any?) -> Any, (Long) -> Long>> defined in org.jetbrains.kotlin.resolve.constants.evaluate in file OperationsMapGenerated.kt[PropertyDescriptorImpl]

'UnaryOperationKey' @ [546:41] ==> public constructor UnaryOperationKey<out A>(f: CompileTimeType<out Any?>, functionName: String) defined in org.jetbrains.kotlin.resolve.constants.evaluate.UnaryOperationKey[ClassConstructorDescriptorImpl]
Inferred types:
    <out A> -> Any?

'receiver' @ [546:59] ==> value-parameter receiver: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateUnaryAndCheck[ValueParameterDescriptorImpl]

'ctcType' @ [546:68] ==> public final val ctcType: CompileTimeType<*> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'name' @ [546:77] ==> value-parameter name: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateUnaryAndCheck[ValueParameterDescriptorImpl]

'component1' @ [548:14] ==> public final operator fun component1(): (Any?) -> Any defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [548:24] ==> public final operator fun component2(): (Long) -> Long defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'functions' @ [548:33] ==> val functions: Pair<(Any?) -> Any, (Long) -> Long> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateUnaryAndCheck[LocalVariableDescriptor]

'invoke' @ [549:22] ==> public abstract operator fun invoke(p1: Any?): Any defined in kotlin.Function1[FunctionInvokeDescriptor]

'receiver' @ [549:31] ==> value-parameter receiver: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateUnaryAndCheck[ValueParameterDescriptorImpl]

'value' @ [549:40] ==> public final val value: Any defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'check' @ [550:13] ==> val check: (Long) -> Long defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateUnaryAndCheck[LocalVariableDescriptor]

'emptyUnaryFun' @ [550:22] ==> internal val emptyUnaryFun: (Long) -> Long defined in org.jetbrains.kotlin.resolve.constants.evaluate in file OperationsMapGenerated.kt[PropertyDescriptorImpl]

'result' @ [551:20] ==> val result: Any defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateUnaryAndCheck[LocalVariableDescriptor]

'assert' @ [553:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'isIntegerType' @ [553:16] ==> public fun isIntegerType(value: Any?): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate[SimpleFunctionDescriptorImpl]

'receiver' @ [553:30] ==> value-parameter receiver: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateUnaryAndCheck[ValueParameterDescriptorImpl]

'value' @ [553:39] ==> public final val value: Any defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'assert' @ [554:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'name' @ [554:16] ==> value-parameter name: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateUnaryAndCheck[ValueParameterDescriptorImpl]

'name' @ [554:35] ==> value-parameter name: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateUnaryAndCheck[ValueParameterDescriptorImpl]

'receiver' @ [556:13] ==> value-parameter receiver: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateUnaryAndCheck[ValueParameterDescriptorImpl]

'value' @ [556:22] ==> public final val value: Any defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'result' @ [556:31] ==> val result: Any defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateUnaryAndCheck[LocalVariableDescriptor]

'!' @ [556:41] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isZero' @ [556:42] ==> private final fun isZero(value: Any?): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'receiver' @ [556:49] ==> value-parameter receiver: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateUnaryAndCheck[ValueParameterDescriptorImpl]

'value' @ [556:58] ==> public final val value: Any defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'trace' @ [557:13] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'report' @ [557:19] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'INTEGER_OVERFLOW' @ [557:33] ==> public final val INTEGER_OVERFLOW: (DiagnosticFactory0<(KtExpression..KtExpression?)>..DiagnosticFactory0<(KtExpression..KtExpression?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [557:50] ==> @NotNull public open fun on(@NotNull element: KtExpression): SimpleDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'callExpression' @ [557:53] ==> value-parameter callExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateUnaryAndCheck[ValueParameterDescriptorImpl]

'getStrictParentOfType' @ [557:68] ==> public inline fun <reified T : PsiElement> PsiElement.getStrictParentOfType(): KtExpression? defined in org.jetbrains.kotlin.psi.psiUtil[SimpleFunctionDescriptorImpl]
Inferred types:
    <reified T : PsiElement> -> KtExpression

'callExpression' @ [557:109] ==> value-parameter callExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateUnaryAndCheck[ValueParameterDescriptorImpl]

'result' @ [559:16] ==> val result: Any defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateUnaryAndCheck[LocalVariableDescriptor]

'getBinaryOperation' @ [563:25] ==> private final fun getBinaryOperation(receiver: ConstantExpressionEvaluatorVisitor.OperationArgument, parameter: ConstantExpressionEvaluatorVisitor.OperationArgument, name: String): Pair<(Any?, Any?) -> Any, (BigInteger, BigInteger) -> BigInteger>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'receiver' @ [563:44] ==> value-parameter receiver: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck[ValueParameterDescriptorImpl]

'parameter' @ [563:54] ==> value-parameter parameter: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck[ValueParameterDescriptorImpl]

'name' @ [563:65] ==> value-parameter name: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck[ValueParameterDescriptorImpl]

'component1' @ [565:14] ==> public final operator fun component1(): (Any?, Any?) -> Any defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [565:24] ==> public final operator fun component2(): (BigInteger, BigInteger) -> BigInteger defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'functions' @ [565:35] ==> val functions: Pair<(Any?, Any?) -> Any, (BigInteger, BigInteger) -> BigInteger> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck[LocalVariableDescriptor]

'invoke' @ [567:13] ==> public abstract operator fun invoke(p1: Any?, p2: Any?): Any defined in kotlin.Function2[FunctionInvokeDescriptor]

'receiver' @ [567:22] ==> value-parameter receiver: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck[ValueParameterDescriptorImpl]

'value' @ [567:31] ==> public final val value: Any defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'parameter' @ [567:38] ==> value-parameter parameter: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck[ValueParameterDescriptorImpl]

'value' @ [567:48] ==> public final val value: Any defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'checker' @ [572:13] ==> val checker: (BigInteger, BigInteger) -> BigInteger defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck[LocalVariableDescriptor]

'emptyBinaryFun' @ [572:24] ==> internal val emptyBinaryFun: (BigInteger, BigInteger) -> BigInteger defined in org.jetbrains.kotlin.resolve.constants.evaluate in file OperationsMapGenerated.kt[PropertyDescriptorImpl]

'actualResult' @ [573:20] ==> val actualResult: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck[LocalVariableDescriptor]

'assert' @ [575:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'isIntegerType' @ [575:17] ==> public fun isIntegerType(value: Any?): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate[SimpleFunctionDescriptorImpl]

'receiver' @ [575:31] ==> value-parameter receiver: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck[ValueParameterDescriptorImpl]

'value' @ [575:40] ==> public final val value: Any defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'isIntegerType' @ [575:50] ==> public fun isIntegerType(value: Any?): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate[SimpleFunctionDescriptorImpl]

'parameter' @ [575:64] ==> value-parameter parameter: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck[ValueParameterDescriptorImpl]

'value' @ [575:74] ==> public final val value: Any defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'valueOf' @ [577:52] ==> public open fun valueOf(p0: Long): (BigInteger..BigInteger?) defined in java.math.BigInteger[JavaMethodDescriptor]

'value' @ [577:61] ==> value-parameter value: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck.toBigInteger[ValueParameterDescriptorImpl]

'toLong' @ [577:78] ==> public abstract fun toLong(): Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor]

'if (name == OperatorNameConventions.MOD.asString()) {
            getBinaryOperation(receiver, parameter, OperatorNameConventions.REM.asString())?.second ?: return null
        }
        else {
            checker
        }' @ [579:30] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (BigInteger, BigInteger) -> BigInteger, elseBranch: (BigInteger, BigInteger) -> BigInteger): (BigInteger, BigInteger) -> BigInteger[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Function2<BigInteger, BigInteger, BigInteger>

'name' @ [579:34] ==> value-parameter name: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck[ValueParameterDescriptorImpl]

'OperatorNameConventions' @ [579:42] ==> public object OperatorNameConventions defined in org.jetbrains.kotlin.util[FakeCallableDescriptorForObject]

'MOD' @ [579:66] ==> @field:JvmField public final val MOD: Name defined in org.jetbrains.kotlin.util.OperatorNameConventions[DeserializedPropertyDescriptor]

'asString' @ [579:70] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'getBinaryOperation' @ [580:13] ==> private final fun getBinaryOperation(receiver: ConstantExpressionEvaluatorVisitor.OperationArgument, parameter: ConstantExpressionEvaluatorVisitor.OperationArgument, name: String): Pair<(Any?, Any?) -> Any, (BigInteger, BigInteger) -> BigInteger>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'receiver' @ [580:32] ==> value-parameter receiver: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck[ValueParameterDescriptorImpl]

'parameter' @ [580:42] ==> value-parameter parameter: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck[ValueParameterDescriptorImpl]

'OperatorNameConventions' @ [580:53] ==> public object OperatorNameConventions defined in org.jetbrains.kotlin.util[FakeCallableDescriptorForObject]

'REM' @ [580:77] ==> @field:JvmField public final val REM: Name defined in org.jetbrains.kotlin.util.OperatorNameConventions[DeserializedPropertyDescriptor]

'asString' @ [580:81] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'second' @ [580:94] ==> public final val second: (BigInteger, BigInteger) -> BigInteger defined in kotlin.Pair[DeserializedPropertyDescriptor]

'checker' @ [583:13] ==> val checker: (BigInteger, BigInteger) -> BigInteger defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck[LocalVariableDescriptor]

'invoke' @ [586:35] ==> public abstract operator fun invoke(p1: BigInteger, p2: BigInteger): BigInteger defined in kotlin.Function2[FunctionInvokeDescriptor]

'toBigInteger' @ [586:50] ==> local final fun toBigInteger(value: Any?): (BigInteger..BigInteger?) defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck[SimpleFunctionDescriptorImpl]

'receiver' @ [586:63] ==> value-parameter receiver: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck[ValueParameterDescriptorImpl]

'value' @ [586:72] ==> public final val value: Any defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'toBigInteger' @ [586:80] ==> local final fun toBigInteger(value: Any?): (BigInteger..BigInteger?) defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck[SimpleFunctionDescriptorImpl]

'parameter' @ [586:93] ==> value-parameter parameter: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck[ValueParameterDescriptorImpl]

'value' @ [586:103] ==> public final val value: Any defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'toBigInteger' @ [588:13] ==> local final fun toBigInteger(value: Any?): (BigInteger..BigInteger?) defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck[SimpleFunctionDescriptorImpl]

'actualResult' @ [588:26] ==> val actualResult: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck[LocalVariableDescriptor]

'resultInBigIntegers' @ [588:43] ==> val resultInBigIntegers: BigInteger defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck[LocalVariableDescriptor]

'trace' @ [589:13] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'report' @ [589:19] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'INTEGER_OVERFLOW' @ [589:33] ==> public final val INTEGER_OVERFLOW: (DiagnosticFactory0<(KtExpression..KtExpression?)>..DiagnosticFactory0<(KtExpression..KtExpression?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [589:50] ==> @NotNull public open fun on(@NotNull element: KtExpression): SimpleDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'callExpression' @ [589:53] ==> value-parameter callExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck[ValueParameterDescriptorImpl]

'getStrictParentOfType' @ [589:68] ==> public inline fun <reified T : PsiElement> PsiElement.getStrictParentOfType(): KtExpression? defined in org.jetbrains.kotlin.psi.psiUtil[SimpleFunctionDescriptorImpl]
Inferred types:
    <reified T : PsiElement> -> KtExpression

'callExpression' @ [589:109] ==> value-parameter callExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck[ValueParameterDescriptorImpl]

'actualResult' @ [591:16] ==> val actualResult: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.evaluateBinaryAndCheck[LocalVariableDescriptor]

'binaryOperations' @ [595:13] ==> internal val binaryOperations: HashMap<BinaryOperationKey<*, *>, Pair<(Any?, Any?) -> Any, (BigInteger, BigInteger) -> BigInteger>> defined in org.jetbrains.kotlin.resolve.constants.evaluate in file OperationsMapGenerated.kt[PropertyDescriptorImpl]

'BinaryOperationKey' @ [595:30] ==> public constructor BinaryOperationKey<out A, out B>(f: CompileTimeType<out Any?>, s: CompileTimeType<out Any?>, functionName: String) defined in org.jetbrains.kotlin.resolve.constants.evaluate.BinaryOperationKey[ClassConstructorDescriptorImpl]
Inferred types:
    <out A> -> Any?
    <out B> -> Any?

'receiver' @ [595:49] ==> value-parameter receiver: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.getBinaryOperation[ValueParameterDescriptorImpl]

'ctcType' @ [595:58] ==> public final val ctcType: CompileTimeType<*> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'parameter' @ [595:67] ==> value-parameter parameter: ConstantExpressionEvaluatorVisitor.OperationArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.getBinaryOperation[ValueParameterDescriptorImpl]

'ctcType' @ [595:77] ==> public final val ctcType: CompileTimeType<*> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[PropertyDescriptorImpl]

'name' @ [595:86] ==> value-parameter name: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.getBinaryOperation[ValueParameterDescriptorImpl]

'name' @ [598:16] ==> value-parameter name: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.isDivisionByZero[ValueParameterDescriptorImpl]

'DIVISION_OPERATION_NAMES' @ [598:24] ==> private val DIVISION_OPERATION_NAMES: Set<String> defined in org.jetbrains.kotlin.resolve.constants.evaluate in file ConstantExpressionEvaluator.kt[PropertyDescriptorImpl]

'isZero' @ [598:52] ==> private final fun isZero(value: Any?): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'parameter' @ [598:59] ==> value-parameter parameter: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.isDivisionByZero[ValueParameterDescriptorImpl]

'when {
            isIntegerType(value) -> (value as Number).toLong() == 0L
            value is Float || value is Double -> (value as Number).toDouble() == 0.0
            else -> false
        }' @ [602:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean, entry2: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'isIntegerType' @ [603:13] ==> public fun isIntegerType(value: Any?): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate[SimpleFunctionDescriptorImpl]

'value' @ [603:27] ==> value-parameter value: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.isZero[ValueParameterDescriptorImpl]

'==' @ [603:37] ==> public open fun equals(other: Any?): Boolean defined in kotlin.Long[DeserializedSimpleFunctionDescriptor]

'value' @ [603:38] ==> value-parameter value: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.isZero[ValueParameterDescriptorImpl]

'toLong' @ [603:55] ==> public abstract fun toLong(): Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor]

'value' @ [604:13] ==> value-parameter value: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.isZero[ValueParameterDescriptorImpl]

'value' @ [604:31] ==> value-parameter value: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.isZero[ValueParameterDescriptorImpl]

'==' @ [604:50] ==> public open fun equals(other: Any?): Boolean defined in kotlin.Double[DeserializedSimpleFunctionDescriptor]

'value' @ [604:51] ==> value-parameter value: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.isZero[ValueParameterDescriptorImpl]

'toDouble' @ [604:68] ==> public abstract fun toDouble(): Double defined in kotlin.Number[DeserializedSimpleFunctionDescriptor]

'expression' @ [610:30] ==> value-parameter expression: KtUnaryExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitUnaryExpression[ValueParameterDescriptorImpl]

'baseExpression' @ [610:41] ==> public final val KtUnaryExpression.baseExpression: KtExpression?[MyPropertyDescriptor]

'evaluateCall' @ [612:16] ==> private final fun evaluateCall(callExpression: KtExpression, receiverExpression: KtExpression, expectedType: KotlinType?): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'expression' @ [612:29] ==> value-parameter expression: KtUnaryExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitUnaryExpression[ValueParameterDescriptorImpl]

'operationReference' @ [612:40] ==> public final val KtUnaryExpression.operationReference: KtSimpleNameExpression[MyPropertyDescriptor]

'leftExpression' @ [612:60] ==> val leftExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitUnaryExpression[LocalVariableDescriptor]

'expectedType' @ [612:76] ==> value-parameter expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitUnaryExpression[ValueParameterDescriptorImpl]

'trace' @ [616:30] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'bindingContext' @ [616:36] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'get' @ [616:51] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(slice: (ReadOnlySlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..ReadOnlySlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?), key: (KtReferenceExpression..KtReferenceExpression?)): DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> KtReferenceExpression
    <V : (Any..Any?)> -> DeclarationDescriptor

'REFERENCE_TARGET' @ [616:70] ==> public final val REFERENCE_TARGET: (WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'expression' @ [616:88] ==> value-parameter expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitSimpleNameExpression[ValueParameterDescriptorImpl]

'enumDescriptor' @ [617:13] ==> val enumDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitSimpleNameExpression[LocalVariableDescriptor]

'isEnumEntry' @ [617:55] ==> public open fun isEnumEntry(@NotNull p0: DeclarationDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'enumDescriptor' @ [617:67] ==> val enumDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitSimpleNameExpression[LocalVariableDescriptor]

'factory' @ [618:20] ==> private final val factory: ConstantValueFactory defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'createEnumValue' @ [618:28] ==> public final fun createEnumValue(enumEntryClass: ClassDescriptor): EnumValue defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[DeserializedSimpleFunctionDescriptor]

'enumDescriptor' @ [618:44] ==> val enumDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitSimpleNameExpression[LocalVariableDescriptor]

'wrap' @ [618:79] ==> private final fun <T> ConstantValue<ClassDescriptor>.wrap(canBeUsedInAnnotation: Boolean = ..., isPure: Boolean = ..., usesVariableAsConstant: Boolean = ..., usesNonConstValAsConstant: Boolean = ...): TypedCompileTimeConstant<ClassDescriptor> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> ClassDescriptor

'expression' @ [621:28] ==> value-parameter expression: KtSimpleNameExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitSimpleNameExpression[ValueParameterDescriptorImpl]

'getResolvedCall' @ [621:39] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[SimpleFunctionDescriptorImpl]

'trace' @ [621:55] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'bindingContext' @ [621:61] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'resolvedCall' @ [622:13] ==> val resolvedCall: ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitSimpleNameExpression[LocalVariableDescriptor]

'resolvedCall' @ [623:38] ==> val resolvedCall: ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitSimpleNameExpression[LocalVariableDescriptor]

'resultingDescriptor' @ [623:51] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.resultingDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'callableDescriptor' @ [624:17] ==> val callableDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitSimpleNameExpression[LocalVariableDescriptor]

'callableDescriptor' @ [626:21] ==> val callableDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitSimpleNameExpression[LocalVariableDescriptor]

'callableDescriptor' @ [626:65] ==> val callableDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitSimpleNameExpression[LocalVariableDescriptor]

'modality' @ [626:84] ==> public final val PropertyDescriptor.modality: Modality[MyPropertyDescriptor]

'Modality' @ [626:96] ==> public companion object defined in org.jetbrains.kotlin.descriptors.Modality[FakeCallableDescriptorForObject]

'FINAL' @ [626:105] ==> enum entry FINAL defined in org.jetbrains.kotlin.descriptors.Modality[FakeCallableDescriptorForObject]

'callableDescriptor' @ [628:43] ==> val callableDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitSimpleNameExpression[LocalVariableDescriptor]

'compileTimeInitializer' @ [628:62] ==> public final val VariableDescriptor.compileTimeInitializer: ConstantValue<*>?[MyPropertyDescriptor]

'createConstant' @ [630:24] ==> private final fun createConstant(value: Any?, expectedType: KotlinType?, parameters: CompileTimeConstant.Parameters): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'variableInitializer' @ [631:25] ==> val variableInitializer: ConstantValue<Any?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitSimpleNameExpression[LocalVariableDescriptor]

'value' @ [631:45] ==> public open val value: Any? defined in org.jetbrains.kotlin.resolve.constants.ConstantValue[DeserializedPropertyDescriptor]

'expectedType' @ [632:25] ==> value-parameter expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitSimpleNameExpression[ValueParameterDescriptorImpl]

'Parameters' @ [633:45] ==> public constructor Parameters(canBeUsedInAnnotation: Boolean, isPure: Boolean, usesVariableAsConstant: Boolean, usesNonConstValAsConstant: Boolean) defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant.Parameters[DeserializedClassConstructorDescriptor]

'isPropertyCompileTimeConstant' @ [634:57] ==> private final fun isPropertyCompileTimeConstant(descriptor: VariableDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'callableDescriptor' @ [634:87] ==> val callableDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitSimpleNameExpression[LocalVariableDescriptor]

'!' @ [637:61] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'callableDescriptor' @ [637:62] ==> val callableDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitSimpleNameExpression[LocalVariableDescriptor]

'isConst' @ [637:81] ==> public final val VariableDescriptor.isConst: Boolean[MyPropertyDescriptor]

'descriptor' @ [647:13] ==> value-parameter descriptor: VariableDescriptor defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.isPropertyCompileTimeConstant[ValueParameterDescriptorImpl]

'isVar' @ [647:24] ==> public final val VariableDescriptor.isVar: Boolean[MyPropertyDescriptor]

'isObject' @ [650:29] ==> public open fun isObject(@Nullable p0: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'descriptor' @ [650:38] ==> value-parameter descriptor: VariableDescriptor defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.isPropertyCompileTimeConstant[ValueParameterDescriptorImpl]

'containingDeclaration' @ [650:49] ==> public final val VariableDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'isStaticDeclaration' @ [651:29] ==> public open fun isStaticDeclaration(@NotNull p0: CallableDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'descriptor' @ [651:49] ==> value-parameter descriptor: VariableDescriptor defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.isPropertyCompileTimeConstant[ValueParameterDescriptorImpl]

'descriptor' @ [652:20] ==> value-parameter descriptor: VariableDescriptor defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.isPropertyCompileTimeConstant[ValueParameterDescriptorImpl]

'type' @ [652:31] ==> public final val VariableDescriptor.type: KotlinType[MyPropertyDescriptor]

'canBeUsedForConstVal' @ [652:36] ==> public fun KotlinType.canBeUsedForConstVal(): Boolean defined in org.jetbrains.kotlin.descriptors[DeserializedSimpleFunctionDescriptor]

'expression' @ [658:34] ==> value-parameter expression: KtQualifiedExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitQualifiedExpression[ValueParameterDescriptorImpl]

'selectorExpression' @ [658:45] ==> public open val selectorExpression: KtExpression? defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[PropertyDescriptorImpl]

'selectorExpression' @ [660:13] ==> val selectorExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitQualifiedExpression[LocalVariableDescriptor]

'evaluate' @ [661:38] ==> public final fun evaluate(expression: KtExpression, expectedType: KotlinType?): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'selectorExpression' @ [661:47] ==> val selectorExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitQualifiedExpression[LocalVariableDescriptor]

'expectedType' @ [661:67] ==> value-parameter expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitQualifiedExpression[ValueParameterDescriptorImpl]

'qualifiedCallValue' @ [662:17] ==> val qualifiedCallValue: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitQualifiedExpression[LocalVariableDescriptor]

'qualifiedCallValue' @ [663:24] ==> val qualifiedCallValue: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitQualifiedExpression[LocalVariableDescriptor]

'selectorExpression' @ [666:36] ==> val selectorExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitQualifiedExpression[LocalVariableDescriptor]

'calleeExpression' @ [666:55] ==> public final val KtCallExpression.calleeExpression: KtExpression?[MyPropertyDescriptor]

'calleeExpression' @ [667:17] ==> val calleeExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitQualifiedExpression[LocalVariableDescriptor]

'expression' @ [671:38] ==> value-parameter expression: KtQualifiedExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitQualifiedExpression[ValueParameterDescriptorImpl]

'receiverExpression' @ [671:49] ==> public open val receiverExpression: KtExpression defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[PropertyDescriptorImpl]

'evaluateCall' @ [672:20] ==> private final fun evaluateCall(callExpression: KtExpression, receiverExpression: KtExpression, expectedType: KotlinType?): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'calleeExpression' @ [672:33] ==> val calleeExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitQualifiedExpression[LocalVariableDescriptor]

'receiverExpression' @ [672:51] ==> val receiverExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitQualifiedExpression[LocalVariableDescriptor]

'expectedType' @ [672:71] ==> value-parameter expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitQualifiedExpression[ValueParameterDescriptorImpl]

'selectorExpression' @ [675:13] ==> val selectorExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitQualifiedExpression[LocalVariableDescriptor]

'evaluateCall' @ [676:26] ==> private final fun evaluateCall(callExpression: KtExpression, receiverExpression: KtExpression, expectedType: KotlinType?): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'selectorExpression' @ [676:39] ==> val selectorExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitQualifiedExpression[LocalVariableDescriptor]

'expression' @ [676:59] ==> value-parameter expression: KtQualifiedExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitQualifiedExpression[ValueParameterDescriptorImpl]

'receiverExpression' @ [676:70] ==> public open val receiverExpression: KtExpression defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[PropertyDescriptorImpl]

'expectedType' @ [676:90] ==> value-parameter expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitQualifiedExpression[ValueParameterDescriptorImpl]

'result' @ [677:17] ==> val result: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitQualifiedExpression[LocalVariableDescriptor]

'result' @ [677:40] ==> val result: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitQualifiedExpression[LocalVariableDescriptor]

'selectorExpression' @ [681:13] ==> val selectorExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitQualifiedExpression[LocalVariableDescriptor]

'evaluate' @ [682:20] ==> public final fun evaluate(expression: KtExpression, expectedType: KotlinType?): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'selectorExpression' @ [682:29] ==> val selectorExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitQualifiedExpression[LocalVariableDescriptor]

'expectedType' @ [682:49] ==> value-parameter expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitQualifiedExpression[ValueParameterDescriptorImpl]

'expression' @ [689:20] ==> value-parameter expression: KtCallExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitCallExpression[ValueParameterDescriptorImpl]

'getResolvedCall' @ [689:31] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[SimpleFunctionDescriptorImpl]

'trace' @ [689:47] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'bindingContext' @ [689:53] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'call' @ [691:35] ==> val call: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitCallExpression[LocalVariableDescriptor]

'resultingDescriptor' @ [691:40] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.resultingDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'isArrayFunctionCall' @ [694:38] ==> public open fun isArrayFunctionCall(@NotNull resolvedCall: ResolvedCall<*>): Boolean defined in org.jetbrains.kotlin.resolve.CompileTimeConstantUtils[JavaMethodDescriptor]

'call' @ [694:58] ==> val call: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitCallExpression[LocalVariableDescriptor]

'createConstantValueForArrayFunctionCall' @ [695:20] ==> private final fun createConstantValueForArrayFunctionCall(call: ResolvedCall<*>): TypedCompileTimeConstant<List<ConstantValue<*>>>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'call' @ [695:60] ==> val call: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitCallExpression[LocalVariableDescriptor]

'resultingDescriptor' @ [699:13] ==> val resultingDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitCallExpression[LocalVariableDescriptor]

'resultingDescriptor' @ [700:52] ==> val resultingDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitCallExpression[LocalVariableDescriptor]

'constructedClass' @ [700:72] ==> public final val ConstructorDescriptor.constructedClass: ClassDescriptor[MyPropertyDescriptor]

'isAnnotationClass' @ [701:33] ==> public open fun isAnnotationClass(@Nullable p0: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'classDescriptor' @ [701:51] ==> val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitCallExpression[LocalVariableDescriptor]

'AnnotationDescriptorImpl' @ [702:34] ==> public constructor AnnotationDescriptorImpl(@NotNull p0: KotlinType, @NotNull p1: (MutableMap<(Name..Name?), (ConstantValue<*>..ConstantValue<*>?)>..Map<(Name..Name?), (ConstantValue<*>..ConstantValue<*>?)>), @NotNull p2: SourceElement) defined in org.jetbrains.kotlin.descriptors.annotations.AnnotationDescriptorImpl[JavaClassConstructorDescriptor]

'classDescriptor' @ [703:25] ==> val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitCallExpression[LocalVariableDescriptor]

'defaultType' @ [703:41] ==> public final val ClassDescriptor.defaultType: SimpleType[MyPropertyDescriptor]

'constantExpressionEvaluator' @ [704:25] ==> private final val constantExpressionEvaluator: ConstantExpressionEvaluator defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'resolveAnnotationArguments' @ [704:53] ==> internal final fun resolveAnnotationArguments(resolvedCall: ResolvedCall<*>, trace: BindingTrace): Map<Name, ConstantValue<*>> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[SimpleFunctionDescriptorImpl]

'call' @ [704:80] ==> val call: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitCallExpression[LocalVariableDescriptor]

'trace' @ [704:86] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'NO_SOURCE' @ [705:39] ==> public final val NO_SOURCE: (SourceElement..SourceElement?) defined in org.jetbrains.kotlin.descriptors.SourceElement[JavaPropertyDescriptor]

'AnnotationValue' @ [707:24] ==> public constructor AnnotationValue(value: AnnotationDescriptor) defined in org.jetbrains.kotlin.resolve.constants.AnnotationValue[DeserializedClassConstructorDescriptor]

'descriptor' @ [707:40] ==> val descriptor: AnnotationDescriptorImpl defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitCallExpression[LocalVariableDescriptor]

'wrap' @ [707:52] ==> private final fun <T> ConstantValue<AnnotationDescriptor>.wrap(canBeUsedInAnnotation: Boolean = ..., isPure: Boolean = ..., usesVariableAsConstant: Boolean = ..., usesNonConstValAsConstant: Boolean = ...): TypedCompileTimeConstant<AnnotationDescriptor> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> AnnotationDescriptor

'call' @ [717:26] ==> value-parameter call: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createConstantValueForArrayFunctionCall[ValueParameterDescriptorImpl]

'resultingDescriptor' @ [717:31] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.resultingDescriptor: (CallableDescriptor..CallableDescriptor?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'returnType' @ [717:51] ==> public final val CallableDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'constantExpressionEvaluator' @ [718:29] ==> private final val constantExpressionEvaluator: ConstantExpressionEvaluator defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'builtIns' @ [718:57] ==> internal final val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[PropertyDescriptorImpl]

'getArrayElementType' @ [718:66] ==> @NotNull public open fun getArrayElementType(@NotNull p0: KotlinType): KotlinType defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'returnType' @ [718:86] ==> val returnType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createConstantValueForArrayFunctionCall[LocalVariableDescriptor]

'call' @ [720:25] ==> value-parameter call: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createConstantValueForArrayFunctionCall[ValueParameterDescriptorImpl]

'valueArguments' @ [720:30] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.valueArguments: (MutableMap<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>..Map<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'values' @ [720:45] ==> public abstract val values: MutableCollection<(ResolvedValueArgument..ResolvedValueArgument?)> defined in kotlin.collections.MutableMap[DeserializedPropertyDescriptor]

'flatMap' @ [720:52] ==> public inline fun <T, R> Iterable<(ResolvedValueArgument..ResolvedValueArgument?)>.flatMap(transform: ((ResolvedValueArgument..ResolvedValueArgument?)) -> Iterable<CompileTimeConstant<*>?>): List<CompileTimeConstant<*>?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument..org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument?)
    <R> -> CompileTimeConstant<*>?

'resolveArguments' @ [720:62] ==> private final fun resolveArguments(valueArguments: List<ValueArgument>, expectedType: KotlinType): List<CompileTimeConstant<*>?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'it' @ [720:79] ==> value-parameter it: (ResolvedValueArgument..ResolvedValueArgument?) defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createConstantValueForArrayFunctionCall.<anonymous>[ValueParameterDescriptorImpl]

'arguments' @ [720:82] ==> public final val ResolvedValueArgument.arguments: (MutableList<(ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>)[MyPropertyDescriptor]

'componentType' @ [720:93] ==> val componentType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createConstantValueForArrayFunctionCall[LocalVariableDescriptor]

'arguments' @ [723:34] ==> val arguments: List<CompileTimeConstant<*>?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createConstantValueForArrayFunctionCall[LocalVariableDescriptor]

'filterNotNull' @ [723:44] ==> public fun <T : Any> Iterable<CompileTimeConstant<*>?>.filterNotNull(): List<CompileTimeConstant<*>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> CompileTimeConstant<*>

'factory' @ [725:16] ==> private final val factory: ConstantValueFactory defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'createArrayValue' @ [725:24] ==> public final fun createArrayValue(value: List<ConstantValue<*>>, type: KotlinType): ArrayValue defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[DeserializedSimpleFunctionDescriptor]

'evaluatedArguments' @ [725:41] ==> val evaluatedArguments: List<CompileTimeConstant<*>> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createConstantValueForArrayFunctionCall[LocalVariableDescriptor]

'map' @ [725:60] ==> public inline fun <T, R> Iterable<CompileTimeConstant<*>>.map(transform: (CompileTimeConstant<*>) -> ConstantValue<Any?>): List<ConstantValue<Any?>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> CompileTimeConstant<*>
    <R> -> ConstantValue<Any?>

'it' @ [725:66] ==> value-parameter it: CompileTimeConstant<*> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createConstantValueForArrayFunctionCall.<anonymous>[ValueParameterDescriptorImpl]

'toConstantValue' @ [725:69] ==> public abstract fun toConstantValue(expectedType: KotlinType): ConstantValue<Any?> defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant[DeserializedSimpleFunctionDescriptor]

'componentType' @ [725:85] ==> val componentType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createConstantValueForArrayFunctionCall[LocalVariableDescriptor]

'returnType' @ [725:103] ==> val returnType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createConstantValueForArrayFunctionCall[LocalVariableDescriptor]

'wrap' @ [726:18] ==> private final fun <T> ConstantValue<List<ConstantValue<*>>>.wrap(canBeUsedInAnnotation: Boolean = ..., isPure: Boolean = ..., usesVariableAsConstant: Boolean = ..., usesNonConstValAsConstant: Boolean = ...): TypedCompileTimeConstant<List<ConstantValue<*>>> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> List<ConstantValue<*>>

'evaluatedArguments' @ [727:50] ==> val evaluatedArguments: List<CompileTimeConstant<*>> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createConstantValueForArrayFunctionCall[LocalVariableDescriptor]

'any' @ [727:69] ==> public inline fun <T> Iterable<CompileTimeConstant<*>>.any(predicate: (CompileTimeConstant<*>) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> CompileTimeConstant<*>

'it' @ [727:75] ==> value-parameter it: CompileTimeConstant<*> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createConstantValueForArrayFunctionCall.<anonymous>[ValueParameterDescriptorImpl]

'usesVariableAsConstant' @ [727:78] ==> public open val usesVariableAsConstant: Boolean defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant[DeserializedPropertyDescriptor]

'arguments' @ [728:53] ==> val arguments: List<CompileTimeConstant<*>?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createConstantValueForArrayFunctionCall[LocalVariableDescriptor]

'any' @ [728:63] ==> public inline fun <T> Iterable<CompileTimeConstant<*>?>.any(predicate: (CompileTimeConstant<*>?) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> CompileTimeConstant<*>?

'it' @ [728:69] ==> value-parameter it: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createConstantValueForArrayFunctionCall.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [728:83] ==> value-parameter it: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createConstantValueForArrayFunctionCall.<anonymous>[ValueParameterDescriptorImpl]

'usesNonConstValAsConstant' @ [728:86] ==> public open val usesNonConstValAsConstant: Boolean defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant[DeserializedPropertyDescriptor]

'trace' @ [733:20] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'getType' @ [733:26] ==> @Nullable public abstract fun getType(@NotNull expression: KtExpression): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'expression' @ [733:34] ==> value-parameter expression: KtClassLiteralExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitClassLiteralExpression[ValueParameterDescriptorImpl]

'type' @ [734:13] ==> val type: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitClassLiteralExpression[LocalVariableDescriptor]

'isError' @ [734:18] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types[DeserializedPropertyDescriptor]

'KClassValue' @ [735:16] ==> public constructor KClassValue(type: KotlinType) defined in org.jetbrains.kotlin.resolve.constants.KClassValue[DeserializedClassConstructorDescriptor]

'type' @ [735:28] ==> val type: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.visitClassLiteralExpression[LocalVariableDescriptor]

'wrap' @ [735:34] ==> private final fun <T> ConstantValue<KotlinType>.wrap(canBeUsedInAnnotation: Boolean = ..., isPure: Boolean = ..., usesVariableAsConstant: Boolean = ..., usesNonConstValAsConstant: Boolean = ...): TypedCompileTimeConstant<KotlinType> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> KotlinType

'arrayListOf' @ [739:25] ==> @SinceKotlin @InlineOnly public inline fun <T> arrayListOf(): ArrayList<CompileTimeConstant<*>?> /* = ArrayList<CompileTimeConstant<*>?> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> CompileTimeConstant<*>?

'valueArguments' @ [740:26] ==> value-parameter valueArguments: List<ValueArgument> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.resolveArguments[ValueParameterDescriptorImpl]

'argument' @ [741:38] ==> val argument: ValueArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.resolveArguments[LocalVariableDescriptor]

'getArgumentExpression' @ [741:47] ==> @IfNotParsed public abstract fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.ValueArgument[SimpleFunctionDescriptorImpl]

'argumentExpression' @ [742:17] ==> val argumentExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.resolveArguments[LocalVariableDescriptor]

'constants' @ [743:17] ==> val constants: ArrayList<CompileTimeConstant<*>?> /* = ArrayList<CompileTimeConstant<*>?> */ defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.resolveArguments[LocalVariableDescriptor]

'add' @ [743:27] ==> public open fun add(element: CompileTimeConstant<*>?): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'evaluate' @ [743:31] ==> public final fun evaluate(expression: KtExpression, expectedType: KotlinType?): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'argumentExpression' @ [743:40] ==> val argumentExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.resolveArguments[LocalVariableDescriptor]

'expectedType' @ [743:60] ==> value-parameter expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.resolveArguments[ValueParameterDescriptorImpl]

'constants' @ [746:16] ==> val constants: ArrayList<CompileTimeConstant<*>?> /* = ArrayList<CompileTimeConstant<*>?> */ defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.resolveArguments[LocalVariableDescriptor]

'getReceiverExpressionType' @ [756:38] ==> private fun getReceiverExpressionType(resolvedCall: ResolvedCall<*>): KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate in file ConstantExpressionEvaluator.kt[SimpleFunctionDescriptorImpl]

'resolvedCall' @ [756:64] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createOperationArgumentForReceiver[ValueParameterDescriptorImpl]

'getCompileTimeType' @ [758:39] ==> private final fun getCompileTimeType(c: KotlinType): CompileTimeType<out Any>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'receiverExpressionType' @ [758:58] ==> val receiverExpressionType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createOperationArgumentForReceiver[LocalVariableDescriptor]

'createOperationArgument' @ [760:16] ==> private final fun createOperationArgument(expression: KtExpression, parameterType: KotlinType, compileTimeType: CompileTimeType<*>): ConstantExpressionEvaluatorVisitor.OperationArgument? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'expression' @ [760:40] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createOperationArgumentForReceiver[ValueParameterDescriptorImpl]

'receiverExpressionType' @ [760:52] ==> val receiverExpressionType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createOperationArgumentForReceiver[LocalVariableDescriptor]

'receiverCompileTimeType' @ [760:76] ==> val receiverCompileTimeType: CompileTimeType<out Any> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createOperationArgumentForReceiver[LocalVariableDescriptor]

'getCompileTimeType' @ [764:39] ==> private final fun getCompileTimeType(c: KotlinType): CompileTimeType<out Any>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'parameter' @ [764:58] ==> value-parameter parameter: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createOperationArgumentForFirstParameter[ValueParameterDescriptorImpl]

'type' @ [764:68] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'argument' @ [766:25] ==> value-parameter argument: ResolvedValueArgument defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createOperationArgumentForFirstParameter[ValueParameterDescriptorImpl]

'arguments' @ [766:34] ==> public final val ResolvedValueArgument.arguments: (MutableList<(ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>)[MyPropertyDescriptor]

'arguments' @ [767:13] ==> val arguments: (MutableList<(ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>) defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createOperationArgumentForFirstParameter[LocalVariableDescriptor]

'size' @ [767:23] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'arguments' @ [769:34] ==> val arguments: (MutableList<(ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>) defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createOperationArgumentForFirstParameter[LocalVariableDescriptor]

'first' @ [769:44] ==> public fun <T> List<(ValueArgument..ValueArgument?)>.first(): (ValueArgument..ValueArgument?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)

'getArgumentExpression' @ [769:52] ==> @IfNotParsed public abstract fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.ValueArgument[SimpleFunctionDescriptorImpl]

'createOperationArgument' @ [771:16] ==> private final fun createOperationArgument(expression: KtExpression, parameterType: KotlinType, compileTimeType: CompileTimeType<*>): ConstantExpressionEvaluatorVisitor.OperationArgument? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'argumentExpression' @ [771:40] ==> val argumentExpression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createOperationArgumentForFirstParameter[LocalVariableDescriptor]

'parameter' @ [771:60] ==> value-parameter parameter: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createOperationArgumentForFirstParameter[ValueParameterDescriptorImpl]

'type' @ [771:70] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'argumentCompileTimeType' @ [771:76] ==> val argumentCompileTimeType: CompileTimeType<out Any> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createOperationArgumentForFirstParameter[LocalVariableDescriptor]

'constantExpressionEvaluator' @ [776:24] ==> private final val constantExpressionEvaluator: ConstantExpressionEvaluator defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'builtIns' @ [776:52] ==> internal final val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[PropertyDescriptorImpl]

'when (TypeUtils.makeNotNullable(c)) {
            builtIns.intType -> INT
            builtIns.byteType -> BYTE
            builtIns.shortType -> SHORT
            builtIns.longType -> LONG
            builtIns.doubleType -> DOUBLE
            builtIns.floatType -> FLOAT
            builtIns.charType -> CHAR
            builtIns.booleanType -> BOOLEAN
            builtIns.stringType -> STRING
            builtIns.anyType -> ANY
            else -> null
        }' @ [777:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: CompileTimeType<out Any>?, entry1: CompileTimeType<out Any>?, entry2: CompileTimeType<out Any>?, entry3: CompileTimeType<out Any>?, entry4: CompileTimeType<out Any>?, entry5: CompileTimeType<out Any>?, entry6: CompileTimeType<out Any>?, entry7: CompileTimeType<out Any>?, entry8: CompileTimeType<out Any>?, entry9: CompileTimeType<out Any>?, entry10: CompileTimeType<out Any>?): CompileTimeType<out Any>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> CompileTimeType<out Any>?

'makeNotNullable' @ [777:32] ==> @NotNull public open fun makeNotNullable(@NotNull p0: KotlinType): KotlinType defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'c' @ [777:48] ==> value-parameter c: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.getCompileTimeType[ValueParameterDescriptorImpl]

'builtIns' @ [778:13] ==> val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.getCompileTimeType[LocalVariableDescriptor]

'intType' @ [778:22] ==> public final val KotlinBuiltIns.intType: SimpleType[MyPropertyDescriptor]

'INT' @ [778:33] ==> internal val INT: CompileTimeType<Int> defined in org.jetbrains.kotlin.resolve.constants.evaluate in file ConstantExpressionEvaluator.kt[PropertyDescriptorImpl]

'builtIns' @ [779:13] ==> val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.getCompileTimeType[LocalVariableDescriptor]

'byteType' @ [779:22] ==> public final val KotlinBuiltIns.byteType: SimpleType[MyPropertyDescriptor]

'BYTE' @ [779:34] ==> internal val BYTE: CompileTimeType<Byte> defined in org.jetbrains.kotlin.resolve.constants.evaluate in file ConstantExpressionEvaluator.kt[PropertyDescriptorImpl]

'builtIns' @ [780:13] ==> val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.getCompileTimeType[LocalVariableDescriptor]

'shortType' @ [780:22] ==> public final val KotlinBuiltIns.shortType: SimpleType[MyPropertyDescriptor]

'SHORT' @ [780:35] ==> internal val SHORT: CompileTimeType<Short> defined in org.jetbrains.kotlin.resolve.constants.evaluate in file ConstantExpressionEvaluator.kt[PropertyDescriptorImpl]

'builtIns' @ [781:13] ==> val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.getCompileTimeType[LocalVariableDescriptor]

'longType' @ [781:22] ==> public final val KotlinBuiltIns.longType: SimpleType[MyPropertyDescriptor]

'LONG' @ [781:34] ==> internal val LONG: CompileTimeType<Long> defined in org.jetbrains.kotlin.resolve.constants.evaluate in file ConstantExpressionEvaluator.kt[PropertyDescriptorImpl]

'builtIns' @ [782:13] ==> val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.getCompileTimeType[LocalVariableDescriptor]

'doubleType' @ [782:22] ==> public final val KotlinBuiltIns.doubleType: SimpleType[MyPropertyDescriptor]

'DOUBLE' @ [782:36] ==> internal val DOUBLE: CompileTimeType<Double> defined in org.jetbrains.kotlin.resolve.constants.evaluate in file ConstantExpressionEvaluator.kt[PropertyDescriptorImpl]

'builtIns' @ [783:13] ==> val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.getCompileTimeType[LocalVariableDescriptor]

'floatType' @ [783:22] ==> public final val KotlinBuiltIns.floatType: SimpleType[MyPropertyDescriptor]

'FLOAT' @ [783:35] ==> internal val FLOAT: CompileTimeType<Float> defined in org.jetbrains.kotlin.resolve.constants.evaluate in file ConstantExpressionEvaluator.kt[PropertyDescriptorImpl]

'builtIns' @ [784:13] ==> val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.getCompileTimeType[LocalVariableDescriptor]

'charType' @ [784:22] ==> public final val KotlinBuiltIns.charType: SimpleType[MyPropertyDescriptor]

'CHAR' @ [784:34] ==> internal val CHAR: CompileTimeType<Char> defined in org.jetbrains.kotlin.resolve.constants.evaluate in file ConstantExpressionEvaluator.kt[PropertyDescriptorImpl]

'builtIns' @ [785:13] ==> val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.getCompileTimeType[LocalVariableDescriptor]

'booleanType' @ [785:22] ==> public final val KotlinBuiltIns.booleanType: SimpleType[MyPropertyDescriptor]

'BOOLEAN' @ [785:37] ==> internal val BOOLEAN: CompileTimeType<Boolean> defined in org.jetbrains.kotlin.resolve.constants.evaluate in file ConstantExpressionEvaluator.kt[PropertyDescriptorImpl]

'builtIns' @ [786:13] ==> val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.getCompileTimeType[LocalVariableDescriptor]

'stringType' @ [786:22] ==> public final val KotlinBuiltIns.stringType: SimpleType[MyPropertyDescriptor]

'STRING' @ [786:36] ==> internal val STRING: CompileTimeType<String> defined in org.jetbrains.kotlin.resolve.constants.evaluate in file ConstantExpressionEvaluator.kt[PropertyDescriptorImpl]

'builtIns' @ [787:13] ==> val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.getCompileTimeType[LocalVariableDescriptor]

'anyType' @ [787:22] ==> public final val KotlinBuiltIns.anyType: SimpleType[MyPropertyDescriptor]

'ANY' @ [787:33] ==> internal val ANY: CompileTimeType<Any> defined in org.jetbrains.kotlin.resolve.constants.evaluate in file ConstantExpressionEvaluator.kt[PropertyDescriptorImpl]

'constantExpressionEvaluator' @ [793:35] ==> private final val constantExpressionEvaluator: ConstantExpressionEvaluator defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'evaluateExpression' @ [793:63] ==> public final fun evaluateExpression(expression: KtExpression, trace: BindingTrace, expectedType: KotlinType? = ...): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[SimpleFunctionDescriptorImpl]

'expression' @ [793:82] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createOperationArgument[ValueParameterDescriptorImpl]

'trace' @ [793:94] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'parameterType' @ [793:101] ==> value-parameter parameterType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createOperationArgument[ValueParameterDescriptorImpl]

'compileTimeConstant' @ [794:13] ==> val compileTimeConstant: CompileTimeConstant<Any?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createOperationArgument[LocalVariableDescriptor]

'!' @ [794:64] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'compileTimeConstant' @ [794:65] ==> val compileTimeConstant: CompileTimeConstant<Any?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createOperationArgument[LocalVariableDescriptor]

'type' @ [794:85] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.constants.TypedCompileTimeConstant[DeserializedPropertyDescriptor]

'isSubtypeOf' @ [794:90] ==> public fun KotlinType.isSubtypeOf(superType: KotlinType): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'parameterType' @ [794:102] ==> value-parameter parameterType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createOperationArgument[ValueParameterDescriptorImpl]

'compileTimeConstant' @ [795:32] ==> val compileTimeConstant: CompileTimeConstant<Any?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createOperationArgument[LocalVariableDescriptor]

'getValue' @ [795:52] ==> public open fun getValue(expectedType: KotlinType): Any? defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant[DeserializedSimpleFunctionDescriptor]

'parameterType' @ [795:61] ==> value-parameter parameterType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createOperationArgument[ValueParameterDescriptorImpl]

'OperationArgument' @ [796:16] ==> public constructor OperationArgument(value: Any, ctcType: CompileTimeType<*>, expression: KtExpression) defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.OperationArgument[ClassConstructorDescriptorImpl]

'evaluationResult' @ [796:34] ==> val evaluationResult: Any defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createOperationArgument[LocalVariableDescriptor]

'compileTimeType' @ [796:52] ==> value-parameter compileTimeType: CompileTimeType<*> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createOperationArgument[ValueParameterDescriptorImpl]

'expression' @ [796:69] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createOperationArgument[ValueParameterDescriptorImpl]

'if (parameters.isPure) {
            return createCompileTimeConstant(value, parameters, expectedType ?: TypeUtils.NO_EXPECTED_TYPE)
        }
        else {
            factory.createConstantValue(value)?.wrap(parameters)
        }' @ [804:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: CompileTimeConstant<*>?, elseBranch: CompileTimeConstant<*>?): CompileTimeConstant<*>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> CompileTimeConstant<*>?

'parameters' @ [804:20] ==> value-parameter parameters: CompileTimeConstant.Parameters defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createConstant[ValueParameterDescriptorImpl]

'isPure' @ [804:31] ==> public final val isPure: Boolean defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant.Parameters[DeserializedPropertyDescriptor]

'createCompileTimeConstant' @ [805:20] ==> private final fun createCompileTimeConstant(value: Any?, parameters: CompileTimeConstant.Parameters, expectedType: KotlinType): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'value' @ [805:46] ==> value-parameter value: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createConstant[ValueParameterDescriptorImpl]

'parameters' @ [805:53] ==> value-parameter parameters: CompileTimeConstant.Parameters defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createConstant[ValueParameterDescriptorImpl]

'expectedType' @ [805:65] ==> value-parameter expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createConstant[ValueParameterDescriptorImpl]

'NO_EXPECTED_TYPE' @ [805:91] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'factory' @ [808:13] ==> private final val factory: ConstantValueFactory defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'createConstantValue' @ [808:21] ==> public final fun createConstantValue(value: Any?): ConstantValue<*>? defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[DeserializedSimpleFunctionDescriptor]

'value' @ [808:41] ==> value-parameter value: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createConstant[ValueParameterDescriptorImpl]

'wrap' @ [808:49] ==> private final fun <T> ConstantValue<Any?>.wrap(parameters: CompileTimeConstant.Parameters): TypedCompileTimeConstant<Any?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> Any?

'parameters' @ [808:54] ==> value-parameter parameters: CompileTimeConstant.Parameters defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createConstant[ValueParameterDescriptorImpl]

'when (value) {
            is Byte, is Short, is Int, is Long -> createIntegerCompileTimeConstant((value as Number).toLong(), parameters, expectedType)
            else -> factory.createConstantValue(value)?.wrap(parameters)
        }' @ [817:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: CompileTimeConstant<*>?, entry1: CompileTimeConstant<*>?): CompileTimeConstant<*>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> CompileTimeConstant<*>?

'value' @ [817:22] ==> value-parameter value: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createCompileTimeConstant[ValueParameterDescriptorImpl]

'createIntegerCompileTimeConstant' @ [818:51] ==> private final fun createIntegerCompileTimeConstant(value: Long, parameters: CompileTimeConstant.Parameters, expectedType: KotlinType): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]

'value' @ [818:85] ==> value-parameter value: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createCompileTimeConstant[ValueParameterDescriptorImpl]

'toLong' @ [818:102] ==> public abstract fun toLong(): Long defined in kotlin.Number[DeserializedSimpleFunctionDescriptor]

'parameters' @ [818:112] ==> value-parameter parameters: CompileTimeConstant.Parameters defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createCompileTimeConstant[ValueParameterDescriptorImpl]

'expectedType' @ [818:124] ==> value-parameter expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createCompileTimeConstant[ValueParameterDescriptorImpl]

'factory' @ [819:21] ==> private final val factory: ConstantValueFactory defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'createConstantValue' @ [819:29] ==> public final fun createConstantValue(value: Any?): ConstantValue<*>? defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[DeserializedSimpleFunctionDescriptor]

'value' @ [819:49] ==> value-parameter value: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createCompileTimeConstant[ValueParameterDescriptorImpl]

'wrap' @ [819:57] ==> private final fun <T> ConstantValue<Any?>.wrap(parameters: CompileTimeConstant.Parameters): TypedCompileTimeConstant<Any?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> Any?

'parameters' @ [819:62] ==> value-parameter parameters: CompileTimeConstant.Parameters defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createCompileTimeConstant[ValueParameterDescriptorImpl]

'noExpectedType' @ [828:23] ==> public open fun noExpectedType(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'expectedType' @ [828:38] ==> value-parameter expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createIntegerCompileTimeConstant[ValueParameterDescriptorImpl]

'expectedType' @ [828:55] ==> value-parameter expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createIntegerCompileTimeConstant[ValueParameterDescriptorImpl]

'isError' @ [828:68] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types[DeserializedPropertyDescriptor]

'IntegerValueTypeConstant' @ [829:20] ==> public constructor IntegerValueTypeConstant(value: Number, builtIns: KotlinBuiltIns, parameters: CompileTimeConstant.Parameters) defined in org.jetbrains.kotlin.resolve.constants.IntegerValueTypeConstant[DeserializedClassConstructorDescriptor]

'value' @ [829:45] ==> value-parameter value: Long defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createIntegerCompileTimeConstant[ValueParameterDescriptorImpl]

'constantExpressionEvaluator' @ [829:52] ==> private final val constantExpressionEvaluator: ConstantExpressionEvaluator defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'builtIns' @ [829:80] ==> internal final val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[PropertyDescriptorImpl]

'parameters' @ [829:90] ==> value-parameter parameters: CompileTimeConstant.Parameters defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createIntegerCompileTimeConstant[ValueParameterDescriptorImpl]

'factory' @ [831:28] ==> private final val factory: ConstantValueFactory defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'createIntegerConstantValue' @ [831:36] ==> public final fun createIntegerConstantValue(value: Long, expectedType: KotlinType): ConstantValue<*>? defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[DeserializedSimpleFunctionDescriptor]

'value' @ [831:63] ==> value-parameter value: Long defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createIntegerCompileTimeConstant[ValueParameterDescriptorImpl]

'expectedType' @ [831:70] ==> value-parameter expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createIntegerCompileTimeConstant[ValueParameterDescriptorImpl]

'integerValue' @ [832:13] ==> val integerValue: ConstantValue<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createIntegerCompileTimeConstant[LocalVariableDescriptor]

'integerValue' @ [833:20] ==> val integerValue: ConstantValue<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createIntegerCompileTimeConstant[LocalVariableDescriptor]

'wrap' @ [833:33] ==> private final fun <T> ConstantValue<Any?>.wrap(parameters: CompileTimeConstant.Parameters): TypedCompileTimeConstant<Any?> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> Any?

'parameters' @ [833:38] ==> value-parameter parameters: CompileTimeConstant.Parameters defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createIntegerCompileTimeConstant[ValueParameterDescriptorImpl]

'when (value) {
            value.toInt().toLong() -> factory.createIntValue(value.toInt())
            else -> factory.createLongValue(value)
        }' @ [835:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: IntegerValueConstant<{Comparable<{Long & Int}> & Number}>, entry1: IntegerValueConstant<{Comparable<{Long & Int}> & Number}>): IntegerValueConstant<{Comparable<{Long & Int}> & Number}>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> IntegerValueConstant<{Comparable<{Long & Int}> & Number}>

'value' @ [835:22] ==> value-parameter value: Long defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createIntegerCompileTimeConstant[ValueParameterDescriptorImpl]

'value' @ [836:13] ==> value-parameter value: Long defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createIntegerCompileTimeConstant[ValueParameterDescriptorImpl]

'toInt' @ [836:19] ==> public open fun toInt(): Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor]

'toLong' @ [836:27] ==> public open fun toLong(): Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'factory' @ [836:39] ==> private final val factory: ConstantValueFactory defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'createIntValue' @ [836:47] ==> public final fun createIntValue(value: Int): IntValue defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[DeserializedSimpleFunctionDescriptor]

'value' @ [836:62] ==> value-parameter value: Long defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createIntegerCompileTimeConstant[ValueParameterDescriptorImpl]

'toInt' @ [836:68] ==> public open fun toInt(): Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor]

'factory' @ [837:21] ==> private final val factory: ConstantValueFactory defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[PropertyDescriptorImpl]

'createLongValue' @ [837:29] ==> public final fun createLongValue(value: Long): LongValue defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[DeserializedSimpleFunctionDescriptor]

'value' @ [837:45] ==> value-parameter value: Long defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createIntegerCompileTimeConstant[ValueParameterDescriptorImpl]

'wrap' @ [838:11] ==> private final fun <T> ConstantValue<{Comparable<{Long & Int}> & Number}>.wrap(parameters: CompileTimeConstant.Parameters): TypedCompileTimeConstant<{Comparable<{Long & Int}> & Number}> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> {Comparable<{Long & Int}> & Number}

'parameters' @ [838:16] ==> value-parameter parameters: CompileTimeConstant.Parameters defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.createIntegerCompileTimeConstant[ValueParameterDescriptorImpl]

'TypedCompileTimeConstant' @ [842:15] ==> public constructor TypedCompileTimeConstant<out T>(constantValue: ConstantValue<T>, parameters: CompileTimeConstant.Parameters) defined in org.jetbrains.kotlin.resolve.constants.TypedCompileTimeConstant[DeserializedClassConstructorDescriptor]
Inferred types:
    <out T> -> T

'this' @ [842:40] ==> <this> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.wrap[ReceiverParameterDescriptorImpl]

'parameters' @ [842:46] ==> value-parameter parameters: CompileTimeConstant.Parameters defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.wrap[ValueParameterDescriptorImpl]

'this' @ [845:46] ==> <this> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.wrap[ReceiverParameterDescriptorImpl]

'wrap' @ [850:15] ==> private final fun <T> ConstantValue<T>.wrap(parameters: CompileTimeConstant.Parameters): TypedCompileTimeConstant<T> defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> T

'Parameters' @ [850:40] ==> public constructor Parameters(canBeUsedInAnnotation: Boolean, isPure: Boolean, usesVariableAsConstant: Boolean, usesNonConstValAsConstant: Boolean) defined in org.jetbrains.kotlin.resolve.constants.CompileTimeConstant.Parameters[DeserializedClassConstructorDescriptor]

'canBeUsedInAnnotation' @ [850:51] ==> value-parameter canBeUsedInAnnotation: Boolean = ... defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.wrap[ValueParameterDescriptorImpl]

'isPure' @ [850:74] ==> value-parameter isPure: Boolean = ... defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.wrap[ValueParameterDescriptorImpl]

'usesVariableAsConstant' @ [850:82] ==> value-parameter usesVariableAsConstant: Boolean = ... defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.wrap[ValueParameterDescriptorImpl]

'usesNonConstValAsConstant' @ [850:106] ==> value-parameter usesNonConstValAsConstant: Boolean = ... defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluatorVisitor.wrap[ValueParameterDescriptorImpl]

'text' @ [853:43] ==> value-parameter text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.hasLongSuffix[ValueParameterDescriptorImpl]

'endsWith' @ [853:48] ==> public fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'text' @ [853:65] ==> value-parameter text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.hasLongSuffix[ValueParameterDescriptorImpl]

'endsWith' @ [853:70] ==> public fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'removeUnderscores' @ [856:43] ==> @NotNull public open fun removeUnderscores(@NotNull p0: String): String defined in com.intellij.util.text.LiteralFormatUtil[JavaMethodDescriptor]

'text' @ [856:61] ==> value-parameter text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseNumericLiteral[ValueParameterDescriptorImpl]

'when (type) {
        KtNodeTypes.INTEGER_CONSTANT -> parseLong(canonicalText)
        KtNodeTypes.FLOAT_CONSTANT -> parseFloatingLiteral(canonicalText)
        else -> null
    }' @ [857:12] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Any?, entry1: Any?, entry2: Any?): Any?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Any?

'type' @ [857:18] ==> value-parameter type: IElementType defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseNumericLiteral[ValueParameterDescriptorImpl]

'INTEGER_CONSTANT' @ [858:21] ==> public final val INTEGER_CONSTANT: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'parseLong' @ [858:41] ==> private fun parseLong(text: String): Long? defined in org.jetbrains.kotlin.resolve.constants.evaluate in file ConstantExpressionEvaluator.kt[SimpleFunctionDescriptorImpl]

'canonicalText' @ [858:51] ==> val canonicalText: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseNumericLiteral[LocalVariableDescriptor]

'FLOAT_CONSTANT' @ [859:21] ==> public final val FLOAT_CONSTANT: (KtNodeType..KtNodeType?) defined in org.jetbrains.kotlin.KtNodeTypes[JavaPropertyDescriptor]

'parseFloatingLiteral' @ [859:39] ==> private fun parseFloatingLiteral(text: String): Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate in file ConstantExpressionEvaluator.kt[SimpleFunctionDescriptorImpl]

'canonicalText' @ [859:60] ==> val canonicalText: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseNumericLiteral[LocalVariableDescriptor]

'if (hasLongSuffix(text)) s.substring(0, s.length - 1) else s' @ [866:46] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'hasLongSuffix' @ [866:50] ==> private fun hasLongSuffix(text: String): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate[SimpleFunctionDescriptorImpl]

'text' @ [866:64] ==> value-parameter text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseLong[ValueParameterDescriptorImpl]

's' @ [866:71] ==> value-parameter s: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseLong.substringLongSuffix[ValueParameterDescriptorImpl]

'substring' @ [866:73] ==> @InlineOnly public inline fun String.substring(startIndex: Int, endIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

's' @ [866:86] ==> value-parameter s: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseLong.substringLongSuffix[ValueParameterDescriptorImpl]

'length' @ [866:88] ==> public open val length: Int defined in kotlin.String[DeserializedPropertyDescriptor]

's' @ [866:105] ==> value-parameter s: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseLong.substringLongSuffix[ValueParameterDescriptorImpl]

'parseLong' @ [867:66] ==> public open fun parseLong(p0: (String..String?), p1: Int): Long defined in java.lang.Long[JavaMethodDescriptor]

'substringLongSuffix' @ [867:76] ==> local final fun substringLongSuffix(s: String): String defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseLong[SimpleFunctionDescriptorImpl]

'text' @ [867:96] ==> value-parameter text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseLong.parseLong[ValueParameterDescriptorImpl]

'radix' @ [867:103] ==> value-parameter radix: Int defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseLong.parseLong[ValueParameterDescriptorImpl]

'when {
            text.startsWith("0x") || text.startsWith("0X") -> parseLong(text.substring(2), 16)
            text.startsWith("0b") || text.startsWith("0B") -> parseLong(text.substring(2), 2)
            else -> parseLong(text, 10)
        }' @ [869:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Long?, entry1: Long?, entry2: Long?): Long?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Long?

'text' @ [870:13] ==> value-parameter text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseLong[ValueParameterDescriptorImpl]

'startsWith' @ [870:18] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'text' @ [870:38] ==> value-parameter text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseLong[ValueParameterDescriptorImpl]

'startsWith' @ [870:43] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'parseLong' @ [870:63] ==> local final fun parseLong(text: String, radix: Int): Long defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseLong[SimpleFunctionDescriptorImpl]

'text' @ [870:73] ==> value-parameter text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseLong[ValueParameterDescriptorImpl]

'substring' @ [870:78] ==> @InlineOnly public inline fun String.substring(startIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'text' @ [871:13] ==> value-parameter text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseLong[ValueParameterDescriptorImpl]

'startsWith' @ [871:18] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'text' @ [871:38] ==> value-parameter text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseLong[ValueParameterDescriptorImpl]

'startsWith' @ [871:43] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'parseLong' @ [871:63] ==> local final fun parseLong(text: String, radix: Int): Long defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseLong[SimpleFunctionDescriptorImpl]

'text' @ [871:73] ==> value-parameter text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseLong[ValueParameterDescriptorImpl]

'substring' @ [871:78] ==> @InlineOnly public inline fun String.substring(startIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'parseLong' @ [872:21] ==> local final fun parseLong(text: String, radix: Int): Long defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseLong[SimpleFunctionDescriptorImpl]

'text' @ [872:31] ==> value-parameter text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseLong[ValueParameterDescriptorImpl]

'text' @ [881:9] ==> value-parameter text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseFloatingLiteral[ValueParameterDescriptorImpl]

'toLowerCase' @ [881:14] ==> @InlineOnly public inline fun String.toLowerCase(): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'endsWith' @ [881:28] ==> public fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'parseFloat' @ [882:16] ==> private fun parseFloat(text: String): Float? defined in org.jetbrains.kotlin.resolve.constants.evaluate in file ConstantExpressionEvaluator.kt[SimpleFunctionDescriptorImpl]

'text' @ [882:27] ==> value-parameter text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseFloatingLiteral[ValueParameterDescriptorImpl]

'parseDouble' @ [884:12] ==> private fun parseDouble(text: String): Double? defined in org.jetbrains.kotlin.resolve.constants.evaluate in file ConstantExpressionEvaluator.kt[SimpleFunctionDescriptorImpl]

'text' @ [884:24] ==> value-parameter text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseFloatingLiteral[ValueParameterDescriptorImpl]

'parseDouble' @ [889:33] ==> public open fun parseDouble(p0: (String..String?)): Double defined in java.lang.Double[JavaMethodDescriptor]

'text' @ [889:45] ==> value-parameter text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseDouble[ValueParameterDescriptorImpl]

'parseFloat' @ [898:32] ==> public open fun parseFloat(p0: (String..String?)): Float defined in java.lang.Float[JavaMethodDescriptor]

'text' @ [898:43] ==> value-parameter text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseFloat[ValueParameterDescriptorImpl]

'if ("true".equals(text)) {
        return true
    }
    else if ("false".equals(text)) {
        return false
    }' @ [906:5] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'equals' @ [906:16] ==> public open fun equals(other: Any?): Boolean defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'text' @ [906:23] ==> value-parameter text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseBoolean[ValueParameterDescriptorImpl]

'equals' @ [909:22] ==> public open fun equals(other: Any?): Boolean defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'text' @ [909:29] ==> value-parameter text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseBoolean[ValueParameterDescriptorImpl]

'IllegalStateException' @ [913:11] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'+' @ [913:33] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'text' @ [913:83] ==> value-parameter text: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.parseBoolean[ValueParameterDescriptorImpl]

'result' @ [918:9] ==> value-parameter result: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForEquals[ValueParameterDescriptorImpl]

'assert' @ [919:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'operationReference' @ [919:16] ==> value-parameter operationReference: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForEquals[ValueParameterDescriptorImpl]

'operationReference' @ [920:31] ==> value-parameter operationReference: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForEquals[ValueParameterDescriptorImpl]

'getReferencedNameElementType' @ [920:77] ==> public abstract fun getReferencedNameElementType(): IElementType defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[SimpleFunctionDescriptorImpl]

'when (operationToken) {
            KtTokens.EQEQ -> result
            KtTokens.EXCLEQ -> !result
            KtTokens.IDENTIFIER -> {
                assert(operationReference.getReferencedNameAsName() == OperatorNameConventions.EQUALS) { "This method should be called only for equals operations" }
                result
            }
            else -> throw IllegalStateException("Unknown equals operation token: $operationToken ${operationReference.text}")
        }' @ [921:30] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean, entry2: Boolean, entry3: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'operationToken' @ [921:36] ==> val operationToken: IElementType defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForEquals[LocalVariableDescriptor]

'EQEQ' @ [922:22] ==> public final val EQEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'result' @ [922:30] ==> value-parameter result: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForEquals[ValueParameterDescriptorImpl]

'EXCLEQ' @ [923:22] ==> public final val EXCLEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'!' @ [923:32] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'result' @ [923:33] ==> value-parameter result: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForEquals[ValueParameterDescriptorImpl]

'IDENTIFIER' @ [924:22] ==> public final val IDENTIFIER: (KtToken..KtToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'assert' @ [925:17] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'operationReference' @ [925:24] ==> value-parameter operationReference: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForEquals[ValueParameterDescriptorImpl]

'getReferencedNameAsName' @ [925:43] ==> public abstract fun getReferencedNameAsName(): Name defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[SimpleFunctionDescriptorImpl]

'OperatorNameConventions' @ [925:72] ==> public object OperatorNameConventions defined in org.jetbrains.kotlin.util[FakeCallableDescriptorForObject]

'EQUALS' @ [925:96] ==> @field:JvmField public final val EQUALS: Name defined in org.jetbrains.kotlin.util.OperatorNameConventions[DeserializedPropertyDescriptor]

'result' @ [926:17] ==> value-parameter result: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForEquals[ValueParameterDescriptorImpl]

'IllegalStateException' @ [928:27] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'operationToken' @ [928:83] ==> val operationToken: IElementType defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForEquals[LocalVariableDescriptor]

'operationReference' @ [928:100] ==> value-parameter operationReference: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForEquals[ValueParameterDescriptorImpl]

'text' @ [928:119] ==> public final val KtSimpleNameExpression.text: (String..String?)[MyPropertyDescriptor]

'factory' @ [930:16] ==> value-parameter factory: ConstantValueFactory defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForEquals[ValueParameterDescriptorImpl]

'createBooleanValue' @ [930:24] ==> public final fun createBooleanValue(value: Boolean): BooleanValue defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[DeserializedSimpleFunctionDescriptor]

'value' @ [930:43] ==> val value: Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForEquals[LocalVariableDescriptor]

'result' @ [936:9] ==> value-parameter result: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForCompareTo[ValueParameterDescriptorImpl]

'assert' @ [937:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'operationReference' @ [937:16] ==> value-parameter operationReference: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForCompareTo[ValueParameterDescriptorImpl]

'operationReference' @ [938:31] ==> value-parameter operationReference: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForCompareTo[ValueParameterDescriptorImpl]

'getReferencedNameElementType' @ [938:77] ==> public abstract fun getReferencedNameElementType(): IElementType defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[SimpleFunctionDescriptorImpl]

'when (operationToken) {
            KtTokens.LT -> factory.createBooleanValue(result < 0)
            KtTokens.LTEQ -> factory.createBooleanValue(result <= 0)
            KtTokens.GT -> factory.createBooleanValue(result > 0)
            KtTokens.GTEQ -> factory.createBooleanValue(result >= 0)
            KtTokens.IDENTIFIER -> {
                assert(operationReference.getReferencedNameAsName() == OperatorNameConventions.COMPARE_TO) { "This method should be called only for compareTo operations" }
                return factory.createIntValue(result)
            }
            else -> throw IllegalStateException("Unknown compareTo operation token: $operationToken")
        }' @ [939:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: ConstantValue<*>?, entry1: ConstantValue<*>?, entry2: ConstantValue<*>?, entry3: ConstantValue<*>?, entry4: ConstantValue<*>?, entry5: ConstantValue<*>?): ConstantValue<*>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> ConstantValue<*>?

'operationToken' @ [939:22] ==> val operationToken: IElementType defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForCompareTo[LocalVariableDescriptor]

'LT' @ [940:22] ==> public final val LT: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'factory' @ [940:28] ==> value-parameter factory: ConstantValueFactory defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForCompareTo[ValueParameterDescriptorImpl]

'createBooleanValue' @ [940:36] ==> public final fun createBooleanValue(value: Boolean): BooleanValue defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[DeserializedSimpleFunctionDescriptor]

'result' @ [940:55] ==> value-parameter result: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForCompareTo[ValueParameterDescriptorImpl]

'LTEQ' @ [941:22] ==> public final val LTEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'factory' @ [941:30] ==> value-parameter factory: ConstantValueFactory defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForCompareTo[ValueParameterDescriptorImpl]

'createBooleanValue' @ [941:38] ==> public final fun createBooleanValue(value: Boolean): BooleanValue defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[DeserializedSimpleFunctionDescriptor]

'result' @ [941:57] ==> value-parameter result: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForCompareTo[ValueParameterDescriptorImpl]

'GT' @ [942:22] ==> public final val GT: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'factory' @ [942:28] ==> value-parameter factory: ConstantValueFactory defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForCompareTo[ValueParameterDescriptorImpl]

'createBooleanValue' @ [942:36] ==> public final fun createBooleanValue(value: Boolean): BooleanValue defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[DeserializedSimpleFunctionDescriptor]

'result' @ [942:55] ==> value-parameter result: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForCompareTo[ValueParameterDescriptorImpl]

'GTEQ' @ [943:22] ==> public final val GTEQ: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'factory' @ [943:30] ==> value-parameter factory: ConstantValueFactory defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForCompareTo[ValueParameterDescriptorImpl]

'createBooleanValue' @ [943:38] ==> public final fun createBooleanValue(value: Boolean): BooleanValue defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[DeserializedSimpleFunctionDescriptor]

'result' @ [943:57] ==> value-parameter result: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForCompareTo[ValueParameterDescriptorImpl]

'IDENTIFIER' @ [944:22] ==> public final val IDENTIFIER: (KtToken..KtToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'assert' @ [945:17] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'operationReference' @ [945:24] ==> value-parameter operationReference: KtExpression defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForCompareTo[ValueParameterDescriptorImpl]

'getReferencedNameAsName' @ [945:43] ==> public abstract fun getReferencedNameAsName(): Name defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[SimpleFunctionDescriptorImpl]

'OperatorNameConventions' @ [945:72] ==> public object OperatorNameConventions defined in org.jetbrains.kotlin.util[FakeCallableDescriptorForObject]

'COMPARE_TO' @ [945:96] ==> @field:JvmField public final val COMPARE_TO: Name defined in org.jetbrains.kotlin.util.OperatorNameConventions[DeserializedPropertyDescriptor]

'factory' @ [946:24] ==> value-parameter factory: ConstantValueFactory defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForCompareTo[ValueParameterDescriptorImpl]

'createIntValue' @ [946:32] ==> public final fun createIntValue(value: Int): IntValue defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[DeserializedSimpleFunctionDescriptor]

'result' @ [946:47] ==> value-parameter result: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForCompareTo[ValueParameterDescriptorImpl]

'IllegalStateException' @ [948:27] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'operationToken' @ [948:86] ==> val operationToken: IElementType defined in org.jetbrains.kotlin.resolve.constants.evaluate.createCompileTimeConstantForCompareTo[LocalVariableDescriptor]

'value' @ [954:34] ==> value-parameter value: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.isIntegerType[ValueParameterDescriptorImpl]

'value' @ [954:51] ==> value-parameter value: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.isIntegerType[ValueParameterDescriptorImpl]

'value' @ [954:69] ==> value-parameter value: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.isIntegerType[ValueParameterDescriptorImpl]

'value' @ [954:85] ==> value-parameter value: Any? defined in org.jetbrains.kotlin.resolve.constants.evaluate.isIntegerType[ValueParameterDescriptorImpl]

'when (resolvedCall.explicitReceiverKind) {
        ExplicitReceiverKind.DISPATCH_RECEIVER -> resolvedCall.dispatchReceiver!!.type
        ExplicitReceiverKind.EXTENSION_RECEIVER -> resolvedCall.extensionReceiver!!.type
        ExplicitReceiverKind.NO_EXPLICIT_RECEIVER -> null
        ExplicitReceiverKind.BOTH_RECEIVERS -> null
        else -> null
    }' @ [957:12] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KotlinType?, entry1: KotlinType?, entry2: KotlinType?, entry3: KotlinType?, entry4: KotlinType?): KotlinType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KotlinType?

'resolvedCall' @ [957:18] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.constants.evaluate.getReceiverExpressionType[ValueParameterDescriptorImpl]

'explicitReceiverKind' @ [957:31] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.explicitReceiverKind: ExplicitReceiverKind[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'DISPATCH_RECEIVER' @ [958:30] ==> enum entry DISPATCH_RECEIVER defined in org.jetbrains.kotlin.resolve.calls.tasks.ExplicitReceiverKind[FakeCallableDescriptorForObject]

'resolvedCall' @ [958:51] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.constants.evaluate.getReceiverExpressionType[ValueParameterDescriptorImpl]

'dispatchReceiver' @ [958:64] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.dispatchReceiver: ReceiverValue?[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'type' @ [958:83] ==> public final val ReceiverValue.type: KotlinType[MyPropertyDescriptor]

'EXTENSION_RECEIVER' @ [959:30] ==> enum entry EXTENSION_RECEIVER defined in org.jetbrains.kotlin.resolve.calls.tasks.ExplicitReceiverKind[FakeCallableDescriptorForObject]

'resolvedCall' @ [959:52] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.resolve.constants.evaluate.getReceiverExpressionType[ValueParameterDescriptorImpl]

'extensionReceiver' @ [959:65] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.extensionReceiver: ReceiverValue?[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'type' @ [959:85] ==> public final val ReceiverValue.type: KotlinType[MyPropertyDescriptor]

'NO_EXPLICIT_RECEIVER' @ [960:30] ==> enum entry NO_EXPLICIT_RECEIVER defined in org.jetbrains.kotlin.resolve.calls.tasks.ExplicitReceiverKind[FakeCallableDescriptorForObject]

'BOTH_RECEIVERS' @ [961:30] ==> enum entry BOTH_RECEIVERS defined in org.jetbrains.kotlin.resolve.calls.tasks.ExplicitReceiverKind[FakeCallableDescriptorForObject]

'name' @ [967:31] ==> public final val name: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.CompileTimeType[PropertyDescriptorImpl]

'CompileTimeType' @ [970:21] ==> public constructor CompileTimeType<T>(name: String) defined in org.jetbrains.kotlin.resolve.constants.evaluate.CompileTimeType[ClassConstructorDescriptorImpl]
Inferred types:
    <T> -> Byte

'CompileTimeType' @ [971:22] ==> public constructor CompileTimeType<T>(name: String) defined in org.jetbrains.kotlin.resolve.constants.evaluate.CompileTimeType[ClassConstructorDescriptorImpl]
Inferred types:
    <T> -> Short

'CompileTimeType' @ [972:20] ==> public constructor CompileTimeType<T>(name: String) defined in org.jetbrains.kotlin.resolve.constants.evaluate.CompileTimeType[ClassConstructorDescriptorImpl]
Inferred types:
    <T> -> Int

'CompileTimeType' @ [973:21] ==> public constructor CompileTimeType<T>(name: String) defined in org.jetbrains.kotlin.resolve.constants.evaluate.CompileTimeType[ClassConstructorDescriptorImpl]
Inferred types:
    <T> -> Long

'CompileTimeType' @ [974:23] ==> public constructor CompileTimeType<T>(name: String) defined in org.jetbrains.kotlin.resolve.constants.evaluate.CompileTimeType[ClassConstructorDescriptorImpl]
Inferred types:
    <T> -> Double

'CompileTimeType' @ [975:22] ==> public constructor CompileTimeType<T>(name: String) defined in org.jetbrains.kotlin.resolve.constants.evaluate.CompileTimeType[ClassConstructorDescriptorImpl]
Inferred types:
    <T> -> Float

'CompileTimeType' @ [976:21] ==> public constructor CompileTimeType<T>(name: String) defined in org.jetbrains.kotlin.resolve.constants.evaluate.CompileTimeType[ClassConstructorDescriptorImpl]
Inferred types:
    <T> -> Char

'CompileTimeType' @ [977:24] ==> public constructor CompileTimeType<T>(name: String) defined in org.jetbrains.kotlin.resolve.constants.evaluate.CompileTimeType[ClassConstructorDescriptorImpl]
Inferred types:
    <T> -> Boolean

'CompileTimeType' @ [978:23] ==> public constructor CompileTimeType<T>(name: String) defined in org.jetbrains.kotlin.resolve.constants.evaluate.CompileTimeType[ClassConstructorDescriptorImpl]
Inferred types:
    <T> -> String

'CompileTimeType' @ [979:20] ==> public constructor CompileTimeType<T>(name: String) defined in org.jetbrains.kotlin.resolve.constants.evaluate.CompileTimeType[ClassConstructorDescriptorImpl]
Inferred types:
    <T> -> Any

'Suppress' @ [981:1] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'BinaryOperationKey' @ [988:5] ==> public constructor BinaryOperationKey<out A, out B>(f: CompileTimeType<out A>, s: CompileTimeType<out B>, functionName: String) defined in org.jetbrains.kotlin.resolve.constants.evaluate.BinaryOperationKey[ClassConstructorDescriptorImpl]
Inferred types:
    <out A> -> A
    <out B> -> B

'a' @ [988:24] ==> value-parameter a: CompileTimeType<A> defined in org.jetbrains.kotlin.resolve.constants.evaluate.binaryOperation[ValueParameterDescriptorImpl]

'b' @ [988:27] ==> value-parameter b: CompileTimeType<B> defined in org.jetbrains.kotlin.resolve.constants.evaluate.binaryOperation[ValueParameterDescriptorImpl]

'functionName' @ [988:30] ==> value-parameter functionName: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.binaryOperation[ValueParameterDescriptorImpl]

'Pair' @ [988:47] ==> public constructor Pair<out A, out B>(first: (A, B) -> Any, second: (BigInteger, BigInteger) -> BigInteger) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> Function2<A, B, Any>
    <out B> -> Function2<BigInteger, BigInteger, BigInteger>

'operation' @ [988:52] ==> value-parameter operation: (A, B) -> Any defined in org.jetbrains.kotlin.resolve.constants.evaluate.binaryOperation[ValueParameterDescriptorImpl]

'checker' @ [988:63] ==> value-parameter checker: (BigInteger, BigInteger) -> BigInteger defined in org.jetbrains.kotlin.resolve.constants.evaluate.binaryOperation[ValueParameterDescriptorImpl]

'Suppress' @ [990:1] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'UnaryOperationKey' @ [996:5] ==> public constructor UnaryOperationKey<out A>(f: CompileTimeType<out A>, functionName: String) defined in org.jetbrains.kotlin.resolve.constants.evaluate.UnaryOperationKey[ClassConstructorDescriptorImpl]
Inferred types:
    <out A> -> A

'a' @ [996:23] ==> value-parameter a: CompileTimeType<A> defined in org.jetbrains.kotlin.resolve.constants.evaluate.unaryOperation[ValueParameterDescriptorImpl]

'functionName' @ [996:26] ==> value-parameter functionName: String defined in org.jetbrains.kotlin.resolve.constants.evaluate.unaryOperation[ValueParameterDescriptorImpl]

'Pair' @ [996:43] ==> public constructor Pair<out A, out B>(first: (A) -> Any, second: (Long) -> Long) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> Function1<A, Any>
    <out B> -> Function1<Long, Long>

'operation' @ [996:48] ==> value-parameter operation: (A) -> Any defined in org.jetbrains.kotlin.resolve.constants.evaluate.unaryOperation[ValueParameterDescriptorImpl]

'checker' @ [996:59] ==> value-parameter checker: (Long) -> Long defined in org.jetbrains.kotlin.resolve.constants.evaluate.unaryOperation[ValueParameterDescriptorImpl]

'this' @ [1002:12] ==> <this> defined in org.jetbrains.kotlin.resolve.constants.evaluate.isStandaloneOnlyConstant[ReceiverParameterDescriptorImpl]

'this' @ [1002:35] ==> <this> defined in org.jetbrains.kotlin.resolve.constants.evaluate.isStandaloneOnlyConstant[ReceiverParameterDescriptorImpl]

'this' @ [1002:56] ==> <this> defined in org.jetbrains.kotlin.resolve.constants.evaluate.isStandaloneOnlyConstant[ReceiverParameterDescriptorImpl]

'this' @ [1002:83] ==> <this> defined in org.jetbrains.kotlin.resolve.constants.evaluate.isStandaloneOnlyConstant[ReceiverParameterDescriptorImpl]

'when(this) {
        is TypedCompileTimeConstant -> this.constantValue.isStandaloneOnlyConstant()
        else -> return false
    }' @ [1006:12] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'this' @ [1006:17] ==> <this> defined in org.jetbrains.kotlin.resolve.constants.evaluate.isStandaloneOnlyConstant[ReceiverParameterDescriptorImpl]

'this' @ [1007:40] ==> <this> defined in org.jetbrains.kotlin.resolve.constants.evaluate.isStandaloneOnlyConstant[ReceiverParameterDescriptorImpl]

'constantValue' @ [1007:45] ==> public final val constantValue: ConstantValue<Any?> defined in org.jetbrains.kotlin.resolve.constants.TypedCompileTimeConstant[DeserializedPropertyDescriptor]

'isStandaloneOnlyConstant' @ [1007:59] ==> public fun ConstantValue<*>.isStandaloneOnlyConstant(): Boolean defined in org.jetbrains.kotlin.resolve.constants.evaluate in file ConstantExpressionEvaluator.kt[SimpleFunctionDescriptorImpl]

