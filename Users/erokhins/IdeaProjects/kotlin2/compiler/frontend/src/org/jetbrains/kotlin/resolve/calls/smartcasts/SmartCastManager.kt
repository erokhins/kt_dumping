'getSmartCastVariants' @ [44:13] ==> public final fun getSmartCastVariants(receiverToCast: ReceiverValue, bindingContext: BindingContext, containingDeclarationOrModule: DeclarationDescriptor, dataFlowInfo: DataFlowInfo): List<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager[SimpleFunctionDescriptorImpl]

'receiverToCast' @ [44:34] ==> value-parameter receiverToCast: ReceiverValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastVariants[ValueParameterDescriptorImpl]

'context' @ [44:50] ==> value-parameter context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastVariants[ValueParameterDescriptorImpl]

'trace' @ [44:58] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'bindingContext' @ [44:64] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'context' @ [44:80] ==> value-parameter context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastVariants[ValueParameterDescriptorImpl]

'scope' @ [44:88] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'ownerDescriptor' @ [44:94] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'context' @ [44:111] ==> value-parameter context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastVariants[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [44:119] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'getSmartCastVariantsExcludingReceiver' @ [52:24] ==> private final fun getSmartCastVariantsExcludingReceiver(bindingContext: BindingContext, containingDeclarationOrModule: DeclarationDescriptor, dataFlowInfo: DataFlowInfo, receiverToCast: ReceiverValue): Collection<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager[SimpleFunctionDescriptorImpl]

'bindingContext' @ [52:62] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastVariants[ValueParameterDescriptorImpl]

'containingDeclarationOrModule' @ [52:78] ==> value-parameter containingDeclarationOrModule: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastVariants[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [52:109] ==> value-parameter dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastVariants[ValueParameterDescriptorImpl]

'receiverToCast' @ [52:123] ==> value-parameter receiverToCast: ReceiverValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastVariants[ValueParameterDescriptorImpl]

'ArrayList' @ [53:22] ==> public constructor ArrayList<E : (Any..Any?)>(p0: Int) defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> KotlinType

'variants' @ [53:44] ==> val variants: Collection<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastVariants[LocalVariableDescriptor]

'size' @ [53:53] ==> public abstract val size: Int defined in kotlin.collections.Collection[DeserializedPropertyDescriptor]

'result' @ [54:9] ==> val result: ArrayList<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastVariants[LocalVariableDescriptor]

'add' @ [54:16] ==> public open fun add(element: KotlinType): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'receiverToCast' @ [54:20] ==> value-parameter receiverToCast: ReceiverValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastVariants[ValueParameterDescriptorImpl]

'type' @ [54:35] ==> public final val ReceiverValue.type: KotlinType[MyPropertyDescriptor]

'result' @ [55:9] ==> val result: ArrayList<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastVariants[LocalVariableDescriptor]

'addAll' @ [55:16] ==> public open fun addAll(elements: Collection<KotlinType>): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'variants' @ [55:23] ==> val variants: Collection<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastVariants[LocalVariableDescriptor]

'result' @ [56:16] ==> val result: ArrayList<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastVariants[LocalVariableDescriptor]

'getSmartCastVariantsExcludingReceiver' @ [66:16] ==> private final fun getSmartCastVariantsExcludingReceiver(bindingContext: BindingContext, containingDeclarationOrModule: DeclarationDescriptor, dataFlowInfo: DataFlowInfo, receiverToCast: ReceiverValue): Collection<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager[SimpleFunctionDescriptorImpl]

'context' @ [66:54] ==> value-parameter context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastVariantsExcludingReceiver[ValueParameterDescriptorImpl]

'trace' @ [66:62] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'bindingContext' @ [66:68] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'context' @ [67:54] ==> value-parameter context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastVariantsExcludingReceiver[ValueParameterDescriptorImpl]

'scope' @ [67:62] ==> @NotNull public final val scope: LexicalScope defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'ownerDescriptor' @ [67:68] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'context' @ [68:54] ==> value-parameter context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastVariantsExcludingReceiver[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [68:62] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'receiverToCast' @ [69:54] ==> value-parameter receiverToCast: ReceiverValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastVariantsExcludingReceiver[ValueParameterDescriptorImpl]

'DataFlowValueFactory' @ [81:29] ==> public object DataFlowValueFactory defined in org.jetbrains.kotlin.resolve.calls.smartcasts in file DataFlowValueFactory.kt[FakeCallableDescriptorForObject]

'createDataFlowValue' @ [81:50] ==> @JvmStatic public final fun createDataFlowValue(receiverValue: ReceiverValue, bindingContext: BindingContext, containingDeclarationOrModule: DeclarationDescriptor): DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValueFactory[SimpleFunctionDescriptorImpl]

'receiverToCast' @ [81:70] ==> value-parameter receiverToCast: ReceiverValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastVariantsExcludingReceiver[ValueParameterDescriptorImpl]

'bindingContext' @ [81:86] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastVariantsExcludingReceiver[ValueParameterDescriptorImpl]

'containingDeclarationOrModule' @ [81:102] ==> value-parameter containingDeclarationOrModule: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastVariantsExcludingReceiver[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [82:16] ==> value-parameter dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastVariantsExcludingReceiver[ValueParameterDescriptorImpl]

'getCollectedTypes' @ [82:29] ==> public abstract fun getCollectedTypes(key: DataFlowValue): Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo[SimpleFunctionDescriptorImpl]

'dataFlowValue' @ [82:47] ==> val dataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastVariantsExcludingReceiver[LocalVariableDescriptor]

'getSmartCastVariants' @ [90:30] ==> private final fun getSmartCastVariants(receiverToCast: ReceiverValue, context: ResolutionContext<*>): List<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager[SimpleFunctionDescriptorImpl]

'receiverArgument' @ [90:51] ==> value-parameter receiverArgument: ReceiverValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.isSubTypeBySmartCastIgnoringNullability[ValueParameterDescriptorImpl]

'context' @ [90:69] ==> value-parameter context: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.isSubTypeBySmartCastIgnoringNullability[ValueParameterDescriptorImpl]

'getSmartCastSubType' @ [91:16] ==> private final fun getSmartCastSubType(receiverParameterType: KotlinType, smartCastTypes: Collection<KotlinType>): KotlinType? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager[SimpleFunctionDescriptorImpl]

'makeNullable' @ [91:46] ==> @NotNull public open fun makeNullable(@NotNull p0: KotlinType): KotlinType defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'receiverParameterType' @ [91:59] ==> value-parameter receiverParameterType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.isSubTypeBySmartCastIgnoringNullability[ValueParameterDescriptorImpl]

'smartCastTypes' @ [91:83] ==> val smartCastTypes: List<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.isSubTypeBySmartCastIgnoringNullability[LocalVariableDescriptor]

'smartCastTypes' @ [98:24] ==> value-parameter smartCastTypes: Collection<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastSubType[ValueParameterDescriptorImpl]

'filter' @ [99:18] ==> public inline fun <T> Iterable<KotlinType>.filter(predicate: (KotlinType) -> Boolean): List<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'isSubtypeOfForArgumentType' @ [99:48] ==> public open fun isSubtypeOfForArgumentType(@NotNull actualType: KotlinType, @NotNull expectedType: KotlinType): Boolean defined in org.jetbrains.kotlin.resolve.calls.ArgumentTypeResolver[JavaMethodDescriptor]

'it' @ [99:75] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastSubType.<anonymous>[ValueParameterDescriptorImpl]

'receiverParameterType' @ [99:79] ==> value-parameter receiverParameterType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastSubType[ValueParameterDescriptorImpl]

'distinct' @ [100:18] ==> public fun <T> Iterable<KotlinType>.distinct(): List<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'subTypes' @ [101:13] ==> val subTypes: List<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastSubType[LocalVariableDescriptor]

'isEmpty' @ [101:22] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'intersectTypes' @ [103:44] ==> @Nullable public open fun intersectTypes(@NotNull typeChecker: KotlinTypeChecker, @NotNull types: (MutableCollection<(KotlinType..KotlinType?)>..Collection<(KotlinType..KotlinType?)>)): KotlinType? defined in org.jetbrains.kotlin.types.TypeIntersector[JavaMethodDescriptor]

'DEFAULT' @ [103:77] ==> public final val DEFAULT: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaPropertyDescriptor]

'subTypes' @ [103:86] ==> val subTypes: List<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastSubType[LocalVariableDescriptor]

'intersection' @ [104:13] ==> val intersection: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastSubType[LocalVariableDescriptor]

'!' @ [104:37] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'intersection' @ [104:38] ==> val intersection: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastSubType[LocalVariableDescriptor]

'constructor' @ [104:51] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'isDenotable' @ [104:63] ==> public final val TypeConstructor.isDenotable: Boolean[MyPropertyDescriptor]

'receiverParameterType' @ [105:20] ==> value-parameter receiverParameterType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastSubType[ValueParameterDescriptorImpl]

'intersection' @ [107:16] ==> val intersection: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.getSmartCastSubType[LocalVariableDescriptor]

'isNullableNothing' @ [120:32] ==> public open fun isNullableNothing(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'type' @ [120:50] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[ValueParameterDescriptorImpl]

'if (dataFlowValue.isStable) {
                val oldSmartCasts = trace[SMARTCAST, expression]
                val newSmartCast = SingleSmartCast(call, type)
                if (oldSmartCasts != null) {
                    val oldType = oldSmartCasts.type(call)
                    if (oldType != null && oldType != type) {
                        throw AssertionError("Rewriting key $call for smart cast on ${expression.text}")
                    }
                }
                trace.record(SMARTCAST, expression, oldSmartCasts?.let { it + newSmartCast } ?: newSmartCast)
                if (recordExpressionType) {
                    //TODO
                    //Why the expression type is rewritten for receivers and is not rewritten for arguments? Is it necessary?
                    trace.recordType(expression, type)
                }
            }
            else {
                trace.report(SMARTCAST_IMPOSSIBLE.on(expression, type, expression.text, dataFlowValue.kind.description))
            }' @ [121:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'dataFlowValue' @ [121:17] ==> value-parameter dataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[ValueParameterDescriptorImpl]

'isStable' @ [121:31] ==> public final val isStable: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'trace' @ [122:37] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[ValueParameterDescriptorImpl]

'SMARTCAST' @ [122:43] ==> public final val SMARTCAST: (WritableSlice<(KtExpression..KtExpression?), (ExplicitSmartCasts..ExplicitSmartCasts?)>..WritableSlice<(KtExpression..KtExpression?), (ExplicitSmartCasts..ExplicitSmartCasts?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'expression' @ [122:54] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[ValueParameterDescriptorImpl]

'SingleSmartCast' @ [123:36] ==> public constructor SingleSmartCast(call: Call?, type: KotlinType) defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SingleSmartCast[ClassConstructorDescriptorImpl]

'call' @ [123:52] ==> value-parameter call: Call? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[ValueParameterDescriptorImpl]

'type' @ [123:58] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[ValueParameterDescriptorImpl]

'oldSmartCasts' @ [124:21] ==> val oldSmartCasts: ExplicitSmartCasts? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[LocalVariableDescriptor]

'oldSmartCasts' @ [125:35] ==> val oldSmartCasts: ExplicitSmartCasts? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[LocalVariableDescriptor]

'type' @ [125:49] ==> public abstract fun type(call: Call?): KotlinType? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.ExplicitSmartCasts[SimpleFunctionDescriptorImpl]

'call' @ [125:54] ==> value-parameter call: Call? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[ValueParameterDescriptorImpl]

'oldType' @ [126:25] ==> val oldType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[LocalVariableDescriptor]

'oldType' @ [126:44] ==> val oldType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[LocalVariableDescriptor]

'type' @ [126:55] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[ValueParameterDescriptorImpl]

'AssertionError' @ [127:31] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'call' @ [127:62] ==> value-parameter call: Call? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[ValueParameterDescriptorImpl]

'expression' @ [127:87] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[ValueParameterDescriptorImpl]

'text' @ [127:98] ==> public final val KtExpression.text: (String..String?)[MyPropertyDescriptor]

'trace' @ [130:17] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[ValueParameterDescriptorImpl]

'record' @ [130:23] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(KtExpression..KtExpression?), (ExplicitSmartCasts..ExplicitSmartCasts?)>..WritableSlice<(KtExpression..KtExpression?), (ExplicitSmartCasts..ExplicitSmartCasts?)>?), key: (KtExpression..KtExpression?), value: (ExplicitSmartCasts..ExplicitSmartCasts?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> KtExpression
    <V : (Any..Any?)> -> ExplicitSmartCasts

'SMARTCAST' @ [130:30] ==> public final val SMARTCAST: (WritableSlice<(KtExpression..KtExpression?), (ExplicitSmartCasts..ExplicitSmartCasts?)>..WritableSlice<(KtExpression..KtExpression?), (ExplicitSmartCasts..ExplicitSmartCasts?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'expression' @ [130:41] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[ValueParameterDescriptorImpl]

'oldSmartCasts' @ [130:53] ==> val oldSmartCasts: ExplicitSmartCasts? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[LocalVariableDescriptor]

'let' @ [130:68] ==> @InlineOnly public inline fun <T, R> ExplicitSmartCasts.let(block: (ExplicitSmartCasts) -> ExplicitSmartCasts): ExplicitSmartCasts defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExplicitSmartCasts
    <R> -> ExplicitSmartCasts

'it' @ [130:74] ==> value-parameter it: ExplicitSmartCasts defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError.<anonymous>[ValueParameterDescriptorImpl]

'newSmartCast' @ [130:79] ==> val newSmartCast: SingleSmartCast defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[LocalVariableDescriptor]

'newSmartCast' @ [130:97] ==> val newSmartCast: SingleSmartCast defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[LocalVariableDescriptor]

'recordExpressionType' @ [131:21] ==> value-parameter recordExpressionType: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[ValueParameterDescriptorImpl]

'trace' @ [134:21] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[ValueParameterDescriptorImpl]

'recordType' @ [134:27] ==> public abstract fun recordType(@NotNull expression: KtExpression, @Nullable type: KotlinType?): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'expression' @ [134:38] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[ValueParameterDescriptorImpl]

'type' @ [134:50] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[ValueParameterDescriptorImpl]

'trace' @ [138:17] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[ValueParameterDescriptorImpl]

'report' @ [138:23] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'SMARTCAST_IMPOSSIBLE' @ [138:30] ==> public final val SMARTCAST_IMPOSSIBLE: (DiagnosticFactory3<(KtExpression..KtExpression?), (KotlinType..KotlinType?), (String..String?), (String..String?)>..DiagnosticFactory3<(KtExpression..KtExpression?), (KotlinType..KotlinType?), (String..String?), (String..String?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [138:51] ==> @NotNull public open fun on(@NotNull element: KtExpression, @NotNull a: KotlinType, @NotNull b: String, @NotNull c: String): ParametrizedDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory3[JavaMethodDescriptor]

'expression' @ [138:54] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[ValueParameterDescriptorImpl]

'type' @ [138:66] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[ValueParameterDescriptorImpl]

'expression' @ [138:72] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[ValueParameterDescriptorImpl]

'text' @ [138:83] ==> public final val KtExpression.text: (String..String?)[MyPropertyDescriptor]

'dataFlowValue' @ [138:89] ==> value-parameter dataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.recordCastOrError[ValueParameterDescriptorImpl]

'kind' @ [138:103] ==> public final val kind: DataFlowValue.Kind defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'description' @ [138:108] ==> public final val description: String defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue.Kind[PropertyDescriptorImpl]

'checkAndRecordPossibleCast' @ [150:20] ==> public final fun checkAndRecordPossibleCast(dataFlowValue: DataFlowValue, expectedType: KotlinType, additionalPredicate: ((KotlinType) -> Boolean)?, expression: KtExpression?, c: ResolutionContext<*>, call: Call?, recordExpressionType: Boolean): SmartCastResult? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion[SimpleFunctionDescriptorImpl]

'dataFlowValue' @ [150:47] ==> value-parameter dataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'expectedType' @ [150:62] ==> value-parameter expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'expression' @ [150:82] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'c' @ [150:94] ==> value-parameter c: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'call' @ [150:97] ==> value-parameter call: Call? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'recordExpressionType' @ [150:103] ==> value-parameter recordExpressionType: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'call' @ [162:36] ==> value-parameter call: Call? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'calleeExpression' @ [162:42] ==> public final val Call.calleeExpression: KtExpression?[MyPropertyDescriptor]

'c' @ [163:34] ==> value-parameter c: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [163:36] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'getCollectedTypes' @ [163:49] ==> public abstract fun getCollectedTypes(key: DataFlowValue): Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo[SimpleFunctionDescriptorImpl]

'dataFlowValue' @ [163:67] ==> value-parameter dataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'isSubtypeOfForArgumentType' @ [164:42] ==> public open fun isSubtypeOfForArgumentType(@NotNull actualType: KotlinType, @NotNull expectedType: KotlinType): Boolean defined in org.jetbrains.kotlin.resolve.calls.ArgumentTypeResolver[JavaMethodDescriptor]

'possibleType' @ [164:69] ==> val possibleType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'expectedType' @ [164:83] ==> value-parameter expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'additionalPredicate' @ [164:101] ==> value-parameter additionalPredicate: ((KotlinType) -> Boolean)? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'invoke' @ [164:132] ==> public abstract operator fun invoke(p1: KotlinType): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'possibleType' @ [164:152] ==> val possibleType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'if (expression != null) {
                        recordCastOrError(expression, possibleType, c.trace, dataFlowValue, call, recordExpressionType)
                    }
                    else if (calleeExpression != null && dataFlowValue.isStable) {
                        val receiver = (dataFlowValue.identifierInfo as? IdentifierInfo.Receiver)?.value
                        if (receiver is ImplicitReceiver) {
                            val oldSmartCasts = c.trace[IMPLICIT_RECEIVER_SMARTCAST, calleeExpression]
                            val newSmartCasts = ImplicitSmartCasts(receiver, possibleType)
                            if (oldSmartCasts != null) {
                                val oldType = oldSmartCasts.receiverTypes[receiver]
                                if (oldType != null && oldType != possibleType) {
                                    throw AssertionError("Rewriting key $receiver for implicit smart cast on ${calleeExpression.text}: " +
                                                         "was $oldType, now $possibleType")
                                }
                            }
                            c.trace.record(IMPLICIT_RECEIVER_SMARTCAST, calleeExpression,
                                           oldSmartCasts?.let { it + newSmartCasts } ?: newSmartCasts)

                        }
                    }' @ [165:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'expression' @ [165:25] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'recordCastOrError' @ [166:25] ==> private final fun recordCastOrError(expression: KtExpression, type: KotlinType, trace: BindingTrace, dataFlowValue: DataFlowValue, call: Call?, recordExpressionType: Boolean): Unit defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion[SimpleFunctionDescriptorImpl]

'expression' @ [166:43] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'possibleType' @ [166:55] ==> val possibleType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'c' @ [166:69] ==> value-parameter c: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'trace' @ [166:71] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'dataFlowValue' @ [166:78] ==> value-parameter dataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'call' @ [166:93] ==> value-parameter call: Call? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'recordExpressionType' @ [166:99] ==> value-parameter recordExpressionType: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'calleeExpression' @ [168:30] ==> val calleeExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'dataFlowValue' @ [168:58] ==> value-parameter dataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'isStable' @ [168:72] ==> public final val isStable: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'dataFlowValue' @ [169:41] ==> value-parameter dataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'identifierInfo' @ [169:55] ==> public final val identifierInfo: IdentifierInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'value' @ [169:100] ==> public final val value: ReceiverValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.IdentifierInfo.Receiver[PropertyDescriptorImpl]

'receiver' @ [170:29] ==> val receiver: ReceiverValue? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'c' @ [171:49] ==> value-parameter c: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'trace' @ [171:51] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'IMPLICIT_RECEIVER_SMARTCAST' @ [171:57] ==> public final val IMPLICIT_RECEIVER_SMARTCAST: (WritableSlice<(KtExpression..KtExpression?), (ImplicitSmartCasts..ImplicitSmartCasts?)>..WritableSlice<(KtExpression..KtExpression?), (ImplicitSmartCasts..ImplicitSmartCasts?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'calleeExpression' @ [171:86] ==> val calleeExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'ImplicitSmartCasts' @ [172:49] ==> public constructor ImplicitSmartCasts(receiver: ImplicitReceiver, type: KotlinType) defined in org.jetbrains.kotlin.resolve.calls.smartcasts.ImplicitSmartCasts[ClassConstructorDescriptorImpl]

'receiver' @ [172:68] ==> val receiver: ReceiverValue? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'possibleType' @ [172:78] ==> val possibleType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'oldSmartCasts' @ [173:33] ==> val oldSmartCasts: ImplicitSmartCasts? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'oldSmartCasts' @ [174:47] ==> val oldSmartCasts: ImplicitSmartCasts? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'receiverTypes' @ [174:61] ==> public final val receiverTypes: Map<ImplicitReceiver, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.ImplicitSmartCasts[PropertyDescriptorImpl]

'receiver' @ [174:75] ==> val receiver: ReceiverValue? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'oldType' @ [175:37] ==> val oldType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'oldType' @ [175:56] ==> val oldType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'possibleType' @ [175:67] ==> val possibleType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'AssertionError' @ [176:43] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'+' @ [176:58] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'receiver' @ [176:74] ==> val receiver: ReceiverValue? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'calleeExpression' @ [176:112] ==> val calleeExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'text' @ [176:129] ==> public final val KtExpression.text: (String..String?)[MyPropertyDescriptor]

'oldType' @ [177:64] ==> val oldType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'possibleType' @ [177:78] ==> val possibleType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'c' @ [180:29] ==> value-parameter c: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'trace' @ [180:31] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'record' @ [180:37] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(KtExpression..KtExpression?), (ImplicitSmartCasts..ImplicitSmartCasts?)>..WritableSlice<(KtExpression..KtExpression?), (ImplicitSmartCasts..ImplicitSmartCasts?)>?), key: (KtExpression..KtExpression?), value: (ImplicitSmartCasts..ImplicitSmartCasts?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> KtExpression
    <V : (Any..Any?)> -> ImplicitSmartCasts

'IMPLICIT_RECEIVER_SMARTCAST' @ [180:44] ==> public final val IMPLICIT_RECEIVER_SMARTCAST: (WritableSlice<(KtExpression..KtExpression?), (ImplicitSmartCasts..ImplicitSmartCasts?)>..WritableSlice<(KtExpression..KtExpression?), (ImplicitSmartCasts..ImplicitSmartCasts?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'calleeExpression' @ [180:73] ==> val calleeExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'oldSmartCasts' @ [181:44] ==> val oldSmartCasts: ImplicitSmartCasts? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'let' @ [181:59] ==> @InlineOnly public inline fun <T, R> ImplicitSmartCasts.let(block: (ImplicitSmartCasts) -> ImplicitSmartCasts): ImplicitSmartCasts defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ImplicitSmartCasts
    <R> -> ImplicitSmartCasts

'it' @ [181:65] ==> value-parameter it: ImplicitSmartCasts defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast.<anonymous>[ValueParameterDescriptorImpl]

'newSmartCasts' @ [181:70] ==> val newSmartCasts: ImplicitSmartCasts defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'newSmartCasts' @ [181:89] ==> val newSmartCasts: ImplicitSmartCasts defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'SmartCastResult' @ [185:28] ==> public constructor SmartCastResult(resultType: KotlinType, isCorrect: Boolean) defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastResult[ClassConstructorDescriptorImpl]

'possibleType' @ [185:44] ==> val possibleType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'dataFlowValue' @ [185:58] ==> value-parameter dataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'isStable' @ [185:72] ==> public final val isStable: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'!' @ [189:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'c' @ [189:18] ==> value-parameter c: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [189:20] ==> @NotNull public final val dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'getCollectedNullability' @ [189:33] ==> public abstract fun getCollectedNullability(key: DataFlowValue): Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo[SimpleFunctionDescriptorImpl]

'dataFlowValue' @ [189:57] ==> value-parameter dataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'canBeNull' @ [189:72] ==> public open fun canBeNull(): Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.Nullability[JavaMethodDescriptor]

'!' @ [189:87] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'expectedType' @ [189:88] ==> value-parameter expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'isMarkedNullable' @ [189:101] ==> public abstract val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'!' @ [203:41] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'dataFlowValue' @ [203:42] ==> value-parameter dataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'immanentNullability' @ [203:56] ==> public final val immanentNullability: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'canBeNull' @ [203:76] ==> public open fun canBeNull(): Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.Nullability[JavaMethodDescriptor]

'makeNullable' @ [204:54] ==> @NotNull public open fun makeNullable(@NotNull p0: KotlinType): KotlinType defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'expectedType' @ [204:67] ==> value-parameter expectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'isSubtypeOfForArgumentType' @ [206:42] ==> public open fun isSubtypeOfForArgumentType(@NotNull actualType: KotlinType, @NotNull expectedType: KotlinType): Boolean defined in org.jetbrains.kotlin.resolve.calls.ArgumentTypeResolver[JavaMethodDescriptor]

'dataFlowValue' @ [206:69] ==> value-parameter dataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'type' @ [206:83] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'nullableExpectedType' @ [206:89] ==> val nullableExpectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'additionalPredicate' @ [206:115] ==> value-parameter additionalPredicate: ((KotlinType) -> Boolean)? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'invoke' @ [206:146] ==> public abstract operator fun invoke(p1: KotlinType): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'dataFlowValue' @ [206:166] ==> value-parameter dataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'type' @ [206:180] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'!' @ [207:25] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'immanentlyNotNull' @ [207:26] ==> val immanentlyNotNull: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'expression' @ [207:47] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'recordCastOrError' @ [208:25] ==> private final fun recordCastOrError(expression: KtExpression, type: KotlinType, trace: BindingTrace, dataFlowValue: DataFlowValue, call: Call?, recordExpressionType: Boolean): Unit defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion[SimpleFunctionDescriptorImpl]

'expression' @ [208:43] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'dataFlowValue' @ [208:55] ==> value-parameter dataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'type' @ [208:69] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'c' @ [208:75] ==> value-parameter c: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'trace' @ [208:77] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'dataFlowValue' @ [208:84] ==> value-parameter dataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'call' @ [208:99] ==> value-parameter call: Call? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'recordExpressionType' @ [208:105] ==> value-parameter recordExpressionType: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'SmartCastResult' @ [211:28] ==> public constructor SmartCastResult(resultType: KotlinType, isCorrect: Boolean) defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastResult[ClassConstructorDescriptorImpl]

'dataFlowValue' @ [211:44] ==> value-parameter dataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'type' @ [211:58] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'immanentlyNotNull' @ [211:64] ==> val immanentlyNotNull: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'dataFlowValue' @ [211:85] ==> value-parameter dataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'isStable' @ [211:99] ==> public final val isStable: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'checkAndRecordPossibleCast' @ [213:24] ==> public final fun checkAndRecordPossibleCast(dataFlowValue: DataFlowValue, expectedType: KotlinType, expression: KtExpression?, c: ResolutionContext<*>, call: Call?, recordExpressionType: Boolean): SmartCastResult? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion[SimpleFunctionDescriptorImpl]

'dataFlowValue' @ [213:51] ==> value-parameter dataFlowValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'nullableExpectedType' @ [213:66] ==> val nullableExpectedType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[LocalVariableDescriptor]

'expression' @ [213:88] ==> value-parameter expression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'c' @ [213:100] ==> value-parameter c: ResolutionContext<*> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'call' @ [213:103] ==> value-parameter call: Call? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

'recordExpressionType' @ [213:109] ==> value-parameter recordExpressionType: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.SmartCastManager.Companion.checkAndRecordPossibleCast[ValueParameterDescriptorImpl]

