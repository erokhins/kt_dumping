'function' @ [75:13] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'name' @ [75:22] ==> public final val KtNamedFunction.name: String?[MyPropertyDescriptor]

'trace' @ [75:36] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'report' @ [75:42] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'FUNCTION_DECLARATION_WITH_NO_NAME' @ [75:49] ==> public final val FUNCTION_DECLARATION_WITH_NO_NAME: (DiagnosticFactory0<(KtFunction..KtFunction?)>..DiagnosticFactory0<(KtFunction..KtFunction?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [75:83] ==> @NotNull public open fun on(@NotNull element: KtFunction): SimpleDiagnostic<(KtFunction..KtFunction?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'function' @ [75:86] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'resolveFunctionDescriptor' @ [77:16] ==> private final fun resolveFunctionDescriptor(functionConstructor: (DeclarationDescriptor, Annotations, Name, CallableMemberDescriptor.Kind, SourceElement) -> SimpleFunctionDescriptorImpl, containingDescriptor: DeclarationDescriptor, scope: LexicalScope, function: KtNamedFunction, trace: BindingTrace, dataFlowInfo: DataFlowInfo, expectedFunctionType: KotlinType): SimpleFunctionDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[SimpleFunctionDescriptorImpl]

'SimpleFunctionDescriptorImpl' @ [78:17] ==> protected/*protected and package*/ constructor SimpleFunctionDescriptorImpl(@NotNull p0: DeclarationDescriptor, @Nullable p1: SimpleFunctionDescriptor?, @NotNull p2: Annotations, @NotNull p3: Name, @NotNull p4: CallableMemberDescriptor.Kind, @NotNull p5: SourceElement) defined in org.jetbrains.kotlin.descriptors.impl.SimpleFunctionDescriptorImpl[JavaClassConstructorDescriptor]

'containingDescriptor' @ [78:55] ==> value-parameter containingDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'scope' @ [78:77] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'function' @ [78:84] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'trace' @ [78:94] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [78:101] ==> value-parameter dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'NO_EXPECTED_TYPE' @ [78:125] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'resolveFunctionDescriptor' @ [89:35] ==> private final fun resolveFunctionDescriptor(functionConstructor: (DeclarationDescriptor, Annotations, Name, CallableMemberDescriptor.Kind, SourceElement) -> SimpleFunctionDescriptorImpl, containingDescriptor: DeclarationDescriptor, scope: LexicalScope, function: KtNamedFunction, trace: BindingTrace, dataFlowInfo: DataFlowInfo, expectedFunctionType: KotlinType): SimpleFunctionDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[SimpleFunctionDescriptorImpl]

'containingDescriptor' @ [90:45] ==> value-parameter containingDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionExpressionDescriptor[ValueParameterDescriptorImpl]

'scope' @ [90:67] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionExpressionDescriptor[ValueParameterDescriptorImpl]

'function' @ [90:74] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionExpressionDescriptor[ValueParameterDescriptorImpl]

'trace' @ [90:84] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionExpressionDescriptor[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [90:91] ==> value-parameter dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionExpressionDescriptor[ValueParameterDescriptorImpl]

'expectedFunctionType' @ [90:105] ==> value-parameter expectedFunctionType: KotlinType defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionExpressionDescriptor[ValueParameterDescriptorImpl]

'invoke' @ [101:34] ==> public abstract operator fun invoke(p1: DeclarationDescriptor, p2: Annotations, p3: Name, p4: CallableMemberDescriptor.Kind, p5: SourceElement): SimpleFunctionDescriptorImpl defined in kotlin.Function5[FunctionInvokeDescriptor]

'containingDescriptor' @ [102:17] ==> value-parameter containingDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'annotationResolver' @ [103:17] ==> private final val annotationResolver: AnnotationResolver defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[PropertyDescriptorImpl]

'resolveAnnotationsWithoutArguments' @ [103:36] ==> public final fun resolveAnnotationsWithoutArguments(scope: LexicalScope, modifierList: KtModifierList?, trace: BindingTrace): Annotations defined in org.jetbrains.kotlin.resolve.AnnotationResolver[SimpleFunctionDescriptorImpl]

'scope' @ [103:71] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'function' @ [103:78] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'modifierList' @ [103:87] ==> public final val KtNamedFunction.modifierList: KtModifierList?[MyPropertyDescriptor]

'trace' @ [103:101] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'function' @ [104:17] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'nameAsSafeName' @ [104:26] ==> public final val KtNamedFunction.nameAsSafeName: Name[MyPropertyDescriptor]

'DECLARATION' @ [105:47] ==> enum entry DECLARATION defined in org.jetbrains.kotlin.descriptors.CallableMemberDescriptor.Kind[FakeCallableDescriptorForObject]

'function' @ [106:17] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'toSourceElement' @ [106:26] ==> public fun KtPureElement?.toSourceElement(): SourceElement defined in org.jetbrains.kotlin.resolve.source in file KotlinSourceElement.kt[SimpleFunctionDescriptorImpl]

'initializeFunctionDescriptorAndExplicitReturnType' @ [108:9] ==> public final fun initializeFunctionDescriptorAndExplicitReturnType(containingDescriptor: DeclarationDescriptor, scope: LexicalScope, function: KtFunction, functionDescriptor: SimpleFunctionDescriptorImpl, trace: BindingTrace, expectedFunctionType: KotlinType): Unit defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[SimpleFunctionDescriptorImpl]

'containingDescriptor' @ [108:59] ==> value-parameter containingDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'scope' @ [108:81] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'function' @ [108:88] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'functionDescriptor' @ [108:98] ==> val functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[LocalVariableDescriptor]

'trace' @ [108:118] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'expectedFunctionType' @ [108:125] ==> value-parameter expectedFunctionType: KotlinType defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'initializeFunctionReturnTypeBasedOnFunctionBody' @ [109:9] ==> private final fun initializeFunctionReturnTypeBasedOnFunctionBody(scope: LexicalScope, function: KtNamedFunction, functionDescriptor: SimpleFunctionDescriptorImpl, trace: BindingTrace, dataFlowInfo: DataFlowInfo): Unit defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[SimpleFunctionDescriptorImpl]

'scope' @ [109:57] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'function' @ [109:64] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'functionDescriptor' @ [109:74] ==> val functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[LocalVariableDescriptor]

'trace' @ [109:94] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [109:101] ==> value-parameter dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'recordFunctionDeclarationToDescriptor' @ [110:29] ==> public open fun recordFunctionDeclarationToDescriptor(@NotNull trace: BindingTrace, @NotNull psiElement: PsiElement, @NotNull function: SimpleFunctionDescriptor): Unit defined in org.jetbrains.kotlin.resolve.BindingContextUtils[JavaMethodDescriptor]

'trace' @ [110:67] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'function' @ [110:74] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[ValueParameterDescriptorImpl]

'functionDescriptor' @ [110:84] ==> val functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[LocalVariableDescriptor]

'functionDescriptor' @ [111:16] ==> val functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveFunctionDescriptor[LocalVariableDescriptor]

'functionDescriptor' @ [121:13] ==> value-parameter functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionReturnTypeBasedOnFunctionBody[ValueParameterDescriptorImpl]

'returnType' @ [121:32] ==> public final val SimpleFunctionDescriptorImpl.returnType: KotlinType?[MyPropertyDescriptor]

'assert' @ [122:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'function' @ [122:16] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionReturnTypeBasedOnFunctionBody[ValueParameterDescriptorImpl]

'typeReference' @ [122:25] ==> public final var KtNamedFunction.typeReference: KtTypeReference?[MyPropertyDescriptor]

'+' @ [123:13] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'function' @ [123:70] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionReturnTypeBasedOnFunctionBody[ValueParameterDescriptorImpl]

'text' @ [123:79] ==> public final val KtNamedFunction.text: (String..String?)[MyPropertyDescriptor]

'atLocation' @ [123:113] ==> public open fun atLocation(expression: (KtExpression..KtExpression?)): (String..String?) defined in org.jetbrains.kotlin.diagnostics.DiagnosticUtils[JavaMethodDescriptor]

'function' @ [123:124] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionReturnTypeBasedOnFunctionBody[ValueParameterDescriptorImpl]

'when {
            function.hasBlockBody() ->
                builtIns.unitType
            function.hasBody() ->
                descriptorResolver.inferReturnTypeFromExpressionBody(trace, scope, dataFlowInfo, function, functionDescriptor)
            else ->
                ErrorUtils.createErrorType("No type, no body")
        }' @ [125:26] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KotlinType, entry1: KotlinType, entry2: KotlinType): KotlinType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KotlinType

'function' @ [126:13] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionReturnTypeBasedOnFunctionBody[ValueParameterDescriptorImpl]

'hasBlockBody' @ [126:22] ==> @Override public open fun hasBlockBody(): Boolean defined in org.jetbrains.kotlin.psi.KtNamedFunction[JavaMethodDescriptor]

'builtIns' @ [127:17] ==> private final val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[PropertyDescriptorImpl]

'unitType' @ [127:26] ==> public final val KotlinBuiltIns.unitType: SimpleType[MyPropertyDescriptor]

'function' @ [128:13] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionReturnTypeBasedOnFunctionBody[ValueParameterDescriptorImpl]

'hasBody' @ [128:22] ==> @Override public open fun hasBody(): Boolean defined in org.jetbrains.kotlin.psi.KtNamedFunction[JavaMethodDescriptor]

'descriptorResolver' @ [129:17] ==> private final val descriptorResolver: DescriptorResolver defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[PropertyDescriptorImpl]

'inferReturnTypeFromExpressionBody' @ [129:36] ==> @NotNull public/*package*/ open fun inferReturnTypeFromExpressionBody(@NotNull trace: BindingTrace, @NotNull scope: LexicalScope, @NotNull dataFlowInfo: DataFlowInfo, @NotNull function: KtDeclarationWithBody, @NotNull functionDescriptor: FunctionDescriptor): KotlinType defined in org.jetbrains.kotlin.resolve.DescriptorResolver[JavaMethodDescriptor]

'trace' @ [129:70] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionReturnTypeBasedOnFunctionBody[ValueParameterDescriptorImpl]

'scope' @ [129:77] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionReturnTypeBasedOnFunctionBody[ValueParameterDescriptorImpl]

'dataFlowInfo' @ [129:84] ==> value-parameter dataFlowInfo: DataFlowInfo defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionReturnTypeBasedOnFunctionBody[ValueParameterDescriptorImpl]

'function' @ [129:98] ==> value-parameter function: KtNamedFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionReturnTypeBasedOnFunctionBody[ValueParameterDescriptorImpl]

'functionDescriptor' @ [129:108] ==> value-parameter functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionReturnTypeBasedOnFunctionBody[ValueParameterDescriptorImpl]

'createErrorType' @ [131:28] ==> @NotNull public open fun createErrorType(@NotNull p0: String): SimpleType defined in org.jetbrains.kotlin.types.ErrorUtils[JavaMethodDescriptor]

'functionDescriptor' @ [133:9] ==> value-parameter functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionReturnTypeBasedOnFunctionBody[ValueParameterDescriptorImpl]

'setReturnType' @ [133:28] ==> public open fun setReturnType(@NotNull p0: KotlinType): Unit defined in org.jetbrains.kotlin.descriptors.impl.SimpleFunctionDescriptorImpl[JavaMethodDescriptor]

'returnType' @ [133:42] ==> val returnType: KotlinType defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionReturnTypeBasedOnFunctionBody[LocalVariableDescriptor]

'LexicalWritableScope' @ [144:27] ==> public constructor LexicalWritableScope(parent: LexicalScope, ownerDescriptor: DeclarationDescriptor, isOwnerDescriptorAccessibleByLabel: Boolean, redeclarationChecker: LocalRedeclarationChecker, kind: LexicalScopeKind) defined in org.jetbrains.kotlin.resolve.scopes.LexicalWritableScope[DeserializedClassConstructorDescriptor]

'scope' @ [144:48] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'functionDescriptor' @ [144:55] ==> value-parameter functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'TraceBasedLocalRedeclarationChecker' @ [145:48] ==> public constructor TraceBasedLocalRedeclarationChecker(trace: BindingTrace, overloadChecker: OverloadChecker) defined in org.jetbrains.kotlin.resolve.scopes.TraceBasedLocalRedeclarationChecker[ClassConstructorDescriptorImpl]

'trace' @ [145:84] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'overloadChecker' @ [145:91] ==> private final val overloadChecker: OverloadChecker defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[PropertyDescriptorImpl]

'FUNCTION_HEADER' @ [145:126] ==> enum entry FUNCTION_HEADER defined in org.jetbrains.kotlin.resolve.scopes.LexicalScopeKind[FakeCallableDescriptorForObject]

'descriptorResolver' @ [147:40] ==> private final val descriptorResolver: DescriptorResolver defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[PropertyDescriptorImpl]

'resolveTypeParametersForDescriptor' @ [148:17] ==> public open fun resolveTypeParametersForDescriptor(containingDescriptor: (DeclarationDescriptor..DeclarationDescriptor?), extensibleScope: (LexicalWritableScope..LexicalWritableScope?), scopeForAnnotationsResolve: (LexicalScope..LexicalScope?), typeParameters: (MutableList<(KtTypeParameter..KtTypeParameter?)>..List<(KtTypeParameter..KtTypeParameter?)>?), trace: (BindingTrace..BindingTrace?)): (MutableList<(TypeParameterDescriptorImpl..TypeParameterDescriptorImpl?)>..List<(TypeParameterDescriptorImpl..TypeParameterDescriptorImpl?)>?) defined in org.jetbrains.kotlin.resolve.DescriptorResolver[JavaMethodDescriptor]

'functionDescriptor' @ [148:52] ==> value-parameter functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'headerScope' @ [148:72] ==> val headerScope: LexicalWritableScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[LocalVariableDescriptor]

'scope' @ [148:85] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'function' @ [148:92] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'typeParameters' @ [148:101] ==> public final val KtFunction.typeParameters: (MutableList<(KtTypeParameter..KtTypeParameter?)>..List<(KtTypeParameter..KtTypeParameter?)>)[MyPropertyDescriptor]

'trace' @ [148:117] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'descriptorResolver' @ [149:9] ==> private final val descriptorResolver: DescriptorResolver defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[PropertyDescriptorImpl]

'resolveGenericBounds' @ [149:28] ==> public open fun resolveGenericBounds(@NotNull declaration: KtTypeParameterListOwner, @NotNull descriptor: DeclarationDescriptor, scope: (LexicalScope..LexicalScope?), parameters: (MutableList<(TypeParameterDescriptorImpl..TypeParameterDescriptorImpl?)>..List<(TypeParameterDescriptorImpl..TypeParameterDescriptorImpl?)>?), trace: (BindingTrace..BindingTrace?)): Unit defined in org.jetbrains.kotlin.resolve.DescriptorResolver[JavaMethodDescriptor]

'function' @ [149:49] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'functionDescriptor' @ [149:59] ==> value-parameter functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'headerScope' @ [149:79] ==> val headerScope: LexicalWritableScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[LocalVariableDescriptor]

'typeParameterDescriptors' @ [149:92] ==> val typeParameterDescriptors: (MutableList<(TypeParameterDescriptorImpl..TypeParameterDescriptorImpl?)>..List<(TypeParameterDescriptorImpl..TypeParameterDescriptorImpl?)>?) defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[LocalVariableDescriptor]

'trace' @ [149:118] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'function' @ [151:31] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'receiverTypeReference' @ [151:40] ==> public final val KtFunction.receiverTypeReference: KtTypeReference?[MyPropertyDescriptor]

'if (receiverTypeRef != null) {
                    typeResolver.resolveType(headerScope, receiverTypeRef, trace, true)
                }
                else {
                    if (function is KtFunctionLiteral) expectedFunctionType.getReceiverType() else null
                }' @ [153:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType?, elseBranch: KotlinType?): KotlinType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType?

'receiverTypeRef' @ [153:21] ==> val receiverTypeRef: KtTypeReference? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[LocalVariableDescriptor]

'typeResolver' @ [154:21] ==> private final val typeResolver: TypeResolver defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[PropertyDescriptorImpl]

'resolveType' @ [154:34] ==> public final fun resolveType(scope: LexicalScope, typeReference: KtTypeReference, trace: BindingTrace, checkBounds: Boolean): KotlinType defined in org.jetbrains.kotlin.resolve.TypeResolver[SimpleFunctionDescriptorImpl]

'headerScope' @ [154:46] ==> val headerScope: LexicalWritableScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[LocalVariableDescriptor]

'receiverTypeRef' @ [154:59] ==> val receiverTypeRef: KtTypeReference? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[LocalVariableDescriptor]

'trace' @ [154:76] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'if (function is KtFunctionLiteral) expectedFunctionType.getReceiverType() else null' @ [157:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType?, elseBranch: KotlinType?): KotlinType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType?

'function' @ [157:25] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'expectedFunctionType' @ [157:56] ==> value-parameter expectedFunctionType: KotlinType defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'getReceiverType' @ [157:77] ==> private final fun KotlinType.getReceiverType(): KotlinType? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[SimpleFunctionDescriptorImpl]

'createValueParameterDescriptors' @ [161:41] ==> private final fun createValueParameterDescriptors(function: KtFunction, functionDescriptor: SimpleFunctionDescriptorImpl, innerScope: LexicalWritableScope, trace: BindingTrace, expectedFunctionType: KotlinType): List<ValueParameterDescriptor> defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[SimpleFunctionDescriptorImpl]

'function' @ [161:73] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'functionDescriptor' @ [161:83] ==> value-parameter functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'headerScope' @ [161:103] ==> val headerScope: LexicalWritableScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[LocalVariableDescriptor]

'trace' @ [161:116] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'expectedFunctionType' @ [161:123] ==> value-parameter expectedFunctionType: KotlinType defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'headerScope' @ [163:9] ==> val headerScope: LexicalWritableScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[LocalVariableDescriptor]

'freeze' @ [163:21] ==> public final fun freeze(): Unit defined in org.jetbrains.kotlin.resolve.scopes.LexicalWritableScope[DeserializedSimpleFunctionDescriptor]

'function' @ [165:26] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'typeReference' @ [165:35] ==> public final var KtFunction.typeReference: KtTypeReference?[MyPropertyDescriptor]

'let' @ [165:50] ==> @InlineOnly public inline fun <T, R> KtTypeReference.let(block: (KtTypeReference) -> KotlinType): KotlinType defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtTypeReference
    <R> -> KotlinType

'typeResolver' @ [165:56] ==> private final val typeResolver: TypeResolver defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[PropertyDescriptorImpl]

'resolveType' @ [165:69] ==> public final fun resolveType(scope: LexicalScope, typeReference: KtTypeReference, trace: BindingTrace, checkBounds: Boolean): KotlinType defined in org.jetbrains.kotlin.resolve.TypeResolver[SimpleFunctionDescriptorImpl]

'headerScope' @ [165:81] ==> val headerScope: LexicalWritableScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[LocalVariableDescriptor]

'it' @ [165:94] ==> value-parameter it: KtTypeReference defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType.<anonymous>[ValueParameterDescriptorImpl]

'trace' @ [165:98] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'resolveVisibilityFromModifiers' @ [167:26] ==> @NotNull public open fun resolveVisibilityFromModifiers(@NotNull modifierListOwner: KtModifierListOwner, @NotNull defaultVisibility: Visibility): Visibility defined in org.jetbrains.kotlin.resolve.ModifiersChecker[JavaMethodDescriptor]

'function' @ [167:57] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'getDefaultVisibility' @ [167:67] ==> public open fun getDefaultVisibility(modifierListOwner: (KtModifierListOwner..KtModifierListOwner?), containingDescriptor: (DeclarationDescriptor..DeclarationDescriptor?)): (Visibility..Visibility?) defined in org.jetbrains.kotlin.resolve.DescriptorResolver[JavaMethodDescriptor]

'function' @ [167:88] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'containingDescriptor' @ [167:98] ==> value-parameter containingDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'resolveMemberModalityFromModifiers' @ [168:24] ==> @NotNull public open fun resolveMemberModalityFromModifiers(@Nullable modifierListOwner: KtModifierListOwner?, @NotNull defaultModality: Modality, @NotNull bindingContext: BindingContext, @Nullable containingDescriptor: DeclarationDescriptor?): Modality defined in org.jetbrains.kotlin.resolve.ModifiersChecker[JavaMethodDescriptor]

'function' @ [168:59] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'getDefaultModality' @ [168:69] ==> public open fun getDefaultModality(containingDescriptor: (DeclarationDescriptor..DeclarationDescriptor?), visibility: (Visibility..Visibility?), isBodyPresent: Boolean): (Modality..Modality?) defined in org.jetbrains.kotlin.resolve.DescriptorResolver[JavaMethodDescriptor]

'containingDescriptor' @ [168:88] ==> value-parameter containingDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'visibility' @ [168:110] ==> val visibility: Visibility defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[LocalVariableDescriptor]

'function' @ [168:122] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'hasBody' @ [168:131] ==> public abstract fun hasBody(): Boolean defined in org.jetbrains.kotlin.psi.KtFunction[JavaMethodDescriptor]

'trace' @ [169:59] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'bindingContext' @ [169:65] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'containingDescriptor' @ [169:81] ==> value-parameter containingDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'functionDescriptor' @ [170:9] ==> value-parameter functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'initialize' @ [170:28] ==> @NotNull public open fun initialize(@Nullable p0: KotlinType?, @Nullable p1: ReceiverParameterDescriptor?, @NotNull p2: (MutableList<out (TypeParameterDescriptor..TypeParameterDescriptor?)>..List<(TypeParameterDescriptor..TypeParameterDescriptor?)>), @NotNull p3: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>), @Nullable p4: KotlinType?, @Nullable p5: Modality?, @NotNull p6: Visibility): SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.descriptors.impl.SimpleFunctionDescriptorImpl[JavaMethodDescriptor]

'receiverType' @ [171:17] ==> val receiverType: KotlinType? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[LocalVariableDescriptor]

'getDispatchReceiverParameterIfNeeded' @ [172:17] ==> @Nullable public open fun getDispatchReceiverParameterIfNeeded(@NotNull p0: DeclarationDescriptor): ReceiverParameterDescriptor? defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'containingDescriptor' @ [172:54] ==> value-parameter containingDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'typeParameterDescriptors' @ [173:17] ==> val typeParameterDescriptors: (MutableList<(TypeParameterDescriptorImpl..TypeParameterDescriptorImpl?)>..List<(TypeParameterDescriptorImpl..TypeParameterDescriptorImpl?)>?) defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[LocalVariableDescriptor]

'valueParameterDescriptors' @ [174:17] ==> val valueParameterDescriptors: List<ValueParameterDescriptor> defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[LocalVariableDescriptor]

'returnType' @ [175:17] ==> val returnType: KotlinType? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[LocalVariableDescriptor]

'modality' @ [176:17] ==> val modality: Modality defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[LocalVariableDescriptor]

'visibility' @ [177:17] ==> val visibility: Visibility defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[LocalVariableDescriptor]

'functionDescriptor' @ [179:9] ==> value-parameter functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'isOperator' @ [179:28] ==> public final var SimpleFunctionDescriptorImpl.isOperator: Boolean[MyPropertyDescriptor]

'function' @ [179:41] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'hasModifier' @ [179:50] ==> public abstract fun hasModifier(@NotNull modifier: KtModifierKeywordToken): Boolean defined in org.jetbrains.kotlin.psi.KtFunction[JavaMethodDescriptor]

'OPERATOR_KEYWORD' @ [179:71] ==> public final val OPERATOR_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'functionDescriptor' @ [180:9] ==> value-parameter functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'isInfix' @ [180:28] ==> public final var SimpleFunctionDescriptorImpl.isInfix: Boolean[MyPropertyDescriptor]

'function' @ [180:38] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'hasModifier' @ [180:47] ==> public abstract fun hasModifier(@NotNull modifier: KtModifierKeywordToken): Boolean defined in org.jetbrains.kotlin.psi.KtFunction[JavaMethodDescriptor]

'INFIX_KEYWORD' @ [180:68] ==> public final val INFIX_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'functionDescriptor' @ [181:9] ==> value-parameter functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'isExternal' @ [181:28] ==> public final var SimpleFunctionDescriptorImpl.isExternal: Boolean[MyPropertyDescriptor]

'function' @ [181:41] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'hasModifier' @ [181:50] ==> public abstract fun hasModifier(@NotNull modifier: KtModifierKeywordToken): Boolean defined in org.jetbrains.kotlin.psi.KtFunction[JavaMethodDescriptor]

'EXTERNAL_KEYWORD' @ [181:71] ==> public final val EXTERNAL_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'functionDescriptor' @ [182:9] ==> value-parameter functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'isInline' @ [182:28] ==> public final var SimpleFunctionDescriptorImpl.isInline: Boolean[MyPropertyDescriptor]

'function' @ [182:39] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'hasModifier' @ [182:48] ==> public abstract fun hasModifier(@NotNull modifier: KtModifierKeywordToken): Boolean defined in org.jetbrains.kotlin.psi.KtFunction[JavaMethodDescriptor]

'INLINE_KEYWORD' @ [182:69] ==> public final val INLINE_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'functionDescriptor' @ [183:9] ==> value-parameter functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'isTailrec' @ [183:28] ==> public final var SimpleFunctionDescriptorImpl.isTailrec: Boolean[MyPropertyDescriptor]

'function' @ [183:40] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'hasModifier' @ [183:49] ==> public abstract fun hasModifier(@NotNull modifier: KtModifierKeywordToken): Boolean defined in org.jetbrains.kotlin.psi.KtFunction[JavaMethodDescriptor]

'TAILREC_KEYWORD' @ [183:70] ==> public final val TAILREC_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'functionDescriptor' @ [184:9] ==> value-parameter functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'isSuspend' @ [184:28] ==> public final var SimpleFunctionDescriptorImpl.isSuspend: Boolean[MyPropertyDescriptor]

'function' @ [184:40] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'hasModifier' @ [184:49] ==> public abstract fun hasModifier(@NotNull modifier: KtModifierKeywordToken): Boolean defined in org.jetbrains.kotlin.psi.KtFunction[JavaMethodDescriptor]

'SUSPEND_KEYWORD' @ [184:70] ==> public final val SUSPEND_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'functionDescriptor' @ [185:9] ==> value-parameter functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'isHeader' @ [185:28] ==> public final var SimpleFunctionDescriptorImpl.isHeader: Boolean[MyPropertyDescriptor]

'function' @ [185:39] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'hasModifier' @ [185:48] ==> public abstract fun hasModifier(@NotNull modifier: KtModifierKeywordToken): Boolean defined in org.jetbrains.kotlin.psi.KtFunction[JavaMethodDescriptor]

'HEADER_KEYWORD' @ [185:69] ==> public final val HEADER_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'containingDescriptor' @ [186:41] ==> value-parameter containingDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'containingDescriptor' @ [186:84] ==> value-parameter containingDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'isHeader' @ [186:105] ==> public final val ClassDescriptor.isHeader: Boolean[MyPropertyDescriptor]

'functionDescriptor' @ [187:9] ==> value-parameter functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'isImpl' @ [187:28] ==> public final var SimpleFunctionDescriptorImpl.isImpl: Boolean[MyPropertyDescriptor]

'function' @ [187:37] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[ValueParameterDescriptorImpl]

'hasModifier' @ [187:46] ==> public abstract fun hasModifier(@NotNull modifier: KtModifierKeywordToken): Boolean defined in org.jetbrains.kotlin.psi.KtFunction[JavaMethodDescriptor]

'IMPL_KEYWORD' @ [187:67] ==> public final val IMPL_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'receiverType' @ [189:9] ==> val receiverType: KotlinType? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[LocalVariableDescriptor]

'let' @ [189:23] ==> @InlineOnly public inline fun <T, R> KotlinType.let(block: (KotlinType) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType
    <R> -> Unit

'forceResolveAllContents' @ [189:46] ==> public open fun forceResolveAllContents(@NotNull annotations: Annotations): Unit defined in org.jetbrains.kotlin.resolve.lazy.ForceResolveUtil[JavaMethodDescriptor]

'it' @ [189:70] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType.<anonymous>[ValueParameterDescriptorImpl]

'annotations' @ [189:73] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'valueParameterDescriptors' @ [190:42] ==> val valueParameterDescriptors: List<ValueParameterDescriptor> defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[LocalVariableDescriptor]

'forceResolveAllContents' @ [191:30] ==> public open fun forceResolveAllContents(@NotNull annotations: Annotations): Unit defined in org.jetbrains.kotlin.resolve.lazy.ForceResolveUtil[JavaMethodDescriptor]

'valueParameterDescriptor' @ [191:54] ==> val valueParameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.initializeFunctionDescriptorAndExplicitReturnType[LocalVariableDescriptor]

'type' @ [191:79] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'annotations' @ [191:84] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'expectedFunctionType' @ [202:39] ==> value-parameter expectedFunctionType: KotlinType defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[ValueParameterDescriptorImpl]

'getValueParameters' @ [202:60] ==> private final fun KotlinType.getValueParameters(owner: FunctionDescriptor): List<ValueParameterDescriptor>? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[SimpleFunctionDescriptorImpl]

'functionDescriptor' @ [202:79] ==> value-parameter functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[ValueParameterDescriptorImpl]

'expectedValueParameters' @ [203:38] ==> val expectedValueParameters: List<ValueParameterDescriptor>? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[LocalVariableDescriptor]

'map' @ [203:63] ==> public inline fun <T, R> Iterable<ValueParameterDescriptor>.map(transform: (ValueParameterDescriptor) -> KotlinType): List<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ValueParameterDescriptor
    <R> -> KotlinType

'it' @ [203:69] ==> value-parameter it: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [203:72] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'removeParameterNameAnnotation' @ [203:77] ==> private final fun KotlinType.removeParameterNameAnnotation(): KotlinType defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[SimpleFunctionDescriptorImpl]

'expectedValueParameters' @ [204:13] ==> val expectedValueParameters: List<ValueParameterDescriptor>? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[LocalVariableDescriptor]

'expectedValueParameters' @ [205:17] ==> val expectedValueParameters: List<ValueParameterDescriptor>? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[LocalVariableDescriptor]

'size' @ [205:41] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'function' @ [205:54] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[ValueParameterDescriptorImpl]

'function' @ [205:87] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[ValueParameterDescriptorImpl]

'getValueParameterList' @ [205:96] ==> @Nullable public abstract fun getValueParameterList(): KtParameterList? defined in org.jetbrains.kotlin.psi.KtFunction[JavaMethodDescriptor]

'expectedValueParameters' @ [207:48] ==> val expectedValueParameters: List<ValueParameterDescriptor>? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[LocalVariableDescriptor]

'single' @ [207:72] ==> public fun <T> List<ValueParameterDescriptor>.single(): ValueParameterDescriptor defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ValueParameterDescriptor

'ValueParameterDescriptorImpl' @ [208:26] ==> public constructor ValueParameterDescriptorImpl(containingDeclaration: CallableDescriptor, original: ValueParameterDescriptor?, index: Int, annotations: Annotations, name: Name, outType: KotlinType, declaresDefaultValue: Boolean, isCrossinline: Boolean, isNoinline: Boolean, varargElementType: KotlinType?, source: SourceElement) defined in org.jetbrains.kotlin.descriptors.impl.ValueParameterDescriptorImpl[DeserializedClassConstructorDescriptor]

'functionDescriptor' @ [208:55] ==> value-parameter functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[ValueParameterDescriptorImpl]

'Annotations' @ [208:84] ==> public companion object defined in org.jetbrains.kotlin.descriptors.annotations.Annotations[FakeCallableDescriptorForObject]

'EMPTY' @ [208:96] ==> public final val EMPTY: Annotations defined in org.jetbrains.kotlin.descriptors.annotations.Annotations.Companion[DeserializedPropertyDescriptor]

'identifier' @ [208:108] ==> @NotNull public open fun identifier(@NotNull p0: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'expectedParameterTypes' @ [209:55] ==> val expectedParameterTypes: List<KotlinType>? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[LocalVariableDescriptor]

'single' @ [209:80] ==> public fun <T> List<KotlinType>.single(): KotlinType defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'valueParameterDescriptor' @ [209:90] ==> val valueParameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[LocalVariableDescriptor]

'declaresDefaultValue' @ [209:115] ==> public abstract fun declaresDefaultValue(): Boolean defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedSimpleFunctionDescriptor]

'valueParameterDescriptor' @ [210:55] ==> val valueParameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[LocalVariableDescriptor]

'isCrossinline' @ [210:80] ==> public abstract val isCrossinline: Boolean defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'valueParameterDescriptor' @ [210:95] ==> val valueParameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[LocalVariableDescriptor]

'isNoinline' @ [210:120] ==> public abstract val isNoinline: Boolean defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'valueParameterDescriptor' @ [211:55] ==> val valueParameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[LocalVariableDescriptor]

'varargElementType' @ [211:80] ==> public abstract val varargElementType: KotlinType? defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'NO_SOURCE' @ [211:113] ==> public final val NO_SOURCE: (SourceElement..SourceElement?) defined in org.jetbrains.kotlin.descriptors.SourceElement[JavaPropertyDescriptor]

'trace' @ [212:17] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[ValueParameterDescriptorImpl]

'record' @ [212:23] ==> public abstract fun <K : (Any..Any?)> record(slice: (WritableSlice<(ValueParameterDescriptor..ValueParameterDescriptor?), (Boolean..Boolean?)>..WritableSlice<(ValueParameterDescriptor..ValueParameterDescriptor?), (Boolean..Boolean?)>?), key: (ValueParameterDescriptor..ValueParameterDescriptor?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> ValueParameterDescriptor

'AUTO_CREATED_IT' @ [212:45] ==> public final val AUTO_CREATED_IT: (WritableSlice<(ValueParameterDescriptor..ValueParameterDescriptor?), (Boolean..Boolean?)>..WritableSlice<(ValueParameterDescriptor..ValueParameterDescriptor?), (Boolean..Boolean?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'it' @ [212:62] ==> val it: ValueParameterDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[LocalVariableDescriptor]

'listOf' @ [213:24] ==> public fun <T> listOf(element: ValueParameterDescriptorImpl): List<ValueParameterDescriptorImpl> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ValueParameterDescriptorImpl

'it' @ [213:31] ==> val it: ValueParameterDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[LocalVariableDescriptor]

'function' @ [215:17] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[ValueParameterDescriptorImpl]

'valueParameters' @ [215:26] ==> public final val KtFunction.valueParameters: (MutableList<(KtParameter..KtParameter?)>..List<(KtParameter..KtParameter?)>)[MyPropertyDescriptor]

'size' @ [215:42] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'expectedValueParameters' @ [215:50] ==> val expectedValueParameters: List<ValueParameterDescriptor>? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[LocalVariableDescriptor]

'size' @ [215:74] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'trace' @ [216:17] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[ValueParameterDescriptorImpl]

'report' @ [216:23] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'EXPECTED_PARAMETERS_NUMBER_MISMATCH' @ [216:30] ==> public final val EXPECTED_PARAMETERS_NUMBER_MISMATCH: (DiagnosticFactory2<(KtFunction..KtFunction?), (Int..Int?), (MutableList<(KotlinType..KotlinType?)>..List<(KotlinType..KotlinType?)>?)>..DiagnosticFactory2<(KtFunction..KtFunction?), (Int..Int?), (MutableList<(KotlinType..KotlinType?)>..List<(KotlinType..KotlinType?)>?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [216:66] ==> @NotNull public open fun on(@NotNull element: KtFunction, @NotNull a: Int, @NotNull b: (MutableList<(KotlinType..KotlinType?)>..List<(KotlinType..KotlinType?)>)): ParametrizedDiagnostic<(KtFunction..KtFunction?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'function' @ [216:69] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[ValueParameterDescriptorImpl]

'expectedParameterTypes' @ [216:79] ==> val expectedParameterTypes: List<KotlinType>? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[LocalVariableDescriptor]

'size' @ [216:104] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'expectedParameterTypes' @ [216:110] ==> val expectedParameterTypes: List<KotlinType>? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[LocalVariableDescriptor]

'trace' @ [220:9] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[ValueParameterDescriptorImpl]

'recordScope' @ [220:15] ==> public fun BindingTrace.recordScope(scope: LexicalScope, element: KtElement?): Unit defined in org.jetbrains.kotlin.resolve.bindingContextUtil in file BindingContextUtils.kt[SimpleFunctionDescriptorImpl]

'innerScope' @ [220:27] ==> value-parameter innerScope: LexicalWritableScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[ValueParameterDescriptorImpl]

'function' @ [220:39] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[ValueParameterDescriptorImpl]

'valueParameterList' @ [220:48] ==> public final val KtFunction.valueParameterList: KtParameterList?[MyPropertyDescriptor]

'resolveValueParameters' @ [222:16] ==> private final fun resolveValueParameters(functionDescriptor: FunctionDescriptor, parameterScope: LexicalWritableScope, valueParameters: List<KtParameter>, trace: BindingTrace, expectedParameterTypes: List<KotlinType>?): List<ValueParameterDescriptor> defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[SimpleFunctionDescriptorImpl]

'functionDescriptor' @ [223:17] ==> value-parameter functionDescriptor: SimpleFunctionDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[ValueParameterDescriptorImpl]

'innerScope' @ [224:17] ==> value-parameter innerScope: LexicalWritableScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[ValueParameterDescriptorImpl]

'function' @ [225:17] ==> value-parameter function: KtFunction defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[ValueParameterDescriptorImpl]

'valueParameters' @ [225:26] ==> public final val KtFunction.valueParameters: (MutableList<(KtParameter..KtParameter?)>..List<(KtParameter..KtParameter?)>)[MyPropertyDescriptor]

'trace' @ [226:17] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[ValueParameterDescriptorImpl]

'expectedParameterTypes' @ [227:17] ==> val expectedParameterTypes: List<KotlinType>? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createValueParameterDescriptors[LocalVariableDescriptor]

'this' @ [232:13] ==> <this> defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.removeParameterNameAnnotation[ReceiverParameterDescriptorImpl]

'this' @ [232:51] ==> <this> defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.removeParameterNameAnnotation[ReceiverParameterDescriptorImpl]

'annotations' @ [233:39] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'findAnnotation' @ [233:51] ==> public open fun findAnnotation(fqName: FqName): AnnotationDescriptor? defined in org.jetbrains.kotlin.descriptors.annotations.Annotations[DeserializedSimpleFunctionDescriptor]

'FQ_NAMES' @ [233:81] ==> public final val FQ_NAMES: (KotlinBuiltIns.FqNames..KotlinBuiltIns.FqNames?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaPropertyDescriptor]

'parameterName' @ [233:90] ==> public final val parameterName: (FqName..FqName?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns.FqNames[JavaPropertyDescriptor]

'this' @ [233:115] ==> <this> defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.removeParameterNameAnnotation[ReceiverParameterDescriptorImpl]

'replaceAnnotations' @ [234:16] ==> public fun KotlinType.replaceAnnotations(newAnnotations: Annotations): KotlinType defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'AnnotationsImpl' @ [234:35] ==> public constructor AnnotationsImpl(annotations: List<AnnotationDescriptor>) defined in org.jetbrains.kotlin.descriptors.annotations.AnnotationsImpl[DeserializedClassConstructorDescriptor]

'annotations' @ [234:51] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'filter' @ [234:63] ==> public inline fun <T> Iterable<AnnotationDescriptor>.filter(predicate: (AnnotationDescriptor) -> Boolean): List<AnnotationDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> AnnotationDescriptor

'it' @ [234:72] ==> value-parameter it: AnnotationDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.removeParameterNameAnnotation.<anonymous>[ValueParameterDescriptorImpl]

'parameterNameAnnotation' @ [234:78] ==> val parameterNameAnnotation: AnnotationDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.removeParameterNameAnnotation[LocalVariableDescriptor]

'!' @ [237:53] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'noExpectedType' @ [237:64] ==> public open fun noExpectedType(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'this' @ [237:79] ==> <this> defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.functionTypeExpected[ReceiverParameterDescriptorImpl]

'isBuiltinFunctionalType' @ [237:88] ==> public val KotlinType.isBuiltinFunctionalType: Boolean defined in org.jetbrains.kotlin.builtins[DeserializedPropertyDescriptor]

'if (functionTypeExpected()) this.getReceiverTypeFromFunctionType() else null' @ [239:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType?, elseBranch: KotlinType?): KotlinType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType?

'functionTypeExpected' @ [239:17] ==> private final fun KotlinType.functionTypeExpected(): Boolean defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[SimpleFunctionDescriptorImpl]

'this' @ [239:41] ==> <this> defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.getReceiverType[ReceiverParameterDescriptorImpl]

'getReceiverTypeFromFunctionType' @ [239:46] ==> public fun KotlinType.getReceiverTypeFromFunctionType(): KotlinType? defined in org.jetbrains.kotlin.builtins[DeserializedSimpleFunctionDescriptor]

'if (functionTypeExpected()) {
                createValueParametersForInvokeInFunctionType(owner, this.getValueParameterTypesFromFunctionType())
            }
            else null' @ [242:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<ValueParameterDescriptor>?, elseBranch: List<ValueParameterDescriptor>?): List<ValueParameterDescriptor>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<ValueParameterDescriptor>?

'functionTypeExpected' @ [242:17] ==> private final fun KotlinType.functionTypeExpected(): Boolean defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[SimpleFunctionDescriptorImpl]

'createValueParametersForInvokeInFunctionType' @ [243:17] ==> public fun createValueParametersForInvokeInFunctionType(functionDescriptor: FunctionDescriptor, parameterTypes: List<TypeProjection>): List<ValueParameterDescriptor> defined in org.jetbrains.kotlin.resolve.calls.util[DeserializedSimpleFunctionDescriptor]

'owner' @ [243:62] ==> value-parameter owner: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.getValueParameters[ValueParameterDescriptorImpl]

'this' @ [243:69] ==> <this> defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.getValueParameters[ReceiverParameterDescriptorImpl]

'getValueParameterTypesFromFunctionType' @ [243:74] ==> public fun KotlinType.getValueParameterTypesFromFunctionType(): List<TypeProjection> defined in org.jetbrains.kotlin.builtins[DeserializedSimpleFunctionDescriptor]

'classDescriptor' @ [253:13] ==> value-parameter classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolvePrimaryConstructorDescriptor[ValueParameterDescriptorImpl]

'kind' @ [253:29] ==> public final val ClassDescriptor.kind: ClassKind[MyPropertyDescriptor]

'ENUM_ENTRY' @ [253:47] ==> enum entry ENUM_ENTRY defined in org.jetbrains.kotlin.descriptors.ClassKind[FakeCallableDescriptorForObject]

'!' @ [253:61] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'classElement' @ [253:62] ==> value-parameter classElement: KtPureClassOrObject defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolvePrimaryConstructorDescriptor[ValueParameterDescriptorImpl]

'hasPrimaryConstructor' @ [253:75] ==> public abstract fun hasPrimaryConstructor(): Boolean defined in org.jetbrains.kotlin.psi.KtPureClassOrObject[JavaMethodDescriptor]

'createConstructorDescriptor' @ [254:16] ==> private final fun createConstructorDescriptor(scope: LexicalScope, classDescriptor: ClassDescriptor, isPrimary: Boolean, modifierList: KtModifierList?, declarationToTrace: KtPureElement, valueParameters: List<KtParameter>, trace: BindingTrace): ClassConstructorDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[SimpleFunctionDescriptorImpl]

'scope' @ [255:17] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolvePrimaryConstructorDescriptor[ValueParameterDescriptorImpl]

'classDescriptor' @ [256:17] ==> value-parameter classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolvePrimaryConstructorDescriptor[ValueParameterDescriptorImpl]

'classElement' @ [258:17] ==> value-parameter classElement: KtPureClassOrObject defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolvePrimaryConstructorDescriptor[ValueParameterDescriptorImpl]

'primaryConstructorModifierList' @ [258:30] ==> public final val KtPureClassOrObject.primaryConstructorModifierList: KtModifierList?[MyPropertyDescriptor]

'classElement' @ [259:17] ==> value-parameter classElement: KtPureClassOrObject defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolvePrimaryConstructorDescriptor[ValueParameterDescriptorImpl]

'primaryConstructor' @ [259:30] ==> public final val KtPureClassOrObject.primaryConstructor: KtPrimaryConstructor?[MyPropertyDescriptor]

'classElement' @ [259:52] ==> value-parameter classElement: KtPureClassOrObject defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolvePrimaryConstructorDescriptor[ValueParameterDescriptorImpl]

'classElement' @ [260:17] ==> value-parameter classElement: KtPureClassOrObject defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolvePrimaryConstructorDescriptor[ValueParameterDescriptorImpl]

'primaryConstructorParameters' @ [260:30] ==> public final val KtPureClassOrObject.primaryConstructorParameters: List<(KtParameter..KtParameter?)>[MyPropertyDescriptor]

'trace' @ [261:17] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolvePrimaryConstructorDescriptor[ValueParameterDescriptorImpl]

'createConstructorDescriptor' @ [271:16] ==> private final fun createConstructorDescriptor(scope: LexicalScope, classDescriptor: ClassDescriptor, isPrimary: Boolean, modifierList: KtModifierList?, declarationToTrace: KtPureElement, valueParameters: List<KtParameter>, trace: BindingTrace): ClassConstructorDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[SimpleFunctionDescriptorImpl]

'scope' @ [272:17] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveSecondaryConstructorDescriptor[ValueParameterDescriptorImpl]

'classDescriptor' @ [273:17] ==> value-parameter classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveSecondaryConstructorDescriptor[ValueParameterDescriptorImpl]

'constructor' @ [275:17] ==> value-parameter constructor: KtSecondaryConstructor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveSecondaryConstructorDescriptor[ValueParameterDescriptorImpl]

'modifierList' @ [275:29] ==> public final val KtSecondaryConstructor.modifierList: KtModifierList?[MyPropertyDescriptor]

'constructor' @ [276:17] ==> value-parameter constructor: KtSecondaryConstructor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveSecondaryConstructorDescriptor[ValueParameterDescriptorImpl]

'constructor' @ [277:17] ==> value-parameter constructor: KtSecondaryConstructor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveSecondaryConstructorDescriptor[ValueParameterDescriptorImpl]

'valueParameters' @ [277:29] ==> public final val KtSecondaryConstructor.valueParameters: (MutableList<(KtParameter..KtParameter?)>..List<(KtParameter..KtParameter?)>)[MyPropertyDescriptor]

'trace' @ [278:17] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveSecondaryConstructorDescriptor[ValueParameterDescriptorImpl]

'create' @ [291:68] ==> @NotNull public open fun create(@NotNull p0: ClassDescriptor, @NotNull p1: Annotations, p2: Boolean, @NotNull p3: SourceElement): ClassConstructorDescriptorImpl defined in org.jetbrains.kotlin.descriptors.impl.ClassConstructorDescriptorImpl[JavaMethodDescriptor]

'classDescriptor' @ [292:17] ==> value-parameter classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[ValueParameterDescriptorImpl]

'annotationResolver' @ [293:17] ==> private final val annotationResolver: AnnotationResolver defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[PropertyDescriptorImpl]

'resolveAnnotationsWithoutArguments' @ [293:36] ==> public final fun resolveAnnotationsWithoutArguments(scope: LexicalScope, modifierList: KtModifierList?, trace: BindingTrace): Annotations defined in org.jetbrains.kotlin.resolve.AnnotationResolver[SimpleFunctionDescriptorImpl]

'scope' @ [293:71] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[ValueParameterDescriptorImpl]

'modifierList' @ [293:78] ==> value-parameter modifierList: KtModifierList? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[ValueParameterDescriptorImpl]

'trace' @ [293:92] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[ValueParameterDescriptorImpl]

'isPrimary' @ [294:17] ==> value-parameter isPrimary: Boolean defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[ValueParameterDescriptorImpl]

'declarationToTrace' @ [295:17] ==> value-parameter declarationToTrace: KtPureElement defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[ValueParameterDescriptorImpl]

'toSourceElement' @ [295:36] ==> public fun KtPureElement?.toSourceElement(): SourceElement defined in org.jetbrains.kotlin.resolve.source in file KotlinSourceElement.kt[SimpleFunctionDescriptorImpl]

'classDescriptor' @ [297:13] ==> value-parameter classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[ValueParameterDescriptorImpl]

'isHeader' @ [297:29] ==> public final val ClassDescriptor.isHeader: Boolean[MyPropertyDescriptor]

'constructorDescriptor' @ [298:13] ==> val constructorDescriptor: ClassConstructorDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[LocalVariableDescriptor]

'isHeader' @ [298:35] ==> public final var ClassConstructorDescriptorImpl.isHeader: Boolean[MyPropertyDescriptor]

'classDescriptor' @ [300:13] ==> value-parameter classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[ValueParameterDescriptorImpl]

'isImpl' @ [300:29] ==> public final val ClassDescriptor.isImpl: Boolean[MyPropertyDescriptor]

'constructorDescriptor' @ [301:13] ==> val constructorDescriptor: ClassConstructorDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[LocalVariableDescriptor]

'isImpl' @ [301:35] ==> public final var ClassConstructorDescriptorImpl.isImpl: Boolean[MyPropertyDescriptor]

'declarationToTrace' @ [303:13] ==> value-parameter declarationToTrace: KtPureElement defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[ValueParameterDescriptorImpl]

'trace' @ [304:13] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[ValueParameterDescriptorImpl]

'record' @ [304:19] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(slice: (WritableSlice<(PsiElement..PsiElement?), (ConstructorDescriptor..ConstructorDescriptor?)>..WritableSlice<(PsiElement..PsiElement?), (ConstructorDescriptor..ConstructorDescriptor?)>?), key: (PsiElement..PsiElement?), value: (ConstructorDescriptor..ConstructorDescriptor?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> PsiElement
    <V : (Any..Any?)> -> ConstructorDescriptor

'CONSTRUCTOR' @ [304:41] ==> public final val CONSTRUCTOR: (WritableSlice<(PsiElement..PsiElement?), (ConstructorDescriptor..ConstructorDescriptor?)>..WritableSlice<(PsiElement..PsiElement?), (ConstructorDescriptor..ConstructorDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'declarationToTrace' @ [304:54] ==> value-parameter declarationToTrace: KtPureElement defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[ValueParameterDescriptorImpl]

'constructorDescriptor' @ [304:74] ==> val constructorDescriptor: ClassConstructorDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[LocalVariableDescriptor]

'LexicalWritableScope' @ [305:30] ==> public constructor LexicalWritableScope(parent: LexicalScope, ownerDescriptor: DeclarationDescriptor, isOwnerDescriptorAccessibleByLabel: Boolean, redeclarationChecker: LocalRedeclarationChecker, kind: LexicalScopeKind) defined in org.jetbrains.kotlin.resolve.scopes.LexicalWritableScope[DeserializedClassConstructorDescriptor]

'scope' @ [306:17] ==> value-parameter scope: LexicalScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[ValueParameterDescriptorImpl]

'constructorDescriptor' @ [307:17] ==> val constructorDescriptor: ClassConstructorDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[LocalVariableDescriptor]

'TraceBasedLocalRedeclarationChecker' @ [309:17] ==> public constructor TraceBasedLocalRedeclarationChecker(trace: BindingTrace, overloadChecker: OverloadChecker) defined in org.jetbrains.kotlin.resolve.scopes.TraceBasedLocalRedeclarationChecker[ClassConstructorDescriptorImpl]

'trace' @ [309:53] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[ValueParameterDescriptorImpl]

'overloadChecker' @ [309:60] ==> private final val overloadChecker: OverloadChecker defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[PropertyDescriptorImpl]

'CONSTRUCTOR_HEADER' @ [310:34] ==> enum entry CONSTRUCTOR_HEADER defined in org.jetbrains.kotlin.resolve.scopes.LexicalScopeKind[FakeCallableDescriptorForObject]

'constructorDescriptor' @ [312:27] ==> val constructorDescriptor: ClassConstructorDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[LocalVariableDescriptor]

'initialize' @ [312:49] ==> public open fun initialize(@NotNull p0: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>), @NotNull p1: Visibility): (ClassConstructorDescriptorImpl..ClassConstructorDescriptorImpl?) defined in org.jetbrains.kotlin.descriptors.impl.ClassConstructorDescriptorImpl[JavaMethodDescriptor]

'resolveValueParameters' @ [313:17] ==> private final fun resolveValueParameters(functionDescriptor: FunctionDescriptor, parameterScope: LexicalWritableScope, valueParameters: List<KtParameter>, trace: BindingTrace, expectedParameterTypes: List<KotlinType>?): List<ValueParameterDescriptor> defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[SimpleFunctionDescriptorImpl]

'constructorDescriptor' @ [313:40] ==> val constructorDescriptor: ClassConstructorDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[LocalVariableDescriptor]

'parameterScope' @ [313:63] ==> val parameterScope: LexicalWritableScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[LocalVariableDescriptor]

'valueParameters' @ [313:79] ==> value-parameter valueParameters: List<KtParameter> defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[ValueParameterDescriptorImpl]

'trace' @ [313:96] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[ValueParameterDescriptorImpl]

'resolveVisibilityFromModifiers' @ [314:17] ==> public open fun resolveVisibilityFromModifiers(@Nullable modifierList: KtModifierList?, @NotNull defaultVisibility: Visibility): (Visibility..Visibility?) defined in org.jetbrains.kotlin.resolve.ModifiersChecker[JavaMethodDescriptor]

'modifierList' @ [315:25] ==> value-parameter modifierList: KtModifierList? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[ValueParameterDescriptorImpl]

'getDefaultConstructorVisibility' @ [316:41] ==> @NotNull public open fun getDefaultConstructorVisibility(@NotNull p0: ClassDescriptor): Visibility defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'classDescriptor' @ [316:73] ==> value-parameter classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[ValueParameterDescriptorImpl]

'constructor' @ [319:9] ==> val constructor: (ClassConstructorDescriptorImpl..ClassConstructorDescriptorImpl?) defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[LocalVariableDescriptor]

'returnType' @ [319:21] ==> public final var ClassConstructorDescriptorImpl.returnType: KotlinType[MyPropertyDescriptor]

'classDescriptor' @ [319:34] ==> value-parameter classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[ValueParameterDescriptorImpl]

'defaultType' @ [319:50] ==> public final val ClassDescriptor.defaultType: SimpleType[MyPropertyDescriptor]

'isAnnotationClass' @ [320:29] ==> public open fun isAnnotationClass(@Nullable p0: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'classDescriptor' @ [320:47] ==> value-parameter classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[ValueParameterDescriptorImpl]

'checkConstructorParametersType' @ [321:38] ==> public open fun checkConstructorParametersType(@NotNull parameters: (MutableList<(KtParameter..KtParameter?)>..List<(KtParameter..KtParameter?)>), @NotNull trace: BindingTrace): Unit defined in org.jetbrains.kotlin.resolve.CompileTimeConstantUtils[JavaMethodDescriptor]

'valueParameters' @ [321:69] ==> value-parameter valueParameters: List<KtParameter> defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[ValueParameterDescriptorImpl]

'trace' @ [321:86] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[ValueParameterDescriptorImpl]

'constructor' @ [323:16] ==> val constructor: (ClassConstructorDescriptorImpl..ClassConstructorDescriptorImpl?) defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.createConstructorDescriptor[LocalVariableDescriptor]

'ArrayList' @ [333:22] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> ValueParameterDescriptor

'valueParameters' @ [335:19] ==> value-parameter valueParameters: List<KtParameter> defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'indices' @ [335:35] ==> public val Collection<*>.indices: IntRange defined in kotlin.collections[DeserializedPropertyDescriptor]

'valueParameters' @ [336:34] ==> value-parameter valueParameters: List<KtParameter> defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'i' @ [336:50] ==> val i: Int defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'valueParameter' @ [337:33] ==> val valueParameter: KtParameter defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'typeReference' @ [337:48] ==> public final var KtParameter.typeReference: KtTypeReference?[MyPropertyDescriptor]

'expectedParameterTypes' @ [338:32] ==> value-parameter expectedParameterTypes: List<KotlinType>? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'let' @ [338:56] ==> @InlineOnly public inline fun <T, R> List<KotlinType>.let(block: (List<KotlinType>) -> KotlinType?): KotlinType? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> List<KotlinType>
    <R> -> KotlinType?

'if (i < it.size) it[i] else null' @ [338:62] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType?, elseBranch: KotlinType?): KotlinType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType?

'i' @ [338:66] ==> val i: Int defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'it' @ [338:70] ==> value-parameter it: List<KotlinType> defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters.<anonymous>[ValueParameterDescriptorImpl]

'size' @ [338:73] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'it' @ [338:79] ==> value-parameter it: List<KotlinType> defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters.<anonymous>[ValueParameterDescriptorImpl]

'i' @ [338:82] ==> val i: Int defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'takeUnless' @ [338:98] ==> @InlineOnly @SinceKotlin public inline fun <T> KotlinType.takeUnless(predicate: (KotlinType) -> Boolean): KotlinType? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'noExpectedType' @ [338:121] ==> public open fun noExpectedType(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'it' @ [338:136] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters.<anonymous>[ValueParameterDescriptorImpl]

'if (typeReference != null) {
                type = typeResolver.resolveType(parameterScope, typeReference, trace, true)
                if (expectedType != null) {
                    if (!KotlinTypeChecker.DEFAULT.isSubtypeOf(expectedType, type)) {
                        trace.report(EXPECTED_PARAMETER_TYPE_MISMATCH.on(valueParameter, expectedType))
                    }
                }
            }
            else {
                type = if (isFunctionLiteral(functionDescriptor) || isFunctionExpression(functionDescriptor)) {
                    val containsUninferredParameter = TypeUtils.contains(expectedType) {
                        TypeUtils.isDontCarePlaceholder(it) || ErrorUtils.isUninferredParameter(it)
                    }
                    if (expectedType == null || containsUninferredParameter) {
                        trace.report(CANNOT_INFER_PARAMETER_TYPE.on(valueParameter))
                    }

                    expectedType ?: TypeUtils.CANT_INFER_FUNCTION_PARAM_TYPE
                }
                else {
                    trace.report(VALUE_PARAMETER_WITH_NO_TYPE_ANNOTATION.on(valueParameter))
                    ErrorUtils.createErrorType("Type annotation was missing for parameter ${valueParameter.nameAsSafeName}")
                }
            }' @ [341:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'typeReference' @ [341:17] ==> val typeReference: KtTypeReference? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'type' @ [342:17] ==> val type: KotlinType defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'typeResolver' @ [342:24] ==> private final val typeResolver: TypeResolver defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[PropertyDescriptorImpl]

'resolveType' @ [342:37] ==> public final fun resolveType(scope: LexicalScope, typeReference: KtTypeReference, trace: BindingTrace, checkBounds: Boolean): KotlinType defined in org.jetbrains.kotlin.resolve.TypeResolver[SimpleFunctionDescriptorImpl]

'parameterScope' @ [342:49] ==> value-parameter parameterScope: LexicalWritableScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'typeReference' @ [342:65] ==> val typeReference: KtTypeReference? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'trace' @ [342:80] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'expectedType' @ [343:21] ==> val expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'!' @ [344:25] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'DEFAULT' @ [344:44] ==> public final val DEFAULT: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaPropertyDescriptor]

'isSubtypeOf' @ [344:52] ==> public abstract fun isSubtypeOf(@NotNull p0: KotlinType, @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaMethodDescriptor]

'expectedType' @ [344:64] ==> val expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'type' @ [344:78] ==> val type: KotlinType defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'trace' @ [345:25] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'report' @ [345:31] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'EXPECTED_PARAMETER_TYPE_MISMATCH' @ [345:38] ==> public final val EXPECTED_PARAMETER_TYPE_MISMATCH: (DiagnosticFactory1<(KtParameter..KtParameter?), (KotlinType..KotlinType?)>..DiagnosticFactory1<(KtParameter..KtParameter?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [345:71] ==> @NotNull public open fun on(@NotNull element: KtParameter, @NotNull argument: KotlinType): ParametrizedDiagnostic<(KtParameter..KtParameter?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory1[JavaMethodDescriptor]

'valueParameter' @ [345:74] ==> val valueParameter: KtParameter defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'expectedType' @ [345:90] ==> val expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'type' @ [350:17] ==> val type: KotlinType defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'if (isFunctionLiteral(functionDescriptor) || isFunctionExpression(functionDescriptor)) {
                    val containsUninferredParameter = TypeUtils.contains(expectedType) {
                        TypeUtils.isDontCarePlaceholder(it) || ErrorUtils.isUninferredParameter(it)
                    }
                    if (expectedType == null || containsUninferredParameter) {
                        trace.report(CANNOT_INFER_PARAMETER_TYPE.on(valueParameter))
                    }

                    expectedType ?: TypeUtils.CANT_INFER_FUNCTION_PARAM_TYPE
                }
                else {
                    trace.report(VALUE_PARAMETER_WITH_NO_TYPE_ANNOTATION.on(valueParameter))
                    ErrorUtils.createErrorType("Type annotation was missing for parameter ${valueParameter.nameAsSafeName}")
                }' @ [350:24] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType, elseBranch: KotlinType): KotlinType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType

'isFunctionLiteral' @ [350:28] ==> public open fun isFunctionLiteral(@Nullable descriptor: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingUtils[JavaMethodDescriptor]

'functionDescriptor' @ [350:46] ==> value-parameter functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'isFunctionExpression' @ [350:69] ==> public open fun isFunctionExpression(@Nullable descriptor: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingUtils[JavaMethodDescriptor]

'functionDescriptor' @ [350:90] ==> value-parameter functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'contains' @ [351:65] ==> public open fun contains(@Nullable p0: KotlinType?, @NotNull p1: ((UnwrappedType..UnwrappedType?)) -> (Boolean..Boolean?)): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'expectedType' @ [351:74] ==> val expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'isDontCarePlaceholder' @ [352:35] ==> public open fun isDontCarePlaceholder(@Nullable p0: KotlinType?): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'it' @ [352:57] ==> value-parameter it: (UnwrappedType..UnwrappedType?) defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters.<anonymous>[ValueParameterDescriptorImpl]

'isUninferredParameter' @ [352:75] ==> public open fun isUninferredParameter(@Nullable p0: KotlinType?): Boolean defined in org.jetbrains.kotlin.types.ErrorUtils[JavaMethodDescriptor]

'it' @ [352:97] ==> value-parameter it: (UnwrappedType..UnwrappedType?) defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters.<anonymous>[ValueParameterDescriptorImpl]

'expectedType' @ [354:25] ==> val expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'containsUninferredParameter' @ [354:49] ==> val containsUninferredParameter: Boolean defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'trace' @ [355:25] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'report' @ [355:31] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'CANNOT_INFER_PARAMETER_TYPE' @ [355:38] ==> public final val CANNOT_INFER_PARAMETER_TYPE: (DiagnosticFactory0<(KtParameter..KtParameter?)>..DiagnosticFactory0<(KtParameter..KtParameter?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [355:66] ==> @NotNull public open fun on(@NotNull element: KtParameter): SimpleDiagnostic<(KtParameter..KtParameter?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'valueParameter' @ [355:69] ==> val valueParameter: KtParameter defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'expectedType' @ [358:21] ==> val expectedType: KotlinType? defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'CANT_INFER_FUNCTION_PARAM_TYPE' @ [358:47] ==> public final val CANT_INFER_FUNCTION_PARAM_TYPE: (SimpleType..SimpleType?) defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'trace' @ [361:21] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'report' @ [361:27] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'VALUE_PARAMETER_WITH_NO_TYPE_ANNOTATION' @ [361:34] ==> public final val VALUE_PARAMETER_WITH_NO_TYPE_ANNOTATION: (DiagnosticFactory0<(KtParameter..KtParameter?)>..DiagnosticFactory0<(KtParameter..KtParameter?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [361:74] ==> @NotNull public open fun on(@NotNull element: KtParameter): SimpleDiagnostic<(KtParameter..KtParameter?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'valueParameter' @ [361:77] ==> val valueParameter: KtParameter defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'createErrorType' @ [362:32] ==> @NotNull public open fun createErrorType(@NotNull p0: String): SimpleType defined in org.jetbrains.kotlin.types.ErrorUtils[JavaMethodDescriptor]

'valueParameter' @ [362:93] ==> val valueParameter: KtParameter defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'nameAsSafeName' @ [362:108] ==> public final val KtParameter.nameAsSafeName: Name[MyPropertyDescriptor]

'functionDescriptor' @ [366:17] ==> value-parameter functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'!' @ [366:65] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'functionDescriptor' @ [366:66] ==> value-parameter functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'isPrimary' @ [366:85] ==> public final val ConstructorDescriptor.isPrimary: Boolean[MyPropertyDescriptor]

'functionDescriptor' @ [367:37] ==> value-parameter functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'with' @ [368:17] ==> @InlineOnly public inline fun <T, R> with(receiver: ModifiersChecker.ModifiersCheckingProcedure, block: (ModifiersChecker.ModifiersCheckingProcedure).() -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ModifiersCheckingProcedure
    <R> -> Unit

'modifiersChecker' @ [368:23] ==> private final val modifiersChecker: ModifiersChecker defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[PropertyDescriptorImpl]

'withTrace' @ [368:40] ==> @NotNull public open fun withTrace(@NotNull trace: BindingTrace): ModifiersChecker.ModifiersCheckingProcedure defined in org.jetbrains.kotlin.resolve.ModifiersChecker[JavaMethodDescriptor]

'trace' @ [368:50] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'checkParameterHasNoValOrVar' @ [369:21] ==> public open fun checkParameterHasNoValOrVar(@NotNull parameter: KtValVarKeywordOwner, @NotNull diagnosticFactory: DiagnosticFactory1<(PsiElement..PsiElement?), (KtKeywordToken..KtKeywordToken?)>): Unit defined in org.jetbrains.kotlin.resolve.ModifiersChecker.ModifiersCheckingProcedure[JavaMethodDescriptor]

'valueParameter' @ [370:29] ==> val valueParameter: KtParameter defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'if (isConstructor) VAL_OR_VAR_ON_SECONDARY_CONSTRUCTOR_PARAMETER else VAL_OR_VAR_ON_FUN_PARAMETER' @ [371:29] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (DiagnosticFactory1<(PsiElement..PsiElement?), (KtKeywordToken..KtKeywordToken?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (KtKeywordToken..KtKeywordToken?)>?), elseBranch: (DiagnosticFactory1<(PsiElement..PsiElement?), (KtKeywordToken..KtKeywordToken?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (KtKeywordToken..KtKeywordToken?)>?)): (DiagnosticFactory1<(PsiElement..PsiElement?), (KtKeywordToken..KtKeywordToken?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (KtKeywordToken..KtKeywordToken?)>?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (org.jetbrains.kotlin.diagnostics.DiagnosticFactory1<(com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?), (org.jetbrains.kotlin.lexer.KtKeywordToken..org.jetbrains.kotlin.lexer.KtKeywordToken?)>..org.jetbrains.kotlin.diagnostics.DiagnosticFactory1<(com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?), (org.jetbrains.kotlin.lexer.KtKeywordToken..org.jetbrains.kotlin.lexer.KtKeywordToken?)>?)

'isConstructor' @ [371:33] ==> val isConstructor: Boolean defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'VAL_OR_VAR_ON_SECONDARY_CONSTRUCTOR_PARAMETER' @ [371:48] ==> public final val VAL_OR_VAR_ON_SECONDARY_CONSTRUCTOR_PARAMETER: (DiagnosticFactory1<(PsiElement..PsiElement?), (KtKeywordToken..KtKeywordToken?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (KtKeywordToken..KtKeywordToken?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'VAL_OR_VAR_ON_FUN_PARAMETER' @ [371:99] ==> public final val VAL_OR_VAR_ON_FUN_PARAMETER: (DiagnosticFactory1<(PsiElement..PsiElement?), (KtKeywordToken..KtKeywordToken?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (KtKeywordToken..KtKeywordToken?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'descriptorResolver' @ [376:44] ==> private final val descriptorResolver: DescriptorResolver defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver[PropertyDescriptorImpl]

'resolveValueParameterDescriptor' @ [376:63] ==> @NotNull public open fun resolveValueParameterDescriptor(@NotNull scope: LexicalScope, @NotNull owner: FunctionDescriptor, @NotNull valueParameter: KtParameter, index: Int, @NotNull type: KotlinType, @NotNull trace: BindingTrace): ValueParameterDescriptorImpl defined in org.jetbrains.kotlin.resolve.DescriptorResolver[JavaMethodDescriptor]

'parameterScope' @ [376:95] ==> value-parameter parameterScope: LexicalWritableScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'functionDescriptor' @ [376:111] ==> value-parameter functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'valueParameter' @ [377:95] ==> val valueParameter: KtParameter defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'i' @ [377:111] ==> val i: Int defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'type' @ [377:114] ==> val type: KotlinType defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'trace' @ [377:120] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'checkVariableShadowing' @ [380:35] ==> public open fun checkVariableShadowing(@NotNull scope: LexicalScope, @NotNull trace: BindingTrace, @NotNull variableDescriptor: VariableDescriptor): Unit defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingUtils[JavaMethodDescriptor]

'parameterScope' @ [380:58] ==> value-parameter parameterScope: LexicalWritableScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'trace' @ [380:74] ==> value-parameter trace: BindingTrace defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'valueParameterDescriptor' @ [380:81] ==> val valueParameterDescriptor: ValueParameterDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'parameterScope' @ [382:13] ==> value-parameter parameterScope: LexicalWritableScope defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[ValueParameterDescriptorImpl]

'addVariableDescriptor' @ [382:28] ==> public final fun addVariableDescriptor(variableDescriptor: VariableDescriptor): Unit defined in org.jetbrains.kotlin.resolve.scopes.LexicalWritableScope[DeserializedSimpleFunctionDescriptor]

'valueParameterDescriptor' @ [382:50] ==> val valueParameterDescriptor: ValueParameterDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'result' @ [383:13] ==> val result: ArrayList<ValueParameterDescriptor> defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'add' @ [383:20] ==> public open fun add(element: ValueParameterDescriptor): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'valueParameterDescriptor' @ [383:24] ==> val valueParameterDescriptor: ValueParameterDescriptorImpl defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

'result' @ [385:16] ==> val result: ArrayList<ValueParameterDescriptor> defined in org.jetbrains.kotlin.resolve.FunctionDescriptorResolver.resolveValueParameters[LocalVariableDescriptor]

