'descriptor' @ [37:13] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.check[ValueParameterDescriptorImpl]

'!' @ [37:50] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'declaration' @ [37:51] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.check[ValueParameterDescriptorImpl]

'hasModifier' @ [37:63] ==> public abstract fun hasModifier(@NotNull modifier: KtModifierKeywordToken): Boolean defined in org.jetbrains.kotlin.psi.KtDeclaration[JavaMethodDescriptor]

'CONST_KEYWORD' @ [37:84] ==> public final val CONST_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'declaration' @ [39:39] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.check[ValueParameterDescriptorImpl]

'modifierList' @ [39:51] ==> public final val KtDeclaration.modifierList: KtModifierList?[MyPropertyDescriptor]

'getModifier' @ [39:66] ==> @Nullable public open fun getModifier(@NotNull tokenType: KtModifierKeywordToken): PsiElement? defined in org.jetbrains.kotlin.psi.KtModifierList[JavaMethodDescriptor]

'CONST_KEYWORD' @ [39:87] ==> public final val CONST_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'checkCanBeConst' @ [41:26] ==> private final fun checkCanBeConst(declaration: KtDeclaration, constModifierPsiElement: PsiElement, descriptor: VariableDescriptor): ConstApplicability defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker[SimpleFunctionDescriptorImpl]

'declaration' @ [41:42] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.check[ValueParameterDescriptorImpl]

'constModifierPsiElement' @ [41:55] ==> val constModifierPsiElement: PsiElement defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.check[LocalVariableDescriptor]

'descriptor' @ [41:80] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.check[ValueParameterDescriptorImpl]

'diagnostic' @ [41:92] ==> public final val diagnostic: Diagnostic? defined in org.jetbrains.kotlin.resolve.checkers.ConstApplicability[PropertyDescriptorImpl]

'diagnostic' @ [42:13] ==> val diagnostic: Diagnostic? defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.check[LocalVariableDescriptor]

'diagnosticHolder' @ [43:13] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.check[ValueParameterDescriptorImpl]

'report' @ [43:30] ==> public abstract fun report(@NotNull diagnostic: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'diagnostic' @ [43:37] ==> val diagnostic: Diagnostic? defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.check[LocalVariableDescriptor]

'checkCanBeConst' @ [48:13] ==> private final fun checkCanBeConst(declaration: KtDeclaration, constModifierPsiElement: PsiElement, descriptor: VariableDescriptor): ConstApplicability defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker[SimpleFunctionDescriptorImpl]

'declaration' @ [48:29] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.canBeConst[ValueParameterDescriptorImpl]

'constModifierPsiElement' @ [48:42] ==> value-parameter constModifierPsiElement: PsiElement defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.canBeConst[ValueParameterDescriptorImpl]

'descriptor' @ [48:67] ==> value-parameter descriptor: VariableDescriptor defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.canBeConst[ValueParameterDescriptorImpl]

'canBeConst' @ [48:79] ==> public final val canBeConst: Boolean defined in org.jetbrains.kotlin.resolve.checkers.ConstApplicability[PropertyDescriptorImpl]

'descriptor' @ [53:13] ==> value-parameter descriptor: VariableDescriptor defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.checkCanBeConst[ValueParameterDescriptorImpl]

'isVar' @ [53:24] ==> public final val VariableDescriptor.isVar: Boolean[MyPropertyDescriptor]

'WRONG_MODIFIER_TARGET' @ [54:27] ==> public final val WRONG_MODIFIER_TARGET: (DiagnosticFactory2<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?), (String..String?)>..DiagnosticFactory2<(PsiElement..PsiElement?), (KtModifierKeywordToken..KtModifierKeywordToken?), (String..String?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [54:49] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull a: KtModifierKeywordToken, @NotNull b: String): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory2[JavaMethodDescriptor]

'constModifierPsiElement' @ [54:52] ==> value-parameter constModifierPsiElement: PsiElement defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.checkCanBeConst[ValueParameterDescriptorImpl]

'CONST_KEYWORD' @ [54:86] ==> public final val CONST_KEYWORD: (KtModifierKeywordToken..KtModifierKeywordToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'nonApplicable' @ [54:109] ==> private fun Diagnostic.nonApplicable(): ConstApplicability.NonApplicable defined in org.jetbrains.kotlin.resolve.checkers in file ConstModifierChecker.kt[SimpleFunctionDescriptorImpl]

'descriptor' @ [57:37] ==> value-parameter descriptor: VariableDescriptor defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.checkCanBeConst[ValueParameterDescriptorImpl]

'containingDeclaration' @ [57:48] ==> public final val VariableDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'containingDeclaration' @ [58:13] ==> val containingDeclaration: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.checkCanBeConst[LocalVariableDescriptor]

'containingDeclaration' @ [58:57] ==> val containingDeclaration: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.checkCanBeConst[LocalVariableDescriptor]

'kind' @ [58:79] ==> public final val ClassDescriptor.kind: ClassKind[MyPropertyDescriptor]

'OBJECT' @ [58:97] ==> enum entry OBJECT defined in org.jetbrains.kotlin.descriptors.ClassKind[FakeCallableDescriptorForObject]

'CONST_VAL_NOT_TOP_LEVEL_OR_OBJECT' @ [59:27] ==> public final val CONST_VAL_NOT_TOP_LEVEL_OR_OBJECT: (DiagnosticFactory0<(PsiElement..PsiElement?)>..DiagnosticFactory0<(PsiElement..PsiElement?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [59:61] ==> @NotNull public open fun on(@NotNull element: PsiElement): SimpleDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'constModifierPsiElement' @ [59:64] ==> value-parameter constModifierPsiElement: PsiElement defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.checkCanBeConst[ValueParameterDescriptorImpl]

'nonApplicable' @ [59:89] ==> private fun Diagnostic.nonApplicable(): ConstApplicability.NonApplicable defined in org.jetbrains.kotlin.resolve.checkers in file ConstModifierChecker.kt[SimpleFunctionDescriptorImpl]

'declaration' @ [62:13] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.checkCanBeConst[ValueParameterDescriptorImpl]

'descriptor' @ [62:43] ==> value-parameter descriptor: VariableDescriptor defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.checkCanBeConst[ValueParameterDescriptorImpl]

'NonApplicable' @ [62:104] ==> public constructor NonApplicable(diagnostic: Diagnostic? = ...) defined in org.jetbrains.kotlin.resolve.checkers.ConstApplicability.NonApplicable[ClassConstructorDescriptorImpl]

'declaration' @ [64:13] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.checkCanBeConst[ValueParameterDescriptorImpl]

'hasDelegate' @ [64:25] ==> public open fun hasDelegate(): Boolean defined in org.jetbrains.kotlin.psi.KtProperty[JavaMethodDescriptor]

'CONST_VAL_WITH_DELEGATE' @ [65:27] ==> public final val CONST_VAL_WITH_DELEGATE: (DiagnosticFactory0<(PsiElement..PsiElement?)>..DiagnosticFactory0<(PsiElement..PsiElement?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [65:51] ==> @NotNull public open fun on(@NotNull element: PsiElement): SimpleDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'declaration' @ [65:54] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.checkCanBeConst[ValueParameterDescriptorImpl]

'delegate' @ [65:66] ==> public final val KtProperty.delegate: KtPropertyDelegate?[MyPropertyDescriptor]

'nonApplicable' @ [65:78] ==> private fun Diagnostic.nonApplicable(): ConstApplicability.NonApplicable defined in org.jetbrains.kotlin.resolve.checkers in file ConstModifierChecker.kt[SimpleFunctionDescriptorImpl]

'!' @ [68:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'descriptor' @ [68:14] ==> value-parameter descriptor: VariableDescriptor defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.checkCanBeConst[ValueParameterDescriptorImpl]

'getter' @ [68:25] ==> public abstract val getter: PropertyGetterDescriptor? defined in org.jetbrains.kotlin.descriptors.PropertyDescriptor[JavaPropertyDescriptor]

'isDefault' @ [68:34] ==> public final val PropertyGetterDescriptor.isDefault: Boolean[MyPropertyDescriptor]

'CONST_VAL_WITH_GETTER' @ [69:27] ==> public final val CONST_VAL_WITH_GETTER: (DiagnosticFactory0<(PsiElement..PsiElement?)>..DiagnosticFactory0<(PsiElement..PsiElement?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [69:49] ==> @NotNull public open fun on(@NotNull element: PsiElement): SimpleDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'declaration' @ [69:52] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.checkCanBeConst[ValueParameterDescriptorImpl]

'getter' @ [69:64] ==> public final val KtProperty.getter: KtPropertyAccessor?[MyPropertyDescriptor]

'nonApplicable' @ [69:74] ==> private fun Diagnostic.nonApplicable(): ConstApplicability.NonApplicable defined in org.jetbrains.kotlin.resolve.checkers in file ConstModifierChecker.kt[SimpleFunctionDescriptorImpl]

'descriptor' @ [72:13] ==> value-parameter descriptor: VariableDescriptor defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.checkCanBeConst[ValueParameterDescriptorImpl]

'type' @ [72:24] ==> public final val PropertyDescriptor.type: KotlinType[MyPropertyDescriptor]

'isError' @ [72:29] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types[DeserializedPropertyDescriptor]

'NonApplicable' @ [72:64] ==> public constructor NonApplicable(diagnostic: Diagnostic? = ...) defined in org.jetbrains.kotlin.resolve.checkers.ConstApplicability.NonApplicable[ClassConstructorDescriptorImpl]

'!' @ [75:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'descriptor' @ [75:14] ==> value-parameter descriptor: VariableDescriptor defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.checkCanBeConst[ValueParameterDescriptorImpl]

'type' @ [75:25] ==> public final val PropertyDescriptor.type: KotlinType[MyPropertyDescriptor]

'canBeUsedForConstVal' @ [75:30] ==> public fun KotlinType.canBeUsedForConstVal(): Boolean defined in org.jetbrains.kotlin.descriptors[DeserializedSimpleFunctionDescriptor]

'TYPE_CANT_BE_USED_FOR_CONST_VAL' @ [76:27] ==> public final val TYPE_CANT_BE_USED_FOR_CONST_VAL: (DiagnosticFactory1<(PsiElement..PsiElement?), (KotlinType..KotlinType?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [76:59] ==> @NotNull public open fun on(@NotNull element: PsiElement, @NotNull argument: KotlinType): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory1[JavaMethodDescriptor]

'constModifierPsiElement' @ [76:62] ==> value-parameter constModifierPsiElement: PsiElement defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.checkCanBeConst[ValueParameterDescriptorImpl]

'descriptor' @ [76:87] ==> value-parameter descriptor: VariableDescriptor defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.checkCanBeConst[ValueParameterDescriptorImpl]

'type' @ [76:98] ==> public final val PropertyDescriptor.type: KotlinType[MyPropertyDescriptor]

'nonApplicable' @ [76:104] ==> private fun Diagnostic.nonApplicable(): ConstApplicability.NonApplicable defined in org.jetbrains.kotlin.resolve.checkers in file ConstModifierChecker.kt[SimpleFunctionDescriptorImpl]

'declaration' @ [79:13] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.checkCanBeConst[ValueParameterDescriptorImpl]

'initializer' @ [79:25] ==> public final var KtProperty.initializer: KtExpression?[MyPropertyDescriptor]

'CONST_VAL_WITHOUT_INITIALIZER' @ [80:27] ==> public final val CONST_VAL_WITHOUT_INITIALIZER: (DiagnosticFactory0<(PsiElement..PsiElement?)>..DiagnosticFactory0<(PsiElement..PsiElement?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [80:57] ==> @NotNull public open fun on(@NotNull element: PsiElement): SimpleDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'constModifierPsiElement' @ [80:60] ==> value-parameter constModifierPsiElement: PsiElement defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.checkCanBeConst[ValueParameterDescriptorImpl]

'nonApplicable' @ [80:85] ==> private fun Diagnostic.nonApplicable(): ConstApplicability.NonApplicable defined in org.jetbrains.kotlin.resolve.checkers in file ConstModifierChecker.kt[SimpleFunctionDescriptorImpl]

'descriptor' @ [83:13] ==> value-parameter descriptor: VariableDescriptor defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.checkCanBeConst[ValueParameterDescriptorImpl]

'compileTimeInitializer' @ [83:24] ==> public final val PropertyDescriptor.compileTimeInitializer: ConstantValue<*>?[MyPropertyDescriptor]

'CONST_VAL_WITH_NON_CONST_INITIALIZER' @ [84:27] ==> public final val CONST_VAL_WITH_NON_CONST_INITIALIZER: (DiagnosticFactory0<(KtExpression..KtExpression?)>..DiagnosticFactory0<(KtExpression..KtExpression?)>?) defined in org.jetbrains.kotlin.diagnostics.Errors[JavaPropertyDescriptor]

'on' @ [84:64] ==> @NotNull public open fun on(@NotNull element: KtExpression): SimpleDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'declaration' @ [84:67] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.resolve.checkers.ConstModifierChecker.checkCanBeConst[ValueParameterDescriptorImpl]

'initializer' @ [84:79] ==> public final var KtProperty.initializer: KtExpression?[MyPropertyDescriptor]

'nonApplicable' @ [84:94] ==> private fun Diagnostic.nonApplicable(): ConstApplicability.NonApplicable defined in org.jetbrains.kotlin.resolve.checkers in file ConstModifierChecker.kt[SimpleFunctionDescriptorImpl]

'Applicable' @ [87:35] ==> public object Applicable : ConstApplicability defined in org.jetbrains.kotlin.resolve.checkers.ConstApplicability[FakeCallableDescriptorForObject]

'ConstApplicability' @ [92:25] ==> private constructor ConstApplicability(canBeConst: Boolean, diagnostic: Diagnostic?) defined in org.jetbrains.kotlin.resolve.checkers.ConstApplicability[ClassConstructorDescriptorImpl]

'ConstApplicability' @ [93:59] ==> private constructor ConstApplicability(canBeConst: Boolean, diagnostic: Diagnostic?) defined in org.jetbrains.kotlin.resolve.checkers.ConstApplicability[ClassConstructorDescriptorImpl]

'diagnostic' @ [93:85] ==> value-parameter diagnostic: Diagnostic? = ... defined in org.jetbrains.kotlin.resolve.checkers.ConstApplicability.NonApplicable.<init>[ValueParameterDescriptorImpl]

'NonApplicable' @ [96:61] ==> public constructor NonApplicable(diagnostic: Diagnostic? = ...) defined in org.jetbrains.kotlin.resolve.checkers.ConstApplicability.NonApplicable[ClassConstructorDescriptorImpl]

'this' @ [96:75] ==> <this> defined in org.jetbrains.kotlin.resolve.checkers.nonApplicable[ReceiverParameterDescriptorImpl]

