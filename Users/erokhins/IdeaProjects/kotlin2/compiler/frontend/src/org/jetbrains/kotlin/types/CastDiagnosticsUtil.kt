'JvmStatic' @ [39:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'isNullableType' @ [45:37] ==> public open fun isNullableType(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'rhsType' @ [45:52] ==> value-parameter rhsType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastPossible[ValueParameterDescriptorImpl]

'isNullableType' @ [46:37] ==> public open fun isNullableType(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'lhsType' @ [46:52] ==> value-parameter lhsType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastPossible[ValueParameterDescriptorImpl]

'isNullableNothing' @ [47:28] ==> public open fun isNullableNothing(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'lhsType' @ [47:46] ==> value-parameter lhsType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastPossible[ValueParameterDescriptorImpl]

'!' @ [47:58] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'rhsNullable' @ [47:59] ==> val rhsNullable: Boolean defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastPossible[LocalVariableDescriptor]

'isNothing' @ [48:28] ==> public open fun isNothing(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'rhsType' @ [48:38] ==> value-parameter rhsType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastPossible[ValueParameterDescriptorImpl]

'isNullableNothing' @ [49:28] ==> public open fun isNullableNothing(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'rhsType' @ [49:46] ==> value-parameter rhsType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastPossible[ValueParameterDescriptorImpl]

'lhsNullable' @ [49:63] ==> val lhsNullable: Boolean defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastPossible[LocalVariableDescriptor]

'lhsNullable' @ [50:13] ==> val lhsNullable: Boolean defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastPossible[LocalVariableDescriptor]

'rhsNullable' @ [50:28] ==> val rhsNullable: Boolean defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastPossible[LocalVariableDescriptor]

'lhsType' @ [51:13] ==> value-parameter lhsType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastPossible[ValueParameterDescriptorImpl]

'isError' @ [51:21] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types[DeserializedPropertyDescriptor]

'isRelated' @ [52:13] ==> private final fun isRelated(a: KotlinType, b: KotlinType, platformToKotlinClassMap: PlatformToKotlinClassMap): Boolean defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil[SimpleFunctionDescriptorImpl]

'lhsType' @ [52:23] ==> value-parameter lhsType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastPossible[ValueParameterDescriptorImpl]

'rhsType' @ [52:32] ==> value-parameter rhsType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastPossible[ValueParameterDescriptorImpl]

'platformToKotlinClassMap' @ [52:41] ==> value-parameter platformToKotlinClassMap: PlatformToKotlinClassMap defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastPossible[ValueParameterDescriptorImpl]

'isTypeParameter' @ [55:23] ==> public open fun isTypeParameter(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'lhsType' @ [55:39] ==> value-parameter lhsType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastPossible[ValueParameterDescriptorImpl]

'isTypeParameter' @ [55:61] ==> public open fun isTypeParameter(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'rhsType' @ [55:77] ==> value-parameter rhsType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastPossible[ValueParameterDescriptorImpl]

'isFinal' @ [57:13] ==> private final fun isFinal(type: KotlinType): Boolean defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil[SimpleFunctionDescriptorImpl]

'lhsType' @ [57:21] ==> value-parameter lhsType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastPossible[ValueParameterDescriptorImpl]

'isFinal' @ [57:33] ==> private final fun isFinal(type: KotlinType): Boolean defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil[SimpleFunctionDescriptorImpl]

'rhsType' @ [57:41] ==> value-parameter rhsType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastPossible[ValueParameterDescriptorImpl]

'isTrait' @ [58:13] ==> private final fun isTrait(type: KotlinType): Boolean defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil[SimpleFunctionDescriptorImpl]

'lhsType' @ [58:21] ==> value-parameter lhsType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastPossible[ValueParameterDescriptorImpl]

'isTrait' @ [58:33] ==> private final fun isTrait(type: KotlinType): Boolean defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil[SimpleFunctionDescriptorImpl]

'rhsType' @ [58:41] ==> value-parameter rhsType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastPossible[ValueParameterDescriptorImpl]

'mapToPlatformClasses' @ [72:24] ==> private final fun mapToPlatformClasses(type: KotlinType, platformToKotlinClassMap: PlatformToKotlinClassMap): List<ClassDescriptor> defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil[SimpleFunctionDescriptorImpl]

'a' @ [72:45] ==> value-parameter a: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isRelated[ValueParameterDescriptorImpl]

'platformToKotlinClassMap' @ [72:48] ==> value-parameter platformToKotlinClassMap: PlatformToKotlinClassMap defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isRelated[ValueParameterDescriptorImpl]

'mapToPlatformClasses' @ [73:24] ==> private final fun mapToPlatformClasses(type: KotlinType, platformToKotlinClassMap: PlatformToKotlinClassMap): List<ClassDescriptor> defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil[SimpleFunctionDescriptorImpl]

'b' @ [73:45] ==> value-parameter b: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isRelated[ValueParameterDescriptorImpl]

'platformToKotlinClassMap' @ [73:48] ==> value-parameter platformToKotlinClassMap: PlatformToKotlinClassMap defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isRelated[ValueParameterDescriptorImpl]

'aClasses' @ [75:16] ==> val aClasses: List<ClassDescriptor> defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isRelated[LocalVariableDescriptor]

'any' @ [75:25] ==> public inline fun <T> Iterable<ClassDescriptor>.any(predicate: (ClassDescriptor) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ClassDescriptor

'isSubtypeOfClass' @ [75:47] ==> public open fun isSubtypeOfClass(@NotNull p0: KotlinType, @NotNull p1: DeclarationDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'b' @ [75:64] ==> value-parameter b: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isRelated[ValueParameterDescriptorImpl]

'it' @ [75:67] ==> value-parameter it: ClassDescriptor defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isRelated.<anonymous>[ValueParameterDescriptorImpl]

'bClasses' @ [75:76] ==> val bClasses: List<ClassDescriptor> defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isRelated[LocalVariableDescriptor]

'any' @ [75:85] ==> public inline fun <T> Iterable<ClassDescriptor>.any(predicate: (ClassDescriptor) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ClassDescriptor

'isSubtypeOfClass' @ [75:107] ==> public open fun isSubtypeOfClass(@NotNull p0: KotlinType, @NotNull p1: DeclarationDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'a' @ [75:124] ==> value-parameter a: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isRelated[ValueParameterDescriptorImpl]

'it' @ [75:127] ==> value-parameter it: ClassDescriptor defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isRelated.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [82:26] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.mapToPlatformClasses[ValueParameterDescriptorImpl]

'constructor' @ [82:31] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'declarationDescriptor' @ [82:43] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'listOf' @ [82:95] ==> @InlineOnly public inline fun <T> listOf(): List<ClassDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ClassDescriptor

'platformToKotlinClassMap' @ [84:16] ==> value-parameter platformToKotlinClassMap: PlatformToKotlinClassMap defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.mapToPlatformClasses[ValueParameterDescriptorImpl]

'mapPlatformClass' @ [84:41] ==> @NotNull public abstract fun mapPlatformClass(@NotNull p0: ClassDescriptor): (MutableCollection<(ClassDescriptor..ClassDescriptor?)>..Collection<(ClassDescriptor..ClassDescriptor?)>) defined in org.jetbrains.kotlin.platform.PlatformToKotlinClassMap[JavaMethodDescriptor]

'descriptor' @ [84:58] ==> val descriptor: ClassDescriptor defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.mapToPlatformClasses[LocalVariableDescriptor]

'descriptor' @ [84:72] ==> val descriptor: ClassDescriptor defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.mapToPlatformClasses[LocalVariableDescriptor]

'!' @ [87:45] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'canHaveSubtypes' @ [87:56] ==> public open fun canHaveSubtypes(p0: (KotlinTypeChecker..KotlinTypeChecker?), @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'DEFAULT' @ [87:90] ==> public final val DEFAULT: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaPropertyDescriptor]

'type' @ [87:99] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isFinal[ValueParameterDescriptorImpl]

'type' @ [90:13] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isTrait[ValueParameterDescriptorImpl]

'constructor' @ [90:18] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'declarationDescriptor' @ [90:30] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'let' @ [90:52] ==> @InlineOnly public inline fun <T, R> ClassifierDescriptor?.let(block: (ClassifierDescriptor?) -> Boolean): Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ClassifierDescriptor?
    <R> -> Boolean

'it' @ [90:58] ==> value-parameter it: ClassifierDescriptor? defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isTrait.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [90:83] ==> value-parameter it: ClassifierDescriptor? defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isTrait.<anonymous>[ValueParameterDescriptorImpl]

'kind' @ [90:86] ==> public final val ClassDescriptor.kind: ClassKind[MyPropertyDescriptor]

'INTERFACE' @ [90:104] ==> enum entry INTERFACE defined in org.jetbrains.kotlin.descriptors.ClassKind[FakeCallableDescriptorForObject]

'JvmStatic' @ [96:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'isNonReifiedTypeParameter' @ [98:51] ==> public open fun isNonReifiedTypeParameter(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'subtype' @ [98:77] ==> value-parameter subtype: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastErased[ValueParameterDescriptorImpl]

'typeChecker' @ [99:24] ==> value-parameter typeChecker: KotlinTypeChecker defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastErased[ValueParameterDescriptorImpl]

'isSubtypeOf' @ [99:36] ==> public abstract fun isSubtypeOf(@NotNull p0: KotlinType, @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaMethodDescriptor]

'supertype' @ [99:48] ==> value-parameter supertype: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastErased[ValueParameterDescriptorImpl]

'subtype' @ [99:59] ==> value-parameter subtype: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastErased[ValueParameterDescriptorImpl]

'isNonReifiedTypeParameter' @ [102:13] ==> val isNonReifiedTypeParameter: Boolean defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastErased[LocalVariableDescriptor]

'!' @ [102:42] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isUpcast' @ [102:43] ==> val isUpcast: Boolean defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastErased[LocalVariableDescriptor]

'!' @ [104:47] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isNullableType' @ [104:58] ==> public open fun isNullableType(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'subtype' @ [104:73] ==> value-parameter subtype: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastErased[ValueParameterDescriptorImpl]

'supertype' @ [104:85] ==> value-parameter supertype: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastErased[ValueParameterDescriptorImpl]

'makeNotNullable' @ [104:95] ==> public fun KotlinType.makeNotNullable(): KotlinType defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'subtype' @ [104:116] ==> value-parameter subtype: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastErased[ValueParameterDescriptorImpl]

'!' @ [105:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'nullableToDefinitelyNotNull' @ [105:18] ==> val nullableToDefinitelyNotNull: Boolean defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastErased[LocalVariableDescriptor]

'supertype' @ [111:13] ==> value-parameter supertype: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastErased[ValueParameterDescriptorImpl]

'isMarkedNullable' @ [111:23] ==> public abstract val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'subtype' @ [111:43] ==> value-parameter subtype: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastErased[ValueParameterDescriptorImpl]

'isMarkedNullable' @ [111:51] ==> public abstract val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'isCastErased' @ [112:20] ==> @JvmStatic public final fun isCastErased(supertype: KotlinType, subtype: KotlinType, typeChecker: KotlinTypeChecker): Boolean defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil[SimpleFunctionDescriptorImpl]

'makeNotNullable' @ [112:43] ==> @NotNull public open fun makeNotNullable(@NotNull p0: KotlinType): KotlinType defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'supertype' @ [112:59] ==> value-parameter supertype: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastErased[ValueParameterDescriptorImpl]

'makeNotNullable' @ [112:81] ==> @NotNull public open fun makeNotNullable(@NotNull p0: KotlinType): KotlinType defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'subtype' @ [112:97] ==> value-parameter subtype: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastErased[ValueParameterDescriptorImpl]

'typeChecker' @ [112:107] ==> value-parameter typeChecker: KotlinTypeChecker defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastErased[ValueParameterDescriptorImpl]

'isUpcast' @ [116:13] ==> val isUpcast: Boolean defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastErased[LocalVariableDescriptor]

'isNonReifiedTypeParameter' @ [119:13] ==> val isNonReifiedTypeParameter: Boolean defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastErased[LocalVariableDescriptor]

'allParametersReified' @ [123:13] ==> private final fun allParametersReified(subtype: KotlinType): Boolean defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil[SimpleFunctionDescriptorImpl]

'subtype' @ [123:34] ==> value-parameter subtype: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastErased[ValueParameterDescriptorImpl]

'findStaticallyKnownSubtype' @ [125:38] ==> @JvmStatic public final fun findStaticallyKnownSubtype(supertype: KotlinType, subtypeConstructor: TypeConstructor): TypeReconstructionResult defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil[SimpleFunctionDescriptorImpl]

'supertype' @ [125:65] ==> value-parameter supertype: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastErased[ValueParameterDescriptorImpl]

'subtype' @ [125:76] ==> value-parameter subtype: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastErased[ValueParameterDescriptorImpl]

'constructor' @ [125:84] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'resultingType' @ [125:97] ==> public final val TypeReconstructionResult.resultingType: KotlinType?[MyPropertyDescriptor]

'!' @ [132:16] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'typeChecker' @ [132:17] ==> value-parameter typeChecker: KotlinTypeChecker defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastErased[ValueParameterDescriptorImpl]

'isSubtypeOf' @ [132:29] ==> public abstract fun isSubtypeOf(@NotNull p0: KotlinType, @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaMethodDescriptor]

'staticallyKnownSubtype' @ [132:41] ==> val staticallyKnownSubtype: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastErased[LocalVariableDescriptor]

'subtype' @ [132:65] ==> value-parameter subtype: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isCastErased[ValueParameterDescriptorImpl]

'JvmStatic' @ [151:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'assert' @ [153:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'!' @ [153:16] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'supertype' @ [153:17] ==> value-parameter supertype: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[ValueParameterDescriptorImpl]

'isMarkedNullable' @ [153:27] ==> public abstract val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'subtypeConstructor' @ [157:26] ==> value-parameter subtypeConstructor: TypeConstructor defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[ValueParameterDescriptorImpl]

'declarationDescriptor' @ [157:45] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'error' @ [157:70] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'+' @ [157:76] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'subtypeConstructor' @ [157:111] ==> value-parameter subtypeConstructor: TypeConstructor defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[ValueParameterDescriptorImpl]

'descriptor' @ [158:36] ==> val descriptor: ClassifierDescriptor defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[LocalVariableDescriptor]

'defaultType' @ [158:47] ==> public final val ClassifierDescriptor.defaultType: SimpleType[MyPropertyDescriptor]

'findCorrespondingSupertype' @ [162:60] ==> @Nullable public open fun findCorrespondingSupertype(@NotNull p0: KotlinType, @NotNull p1: KotlinType): KotlinType? defined in org.jetbrains.kotlin.types.checker.TypeCheckingProcedure[JavaMethodDescriptor]

'subtypeWithVariables' @ [162:87] ==> val subtypeWithVariables: SimpleType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[LocalVariableDescriptor]

'supertype' @ [162:109] ==> value-parameter supertype: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[ValueParameterDescriptorImpl]

'subtypeWithVariables' @ [164:25] ==> val subtypeWithVariables: SimpleType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[LocalVariableDescriptor]

'constructor' @ [164:46] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'parameters' @ [164:58] ==> public final val TypeConstructor.parameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'variables' @ [165:36] ==> val variables: List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[LocalVariableDescriptor]

'map' @ [165:46] ==> public inline fun <T, R> Iterable<(TypeParameterDescriptor..TypeParameterDescriptor?)>.map(transform: ((TypeParameterDescriptor..TypeParameterDescriptor?)) -> TypeConstructor): List<TypeConstructor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)
    <R> -> TypeConstructor

'descriptor' @ [165:66] ==> value-parameter descriptor: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype.<anonymous>[ValueParameterDescriptorImpl]

'typeConstructor' @ [165:77] ==> public final val TypeParameterDescriptor.typeConstructor: TypeConstructor[MyPropertyDescriptor]

'toSet' @ [165:95] ==> public fun <T> Iterable<TypeConstructor>.toSet(): Set<TypeConstructor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeConstructor

'if (supertypeWithVariables != null) {
            // Now, let's try to unify Collection<T> and Collection<Foo> solution is a map from T to Foo
            val solution = TypeUnifier.unify(
                    TypeProjectionImpl(supertype), TypeProjectionImpl(supertypeWithVariables), variableConstructors::contains
            )
            Maps.newHashMap(solution.substitution)
        }
        else {
            // If there's no corresponding supertype, no variables are determined
            // This may be OK, e.g. in case 'Any as List<*>'
            Maps.newHashMapWithExpectedSize<TypeConstructor, TypeProjection>(variables.size)
        }' @ [167:73] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: MutableMap<TypeConstructor, TypeProjection>, elseBranch: MutableMap<TypeConstructor, TypeProjection>): MutableMap<TypeConstructor, TypeProjection>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> MutableMap<TypeConstructor, TypeProjection>

'supertypeWithVariables' @ [167:77] ==> val supertypeWithVariables: KotlinType? defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[LocalVariableDescriptor]

'unify' @ [169:40] ==> @NotNull public final fun unify(@NotNull knownProjection: TypeProjection, @NotNull projectWithVariables: TypeProjection, @NotNull isVariable: ((TypeConstructor..TypeConstructor?)) -> Boolean): TypeUnifier.UnificationResult defined in org.jetbrains.kotlin.types.TypeUnifier[SamAdapterFunctionDescriptor]

'TypeProjectionImpl' @ [170:21] ==> public constructor TypeProjectionImpl(@NotNull p0: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'supertype' @ [170:40] ==> value-parameter supertype: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[ValueParameterDescriptorImpl]

'TypeProjectionImpl' @ [170:52] ==> public constructor TypeProjectionImpl(@NotNull p0: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'supertypeWithVariables' @ [170:71] ==> val supertypeWithVariables: KotlinType? defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[LocalVariableDescriptor]

'variableConstructors' @ [170:96] ==> val variableConstructors: Set<TypeConstructor> defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[LocalVariableDescriptor]

'contains' @ [170:118] ==> public abstract fun contains(element: TypeConstructor): Boolean defined in kotlin.collections.Set[DeserializedSimpleFunctionDescriptor]

'newHashMap' @ [172:18] ==> public open fun <K : (Any..Any?), V : (Any..Any?)> newHashMap(p0: (MutableMap<out (TypeConstructor..TypeConstructor?), out (TypeProjection..TypeProjection?)>..Map<out (TypeConstructor..TypeConstructor?), (TypeProjection..TypeProjection?)>?)): (HashMap<(TypeConstructor..TypeConstructor?), (TypeProjection..TypeProjection?)>..HashMap<(TypeConstructor..TypeConstructor?), (TypeProjection..TypeProjection?)>?) defined in com.google.common.collect.Maps[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.types.TypeConstructor..org.jetbrains.kotlin.types.TypeConstructor?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.types.TypeProjection..org.jetbrains.kotlin.types.TypeProjection?)

'solution' @ [172:29] ==> val solution: TypeUnifier.UnificationResult defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[LocalVariableDescriptor]

'substitution' @ [172:38] ==> public final val TypeUnifier.UnificationResult.substitution: (MutableMap<(TypeConstructor..TypeConstructor?), (TypeProjection..TypeProjection?)>..Map<(TypeConstructor..TypeConstructor?), (TypeProjection..TypeProjection?)>)[MyPropertyDescriptor]

'newHashMapWithExpectedSize' @ [177:18] ==> public open fun <K : (Any..Any?), V : (Any..Any?)> newHashMapWithExpectedSize(p0: Int): (HashMap<(TypeConstructor..TypeConstructor?), (TypeProjection..TypeProjection?)>..HashMap<(TypeConstructor..TypeConstructor?), (TypeProjection..TypeProjection?)>?) defined in com.google.common.collect.Maps[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> TypeConstructor
    <V : (Any..Any?)> -> TypeProjection

'variables' @ [177:78] ==> val variables: List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[LocalVariableDescriptor]

'size' @ [177:88] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'variables' @ [183:26] ==> val variables: List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[LocalVariableDescriptor]

'substitution' @ [184:25] ==> val substitution: MutableMap<TypeConstructor, TypeProjection> defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[LocalVariableDescriptor]

'variable' @ [184:38] ==> val variable: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[LocalVariableDescriptor]

'typeConstructor' @ [184:47] ==> public final val TypeParameterDescriptor.typeConstructor: TypeConstructor[MyPropertyDescriptor]

'value' @ [185:17] ==> val value: TypeProjection? defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[LocalVariableDescriptor]

'substitution' @ [186:17] ==> val substitution: MutableMap<TypeConstructor, TypeProjection> defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[LocalVariableDescriptor]

'put' @ [186:30] ==> public abstract fun put(key: TypeConstructor, value: TypeProjection): TypeProjection? defined in kotlin.collections.MutableMap[DeserializedSimpleFunctionDescriptor]

'variable' @ [187:25] ==> val variable: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[LocalVariableDescriptor]

'typeConstructor' @ [187:34] ==> public final val TypeParameterDescriptor.typeConstructor: TypeConstructor[MyPropertyDescriptor]

'makeStarProjection' @ [188:35] ==> @NotNull public open fun makeStarProjection(@NotNull p0: TypeParameterDescriptor): TypeProjection defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'variable' @ [188:54] ==> val variable: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[LocalVariableDescriptor]

'allArgumentsInferred' @ [189:17] ==> var allArgumentsInferred: Boolean defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[LocalVariableDescriptor]

'create' @ [195:43] ==> @NotNull public open fun create(@NotNull p0: (MutableMap<(TypeConstructor..TypeConstructor?), (TypeProjection..TypeProjection?)>..Map<(TypeConstructor..TypeConstructor?), (TypeProjection..TypeProjection?)>)): TypeSubstitutor defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'substitution' @ [195:50] ==> val substitution: MutableMap<TypeConstructor, TypeProjection> defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[LocalVariableDescriptor]

'substitute' @ [195:64] ==> @Nullable public open fun substitute(@NotNull p0: KotlinType, @NotNull p1: Variance): KotlinType? defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'subtypeWithVariables' @ [195:75] ==> val subtypeWithVariables: SimpleType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[LocalVariableDescriptor]

'INVARIANT' @ [195:106] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'TypeReconstructionResult' @ [197:16] ==> public constructor TypeReconstructionResult(@Nullable resultingType: KotlinType?, allArgumentsInferred: Boolean) defined in org.jetbrains.kotlin.types.TypeReconstructionResult[JavaClassConstructorDescriptor]

'substituted' @ [197:41] ==> val substituted: KotlinType? defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[LocalVariableDescriptor]

'allArgumentsInferred' @ [197:54] ==> var allArgumentsInferred: Boolean defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.findStaticallyKnownSubtype[LocalVariableDescriptor]

'subtype' @ [200:61] ==> value-parameter subtype: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.allParametersReified[ValueParameterDescriptorImpl]

'constructor' @ [200:69] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'parameters' @ [200:81] ==> public final val TypeConstructor.parameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'all' @ [200:92] ==> public inline fun <T> Iterable<(TypeParameterDescriptor..TypeParameterDescriptor?)>.all(predicate: ((TypeParameterDescriptor..TypeParameterDescriptor?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)

'it' @ [200:98] ==> value-parameter it: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.allParametersReified.<anonymous>[ValueParameterDescriptorImpl]

'isReified' @ [200:101] ==> public final val TypeParameterDescriptor.isReified: Boolean[MyPropertyDescriptor]

'if (KtPsiUtil.isSafeCast(expression)) TypeUtils.makeNullable(targetType) else targetType' @ [210:33] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType, elseBranch: KotlinType): KotlinType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType

'isSafeCast' @ [210:47] ==> public open fun isSafeCast(@NotNull expression: KtBinaryExpressionWithTypeRHS): Boolean defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'expression' @ [210:58] ==> value-parameter expression: KtBinaryExpressionWithTypeRHS defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.castIsUseless[ValueParameterDescriptorImpl]

'makeNullable' @ [210:81] ==> @NotNull public open fun makeNullable(@NotNull p0: KotlinType): KotlinType defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'targetType' @ [210:94] ==> value-parameter targetType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.castIsUseless[ValueParameterDescriptorImpl]

'targetType' @ [210:111] ==> value-parameter targetType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.castIsUseless[ValueParameterDescriptorImpl]

'getAllPossibleTypes' @ [211:46] ==> @NotNull public open fun getAllPossibleTypes(@NotNull expression: KtExpression, @NotNull type: KotlinType, @NotNull c: raw (ResolutionContext<(ResolutionContext<*>..ResolutionContext<*>?)>..ResolutionContext<out (ResolutionContext<*>..ResolutionContext<*>?)>)): (MutableCollection<(KotlinType..KotlinType?)>..Collection<(KotlinType..KotlinType?)>) defined in org.jetbrains.kotlin.types.expressions.DataFlowAnalyzer[JavaMethodDescriptor]

'expression' @ [211:66] ==> value-parameter expression: KtBinaryExpressionWithTypeRHS defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.castIsUseless[ValueParameterDescriptorImpl]

'left' @ [211:77] ==> public final val KtBinaryExpressionWithTypeRHS.left: KtExpression[MyPropertyDescriptor]

'actualType' @ [211:83] ==> value-parameter actualType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.castIsUseless[ValueParameterDescriptorImpl]

'context' @ [211:95] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.castIsUseless[ValueParameterDescriptorImpl]

'isRefinementUseless' @ [212:16] ==> public final fun isRefinementUseless(possibleTypes: Collection<KotlinType>, targetType: KotlinType, typeChecker: KotlinTypeChecker, shouldCheckForExactType: Boolean): Boolean defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil[SimpleFunctionDescriptorImpl]

'possibleTypes' @ [212:36] ==> val possibleTypes: (MutableCollection<(KotlinType..KotlinType?)>..Collection<(KotlinType..KotlinType?)>) defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.castIsUseless[LocalVariableDescriptor]

'refinedTargetType' @ [212:51] ==> val refinedTargetType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.castIsUseless[LocalVariableDescriptor]

'typeChecker' @ [212:70] ==> value-parameter typeChecker: KotlinTypeChecker defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.castIsUseless[ValueParameterDescriptorImpl]

'shouldCheckForExactType' @ [212:83] ==> private final fun shouldCheckForExactType(expression: KtBinaryExpressionWithTypeRHS, expectedType: KotlinType): Boolean defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil[SimpleFunctionDescriptorImpl]

'expression' @ [212:107] ==> value-parameter expression: KtBinaryExpressionWithTypeRHS defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.castIsUseless[ValueParameterDescriptorImpl]

'context' @ [212:119] ==> value-parameter context: ExpressionTypingContext defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.castIsUseless[ValueParameterDescriptorImpl]

'expectedType' @ [212:127] ==> @NotNull public final val expectedType: KotlinType defined in org.jetbrains.kotlin.types.expressions.ExpressionTypingContext[JavaPropertyDescriptor]

'?:' @ [222:31] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KotlinType?, right: KotlinType): KotlinType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KotlinType

'intersectTypes' @ [222:47] ==> @Nullable public open fun intersectTypes(@NotNull typeChecker: KotlinTypeChecker, @NotNull types: (MutableCollection<(KotlinType..KotlinType?)>..Collection<(KotlinType..KotlinType?)>)): KotlinType? defined in org.jetbrains.kotlin.types.TypeIntersector[JavaMethodDescriptor]

'typeChecker' @ [222:62] ==> value-parameter typeChecker: KotlinTypeChecker defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isRefinementUseless[ValueParameterDescriptorImpl]

'possibleTypes' @ [222:75] ==> value-parameter possibleTypes: Collection<KotlinType> defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isRefinementUseless[ValueParameterDescriptorImpl]

'map' @ [222:89] ==> public inline fun <T, R> Iterable<KotlinType>.map(transform: (KotlinType) -> SimpleType): List<SimpleType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType
    <R> -> SimpleType

'it' @ [222:95] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isRefinementUseless.<anonymous>[ValueParameterDescriptorImpl]

'upperIfFlexible' @ [222:98] ==> public fun KotlinType.upperIfFlexible(): SimpleType defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'if (shouldCheckForExactType)
            isExactTypeCast(intersectedType, targetType)
        else
            isUpcast(intersectedType, targetType, typeChecker)' @ [224:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Boolean, elseBranch: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Boolean

'shouldCheckForExactType' @ [224:20] ==> value-parameter shouldCheckForExactType: Boolean defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isRefinementUseless[ValueParameterDescriptorImpl]

'isExactTypeCast' @ [225:13] ==> private final fun isExactTypeCast(candidateType: KotlinType, targetType: KotlinType): Boolean defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil[SimpleFunctionDescriptorImpl]

'intersectedType' @ [225:29] ==> val intersectedType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isRefinementUseless[LocalVariableDescriptor]

'targetType' @ [225:46] ==> value-parameter targetType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isRefinementUseless[ValueParameterDescriptorImpl]

'isUpcast' @ [227:13] ==> private final fun isUpcast(candidateType: KotlinType, targetType: KotlinType, typeChecker: KotlinTypeChecker): Boolean defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil[SimpleFunctionDescriptorImpl]

'intersectedType' @ [227:22] ==> val intersectedType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isRefinementUseless[LocalVariableDescriptor]

'targetType' @ [227:39] ==> value-parameter targetType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isRefinementUseless[ValueParameterDescriptorImpl]

'typeChecker' @ [227:51] ==> value-parameter typeChecker: KotlinTypeChecker defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isRefinementUseless[ValueParameterDescriptorImpl]

'noExpectedType' @ [231:23] ==> public open fun noExpectedType(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'expectedType' @ [231:38] ==> value-parameter expectedType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.shouldCheckForExactType[ValueParameterDescriptorImpl]

'checkExactTypeForUselessCast' @ [232:20] ==> private final fun checkExactTypeForUselessCast(expression: KtBinaryExpressionWithTypeRHS): Boolean defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil[SimpleFunctionDescriptorImpl]

'expression' @ [232:49] ==> value-parameter expression: KtBinaryExpressionWithTypeRHS defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.shouldCheckForExactType[ValueParameterDescriptorImpl]

'isDontCarePlaceholder' @ [237:26] ==> public open fun isDontCarePlaceholder(@Nullable p0: KotlinType?): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'expectedType' @ [237:48] ==> value-parameter expectedType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.shouldCheckForExactType[ValueParameterDescriptorImpl]

'candidateType' @ [241:16] ==> value-parameter candidateType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isExactTypeCast[ValueParameterDescriptorImpl]

'targetType' @ [241:33] ==> value-parameter targetType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isExactTypeCast[ValueParameterDescriptorImpl]

'candidateType' @ [241:47] ==> value-parameter candidateType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isExactTypeCast[ValueParameterDescriptorImpl]

'isExtensionFunctionType' @ [241:61] ==> public val KotlinType.isExtensionFunctionType: Boolean defined in org.jetbrains.kotlin.builtins[DeserializedPropertyDescriptor]

'targetType' @ [241:88] ==> value-parameter targetType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isExactTypeCast[ValueParameterDescriptorImpl]

'isExtensionFunctionType' @ [241:99] ==> public val KotlinType.isExtensionFunctionType: Boolean defined in org.jetbrains.kotlin.builtins[DeserializedPropertyDescriptor]

'!' @ [245:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'typeChecker' @ [245:14] ==> value-parameter typeChecker: KotlinTypeChecker defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isUpcast[ValueParameterDescriptorImpl]

'isSubtypeOf' @ [245:26] ==> public abstract fun isSubtypeOf(@NotNull p0: KotlinType, @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaMethodDescriptor]

'candidateType' @ [245:38] ==> value-parameter candidateType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isUpcast[ValueParameterDescriptorImpl]

'targetType' @ [245:53] ==> value-parameter targetType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isUpcast[ValueParameterDescriptorImpl]

'candidateType' @ [247:13] ==> value-parameter candidateType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isUpcast[ValueParameterDescriptorImpl]

'isFunctionType' @ [247:27] ==> public val KotlinType.isFunctionType: Boolean defined in org.jetbrains.kotlin.builtins[DeserializedPropertyDescriptor]

'targetType' @ [247:45] ==> value-parameter targetType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isUpcast[ValueParameterDescriptorImpl]

'isFunctionType' @ [247:56] ==> public val KotlinType.isFunctionType: Boolean defined in org.jetbrains.kotlin.builtins[DeserializedPropertyDescriptor]

'candidateType' @ [248:20] ==> value-parameter candidateType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isUpcast[ValueParameterDescriptorImpl]

'isExtensionFunctionType' @ [248:34] ==> public val KotlinType.isExtensionFunctionType: Boolean defined in org.jetbrains.kotlin.builtins[DeserializedPropertyDescriptor]

'targetType' @ [248:61] ==> value-parameter targetType: KotlinType defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.isUpcast[ValueParameterDescriptorImpl]

'isExtensionFunctionType' @ [248:72] ==> public val KotlinType.isExtensionFunctionType: Boolean defined in org.jetbrains.kotlin.builtins[DeserializedPropertyDescriptor]

'expression' @ [257:22] ==> value-parameter expression: KtBinaryExpressionWithTypeRHS defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.checkExactTypeForUselessCast[ValueParameterDescriptorImpl]

'parent' @ [257:33] ==> public final val KtBinaryExpressionWithTypeRHS.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [258:16] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.checkExactTypeForUselessCast[LocalVariableDescriptor]

'parent' @ [259:16] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.checkExactTypeForUselessCast[LocalVariableDescriptor]

'parent' @ [260:16] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.checkExactTypeForUselessCast[LocalVariableDescriptor]

'parent' @ [261:13] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.checkExactTypeForUselessCast[LocalVariableDescriptor]

'parent' @ [261:22] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.checkExactTypeForUselessCast[LocalVariableDescriptor]

'parent' @ [261:29] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'when (parent) {
            is KtValueArgument -> true

            is KtQualifiedExpression -> {
                val receiver = parent.receiverExpression
                PsiTreeUtil.isAncestor(receiver, expression, false)
            }

            // in binary expression, left argument can be a receiver and right an argument
            // in unary expression, left argument can be a receiver
            is KtBinaryExpression, is KtUnaryExpression -> true

            // Previously we've checked that there is no expected type, therefore cast in property has an effect on inference
            is KtProperty, is KtPropertyAccessor -> true

            else -> false
        }' @ [264:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean, entry2: Boolean, entry3: Boolean, entry4: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'parent' @ [264:22] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.checkExactTypeForUselessCast[LocalVariableDescriptor]

'parent' @ [268:32] ==> var parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.checkExactTypeForUselessCast[LocalVariableDescriptor]

'receiverExpression' @ [268:39] ==> public open val receiverExpression: KtExpression defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[PropertyDescriptorImpl]

'isAncestor' @ [269:29] ==> @Contract public open fun isAncestor(@Nullable p0: PsiElement?, @NotNull p1: PsiElement, p2: Boolean): Boolean defined in com.intellij.psi.util.PsiTreeUtil[JavaMethodDescriptor]

'receiver' @ [269:40] ==> val receiver: KtExpression defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.checkExactTypeForUselessCast[LocalVariableDescriptor]

'expression' @ [269:50] ==> value-parameter expression: KtBinaryExpressionWithTypeRHS defined in org.jetbrains.kotlin.types.CastDiagnosticsUtil.checkExactTypeForUselessCast[ValueParameterDescriptorImpl]

