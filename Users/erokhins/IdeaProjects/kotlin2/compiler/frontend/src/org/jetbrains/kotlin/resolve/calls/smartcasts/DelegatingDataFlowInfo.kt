'this' @ [47:20] ==> private constructor DelegatingDataFlowInfo(parent: DataFlowInfo?, nullabilityInfo: Map<DataFlowValue, Nullability>, typeInfo: SetMultimap<DataFlowValue, KotlinType>, valueWithGivenTypeInfo: DataFlowValue?) defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[ClassConstructorDescriptorImpl]

'emptyMap' @ [47:31] ==> public fun <K, V> emptyMap(): Map<DataFlowValue, Nullability> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> DataFlowValue
    <V> -> Nullability

'newTypeInfo' @ [47:43] ==> public final fun newTypeInfo(): SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion[SimpleFunctionDescriptorImpl]

'hashMapOf' @ [51:26] ==> @SinceKotlin @InlineOnly public inline fun <K, V> hashMapOf(): HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> DataFlowValue
    <V> -> Nullability

'this' @ [52:49] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[LazyClassReceiverParameterDescriptor]

'info' @ [53:20] ==> var info: DelegatingDataFlowInfo? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.<get-completeNullabilityInfo>[LocalVariableDescriptor]

'component1' @ [54:23] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<DataFlowValue, Nullability>.component1(): DataFlowValue defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> DataFlowValue
    <V> -> Nullability

'component2' @ [54:28] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<DataFlowValue, Nullability>.component2(): Nullability defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> DataFlowValue
    <V> -> Nullability

'info' @ [54:38] ==> var info: DelegatingDataFlowInfo? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.<get-completeNullabilityInfo>[LocalVariableDescriptor]

'nullabilityInfo' @ [54:43] ==> private final val nullabilityInfo: Map<DataFlowValue, Nullability> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[PropertyDescriptorImpl]

'!' @ [55:25] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'result' @ [55:26] ==> val result: HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.<get-completeNullabilityInfo>[LocalVariableDescriptor]

'containsKey' @ [55:33] ==> public open fun containsKey(key: DataFlowValue): Boolean defined in java.util.HashMap[JavaMethodDescriptor]

'key' @ [55:45] ==> val key: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.<get-completeNullabilityInfo>[LocalVariableDescriptor]

'result' @ [56:25] ==> val result: HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.<get-completeNullabilityInfo>[LocalVariableDescriptor]

'put' @ [56:32] ==> public open fun put(key: DataFlowValue, value: Nullability): Nullability? defined in java.util.HashMap[JavaMethodDescriptor]

'key' @ [56:36] ==> val key: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.<get-completeNullabilityInfo>[LocalVariableDescriptor]

'value' @ [56:41] ==> val value: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.<get-completeNullabilityInfo>[LocalVariableDescriptor]

'info' @ [59:17] ==> var info: DelegatingDataFlowInfo? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.<get-completeNullabilityInfo>[LocalVariableDescriptor]

'info' @ [59:24] ==> var info: DelegatingDataFlowInfo? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.<get-completeNullabilityInfo>[LocalVariableDescriptor]

'parent' @ [59:29] ==> private final val parent: DataFlowInfo? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[PropertyDescriptorImpl]

'result' @ [61:20] ==> val result: HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.<get-completeNullabilityInfo>[LocalVariableDescriptor]

'newTypeInfo' @ [66:26] ==> public final fun newTypeInfo(): SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion[SimpleFunctionDescriptorImpl]

'HashSet' @ [67:37] ==> public constructor HashSet<E : (Any..Any?)>() defined in java.util.HashSet[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> DataFlowValue

'this' @ [68:49] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[LazyClassReceiverParameterDescriptor]

'info' @ [69:20] ==> var info: DelegatingDataFlowInfo? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.<get-completeTypeInfo>[LocalVariableDescriptor]

'info' @ [70:29] ==> var info: DelegatingDataFlowInfo? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.<get-completeTypeInfo>[LocalVariableDescriptor]

'typeInfo' @ [70:34] ==> private final val typeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[PropertyDescriptorImpl]

'keySet' @ [70:43] ==> public abstract fun keySet(): (MutableSet<(DataFlowValue..DataFlowValue?)>..Set<(DataFlowValue..DataFlowValue?)>?) defined in com.google.common.collect.SetMultimap[JavaMethodDescriptor]

'!' @ [71:25] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'withGivenTypeInfo' @ [71:26] ==> val withGivenTypeInfo: HashSet<DataFlowValue> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.<get-completeTypeInfo>[LocalVariableDescriptor]

'contains' @ [71:44] ==> public open fun contains(element: DataFlowValue): Boolean defined in java.util.HashSet[JavaMethodDescriptor]

'key' @ [71:53] ==> val key: (DataFlowValue..DataFlowValue?) defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.<get-completeTypeInfo>[LocalVariableDescriptor]

'result' @ [72:25] ==> val result: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.<get-completeTypeInfo>[LocalVariableDescriptor]

'putAll' @ [72:32] ==> @CanIgnoreReturnValue public abstract fun putAll(@Nullable p0: DataFlowValue?, p1: (MutableIterable<(KotlinType..KotlinType?)>..Iterable<(KotlinType..KotlinType?)>?)): Boolean defined in com.google.common.collect.SetMultimap[JavaMethodDescriptor]

'key' @ [72:39] ==> val key: (DataFlowValue..DataFlowValue?) defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.<get-completeTypeInfo>[LocalVariableDescriptor]

'info' @ [72:44] ==> var info: DelegatingDataFlowInfo? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.<get-completeTypeInfo>[LocalVariableDescriptor]

'typeInfo' @ [72:49] ==> private final val typeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[PropertyDescriptorImpl]

'get' @ [72:58] ==> public abstract fun get(@Nullable p0: DataFlowValue?): (MutableSet<(KotlinType..KotlinType?)>..Set<(KotlinType..KotlinType?)>?) defined in com.google.common.collect.SetMultimap[JavaMethodDescriptor]

'key' @ [72:62] ==> val key: (DataFlowValue..DataFlowValue?) defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.<get-completeTypeInfo>[LocalVariableDescriptor]

'info' @ [75:17] ==> var info: DelegatingDataFlowInfo? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.<get-completeTypeInfo>[LocalVariableDescriptor]

'valueWithGivenTypeInfo' @ [75:22] ==> private final val valueWithGivenTypeInfo: DataFlowValue? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[PropertyDescriptorImpl]

'let' @ [75:46] ==> @InlineOnly public inline fun <T, R> DataFlowValue.let(block: (DataFlowValue) -> Boolean): Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DataFlowValue
    <R> -> Boolean

'withGivenTypeInfo' @ [75:52] ==> val withGivenTypeInfo: HashSet<DataFlowValue> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.<get-completeTypeInfo>[LocalVariableDescriptor]

'add' @ [75:70] ==> public open fun add(element: DataFlowValue): Boolean defined in java.util.HashSet[JavaMethodDescriptor]

'it' @ [75:74] ==> value-parameter it: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.<get-completeTypeInfo>.<anonymous>[ValueParameterDescriptorImpl]

'info' @ [76:17] ==> var info: DelegatingDataFlowInfo? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.<get-completeTypeInfo>[LocalVariableDescriptor]

'info' @ [76:24] ==> var info: DelegatingDataFlowInfo? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.<get-completeTypeInfo>[LocalVariableDescriptor]

'parent' @ [76:29] ==> private final val parent: DataFlowInfo? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[PropertyDescriptorImpl]

'result' @ [78:20] ==> val result: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.<get-completeTypeInfo>[LocalVariableDescriptor]

'getNullability' @ [81:64] ==> private final fun getNullability(key: DataFlowValue, stableOnly: Boolean): Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'key' @ [81:79] ==> value-parameter key: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getCollectedNullability[ValueParameterDescriptorImpl]

'getNullability' @ [83:61] ==> private final fun getNullability(key: DataFlowValue, stableOnly: Boolean): Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'key' @ [83:76] ==> value-parameter key: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getStableNullability[ValueParameterDescriptorImpl]

'if (stableOnly && !key.isStable) {
                key.immanentNullability
            }
            else {
                nullabilityInfo[key] ?: parent?.getCollectedNullability(key) ?: key.immanentNullability
            }' @ [86:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nullability, elseBranch: Nullability): Nullability[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nullability

'stableOnly' @ [86:17] ==> value-parameter stableOnly: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getNullability[ValueParameterDescriptorImpl]

'!' @ [86:31] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'key' @ [86:32] ==> value-parameter key: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getNullability[ValueParameterDescriptorImpl]

'isStable' @ [86:36] ==> public final val isStable: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'key' @ [87:17] ==> value-parameter key: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getNullability[ValueParameterDescriptorImpl]

'immanentNullability' @ [87:21] ==> public final val immanentNullability: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'nullabilityInfo' @ [90:17] ==> private final val nullabilityInfo: Map<DataFlowValue, Nullability> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[PropertyDescriptorImpl]

'key' @ [90:33] ==> value-parameter key: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getNullability[ValueParameterDescriptorImpl]

'parent' @ [90:41] ==> private final val parent: DataFlowInfo? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[PropertyDescriptorImpl]

'getCollectedNullability' @ [90:49] ==> public abstract fun getCollectedNullability(key: DataFlowValue): Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo[SimpleFunctionDescriptorImpl]

'key' @ [90:73] ==> value-parameter key: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getNullability[ValueParameterDescriptorImpl]

'key' @ [90:81] ==> value-parameter key: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getNullability[ValueParameterDescriptorImpl]

'immanentNullability' @ [90:85] ==> public final val immanentNullability: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'map' @ [101:9] ==> value-parameter map: MutableMap<DataFlowValue, Nullability> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[ValueParameterDescriptorImpl]

'put' @ [101:13] ==> public abstract fun put(key: DataFlowValue, value: Nullability): Nullability? defined in kotlin.collections.MutableMap[DeserializedSimpleFunctionDescriptor]

'value' @ [101:17] ==> value-parameter value: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[ValueParameterDescriptorImpl]

'nullability' @ [101:24] ==> value-parameter nullability: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[ValueParameterDescriptorImpl]

'value' @ [103:30] ==> value-parameter value: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[ValueParameterDescriptorImpl]

'identifierInfo' @ [103:36] ==> public final val identifierInfo: IdentifierInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'affectReceiver' @ [104:13] ==> value-parameter affectReceiver: Boolean = ... defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[ValueParameterDescriptorImpl]

'!' @ [104:31] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'nullability' @ [104:32] ==> value-parameter nullability: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[ValueParameterDescriptorImpl]

'canBeNull' @ [104:44] ==> public open fun canBeNull(): Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.Nullability[JavaMethodDescriptor]

'languageVersionSettings' @ [105:13] ==> value-parameter languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[ValueParameterDescriptorImpl]

'supportsFeature' @ [105:37] ==> public open fun supportsFeature(feature: LanguageFeature): Boolean defined in org.jetbrains.kotlin.config.LanguageVersionSettings[DeserializedSimpleFunctionDescriptor]

'LanguageFeature' @ [105:53] ==> public companion object defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'SafeCallBoundSmartCasts' @ [105:69] ==> enum entry SafeCallBoundSmartCasts defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'when (identifierInfo) {
                is IdentifierInfo.Qualified -> {
                    val receiverType = identifierInfo.receiverType
                    if (identifierInfo.safe && receiverType != null) {
                        val receiverValue = DataFlowValue(identifierInfo.receiverInfo, receiverType)
                        putNullabilityAndTypeInfo(map, receiverValue, nullability, languageVersionSettings, typeInfo)
                    }
                }
                is IdentifierInfo.SafeCast -> {
                    val targetType = identifierInfo.targetType
                    val subjectType = identifierInfo.subjectType
                    if (targetType != null && subjectType != null &&
                        languageVersionSettings.supportsFeature(LanguageFeature.SafeCastCheckBoundSmartCasts)) {

                        val subjectValue = DataFlowValue(identifierInfo.subjectInfo, subjectType)
                        putNullabilityAndTypeInfo(map, subjectValue, nullability, languageVersionSettings, typeInfo)
                        typeInfo?.put(subjectValue, targetType)
                    }
                }
                is IdentifierInfo.Variable -> identifierInfo.bound?.let {
                    putNullabilityAndTypeInfo(map, it, nullability, languageVersionSettings, typeInfo)
                }
            }' @ [106:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Any?, entry1: Any?, entry2: Any?): Any?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Any?

'identifierInfo' @ [106:19] ==> val identifierInfo: IdentifierInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[LocalVariableDescriptor]

'identifierInfo' @ [108:40] ==> val identifierInfo: IdentifierInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[LocalVariableDescriptor]

'receiverType' @ [108:55] ==> public final val receiverType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.IdentifierInfo.Qualified[PropertyDescriptorImpl]

'identifierInfo' @ [109:25] ==> val identifierInfo: IdentifierInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[LocalVariableDescriptor]

'safe' @ [109:40] ==> public final val safe: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.IdentifierInfo.Qualified[PropertyDescriptorImpl]

'receiverType' @ [109:48] ==> val receiverType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[LocalVariableDescriptor]

'DataFlowValue' @ [110:45] ==> public constructor DataFlowValue(identifierInfo: IdentifierInfo, type: KotlinType, immanentNullability: Nullability = ...) defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[ClassConstructorDescriptorImpl]

'identifierInfo' @ [110:59] ==> val identifierInfo: IdentifierInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[LocalVariableDescriptor]

'receiverInfo' @ [110:74] ==> public final val receiverInfo: IdentifierInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.IdentifierInfo.Qualified[PropertyDescriptorImpl]

'receiverType' @ [110:88] ==> val receiverType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[LocalVariableDescriptor]

'putNullabilityAndTypeInfo' @ [111:25] ==> private final fun putNullabilityAndTypeInfo(map: MutableMap<DataFlowValue, Nullability>, value: DataFlowValue, nullability: Nullability, languageVersionSettings: LanguageVersionSettings, typeInfo: SetMultimap<DataFlowValue, KotlinType>? = ..., affectReceiver: Boolean = ...): Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'map' @ [111:51] ==> value-parameter map: MutableMap<DataFlowValue, Nullability> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[ValueParameterDescriptorImpl]

'receiverValue' @ [111:56] ==> val receiverValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[LocalVariableDescriptor]

'nullability' @ [111:71] ==> value-parameter nullability: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[ValueParameterDescriptorImpl]

'languageVersionSettings' @ [111:84] ==> value-parameter languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[ValueParameterDescriptorImpl]

'typeInfo' @ [111:109] ==> value-parameter typeInfo: SetMultimap<DataFlowValue, KotlinType>? = ... defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[ValueParameterDescriptorImpl]

'identifierInfo' @ [115:38] ==> val identifierInfo: IdentifierInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[LocalVariableDescriptor]

'targetType' @ [115:53] ==> public final val targetType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.IdentifierInfo.SafeCast[PropertyDescriptorImpl]

'identifierInfo' @ [116:39] ==> val identifierInfo: IdentifierInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[LocalVariableDescriptor]

'subjectType' @ [116:54] ==> public final val subjectType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.IdentifierInfo.SafeCast[PropertyDescriptorImpl]

'targetType' @ [117:25] ==> val targetType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[LocalVariableDescriptor]

'subjectType' @ [117:47] ==> val subjectType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[LocalVariableDescriptor]

'languageVersionSettings' @ [118:25] ==> value-parameter languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[ValueParameterDescriptorImpl]

'supportsFeature' @ [118:49] ==> public open fun supportsFeature(feature: LanguageFeature): Boolean defined in org.jetbrains.kotlin.config.LanguageVersionSettings[DeserializedSimpleFunctionDescriptor]

'LanguageFeature' @ [118:65] ==> public companion object defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'SafeCastCheckBoundSmartCasts' @ [118:81] ==> enum entry SafeCastCheckBoundSmartCasts defined in org.jetbrains.kotlin.config.LanguageFeature[FakeCallableDescriptorForObject]

'DataFlowValue' @ [120:44] ==> public constructor DataFlowValue(identifierInfo: IdentifierInfo, type: KotlinType, immanentNullability: Nullability = ...) defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[ClassConstructorDescriptorImpl]

'identifierInfo' @ [120:58] ==> val identifierInfo: IdentifierInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[LocalVariableDescriptor]

'subjectInfo' @ [120:73] ==> public final val subjectInfo: IdentifierInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.IdentifierInfo.SafeCast[PropertyDescriptorImpl]

'subjectType' @ [120:86] ==> val subjectType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[LocalVariableDescriptor]

'putNullabilityAndTypeInfo' @ [121:25] ==> private final fun putNullabilityAndTypeInfo(map: MutableMap<DataFlowValue, Nullability>, value: DataFlowValue, nullability: Nullability, languageVersionSettings: LanguageVersionSettings, typeInfo: SetMultimap<DataFlowValue, KotlinType>? = ..., affectReceiver: Boolean = ...): Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'map' @ [121:51] ==> value-parameter map: MutableMap<DataFlowValue, Nullability> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[ValueParameterDescriptorImpl]

'subjectValue' @ [121:56] ==> val subjectValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[LocalVariableDescriptor]

'nullability' @ [121:70] ==> value-parameter nullability: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[ValueParameterDescriptorImpl]

'languageVersionSettings' @ [121:83] ==> value-parameter languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[ValueParameterDescriptorImpl]

'typeInfo' @ [121:108] ==> value-parameter typeInfo: SetMultimap<DataFlowValue, KotlinType>? = ... defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[ValueParameterDescriptorImpl]

'typeInfo' @ [122:25] ==> value-parameter typeInfo: SetMultimap<DataFlowValue, KotlinType>? = ... defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[ValueParameterDescriptorImpl]

'put' @ [122:35] ==> @CanIgnoreReturnValue public abstract fun put(@Nullable p0: DataFlowValue?, @Nullable p1: KotlinType?): Boolean defined in com.google.common.collect.SetMultimap[JavaMethodDescriptor]

'subjectValue' @ [122:39] ==> val subjectValue: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[LocalVariableDescriptor]

'targetType' @ [122:53] ==> val targetType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[LocalVariableDescriptor]

'identifierInfo' @ [125:47] ==> val identifierInfo: IdentifierInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[LocalVariableDescriptor]

'bound' @ [125:62] ==> public final val bound: DataFlowValue? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.IdentifierInfo.Variable[PropertyDescriptorImpl]

'let' @ [125:69] ==> @InlineOnly public inline fun <T, R> DataFlowValue.let(block: (DataFlowValue) -> Boolean): Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DataFlowValue
    <R> -> Boolean

'putNullabilityAndTypeInfo' @ [126:21] ==> private final fun putNullabilityAndTypeInfo(map: MutableMap<DataFlowValue, Nullability>, value: DataFlowValue, nullability: Nullability, languageVersionSettings: LanguageVersionSettings, typeInfo: SetMultimap<DataFlowValue, KotlinType>? = ..., affectReceiver: Boolean = ...): Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'map' @ [126:47] ==> value-parameter map: MutableMap<DataFlowValue, Nullability> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[ValueParameterDescriptorImpl]

'it' @ [126:52] ==> value-parameter it: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo.<anonymous>[ValueParameterDescriptorImpl]

'nullability' @ [126:56] ==> value-parameter nullability: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[ValueParameterDescriptorImpl]

'languageVersionSettings' @ [126:69] ==> value-parameter languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[ValueParameterDescriptorImpl]

'typeInfo' @ [126:94] ==> value-parameter typeInfo: SetMultimap<DataFlowValue, KotlinType>? = ... defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[ValueParameterDescriptorImpl]

'nullability' @ [131:16] ==> value-parameter nullability: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[ValueParameterDescriptorImpl]

'getCollectedNullability' @ [131:31] ==> public open fun getCollectedNullability(key: DataFlowValue): Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'value' @ [131:55] ==> value-parameter value: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.putNullabilityAndTypeInfo[ValueParameterDescriptorImpl]

'getCollectedTypes' @ [134:58] ==> private final fun getCollectedTypes(key: DataFlowValue, enrichWithNotNull: Boolean): Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'key' @ [134:76] ==> value-parameter key: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getCollectedTypes[ValueParameterDescriptorImpl]

'collectTypesFromMeAndParents' @ [137:21] ==> private final fun collectTypesFromMeAndParents(value: DataFlowValue): Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'key' @ [137:50] ==> value-parameter key: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getCollectedTypes[ValueParameterDescriptorImpl]

'!' @ [138:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'enrichWithNotNull' @ [138:14] ==> value-parameter enrichWithNotNull: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getCollectedTypes[ValueParameterDescriptorImpl]

'getCollectedNullability' @ [138:35] ==> public open fun getCollectedNullability(key: DataFlowValue): Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'key' @ [138:59] ==> value-parameter key: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getCollectedTypes[ValueParameterDescriptorImpl]

'canBeNull' @ [138:64] ==> public open fun canBeNull(): Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.Nullability[JavaMethodDescriptor]

'types' @ [139:20] ==> val types: Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getCollectedTypes[LocalVariableDescriptor]

'newLinkedHashSetWithExpectedSize' @ [142:29] ==> public fun <E> newLinkedHashSetWithExpectedSize(expectedSize: Int): LinkedHashSet<KotlinType> defined in org.jetbrains.kotlin.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <E> -> KotlinType

'types' @ [142:74] ==> val types: Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getCollectedTypes[LocalVariableDescriptor]

'size' @ [142:80] ==> public abstract val size: Int defined in kotlin.collections.Set[DeserializedPropertyDescriptor]

'key' @ [143:28] ==> value-parameter key: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getCollectedTypes[ValueParameterDescriptorImpl]

'type' @ [143:32] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'types' @ [144:22] ==> val types: Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getCollectedTypes[LocalVariableDescriptor]

'enrichedTypes' @ [145:13] ==> val enrichedTypes: LinkedHashSet<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getCollectedTypes[LocalVariableDescriptor]

'add' @ [145:27] ==> public open fun add(element: KotlinType): Boolean defined in java.util.LinkedHashSet[JavaMethodDescriptor]

'makeNotNullable' @ [145:41] ==> @NotNull public open fun makeNotNullable(@NotNull p0: KotlinType): KotlinType defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'type' @ [145:57] ==> val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getCollectedTypes[LocalVariableDescriptor]

'originalType' @ [147:13] ==> val originalType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getCollectedTypes[LocalVariableDescriptor]

'isMarkedNullable' @ [147:26] ==> public abstract val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'enrichedTypes' @ [148:13] ==> val enrichedTypes: LinkedHashSet<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getCollectedTypes[LocalVariableDescriptor]

'add' @ [148:27] ==> public open fun add(element: KotlinType): Boolean defined in java.util.LinkedHashSet[JavaMethodDescriptor]

'makeNotNullable' @ [148:41] ==> @NotNull public open fun makeNotNullable(@NotNull p0: KotlinType): KotlinType defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'originalType' @ [148:57] ==> val originalType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getCollectedTypes[LocalVariableDescriptor]

'enrichedTypes' @ [151:16] ==> val enrichedTypes: LinkedHashSet<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getCollectedTypes[LocalVariableDescriptor]

'getStableTypes' @ [154:55] ==> private final fun getStableTypes(key: DataFlowValue, enrichWithNotNull: Boolean): Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'key' @ [154:70] ==> value-parameter key: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getStableTypes[ValueParameterDescriptorImpl]

'if (!key.isStable) LinkedHashSet() else getCollectedTypes(key, enrichWithNotNull)' @ [157:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Set<KotlinType>, elseBranch: Set<KotlinType>): Set<KotlinType>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Set<KotlinType>

'!' @ [157:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'key' @ [157:18] ==> value-parameter key: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getStableTypes[ValueParameterDescriptorImpl]

'isStable' @ [157:22] ==> public final val isStable: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'LinkedHashSet' @ [157:32] ==> public constructor LinkedHashSet<E : (Any..Any?)>() defined in java.util.LinkedHashSet[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> KotlinType

'getCollectedTypes' @ [157:53] ==> private final fun getCollectedTypes(key: DataFlowValue, enrichWithNotNull: Boolean): Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'key' @ [157:71] ==> value-parameter key: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getStableTypes[ValueParameterDescriptorImpl]

'enrichWithNotNull' @ [157:76] ==> value-parameter enrichWithNotNull: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.getStableTypes[ValueParameterDescriptorImpl]

'hashMapOf' @ [166:37] ==> @SinceKotlin @InlineOnly public inline fun <K, V> hashMapOf(): HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> DataFlowValue
    <V> -> Nullability

'putNullabilityAndTypeInfo' @ [167:9] ==> private final fun putNullabilityAndTypeInfo(map: MutableMap<DataFlowValue, Nullability>, value: DataFlowValue, nullability: Nullability, languageVersionSettings: LanguageVersionSettings, typeInfo: SetMultimap<DataFlowValue, KotlinType>? = ..., affectReceiver: Boolean = ...): Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'resultNullabilityInfo' @ [167:35] ==> val resultNullabilityInfo: HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.clearValueInfo[LocalVariableDescriptor]

'value' @ [167:58] ==> value-parameter value: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.clearValueInfo[ValueParameterDescriptorImpl]

'value' @ [167:65] ==> value-parameter value: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.clearValueInfo[ValueParameterDescriptorImpl]

'immanentNullability' @ [167:71] ==> public final val immanentNullability: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'languageVersionSettings' @ [167:92] ==> value-parameter languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.clearValueInfo[ValueParameterDescriptorImpl]

'create' @ [168:16] ==> private final fun create(parent: DataFlowInfo?, nullabilityInfo: Map<DataFlowValue, Nullability>, typeInfo: SetMultimap<DataFlowValue, KotlinType>, valueWithGivenTypeInfo: DataFlowValue? = ...): DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion[SimpleFunctionDescriptorImpl]

'this' @ [168:23] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[LazyClassReceiverParameterDescriptor]

'resultNullabilityInfo' @ [168:29] ==> val resultNullabilityInfo: HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.clearValueInfo[LocalVariableDescriptor]

'EMPTY_TYPE_INFO' @ [168:52] ==> private final val EMPTY_TYPE_INFO: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion[PropertyDescriptorImpl]

'value' @ [168:69] ==> value-parameter value: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.clearValueInfo[ValueParameterDescriptorImpl]

'hashMapOf' @ [172:27] ==> @SinceKotlin @InlineOnly public inline fun <K, V> hashMapOf(): HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> DataFlowValue
    <V> -> Nullability

'getStableNullability' @ [173:30] ==> public open fun getStableNullability(key: DataFlowValue): Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'b' @ [173:51] ==> value-parameter b: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.assign[ValueParameterDescriptorImpl]

'putNullabilityAndTypeInfo' @ [174:9] ==> private final fun putNullabilityAndTypeInfo(map: MutableMap<DataFlowValue, Nullability>, value: DataFlowValue, nullability: Nullability, languageVersionSettings: LanguageVersionSettings, typeInfo: SetMultimap<DataFlowValue, KotlinType>? = ..., affectReceiver: Boolean = ...): Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'nullability' @ [174:35] ==> val nullability: HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.assign[LocalVariableDescriptor]

'a' @ [174:48] ==> value-parameter a: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.assign[ValueParameterDescriptorImpl]

'nullabilityOfB' @ [174:51] ==> val nullabilityOfB: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.assign[LocalVariableDescriptor]

'languageVersionSettings' @ [174:67] ==> value-parameter languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.assign[ValueParameterDescriptorImpl]

'newTypeInfo' @ [176:27] ==> public final fun newTypeInfo(): SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion[SimpleFunctionDescriptorImpl]

'getStableTypes' @ [177:25] ==> public open fun getStableTypes(key: DataFlowValue): Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'b' @ [177:40] ==> value-parameter b: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.assign[ValueParameterDescriptorImpl]

'!' @ [182:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'b' @ [182:14] ==> value-parameter b: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.assign[ValueParameterDescriptorImpl]

'type' @ [182:16] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'isError' @ [182:21] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types[DeserializedPropertyDescriptor]

'a' @ [182:32] ==> value-parameter a: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.assign[ValueParameterDescriptorImpl]

'type' @ [182:34] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'b' @ [182:42] ==> value-parameter b: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.assign[ValueParameterDescriptorImpl]

'type' @ [182:44] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'typesForB' @ [183:13] ==> var typesForB: Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.assign[LocalVariableDescriptor]

'b' @ [183:26] ==> value-parameter b: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.assign[ValueParameterDescriptorImpl]

'type' @ [183:28] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'newTypeInfo' @ [185:9] ==> val newTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.assign[LocalVariableDescriptor]

'putAll' @ [185:21] ==> @CanIgnoreReturnValue public abstract fun putAll(@Nullable p0: DataFlowValue?, p1: (MutableIterable<(KotlinType..KotlinType?)>..Iterable<(KotlinType..KotlinType?)>?)): Boolean defined in com.google.common.collect.SetMultimap[JavaMethodDescriptor]

'a' @ [185:28] ==> value-parameter a: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.assign[ValueParameterDescriptorImpl]

'typesForB' @ [185:31] ==> var typesForB: Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.assign[LocalVariableDescriptor]

'create' @ [187:16] ==> private final fun create(parent: DataFlowInfo?, nullabilityInfo: Map<DataFlowValue, Nullability>, typeInfo: SetMultimap<DataFlowValue, KotlinType>, valueWithGivenTypeInfo: DataFlowValue? = ...): DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion[SimpleFunctionDescriptorImpl]

'this' @ [187:23] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[LazyClassReceiverParameterDescriptor]

'nullability' @ [187:29] ==> val nullability: HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.assign[LocalVariableDescriptor]

'if (newTypeInfo.isEmpty) EMPTY_TYPE_INFO else newTypeInfo' @ [187:42] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: SetMultimap<DataFlowValue, KotlinType>, elseBranch: SetMultimap<DataFlowValue, KotlinType>): SetMultimap<DataFlowValue, KotlinType>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> SetMultimap<DataFlowValue, KotlinType>

'newTypeInfo' @ [187:46] ==> val newTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.assign[LocalVariableDescriptor]

'isEmpty' @ [187:58] ==> public final val <K : (Any..Any?), V : (Any..Any?)> SetMultimap<DataFlowValue, KotlinType>.isEmpty: Boolean[MyPropertyDescriptor]
Inferred types:
    <K : (Any..Any?)> -> DataFlowValue
    <V : (Any..Any?)> -> KotlinType

'EMPTY_TYPE_INFO' @ [187:67] ==> private final val EMPTY_TYPE_INFO: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion[PropertyDescriptorImpl]

'newTypeInfo' @ [187:88] ==> val newTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.assign[LocalVariableDescriptor]

'a' @ [187:101] ==> value-parameter a: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.assign[ValueParameterDescriptorImpl]

'hashMapOf' @ [193:37] ==> @SinceKotlin @InlineOnly public inline fun <K, V> hashMapOf(): HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> DataFlowValue
    <V> -> Nullability

'getStableNullability' @ [194:30] ==> public open fun getStableNullability(key: DataFlowValue): Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'a' @ [194:51] ==> value-parameter a: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[ValueParameterDescriptorImpl]

'getStableNullability' @ [195:30] ==> public open fun getStableNullability(key: DataFlowValue): Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'b' @ [195:51] ==> value-parameter b: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[ValueParameterDescriptorImpl]

'newTypeInfo' @ [197:27] ==> public final fun newTypeInfo(): SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion[SimpleFunctionDescriptorImpl]

'putNullabilityAndTypeInfo' @ [199:17] ==> private final fun putNullabilityAndTypeInfo(map: MutableMap<DataFlowValue, Nullability>, value: DataFlowValue, nullability: Nullability, languageVersionSettings: LanguageVersionSettings, typeInfo: SetMultimap<DataFlowValue, KotlinType>? = ..., affectReceiver: Boolean = ...): Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'resultNullabilityInfo' @ [199:43] ==> val resultNullabilityInfo: HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[LocalVariableDescriptor]

'a' @ [199:66] ==> value-parameter a: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[ValueParameterDescriptorImpl]

'nullabilityOfA' @ [199:69] ==> val nullabilityOfA: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[LocalVariableDescriptor]

'refine' @ [199:84] ==> @NotNull public open fun refine(@NotNull other: Nullability): Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.Nullability[JavaMethodDescriptor]

'nullabilityOfB' @ [199:91] ==> val nullabilityOfB: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[LocalVariableDescriptor]

'languageVersionSettings' @ [199:108] ==> value-parameter languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[ValueParameterDescriptorImpl]

'newTypeInfo' @ [199:133] ==> val newTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[LocalVariableDescriptor]

'putNullabilityAndTypeInfo' @ [200:17] ==> private final fun putNullabilityAndTypeInfo(map: MutableMap<DataFlowValue, Nullability>, value: DataFlowValue, nullability: Nullability, languageVersionSettings: LanguageVersionSettings, typeInfo: SetMultimap<DataFlowValue, KotlinType>? = ..., affectReceiver: Boolean = ...): Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'resultNullabilityInfo' @ [200:43] ==> val resultNullabilityInfo: HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[LocalVariableDescriptor]

'b' @ [200:66] ==> value-parameter b: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[ValueParameterDescriptorImpl]

'nullabilityOfB' @ [200:69] ==> val nullabilityOfB: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[LocalVariableDescriptor]

'refine' @ [200:84] ==> @NotNull public open fun refine(@NotNull other: Nullability): Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.Nullability[JavaMethodDescriptor]

'nullabilityOfA' @ [200:91] ==> val nullabilityOfA: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[LocalVariableDescriptor]

'languageVersionSettings' @ [200:108] ==> value-parameter languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[ValueParameterDescriptorImpl]

'newTypeInfo' @ [200:133] ==> val newTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[LocalVariableDescriptor]

'identityEquals' @ [203:13] ==> value-parameter identityEquals: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[ValueParameterDescriptorImpl]

'!' @ [203:31] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'nullabilityOfA' @ [203:32] ==> val nullabilityOfA: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[LocalVariableDescriptor]

'canBeNonNull' @ [203:47] ==> public open fun canBeNonNull(): Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.Nullability[JavaMethodDescriptor]

'!' @ [203:65] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'nullabilityOfB' @ [203:66] ==> val nullabilityOfB: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[LocalVariableDescriptor]

'canBeNonNull' @ [203:81] ==> public open fun canBeNonNull(): Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.Nullability[JavaMethodDescriptor]

'newTypeInfo' @ [204:13] ==> val newTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[LocalVariableDescriptor]

'putAll' @ [204:25] ==> @CanIgnoreReturnValue public abstract fun putAll(@Nullable p0: DataFlowValue?, p1: (MutableIterable<(KotlinType..KotlinType?)>..Iterable<(KotlinType..KotlinType?)>?)): Boolean defined in com.google.common.collect.SetMultimap[JavaMethodDescriptor]

'a' @ [204:32] ==> value-parameter a: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[ValueParameterDescriptorImpl]

'getStableTypes' @ [204:35] ==> private final fun getStableTypes(key: DataFlowValue, enrichWithNotNull: Boolean): Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'b' @ [204:50] ==> value-parameter b: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[ValueParameterDescriptorImpl]

'newTypeInfo' @ [205:13] ==> val newTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[LocalVariableDescriptor]

'putAll' @ [205:25] ==> @CanIgnoreReturnValue public abstract fun putAll(@Nullable p0: DataFlowValue?, p1: (MutableIterable<(KotlinType..KotlinType?)>..Iterable<(KotlinType..KotlinType?)>?)): Boolean defined in com.google.common.collect.SetMultimap[JavaMethodDescriptor]

'b' @ [205:32] ==> value-parameter b: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[ValueParameterDescriptorImpl]

'getStableTypes' @ [205:35] ==> private final fun getStableTypes(key: DataFlowValue, enrichWithNotNull: Boolean): Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'a' @ [205:50] ==> value-parameter a: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[ValueParameterDescriptorImpl]

'a' @ [206:17] ==> value-parameter a: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[ValueParameterDescriptorImpl]

'type' @ [206:19] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'b' @ [206:27] ==> value-parameter b: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[ValueParameterDescriptorImpl]

'type' @ [206:29] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'!' @ [208:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'a' @ [208:22] ==> value-parameter a: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[ValueParameterDescriptorImpl]

'type' @ [208:24] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'isSubtypeOf' @ [208:29] ==> public fun KotlinType.isSubtypeOf(superType: KotlinType): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'b' @ [208:41] ==> value-parameter b: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[ValueParameterDescriptorImpl]

'type' @ [208:43] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'newTypeInfo' @ [209:21] ==> val newTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[LocalVariableDescriptor]

'put' @ [209:33] ==> @CanIgnoreReturnValue public abstract fun put(@Nullable p0: DataFlowValue?, @Nullable p1: KotlinType?): Boolean defined in com.google.common.collect.SetMultimap[JavaMethodDescriptor]

'a' @ [209:37] ==> value-parameter a: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[ValueParameterDescriptorImpl]

'b' @ [209:40] ==> value-parameter b: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[ValueParameterDescriptorImpl]

'type' @ [209:42] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'!' @ [211:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'b' @ [211:22] ==> value-parameter b: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[ValueParameterDescriptorImpl]

'type' @ [211:24] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'isSubtypeOf' @ [211:29] ==> public fun KotlinType.isSubtypeOf(superType: KotlinType): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'a' @ [211:41] ==> value-parameter a: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[ValueParameterDescriptorImpl]

'type' @ [211:43] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'newTypeInfo' @ [212:21] ==> val newTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[LocalVariableDescriptor]

'put' @ [212:33] ==> @CanIgnoreReturnValue public abstract fun put(@Nullable p0: DataFlowValue?, @Nullable p1: KotlinType?): Boolean defined in com.google.common.collect.SetMultimap[JavaMethodDescriptor]

'b' @ [212:37] ==> value-parameter b: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[ValueParameterDescriptorImpl]

'a' @ [212:40] ==> value-parameter a: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[ValueParameterDescriptorImpl]

'type' @ [212:42] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'changed' @ [215:13] ==> var changed: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[LocalVariableDescriptor]

'changed' @ [215:23] ==> var changed: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[LocalVariableDescriptor]

'!' @ [215:34] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'newTypeInfo' @ [215:35] ==> val newTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[LocalVariableDescriptor]

'isEmpty' @ [215:47] ==> public final val <K : (Any..Any?), V : (Any..Any?)> SetMultimap<DataFlowValue, KotlinType>.isEmpty: Boolean[MyPropertyDescriptor]
Inferred types:
    <K : (Any..Any?)> -> DataFlowValue
    <V : (Any..Any?)> -> KotlinType

'if (changed) create(this, resultNullabilityInfo, if (newTypeInfo.isEmpty) EMPTY_TYPE_INFO else newTypeInfo) else this' @ [218:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: DataFlowInfo, elseBranch: DataFlowInfo): DataFlowInfo[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> DataFlowInfo

'changed' @ [218:20] ==> var changed: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[LocalVariableDescriptor]

'create' @ [218:29] ==> private final fun create(parent: DataFlowInfo?, nullabilityInfo: Map<DataFlowValue, Nullability>, typeInfo: SetMultimap<DataFlowValue, KotlinType>, valueWithGivenTypeInfo: DataFlowValue? = ...): DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion[SimpleFunctionDescriptorImpl]

'this' @ [218:36] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[LazyClassReceiverParameterDescriptor]

'resultNullabilityInfo' @ [218:42] ==> val resultNullabilityInfo: HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[LocalVariableDescriptor]

'if (newTypeInfo.isEmpty) EMPTY_TYPE_INFO else newTypeInfo' @ [218:65] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: SetMultimap<DataFlowValue, KotlinType>, elseBranch: SetMultimap<DataFlowValue, KotlinType>): SetMultimap<DataFlowValue, KotlinType>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> SetMultimap<DataFlowValue, KotlinType>

'newTypeInfo' @ [218:69] ==> val newTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[LocalVariableDescriptor]

'isEmpty' @ [218:81] ==> public final val <K : (Any..Any?), V : (Any..Any?)> SetMultimap<DataFlowValue, KotlinType>.isEmpty: Boolean[MyPropertyDescriptor]
Inferred types:
    <K : (Any..Any?)> -> DataFlowValue
    <V : (Any..Any?)> -> KotlinType

'EMPTY_TYPE_INFO' @ [218:90] ==> private final val EMPTY_TYPE_INFO: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion[PropertyDescriptorImpl]

'newTypeInfo' @ [218:111] ==> val newTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.equate[LocalVariableDescriptor]

'this' @ [218:129] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[LazyClassReceiverParameterDescriptor]

'LinkedHashSet' @ [222:21] ==> public constructor LinkedHashSet<E : (Any..Any?)>() defined in java.util.LinkedHashSet[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> KotlinType

'this' @ [224:38] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[LazyClassReceiverParameterDescriptor]

'current' @ [225:16] ==> var current: DataFlowInfo? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.collectTypesFromMeAndParents[LocalVariableDescriptor]

'if (current is DelegatingDataFlowInfo) {
                types.addAll(current.typeInfo.get(value))
                current = if (value == current.valueWithGivenTypeInfo) null else current.parent
            }
            else {
                types.addAll(current.getCollectedTypes(value))
                break
            }' @ [226:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'current' @ [226:17] ==> var current: DataFlowInfo? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.collectTypesFromMeAndParents[LocalVariableDescriptor]

'types' @ [227:17] ==> val types: LinkedHashSet<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.collectTypesFromMeAndParents[LocalVariableDescriptor]

'addAll' @ [227:23] ==> public open fun addAll(elements: Collection<KotlinType>): Boolean defined in java.util.LinkedHashSet[JavaMethodDescriptor]

'current' @ [227:30] ==> var current: DataFlowInfo? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.collectTypesFromMeAndParents[LocalVariableDescriptor]

'typeInfo' @ [227:38] ==> private final val typeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[PropertyDescriptorImpl]

'get' @ [227:47] ==> public abstract fun get(@Nullable p0: DataFlowValue?): (MutableSet<(KotlinType..KotlinType?)>..Set<(KotlinType..KotlinType?)>?) defined in com.google.common.collect.SetMultimap[JavaMethodDescriptor]

'value' @ [227:51] ==> value-parameter value: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.collectTypesFromMeAndParents[ValueParameterDescriptorImpl]

'current' @ [228:17] ==> var current: DataFlowInfo? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.collectTypesFromMeAndParents[LocalVariableDescriptor]

'if (value == current.valueWithGivenTypeInfo) null else current.parent' @ [228:27] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: DataFlowInfo?, elseBranch: DataFlowInfo?): DataFlowInfo?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> DataFlowInfo?

'value' @ [228:31] ==> value-parameter value: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.collectTypesFromMeAndParents[ValueParameterDescriptorImpl]

'current' @ [228:40] ==> var current: DataFlowInfo? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.collectTypesFromMeAndParents[LocalVariableDescriptor]

'valueWithGivenTypeInfo' @ [228:48] ==> private final val valueWithGivenTypeInfo: DataFlowValue? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[PropertyDescriptorImpl]

'current' @ [228:82] ==> var current: DataFlowInfo? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.collectTypesFromMeAndParents[LocalVariableDescriptor]

'parent' @ [228:90] ==> private final val parent: DataFlowInfo? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[PropertyDescriptorImpl]

'types' @ [231:17] ==> val types: LinkedHashSet<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.collectTypesFromMeAndParents[LocalVariableDescriptor]

'addAll' @ [231:23] ==> public open fun addAll(elements: Collection<KotlinType>): Boolean defined in java.util.LinkedHashSet[JavaMethodDescriptor]

'current' @ [231:30] ==> var current: DataFlowInfo? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.collectTypesFromMeAndParents[LocalVariableDescriptor]

'getCollectedTypes' @ [231:38] ==> public abstract fun getCollectedTypes(key: DataFlowValue): Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo[SimpleFunctionDescriptorImpl]

'value' @ [231:56] ==> value-parameter value: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.collectTypesFromMeAndParents[ValueParameterDescriptorImpl]

'types' @ [236:16] ==> val types: LinkedHashSet<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.collectTypesFromMeAndParents[LocalVariableDescriptor]

'hashMapOf' @ [242:37] ==> @SinceKotlin @InlineOnly public inline fun <K, V> hashMapOf(): HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> DataFlowValue
    <V> -> Nullability

'getStableNullability' @ [243:30] ==> public open fun getStableNullability(key: DataFlowValue): Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'a' @ [243:51] ==> value-parameter a: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.disequate[ValueParameterDescriptorImpl]

'getStableNullability' @ [244:30] ==> public open fun getStableNullability(key: DataFlowValue): Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'b' @ [244:51] ==> value-parameter b: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.disequate[ValueParameterDescriptorImpl]

'newTypeInfo' @ [246:27] ==> public final fun newTypeInfo(): SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion[SimpleFunctionDescriptorImpl]

'putNullabilityAndTypeInfo' @ [248:17] ==> private final fun putNullabilityAndTypeInfo(map: MutableMap<DataFlowValue, Nullability>, value: DataFlowValue, nullability: Nullability, languageVersionSettings: LanguageVersionSettings, typeInfo: SetMultimap<DataFlowValue, KotlinType>? = ..., affectReceiver: Boolean = ...): Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'resultNullabilityInfo' @ [248:43] ==> val resultNullabilityInfo: HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.disequate[LocalVariableDescriptor]

'a' @ [248:66] ==> value-parameter a: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.disequate[ValueParameterDescriptorImpl]

'nullabilityOfA' @ [248:69] ==> val nullabilityOfA: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.disequate[LocalVariableDescriptor]

'refine' @ [248:84] ==> @NotNull public open fun refine(@NotNull other: Nullability): Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.Nullability[JavaMethodDescriptor]

'nullabilityOfB' @ [248:91] ==> val nullabilityOfB: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.disequate[LocalVariableDescriptor]

'invert' @ [248:106] ==> @NotNull public open fun invert(): Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.Nullability[JavaMethodDescriptor]

'languageVersionSettings' @ [248:117] ==> value-parameter languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.disequate[ValueParameterDescriptorImpl]

'newTypeInfo' @ [248:142] ==> val newTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.disequate[LocalVariableDescriptor]

'putNullabilityAndTypeInfo' @ [249:17] ==> private final fun putNullabilityAndTypeInfo(map: MutableMap<DataFlowValue, Nullability>, value: DataFlowValue, nullability: Nullability, languageVersionSettings: LanguageVersionSettings, typeInfo: SetMultimap<DataFlowValue, KotlinType>? = ..., affectReceiver: Boolean = ...): Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'resultNullabilityInfo' @ [249:43] ==> val resultNullabilityInfo: HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.disequate[LocalVariableDescriptor]

'b' @ [249:66] ==> value-parameter b: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.disequate[ValueParameterDescriptorImpl]

'nullabilityOfB' @ [249:69] ==> val nullabilityOfB: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.disequate[LocalVariableDescriptor]

'refine' @ [249:84] ==> @NotNull public open fun refine(@NotNull other: Nullability): Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.Nullability[JavaMethodDescriptor]

'nullabilityOfA' @ [249:91] ==> val nullabilityOfA: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.disequate[LocalVariableDescriptor]

'invert' @ [249:106] ==> @NotNull public open fun invert(): Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.Nullability[JavaMethodDescriptor]

'languageVersionSettings' @ [249:117] ==> value-parameter languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.disequate[ValueParameterDescriptorImpl]

'newTypeInfo' @ [249:142] ==> val newTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.disequate[LocalVariableDescriptor]

'if (changed) create(this, resultNullabilityInfo, if (newTypeInfo.isEmpty) EMPTY_TYPE_INFO else newTypeInfo) else this' @ [251:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: DataFlowInfo, elseBranch: DataFlowInfo): DataFlowInfo[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> DataFlowInfo

'changed' @ [251:20] ==> val changed: Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.disequate[LocalVariableDescriptor]

'create' @ [251:29] ==> private final fun create(parent: DataFlowInfo?, nullabilityInfo: Map<DataFlowValue, Nullability>, typeInfo: SetMultimap<DataFlowValue, KotlinType>, valueWithGivenTypeInfo: DataFlowValue? = ...): DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion[SimpleFunctionDescriptorImpl]

'this' @ [251:36] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[LazyClassReceiverParameterDescriptor]

'resultNullabilityInfo' @ [251:42] ==> val resultNullabilityInfo: HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.disequate[LocalVariableDescriptor]

'if (newTypeInfo.isEmpty) EMPTY_TYPE_INFO else newTypeInfo' @ [251:65] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: SetMultimap<DataFlowValue, KotlinType>, elseBranch: SetMultimap<DataFlowValue, KotlinType>): SetMultimap<DataFlowValue, KotlinType>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> SetMultimap<DataFlowValue, KotlinType>

'newTypeInfo' @ [251:69] ==> val newTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.disequate[LocalVariableDescriptor]

'isEmpty' @ [251:81] ==> public final val <K : (Any..Any?), V : (Any..Any?)> SetMultimap<DataFlowValue, KotlinType>.isEmpty: Boolean[MyPropertyDescriptor]
Inferred types:
    <K : (Any..Any?)> -> DataFlowValue
    <V : (Any..Any?)> -> KotlinType

'EMPTY_TYPE_INFO' @ [251:90] ==> private final val EMPTY_TYPE_INFO: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion[PropertyDescriptorImpl]

'newTypeInfo' @ [251:111] ==> val newTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.disequate[LocalVariableDescriptor]

'this' @ [251:129] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[LazyClassReceiverParameterDescriptor]

'value' @ [258:13] ==> value-parameter value: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.establishSubtyping[ValueParameterDescriptorImpl]

'type' @ [258:19] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'type' @ [258:27] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.establishSubtyping[ValueParameterDescriptorImpl]

'this' @ [258:40] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[LazyClassReceiverParameterDescriptor]

'getCollectedTypes' @ [259:13] ==> public open fun getCollectedTypes(key: DataFlowValue): Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'value' @ [259:31] ==> value-parameter value: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.establishSubtyping[ValueParameterDescriptorImpl]

'contains' @ [259:38] ==> public abstract fun contains(element: KotlinType): Boolean defined in kotlin.collections.Set[DeserializedSimpleFunctionDescriptor]

'type' @ [259:47] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.establishSubtyping[ValueParameterDescriptorImpl]

'this' @ [259:61] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[LazyClassReceiverParameterDescriptor]

'!' @ [260:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'value' @ [260:14] ==> value-parameter value: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.establishSubtyping[ValueParameterDescriptorImpl]

'type' @ [260:20] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'isFlexible' @ [260:25] ==> public fun KotlinType.isFlexible(): Boolean defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'value' @ [260:41] ==> value-parameter value: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.establishSubtyping[ValueParameterDescriptorImpl]

'type' @ [260:47] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'isSubtypeOf' @ [260:52] ==> public fun KotlinType.isSubtypeOf(superType: KotlinType): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'type' @ [260:64] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.establishSubtyping[ValueParameterDescriptorImpl]

'this' @ [260:78] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[LazyClassReceiverParameterDescriptor]

'newTypeInfo' @ [261:27] ==> public final fun newTypeInfo(): SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion[SimpleFunctionDescriptorImpl]

'newTypeInfo' @ [262:9] ==> val newTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.establishSubtyping[LocalVariableDescriptor]

'put' @ [262:21] ==> @CanIgnoreReturnValue public abstract fun put(@Nullable p0: DataFlowValue?, @Nullable p1: KotlinType?): Boolean defined in com.google.common.collect.SetMultimap[JavaMethodDescriptor]

'value' @ [262:25] ==> value-parameter value: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.establishSubtyping[ValueParameterDescriptorImpl]

'type' @ [262:32] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.establishSubtyping[ValueParameterDescriptorImpl]

'hashMapOf' @ [263:31] ==> @SinceKotlin @InlineOnly public inline fun <K, V> hashMapOf(): HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> DataFlowValue
    <V> -> Nullability

'!' @ [264:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'type' @ [264:14] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.establishSubtyping[ValueParameterDescriptorImpl]

'isMarkedNullable' @ [264:19] ==> public abstract val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'putNullabilityAndTypeInfo' @ [265:13] ==> private final fun putNullabilityAndTypeInfo(map: MutableMap<DataFlowValue, Nullability>, value: DataFlowValue, nullability: Nullability, languageVersionSettings: LanguageVersionSettings, typeInfo: SetMultimap<DataFlowValue, KotlinType>? = ..., affectReceiver: Boolean = ...): Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'nullabilityInfo' @ [265:39] ==> val nullabilityInfo: HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.establishSubtyping[LocalVariableDescriptor]

'value' @ [265:56] ==> value-parameter value: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.establishSubtyping[ValueParameterDescriptorImpl]

'NOT_NULL' @ [265:63] ==> enum entry NOT_NULL defined in org.jetbrains.kotlin.resolve.calls.smartcasts.Nullability[FakeCallableDescriptorForObject]

'languageVersionSettings' @ [265:73] ==> value-parameter languageVersionSettings: LanguageVersionSettings defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.establishSubtyping[ValueParameterDescriptorImpl]

'create' @ [267:16] ==> private final fun create(parent: DataFlowInfo?, nullabilityInfo: Map<DataFlowValue, Nullability>, typeInfo: SetMultimap<DataFlowValue, KotlinType>, valueWithGivenTypeInfo: DataFlowValue? = ...): DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion[SimpleFunctionDescriptorImpl]

'this' @ [267:23] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[LazyClassReceiverParameterDescriptor]

'if (type.isMarkedNullable) emptyMap() else nullabilityInfo' @ [267:29] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Map<DataFlowValue, Nullability>, elseBranch: Map<DataFlowValue, Nullability>): Map<DataFlowValue, Nullability>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Map<DataFlowValue, Nullability>

'type' @ [267:33] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.establishSubtyping[ValueParameterDescriptorImpl]

'isMarkedNullable' @ [267:38] ==> public abstract val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'emptyMap' @ [267:56] ==> public fun <K, V> emptyMap(): Map<DataFlowValue, Nullability> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> DataFlowValue
    <V> -> Nullability

'nullabilityInfo' @ [267:72] ==> val nullabilityInfo: HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.establishSubtyping[LocalVariableDescriptor]

'newTypeInfo' @ [267:89] ==> val newTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.establishSubtyping[LocalVariableDescriptor]

'other' @ [271:13] ==> value-parameter other: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.and[ValueParameterDescriptorImpl]

'DataFlowInfo' @ [271:23] ==> public companion object defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo[FakeCallableDescriptorForObject]

'EMPTY' @ [271:36] ==> public final val EMPTY: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo.Companion[PropertyDescriptorImpl]

'this' @ [271:50] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[LazyClassReceiverParameterDescriptor]

'this' @ [272:13] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[LazyClassReceiverParameterDescriptor]

'DataFlowInfo' @ [272:22] ==> public companion object defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo[FakeCallableDescriptorForObject]

'EMPTY' @ [272:35] ==> public final val EMPTY: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo.Companion[PropertyDescriptorImpl]

'other' @ [272:49] ==> value-parameter other: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.and[ValueParameterDescriptorImpl]

'this' @ [273:13] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[LazyClassReceiverParameterDescriptor]

'other' @ [273:22] ==> value-parameter other: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.and[ValueParameterDescriptorImpl]

'this' @ [273:36] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[LazyClassReceiverParameterDescriptor]

'assert' @ [275:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'other' @ [275:16] ==> value-parameter other: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.and[ValueParameterDescriptorImpl]

'+' @ [275:51] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'other' @ [275:83] ==> value-parameter other: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.and[ValueParameterDescriptorImpl]

'hashMapOf' @ [277:37] ==> @SinceKotlin @InlineOnly public inline fun <K, V> hashMapOf(): HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> DataFlowValue
    <V> -> Nullability

'component1' @ [278:15] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<DataFlowValue, Nullability>.component1(): DataFlowValue defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> DataFlowValue
    <V> -> Nullability

'component2' @ [278:20] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<DataFlowValue, Nullability>.component2(): Nullability defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> DataFlowValue
    <V> -> Nullability

'other' @ [278:35] ==> value-parameter other: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.and[ValueParameterDescriptorImpl]

'completeNullabilityInfo' @ [278:41] ==> public abstract val completeNullabilityInfo: Map<DataFlowValue, Nullability> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo[PropertyDescriptorImpl]

'getCollectedNullability' @ [279:29] ==> public open fun getCollectedNullability(key: DataFlowValue): Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'key' @ [279:53] ==> val key: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.and[LocalVariableDescriptor]

'thisFlags' @ [280:25] ==> val thisFlags: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.and[LocalVariableDescriptor]

'and' @ [280:35] ==> @NotNull public open fun and(@NotNull other: Nullability): Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.Nullability[JavaMethodDescriptor]

'otherFlags' @ [280:39] ==> val otherFlags: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.and[LocalVariableDescriptor]

'flags' @ [281:17] ==> val flags: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.and[LocalVariableDescriptor]

'thisFlags' @ [281:26] ==> val thisFlags: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.and[LocalVariableDescriptor]

'resultNullabilityInfo' @ [282:17] ==> val resultNullabilityInfo: HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.and[LocalVariableDescriptor]

'put' @ [282:39] ==> public open fun put(key: DataFlowValue, value: Nullability): Nullability? defined in java.util.HashMap[JavaMethodDescriptor]

'key' @ [282:43] ==> val key: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.and[LocalVariableDescriptor]

'flags' @ [282:48] ==> val flags: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.and[LocalVariableDescriptor]

'completeTypeInfo' @ [286:26] ==> public open val completeTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[PropertyDescriptorImpl]

'other' @ [287:29] ==> value-parameter other: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.and[ValueParameterDescriptorImpl]

'completeTypeInfo' @ [287:35] ==> public abstract val completeTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo[PropertyDescriptorImpl]

'resultNullabilityInfo' @ [288:13] ==> val resultNullabilityInfo: HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.and[LocalVariableDescriptor]

'isEmpty' @ [288:35] ==> public open fun isEmpty(): Boolean defined in java.util.HashMap[JavaMethodDescriptor]

'containsAll' @ [288:48] ==> private final fun containsAll(first: SetMultimap<DataFlowValue, KotlinType>, second: SetMultimap<DataFlowValue, KotlinType>): Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion[SimpleFunctionDescriptorImpl]

'myTypeInfo' @ [288:60] ==> val myTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.and[LocalVariableDescriptor]

'otherTypeInfo' @ [288:72] ==> val otherTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.and[LocalVariableDescriptor]

'this' @ [289:20] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[LazyClassReceiverParameterDescriptor]

'create' @ [292:16] ==> private final fun create(parent: DataFlowInfo?, nullabilityInfo: Map<DataFlowValue, Nullability>, typeInfo: SetMultimap<DataFlowValue, KotlinType>, valueWithGivenTypeInfo: DataFlowValue? = ...): DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion[SimpleFunctionDescriptorImpl]

'this' @ [292:23] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[LazyClassReceiverParameterDescriptor]

'resultNullabilityInfo' @ [292:29] ==> val resultNullabilityInfo: HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.and[LocalVariableDescriptor]

'otherTypeInfo' @ [292:52] ==> val otherTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.and[LocalVariableDescriptor]

'any' @ [295:53] ==> public inline fun <T> Iterable<KotlinType>.any(predicate: (KotlinType) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'isNothing' @ [295:74] ==> public open fun isNothing(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'it' @ [295:84] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.containsNothing.<anonymous>[ValueParameterDescriptorImpl]

'when {
                other.containsNothing() -> this
                this.containsNothing() -> other
                else -> this.intersect(other)
            }' @ [298:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Set<KotlinType>, entry1: Set<KotlinType>, entry2: Set<KotlinType>): Set<KotlinType>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Set<KotlinType>

'other' @ [299:17] ==> value-parameter other: Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.intersectConsideringNothing[ValueParameterDescriptorImpl]

'containsNothing' @ [299:23] ==> private final fun Set<KotlinType>.containsNothing(): Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'this' @ [299:44] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.intersectConsideringNothing[ReceiverParameterDescriptorImpl]

'this' @ [300:17] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.intersectConsideringNothing[ReceiverParameterDescriptorImpl]

'containsNothing' @ [300:22] ==> private final fun Set<KotlinType>.containsNothing(): Boolean defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'other' @ [300:43] ==> value-parameter other: Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.intersectConsideringNothing[ValueParameterDescriptorImpl]

'this' @ [301:25] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.intersectConsideringNothing[ReceiverParameterDescriptorImpl]

'intersect' @ [301:30] ==> public infix fun <T> Iterable<KotlinType>.intersect(other: Iterable<KotlinType>): Set<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType

'other' @ [301:40] ==> value-parameter other: Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.intersectConsideringNothing[ValueParameterDescriptorImpl]

'other' @ [305:13] ==> value-parameter other: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.or[ValueParameterDescriptorImpl]

'DataFlowInfo' @ [305:23] ==> public companion object defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo[FakeCallableDescriptorForObject]

'EMPTY' @ [305:36] ==> public final val EMPTY: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo.Companion[PropertyDescriptorImpl]

'DataFlowInfo' @ [305:50] ==> public companion object defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo[FakeCallableDescriptorForObject]

'EMPTY' @ [305:63] ==> public final val EMPTY: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo.Companion[PropertyDescriptorImpl]

'this' @ [306:13] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[LazyClassReceiverParameterDescriptor]

'DataFlowInfo' @ [306:22] ==> public companion object defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo[FakeCallableDescriptorForObject]

'EMPTY' @ [306:35] ==> public final val EMPTY: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo.Companion[PropertyDescriptorImpl]

'DataFlowInfo' @ [306:49] ==> public companion object defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo[FakeCallableDescriptorForObject]

'EMPTY' @ [306:62] ==> public final val EMPTY: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo.Companion[PropertyDescriptorImpl]

'this' @ [307:13] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[LazyClassReceiverParameterDescriptor]

'other' @ [307:22] ==> value-parameter other: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.or[ValueParameterDescriptorImpl]

'this' @ [307:36] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[LazyClassReceiverParameterDescriptor]

'assert' @ [309:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'other' @ [309:16] ==> value-parameter other: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.or[ValueParameterDescriptorImpl]

'+' @ [309:51] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'other' @ [309:83] ==> value-parameter other: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.or[ValueParameterDescriptorImpl]

'hashMapOf' @ [311:37] ==> @SinceKotlin @InlineOnly public inline fun <K, V> hashMapOf(): HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> DataFlowValue
    <V> -> Nullability

'component1' @ [312:15] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<DataFlowValue, Nullability>.component1(): DataFlowValue defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> DataFlowValue
    <V> -> Nullability

'component2' @ [312:20] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<DataFlowValue, Nullability>.component2(): Nullability defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> DataFlowValue
    <V> -> Nullability

'other' @ [312:35] ==> value-parameter other: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.or[ValueParameterDescriptorImpl]

'completeNullabilityInfo' @ [312:41] ==> public abstract val completeNullabilityInfo: Map<DataFlowValue, Nullability> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo[PropertyDescriptorImpl]

'getCollectedNullability' @ [313:29] ==> public open fun getCollectedNullability(key: DataFlowValue): Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'key' @ [313:53] ==> val key: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.or[LocalVariableDescriptor]

'resultNullabilityInfo' @ [314:13] ==> val resultNullabilityInfo: HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.or[LocalVariableDescriptor]

'put' @ [314:35] ==> public open fun put(key: DataFlowValue, value: Nullability): Nullability? defined in java.util.HashMap[JavaMethodDescriptor]

'key' @ [314:39] ==> val key: DataFlowValue defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.or[LocalVariableDescriptor]

'thisFlags' @ [314:44] ==> val thisFlags: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.or[LocalVariableDescriptor]

'or' @ [314:54] ==> @NotNull public open fun or(@NotNull other: Nullability): Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.Nullability[JavaMethodDescriptor]

'otherFlags' @ [314:57] ==> val otherFlags: Nullability defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.or[LocalVariableDescriptor]

'completeTypeInfo' @ [317:26] ==> public open val completeTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[PropertyDescriptorImpl]

'other' @ [318:29] ==> value-parameter other: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.or[ValueParameterDescriptorImpl]

'completeTypeInfo' @ [318:35] ==> public abstract val completeTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo[PropertyDescriptorImpl]

'newTypeInfo' @ [319:27] ==> public final fun newTypeInfo(): SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion[SimpleFunctionDescriptorImpl]

'myTypeInfo' @ [321:21] ==> val myTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.or[LocalVariableDescriptor]

'keySet' @ [321:32] ==> public abstract fun keySet(): (MutableSet<(DataFlowValue..DataFlowValue?)>..Set<(DataFlowValue..DataFlowValue?)>?) defined in com.google.common.collect.SetMultimap[JavaMethodDescriptor]

'key' @ [322:17] ==> val key: (DataFlowValue..DataFlowValue?) defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.or[LocalVariableDescriptor]

'otherTypeInfo' @ [322:24] ==> val otherTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.or[LocalVariableDescriptor]

'keySet' @ [322:38] ==> public abstract fun keySet(): (MutableSet<(DataFlowValue..DataFlowValue?)>..Set<(DataFlowValue..DataFlowValue?)>?) defined in com.google.common.collect.SetMultimap[JavaMethodDescriptor]

'newTypeInfo' @ [323:17] ==> val newTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.or[LocalVariableDescriptor]

'putAll' @ [323:29] ==> @CanIgnoreReturnValue public abstract fun putAll(@Nullable p0: DataFlowValue?, p1: (MutableIterable<(KotlinType..KotlinType?)>..Iterable<(KotlinType..KotlinType?)>?)): Boolean defined in com.google.common.collect.SetMultimap[JavaMethodDescriptor]

'key' @ [323:36] ==> val key: (DataFlowValue..DataFlowValue?) defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.or[LocalVariableDescriptor]

'myTypeInfo' @ [323:41] ==> val myTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.or[LocalVariableDescriptor]

'key' @ [323:52] ==> val key: (DataFlowValue..DataFlowValue?) defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.or[LocalVariableDescriptor]

'intersectConsideringNothing' @ [323:57] ==> private final fun Set<KotlinType>.intersectConsideringNothing(other: Set<KotlinType>): Set<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[SimpleFunctionDescriptorImpl]

'otherTypeInfo' @ [323:85] ==> val otherTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.or[LocalVariableDescriptor]

'key' @ [323:99] ==> val key: (DataFlowValue..DataFlowValue?) defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.or[LocalVariableDescriptor]

'create' @ [326:16] ==> private final fun create(parent: DataFlowInfo?, nullabilityInfo: Map<DataFlowValue, Nullability>, typeInfo: SetMultimap<DataFlowValue, KotlinType>, valueWithGivenTypeInfo: DataFlowValue? = ...): DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion[SimpleFunctionDescriptorImpl]

'resultNullabilityInfo' @ [326:29] ==> val resultNullabilityInfo: HashMap<DataFlowValue, Nullability> /* = HashMap<DataFlowValue, Nullability> */ defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.or[LocalVariableDescriptor]

'newTypeInfo' @ [326:52] ==> val newTypeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.or[LocalVariableDescriptor]

'if (typeInfo.isEmpty && nullabilityInfo.isEmpty()) "EMPTY" else "Non-trivial DataFlowInfo"' @ [329:31] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'typeInfo' @ [329:35] ==> private final val typeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[PropertyDescriptorImpl]

'isEmpty' @ [329:44] ==> public final val <K : (Any..Any?), V : (Any..Any?)> SetMultimap<DataFlowValue, KotlinType>.isEmpty: Boolean[MyPropertyDescriptor]
Inferred types:
    <K : (Any..Any?)> -> DataFlowValue
    <V : (Any..Any?)> -> KotlinType

'nullabilityInfo' @ [329:55] ==> private final val nullabilityInfo: Map<DataFlowValue, Nullability> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[PropertyDescriptorImpl]

'isEmpty' @ [329:71] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.Map[DeserializedSimpleFunctionDescriptor]

'newTypeInfo' @ [332:39] ==> public final fun newTypeInfo(): SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion[SimpleFunctionDescriptorImpl]

'first' @ [335:17] ==> value-parameter first: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion.containsAll[ValueParameterDescriptorImpl]

'entries' @ [335:23] ==> public abstract fun entries(): (MutableSet<(MutableMap.MutableEntry<(DataFlowValue..DataFlowValue?), (KotlinType..KotlinType?)>..Map.Entry<(DataFlowValue..DataFlowValue?), (KotlinType..KotlinType?)>?)>..Set<(MutableMap.MutableEntry<(DataFlowValue..DataFlowValue?), (KotlinType..KotlinType?)>..Map.Entry<(DataFlowValue..DataFlowValue?), (KotlinType..KotlinType?)>?)>?) defined in com.google.common.collect.SetMultimap[JavaMethodDescriptor]

'containsAll' @ [335:33] ==> public abstract fun containsAll(elements: Collection<(MutableMap.MutableEntry<(DataFlowValue..DataFlowValue?), (KotlinType..KotlinType?)>..Map.Entry<(DataFlowValue..DataFlowValue?), (KotlinType..KotlinType?)>?)>): Boolean defined in kotlin.collections.MutableSet[DeserializedSimpleFunctionDescriptor]

'second' @ [335:45] ==> value-parameter second: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion.containsAll[ValueParameterDescriptorImpl]

'entries' @ [335:52] ==> public abstract fun entries(): (MutableSet<(MutableMap.MutableEntry<(DataFlowValue..DataFlowValue?), (KotlinType..KotlinType?)>..Map.Entry<(DataFlowValue..DataFlowValue?), (KotlinType..KotlinType?)>?)>..Set<(MutableMap.MutableEntry<(DataFlowValue..DataFlowValue?), (KotlinType..KotlinType?)>..Map.Entry<(DataFlowValue..DataFlowValue?), (KotlinType..KotlinType?)>?)>?) defined in com.google.common.collect.SetMultimap[JavaMethodDescriptor]

'create' @ [337:88] ==> public open fun <K : (Any..Any?), V : (Any..Any?)> create(): (LinkedHashMultimap<(DataFlowValue..DataFlowValue?), (KotlinType..KotlinType?)>..LinkedHashMultimap<(DataFlowValue..DataFlowValue?), (KotlinType..KotlinType?)>?) defined in com.google.common.collect.LinkedHashMultimap[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> DataFlowValue
    <V : (Any..Any?)> -> KotlinType

'newTypeInfo' @ [345:28] ==> public final fun newTypeInfo(): SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion[SimpleFunctionDescriptorImpl]

'typeInfo' @ [346:27] ==> value-parameter typeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion.create[ValueParameterDescriptorImpl]

'keys' @ [346:36] ==> public abstract fun keys(): (Multiset<(DataFlowValue..DataFlowValue?)>..Multiset<(DataFlowValue..DataFlowValue?)>?) defined in com.google.common.collect.SetMultimap[JavaMethodDescriptor]

'typeInfo' @ [347:30] ==> value-parameter typeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion.create[ValueParameterDescriptorImpl]

'value' @ [347:39] ==> val value: (DataFlowValue..DataFlowValue?) defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion.create[LocalVariableDescriptor]

'value' @ [349:25] ==> val value: (DataFlowValue..DataFlowValue?) defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion.create[LocalVariableDescriptor]

'type' @ [349:31] ==> public final val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue[PropertyDescriptorImpl]

'type' @ [349:39] ==> val type: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion.create[LocalVariableDescriptor]

'type' @ [349:47] ==> val type: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion.create[LocalVariableDescriptor]

'contains' @ [349:52] ==> public fun KotlinType.contains(predicate: (UnwrappedType) -> Boolean): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'it' @ [349:63] ==> value-parameter it: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion.create.<anonymous>[ValueParameterDescriptorImpl]

'constructor' @ [349:66] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.UnwrappedType[DeserializedPropertyDescriptor]

'toDelete' @ [350:25] ==> val toDelete: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion.create[LocalVariableDescriptor]

'put' @ [350:34] ==> @CanIgnoreReturnValue public abstract fun put(@Nullable p0: DataFlowValue?, @Nullable p1: KotlinType?): Boolean defined in com.google.common.collect.SetMultimap[JavaMethodDescriptor]

'value' @ [350:38] ==> val value: (DataFlowValue..DataFlowValue?) defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion.create[LocalVariableDescriptor]

'type' @ [350:45] ==> val type: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion.create[LocalVariableDescriptor]

'component1' @ [354:19] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(DataFlowValue..DataFlowValue?), (KotlinType..KotlinType?)>.component1(): (DataFlowValue..DataFlowValue?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue..org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue?)
    <V> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)

'component2' @ [354:26] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(DataFlowValue..DataFlowValue?), (KotlinType..KotlinType?)>.component2(): (KotlinType..KotlinType?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue..org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValue?)
    <V> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)

'toDelete' @ [354:35] ==> val toDelete: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion.create[LocalVariableDescriptor]

'entries' @ [354:44] ==> public abstract fun entries(): (MutableSet<(MutableMap.MutableEntry<(DataFlowValue..DataFlowValue?), (KotlinType..KotlinType?)>..Map.Entry<(DataFlowValue..DataFlowValue?), (KotlinType..KotlinType?)>?)>..Set<(MutableMap.MutableEntry<(DataFlowValue..DataFlowValue?), (KotlinType..KotlinType?)>..Map.Entry<(DataFlowValue..DataFlowValue?), (KotlinType..KotlinType?)>?)>?) defined in com.google.common.collect.SetMultimap[JavaMethodDescriptor]

'typeInfo' @ [355:17] ==> value-parameter typeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion.create[ValueParameterDescriptorImpl]

'remove' @ [355:26] ==> @CanIgnoreReturnValue public abstract fun remove(@Nullable @CompatibleWith p0: Any?, @Nullable @CompatibleWith p1: Any?): Boolean defined in com.google.common.collect.SetMultimap[JavaMethodDescriptor]

'value' @ [355:33] ==> val value: (DataFlowValue..DataFlowValue?) defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion.create[LocalVariableDescriptor]

'type' @ [355:40] ==> val type: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion.create[LocalVariableDescriptor]

'nullabilityInfo' @ [357:17] ==> value-parameter nullabilityInfo: Map<DataFlowValue, Nullability> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion.create[ValueParameterDescriptorImpl]

'isEmpty' @ [357:33] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.Map[DeserializedSimpleFunctionDescriptor]

'typeInfo' @ [357:46] ==> value-parameter typeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion.create[ValueParameterDescriptorImpl]

'isEmpty' @ [357:55] ==> public final val <K : (Any..Any?), V : (Any..Any?)> SetMultimap<DataFlowValue, KotlinType>.isEmpty: Boolean[MyPropertyDescriptor]
Inferred types:
    <K : (Any..Any?)> -> DataFlowValue
    <V : (Any..Any?)> -> KotlinType

'valueWithGivenTypeInfo' @ [357:66] ==> value-parameter valueWithGivenTypeInfo: DataFlowValue? = ... defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion.create[ValueParameterDescriptorImpl]

'parent' @ [358:24] ==> value-parameter parent: DataFlowInfo? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion.create[ValueParameterDescriptorImpl]

'DataFlowInfoFactory' @ [358:34] ==> public object DataFlowInfoFactory defined in org.jetbrains.kotlin.resolve.calls.smartcasts in file DataFlowInfo.kt[FakeCallableDescriptorForObject]

'EMPTY' @ [358:54] ==> @JvmField public final val EMPTY: DataFlowInfo defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfoFactory[PropertyDescriptorImpl]

'DelegatingDataFlowInfo' @ [360:20] ==> private constructor DelegatingDataFlowInfo(parent: DataFlowInfo?, nullabilityInfo: Map<DataFlowValue, Nullability>, typeInfo: SetMultimap<DataFlowValue, KotlinType>, valueWithGivenTypeInfo: DataFlowValue?) defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo[ClassConstructorDescriptorImpl]

'parent' @ [360:43] ==> value-parameter parent: DataFlowInfo? defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion.create[ValueParameterDescriptorImpl]

'nullabilityInfo' @ [360:51] ==> value-parameter nullabilityInfo: Map<DataFlowValue, Nullability> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion.create[ValueParameterDescriptorImpl]

'typeInfo' @ [360:68] ==> value-parameter typeInfo: SetMultimap<DataFlowValue, KotlinType> defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion.create[ValueParameterDescriptorImpl]

'valueWithGivenTypeInfo' @ [360:78] ==> value-parameter valueWithGivenTypeInfo: DataFlowValue? = ... defined in org.jetbrains.kotlin.resolve.calls.smartcasts.DelegatingDataFlowInfo.Companion.create[ValueParameterDescriptorImpl]

