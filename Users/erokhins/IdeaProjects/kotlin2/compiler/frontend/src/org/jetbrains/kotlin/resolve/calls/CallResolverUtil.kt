'assert' @ [56:5] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'ReflectionTypes' @ [56:12] ==> public companion object defined in org.jetbrains.kotlin.builtins.ReflectionTypes[FakeCallableDescriptorForObject]

'isCallableType' @ [56:28] ==> public final fun isCallableType(type: KotlinType): Boolean defined in org.jetbrains.kotlin.builtins.ReflectionTypes.Companion[DeserializedSimpleFunctionDescriptor]

'type' @ [56:43] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.hasUnknownFunctionParameter[ValueParameterDescriptorImpl]

'type' @ [56:52] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.hasUnknownFunctionParameter[ValueParameterDescriptorImpl]

'isSuspendFunctionType' @ [56:57] ==> public val KotlinType.isSuspendFunctionType: Boolean defined in org.jetbrains.kotlin.builtins[DeserializedPropertyDescriptor]

'type' @ [56:89] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.hasUnknownFunctionParameter[ValueParameterDescriptorImpl]

'getParameterArgumentsOfCallableType' @ [57:12] ==> private fun getParameterArgumentsOfCallableType(type: KotlinType): List<TypeProjection> defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil in file CallResolverUtil.kt[SimpleFunctionDescriptorImpl]

'type' @ [57:48] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.hasUnknownFunctionParameter[ValueParameterDescriptorImpl]

'any' @ [57:54] ==> public inline fun <T> Iterable<TypeProjection>.any(predicate: (TypeProjection) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection

'it' @ [58:9] ==> value-parameter it: TypeProjection defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.hasUnknownFunctionParameter.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [58:12] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'contains' @ [58:17] ==> public fun KotlinType.contains(predicate: (UnwrappedType) -> Boolean): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'isDontCarePlaceholder' @ [58:38] ==> public open fun isDontCarePlaceholder(@Nullable p0: KotlinType?): Boolean defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'it' @ [58:60] ==> value-parameter it: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.hasUnknownFunctionParameter.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'containsUninferredParameter' @ [58:80] ==> public open fun containsUninferredParameter(@Nullable p0: KotlinType?): Boolean defined in org.jetbrains.kotlin.types.ErrorUtils[JavaMethodDescriptor]

'it' @ [58:108] ==> value-parameter it: TypeProjection defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.hasUnknownFunctionParameter.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [58:111] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'assert' @ [63:5] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'ReflectionTypes' @ [63:12] ==> public companion object defined in org.jetbrains.kotlin.builtins.ReflectionTypes[FakeCallableDescriptorForObject]

'isCallableType' @ [63:28] ==> public final fun isCallableType(type: KotlinType): Boolean defined in org.jetbrains.kotlin.builtins.ReflectionTypes.Companion[DeserializedSimpleFunctionDescriptor]

'type' @ [63:43] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.hasUnknownReturnType[ValueParameterDescriptorImpl]

'type' @ [63:52] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.hasUnknownReturnType[ValueParameterDescriptorImpl]

'isSuspendFunctionType' @ [63:57] ==> public val KotlinType.isSuspendFunctionType: Boolean defined in org.jetbrains.kotlin.builtins[DeserializedPropertyDescriptor]

'type' @ [63:89] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.hasUnknownReturnType[ValueParameterDescriptorImpl]

'containsErrorType' @ [64:23] ==> public open fun containsErrorType(@Nullable p0: KotlinType?): Boolean defined in org.jetbrains.kotlin.types.ErrorUtils[JavaMethodDescriptor]

'getReturnTypeForCallable' @ [64:41] ==> public fun getReturnTypeForCallable(type: KotlinType): KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil in file CallResolverUtil.kt[SimpleFunctionDescriptorImpl]

'type' @ [64:66] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.hasUnknownReturnType[ValueParameterDescriptorImpl]

'assert' @ [68:5] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'ReflectionTypes' @ [68:12] ==> public companion object defined in org.jetbrains.kotlin.builtins.ReflectionTypes[FakeCallableDescriptorForObject]

'isCallableType' @ [68:28] ==> public final fun isCallableType(type: KotlinType): Boolean defined in org.jetbrains.kotlin.builtins.ReflectionTypes.Companion[DeserializedSimpleFunctionDescriptor]

'type' @ [68:43] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.replaceReturnTypeForCallable[ValueParameterDescriptorImpl]

'type' @ [68:52] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.replaceReturnTypeForCallable[ValueParameterDescriptorImpl]

'isSuspendFunctionType' @ [68:57] ==> public val KotlinType.isSuspendFunctionType: Boolean defined in org.jetbrains.kotlin.builtins[DeserializedPropertyDescriptor]

'type' @ [68:89] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.replaceReturnTypeForCallable[ValueParameterDescriptorImpl]

'newArrayList' @ [69:30] ==> @GwtCompatible public open fun <E : (Any..Any?)> newArrayList(): (ArrayList<(TypeProjection..TypeProjection?)>..ArrayList<(TypeProjection..TypeProjection?)>?) defined in com.google.common.collect.Lists[JavaMethodDescriptor]
Inferred types:
    <E : (Any..Any?)> -> TypeProjection

'newArguments' @ [70:5] ==> val newArguments: (ArrayList<(TypeProjection..TypeProjection?)>..ArrayList<(TypeProjection..TypeProjection?)>?) defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.replaceReturnTypeForCallable[LocalVariableDescriptor]

'addAll' @ [70:18] ==> public open fun addAll(elements: Collection<(TypeProjection..TypeProjection?)>): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'getParameterArgumentsOfCallableType' @ [70:25] ==> private fun getParameterArgumentsOfCallableType(type: KotlinType): List<TypeProjection> defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil in file CallResolverUtil.kt[SimpleFunctionDescriptorImpl]

'type' @ [70:61] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.replaceReturnTypeForCallable[ValueParameterDescriptorImpl]

'newArguments' @ [71:5] ==> val newArguments: (ArrayList<(TypeProjection..TypeProjection?)>..ArrayList<(TypeProjection..TypeProjection?)>?) defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.replaceReturnTypeForCallable[LocalVariableDescriptor]

'add' @ [71:18] ==> public open fun add(element: (TypeProjection..TypeProjection?)): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'TypeProjectionImpl' @ [71:22] ==> public constructor TypeProjectionImpl(@NotNull p0: Variance, @NotNull p1: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'INVARIANT' @ [71:50] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'given' @ [71:61] ==> value-parameter given: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.replaceReturnTypeForCallable[ValueParameterDescriptorImpl]

'replaceTypeArguments' @ [72:12] ==> private fun replaceTypeArguments(type: KotlinType, newArguments: List<TypeProjection>): SimpleType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil in file CallResolverUtil.kt[SimpleFunctionDescriptorImpl]

'type' @ [72:33] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.replaceReturnTypeForCallable[ValueParameterDescriptorImpl]

'newArguments' @ [72:39] ==> val newArguments: (ArrayList<(TypeProjection..TypeProjection?)>..ArrayList<(TypeProjection..TypeProjection?)>?) defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.replaceReturnTypeForCallable[LocalVariableDescriptor]

'replaceReturnTypeForCallable' @ [75:52] ==> public fun replaceReturnTypeForCallable(type: KotlinType, given: KotlinType): KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil in file CallResolverUtil.kt[SimpleFunctionDescriptorImpl]

'type' @ [75:81] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.replaceReturnTypeByUnknown[ValueParameterDescriptorImpl]

'DONT_CARE' @ [75:87] ==> public final val DONT_CARE: (SimpleType..SimpleType?) defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'KotlinTypeFactory' @ [78:9] ==> public object KotlinTypeFactory defined in org.jetbrains.kotlin.types[FakeCallableDescriptorForObject]

'simpleType' @ [78:27] ==> @JvmStatic public final fun simpleType(annotations: Annotations, constructor: TypeConstructor, arguments: List<TypeProjection>, nullable: Boolean, memberScope: MemberScope): SimpleType defined in org.jetbrains.kotlin.types.KotlinTypeFactory[DeserializedSimpleFunctionDescriptor]

'type' @ [78:38] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.replaceTypeArguments[ValueParameterDescriptorImpl]

'annotations' @ [78:43] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'type' @ [78:56] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.replaceTypeArguments[ValueParameterDescriptorImpl]

'constructor' @ [78:61] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'newArguments' @ [78:74] ==> value-parameter newArguments: List<TypeProjection> defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.replaceTypeArguments[ValueParameterDescriptorImpl]

'type' @ [78:88] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.replaceTypeArguments[ValueParameterDescriptorImpl]

'isMarkedNullable' @ [78:93] ==> public abstract val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'type' @ [78:111] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.replaceTypeArguments[ValueParameterDescriptorImpl]

'memberScope' @ [78:116] ==> public abstract val memberScope: MemberScope defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'type' @ [81:9] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getParameterArgumentsOfCallableType[ValueParameterDescriptorImpl]

'arguments' @ [81:14] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'dropLast' @ [81:24] ==> public fun <T> List<TypeProjection>.dropLast(n: Int): List<TypeProjection> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection

'type' @ [84:9] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getReturnTypeForCallable[ValueParameterDescriptorImpl]

'arguments' @ [84:14] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'last' @ [84:24] ==> public fun <T> List<TypeProjection>.last(): TypeProjection defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection

'type' @ [84:31] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'returnType' @ [87:22] ==> public final val CallableDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'constraintSystem' @ [88:31] ==> value-parameter constraintSystem: ConstraintSystem defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.hasReturnTypeDependentOnUninferredParams[ValueParameterDescriptorImpl]

'getNestedTypeVariables' @ [88:48] ==> public fun ConstraintSystem.getNestedTypeVariables(type: KotlinType): List<TypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference in file constraintSystemUtils.kt[SimpleFunctionDescriptorImpl]

'returnType' @ [88:71] ==> val returnType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.hasReturnTypeDependentOnUninferredParams[LocalVariableDescriptor]

'nestedTypeVariables' @ [89:12] ==> val nestedTypeVariables: List<TypeVariable> defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.hasReturnTypeDependentOnUninferredParams[LocalVariableDescriptor]

'any' @ [89:32] ==> public inline fun <T> Iterable<TypeVariable>.any(predicate: (TypeVariable) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeVariable

'constraintSystem' @ [89:38] ==> value-parameter constraintSystem: ConstraintSystem defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.hasReturnTypeDependentOnUninferredParams[ValueParameterDescriptorImpl]

'getTypeBounds' @ [89:55] ==> public abstract fun getTypeBounds(typeVariable: TypeVariable): TypeBounds defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem[SimpleFunctionDescriptorImpl]

'it' @ [89:69] ==> value-parameter it: TypeVariable defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.hasReturnTypeDependentOnUninferredParams.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [89:73] ==> public open val value: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.TypeBounds[PropertyDescriptorImpl]

'hasReturnTypeDependentOnUninferredParams' @ [93:9] ==> private fun CallableDescriptor.hasReturnTypeDependentOnUninferredParams(constraintSystem: ConstraintSystem): Boolean defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil in file CallResolverUtil.kt[SimpleFunctionDescriptorImpl]

'constraintSystem' @ [93:50] ==> value-parameter constraintSystem: ConstraintSystem defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.hasInferredReturnType[ValueParameterDescriptorImpl]

'constraintSystem' @ [96:9] ==> value-parameter constraintSystem: ConstraintSystem defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.hasInferredReturnType[ValueParameterDescriptorImpl]

'status' @ [96:26] ==> public abstract val status: ConstraintSystemStatus defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem[PropertyDescriptorImpl]

'hasOnlyErrorsDerivedFrom' @ [96:33] ==> public abstract fun hasOnlyErrorsDerivedFrom(kind: ConstraintPositionKind): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemStatus[SimpleFunctionDescriptorImpl]

'EXPECTED_TYPE_POSITION' @ [96:58] ==> enum entry EXPECTED_TYPE_POSITION defined in org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPositionKind[FakeCallableDescriptorForObject]

'receiverParameterDescriptor' @ [101:24] ==> value-parameter receiverParameterDescriptor: ReceiverParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getErasedReceiverType[ValueParameterDescriptorImpl]

'type' @ [101:52] ==> public final val ReceiverParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'descriptor' @ [102:27] ==> value-parameter descriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getErasedReceiverType[ValueParameterDescriptorImpl]

'typeParameters' @ [102:38] ==> public final val CallableDescriptor.typeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'typeParameter' @ [103:13] ==> val typeParameter: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getErasedReceiverType[LocalVariableDescriptor]

'typeConstructor' @ [103:27] ==> public final val TypeParameterDescriptor.typeConstructor: TypeConstructor[MyPropertyDescriptor]

'receiverType' @ [103:46] ==> var receiverType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getErasedReceiverType[LocalVariableDescriptor]

'constructor' @ [103:59] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'receiverType' @ [104:13] ==> var receiverType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getErasedReceiverType[LocalVariableDescriptor]

'getUpperBoundsAsType' @ [104:44] ==> @NotNull public open fun getUpperBoundsAsType(@NotNull descriptor: TypeParameterDescriptor): KotlinType defined in org.jetbrains.kotlin.types.TypeIntersector[JavaMethodDescriptor]

'typeParameter' @ [104:65] ==> val typeParameter: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getErasedReceiverType[LocalVariableDescriptor]

'newSmartList' @ [107:43] ==> @NotNull @Contract public open fun <T : (Any..Any?)> newSmartList(): (MutableList<(TypeProjection..TypeProjection?)>..List<(TypeProjection..TypeProjection?)>) defined in com.intellij.util.containers.ContainerUtil[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> TypeProjection

'receiverType' @ [108:28] ==> var receiverType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getErasedReceiverType[LocalVariableDescriptor]

'arguments' @ [108:41] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'fakeTypeArguments' @ [109:9] ==> val fakeTypeArguments: (MutableList<(TypeProjection..TypeProjection?)>..List<(TypeProjection..TypeProjection?)>) defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getErasedReceiverType[LocalVariableDescriptor]

'add' @ [109:27] ==> public abstract fun add(element: (TypeProjection..TypeProjection?)): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'TypeProjectionImpl' @ [109:31] ==> public constructor TypeProjectionImpl(@NotNull p0: Variance, @NotNull p1: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'typeProjection' @ [109:50] ==> val typeProjection: TypeProjection defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getErasedReceiverType[LocalVariableDescriptor]

'projectionKind' @ [109:65] ==> public final val TypeProjection.projectionKind: Variance[MyPropertyDescriptor]

'DONT_CARE' @ [109:81] ==> public final val DONT_CARE: (SimpleType..SimpleType?) defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'if (receiverType.constructor is IntersectionTypeConstructor) {
        val superTypesWithFakeArguments = receiverType.constructor.supertypes.map { supertype ->
            val fakeArguments = supertype.arguments.map { TypeProjectionImpl(it.projectionKind, DONT_CARE) }
            supertype.replace(fakeArguments)
        }

        IntersectionTypeConstructor(superTypesWithFakeArguments)
    } else {
        receiverType.constructor
    }' @ [112:35] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: TypeConstructor, elseBranch: TypeConstructor): TypeConstructor[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> TypeConstructor

'receiverType' @ [112:39] ==> var receiverType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getErasedReceiverType[LocalVariableDescriptor]

'constructor' @ [112:52] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'receiverType' @ [113:43] ==> var receiverType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getErasedReceiverType[LocalVariableDescriptor]

'constructor' @ [113:56] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'supertypes' @ [113:68] ==> public final val TypeConstructor.supertypes: Collection<(KotlinType..KotlinType?)>[MyPropertyDescriptor]

'map' @ [113:79] ==> public inline fun <T, R> Iterable<(KotlinType..KotlinType?)>.map(transform: ((KotlinType..KotlinType?)) -> KotlinType): List<KotlinType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)
    <R> -> KotlinType

'supertype' @ [114:33] ==> value-parameter supertype: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getErasedReceiverType.<anonymous>[ValueParameterDescriptorImpl]

'arguments' @ [114:43] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'map' @ [114:53] ==> public inline fun <T, R> Iterable<TypeProjection>.map(transform: (TypeProjection) -> TypeProjectionImpl): List<TypeProjectionImpl> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection
    <R> -> TypeProjectionImpl

'TypeProjectionImpl' @ [114:59] ==> public constructor TypeProjectionImpl(@NotNull p0: Variance, @NotNull p1: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'it' @ [114:78] ==> value-parameter it: TypeProjection defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getErasedReceiverType.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'projectionKind' @ [114:81] ==> public final val TypeProjection.projectionKind: Variance[MyPropertyDescriptor]

'DONT_CARE' @ [114:97] ==> public final val DONT_CARE: (SimpleType..SimpleType?) defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'supertype' @ [115:13] ==> value-parameter supertype: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getErasedReceiverType.<anonymous>[ValueParameterDescriptorImpl]

'replace' @ [115:23] ==> @JvmOverloads public fun KotlinType.replace(newArguments: List<TypeProjection> = ..., newAnnotations: Annotations = ...): KotlinType defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'fakeArguments' @ [115:31] ==> val fakeArguments: List<TypeProjectionImpl> defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getErasedReceiverType.<anonymous>[LocalVariableDescriptor]

'IntersectionTypeConstructor' @ [118:9] ==> public constructor IntersectionTypeConstructor(p0: (MutableCollection<(KotlinType..KotlinType?)>..Collection<(KotlinType..KotlinType?)>?)) defined in org.jetbrains.kotlin.types.IntersectionTypeConstructor[JavaClassConstructorDescriptor]

'superTypesWithFakeArguments' @ [118:37] ==> val superTypesWithFakeArguments: List<KotlinType> defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getErasedReceiverType[LocalVariableDescriptor]

'receiverType' @ [120:9] ==> var receiverType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getErasedReceiverType[LocalVariableDescriptor]

'constructor' @ [120:22] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'KotlinTypeFactory' @ [123:12] ==> public object KotlinTypeFactory defined in org.jetbrains.kotlin.types[FakeCallableDescriptorForObject]

'simpleType' @ [123:30] ==> @JvmStatic public final fun simpleType(annotations: Annotations, constructor: TypeConstructor, arguments: List<TypeProjection>, nullable: Boolean, memberScope: MemberScope): SimpleType defined in org.jetbrains.kotlin.types.KotlinTypeFactory[DeserializedSimpleFunctionDescriptor]

'receiverType' @ [123:41] ==> var receiverType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getErasedReceiverType[LocalVariableDescriptor]

'annotations' @ [123:54] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'receiverTypeConstructor' @ [123:67] ==> val receiverTypeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getErasedReceiverType[LocalVariableDescriptor]

'fakeTypeArguments' @ [123:92] ==> val fakeTypeArguments: (MutableList<(TypeProjection..TypeProjection?)>..List<(TypeProjection..TypeProjection?)>) defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getErasedReceiverType[LocalVariableDescriptor]

'receiverType' @ [124:41] ==> var receiverType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getErasedReceiverType[LocalVariableDescriptor]

'isMarkedNullable' @ [124:54] ==> public abstract val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'createErrorScope' @ [124:83] ==> @NotNull public open fun createErrorScope(@NotNull p0: String, p1: Boolean): MemberScope defined in org.jetbrains.kotlin.types.ErrorUtils[JavaMethodDescriptor]

'descriptor' @ [128:9] ==> value-parameter descriptor: CallableMemberDescriptor defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isOrOverridesSynthesized[ValueParameterDescriptorImpl]

'kind' @ [128:20] ==> public final val CallableMemberDescriptor.kind: CallableMemberDescriptor.Kind[MyPropertyDescriptor]

'SYNTHESIZED' @ [128:58] ==> enum entry SYNTHESIZED defined in org.jetbrains.kotlin.descriptors.CallableMemberDescriptor.Kind[FakeCallableDescriptorForObject]

'descriptor' @ [131:9] ==> value-parameter descriptor: CallableMemberDescriptor defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isOrOverridesSynthesized[ValueParameterDescriptorImpl]

'kind' @ [131:20] ==> public final val CallableMemberDescriptor.kind: CallableMemberDescriptor.Kind[MyPropertyDescriptor]

'FAKE_OVERRIDE' @ [131:58] ==> enum entry FAKE_OVERRIDE defined in org.jetbrains.kotlin.descriptors.CallableMemberDescriptor.Kind[FakeCallableDescriptorForObject]

'descriptor' @ [132:16] ==> value-parameter descriptor: CallableMemberDescriptor defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isOrOverridesSynthesized[ValueParameterDescriptorImpl]

'overriddenDescriptors' @ [132:27] ==> public final var CallableMemberDescriptor.overriddenDescriptors: (MutableCollection<out (CallableMemberDescriptor..CallableMemberDescriptor?)>..Collection<(CallableMemberDescriptor..CallableMemberDescriptor?)>)[MyPropertyDescriptor]

'all' @ [132:49] ==> public inline fun <T> Iterable<(CallableMemberDescriptor..CallableMemberDescriptor?)>.all(predicate: ((CallableMemberDescriptor..CallableMemberDescriptor?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.CallableMemberDescriptor..org.jetbrains.kotlin.descriptors.CallableMemberDescriptor?)

'isOrOverridesSynthesized' @ [132:55] ==> public fun isOrOverridesSynthesized(descriptor: CallableMemberDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil in file CallResolverUtil.kt[SimpleFunctionDescriptorImpl]

'call' @ [138:23] ==> value-parameter call: Call defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isBinaryRemOperator[ValueParameterDescriptorImpl]

'callElement' @ [138:28] ==> public final val Call.callElement: KtElement[MyPropertyDescriptor]

'callElement' @ [139:20] ==> val callElement: KtBinaryExpression defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isBinaryRemOperator[LocalVariableDescriptor]

'operationToken' @ [139:32] ==> public final val KtBinaryExpression.operationToken: IElementType[MyPropertyDescriptor]

'operator' @ [140:9] ==> val operator: IElementType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isBinaryRemOperator[LocalVariableDescriptor]

'getNameForOperationSymbol' @ [142:36] ==> @Nullable public open fun getNameForOperationSymbol(@NotNull token: KtToken, unaryOperations: Boolean, binaryOperations: Boolean): Name? defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaMethodDescriptor]

'operator' @ [142:62] ==> val operator: IElementType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isBinaryRemOperator[LocalVariableDescriptor]

'name' @ [143:12] ==> val name: Name? defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isBinaryRemOperator[LocalVariableDescriptor]

'REM_TO_MOD_OPERATION_NAMES' @ [143:40] ==> public final val REM_TO_MOD_OPERATION_NAMES: (ImmutableBiMap<(Name..Name?), (Name..Name?)>..ImmutableBiMap<(Name..Name?), (Name..Name?)>?) defined in org.jetbrains.kotlin.types.expressions.OperatorConventions[JavaPropertyDescriptor]

'keys' @ [143:67] ==> public open val keys: ImmutableSet<(Name..Name?)> defined in com.google.common.collect.ImmutableBiMap[JavaPropertyDescriptor]

'call' @ [147:9] ==> value-parameter call: Call defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isConventionCall[ValueParameterDescriptorImpl]

'call' @ [148:23] ==> value-parameter call: Call defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isConventionCall[ValueParameterDescriptorImpl]

'callElement' @ [148:28] ==> public final val Call.callElement: KtElement[MyPropertyDescriptor]

'callElement' @ [149:9] ==> val callElement: KtElement defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isConventionCall[LocalVariableDescriptor]

'callElement' @ [149:51] ==> val callElement: KtElement defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isConventionCall[LocalVariableDescriptor]

'call' @ [150:28] ==> value-parameter call: Call defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isConventionCall[ValueParameterDescriptorImpl]

'calleeExpression' @ [150:33] ==> public final val Call.calleeExpression: KtExpression?[MyPropertyDescriptor]

'calleeExpression' @ [151:12] ==> val calleeExpression: KtOperationReferenceExpression defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isConventionCall[LocalVariableDescriptor]

'isConventionOperator' @ [151:29] ==> public final fun isConventionOperator(): Boolean defined in org.jetbrains.kotlin.psi.KtOperationReferenceExpression[SimpleFunctionDescriptorImpl]

'call' @ [155:34] ==> value-parameter call: Call defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isInfixCall[ValueParameterDescriptorImpl]

'calleeExpression' @ [155:39] ==> public final val Call.calleeExpression: KtExpression?[MyPropertyDescriptor]

'operationRefExpression' @ [156:28] ==> val operationRefExpression: KtOperationReferenceExpression defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isInfixCall[LocalVariableDescriptor]

'parent' @ [156:51] ==> public final val KtOperationReferenceExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'binaryExpression' @ [157:12] ==> val binaryExpression: KtBinaryExpression defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isInfixCall[LocalVariableDescriptor]

'operationReference' @ [157:29] ==> public final val KtBinaryExpression.operationReference: KtOperationReferenceExpression[MyPropertyDescriptor]

'operationRefExpression' @ [157:52] ==> val operationRefExpression: KtOperationReferenceExpression defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isInfixCall[LocalVariableDescriptor]

'operationRefExpression' @ [157:78] ==> val operationRefExpression: KtOperationReferenceExpression defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isInfixCall[LocalVariableDescriptor]

'operationSignTokenType' @ [157:101] ==> public final val operationSignTokenType: KtSingleValueToken? defined in org.jetbrains.kotlin.psi.KtOperationReferenceExpression[PropertyDescriptorImpl]

'call' @ [161:9] ==> value-parameter call: Call defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isSuperOrDelegatingConstructorCall[ValueParameterDescriptorImpl]

'calleeExpression' @ [161:14] ==> public final val Call.calleeExpression: KtExpression?[MyPropertyDescriptor]

'let' @ [161:31] ==> @InlineOnly public inline fun <T, R> KtExpression?.let(block: (KtExpression?) -> Boolean): Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression?
    <R> -> Boolean

'it' @ [161:37] ==> value-parameter it: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isSuperOrDelegatingConstructorCall.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [161:77] ==> value-parameter it: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isSuperOrDelegatingConstructorCall.<anonymous>[ValueParameterDescriptorImpl]

'call' @ [164:9] ==> value-parameter call: Call defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isInvokeCallOnVariable[ValueParameterDescriptorImpl]

'callType' @ [164:14] ==> public final val Call.callType: Call.CallType[MyPropertyDescriptor]

'INVOKE' @ [164:41] ==> enum entry INVOKE defined in org.jetbrains.kotlin.psi.Call.CallType[FakeCallableDescriptorForObject]

'call' @ [165:28] ==> value-parameter call: Call defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isInvokeCallOnVariable[ValueParameterDescriptorImpl]

'dispatchReceiver' @ [165:33] ==> public final val Call.dispatchReceiver: ReceiverValue?[MyPropertyDescriptor]

'dispatchReceiver' @ [167:23] ==> val dispatchReceiver: ReceiverValue? defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isInvokeCallOnVariable[LocalVariableDescriptor]

'expression' @ [167:63] ==> public abstract val expression: KtExpression defined in org.jetbrains.kotlin.resolve.scopes.receivers.ExpressionReceiver[PropertyDescriptorImpl]

'expression' @ [168:12] ==> val expression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isInvokeCallOnVariable[LocalVariableDescriptor]

'call' @ [172:9] ==> value-parameter call: Call defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isInvokeCallOnExpressionWithBothReceivers[ValueParameterDescriptorImpl]

'callType' @ [172:14] ==> public final val Call.callType: Call.CallType[MyPropertyDescriptor]

'INVOKE' @ [172:41] ==> enum entry INVOKE defined in org.jetbrains.kotlin.psi.Call.CallType[FakeCallableDescriptorForObject]

'isInvokeCallOnVariable' @ [172:51] ==> public fun isInvokeCallOnVariable(call: Call): Boolean defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil in file CallResolverUtil.kt[SimpleFunctionDescriptorImpl]

'call' @ [172:74] ==> value-parameter call: Call defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isInvokeCallOnExpressionWithBothReceivers[ValueParameterDescriptorImpl]

'call' @ [173:12] ==> value-parameter call: Call defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isInvokeCallOnExpressionWithBothReceivers[ValueParameterDescriptorImpl]

'explicitReceiver' @ [173:17] ==> public final val Call.explicitReceiver: Receiver?[MyPropertyDescriptor]

'call' @ [173:45] ==> value-parameter call: Call defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.isInvokeCallOnExpressionWithBothReceivers[ValueParameterDescriptorImpl]

'dispatchReceiver' @ [173:50] ==> public final val Call.dispatchReceiver: ReceiverValue?[MyPropertyDescriptor]

'call' @ [177:13] ==> value-parameter call: Call defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getSuperCallExpression[ValueParameterDescriptorImpl]

'explicitReceiver' @ [177:18] ==> public final val Call.explicitReceiver: Receiver?[MyPropertyDescriptor]

'expression' @ [177:60] ==> public abstract val expression: KtExpression defined in org.jetbrains.kotlin.resolve.scopes.receivers.ExpressionReceiver[PropertyDescriptorImpl]

'argument' @ [181:9] ==> value-parameter argument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getEffectiveExpectedType[ValueParameterDescriptorImpl]

'getSpreadElement' @ [181:18] ==> public abstract fun getSpreadElement(): LeafPsiElement? defined in org.jetbrains.kotlin.psi.ValueArgument[SimpleFunctionDescriptorImpl]

'parameterDescriptor' @ [182:13] ==> value-parameter parameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getEffectiveExpectedType[ValueParameterDescriptorImpl]

'varargElementType' @ [182:33] ==> public abstract val varargElementType: KotlinType? defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'DONT_CARE' @ [184:20] ==> public final val DONT_CARE: (SimpleType..SimpleType?) defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'parameterDescriptor' @ [186:16] ==> value-parameter parameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getEffectiveExpectedType[ValueParameterDescriptorImpl]

'type' @ [186:36] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'parameterDescriptor' @ [188:29] ==> value-parameter parameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getEffectiveExpectedType[ValueParameterDescriptorImpl]

'varargElementType' @ [188:49] ==> public abstract val varargElementType: KotlinType? defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'varargElementType' @ [189:9] ==> val varargElementType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getEffectiveExpectedType[LocalVariableDescriptor]

'varargElementType' @ [190:16] ==> val varargElementType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getEffectiveExpectedType[LocalVariableDescriptor]

'parameterDescriptor' @ [193:12] ==> value-parameter parameterDescriptor: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getEffectiveExpectedType[ValueParameterDescriptorImpl]

'type' @ [193:32] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'typeWithConstructors' @ [203:33] ==> value-parameter typeWithConstructors: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[ValueParameterDescriptorImpl]

'constructor' @ [203:54] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'declarationDescriptor' @ [203:66] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'typeWithConstructors' @ [205:25] ==> value-parameter typeWithConstructors: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[ValueParameterDescriptorImpl]

'unwrap' @ [205:46] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'if (useKnownTypeSubstitutor)
                TypeSubstitutor.create(
                        (unwrappedType as? AbbreviatedType)?.abbreviation ?: unwrappedType
                )
            else null' @ [207:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: TypeSubstitutor?, elseBranch: TypeSubstitutor?): TypeSubstitutor?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> TypeSubstitutor?

'useKnownTypeSubstitutor' @ [207:17] ==> value-parameter useKnownTypeSubstitutor: Boolean defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[ValueParameterDescriptorImpl]

'create' @ [208:33] ==> @NotNull public open fun create(@NotNull p0: KotlinType): TypeSubstitutor defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'?:' @ [209:25] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KotlinType?, right: KotlinType): KotlinType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KotlinType

'unwrappedType' @ [209:26] ==> val unwrappedType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[LocalVariableDescriptor]

'abbreviation' @ [209:62] ==> public final val abbreviation: SimpleType defined in org.jetbrains.kotlin.types.AbbreviatedType[DeserializedPropertyDescriptor]

'unwrappedType' @ [209:78] ==> val unwrappedType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[LocalVariableDescriptor]

'if (unwrappedType is AbbreviatedType)
                unwrappedType.abbreviation.constructor.declarationDescriptor as? TypeAliasDescriptor
            else
                null' @ [214:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: TypeAliasDescriptor?, elseBranch: TypeAliasDescriptor?): TypeAliasDescriptor?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> TypeAliasDescriptor?

'unwrappedType' @ [214:17] ==> val unwrappedType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[LocalVariableDescriptor]

'unwrappedType' @ [215:17] ==> val unwrappedType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[LocalVariableDescriptor]

'abbreviation' @ [215:31] ==> public final val abbreviation: SimpleType defined in org.jetbrains.kotlin.types.AbbreviatedType[DeserializedPropertyDescriptor]

'constructor' @ [215:44] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'declarationDescriptor' @ [215:56] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'typeAliasDescriptor' @ [219:24] ==> val typeAliasDescriptor: TypeAliasDescriptor? defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[LocalVariableDescriptor]

'constructors' @ [219:45] ==> public abstract val constructors: Collection<TypeAliasConstructorDescriptor> defined in org.jetbrains.kotlin.descriptors.TypeAliasDescriptor[DeserializedPropertyDescriptor]

'mapNotNull' @ [219:59] ==> public inline fun <T, R : Any> Iterable<TypeAliasConstructorDescriptor>.mapNotNull(transform: (TypeAliasConstructorDescriptor) -> TypeAliasConstructorDescriptor?): List<TypeAliasConstructorDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeAliasConstructorDescriptor
    <R : Any> -> TypeAliasConstructorDescriptor

'withDispatchReceiver' @ [219:102] ==> public abstract val withDispatchReceiver: TypeAliasConstructorDescriptor? defined in org.jetbrains.kotlin.descriptors.impl.TypeAliasConstructorDescriptor[DeserializedPropertyDescriptor]

'classWithConstructors' @ [219:127] ==> val classWithConstructors: ClassDescriptor defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[LocalVariableDescriptor]

'constructors' @ [219:149] ==> public final val ClassDescriptor.constructors: Collection<(ClassConstructorDescriptor..ClassConstructorDescriptor?)>[MyPropertyDescriptor]

'constructors' @ [221:9] ==> val constructors: Collection<(ConstructorDescriptor..ConstructorDescriptor?)> defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[LocalVariableDescriptor]

'isEmpty' @ [221:22] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.Collection[DeserializedSimpleFunctionDescriptor]

'emptyList' @ [221:40] ==> public fun <T> emptyList(): List<ResolutionCandidate<ConstructorDescriptor>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ResolutionCandidate<ConstructorDescriptor>

'if (classWithConstructors.isInner) {
        val outerClassType = (classWithConstructors.containingDeclaration as? ClassDescriptor)?.defaultType ?: return emptyList()
        val substitutedOuterClassType = knownSubstitutor?.substitute(outerClassType, Variance.INVARIANT) ?: outerClassType

        val receiver = lexicalScope.getImplicitReceiversHierarchy().firstOrNull {
            KotlinTypeChecker.DEFAULT.isSubtypeOf(it.type, substitutedOuterClassType)
        } ?: return emptyList()

        receiverKind = ExplicitReceiverKind.DISPATCH_RECEIVER
        dispatchReceiver = receiver.value
    }
    else {
        receiverKind = ExplicitReceiverKind.NO_EXPLICIT_RECEIVER
        dispatchReceiver = null
    }' @ [226:5] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'classWithConstructors' @ [226:9] ==> val classWithConstructors: ClassDescriptor defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[LocalVariableDescriptor]

'isInner' @ [226:31] ==> public final val ClassDescriptor.isInner: Boolean[MyPropertyDescriptor]

'?:' @ [227:30] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: SimpleType?, right: SimpleType): SimpleType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> SimpleType

'classWithConstructors' @ [227:31] ==> val classWithConstructors: ClassDescriptor defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[LocalVariableDescriptor]

'containingDeclaration' @ [227:53] ==> public final val ClassDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'defaultType' @ [227:97] ==> public final val ClassDescriptor.defaultType: SimpleType[MyPropertyDescriptor]

'emptyList' @ [227:119] ==> public fun <T> emptyList(): List<ResolutionCandidate<ConstructorDescriptor>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ResolutionCandidate<ConstructorDescriptor>

'knownSubstitutor' @ [228:41] ==> val knownSubstitutor: TypeSubstitutor? defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[LocalVariableDescriptor]

'substitute' @ [228:59] ==> @Nullable public open fun substitute(@NotNull p0: KotlinType, @NotNull p1: Variance): KotlinType? defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'outerClassType' @ [228:70] ==> val outerClassType: SimpleType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[LocalVariableDescriptor]

'INVARIANT' @ [228:95] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'outerClassType' @ [228:109] ==> val outerClassType: SimpleType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[LocalVariableDescriptor]

'lexicalScope' @ [230:24] ==> value-parameter lexicalScope: LexicalScope defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[ValueParameterDescriptorImpl]

'getImplicitReceiversHierarchy' @ [230:37] ==> public fun LexicalScope.getImplicitReceiversHierarchy(): List<ReceiverParameterDescriptor> defined in org.jetbrains.kotlin.resolve.scopes.utils[DeserializedSimpleFunctionDescriptor]

'firstOrNull' @ [230:69] ==> public inline fun <T> Iterable<ReceiverParameterDescriptor>.firstOrNull(predicate: (ReceiverParameterDescriptor) -> Boolean): ReceiverParameterDescriptor? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ReceiverParameterDescriptor

'DEFAULT' @ [231:31] ==> public final val DEFAULT: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaPropertyDescriptor]

'isSubtypeOf' @ [231:39] ==> public abstract fun isSubtypeOf(@NotNull p0: KotlinType, @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaMethodDescriptor]

'it' @ [231:51] ==> value-parameter it: ReceiverParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [231:54] ==> public final val ReceiverParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'substitutedOuterClassType' @ [231:60] ==> val substitutedOuterClassType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[LocalVariableDescriptor]

'emptyList' @ [232:21] ==> public fun <T> emptyList(): List<ResolutionCandidate<ConstructorDescriptor>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ResolutionCandidate<ConstructorDescriptor>

'receiverKind' @ [234:9] ==> val receiverKind: ExplicitReceiverKind defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[LocalVariableDescriptor]

'DISPATCH_RECEIVER' @ [234:45] ==> enum entry DISPATCH_RECEIVER defined in org.jetbrains.kotlin.resolve.calls.tasks.ExplicitReceiverKind[FakeCallableDescriptorForObject]

'dispatchReceiver' @ [235:9] ==> val dispatchReceiver: ReceiverValue? defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[LocalVariableDescriptor]

'receiver' @ [235:28] ==> val receiver: ReceiverParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[LocalVariableDescriptor]

'value' @ [235:37] ==> public final val ReceiverParameterDescriptor.value: ReceiverValue[MyPropertyDescriptor]

'receiverKind' @ [238:9] ==> val receiverKind: ExplicitReceiverKind defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[LocalVariableDescriptor]

'NO_EXPLICIT_RECEIVER' @ [238:45] ==> enum entry NO_EXPLICIT_RECEIVER defined in org.jetbrains.kotlin.resolve.calls.tasks.ExplicitReceiverKind[FakeCallableDescriptorForObject]

'dispatchReceiver' @ [239:9] ==> val dispatchReceiver: ReceiverValue? defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[LocalVariableDescriptor]

'constructors' @ [242:33] ==> val constructors: Collection<(ConstructorDescriptor..ConstructorDescriptor?)> defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[LocalVariableDescriptor]

'flatMap' @ [242:46] ==> public inline fun <T, R> Iterable<(ConstructorDescriptor..ConstructorDescriptor?)>.flatMap(transform: ((ConstructorDescriptor..ConstructorDescriptor?)) -> Iterable<ConstructorDescriptor>): List<ConstructorDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ConstructorDescriptor..org.jetbrains.kotlin.descriptors.ConstructorDescriptor?)
    <R> -> ConstructorDescriptor

'syntheticScopes' @ [242:56] ==> value-parameter syntheticScopes: SyntheticScopes defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[ValueParameterDescriptorImpl]

'collectSyntheticConstructors' @ [242:72] ==> public fun SyntheticScopes.collectSyntheticConstructors(constructor: ConstructorDescriptor): List<ConstructorDescriptor> defined in org.jetbrains.kotlin.resolve.scopes[DeserializedSimpleFunctionDescriptor]

'it' @ [242:101] ==> value-parameter it: (ConstructorDescriptor..ConstructorDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors.<anonymous>[ValueParameterDescriptorImpl]

'constructors' @ [244:13] ==> val constructors: Collection<(ConstructorDescriptor..ConstructorDescriptor?)> defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[LocalVariableDescriptor]

'syntheticConstructors' @ [244:28] ==> val syntheticConstructors: List<ConstructorDescriptor> defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[LocalVariableDescriptor]

'map' @ [244:51] ==> public inline fun <T, R> Iterable<(ConstructorDescriptor..ConstructorDescriptor?)>.map(transform: ((ConstructorDescriptor..ConstructorDescriptor?)) -> (ResolutionCandidate<(ConstructorDescriptor..ConstructorDescriptor?)>..ResolutionCandidate<(ConstructorDescriptor..ConstructorDescriptor?)>?)): List<(ResolutionCandidate<(ConstructorDescriptor..ConstructorDescriptor?)>..ResolutionCandidate<(ConstructorDescriptor..ConstructorDescriptor?)>?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ConstructorDescriptor..org.jetbrains.kotlin.descriptors.ConstructorDescriptor?)
    <R> -> (org.jetbrains.kotlin.resolve.calls.tasks.ResolutionCandidate<(org.jetbrains.kotlin.descriptors.ConstructorDescriptor..org.jetbrains.kotlin.descriptors.ConstructorDescriptor?)>..org.jetbrains.kotlin.resolve.calls.tasks.ResolutionCandidate<(org.jetbrains.kotlin.descriptors.ConstructorDescriptor..org.jetbrains.kotlin.descriptors.ConstructorDescriptor?)>?)

'create' @ [245:29] ==> public open fun <D : (CallableDescriptor..CallableDescriptor?)> create(@NotNull call: Call, @NotNull descriptor: ConstructorDescriptor, @Nullable dispatchReceiver: ReceiverValue?, @NotNull explicitReceiverKind: ExplicitReceiverKind, @Nullable knownTypeParametersResultingSubstitutor: TypeSubstitutor?): (ResolutionCandidate<(ConstructorDescriptor..ConstructorDescriptor?)>..ResolutionCandidate<(ConstructorDescriptor..ConstructorDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.calls.tasks.ResolutionCandidate[JavaMethodDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.ConstructorDescriptor..org.jetbrains.kotlin.descriptors.ConstructorDescriptor?)

'call' @ [245:36] ==> value-parameter call: Call defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[ValueParameterDescriptorImpl]

'it' @ [245:42] ==> value-parameter it: (ConstructorDescriptor..ConstructorDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors.<anonymous>[ValueParameterDescriptorImpl]

'dispatchReceiver' @ [245:46] ==> val dispatchReceiver: ReceiverValue? defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[LocalVariableDescriptor]

'receiverKind' @ [245:64] ==> val receiverKind: ExplicitReceiverKind defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[LocalVariableDescriptor]

'knownSubstitutor' @ [245:78] ==> val knownSubstitutor: TypeSubstitutor? defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.createResolutionCandidatesForConstructors[LocalVariableDescriptor]

'?:' @ [252:24] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: ResolvedCall<out CallableDescriptor>?, right: ResolvedCall<out CallableDescriptor>): ResolvedCall<out CallableDescriptor>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> ResolvedCall<out CallableDescriptor>

'getParentCallIfPresent' @ [252:34] ==> @Nullable public open fun getParentCallIfPresent(@NotNull expression: KtExpression): KtExpression? defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'this' @ [252:57] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getCorrespondingParameterForFunctionArgument[ReceiverParameterDescriptorImpl]

'getResolvedCall' @ [252:64] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil in file callUtil.kt[SimpleFunctionDescriptorImpl]

'bindingContext' @ [252:80] ==> value-parameter bindingContext: BindingContext defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getCorrespondingParameterForFunctionArgument[ValueParameterDescriptorImpl]

'resolvedCall' @ [254:13] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getCorrespondingParameterForFunctionArgument[LocalVariableDescriptor]

'call' @ [254:26] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out CallableDescriptor)

'getValueArgumentForExpression' @ [254:31] ==> public fun Call.getValueArgumentForExpression(expression: KtExpression): ValueArgument? defined in org.jetbrains.kotlin.resolve.calls.callUtil in file callUtil.kt[SimpleFunctionDescriptorImpl]

'this' @ [254:61] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getCorrespondingParameterForFunctionArgument[ReceiverParameterDescriptorImpl]

'resolvedCall' @ [256:19] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getCorrespondingParameterForFunctionArgument[LocalVariableDescriptor]

'getArgumentMapping' @ [256:32] ==> @NotNull public abstract fun getArgumentMapping(@NotNull valueArgument: ValueArgument): ArgumentMapping defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCall[JavaMethodDescriptor]

'valueArgument' @ [256:51] ==> val valueArgument: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getCorrespondingParameterForFunctionArgument[LocalVariableDescriptor]

'mapping' @ [258:12] ==> val mapping: ArgumentMatch defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil.getCorrespondingParameterForFunctionArgument[LocalVariableDescriptor]

'valueParameter' @ [258:20] ==> public abstract val valueParameter: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.model.ArgumentMatch[PropertyDescriptorImpl]

