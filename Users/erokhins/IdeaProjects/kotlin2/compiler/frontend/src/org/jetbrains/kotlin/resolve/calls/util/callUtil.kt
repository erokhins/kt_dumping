'call' @ [39:12] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<D>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> D

'valueArguments' @ [39:17] ==> public final val Call.valueArguments: List<(ValueArgument..ValueArgument?)>[MyPropertyDescriptor]

'all' @ [39:32] ==> public inline fun <T> Iterable<(ValueArgument..ValueArgument?)>.all(predicate: ((ValueArgument..ValueArgument?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)

'!' @ [39:50] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'getArgumentMapping' @ [39:51] ==> @NotNull public abstract fun getArgumentMapping(@NotNull valueArgument: ValueArgument): ArgumentMapping defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCall[JavaMethodDescriptor]

'argument' @ [39:70] ==> value-parameter argument: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.resolve.calls.callUtil.noErrorsInValueArguments.<anonymous>[ValueParameterDescriptorImpl]

'isError' @ [39:82] ==> public abstract fun isError(): Boolean defined in org.jetbrains.kotlin.resolve.calls.model.ArgumentMapping[SimpleFunctionDescriptorImpl]

'call' @ [43:12] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<D>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> D

'valueArguments' @ [43:17] ==> public final val Call.valueArguments: List<(ValueArgument..ValueArgument?)>[MyPropertyDescriptor]

'any' @ [43:32] ==> public inline fun <T> Iterable<(ValueArgument..ValueArgument?)>.any(predicate: ((ValueArgument..ValueArgument?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)

'getArgumentMapping' @ [43:50] ==> @NotNull public abstract fun getArgumentMapping(@NotNull valueArgument: ValueArgument): ArgumentMapping defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCall[JavaMethodDescriptor]

'argument' @ [43:69] ==> value-parameter argument: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.resolve.calls.callUtil.hasUnmappedArguments.<anonymous>[ValueParameterDescriptorImpl]

'ArgumentUnmapped' @ [43:84] ==> public object ArgumentUnmapped : ArgumentMapping defined in org.jetbrains.kotlin.resolve.calls.model in file ArgumentMapping.kt[FakeCallableDescriptorForObject]

'valueArguments' @ [47:34] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<D>.valueArguments: (MutableMap<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>..Map<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> D

'!' @ [48:12] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'parameterToArgumentMap' @ [48:13] ==> val parameterToArgumentMap: (MutableMap<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>..Map<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>) defined in org.jetbrains.kotlin.resolve.calls.callUtil.hasUnmappedParameters[LocalVariableDescriptor]

'keys' @ [48:36] ==> public abstract val keys: MutableSet<(ValueParameterDescriptor..ValueParameterDescriptor?)> defined in kotlin.collections.MutableMap[DeserializedPropertyDescriptor]

'containsAll' @ [48:41] ==> public abstract fun containsAll(elements: Collection<(ValueParameterDescriptor..ValueParameterDescriptor?)>): Boolean defined in kotlin.collections.MutableSet[DeserializedSimpleFunctionDescriptor]

'resultingDescriptor' @ [48:53] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<D>.resultingDescriptor: D[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> D

'valueParameters' @ [48:73] ==> public final val CallableDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'call' @ [52:11] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<D>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> D

'valueArguments' @ [52:16] ==> public final val Call.valueArguments: List<(ValueArgument..ValueArgument?)>[MyPropertyDescriptor]

'all' @ [52:31] ==> public inline fun <T> Iterable<(ValueArgument..ValueArgument?)>.all(predicate: ((ValueArgument..ValueArgument?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)

'getArgumentMapping' @ [52:49] ==> @NotNull public abstract fun getArgumentMapping(@NotNull valueArgument: ValueArgument): ArgumentMapping defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCall[JavaMethodDescriptor]

'argument' @ [52:68] ==> value-parameter argument: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.resolve.calls.callUtil.allArgumentsMapped.<anonymous>[ValueParameterDescriptorImpl]

'valueArguments' @ [55:33] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<D>.valueArguments: (MutableMap<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>..Map<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> D

'parameter' @ [55:48] ==> value-parameter parameter: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.callUtil.hasTypeMismatchErrorOnParameter[ValueParameterDescriptorImpl]

'resolvedValueArgument' @ [56:9] ==> val resolvedValueArgument: ResolvedValueArgument? defined in org.jetbrains.kotlin.resolve.calls.callUtil.hasTypeMismatchErrorOnParameter[LocalVariableDescriptor]

'resolvedValueArgument' @ [58:12] ==> val resolvedValueArgument: ResolvedValueArgument? defined in org.jetbrains.kotlin.resolve.calls.callUtil.hasTypeMismatchErrorOnParameter[LocalVariableDescriptor]

'arguments' @ [58:34] ==> public final val ResolvedValueArgument.arguments: (MutableList<(ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>)[MyPropertyDescriptor]

'any' @ [58:44] ==> public inline fun <T> Iterable<(ValueArgument..ValueArgument?)>.any(predicate: ((ValueArgument..ValueArgument?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)

'getArgumentMapping' @ [59:31] ==> @NotNull public abstract fun getArgumentMapping(@NotNull valueArgument: ValueArgument): ArgumentMapping defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCall[JavaMethodDescriptor]

'argument' @ [59:50] ==> value-parameter argument: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.resolve.calls.callUtil.hasTypeMismatchErrorOnParameter.<anonymous>[ValueParameterDescriptorImpl]

'argumentMapping' @ [60:9] ==> val argumentMapping: ArgumentMapping defined in org.jetbrains.kotlin.resolve.calls.callUtil.hasTypeMismatchErrorOnParameter.<anonymous>[LocalVariableDescriptor]

'argumentMapping' @ [60:45] ==> val argumentMapping: ArgumentMapping defined in org.jetbrains.kotlin.resolve.calls.callUtil.hasTypeMismatchErrorOnParameter.<anonymous>[LocalVariableDescriptor]

'status' @ [60:61] ==> public abstract val status: ArgumentMatchStatus defined in org.jetbrains.kotlin.resolve.calls.model.ArgumentMatch[PropertyDescriptorImpl]

'TYPE_MISMATCH' @ [60:91] ==> enum entry TYPE_MISMATCH defined in org.jetbrains.kotlin.resolve.calls.model.ArgumentMatchStatus[FakeCallableDescriptorForObject]

'valueArgument' @ [65:13] ==> value-parameter valueArgument: ValueArgument? defined in org.jetbrains.kotlin.resolve.calls.callUtil.getParameterForArgument[ValueParameterDescriptorImpl]

'let' @ [65:28] ==> @InlineOnly public inline fun <T, R> ValueArgument.let(block: (ValueArgument) -> ArgumentMapping): ArgumentMapping defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ValueArgument
    <R> -> ArgumentMapping

'getArgumentMapping' @ [65:34] ==> @NotNull public abstract fun getArgumentMapping(@NotNull valueArgument: ValueArgument): ArgumentMapping defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCall[JavaMethodDescriptor]

'it' @ [65:53] ==> value-parameter it: ValueArgument defined in org.jetbrains.kotlin.resolve.calls.callUtil.getParameterForArgument.<anonymous>[ValueParameterDescriptorImpl]

'valueParameter' @ [65:79] ==> public abstract val valueParameter: ValueParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.model.ArgumentMatch[PropertyDescriptorImpl]

'valueArgumentsByIndex' @ [69:12] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<D>.valueArgumentsByIndex: (MutableList<(ResolvedValueArgument..ResolvedValueArgument?)>?..List<(ResolvedValueArgument..ResolvedValueArgument?)>?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> D

'any' @ [69:35] ==> public inline fun <T> Iterable<(ResolvedValueArgument..ResolvedValueArgument?)>.any(predicate: ((ResolvedValueArgument..ResolvedValueArgument?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument..org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument?)

'it' @ [69:41] ==> value-parameter it: (ResolvedValueArgument..ResolvedValueArgument?) defined in org.jetbrains.kotlin.resolve.calls.callUtil.usesDefaultArguments.<anonymous>[ValueParameterDescriptorImpl]

'valueArguments' @ [76:21] ==> public final val Call.valueArguments: List<(ValueArgument..ValueArgument?)>[MyPropertyDescriptor]

'map' @ [76:36] ==> public inline fun <T, R> Iterable<(ValueArgument..ValueArgument?)>.map(transform: ((ValueArgument..ValueArgument?)) -> KtExpression?): List<KtExpression?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)
    <R> -> KtExpression?

'it' @ [76:42] ==> value-parameter it: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.resolve.calls.callUtil.hasUnresolvedArguments.<anonymous>[ValueParameterDescriptorImpl]

'getArgumentExpression' @ [76:45] ==> @IfNotParsed public abstract fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.ValueArgument[SimpleFunctionDescriptorImpl]

'arguments' @ [77:12] ==> val arguments: List<KtExpression?> defined in org.jetbrains.kotlin.resolve.calls.callUtil.hasUnresolvedArguments[LocalVariableDescriptor]

'any' @ [77:22] ==> public inline fun <T> Iterable<KtExpression?>.any(predicate: (KtExpression?) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression?

'argument' @ [78:13] ==> value-parameter argument: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.callUtil.hasUnresolvedArguments.<no name provided>[ValueParameterDescriptorImpl]

'isFunctionLiteralArgument' @ [78:54] ==> public open fun isFunctionLiteralArgument(@NotNull expression: KtExpression, @NotNull context: raw (ResolutionContext<(ResolutionContext<*>..ResolutionContext<*>?)>..ResolutionContext<out (ResolutionContext<*>..ResolutionContext<*>?)>)): Boolean defined in org.jetbrains.kotlin.resolve.calls.ArgumentTypeResolver[JavaMethodDescriptor]

'argument' @ [78:80] ==> value-parameter argument: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.callUtil.hasUnresolvedArguments.<no name provided>[ValueParameterDescriptorImpl]

'context' @ [78:90] ==> value-parameter context: ResolutionContext<C> defined in org.jetbrains.kotlin.resolve.calls.callUtil.hasUnresolvedArguments[ValueParameterDescriptorImpl]

'argument' @ [80:28] ==> value-parameter argument: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.callUtil.hasUnresolvedArguments.<no name provided>[ValueParameterDescriptorImpl]

'getResolvedCall' @ [80:37] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[SimpleFunctionDescriptorImpl]

'context' @ [80:53] ==> value-parameter context: ResolutionContext<C> defined in org.jetbrains.kotlin.resolve.calls.callUtil.hasUnresolvedArguments[ValueParameterDescriptorImpl]

'trace' @ [80:61] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'bindingContext' @ [80:67] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'resolvedCall' @ [81:13] ==> val resolvedCall: MutableResolvedCall<*>? defined in org.jetbrains.kotlin.resolve.calls.callUtil.hasUnresolvedArguments.<no name provided>[LocalVariableDescriptor]

'!' @ [81:37] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'resolvedCall' @ [81:38] ==> val resolvedCall: MutableResolvedCall<*>? defined in org.jetbrains.kotlin.resolve.calls.callUtil.hasUnresolvedArguments.<no name provided>[LocalVariableDescriptor]

'hasInferredReturnType' @ [81:51] ==> public abstract fun hasInferredReturnType(): Boolean defined in org.jetbrains.kotlin.resolve.calls.model.MutableResolvedCall[JavaMethodDescriptor]

'context' @ [83:30] ==> value-parameter context: ResolutionContext<C> defined in org.jetbrains.kotlin.resolve.calls.callUtil.hasUnresolvedArguments[ValueParameterDescriptorImpl]

'trace' @ [83:38] ==> @NotNull public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.context.ResolutionContext[JavaPropertyDescriptor]

'bindingContext' @ [83:44] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'getType' @ [83:59] ==> @Nullable public abstract fun getType(@NotNull expression: KtExpression): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]

'argument' @ [83:67] ==> value-parameter argument: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.callUtil.hasUnresolvedArguments.<no name provided>[ValueParameterDescriptorImpl]

'expressionType' @ [84:16] ==> val expressionType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.callUtil.hasUnresolvedArguments.<no name provided>[LocalVariableDescriptor]

'expressionType' @ [84:42] ==> val expressionType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.callUtil.hasUnresolvedArguments.<no name provided>[LocalVariableDescriptor]

'isError' @ [84:57] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types[DeserializedPropertyDescriptor]

'valueArguments' @ [88:66] ==> public final val Call.valueArguments: List<(ValueArgument..ValueArgument?)>[MyPropertyDescriptor]

'filterArgsInParentheses' @ [88:81] ==> @Suppress private fun List<ValueArgument?>.filterArgsInParentheses(): List<ValueArgument> defined in org.jetbrains.kotlin.resolve.calls.callUtil[SimpleFunctionDescriptorImpl]

'valueArguments' @ [90:75] ==> public final val KtCallElement.valueArguments: (MutableList<out (ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>)[MyPropertyDescriptor]

'filterArgsInParentheses' @ [90:90] ==> @Suppress private fun List<ValueArgument?>.filterArgsInParentheses(): List<ValueArgument> defined in org.jetbrains.kotlin.resolve.calls.callUtil[SimpleFunctionDescriptorImpl]

'if (this is CallTransformer.CallForImplicitInvoke) {
            outerCall.getValueArgumentListOrElement()
        }
        else {
            valueArgumentList ?: calleeExpression ?: callElement
        }' @ [93:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtElement, elseBranch: KtElement): KtElement[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtElement

'this' @ [93:13] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getValueArgumentListOrElement[ReceiverParameterDescriptorImpl]

'outerCall' @ [94:13] ==> public final val CallTransformer.CallForImplicitInvoke.outerCall: Call[MyPropertyDescriptor]

'getValueArgumentListOrElement' @ [94:23] ==> public fun Call.getValueArgumentListOrElement(): KtElement defined in org.jetbrains.kotlin.resolve.calls.callUtil in file callUtil.kt[SimpleFunctionDescriptorImpl]

'valueArgumentList' @ [97:13] ==> public final val Call.valueArgumentList: KtValueArgumentList?[MyPropertyDescriptor]

'calleeExpression' @ [97:34] ==> public final val Call.calleeExpression: KtExpression?[MyPropertyDescriptor]

'callElement' @ [97:54] ==> public final val Call.callElement: KtElement[MyPropertyDescriptor]

'Suppress' @ [100:1] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'filter' @ [101:62] ==> public inline fun <T> Iterable<ValueArgument?>.filter(predicate: (ValueArgument?) -> Boolean): List<ValueArgument?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ValueArgument?

'it' @ [101:71] ==> value-parameter it: ValueArgument? defined in org.jetbrains.kotlin.resolve.calls.callUtil.filterArgsInParentheses.<anonymous>[ValueParameterDescriptorImpl]

'if (this is KtExpression) KtPsiUtil.deparenthesizeOnce(this) else this' @ [105:31] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtElement?, elseBranch: KtElement?): KtElement?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtElement?

'this' @ [105:35] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getValueArgumentForExpression.deparenthesizeStructurally[ReceiverParameterDescriptorImpl]

'deparenthesizeOnce' @ [105:67] ==> @Nullable public open fun deparenthesizeOnce(@Nullable expression: KtExpression?): KtExpression? defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'this' @ [105:86] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getValueArgumentForExpression.deparenthesizeStructurally[ReceiverParameterDescriptorImpl]

'this' @ [105:97] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getValueArgumentForExpression.deparenthesizeStructurally[ReceiverParameterDescriptorImpl]

'when {
            deparenthesized != this -> deparenthesized
            this is KtLambdaExpression -> this.functionLiteral
            this is KtFunctionLiteral -> this.bodyExpression
            else -> null
        }' @ [106:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KtElement?, entry1: KtElement?, entry2: KtElement?, entry3: KtElement?): KtElement?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KtElement?

'deparenthesized' @ [107:13] ==> val deparenthesized: KtElement? defined in org.jetbrains.kotlin.resolve.calls.callUtil.getValueArgumentForExpression.deparenthesizeStructurally[LocalVariableDescriptor]

'this' @ [107:32] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getValueArgumentForExpression.deparenthesizeStructurally[ReceiverParameterDescriptorImpl]

'deparenthesized' @ [107:40] ==> val deparenthesized: KtElement? defined in org.jetbrains.kotlin.resolve.calls.callUtil.getValueArgumentForExpression.deparenthesizeStructurally[LocalVariableDescriptor]

'this' @ [108:13] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getValueArgumentForExpression.deparenthesizeStructurally[ReceiverParameterDescriptorImpl]

'this' @ [108:43] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getValueArgumentForExpression.deparenthesizeStructurally[ReceiverParameterDescriptorImpl]

'functionLiteral' @ [108:48] ==> public final val KtLambdaExpression.functionLiteral: KtFunctionLiteral[MyPropertyDescriptor]

'this' @ [109:13] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getValueArgumentForExpression.deparenthesizeStructurally[ReceiverParameterDescriptorImpl]

'this' @ [109:42] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getValueArgumentForExpression.deparenthesizeStructurally[ReceiverParameterDescriptorImpl]

'bodyExpression' @ [109:47] ==> public final val KtFunctionLiteral.bodyExpression: KtBlockExpression?[MyPropertyDescriptor]

'generateSequence' @ [113:49] ==> @LowPriorityInOverloadResolution public fun <T : Any> generateSequence(seed: KtElement?, nextFunction: (KtElement) -> KtElement?): Sequence<KtElement> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> KtElement

'this' @ [113:66] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getValueArgumentForExpression.isParenthesizedExpression[ReceiverParameterDescriptorImpl]

'it' @ [113:74] ==> value-parameter it: KtElement defined in org.jetbrains.kotlin.resolve.calls.callUtil.getValueArgumentForExpression.isParenthesizedExpression.<anonymous>[ValueParameterDescriptorImpl]

'deparenthesizeStructurally' @ [113:77] ==> local final fun KtElement.deparenthesizeStructurally(): KtElement? defined in org.jetbrains.kotlin.resolve.calls.callUtil.getValueArgumentForExpression[SimpleFunctionDescriptorImpl]

'any' @ [113:108] ==> public inline fun <T> Sequence<KtElement>.any(predicate: (KtElement) -> Boolean): Boolean defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtElement

'it' @ [113:114] ==> value-parameter it: KtElement defined in org.jetbrains.kotlin.resolve.calls.callUtil.getValueArgumentForExpression.isParenthesizedExpression.<anonymous>[ValueParameterDescriptorImpl]

'expression' @ [113:120] ==> value-parameter expression: KtExpression defined in org.jetbrains.kotlin.resolve.calls.callUtil.getValueArgumentForExpression[ValueParameterDescriptorImpl]

'valueArguments' @ [114:12] ==> public final val Call.valueArguments: List<(ValueArgument..ValueArgument?)>[MyPropertyDescriptor]

'firstOrNull' @ [114:27] ==> public inline fun <T> Iterable<(ValueArgument..ValueArgument?)>.firstOrNull(predicate: ((ValueArgument..ValueArgument?)) -> Boolean): ValueArgument? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)

'it' @ [114:41] ==> value-parameter it: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.resolve.calls.callUtil.getValueArgumentForExpression.<anonymous>[ValueParameterDescriptorImpl]

'getArgumentExpression' @ [114:45] ==> @IfNotParsed public abstract fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.ValueArgument[SimpleFunctionDescriptorImpl]

'isParenthesizedExpression' @ [114:70] ==> local final fun KtElement.isParenthesizedExpression(): Boolean defined in org.jetbrains.kotlin.resolve.calls.callUtil.getValueArgumentForExpression[SimpleFunctionDescriptorImpl]

'if (this is KtExpression) KtPsiUtil.deparenthesize(this) else this' @ [120:19] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtElement?, elseBranch: KtElement?): KtElement?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtElement?

'this' @ [120:23] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCalleeExpressionIfAny[ReceiverParameterDescriptorImpl]

'deparenthesize' @ [120:55] ==> @Nullable public open fun deparenthesize(@Nullable expression: KtExpression?): KtExpression? defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'this' @ [120:70] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCalleeExpressionIfAny[ReceiverParameterDescriptorImpl]

'this' @ [120:81] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCalleeExpressionIfAny[ReceiverParameterDescriptorImpl]

'when (element) {
        is KtSimpleNameExpression -> element
        is KtCallElement -> element.calleeExpression
        is KtQualifiedExpression -> element.selectorExpression.getCalleeExpressionIfAny()
        is KtOperationExpression -> element.operationReference
        else -> null
    }' @ [121:12] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KtExpression?, entry1: KtExpression?, entry2: KtExpression?, entry3: KtExpression?, entry4: KtExpression?): KtExpression?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KtExpression?

'element' @ [121:18] ==> val element: KtElement? defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCalleeExpressionIfAny[LocalVariableDescriptor]

'element' @ [122:38] ==> val element: KtElement? defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCalleeExpressionIfAny[LocalVariableDescriptor]

'element' @ [123:29] ==> val element: KtElement? defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCalleeExpressionIfAny[LocalVariableDescriptor]

'calleeExpression' @ [123:37] ==> public final val KtCallElement.calleeExpression: KtExpression?[MyPropertyDescriptor]

'element' @ [124:37] ==> val element: KtElement? defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCalleeExpressionIfAny[LocalVariableDescriptor]

'selectorExpression' @ [124:45] ==> public open val selectorExpression: KtExpression? defined in org.jetbrains.kotlin.psi.KtQualifiedExpression[PropertyDescriptorImpl]

'getCalleeExpressionIfAny' @ [124:64] ==> public fun KtElement?.getCalleeExpressionIfAny(): KtExpression? defined in org.jetbrains.kotlin.resolve.calls.callUtil in file callUtil.kt[SimpleFunctionDescriptorImpl]

'element' @ [125:37] ==> val element: KtElement? defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCalleeExpressionIfAny[LocalVariableDescriptor]

'operationReference' @ [125:45] ==> public final val KtOperationExpression.operationReference: KtSimpleNameExpression[MyPropertyDescriptor]

'if (this is KtExpression) KtPsiUtil.deparenthesize(this) else this' @ [138:19] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtElement?, elseBranch: KtElement?): KtElement?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtElement?

'this' @ [138:23] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCall[ReceiverParameterDescriptorImpl]

'deparenthesize' @ [138:55] ==> @Nullable public open fun deparenthesize(@Nullable expression: KtExpression?): KtExpression? defined in org.jetbrains.kotlin.psi.KtPsiUtil[JavaMethodDescriptor]

'this' @ [138:70] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCall[ReceiverParameterDescriptorImpl]

'this' @ [138:81] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCall[ReceiverParameterDescriptorImpl]

'element' @ [139:9] ==> val element: KtElement? defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCall[LocalVariableDescriptor]

'element' @ [142:9] ==> val element: KtElement? defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCall[LocalVariableDescriptor]

'element' @ [142:37] ==> val element: KtElement? defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCall[LocalVariableDescriptor]

'calleeExpression' @ [142:45] ==> public final val KtCallElement.calleeExpression: KtExpression?[MyPropertyDescriptor]

'element' @ [144:18] ==> val element: KtElement? defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCall[LocalVariableDescriptor]

'parent' @ [144:26] ==> public final val KtElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'when (parent) {
        is KtInstanceExpressionWithLabel -> parent
        is KtUserType -> parent.parent.parent as? KtConstructorCalleeExpression
        else -> element.getCalleeExpressionIfAny()
    }' @ [145:36] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KtExpression?, entry1: KtExpression?, entry2: KtExpression?): KtExpression?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KtExpression?

'parent' @ [145:42] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCall[LocalVariableDescriptor]

'parent' @ [146:45] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCall[LocalVariableDescriptor]

'parent' @ [147:26] ==> val parent: (PsiElement..PsiElement?) defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCall[LocalVariableDescriptor]

'parent' @ [147:33] ==> public final val KtUserType.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'parent' @ [147:40] ==> public final val PsiElement.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'element' @ [148:17] ==> val element: KtElement? defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCall[LocalVariableDescriptor]

'getCalleeExpressionIfAny' @ [148:25] ==> public fun KtElement?.getCalleeExpressionIfAny(): KtExpression? defined in org.jetbrains.kotlin.resolve.calls.callUtil in file callUtil.kt[SimpleFunctionDescriptorImpl]

'reference' @ [150:9] ==> val reference: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCall[LocalVariableDescriptor]

'context' @ [151:16] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCall[ValueParameterDescriptorImpl]

'CALL' @ [151:24] ==> public final val CALL: (WritableSlice<(KtElement..KtElement?), (Call..Call?)>..WritableSlice<(KtElement..KtElement?), (Call..Call?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'reference' @ [151:30] ==> val reference: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCall[LocalVariableDescriptor]

'context' @ [153:12] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCall[ValueParameterDescriptorImpl]

'CALL' @ [153:20] ==> public final val CALL: (WritableSlice<(KtElement..KtElement?), (Call..Call?)>..WritableSlice<(KtElement..KtElement?), (Call..Call?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'element' @ [153:26] ==> val element: KtElement? defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCall[LocalVariableDescriptor]

'arrayOf' @ [157:31] ==> public inline fun <reified @PureReifiable T> arrayOf(vararg elements: Class<out KtElement>?): Array<Class<out KtElement>?> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified @PureReifiable T> -> Class<out KtElement>?

'java' @ [158:43] ==> public val <T> KClass<KtSimpleNameExpression>.java: Class<KtSimpleNameExpression> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtSimpleNameExpression

'java' @ [158:70] ==> public val <T> KClass<KtCallElement>.java: Class<KtCallElement> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtCallElement

'KtBinaryExpression' @ [158:76] ==> public constructor KtBinaryExpression(@NotNull node: ASTNode) defined in org.jetbrains.kotlin.psi.KtBinaryExpression[JavaClassConstructorDescriptor]

'java' @ [158:102] ==> public val <T> KClass<KtBinaryExpression>.java: Class<KtBinaryExpression> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtBinaryExpression

'KtUnaryExpression' @ [159:13] ==> public constructor KtUnaryExpression(node: (ASTNode..ASTNode?)) defined in org.jetbrains.kotlin.psi.KtUnaryExpression[JavaClassConstructorDescriptor]

'java' @ [159:38] ==> public val <T> KClass<KtUnaryExpression>.java: Class<KtUnaryExpression> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtUnaryExpression

'KtArrayAccessExpression' @ [159:44] ==> public constructor KtArrayAccessExpression(@NotNull node: ASTNode) defined in org.jetbrains.kotlin.psi.KtArrayAccessExpression[JavaClassConstructorDescriptor]

'java' @ [159:75] ==> public val <T> KClass<KtArrayAccessExpression>.java: Class<KtArrayAccessExpression> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> KtArrayAccessExpression

'if (strict) {
        PsiTreeUtil.getParentOfType(this, *callExpressionTypes)
    } else {
        PsiTreeUtil.getNonStrictParentOfType(this, *callExpressionTypes)
    }' @ [161:18] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtElement?, elseBranch: KtElement?): KtElement?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtElement?

'strict' @ [161:22] ==> value-parameter strict: Boolean = ... defined in org.jetbrains.kotlin.resolve.calls.callUtil.getParentCall[ValueParameterDescriptorImpl]

'getParentOfType' @ [162:21] ==> @SafeVarargs @Nullable @Contract public open fun <T : (PsiElement..PsiElement?)> getParentOfType(@Nullable p0: PsiElement?, @NotNull vararg p1: (Class<out (KtElement..KtElement?)>..Class<out (KtElement..KtElement?)>?)): KtElement? defined in com.intellij.psi.util.PsiTreeUtil[JavaMethodDescriptor]
Inferred types:
    <T : (PsiElement..PsiElement?)> -> KtElement

'this' @ [162:37] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getParentCall[ReceiverParameterDescriptorImpl]

'callExpressionTypes' @ [162:44] ==> val callExpressionTypes: Array<Class<out KtElement>?> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getParentCall[LocalVariableDescriptor]

'getNonStrictParentOfType' @ [164:21] ==> @SafeVarargs @Nullable @Contract public open fun <T : (PsiElement..PsiElement?)> getNonStrictParentOfType(@Nullable p0: PsiElement?, @NotNull vararg p1: (Class<out (KtElement..KtElement?)>..Class<out (KtElement..KtElement?)>?)): KtElement? defined in com.intellij.psi.util.PsiTreeUtil[JavaMethodDescriptor]
Inferred types:
    <T : (PsiElement..PsiElement?)> -> KtElement

'this' @ [164:46] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getParentCall[ReceiverParameterDescriptorImpl]

'callExpressionTypes' @ [164:53] ==> val callExpressionTypes: Array<Class<out KtElement>?> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getParentCall[LocalVariableDescriptor]

'parent' @ [166:12] ==> val parent: KtElement? defined in org.jetbrains.kotlin.resolve.calls.callUtil.getParentCall[LocalVariableDescriptor]

'getCall' @ [166:20] ==> public fun KtElement.getCall(context: BindingContext): Call? defined in org.jetbrains.kotlin.resolve.calls.callUtil in file callUtil.kt[SimpleFunctionDescriptorImpl]

'context' @ [166:28] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.calls.callUtil.getParentCall[ValueParameterDescriptorImpl]

'context' @ [170:12] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCall[ValueParameterDescriptorImpl]

'RESOLVED_CALL' @ [170:20] ==> public final val RESOLVED_CALL: (WritableSlice<(Call..Call?), (ResolvedCall<*>..ResolvedCall<*>?)>..WritableSlice<(Call..Call?), (ResolvedCall<*>..ResolvedCall<*>?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'this' @ [170:35] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCall[ReceiverParameterDescriptorImpl]

'this' @ [174:12] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCall[ReceiverParameterDescriptorImpl]

'getCall' @ [174:18] ==> public fun KtElement.getCall(context: BindingContext): Call? defined in org.jetbrains.kotlin.resolve.calls.callUtil in file callUtil.kt[SimpleFunctionDescriptorImpl]

'context' @ [174:26] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCall[ValueParameterDescriptorImpl]

'getResolvedCall' @ [174:36] ==> public fun Call?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[SimpleFunctionDescriptorImpl]

'context' @ [174:52] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCall[ValueParameterDescriptorImpl]

'this' @ [178:12] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getParentResolvedCall[ReceiverParameterDescriptorImpl]

'getParentCall' @ [178:18] ==> public fun KtElement.getParentCall(context: BindingContext, strict: Boolean = ...): Call? defined in org.jetbrains.kotlin.resolve.calls.callUtil in file callUtil.kt[SimpleFunctionDescriptorImpl]

'context' @ [178:32] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.calls.callUtil.getParentResolvedCall[ValueParameterDescriptorImpl]

'strict' @ [178:41] ==> value-parameter strict: Boolean = ... defined in org.jetbrains.kotlin.resolve.calls.callUtil.getParentResolvedCall[ValueParameterDescriptorImpl]

'getResolvedCall' @ [178:50] ==> public fun Call?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[SimpleFunctionDescriptorImpl]

'context' @ [178:66] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.calls.callUtil.getParentResolvedCall[ValueParameterDescriptorImpl]

'getCall' @ [182:12] ==> public fun KtElement.getCall(context: BindingContext): Call? defined in org.jetbrains.kotlin.resolve.calls.callUtil in file callUtil.kt[SimpleFunctionDescriptorImpl]

'context' @ [182:20] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCallWithAssert[ValueParameterDescriptorImpl]

'sure' @ [182:29] ==> public inline fun <T : Any> Call?.sure(message: () -> String): Call defined in org.jetbrains.kotlin.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> Call

'this' @ [182:51] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getCallWithAssert[ReceiverParameterDescriptorImpl]

'getTextWithLocation' @ [182:56] ==> public fun PsiElement.getTextWithLocation(): String defined in org.jetbrains.kotlin.psi.psiUtil in file psiUtils.kt[SimpleFunctionDescriptorImpl]

'getResolvedCall' @ [186:12] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[SimpleFunctionDescriptorImpl]

'context' @ [186:28] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCallWithAssert[ValueParameterDescriptorImpl]

'sure' @ [186:37] ==> public inline fun <T : Any> ResolvedCall<out CallableDescriptor>?.sure(message: () -> String): ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> ResolvedCall<out CallableDescriptor>

'this' @ [186:68] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCallWithAssert[ReceiverParameterDescriptorImpl]

'getTextWithLocation' @ [186:73] ==> public fun PsiElement.getTextWithLocation(): String defined in org.jetbrains.kotlin.psi.psiUtil in file psiUtils.kt[SimpleFunctionDescriptorImpl]

'getResolvedCall' @ [190:12] ==> public fun Call?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[SimpleFunctionDescriptorImpl]

'context' @ [190:28] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCallWithAssert[ValueParameterDescriptorImpl]

'sure' @ [190:37] ==> public inline fun <T : Any> ResolvedCall<out CallableDescriptor>?.sure(message: () -> String): ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> ResolvedCall<out CallableDescriptor>

'this' @ [190:68] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCallWithAssert[ReceiverParameterDescriptorImpl]

'callElement' @ [190:73] ==> public final val Call.callElement: KtElement[MyPropertyDescriptor]

'getTextWithLocation' @ [190:85] ==> public fun PsiElement.getTextWithLocation(): String defined in org.jetbrains.kotlin.psi.psiUtil in file psiUtils.kt[SimpleFunctionDescriptorImpl]

'getResolvedCallWithAssert' @ [194:24] ==> public fun KtElement.getResolvedCallWithAssert(context: BindingContext): ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.callUtil[SimpleFunctionDescriptorImpl]

'context' @ [194:50] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.calls.callUtil.getFunctionResolvedCallWithAssert[ValueParameterDescriptorImpl]

'assert' @ [195:5] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'resolvedCall' @ [195:12] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getFunctionResolvedCallWithAssert[LocalVariableDescriptor]

'resultingDescriptor' @ [195:25] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.resultingDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'this' @ [196:97] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getFunctionResolvedCallWithAssert[ReceiverParameterDescriptorImpl]

'getTextWithLocation' @ [196:102] ==> public fun PsiElement.getTextWithLocation(): String defined in org.jetbrains.kotlin.psi.psiUtil in file psiUtils.kt[SimpleFunctionDescriptorImpl]

'Suppress' @ [198:5] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'resolvedCall' @ [199:12] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getFunctionResolvedCallWithAssert[LocalVariableDescriptor]

'getResolvedCallWithAssert' @ [203:24] ==> public fun KtElement.getResolvedCallWithAssert(context: BindingContext): ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.callUtil[SimpleFunctionDescriptorImpl]

'context' @ [203:50] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.calls.callUtil.getPropertyResolvedCallWithAssert[ValueParameterDescriptorImpl]

'assert' @ [204:5] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'resolvedCall' @ [204:12] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getPropertyResolvedCallWithAssert[LocalVariableDescriptor]

'resultingDescriptor' @ [204:25] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.resultingDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'this' @ [205:97] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getPropertyResolvedCallWithAssert[ReceiverParameterDescriptorImpl]

'getTextWithLocation' @ [205:102] ==> public fun PsiElement.getTextWithLocation(): String defined in org.jetbrains.kotlin.psi.psiUtil in file psiUtils.kt[SimpleFunctionDescriptorImpl]

'Suppress' @ [207:5] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'resolvedCall' @ [208:12] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getPropertyResolvedCallWithAssert[LocalVariableDescriptor]

'getResolvedCallWithAssert' @ [212:24] ==> public fun KtElement.getResolvedCallWithAssert(context: BindingContext): ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.callUtil[SimpleFunctionDescriptorImpl]

'context' @ [212:50] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.calls.callUtil.getVariableResolvedCallWithAssert[ValueParameterDescriptorImpl]

'assert' @ [213:5] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'resolvedCall' @ [213:12] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getVariableResolvedCallWithAssert[LocalVariableDescriptor]

'resultingDescriptor' @ [213:25] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.resultingDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> CallableDescriptor

'this' @ [214:97] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getVariableResolvedCallWithAssert[ReceiverParameterDescriptorImpl]

'getTextWithLocation' @ [214:102] ==> public fun PsiElement.getTextWithLocation(): String defined in org.jetbrains.kotlin.psi.psiUtil in file psiUtils.kt[SimpleFunctionDescriptorImpl]

'Suppress' @ [216:5] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'resolvedCall' @ [217:12] ==> val resolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getVariableResolvedCallWithAssert[LocalVariableDescriptor]

'context' @ [221:16] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.calls.callUtil.getType[ValueParameterDescriptorImpl]

'getType' @ [221:24] ==> @Nullable public abstract fun getType(@NotNull expression: KtExpression): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]

'this' @ [221:32] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getType[ReceiverParameterDescriptorImpl]

'type' @ [222:9] ==> val type: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.callUtil.getType[LocalVariableDescriptor]

'type' @ [222:30] ==> val type: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.callUtil.getType[LocalVariableDescriptor]

'this' @ [223:24] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.getType[ReceiverParameterDescriptorImpl]

'getResolvedCall' @ [223:29] ==> public fun KtElement?.getResolvedCall(context: BindingContext): ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil[SimpleFunctionDescriptorImpl]

'context' @ [223:45] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.calls.callUtil.getType[ValueParameterDescriptorImpl]

'resolvedCall' @ [224:9] ==> val resolvedCall: ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil.getType[LocalVariableDescriptor]

'resolvedCall' @ [225:16] ==> val resolvedCall: ResolvedCall<out CallableDescriptor>? defined in org.jetbrains.kotlin.resolve.calls.callUtil.getType[LocalVariableDescriptor]

'variableCall' @ [225:29] ==> public abstract val variableCall: ResolvedCall<VariableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.model.VariableAsFunctionResolvedCall[PropertyDescriptorImpl]

'resultingDescriptor' @ [225:42] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<VariableDescriptor>.resultingDescriptor: VariableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> VariableDescriptor

'type' @ [225:62] ==> public final val VariableDescriptor.type: KotlinType[MyPropertyDescriptor]

'containingFile' @ [233:20] ==> public final val KtElement.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'file' @ [234:16] ==> val file: (PsiFile..PsiFile?) defined in org.jetbrains.kotlin.resolve.calls.callUtil.<get-isFakeElement>[LocalVariableDescriptor]

'file' @ [234:34] ==> val file: (PsiFile..PsiFile?) defined in org.jetbrains.kotlin.resolve.calls.callUtil.<get-isFakeElement>[LocalVariableDescriptor]

'doNotAnalyze' @ [234:39] ==> public var KtFile.doNotAnalyze: String? defined in org.jetbrains.kotlin.psi in file KtPsiFactory.kt[PropertyDescriptorImpl]

'this' @ [238:9] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.callUtil.isSafeCall[ReceiverParameterDescriptorImpl]

'outerCall' @ [240:13] ==> public final val CallTransformer.CallForImplicitInvoke.outerCall: Call[MyPropertyDescriptor]

'isExplicitSafeCall' @ [240:23] ==> public fun Call.isExplicitSafeCall(): Boolean defined in org.jetbrains.kotlin.resolve.calls.callUtil in file callUtil.kt[SimpleFunctionDescriptorImpl]

'isExplicitSafeCall' @ [244:12] ==> public fun Call.isExplicitSafeCall(): Boolean defined in org.jetbrains.kotlin.resolve.calls.callUtil in file callUtil.kt[SimpleFunctionDescriptorImpl]

'callOperationNode' @ [247:42] ==> public final val Call.callOperationNode: ASTNode?[MyPropertyDescriptor]

'elementType' @ [247:61] ==> public final val ASTNode.elementType: IElementType[MyPropertyDescriptor]

'SAFE_ACCESS' @ [247:85] ==> public final val SAFE_ACCESS: (KtSingleValueToken..KtSingleValueToken?) defined in org.jetbrains.kotlin.lexer.KtTokens[JavaPropertyDescriptor]

'callElement' @ [250:23] ==> public final val Call.callElement: KtElement[MyPropertyDescriptor]

'callElement' @ [251:12] ==> val callElement: KtElement defined in org.jetbrains.kotlin.resolve.calls.callUtil.isCallableReference[LocalVariableDescriptor]

'==' @ [252:12] ==> public open fun equals(other: Any?): Boolean defined in org.jetbrains.kotlin.psi.KtSimpleNameExpression[DeserializedSimpleFunctionDescriptor]

'callElement' @ [252:13] ==> val callElement: KtElement defined in org.jetbrains.kotlin.resolve.calls.callUtil.isCallableReference[LocalVariableDescriptor]

'parent' @ [252:25] ==> public final val KtNameReferenceExpression.parent: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'callableReference' @ [252:68] ==> public final val KtCallableReferenceExpression.callableReference: KtSimpleNameExpression[MyPropertyDescriptor]

'callElement' @ [252:89] ==> val callElement: KtElement defined in org.jetbrains.kotlin.resolve.calls.callUtil.isCallableReference[LocalVariableDescriptor]

'calleeExpression' @ [256:28] ==> public final val Call.calleeExpression: KtExpression?[MyPropertyDescriptor]

'if (calleeExpression != null && !calleeExpression.isFakeElement) calleeExpression
            else callElement' @ [258:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtElement, elseBranch: KtElement): KtElement[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtElement

'calleeExpression' @ [258:17] ==> val calleeExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.callUtil.createLookupLocation[LocalVariableDescriptor]

'!' @ [258:45] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'calleeExpression' @ [258:46] ==> val calleeExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.callUtil.createLookupLocation[LocalVariableDescriptor]

'isFakeElement' @ [258:63] ==> public val KtElement.isFakeElement: Boolean defined in org.jetbrains.kotlin.resolve.calls.callUtil in file callUtil.kt[PropertyDescriptorImpl]

'calleeExpression' @ [258:78] ==> val calleeExpression: KtExpression? defined in org.jetbrains.kotlin.resolve.calls.callUtil.createLookupLocation[LocalVariableDescriptor]

'callElement' @ [259:18] ==> public final val Call.callElement: KtElement[MyPropertyDescriptor]

'KotlinLookupLocation' @ [260:12] ==> public constructor KotlinLookupLocation(element: KtElement) defined in org.jetbrains.kotlin.incremental.KotlinLookupLocation[ClassConstructorDescriptorImpl]

'element' @ [260:33] ==> val element: KtElement defined in org.jetbrains.kotlin.resolve.calls.callUtil.createLookupLocation[LocalVariableDescriptor]

