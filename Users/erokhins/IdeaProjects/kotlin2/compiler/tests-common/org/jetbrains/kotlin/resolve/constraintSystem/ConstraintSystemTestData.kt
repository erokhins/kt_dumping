'context' @ [46:25] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData.<init>[ValueParameterDescriptorImpl]

'getSliceContents' @ [46:33] ==> @NotNull public abstract fun <K : (Any..Any?), V : (Any..Any?)> getSliceContents(@NotNull p0: ReadOnlySlice<(PsiElement..PsiElement?), (SimpleFunctionDescriptor..SimpleFunctionDescriptor?)>): ImmutableMap<(PsiElement..PsiElement?), (SimpleFunctionDescriptor..SimpleFunctionDescriptor?)> defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (com.intellij.psi.PsiElement..com.intellij.psi.PsiElement?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.descriptors.SimpleFunctionDescriptor..org.jetbrains.kotlin.descriptors.SimpleFunctionDescriptor?)

'FUNCTION' @ [46:65] ==> public final val FUNCTION: (WritableSlice<(PsiElement..PsiElement?), (SimpleFunctionDescriptor..SimpleFunctionDescriptor?)>..WritableSlice<(PsiElement..PsiElement?), (SimpleFunctionDescriptor..SimpleFunctionDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'functionFoo' @ [47:9] ==> private final val functionFoo: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData[PropertyDescriptorImpl]

'findFunctionByName' @ [47:23] ==> private final fun findFunctionByName(functions: Collection<FunctionDescriptor>, name: String): FunctionDescriptor defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData[SimpleFunctionDescriptorImpl]

'functions' @ [47:42] ==> val functions: ImmutableMap<(PsiElement..PsiElement?), (SimpleFunctionDescriptor..SimpleFunctionDescriptor?)> defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData.<init>[LocalVariableDescriptor]

'values' @ [47:52] ==> public open val values: ImmutableCollection<(SimpleFunctionDescriptor..SimpleFunctionDescriptor?)> defined in com.google.common.collect.ImmutableMap[JavaPropertyDescriptor]

'DescriptorToSourceUtils' @ [48:24] ==> public object DescriptorToSourceUtils defined in org.jetbrains.kotlin.resolve[FakeCallableDescriptorForObject]

'descriptorToDeclaration' @ [48:48] ==> @JvmStatic public final fun descriptorToDeclaration(descriptor: DeclarationDescriptor): PsiElement? defined in org.jetbrains.kotlin.resolve.DescriptorToSourceUtils[DeserializedSimpleFunctionDescriptor]

'functionFoo' @ [48:72] ==> private final val functionFoo: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData[PropertyDescriptorImpl]

'function' @ [49:23] ==> val function: KtFunction defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData.<init>[LocalVariableDescriptor]

'bodyExpression' @ [49:32] ==> public final val KtFunction.bodyExpression: KtExpression?[MyPropertyDescriptor]

'scopeToResolveTypeParameters' @ [50:9] ==> private final val scopeToResolveTypeParameters: LexicalScope defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData[PropertyDescriptorImpl]

'context' @ [50:40] ==> value-parameter context: BindingContext defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData.<init>[ValueParameterDescriptorImpl]

'get' @ [50:48] ==> @Nullable public abstract operator fun <K : (Any..Any?), V : (Any..Any?)> get(p0: (ReadOnlySlice<(KtElement..KtElement?), (LexicalScope..LexicalScope?)>..ReadOnlySlice<(KtElement..KtElement?), (LexicalScope..LexicalScope?)>?), p1: (KtElement..KtElement?)): LexicalScope? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.psi.KtElement..org.jetbrains.kotlin.psi.KtElement?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.resolve.scopes.LexicalScope..org.jetbrains.kotlin.resolve.scopes.LexicalScope?)

'LEXICAL_SCOPE' @ [50:67] ==> public final val LEXICAL_SCOPE: (WritableSlice<(KtElement..KtElement?), (LexicalScope..LexicalScope?)>..WritableSlice<(KtElement..KtElement?), (LexicalScope..LexicalScope?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'fooBody' @ [50:82] ==> val fooBody: KtExpression? defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData.<init>[LocalVariableDescriptor]

'functions' @ [54:16] ==> value-parameter functions: Collection<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData.findFunctionByName[ValueParameterDescriptorImpl]

'firstOrNull' @ [54:26] ==> public inline fun <T> Iterable<FunctionDescriptor>.firstOrNull(predicate: (FunctionDescriptor) -> Boolean): FunctionDescriptor? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FunctionDescriptor

'it' @ [54:40] ==> value-parameter it: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData.findFunctionByName.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [54:43] ==> public final val FunctionDescriptor.name: Name[MyPropertyDescriptor]

'asString' @ [54:48] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'name' @ [54:62] ==> value-parameter name: String defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData.findFunctionByName[ValueParameterDescriptorImpl]

'AssertionError' @ [55:22] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'name' @ [55:49] ==> value-parameter name: String defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData.findFunctionByName[ValueParameterDescriptorImpl]

'functionFoo' @ [59:16] ==> private final val functionFoo: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData[PropertyDescriptorImpl]

'typeParameters' @ [59:28] ==> public final val FunctionDescriptor.typeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'firstOrNull' @ [59:43] ==> public inline fun <T> Iterable<(TypeParameterDescriptor..TypeParameterDescriptor?)>.firstOrNull(predicate: ((TypeParameterDescriptor..TypeParameterDescriptor?)) -> Boolean): TypeParameterDescriptor? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)

'it' @ [59:57] ==> value-parameter it: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData.getParameterDescriptor.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [59:60] ==> public final val TypeParameterDescriptor.name: Name[MyPropertyDescriptor]

'asString' @ [59:65] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'name' @ [59:79] ==> value-parameter name: String defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData.getParameterDescriptor[ValueParameterDescriptorImpl]

'AssertionError' @ [60:22] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'name' @ [60:72] ==> value-parameter name: String defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData.getParameterDescriptor[ValueParameterDescriptorImpl]

'INTEGER_VALUE_TYPE_PATTERN' @ [64:23] ==> private val INTEGER_VALUE_TYPE_PATTERN: (Pattern..Pattern?) defined in org.jetbrains.kotlin.resolve.constraintSystem in file ConstraintSystemTestData.kt[PropertyDescriptorImpl]

'matcher' @ [64:50] ==> public open fun matcher(p0: (CharSequence..CharSequence?)): (Matcher..Matcher?) defined in java.util.regex.Pattern[JavaMethodDescriptor]

'name' @ [64:58] ==> value-parameter name: String defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData.getType[ValueParameterDescriptorImpl]

'matcher' @ [65:13] ==> val matcher: (Matcher..Matcher?) defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData.getType[LocalVariableDescriptor]

'find' @ [65:21] ==> public open fun find(): Boolean defined in java.util.regex.Matcher[JavaMethodDescriptor]

'matcher' @ [66:26] ==> val matcher: (Matcher..Matcher?) defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData.getType[LocalVariableDescriptor]

'group' @ [66:34] ==> public open fun group(p0: Int): (String..String?) defined in java.util.regex.Matcher[JavaMethodDescriptor]

'KotlinTypeFactory' @ [67:20] ==> public object KotlinTypeFactory defined in org.jetbrains.kotlin.types[FakeCallableDescriptorForObject]

'simpleType' @ [67:38] ==> @JvmStatic public final fun simpleType(annotations: Annotations, constructor: TypeConstructor, arguments: List<TypeProjection>, nullable: Boolean, memberScope: MemberScope): SimpleType defined in org.jetbrains.kotlin.types.KotlinTypeFactory[DeserializedSimpleFunctionDescriptor]

'EMPTY' @ [67:61] ==> public final val EMPTY: Annotations defined in org.jetbrains.kotlin.descriptors.annotations.Annotations.Companion[DeserializedPropertyDescriptor]

'IntegerValueTypeConstructor' @ [67:68] ==> public constructor IntegerValueTypeConstructor(value: Long, builtIns: KotlinBuiltIns) defined in org.jetbrains.kotlin.resolve.constants.IntegerValueTypeConstructor[DeserializedClassConstructorDescriptor]

'number' @ [67:96] ==> val number: String defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData.getType[LocalVariableDescriptor]

'toLong' @ [67:103] ==> @InlineOnly public inline fun String.toLong(): Long defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'functionFoo' @ [67:113] ==> private final val functionFoo: FunctionDescriptor defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData[PropertyDescriptorImpl]

'builtIns' @ [67:125] ==> public val DeclarationDescriptor.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'listOf' @ [68:49] ==> @InlineOnly public inline fun <T> listOf(): List<TypeProjection> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection

'Empty' @ [68:78] ==> public object Empty : MemberScopeImpl defined in org.jetbrains.kotlin.resolve.scopes.MemberScope[FakeCallableDescriptorForObject]

'typeResolver' @ [71:16] ==> private final val typeResolver: TypeResolver defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData[PropertyDescriptorImpl]

'resolveType' @ [71:29] ==> public final fun resolveType(scope: LexicalScope, typeReference: KtTypeReference, trace: BindingTrace, checkBounds: Boolean): KotlinType defined in org.jetbrains.kotlin.resolve.TypeResolver[DeserializedSimpleFunctionDescriptor]

'scopeToResolveTypeParameters' @ [72:17] ==> private final val scopeToResolveTypeParameters: LexicalScope defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData[PropertyDescriptorImpl]

'KtPsiFactory' @ [72:47] ==> @JvmOverloads public constructor KtPsiFactory(project: Project, markGenerated: Boolean = ...) defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedClassConstructorDescriptor]

'project' @ [72:60] ==> private final val project: Project defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData[PropertyDescriptorImpl]

'createType' @ [72:69] ==> public final fun createType(type: String): KtTypeReference defined in org.jetbrains.kotlin.psi.KtPsiFactory[DeserializedSimpleFunctionDescriptor]

'name' @ [72:80] ==> value-parameter name: String defined in org.jetbrains.kotlin.resolve.constraintSystem.ConstraintSystemTestData.getType[ValueParameterDescriptorImpl]

'DUMMY_TRACE' @ [73:33] ==> public final val DUMMY_TRACE: (BindingTrace..BindingTrace?) defined in org.jetbrains.kotlin.test.KotlinTestUtils[JavaPropertyDescriptor]

'compile' @ [77:50] ==> public open fun compile(p0: (String..String?)): (Pattern..Pattern?) defined in java.util.regex.Pattern[JavaMethodDescriptor]

