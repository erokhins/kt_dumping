'assert' @ [53:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'!' @ [53:16] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'analyzed' @ [53:17] ==> public final var analyzed: Boolean defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedAtom[PropertyDescriptorImpl]

'this' @ [54:33] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedAtom[LazyClassReceiverParameterDescriptor]

'analyzed' @ [57:9] ==> public final var analyzed: Boolean defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedAtom[PropertyDescriptorImpl]

'this' @ [59:9] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedAtom[LazyClassReceiverParameterDescriptor]

'subResolvedAtoms' @ [59:14] ==> public final lateinit var subResolvedAtoms: List<ResolvedAtom> defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedAtom[PropertyDescriptorImpl]

'subResolvedAtoms' @ [59:33] ==> value-parameter subResolvedAtoms: List<ResolvedAtom> defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedAtom.setAnalyzedResults[ValueParameterDescriptorImpl]

'this' @ [60:9] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedAtom[LazyClassReceiverParameterDescriptor]

'diagnostics' @ [60:14] ==> public final lateinit var diagnostics: Collection<KotlinCallDiagnostic> defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedAtom[PropertyDescriptorImpl]

'diagnostics' @ [60:28] ==> value-parameter diagnostics: Collection<KotlinCallDiagnostic> defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedAtom.setAnalyzedResults[ValueParameterDescriptorImpl]

'ResolvedAtom' @ [64:35] ==> private constructor ResolvedAtom() defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedAtom[ClassConstructorDescriptorImpl]

'ResolvedAtom' @ [75:81] ==> private constructor ResolvedAtom() defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedAtom[ClassConstructorDescriptorImpl]

'setAnalyzedResults' @ [77:9] ==> protected open fun setAnalyzedResults(subResolvedAtoms: List<ResolvedAtom>, diagnostics: Collection<KotlinCallDiagnostic>): Unit defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedExpressionAtom[SimpleFunctionDescriptorImpl]

'listOf' @ [77:28] ==> @InlineOnly public inline fun <T> listOf(): List<ResolvedAtom> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ResolvedAtom

'listOf' @ [77:38] ==> @InlineOnly public inline fun <T> listOf(): List<KotlinCallDiagnostic> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinCallDiagnostic

'ResolvedAtom' @ [80:38] ==> private constructor ResolvedAtom() defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedAtom[ClassConstructorDescriptorImpl]

'PostponedResolvedAtom' @ [88:5] ==> private constructor PostponedResolvedAtom() defined in org.jetbrains.kotlin.resolve.calls.model.PostponedResolvedAtom[ClassConstructorDescriptorImpl]

'listOf' @ [89:64] ==> public fun <T> listOf(element: UnwrappedType): List<UnwrappedType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> UnwrappedType

'expectedType' @ [89:71] ==> public final val expectedType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.model.LambdaWithTypeVariableAsExpectedTypeAtom[PropertyDescriptorImpl]

'setAnalyzedResults' @ [93:9] ==> protected open fun setAnalyzedResults(subResolvedAtoms: List<ResolvedAtom>, diagnostics: Collection<KotlinCallDiagnostic>): Unit defined in org.jetbrains.kotlin.resolve.calls.model.LambdaWithTypeVariableAsExpectedTypeAtom[SimpleFunctionDescriptorImpl]

'listOf' @ [93:28] ==> public fun <T> listOf(element: ResolvedLambdaAtom): List<ResolvedLambdaAtom> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ResolvedLambdaAtom

'resolvedLambdaAtom' @ [93:35] ==> value-parameter resolvedLambdaAtom: ResolvedLambdaAtom defined in org.jetbrains.kotlin.resolve.calls.model.LambdaWithTypeVariableAsExpectedTypeAtom.setAnalyzed[ValueParameterDescriptorImpl]

'listOf' @ [93:56] ==> @InlineOnly public inline fun <T> listOf(): List<KotlinCallDiagnostic> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinCallDiagnostic

'PostponedResolvedAtom' @ [104:5] ==> private constructor PostponedResolvedAtom() defined in org.jetbrains.kotlin.resolve.calls.model.PostponedResolvedAtom[ClassConstructorDescriptorImpl]

'this' @ [113:9] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedLambdaAtom[LazyClassReceiverParameterDescriptor]

'resultArguments' @ [113:14] ==> public final lateinit var resultArguments: List<KotlinCallArgument> defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedLambdaAtom[PropertyDescriptorImpl]

'resultArguments' @ [113:32] ==> value-parameter resultArguments: List<KotlinCallArgument> defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedLambdaAtom.setAnalyzedResults[ValueParameterDescriptorImpl]

'setAnalyzedResults' @ [114:9] ==> protected open fun setAnalyzedResults(subResolvedAtoms: List<ResolvedAtom>, diagnostics: Collection<KotlinCallDiagnostic>): Unit defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedLambdaAtom[SimpleFunctionDescriptorImpl]

'subResolvedAtoms' @ [114:28] ==> value-parameter subResolvedAtoms: List<ResolvedAtom> defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedLambdaAtom.setAnalyzedResults[ValueParameterDescriptorImpl]

'diagnostics' @ [114:46] ==> value-parameter diagnostics: Collection<KotlinCallDiagnostic> defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedLambdaAtom.setAnalyzedResults[ValueParameterDescriptorImpl]

'receiver' @ [117:64] ==> public final val receiver: UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedLambdaAtom[PropertyDescriptorImpl]

'let' @ [117:74] ==> @InlineOnly public inline fun <T, R> UnwrappedType.let(block: (UnwrappedType) -> List<UnwrappedType>): List<UnwrappedType> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> UnwrappedType
    <R> -> List<UnwrappedType>

'parameters' @ [117:80] ==> public final val parameters: List<UnwrappedType> defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedLambdaAtom[PropertyDescriptorImpl]

'it' @ [117:93] ==> value-parameter it: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedLambdaAtom.<get-inputTypes>.<anonymous>[ValueParameterDescriptorImpl]

'parameters' @ [117:101] ==> public final val parameters: List<UnwrappedType> defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedLambdaAtom[PropertyDescriptorImpl]

'returnType' @ [118:52] ==> public final val returnType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedLambdaAtom[PropertyDescriptorImpl]

'PostponedResolvedAtom' @ [124:5] ==> private constructor PostponedResolvedAtom() defined in org.jetbrains.kotlin.resolve.calls.model.PostponedResolvedAtom[ClassConstructorDescriptorImpl]

'this' @ [133:9] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCallableReferenceAtom[LazyClassReceiverParameterDescriptor]

'candidate' @ [133:14] ==> public final var candidate: CallableReferenceCandidate? defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCallableReferenceAtom[PropertyDescriptorImpl]

'candidate' @ [133:26] ==> value-parameter candidate: CallableReferenceCandidate? defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCallableReferenceAtom.setAnalyzedResults[ValueParameterDescriptorImpl]

'setAnalyzedResults' @ [134:9] ==> protected open fun setAnalyzedResults(subResolvedAtoms: List<ResolvedAtom>, diagnostics: Collection<KotlinCallDiagnostic>): Unit defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCallableReferenceAtom[SimpleFunctionDescriptorImpl]

'subResolvedAtoms' @ [134:28] ==> value-parameter subResolvedAtoms: List<ResolvedAtom> defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCallableReferenceAtom.setAnalyzedResults[ValueParameterDescriptorImpl]

'diagnostics' @ [134:46] ==> value-parameter diagnostics: Collection<KotlinCallDiagnostic> defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCallableReferenceAtom.setAnalyzedResults[ValueParameterDescriptorImpl]

'getFunctionTypeFromCallableReferenceExpectedType' @ [139:32] ==> public fun getFunctionTypeFromCallableReferenceExpectedType(expectedType: UnwrappedType?): UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.components in file CallableReferenceResolution.kt[SimpleFunctionDescriptorImpl]

'expectedType' @ [139:81] ==> public final val expectedType: UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCallableReferenceAtom[PropertyDescriptorImpl]

'emptyList' @ [139:105] ==> public fun <T> emptyList(): List<UnwrappedType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> UnwrappedType

'functionType' @ [140:30] ==> val functionType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCallableReferenceAtom.<get-inputTypes>[LocalVariableDescriptor]

'getValueParameterTypesFromFunctionType' @ [140:43] ==> public fun KotlinType.getValueParameterTypesFromFunctionType(): List<TypeProjection> defined in org.jetbrains.kotlin.builtins[DeserializedSimpleFunctionDescriptor]

'map' @ [140:84] ==> public inline fun <T, R> Iterable<TypeProjection>.map(transform: (TypeProjection) -> UnwrappedType): List<UnwrappedType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection
    <R> -> UnwrappedType

'it' @ [140:90] ==> value-parameter it: TypeProjection defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCallableReferenceAtom.<get-inputTypes>.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [140:93] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'unwrap' @ [140:98] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'functionType' @ [141:28] ==> val functionType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCallableReferenceAtom.<get-inputTypes>[LocalVariableDescriptor]

'getReceiverTypeFromFunctionType' @ [141:41] ==> public fun KotlinType.getReceiverTypeFromFunctionType(): KotlinType? defined in org.jetbrains.kotlin.builtins[DeserializedSimpleFunctionDescriptor]

'unwrap' @ [141:76] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'receiver' @ [142:20] ==> val receiver: UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCallableReferenceAtom.<get-inputTypes>[LocalVariableDescriptor]

'let' @ [142:30] ==> @InlineOnly public inline fun <T, R> UnwrappedType.let(block: (UnwrappedType) -> List<UnwrappedType>): List<UnwrappedType> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> UnwrappedType
    <R> -> List<UnwrappedType>

'parameters' @ [142:36] ==> val parameters: List<UnwrappedType> defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCallableReferenceAtom.<get-inputTypes>[LocalVariableDescriptor]

'it' @ [142:49] ==> value-parameter it: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCallableReferenceAtom.<get-inputTypes>.<anonymous>[ValueParameterDescriptorImpl]

'parameters' @ [142:57] ==> val parameters: List<UnwrappedType> defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCallableReferenceAtom.<get-inputTypes>[LocalVariableDescriptor]

'getFunctionTypeFromCallableReferenceExpectedType' @ [147:32] ==> public fun getFunctionTypeFromCallableReferenceExpectedType(expectedType: UnwrappedType?): UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.components in file CallableReferenceResolution.kt[SimpleFunctionDescriptorImpl]

'expectedType' @ [147:81] ==> public final val expectedType: UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCallableReferenceAtom[PropertyDescriptorImpl]

'functionType' @ [148:20] ==> val functionType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCallableReferenceAtom.<get-outputType>[LocalVariableDescriptor]

'getReturnTypeFromFunctionType' @ [148:33] ==> public fun KotlinType.getReturnTypeFromFunctionType(): KotlinType defined in org.jetbrains.kotlin.builtins[DeserializedSimpleFunctionDescriptor]

'unwrap' @ [148:65] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'ResolvedAtom' @ [155:5] ==> private constructor ResolvedAtom() defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedAtom[ClassConstructorDescriptorImpl]

'setAnalyzedResults' @ [157:9] ==> protected open fun setAnalyzedResults(subResolvedAtoms: List<ResolvedAtom>, diagnostics: Collection<KotlinCallDiagnostic>): Unit defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCollectionLiteralAtom[SimpleFunctionDescriptorImpl]

'listOf' @ [157:28] ==> @InlineOnly public inline fun <T> listOf(): List<ResolvedAtom> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ResolvedAtom

'listOf' @ [157:38] ==> @InlineOnly public inline fun <T> listOf(): List<KotlinCallDiagnostic> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinCallDiagnostic

'ResolvedAtom' @ [167:5] ==> private constructor ResolvedAtom() defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedAtom[ClassConstructorDescriptorImpl]

'setAnalyzedResults' @ [178:9] ==> protected open fun setAnalyzedResults(subResolvedAtoms: List<ResolvedAtom>, diagnostics: Collection<KotlinCallDiagnostic>): Unit defined in org.jetbrains.kotlin.resolve.calls.model.CallResolutionResult[SimpleFunctionDescriptorImpl]

'listOfNotNull' @ [178:28] ==> public fun <T : Any> listOfNotNull(element: ResolvedCallAtom?): List<ResolvedCallAtom> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> ResolvedCallAtom

'resultCallAtom' @ [178:42] ==> public final val resultCallAtom: ResolvedCallAtom? defined in org.jetbrains.kotlin.resolve.calls.model.CallResolutionResult[PropertyDescriptorImpl]

'diagnostics' @ [178:59] ==> value-parameter diagnostics: List<KotlinCallDiagnostic> defined in org.jetbrains.kotlin.resolve.calls.model.CallResolutionResult.<init>[ValueParameterDescriptorImpl]

'type' @ [181:33] ==> public final val type: CallResolutionResult.Type defined in org.jetbrains.kotlin.resolve.calls.model.CallResolutionResult[PropertyDescriptorImpl]

'resultCallAtom' @ [181:57] ==> public final val resultCallAtom: ResolvedCallAtom? defined in org.jetbrains.kotlin.resolve.calls.model.CallResolutionResult[PropertyDescriptorImpl]

'diagnostics' @ [181:76] ==> public final lateinit var diagnostics: Collection<KotlinCallDiagnostic> defined in org.jetbrains.kotlin.resolve.calls.model.CallResolutionResult[PropertyDescriptorImpl]

'joinToString' @ [181:88] ==> public fun <T> Iterable<KotlinCallDiagnostic>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((KotlinCallDiagnostic) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinCallDiagnostic

'candidateDescriptor' @ [185:22] ==> public abstract val candidateDescriptor: CallableDescriptor defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCallAtom[PropertyDescriptorImpl]

'returnType' @ [185:42] ==> public final val CallableDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'substitutor' @ [186:12] ==> public abstract val substitutor: FreshVariableNewTypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedCallAtom[PropertyDescriptorImpl]

'safeSubstitute' @ [186:24] ==> public open fun safeSubstitute(type: UnwrappedType): UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.FreshVariableNewTypeSubstitutor[SimpleFunctionDescriptorImpl]

'returnType' @ [186:39] ==> val returnType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.model.<get-freshReturnType>[LocalVariableDescriptor]

'unwrap' @ [186:50] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

