'constraint' @ [47:13] ==> value-parameter constraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.incorporate[ValueParameterDescriptorImpl]

'type' @ [47:24] ==> public final val type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'contains' @ [47:29] ==> public fun KotlinType.contains(predicate: (UnwrappedType) -> Boolean): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'it' @ [47:40] ==> value-parameter it: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.incorporate.<anonymous>[ValueParameterDescriptorImpl]

'constructor' @ [47:43] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.UnwrappedType[DeserializedPropertyDescriptor]

'typeVariable' @ [47:58] ==> value-parameter typeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.incorporate[ValueParameterDescriptorImpl]

'freshTypeConstructor' @ [47:71] ==> public final val freshTypeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewTypeVariable[PropertyDescriptorImpl]

'directWithVariable' @ [49:9] ==> private final fun directWithVariable(c: ConstraintIncorporator.Context, typeVariable: NewTypeVariable, constraint: Constraint): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator[SimpleFunctionDescriptorImpl]

'c' @ [49:28] ==> value-parameter c: ConstraintIncorporator.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.incorporate[ValueParameterDescriptorImpl]

'typeVariable' @ [49:31] ==> value-parameter typeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.incorporate[ValueParameterDescriptorImpl]

'constraint' @ [49:45] ==> value-parameter constraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.incorporate[ValueParameterDescriptorImpl]

'otherInsideMyConstraint' @ [50:9] ==> private final fun otherInsideMyConstraint(c: ConstraintIncorporator.Context, typeVariable: NewTypeVariable, constraint: Constraint): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator[SimpleFunctionDescriptorImpl]

'c' @ [50:33] ==> value-parameter c: ConstraintIncorporator.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.incorporate[ValueParameterDescriptorImpl]

'typeVariable' @ [50:36] ==> value-parameter typeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.incorporate[ValueParameterDescriptorImpl]

'constraint' @ [50:50] ==> value-parameter constraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.incorporate[ValueParameterDescriptorImpl]

'insideOtherConstraint' @ [51:9] ==> private final fun insideOtherConstraint(c: ConstraintIncorporator.Context, typeVariable: NewTypeVariable, constraint: Constraint): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator[SimpleFunctionDescriptorImpl]

'c' @ [51:31] ==> value-parameter c: ConstraintIncorporator.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.incorporate[ValueParameterDescriptorImpl]

'typeVariable' @ [51:34] ==> value-parameter typeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.incorporate[ValueParameterDescriptorImpl]

'constraint' @ [51:48] ==> value-parameter constraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.incorporate[ValueParameterDescriptorImpl]

'constraint' @ [57:13] ==> value-parameter constraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.directWithVariable[ValueParameterDescriptorImpl]

'kind' @ [57:24] ==> public final val kind: ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'LOWER' @ [57:47] ==> enum entry LOWER defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'c' @ [58:13] ==> value-parameter c: ConstraintIncorporator.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.directWithVariable[ValueParameterDescriptorImpl]

'getConstraintsForVariable' @ [58:15] ==> public abstract fun getConstraintsForVariable(typeVariable: NewTypeVariable): Collection<Constraint> defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.Context[SimpleFunctionDescriptorImpl]

'typeVariable' @ [58:41] ==> value-parameter typeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.directWithVariable[ValueParameterDescriptorImpl]

'forEach' @ [58:55] ==> @HidesMembers public inline fun <T> Iterable<Constraint>.forEach(action: (Constraint) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Constraint

'it' @ [59:21] ==> value-parameter it: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.directWithVariable.<anonymous>[ValueParameterDescriptorImpl]

'kind' @ [59:24] ==> public final val kind: ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'UPPER' @ [59:47] ==> enum entry UPPER defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'c' @ [60:21] ==> value-parameter c: ConstraintIncorporator.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.directWithVariable[ValueParameterDescriptorImpl]

'addNewIncorporatedConstraint' @ [60:23] ==> public abstract fun addNewIncorporatedConstraint(lowerType: UnwrappedType, upperType: UnwrappedType): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.Context[SimpleFunctionDescriptorImpl]

'it' @ [60:52] ==> value-parameter it: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.directWithVariable.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [60:55] ==> public final val type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'constraint' @ [60:61] ==> value-parameter constraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.directWithVariable[ValueParameterDescriptorImpl]

'type' @ [60:72] ==> public final val type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'constraint' @ [66:13] ==> value-parameter constraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.directWithVariable[ValueParameterDescriptorImpl]

'kind' @ [66:24] ==> public final val kind: ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'UPPER' @ [66:47] ==> enum entry UPPER defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'c' @ [67:13] ==> value-parameter c: ConstraintIncorporator.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.directWithVariable[ValueParameterDescriptorImpl]

'getConstraintsForVariable' @ [67:15] ==> public abstract fun getConstraintsForVariable(typeVariable: NewTypeVariable): Collection<Constraint> defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.Context[SimpleFunctionDescriptorImpl]

'typeVariable' @ [67:41] ==> value-parameter typeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.directWithVariable[ValueParameterDescriptorImpl]

'forEach' @ [67:55] ==> @HidesMembers public inline fun <T> Iterable<Constraint>.forEach(action: (Constraint) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Constraint

'it' @ [68:21] ==> value-parameter it: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.directWithVariable.<anonymous>[ValueParameterDescriptorImpl]

'kind' @ [68:24] ==> public final val kind: ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'LOWER' @ [68:47] ==> enum entry LOWER defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'c' @ [69:21] ==> value-parameter c: ConstraintIncorporator.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.directWithVariable[ValueParameterDescriptorImpl]

'addNewIncorporatedConstraint' @ [69:23] ==> public abstract fun addNewIncorporatedConstraint(lowerType: UnwrappedType, upperType: UnwrappedType): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.Context[SimpleFunctionDescriptorImpl]

'constraint' @ [69:52] ==> value-parameter constraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.directWithVariable[ValueParameterDescriptorImpl]

'type' @ [69:63] ==> public final val type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'it' @ [69:69] ==> value-parameter it: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.directWithVariable.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [69:72] ==> public final val type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'SmartSet' @ [77:35] ==> public companion object defined in org.jetbrains.kotlin.utils.SmartSet[FakeCallableDescriptorForObject]

'create' @ [77:44] ==> @JvmStatic public final fun <T> create(): SmartSet<NewTypeVariable> defined in org.jetbrains.kotlin.utils.SmartSet.Companion[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> NewTypeVariable

'constraint' @ [78:9] ==> value-parameter constraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.otherInsideMyConstraint[ValueParameterDescriptorImpl]

'type' @ [78:20] ==> public final val type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'contains' @ [78:25] ==> public fun KotlinType.contains(predicate: (UnwrappedType) -> Boolean): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'otherInMyConstraint' @ [79:13] ==> val otherInMyConstraint: SmartSet<NewTypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.otherInsideMyConstraint[LocalVariableDescriptor]

'addIfNotNull' @ [79:33] ==> public fun <T : Any> MutableCollection<(NewTypeVariable..NewTypeVariable?)>.addIfNotNull(t: NewTypeVariable?): Unit defined in org.jetbrains.kotlin.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> (org.jetbrains.kotlin.resolve.calls.inference.model.NewTypeVariable..org.jetbrains.kotlin.resolve.calls.inference.model.NewTypeVariable?)

'c' @ [79:46] ==> value-parameter c: ConstraintIncorporator.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.otherInsideMyConstraint[ValueParameterDescriptorImpl]

'getTypeVariable' @ [79:48] ==> public abstract fun getTypeVariable(typeConstructor: TypeConstructor): NewTypeVariable? defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.Context[SimpleFunctionDescriptorImpl]

'it' @ [79:64] ==> value-parameter it: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.otherInsideMyConstraint.<anonymous>[ValueParameterDescriptorImpl]

'constructor' @ [79:67] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.UnwrappedType[DeserializedPropertyDescriptor]

'otherInMyConstraint' @ [83:35] ==> val otherInMyConstraint: SmartSet<NewTypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.otherInsideMyConstraint[LocalVariableDescriptor]

'ArrayList' @ [85:36] ==> public constructor ArrayList<E : (Any..Any?)>(p0: (MutableCollection<out (Constraint..Constraint?)>..Collection<(Constraint..Constraint?)>?)) defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> Constraint

'c' @ [85:46] ==> value-parameter c: ConstraintIncorporator.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.otherInsideMyConstraint[ValueParameterDescriptorImpl]

'getConstraintsForVariable' @ [85:48] ==> public abstract fun getConstraintsForVariable(typeVariable: NewTypeVariable): Collection<Constraint> defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.Context[SimpleFunctionDescriptorImpl]

'otherTypeVariable' @ [85:74] ==> val otherTypeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.otherInsideMyConstraint[LocalVariableDescriptor]

'otherConstraints' @ [86:37] ==> val otherConstraints: ArrayList<Constraint> defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.otherInsideMyConstraint[LocalVariableDescriptor]

'generateNewConstraint' @ [87:17] ==> private final fun generateNewConstraint(c: ConstraintIncorporator.Context, targetVariable: NewTypeVariable, baseConstraint: Constraint, otherVariable: NewTypeVariable, otherConstraint: Constraint): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator[SimpleFunctionDescriptorImpl]

'c' @ [87:39] ==> value-parameter c: ConstraintIncorporator.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.otherInsideMyConstraint[ValueParameterDescriptorImpl]

'typeVariable' @ [87:42] ==> value-parameter typeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.otherInsideMyConstraint[ValueParameterDescriptorImpl]

'constraint' @ [87:56] ==> value-parameter constraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.otherInsideMyConstraint[ValueParameterDescriptorImpl]

'otherTypeVariable' @ [87:68] ==> val otherTypeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.otherInsideMyConstraint[LocalVariableDescriptor]

'otherConstraint' @ [87:87] ==> val otherConstraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.otherInsideMyConstraint[LocalVariableDescriptor]

'c' @ [94:44] ==> value-parameter c: ConstraintIncorporator.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.insideOtherConstraint[ValueParameterDescriptorImpl]

'allTypeVariablesWithConstraints' @ [94:46] ==> public abstract val allTypeVariablesWithConstraints: Collection<VariableWithConstraints> defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.Context[PropertyDescriptorImpl]

'typeVariableWithConstraint' @ [95:56] ==> val typeVariableWithConstraint: VariableWithConstraints defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.insideOtherConstraint[LocalVariableDescriptor]

'constraints' @ [95:83] ==> public abstract val constraints: List<Constraint> defined in org.jetbrains.kotlin.resolve.calls.inference.model.VariableWithConstraints[PropertyDescriptorImpl]

'filter' @ [95:95] ==> public inline fun <T> Iterable<Constraint>.filter(predicate: (Constraint) -> Boolean): List<Constraint> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Constraint

'it' @ [96:17] ==> value-parameter it: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.insideOtherConstraint.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [96:20] ==> public final val type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'contains' @ [96:25] ==> public fun KotlinType.contains(predicate: (UnwrappedType) -> Boolean): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'it' @ [96:36] ==> value-parameter it: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.insideOtherConstraint.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'constructor' @ [96:39] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.UnwrappedType[DeserializedPropertyDescriptor]

'typeVariable' @ [96:54] ==> value-parameter typeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.insideOtherConstraint[ValueParameterDescriptorImpl]

'freshTypeConstructor' @ [96:67] ==> public final val freshTypeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewTypeVariable[PropertyDescriptorImpl]

'constraintsWhichConstraintMyVariable' @ [98:13] ==> val constraintsWhichConstraintMyVariable: List<Constraint> defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.insideOtherConstraint[LocalVariableDescriptor]

'forEach' @ [98:50] ==> @HidesMembers public inline fun <T> Iterable<Constraint>.forEach(action: (Constraint) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Constraint

'generateNewConstraint' @ [99:17] ==> private final fun generateNewConstraint(c: ConstraintIncorporator.Context, targetVariable: NewTypeVariable, baseConstraint: Constraint, otherVariable: NewTypeVariable, otherConstraint: Constraint): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator[SimpleFunctionDescriptorImpl]

'c' @ [99:39] ==> value-parameter c: ConstraintIncorporator.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.insideOtherConstraint[ValueParameterDescriptorImpl]

'typeVariableWithConstraint' @ [99:42] ==> val typeVariableWithConstraint: VariableWithConstraints defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.insideOtherConstraint[LocalVariableDescriptor]

'typeVariable' @ [99:69] ==> public abstract val typeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.model.VariableWithConstraints[PropertyDescriptorImpl]

'it' @ [99:83] ==> value-parameter it: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.insideOtherConstraint.<anonymous>[ValueParameterDescriptorImpl]

'typeVariable' @ [99:87] ==> value-parameter typeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.insideOtherConstraint[ValueParameterDescriptorImpl]

'constraint' @ [99:101] ==> value-parameter constraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.insideOtherConstraint[ValueParameterDescriptorImpl]

'when (otherConstraint.kind) {
            ConstraintKind.EQUALITY -> {
                baseConstraint.type.substitute(otherVariable, otherConstraint.type)
            }
            ConstraintKind.UPPER -> {
                val newCapturedTypeConstructor = NewCapturedTypeConstructor(TypeProjectionImpl(Variance.OUT_VARIANCE, otherConstraint.type),
                                                                            listOf(otherConstraint.type))
                val temporaryCapturedType = NewCapturedType(CaptureStatus.FOR_INCORPORATION,
                                                            newCapturedTypeConstructor,
                                                            lowerType = null)
                baseConstraint.type.substitute(otherVariable, temporaryCapturedType)
            }
            ConstraintKind.LOWER -> {
                val newCapturedTypeConstructor = NewCapturedTypeConstructor(TypeProjectionImpl(Variance.IN_VARIANCE, otherConstraint.type),
                                                                            emptyList())
                val temporaryCapturedType = NewCapturedType(CaptureStatus.FOR_INCORPORATION,
                                                            newCapturedTypeConstructor,
                                                            lowerType = otherConstraint.type)
                baseConstraint.type.substitute(otherVariable, temporaryCapturedType)
            }
        }' @ [111:36] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: UnwrappedType, entry1: UnwrappedType, entry2: UnwrappedType): UnwrappedType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> UnwrappedType

'otherConstraint' @ [111:42] ==> value-parameter otherConstraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.generateNewConstraint[ValueParameterDescriptorImpl]

'kind' @ [111:58] ==> public final val kind: ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'EQUALITY' @ [112:28] ==> enum entry EQUALITY defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'baseConstraint' @ [113:17] ==> value-parameter baseConstraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.generateNewConstraint[ValueParameterDescriptorImpl]

'type' @ [113:32] ==> public final val type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'substitute' @ [113:37] ==> private final fun UnwrappedType.substitute(typeVariable: NewTypeVariable, value: UnwrappedType): UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator[SimpleFunctionDescriptorImpl]

'otherVariable' @ [113:48] ==> value-parameter otherVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.generateNewConstraint[ValueParameterDescriptorImpl]

'otherConstraint' @ [113:63] ==> value-parameter otherConstraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.generateNewConstraint[ValueParameterDescriptorImpl]

'type' @ [113:79] ==> public final val type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'UPPER' @ [115:28] ==> enum entry UPPER defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'NewCapturedTypeConstructor' @ [116:50] ==> public constructor NewCapturedTypeConstructor(projection: TypeProjection, supertypes: List<UnwrappedType>? = ...) defined in org.jetbrains.kotlin.types.checker.NewCapturedTypeConstructor[DeserializedClassConstructorDescriptor]

'TypeProjectionImpl' @ [116:77] ==> public constructor TypeProjectionImpl(@NotNull p0: Variance, @NotNull p1: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'OUT_VARIANCE' @ [116:105] ==> enum entry OUT_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'otherConstraint' @ [116:119] ==> value-parameter otherConstraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.generateNewConstraint[ValueParameterDescriptorImpl]

'type' @ [116:135] ==> public final val type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'listOf' @ [117:77] ==> public fun <T> listOf(element: UnwrappedType): List<UnwrappedType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> UnwrappedType

'otherConstraint' @ [117:84] ==> value-parameter otherConstraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.generateNewConstraint[ValueParameterDescriptorImpl]

'type' @ [117:100] ==> public final val type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'NewCapturedType' @ [118:45] ==> public constructor NewCapturedType(captureStatus: CaptureStatus, constructor: NewCapturedTypeConstructor, lowerType: UnwrappedType?, annotations: Annotations = ..., isMarkedNullable: Boolean = ...) defined in org.jetbrains.kotlin.types.checker.NewCapturedType[DeserializedClassConstructorDescriptor]

'FOR_INCORPORATION' @ [118:75] ==> enum entry FOR_INCORPORATION defined in org.jetbrains.kotlin.types.checker.CaptureStatus[FakeCallableDescriptorForObject]

'newCapturedTypeConstructor' @ [119:61] ==> val newCapturedTypeConstructor: NewCapturedTypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.generateNewConstraint[LocalVariableDescriptor]

'baseConstraint' @ [121:17] ==> value-parameter baseConstraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.generateNewConstraint[ValueParameterDescriptorImpl]

'type' @ [121:32] ==> public final val type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'substitute' @ [121:37] ==> private final fun UnwrappedType.substitute(typeVariable: NewTypeVariable, value: UnwrappedType): UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator[SimpleFunctionDescriptorImpl]

'otherVariable' @ [121:48] ==> value-parameter otherVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.generateNewConstraint[ValueParameterDescriptorImpl]

'temporaryCapturedType' @ [121:63] ==> val temporaryCapturedType: NewCapturedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.generateNewConstraint[LocalVariableDescriptor]

'LOWER' @ [123:28] ==> enum entry LOWER defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'NewCapturedTypeConstructor' @ [124:50] ==> public constructor NewCapturedTypeConstructor(projection: TypeProjection, supertypes: List<UnwrappedType>? = ...) defined in org.jetbrains.kotlin.types.checker.NewCapturedTypeConstructor[DeserializedClassConstructorDescriptor]

'TypeProjectionImpl' @ [124:77] ==> public constructor TypeProjectionImpl(@NotNull p0: Variance, @NotNull p1: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'IN_VARIANCE' @ [124:105] ==> enum entry IN_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'otherConstraint' @ [124:118] ==> value-parameter otherConstraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.generateNewConstraint[ValueParameterDescriptorImpl]

'type' @ [124:134] ==> public final val type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'emptyList' @ [125:77] ==> public fun <T> emptyList(): List<UnwrappedType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> UnwrappedType

'NewCapturedType' @ [126:45] ==> public constructor NewCapturedType(captureStatus: CaptureStatus, constructor: NewCapturedTypeConstructor, lowerType: UnwrappedType?, annotations: Annotations = ..., isMarkedNullable: Boolean = ...) defined in org.jetbrains.kotlin.types.checker.NewCapturedType[DeserializedClassConstructorDescriptor]

'FOR_INCORPORATION' @ [126:75] ==> enum entry FOR_INCORPORATION defined in org.jetbrains.kotlin.types.checker.CaptureStatus[FakeCallableDescriptorForObject]

'newCapturedTypeConstructor' @ [127:61] ==> val newCapturedTypeConstructor: NewCapturedTypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.generateNewConstraint[LocalVariableDescriptor]

'otherConstraint' @ [128:73] ==> value-parameter otherConstraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.generateNewConstraint[ValueParameterDescriptorImpl]

'type' @ [128:89] ==> public final val type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'baseConstraint' @ [129:17] ==> value-parameter baseConstraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.generateNewConstraint[ValueParameterDescriptorImpl]

'type' @ [129:32] ==> public final val type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'substitute' @ [129:37] ==> private final fun UnwrappedType.substitute(typeVariable: NewTypeVariable, value: UnwrappedType): UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator[SimpleFunctionDescriptorImpl]

'otherVariable' @ [129:48] ==> value-parameter otherVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.generateNewConstraint[ValueParameterDescriptorImpl]

'temporaryCapturedType' @ [129:63] ==> val temporaryCapturedType: NewCapturedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.generateNewConstraint[LocalVariableDescriptor]

'baseConstraint' @ [133:13] ==> value-parameter baseConstraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.generateNewConstraint[ValueParameterDescriptorImpl]

'kind' @ [133:28] ==> public final val kind: ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'UPPER' @ [133:51] ==> enum entry UPPER defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'c' @ [134:13] ==> value-parameter c: ConstraintIncorporator.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.generateNewConstraint[ValueParameterDescriptorImpl]

'addNewIncorporatedConstraint' @ [134:15] ==> public abstract fun addNewIncorporatedConstraint(lowerType: UnwrappedType, upperType: UnwrappedType): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.Context[SimpleFunctionDescriptorImpl]

'approximateCapturedTypes' @ [134:44] ==> private final fun approximateCapturedTypes(type: UnwrappedType, toSuper: Boolean): UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator[SimpleFunctionDescriptorImpl]

'typeForApproximation' @ [134:69] ==> val typeForApproximation: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.generateNewConstraint[LocalVariableDescriptor]

'targetVariable' @ [134:109] ==> value-parameter targetVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.generateNewConstraint[ValueParameterDescriptorImpl]

'defaultType' @ [134:124] ==> public final val defaultType: SimpleType defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewTypeVariable[PropertyDescriptorImpl]

'baseConstraint' @ [136:13] ==> value-parameter baseConstraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.generateNewConstraint[ValueParameterDescriptorImpl]

'kind' @ [136:28] ==> public final val kind: ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'LOWER' @ [136:51] ==> enum entry LOWER defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'c' @ [137:13] ==> value-parameter c: ConstraintIncorporator.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.generateNewConstraint[ValueParameterDescriptorImpl]

'addNewIncorporatedConstraint' @ [137:15] ==> public abstract fun addNewIncorporatedConstraint(lowerType: UnwrappedType, upperType: UnwrappedType): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.Context[SimpleFunctionDescriptorImpl]

'targetVariable' @ [137:44] ==> value-parameter targetVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.generateNewConstraint[ValueParameterDescriptorImpl]

'defaultType' @ [137:59] ==> public final val defaultType: SimpleType defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewTypeVariable[PropertyDescriptorImpl]

'approximateCapturedTypes' @ [137:72] ==> private final fun approximateCapturedTypes(type: UnwrappedType, toSuper: Boolean): UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator[SimpleFunctionDescriptorImpl]

'typeForApproximation' @ [137:97] ==> val typeForApproximation: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.generateNewConstraint[LocalVariableDescriptor]

'create' @ [142:43] ==> @NotNull public open fun create(@NotNull p0: (MutableMap<(TypeConstructor..TypeConstructor?), (TypeProjection..TypeProjection?)>..Map<(TypeConstructor..TypeConstructor?), (TypeProjection..TypeProjection?)>)): TypeSubstitutor defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'mapOf' @ [142:50] ==> public fun <K, V> mapOf(pair: Pair<(TypeConstructor..TypeConstructor?), TypeProjection>): Map<(TypeConstructor..TypeConstructor?), TypeProjection> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.types.TypeConstructor..org.jetbrains.kotlin.types.TypeConstructor?)
    <V> -> TypeProjection

'typeVariable' @ [142:56] ==> value-parameter typeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.substitute[ValueParameterDescriptorImpl]

'freshTypeConstructor' @ [142:69] ==> public final val freshTypeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewTypeVariable[PropertyDescriptorImpl]

'value' @ [142:93] ==> value-parameter value: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.substitute[ValueParameterDescriptorImpl]

'asTypeProjection' @ [142:99] ==> public fun KotlinType.asTypeProjection(): TypeProjection defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'substitutor' @ [143:20] ==> val substitutor: TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.substitute[LocalVariableDescriptor]

'substitute' @ [143:32] ==> @Nullable public open fun substitute(@NotNull p0: KotlinType, @NotNull p1: Variance): KotlinType? defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'this' @ [143:43] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.substitute[ReceiverParameterDescriptorImpl]

'INVARIANT' @ [143:58] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'error' @ [143:72] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'this' @ [143:108] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.substitute[ReceiverParameterDescriptorImpl]

'typeVariable' @ [143:115] ==> value-parameter typeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.substitute[ValueParameterDescriptorImpl]

'value' @ [143:132] ==> value-parameter value: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.substitute[ValueParameterDescriptorImpl]

'type' @ [144:16] ==> val type: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.substitute[LocalVariableDescriptor]

'unwrap' @ [144:21] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'if (toSuper) typeApproximator.approximateToSuperType(type, TypeApproximatorConfiguration.IncorporationConfiguration) ?: type
            else typeApproximator.approximateToSubType(type, TypeApproximatorConfiguration.IncorporationConfiguration) ?: type' @ [148:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: UnwrappedType, elseBranch: UnwrappedType): UnwrappedType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> UnwrappedType

'toSuper' @ [148:17] ==> value-parameter toSuper: Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.approximateCapturedTypes[ValueParameterDescriptorImpl]

'typeApproximator' @ [148:26] ==> public final val typeApproximator: TypeApproximator defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator[PropertyDescriptorImpl]

'approximateToSuperType' @ [148:43] ==> public final fun approximateToSuperType(type: UnwrappedType, conf: TypeApproximatorConfiguration): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'type' @ [148:66] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.approximateCapturedTypes[ValueParameterDescriptorImpl]

'IncorporationConfiguration' @ [148:102] ==> public object IncorporationConfiguration : TypeApproximatorConfiguration.AbstractCapturedTypesApproximation defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration[FakeCallableDescriptorForObject]

'type' @ [148:133] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.approximateCapturedTypes[ValueParameterDescriptorImpl]

'typeApproximator' @ [149:18] ==> public final val typeApproximator: TypeApproximator defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator[PropertyDescriptorImpl]

'approximateToSubType' @ [149:35] ==> public final fun approximateToSubType(type: UnwrappedType, conf: TypeApproximatorConfiguration): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'type' @ [149:56] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.approximateCapturedTypes[ValueParameterDescriptorImpl]

'IncorporationConfiguration' @ [149:92] ==> public object IncorporationConfiguration : TypeApproximatorConfiguration.AbstractCapturedTypesApproximation defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration[FakeCallableDescriptorForObject]

'type' @ [149:123] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator.approximateCapturedTypes[ValueParameterDescriptorImpl]

