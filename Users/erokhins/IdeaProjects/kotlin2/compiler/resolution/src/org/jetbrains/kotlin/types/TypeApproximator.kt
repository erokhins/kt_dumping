'TO_COMMON_SUPERTYPE' @ [41:51] ==> enum entry TO_COMMON_SUPERTYPE defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration.IntersectionStrategy[FakeCallableDescriptorForObject]

'TypeApproximatorConfiguration' @ [46:43] ==> public constructor TypeApproximatorConfiguration() defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration[ClassConstructorDescriptorImpl]

'allFlexible' @ [49:39] ==> public abstract val allFlexible: Boolean defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration.AllFlexibleSameValue[PropertyDescriptorImpl]

'allFlexible' @ [50:38] ==> public abstract val allFlexible: Boolean defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration.AllFlexibleSameValue[PropertyDescriptorImpl]

'allFlexible' @ [51:38] ==> public abstract val allFlexible: Boolean defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration.AllFlexibleSameValue[PropertyDescriptorImpl]

'AllFlexibleSameValue' @ [54:31] ==> public constructor AllFlexibleSameValue() defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration.AllFlexibleSameValue[ClassConstructorDescriptorImpl]

'ALLOWED' @ [56:43] ==> enum entry ALLOWED defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration.IntersectionStrategy[FakeCallableDescriptorForObject]

'AllFlexibleSameValue' @ [60:32] ==> public constructor AllFlexibleSameValue() defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration.AllFlexibleSameValue[ClassConstructorDescriptorImpl]

'TypeApproximatorConfiguration.AllFlexibleSameValue' @ [65:103] ==> public constructor AllFlexibleSameValue() defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration.AllFlexibleSameValue[ClassConstructorDescriptorImpl]

'it' @ [69:68] ==> value-parameter it: NewCapturedType defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration.AbstractCapturedTypesApproximation.<get-capturedType>.<anonymous>[ValueParameterDescriptorImpl]

'captureStatus' @ [69:71] ==> public final val captureStatus: CaptureStatus defined in org.jetbrains.kotlin.types.checker.NewCapturedType[DeserializedPropertyDescriptor]

'approximatedCapturedStatus' @ [69:88] ==> public final val approximatedCapturedStatus: CaptureStatus defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration.AbstractCapturedTypesApproximation[PropertyDescriptorImpl]

'ALLOWED' @ [70:64] ==> enum entry ALLOWED defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration.IntersectionStrategy[FakeCallableDescriptorForObject]

'TypeApproximatorConfiguration.AbstractCapturedTypesApproximation' @ [74:41] ==> public constructor AbstractCapturedTypesApproximation(approximatedCapturedStatus: CaptureStatus) defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration.AbstractCapturedTypesApproximation[ClassConstructorDescriptorImpl]

'FOR_INCORPORATION' @ [74:106] ==> enum entry FOR_INCORPORATION defined in org.jetbrains.kotlin.types.checker.CaptureStatus[FakeCallableDescriptorForObject]

'TypeApproximatorConfiguration.AbstractCapturedTypesApproximation' @ [75:48] ==> public constructor AbstractCapturedTypesApproximation(approximatedCapturedStatus: CaptureStatus) defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration.AbstractCapturedTypesApproximation[ClassConstructorDescriptorImpl]

'FOR_SUBTYPING' @ [75:113] ==> enum entry FOR_SUBTYPING defined in org.jetbrains.kotlin.types.checker.CaptureStatus[FakeCallableDescriptorForObject]

'TypeApproximatorConfiguration.AbstractCapturedTypesApproximation' @ [76:41] ==> public constructor AbstractCapturedTypesApproximation(approximatedCapturedStatus: CaptureStatus) defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration.AbstractCapturedTypesApproximation[ClassConstructorDescriptorImpl]

'FROM_EXPRESSION' @ [76:106] ==> enum entry FROM_EXPRESSION defined in org.jetbrains.kotlin.types.checker.CaptureStatus[FakeCallableDescriptorForObject]

'this' @ [80:51] ==> <this> defined in org.jetbrains.kotlin.types.TypeApproximator[LazyClassReceiverParameterDescriptor]

'approximateSimpleToSuperType' @ [80:57] ==> private final fun approximateSimpleToSuperType(type: SimpleType, conf: TypeApproximatorConfiguration, depth: Int): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'this' @ [81:49] ==> <this> defined in org.jetbrains.kotlin.types.TypeApproximator[LazyClassReceiverParameterDescriptor]

'approximateSimpleToSubType' @ [81:55] ==> private final fun approximateSimpleToSubType(type: SimpleType, conf: TypeApproximatorConfiguration, depth: Int): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'!' @ [84:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'USE_NEW_INFERENCE' @ [84:14] ==> public val USE_NEW_INFERENCE: Boolean defined in org.jetbrains.kotlin.resolve.calls in file KotlinResolutionConfiguration.kt[PropertyDescriptorImpl]

'baseType' @ [84:40] ==> value-parameter baseType: KotlinType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateDeclarationType[ValueParameterDescriptorImpl]

'unwrap' @ [84:49] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'if (local) TypeApproximatorConfiguration.LocalDeclaration else TypeApproximatorConfiguration.PublicDeclaration' @ [86:29] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: TypeApproximatorConfiguration.AllFlexibleSameValue, elseBranch: TypeApproximatorConfiguration.AllFlexibleSameValue): TypeApproximatorConfiguration.AllFlexibleSameValue[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> AllFlexibleSameValue

'local' @ [86:33] ==> value-parameter local: Boolean defined in org.jetbrains.kotlin.types.TypeApproximator.approximateDeclarationType[ValueParameterDescriptorImpl]

'LocalDeclaration' @ [86:70] ==> public object LocalDeclaration : TypeApproximatorConfiguration.AllFlexibleSameValue defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration[FakeCallableDescriptorForObject]

'PublicDeclaration' @ [86:122] ==> public object PublicDeclaration : TypeApproximatorConfiguration.AllFlexibleSameValue defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration[FakeCallableDescriptorForObject]

'approximateToSuperType' @ [87:16] ==> public final fun approximateToSuperType(type: UnwrappedType, conf: TypeApproximatorConfiguration): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'baseType' @ [87:39] ==> value-parameter baseType: KotlinType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateDeclarationType[ValueParameterDescriptorImpl]

'unwrap' @ [87:48] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'configuration' @ [87:58] ==> val configuration: TypeApproximatorConfiguration.AllFlexibleSameValue defined in org.jetbrains.kotlin.types.TypeApproximator.approximateDeclarationType[LocalVariableDescriptor]

'baseType' @ [87:76] ==> value-parameter baseType: KotlinType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateDeclarationType[ValueParameterDescriptorImpl]

'unwrap' @ [87:85] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'approximateToSuperType' @ [93:13] ==> private final fun approximateToSuperType(type: UnwrappedType, conf: TypeApproximatorConfiguration, depth: Int): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'type' @ [93:36] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateToSuperType[ValueParameterDescriptorImpl]

'conf' @ [93:42] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateToSuperType[ValueParameterDescriptorImpl]

'-' @ [93:48] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'type' @ [93:50] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateToSuperType[ValueParameterDescriptorImpl]

'typeDepth' @ [93:55] ==> internal fun UnwrappedType.typeDepth(): Int defined in org.jetbrains.kotlin.types in file TypeApproximator.kt[SimpleFunctionDescriptorImpl]

'approximateToSubType' @ [97:13] ==> private final fun approximateToSubType(type: UnwrappedType, conf: TypeApproximatorConfiguration, depth: Int): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'type' @ [97:34] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateToSubType[ValueParameterDescriptorImpl]

'conf' @ [97:40] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateToSubType[ValueParameterDescriptorImpl]

'-' @ [97:46] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'type' @ [97:48] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateToSubType[ValueParameterDescriptorImpl]

'typeDepth' @ [97:53] ==> internal fun UnwrappedType.typeDepth(): Int defined in org.jetbrains.kotlin.types in file TypeApproximator.kt[SimpleFunctionDescriptorImpl]

'type' @ [100:13] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateToSuperType[ValueParameterDescriptorImpl]

'approximateTo' @ [101:16] ==> private final fun approximateTo(type: UnwrappedType, conf: TypeApproximatorConfiguration, bound: FlexibleType.() -> SimpleType, approximateTo: (SimpleType, TypeApproximatorConfiguration, depth: Int) -> UnwrappedType?, depth: Int): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'transformToNewType' @ [101:51] ==> public final fun transformToNewType(type: UnwrappedType): UnwrappedType defined in org.jetbrains.kotlin.types.checker.NewKotlinTypeChecker[DeserializedSimpleFunctionDescriptor]

'type' @ [101:70] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateToSuperType[ValueParameterDescriptorImpl]

'conf' @ [101:77] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateToSuperType[ValueParameterDescriptorImpl]

'FlexibleType' @ [101:83] ==> public constructor FlexibleType(lowerBound: SimpleType, upperBound: SimpleType) defined in org.jetbrains.kotlin.types.FlexibleType[DeserializedClassConstructorDescriptor]

'upperBound' @ [101:97] ==> public final val upperBound: SimpleType defined in org.jetbrains.kotlin.types.FlexibleType[DeserializedPropertyDescriptor]

'referenceApproximateToSuperType' @ [102:30] ==> private final val referenceApproximateToSuperType: KFunction3<@ParameterName SimpleType, @ParameterName TypeApproximatorConfiguration, @ParameterName Int, UnwrappedType?> defined in org.jetbrains.kotlin.types.TypeApproximator[PropertyDescriptorImpl]

'depth' @ [102:63] ==> value-parameter depth: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateToSuperType[ValueParameterDescriptorImpl]

'type' @ [106:13] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateToSubType[ValueParameterDescriptorImpl]

'approximateTo' @ [107:16] ==> private final fun approximateTo(type: UnwrappedType, conf: TypeApproximatorConfiguration, bound: FlexibleType.() -> SimpleType, approximateTo: (SimpleType, TypeApproximatorConfiguration, depth: Int) -> UnwrappedType?, depth: Int): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'transformToNewType' @ [107:51] ==> public final fun transformToNewType(type: UnwrappedType): UnwrappedType defined in org.jetbrains.kotlin.types.checker.NewKotlinTypeChecker[DeserializedSimpleFunctionDescriptor]

'type' @ [107:70] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateToSubType[ValueParameterDescriptorImpl]

'conf' @ [107:77] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateToSubType[ValueParameterDescriptorImpl]

'FlexibleType' @ [107:83] ==> public constructor FlexibleType(lowerBound: SimpleType, upperBound: SimpleType) defined in org.jetbrains.kotlin.types.FlexibleType[DeserializedClassConstructorDescriptor]

'lowerBound' @ [107:97] ==> public final val lowerBound: SimpleType defined in org.jetbrains.kotlin.types.FlexibleType[DeserializedPropertyDescriptor]

'referenceApproximateToSubType' @ [108:30] ==> private final val referenceApproximateToSubType: KFunction3<@ParameterName SimpleType, @ParameterName TypeApproximatorConfiguration, @ParameterName Int, UnwrappedType?> defined in org.jetbrains.kotlin.types.TypeApproximator[PropertyDescriptorImpl]

'depth' @ [108:61] ==> value-parameter depth: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateToSubType[ValueParameterDescriptorImpl]

'when (type) {
            is SimpleType -> return approximateTo(type, conf, depth)
            is FlexibleType -> {
                if (type is DynamicType) {
                    return if (conf.dynamic) null else type.bound()
                }
                else if (type is RawType) {
                    return if (conf.rawType) null else type.bound()
                }

                assert(type is FlexibleTypeImpl) {
                    "Unexpected subclass of FlexibleType: ${type::class.java.canonicalName}, type = $type"
                }

                if (conf.flexible) {
                    /**
                     * Let inputType = L_1..U_1; resultType = L_2..U_2
                     * We should create resultType such as inputType <: resultType.
                     * It means that if A <: inputType, then A <: U_1. And, because inputType <: resultType,
                     * A <: resultType => A <: U_2. I.e. for every type A such A <: U_1, A <: U_2 => U_1 <: U_2.
                     *
                     * Similar for L_1 <: L_2: Let B : resultType <: B. L_2 <: B and L_1 <: B.
                     * I.e. for every type B such as L_2 <: B, L_1 <: B. For example B = L_2.
                     */

                    val lowerResult = approximateTo(type.lowerBound, conf, depth)
                    val upperResult = approximateTo(type.upperBound, conf, depth)
                    if (lowerResult == null && upperResult == null) return null

                    /**
                     * If C <: L..U then C <: L.
                     * inputType.lower <: lowerResult => inputType.lower <: lowerResult?.lowerIfFlexible()
                     * i.e. this type is correct. We use this type, because this type more flexible.
                     *
                     * If U_1 <: U_2.lower .. U_2.upper, then we know only that U_1 <: U_2.upper.
                     */
                    return KotlinTypeFactory.flexibleType(lowerResult?.lowerIfFlexible() ?: type.lowerBound,
                                            upperResult?.upperIfFlexible() ?: type.upperBound)
                }
                else {
                    return type.bound().let { approximateTo(it, conf, depth) ?: it }
                }
            }
        }' @ [119:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Nothing, entry1: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Nothing

'type' @ [119:15] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'invoke' @ [120:37] ==> public abstract operator fun invoke(p1: SimpleType, p2: TypeApproximatorConfiguration, depth: @ParameterName Int): UnwrappedType? defined in kotlin.Function3[FunctionInvokeDescriptor]

'type' @ [120:51] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'conf' @ [120:57] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'depth' @ [120:63] ==> value-parameter depth: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'if (type is DynamicType) {
                    return if (conf.dynamic) null else type.bound()
                }
                else if (type is RawType) {
                    return if (conf.rawType) null else type.bound()
                }' @ [122:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'type' @ [122:21] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'if (conf.dynamic) null else type.bound()' @ [123:28] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: UnwrappedType?, elseBranch: UnwrappedType?): UnwrappedType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> UnwrappedType?

'conf' @ [123:32] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'dynamic' @ [123:37] ==> public open val dynamic: Boolean defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration[PropertyDescriptorImpl]

'type' @ [123:56] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'invoke' @ [123:61] ==> public abstract operator fun FlexibleType.invoke(): SimpleType defined in kotlin.Function1[FunctionInvokeDescriptor]

'type' @ [125:26] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'if (conf.rawType) null else type.bound()' @ [126:28] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: UnwrappedType?, elseBranch: UnwrappedType?): UnwrappedType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> UnwrappedType?

'conf' @ [126:32] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'rawType' @ [126:37] ==> public open val rawType: Boolean defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration[PropertyDescriptorImpl]

'type' @ [126:56] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'invoke' @ [126:61] ==> public abstract operator fun FlexibleType.invoke(): SimpleType defined in kotlin.Function1[FunctionInvokeDescriptor]

'assert' @ [129:17] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'type' @ [129:24] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'type' @ [130:61] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'java' @ [130:73] ==> public val <T> KClass<out UnwrappedType>.java: Class<out UnwrappedType> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> Captured(out UnwrappedType)

'canonicalName' @ [130:78] ==> public final val <T : (Any..Any?)> Class<out UnwrappedType>.canonicalName: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Captured(out UnwrappedType)

'type' @ [130:102] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'if (conf.flexible) {
                    /**
                     * Let inputType = L_1..U_1; resultType = L_2..U_2
                     * We should create resultType such as inputType <: resultType.
                     * It means that if A <: inputType, then A <: U_1. And, because inputType <: resultType,
                     * A <: resultType => A <: U_2. I.e. for every type A such A <: U_1, A <: U_2 => U_1 <: U_2.
                     *
                     * Similar for L_1 <: L_2: Let B : resultType <: B. L_2 <: B and L_1 <: B.
                     * I.e. for every type B such as L_2 <: B, L_1 <: B. For example B = L_2.
                     */

                    val lowerResult = approximateTo(type.lowerBound, conf, depth)
                    val upperResult = approximateTo(type.upperBound, conf, depth)
                    if (lowerResult == null && upperResult == null) return null

                    /**
                     * If C <: L..U then C <: L.
                     * inputType.lower <: lowerResult => inputType.lower <: lowerResult?.lowerIfFlexible()
                     * i.e. this type is correct. We use this type, because this type more flexible.
                     *
                     * If U_1 <: U_2.lower .. U_2.upper, then we know only that U_1 <: U_2.upper.
                     */
                    return KotlinTypeFactory.flexibleType(lowerResult?.lowerIfFlexible() ?: type.lowerBound,
                                            upperResult?.upperIfFlexible() ?: type.upperBound)
                }
                else {
                    return type.bound().let { approximateTo(it, conf, depth) ?: it }
                }' @ [133:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nothing, elseBranch: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nothing

'conf' @ [133:21] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'flexible' @ [133:26] ==> public open val flexible: Boolean defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration[PropertyDescriptorImpl]

'invoke' @ [144:39] ==> public abstract operator fun invoke(p1: SimpleType, p2: TypeApproximatorConfiguration, depth: @ParameterName Int): UnwrappedType? defined in kotlin.Function3[FunctionInvokeDescriptor]

'type' @ [144:53] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'lowerBound' @ [144:58] ==> public final val lowerBound: SimpleType defined in org.jetbrains.kotlin.types.FlexibleType[DeserializedPropertyDescriptor]

'conf' @ [144:70] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'depth' @ [144:76] ==> value-parameter depth: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'invoke' @ [145:39] ==> public abstract operator fun invoke(p1: SimpleType, p2: TypeApproximatorConfiguration, depth: @ParameterName Int): UnwrappedType? defined in kotlin.Function3[FunctionInvokeDescriptor]

'type' @ [145:53] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'upperBound' @ [145:58] ==> public final val upperBound: SimpleType defined in org.jetbrains.kotlin.types.FlexibleType[DeserializedPropertyDescriptor]

'conf' @ [145:70] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'depth' @ [145:76] ==> value-parameter depth: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'lowerResult' @ [146:25] ==> val lowerResult: UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[LocalVariableDescriptor]

'upperResult' @ [146:48] ==> val upperResult: UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[LocalVariableDescriptor]

'KotlinTypeFactory' @ [155:28] ==> public object KotlinTypeFactory defined in org.jetbrains.kotlin.types[FakeCallableDescriptorForObject]

'flexibleType' @ [155:46] ==> @JvmStatic public final fun flexibleType(lowerBound: SimpleType, upperBound: SimpleType): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinTypeFactory[DeserializedSimpleFunctionDescriptor]

'lowerResult' @ [155:59] ==> val lowerResult: UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[LocalVariableDescriptor]

'lowerIfFlexible' @ [155:72] ==> public fun KotlinType.lowerIfFlexible(): SimpleType defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'type' @ [155:93] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'lowerBound' @ [155:98] ==> public final val lowerBound: SimpleType defined in org.jetbrains.kotlin.types.FlexibleType[DeserializedPropertyDescriptor]

'upperResult' @ [156:45] ==> val upperResult: UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[LocalVariableDescriptor]

'upperIfFlexible' @ [156:58] ==> public fun KotlinType.upperIfFlexible(): SimpleType defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'type' @ [156:79] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'upperBound' @ [156:84] ==> public final val upperBound: SimpleType defined in org.jetbrains.kotlin.types.FlexibleType[DeserializedPropertyDescriptor]

'type' @ [159:28] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'invoke' @ [159:33] ==> public abstract operator fun FlexibleType.invoke(): SimpleType defined in kotlin.Function1[FunctionInvokeDescriptor]

'let' @ [159:41] ==> @InlineOnly public inline fun <T, R> SimpleType.let(block: (SimpleType) -> UnwrappedType): UnwrappedType defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SimpleType
    <R> -> UnwrappedType

'invoke' @ [159:47] ==> public abstract operator fun invoke(p1: SimpleType, p2: TypeApproximatorConfiguration, depth: @ParameterName Int): UnwrappedType? defined in kotlin.Function3[FunctionInvokeDescriptor]

'it' @ [159:61] ==> value-parameter it: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo.<anonymous>[ValueParameterDescriptorImpl]

'conf' @ [159:65] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'depth' @ [159:71] ==> value-parameter depth: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'it' @ [159:81] ==> value-parameter it: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [166:31] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[ValueParameterDescriptorImpl]

'constructor' @ [166:36] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'assert' @ [167:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'typeConstructor' @ [167:16] ==> val typeConstructor: TypeConstructor defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[LocalVariableDescriptor]

'type' @ [168:44] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[ValueParameterDescriptorImpl]

'typeConstructor' @ [168:75] ==> val typeConstructor: TypeConstructor defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[LocalVariableDescriptor]

'java' @ [168:98] ==> public val <T> KClass<out TypeConstructor>.java: Class<out TypeConstructor> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> Captured(out TypeConstructor)

'canonicalName' @ [168:103] ==> public final val <T : (Any..Any?)> Class<out TypeConstructor>.canonicalName: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Captured(out TypeConstructor)

'assert' @ [170:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'typeConstructor' @ [170:16] ==> val typeConstructor: TypeConstructor defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[LocalVariableDescriptor]

'supertypes' @ [170:32] ==> public final val TypeConstructor.supertypes: Collection<(KotlinType..KotlinType?)>[MyPropertyDescriptor]

'isNotEmpty' @ [170:43] ==> @InlineOnly public inline fun <T> Collection<(KotlinType..KotlinType?)>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)

'type' @ [171:69] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[ValueParameterDescriptorImpl]

'typeConstructor' @ [175:24] ==> val typeConstructor: TypeConstructor defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[LocalVariableDescriptor]

'supertypes' @ [175:40] ==> public final val TypeConstructor.supertypes: Collection<(KotlinType..KotlinType?)>[MyPropertyDescriptor]

'map' @ [175:51] ==> public inline fun <T, R> Iterable<(KotlinType..KotlinType?)>.map(transform: ((KotlinType..KotlinType?)) -> UnwrappedType): List<UnwrappedType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)
    <R> -> UnwrappedType

'if (toSuper) approximateToSuperType(it.unwrap(), conf, depth) else approximateToSubType(it.unwrap(), conf, depth)' @ [176:27] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: UnwrappedType?, elseBranch: UnwrappedType?): UnwrappedType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> UnwrappedType?

'toSuper' @ [176:31] ==> value-parameter toSuper: Boolean defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[ValueParameterDescriptorImpl]

'approximateToSuperType' @ [176:40] ==> private final fun approximateToSuperType(type: UnwrappedType, conf: TypeApproximatorConfiguration, depth: Int): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'it' @ [176:63] ==> value-parameter it: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType.<anonymous>[ValueParameterDescriptorImpl]

'unwrap' @ [176:66] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'conf' @ [176:76] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[ValueParameterDescriptorImpl]

'depth' @ [176:82] ==> value-parameter depth: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[ValueParameterDescriptorImpl]

'approximateToSubType' @ [176:94] ==> private final fun approximateToSubType(type: UnwrappedType, conf: TypeApproximatorConfiguration, depth: Int): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'it' @ [176:115] ==> value-parameter it: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType.<anonymous>[ValueParameterDescriptorImpl]

'unwrap' @ [176:118] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'conf' @ [176:128] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[ValueParameterDescriptorImpl]

'depth' @ [176:134] ==> value-parameter depth: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[ValueParameterDescriptorImpl]

'if (newType != null) {
                thereIsApproximation = true
                newType
            } else it.unwrap()' @ [177:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: UnwrappedType, elseBranch: UnwrappedType): UnwrappedType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> UnwrappedType

'newType' @ [177:17] ==> val newType: UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType.<anonymous>[LocalVariableDescriptor]

'thereIsApproximation' @ [178:17] ==> var thereIsApproximation: Boolean defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[LocalVariableDescriptor]

'newType' @ [179:17] ==> val newType: UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType.<anonymous>[LocalVariableDescriptor]

'it' @ [180:20] ==> value-parameter it: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType.<anonymous>[ValueParameterDescriptorImpl]

'unwrap' @ [180:23] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'when (conf.intersection) {
            ALLOWED -> if (!thereIsApproximation) return null else intersectTypes(newTypes)
            TO_FIRST -> if (toSuper) newTypes.first() else return type.defaultResult(toSuper = false)
            // commonSupertypeCalculator should handle flexible types correctly
            TO_COMMON_SUPERTYPE -> if (toSuper) NewCommonSuperTypeCalculator.commonSuperType(newTypes) else return type.defaultResult(toSuper = false)
        }' @ [189:26] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: UnwrappedType, entry1: UnwrappedType, entry2: UnwrappedType): UnwrappedType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> UnwrappedType

'conf' @ [189:32] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[ValueParameterDescriptorImpl]

'intersection' @ [189:37] ==> public open val intersection: TypeApproximatorConfiguration.IntersectionStrategy defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration[PropertyDescriptorImpl]

'ALLOWED' @ [190:13] ==> enum entry ALLOWED defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration.IntersectionStrategy[FakeCallableDescriptorForObject]

'if (!thereIsApproximation) return null else intersectTypes(newTypes)' @ [190:24] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: UnwrappedType, elseBranch: UnwrappedType): UnwrappedType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> UnwrappedType

'!' @ [190:28] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'thereIsApproximation' @ [190:29] ==> var thereIsApproximation: Boolean defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[LocalVariableDescriptor]

'intersectTypes' @ [190:68] ==> public fun intersectTypes(types: List<UnwrappedType>): UnwrappedType defined in org.jetbrains.kotlin.types.checker[DeserializedSimpleFunctionDescriptor]

'newTypes' @ [190:83] ==> val newTypes: List<UnwrappedType> defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[LocalVariableDescriptor]

'TO_FIRST' @ [191:13] ==> enum entry TO_FIRST defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration.IntersectionStrategy[FakeCallableDescriptorForObject]

'if (toSuper) newTypes.first() else return type.defaultResult(toSuper = false)' @ [191:25] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: UnwrappedType, elseBranch: UnwrappedType): UnwrappedType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> UnwrappedType

'toSuper' @ [191:29] ==> value-parameter toSuper: Boolean defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[ValueParameterDescriptorImpl]

'newTypes' @ [191:38] ==> val newTypes: List<UnwrappedType> defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[LocalVariableDescriptor]

'first' @ [191:47] ==> public fun <T> List<UnwrappedType>.first(): UnwrappedType defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> UnwrappedType

'type' @ [191:67] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[ValueParameterDescriptorImpl]

'defaultResult' @ [191:72] ==> private final fun SimpleType.defaultResult(toSuper: Boolean): SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'TO_COMMON_SUPERTYPE' @ [193:13] ==> enum entry TO_COMMON_SUPERTYPE defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration.IntersectionStrategy[FakeCallableDescriptorForObject]

'if (toSuper) NewCommonSuperTypeCalculator.commonSuperType(newTypes) else return type.defaultResult(toSuper = false)' @ [193:36] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: UnwrappedType, elseBranch: UnwrappedType): UnwrappedType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> UnwrappedType

'toSuper' @ [193:40] ==> value-parameter toSuper: Boolean defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[ValueParameterDescriptorImpl]

'commonSuperType' @ [193:78] ==> public final fun commonSuperType(types: List<UnwrappedType>): UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.NewCommonSuperTypeCalculator[SimpleFunctionDescriptorImpl]

'newTypes' @ [193:94] ==> val newTypes: List<UnwrappedType> defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[LocalVariableDescriptor]

'type' @ [193:116] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[ValueParameterDescriptorImpl]

'defaultResult' @ [193:121] ==> private final fun SimpleType.defaultResult(toSuper: Boolean): SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'if (type.isMarkedNullable) baseResult.makeNullableAsSpecified(true) else baseResult' @ [196:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: UnwrappedType?, elseBranch: UnwrappedType?): UnwrappedType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> UnwrappedType?

'type' @ [196:20] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[ValueParameterDescriptorImpl]

'isMarkedNullable' @ [196:25] ==> public abstract val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'baseResult' @ [196:43] ==> val baseResult: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[LocalVariableDescriptor]

'makeNullableAsSpecified' @ [196:54] ==> public abstract fun makeNullableAsSpecified(newNullability: Boolean): UnwrappedType defined in org.jetbrains.kotlin.types.UnwrappedType[DeserializedSimpleFunctionDescriptor]

'baseResult' @ [196:89] ==> val baseResult: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateIntersectionType[LocalVariableDescriptor]

'type' @ [200:26] ==> value-parameter type: NewCapturedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[ValueParameterDescriptorImpl]

'constructor' @ [200:31] ==> public open val constructor: NewCapturedTypeConstructor defined in org.jetbrains.kotlin.types.checker.NewCapturedType[DeserializedPropertyDescriptor]

'supertypes' @ [200:43] ==> public final val NewCapturedTypeConstructor.supertypes: List<UnwrappedType>[MyPropertyDescriptor]

'when (supertypes.size) {
            0 -> type.builtIns.nullableAnyType // Let C = in Int, then superType for C and C? is Any?
            1 -> supertypes.single()
            else -> intersectTypes(supertypes)
        }' @ [201:29] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: UnwrappedType, entry1: UnwrappedType, entry2: UnwrappedType): UnwrappedType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> UnwrappedType

'supertypes' @ [201:35] ==> val supertypes: List<UnwrappedType> defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[LocalVariableDescriptor]

'size' @ [201:46] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'type' @ [202:18] ==> value-parameter type: NewCapturedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[ValueParameterDescriptorImpl]

'builtIns' @ [202:23] ==> public val KotlinType.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.types.typeUtil[DeserializedPropertyDescriptor]

'nullableAnyType' @ [202:32] ==> public final val KotlinBuiltIns.nullableAnyType: SimpleType[MyPropertyDescriptor]

'supertypes' @ [203:18] ==> val supertypes: List<UnwrappedType> defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[LocalVariableDescriptor]

'single' @ [203:29] ==> public fun <T> List<UnwrappedType>.single(): UnwrappedType defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> UnwrappedType

'intersectTypes' @ [204:21] ==> public fun intersectTypes(types: List<UnwrappedType>): UnwrappedType defined in org.jetbrains.kotlin.types.checker[DeserializedSimpleFunctionDescriptor]

'supertypes' @ [204:36] ==> val supertypes: List<UnwrappedType> defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[LocalVariableDescriptor]

'type' @ [206:27] ==> value-parameter type: NewCapturedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[ValueParameterDescriptorImpl]

'lowerType' @ [206:32] ==> public final val lowerType: UnwrappedType? defined in org.jetbrains.kotlin.types.checker.NewCapturedType[DeserializedPropertyDescriptor]

'type' @ [206:45] ==> value-parameter type: NewCapturedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[ValueParameterDescriptorImpl]

'builtIns' @ [206:50] ==> public val KotlinType.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.types.typeUtil[DeserializedPropertyDescriptor]

'nothingType' @ [206:59] ==> public final val KotlinBuiltIns.nothingType: SimpleType[MyPropertyDescriptor]

'conf' @ [208:13] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[ValueParameterDescriptorImpl]

'invoke' @ [208:18] ==> public abstract operator fun invoke(p1: NewCapturedType): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'type' @ [208:31] ==> value-parameter type: NewCapturedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[ValueParameterDescriptorImpl]

'approximateToSuperType' @ [217:17] ==> private final fun approximateToSuperType(type: UnwrappedType, conf: TypeApproximatorConfiguration, depth: Int): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'baseSuperType' @ [217:40] ==> val baseSuperType: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[LocalVariableDescriptor]

'conf' @ [217:55] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[ValueParameterDescriptorImpl]

'depth' @ [217:61] ==> value-parameter depth: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[ValueParameterDescriptorImpl]

'approximateToSubType' @ [217:79] ==> private final fun approximateToSubType(type: UnwrappedType, conf: TypeApproximatorConfiguration, depth: Int): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'baseSubType' @ [217:100] ==> val baseSubType: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[LocalVariableDescriptor]

'conf' @ [217:113] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[ValueParameterDescriptorImpl]

'depth' @ [217:119] ==> value-parameter depth: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[ValueParameterDescriptorImpl]

'if (toSuper) approximateToSuperType(baseSuperType, conf, depth) ?: baseSuperType else approximateToSubType(baseSubType, conf, depth) ?: baseSubType' @ [221:26] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: UnwrappedType, elseBranch: UnwrappedType): UnwrappedType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> UnwrappedType

'toSuper' @ [221:30] ==> value-parameter toSuper: Boolean defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[ValueParameterDescriptorImpl]

'approximateToSuperType' @ [221:39] ==> private final fun approximateToSuperType(type: UnwrappedType, conf: TypeApproximatorConfiguration, depth: Int): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'baseSuperType' @ [221:62] ==> val baseSuperType: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[LocalVariableDescriptor]

'conf' @ [221:77] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[ValueParameterDescriptorImpl]

'depth' @ [221:83] ==> value-parameter depth: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[ValueParameterDescriptorImpl]

'baseSuperType' @ [221:93] ==> val baseSuperType: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[LocalVariableDescriptor]

'approximateToSubType' @ [221:112] ==> private final fun approximateToSubType(type: UnwrappedType, conf: TypeApproximatorConfiguration, depth: Int): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'baseSubType' @ [221:133] ==> val baseSubType: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[LocalVariableDescriptor]

'conf' @ [221:146] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[ValueParameterDescriptorImpl]

'depth' @ [221:152] ==> value-parameter depth: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[ValueParameterDescriptorImpl]

'baseSubType' @ [221:162] ==> val baseSubType: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[LocalVariableDescriptor]

'if (type.isMarkedNullable) baseResult.makeNullableAsSpecified(true) else baseResult' @ [225:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: UnwrappedType?, elseBranch: UnwrappedType?): UnwrappedType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> UnwrappedType?

'type' @ [225:20] ==> value-parameter type: NewCapturedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[ValueParameterDescriptorImpl]

'isMarkedNullable' @ [225:25] ==> public open val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.checker.NewCapturedType[DeserializedPropertyDescriptor]

'baseResult' @ [225:43] ==> val baseResult: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[LocalVariableDescriptor]

'makeNullableAsSpecified' @ [225:54] ==> public abstract fun makeNullableAsSpecified(newNullability: Boolean): UnwrappedType defined in org.jetbrains.kotlin.types.UnwrappedType[DeserializedSimpleFunctionDescriptor]

'baseResult' @ [225:89] ==> val baseResult: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateCapturedType[LocalVariableDescriptor]

'approximateTo' @ [229:13] ==> private final fun approximateTo(type: SimpleType, conf: TypeApproximatorConfiguration, toSuper: Boolean, depth: Int): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'type' @ [229:27] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateSimpleToSuperType[ValueParameterDescriptorImpl]

'conf' @ [229:33] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateSimpleToSuperType[ValueParameterDescriptorImpl]

'depth' @ [229:63] ==> value-parameter depth: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateSimpleToSuperType[ValueParameterDescriptorImpl]

'approximateTo' @ [231:13] ==> private final fun approximateTo(type: SimpleType, conf: TypeApproximatorConfiguration, toSuper: Boolean, depth: Int): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'type' @ [231:27] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateSimpleToSubType[ValueParameterDescriptorImpl]

'conf' @ [231:33] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateSimpleToSubType[ValueParameterDescriptorImpl]

'depth' @ [231:64] ==> value-parameter depth: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateSimpleToSubType[ValueParameterDescriptorImpl]

'type' @ [234:13] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'isError' @ [234:18] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types[DeserializedPropertyDescriptor]

'if (conf.errorType) null else type.defaultResult(toSuper)' @ [236:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: UnwrappedType?, elseBranch: UnwrappedType?): UnwrappedType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> UnwrappedType?

'conf' @ [236:24] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'errorType' @ [236:29] ==> public open val errorType: Boolean defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration[PropertyDescriptorImpl]

'type' @ [236:50] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'defaultResult' @ [236:55] ==> private final fun SimpleType.defaultResult(toSuper: Boolean): SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'toSuper' @ [236:69] ==> value-parameter toSuper: Boolean defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'depth' @ [239:13] ==> value-parameter depth: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'type' @ [239:31] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'defaultResult' @ [239:36] ==> private final fun SimpleType.defaultResult(toSuper: Boolean): SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'toSuper' @ [239:50] ==> value-parameter toSuper: Boolean defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'type' @ [241:13] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'arguments' @ [241:18] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'isNotEmpty' @ [241:28] ==> @InlineOnly public inline fun <T> Collection<TypeProjection>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection

'approximateParametrizedType' @ [242:20] ==> private final fun approximateParametrizedType(type: SimpleType, conf: TypeApproximatorConfiguration, toSuper: Boolean, depth: Int): SimpleType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'type' @ [242:48] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'conf' @ [242:54] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'toSuper' @ [242:60] ==> value-parameter toSuper: Boolean defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'depth' @ [242:69] ==> value-parameter depth: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'type' @ [245:31] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'constructor' @ [245:36] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'typeConstructor' @ [247:13] ==> val typeConstructor: TypeConstructor defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[LocalVariableDescriptor]

'assert' @ [248:13] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'type' @ [248:20] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'+' @ [249:17] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'typeConstructor' @ [249:91] ==> val typeConstructor: TypeConstructor defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[LocalVariableDescriptor]

'type' @ [250:31] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'java' @ [250:43] ==> public val <T> KClass<out SimpleType>.java: Class<out SimpleType> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> Captured(out SimpleType)

'canonicalName' @ [250:48] ==> public final val <T : (Any..Any?)> Class<out SimpleType>.canonicalName: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Captured(out SimpleType)

'type' @ [250:83] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'approximateCapturedType' @ [252:20] ==> private final fun approximateCapturedType(type: NewCapturedType, conf: TypeApproximatorConfiguration, toSuper: Boolean, depth: Int): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'type' @ [252:44] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'conf' @ [252:69] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'toSuper' @ [252:75] ==> value-parameter toSuper: Boolean defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'depth' @ [252:84] ==> value-parameter depth: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'typeConstructor' @ [255:13] ==> val typeConstructor: TypeConstructor defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[LocalVariableDescriptor]

'approximateIntersectionType' @ [256:20] ==> private final fun approximateIntersectionType(type: SimpleType, conf: TypeApproximatorConfiguration, toSuper: Boolean, depth: Int): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'type' @ [256:48] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'conf' @ [256:54] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'toSuper' @ [256:60] ==> value-parameter toSuper: Boolean defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'depth' @ [256:69] ==> value-parameter depth: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'typeConstructor' @ [259:13] ==> val typeConstructor: TypeConstructor defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[LocalVariableDescriptor]

'if (conf.typeVariable(typeConstructor)) null else type.defaultResult(toSuper)' @ [260:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: UnwrappedType?, elseBranch: UnwrappedType?): UnwrappedType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> UnwrappedType?

'conf' @ [260:24] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'invoke' @ [260:29] ==> public abstract operator fun invoke(p1: TypeVariableTypeConstructor): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'typeConstructor' @ [260:42] ==> val typeConstructor: TypeConstructor defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[LocalVariableDescriptor]

'type' @ [260:70] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'defaultResult' @ [260:75] ==> private final fun SimpleType.defaultResult(toSuper: Boolean): SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'toSuper' @ [260:89] ==> value-parameter toSuper: Boolean defined in org.jetbrains.kotlin.types.TypeApproximator.approximateTo[ValueParameterDescriptorImpl]

'when (effectiveVariance) {
                Variance.OUT_VARIANCE -> toSuper
                Variance.IN_VARIANCE -> !toSuper
                Variance.INVARIANT -> throw AssertionError("Incorrect variance $effectiveVariance")
            }' @ [267:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean, entry2: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'effectiveVariance' @ [267:19] ==> value-parameter effectiveVariance: Variance defined in org.jetbrains.kotlin.types.TypeApproximator.isApproximateDirectionToSuper[ValueParameterDescriptorImpl]

'OUT_VARIANCE' @ [268:26] ==> enum entry OUT_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'toSuper' @ [268:42] ==> value-parameter toSuper: Boolean defined in org.jetbrains.kotlin.types.TypeApproximator.isApproximateDirectionToSuper[ValueParameterDescriptorImpl]

'IN_VARIANCE' @ [269:26] ==> enum entry IN_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'!' @ [269:41] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'toSuper' @ [269:42] ==> value-parameter toSuper: Boolean defined in org.jetbrains.kotlin.types.TypeApproximator.isApproximateDirectionToSuper[ValueParameterDescriptorImpl]

'INVARIANT' @ [270:26] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'AssertionError' @ [270:45] ==> public final fun <init>(p0: (Any..Any?)): AssertionError /* = AssertionError */ defined in kotlin.AssertionError[TypeAliasConstructorDescriptorImpl]

'effectiveVariance' @ [270:81] ==> value-parameter effectiveVariance: Variance defined in org.jetbrains.kotlin.types.TypeApproximator.isApproximateDirectionToSuper[ValueParameterDescriptorImpl]

'type' @ [274:26] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'constructor' @ [274:31] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'parameters' @ [274:43] ==> public final val TypeConstructor.parameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'type' @ [275:25] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'arguments' @ [275:30] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'parameters' @ [276:13] ==> val parameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'size' @ [276:24] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'arguments' @ [276:32] ==> val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'size' @ [276:42] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'if (conf.errorType) {
                ErrorUtils.createErrorType("Inconsistent type: $type (parameters.size = ${parameters.size}, arguments.size = ${arguments.size})")
            }
            else type.defaultResult(toSuper)' @ [277:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: SimpleType?, elseBranch: SimpleType?): SimpleType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> SimpleType?

'conf' @ [277:24] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'errorType' @ [277:29] ==> public open val errorType: Boolean defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration[PropertyDescriptorImpl]

'createErrorType' @ [278:28] ==> @NotNull public open fun createErrorType(@NotNull p0: String): SimpleType defined in org.jetbrains.kotlin.types.ErrorUtils[JavaMethodDescriptor]

'type' @ [278:65] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'parameters' @ [278:91] ==> val parameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'size' @ [278:102] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'arguments' @ [278:128] ==> val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'size' @ [278:138] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'type' @ [280:18] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'defaultResult' @ [280:23] ==> private final fun SimpleType.defaultResult(toSuper: Boolean): SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'toSuper' @ [280:37] ==> value-parameter toSuper: Boolean defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'arrayOfNulls' @ [283:28] ==> public fun <reified @PureReifiable T> arrayOfNulls(size: Int): Array<TypeProjection?> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified @PureReifiable T> -> TypeProjection?

'arguments' @ [283:58] ==> val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'size' @ [283:68] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'arguments' @ [285:29] ==> val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'indices' @ [285:39] ==> public val Collection<*>.indices: IntRange defined in kotlin.collections[DeserializedPropertyDescriptor]

'parameters' @ [286:29] ==> val parameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'index' @ [286:40] ==> val index: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'arguments' @ [287:28] ==> val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'index' @ [287:38] ==> val index: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'argument' @ [289:17] ==> val argument: TypeProjection defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'isStarProjection' @ [289:26] ==> public final val TypeProjection.isStarProjection: Boolean[MyPropertyDescriptor]

'argument' @ [291:32] ==> val argument: TypeProjection defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'type' @ [291:41] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'unwrap' @ [291:46] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'NewKotlinTypeChecker' @ [292:37] ==> public object NewKotlinTypeChecker : KotlinTypeChecker defined in org.jetbrains.kotlin.types.checker[FakeCallableDescriptorForObject]

'effectiveVariance' @ [292:58] ==> public final fun effectiveVariance(declared: Variance, useSite: Variance): Variance? defined in org.jetbrains.kotlin.types.checker.NewKotlinTypeChecker[DeserializedSimpleFunctionDescriptor]

'parameter' @ [292:76] ==> val parameter: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'variance' @ [292:86] ==> public final val TypeParameterDescriptor.variance: Variance[MyPropertyDescriptor]

'argument' @ [292:96] ==> val argument: TypeProjection defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'projectionKind' @ [292:105] ==> public final val TypeProjection.projectionKind: Variance[MyPropertyDescriptor]

'when (effectiveVariance) {
                null -> {
                    return if (conf.errorType) {
                        ErrorUtils.createErrorType("Inconsistent type: $type ($index parameter has declared variance: ${parameter.variance}, " +
                                                   "but argument variance is ${argument.projectionKind})")
                    } else type.defaultResult(toSuper)
                }
                Variance.OUT_VARIANCE, Variance.IN_VARIANCE -> {
                    /**
                     * Out<Foo> <: Out<superType(Foo)>
                     * Inv<out Foo> <: Inv<out superType(Foo)>

                     * In<Foo> <: In<subType(Foo)>
                     * Inv<in Foo> <: Inv<in subType(Foo)>
                     */
                    val approximatedArgument = argumentType.let {
                        if (isApproximateDirectionToSuper(effectiveVariance, toSuper)) {
                            approximateToSuperType(it, conf, depth)
                        }
                        else {
                            approximateToSubType(it, conf, depth)
                        }
                    } ?: continue@loop

                    if (parameter.variance == Variance.INVARIANT) {
                        newArguments[index] = TypeProjectionImpl(effectiveVariance, approximatedArgument)
                    } else {
                        newArguments[index] = approximatedArgument.asTypeProjection()
                    }
                }
                Variance.INVARIANT -> {
                    if (!toSuper) {
                        // Inv<Foo> cannot be approximated to subType
                        val toSubType = approximateToSubType(argumentType, conf, depth) ?: continue@loop

                        // Inv<Foo!> is supertype for Inv<Foo?>
                        if (!NewKotlinTypeChecker.equalTypes(argumentType, toSubType)) return type.defaultResult(toSuper)

                        // also Captured(out Nothing) = Nothing
                        newArguments[index] = toSubType.asTypeProjection()
                        continue@loop
                    }

                    /**
                     * Example with non-trivial both type approximations:
                     * Inv<In<C>> where C = in Int
                     * Inv<In<C>> <: Inv<out In<Int>>
                     * Inv<In<C>> <: Inv<in In<Any?>>
                     *
                     * So such case is rare and we will chose Inv<out In<Int>> for now.
                     *
                     * Note that for case Inv<C> we will chose Inv<in Int>, because it is more informative then Inv<out Any?>.
                     * May be we should do the same for deeper types, but not now.
                     */
                    if (argumentType is NewCapturedType) {
                        val subType = approximateToSubType(argumentType, conf, depth) ?: continue@loop
                        if (!subType.isTrivialSub()) {
                            newArguments[index] = TypeProjectionImpl(Variance.IN_VARIANCE, subType)
                            continue@loop
                        }
                    }

                    val approximatedSuperType = approximateToSuperType(argumentType, conf, depth) ?: continue@loop // null means that this type we can leave as is
                    if (approximatedSuperType.isTrivialSuper()) {
                        val approximatedSubType = approximateToSubType(argumentType, conf, depth) ?: continue@loop // seems like this is never null
                        if (!approximatedSubType.isTrivialSub()) {
                            newArguments[index] = TypeProjectionImpl(Variance.IN_VARIANCE, approximatedSubType)
                            continue@loop
                        }
                    }

                    newArguments[index] = TypeProjectionImpl(Variance.OUT_VARIANCE, approximatedSuperType)
                }
            }' @ [293:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'effectiveVariance' @ [293:19] ==> val effectiveVariance: Variance? defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'if (conf.errorType) {
                        ErrorUtils.createErrorType("Inconsistent type: $type ($index parameter has declared variance: ${parameter.variance}, " +
                                                   "but argument variance is ${argument.projectionKind})")
                    } else type.defaultResult(toSuper)' @ [295:28] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: SimpleType?, elseBranch: SimpleType?): SimpleType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> SimpleType?

'conf' @ [295:32] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'errorType' @ [295:37] ==> public open val errorType: Boolean defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration[PropertyDescriptorImpl]

'createErrorType' @ [296:36] ==> @NotNull public open fun createErrorType(@NotNull p0: String): SimpleType defined in org.jetbrains.kotlin.types.ErrorUtils[JavaMethodDescriptor]

'+' @ [296:52] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'type' @ [296:73] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'index' @ [296:80] ==> val index: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'parameter' @ [296:121] ==> val parameter: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'variance' @ [296:131] ==> public final val TypeParameterDescriptor.variance: Variance[MyPropertyDescriptor]

'argument' @ [297:80] ==> val argument: TypeProjection defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'projectionKind' @ [297:89] ==> public final val TypeProjection.projectionKind: Variance[MyPropertyDescriptor]

'type' @ [298:28] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'defaultResult' @ [298:33] ==> private final fun SimpleType.defaultResult(toSuper: Boolean): SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'toSuper' @ [298:47] ==> value-parameter toSuper: Boolean defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'OUT_VARIANCE' @ [300:26] ==> enum entry OUT_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'IN_VARIANCE' @ [300:49] ==> enum entry IN_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'argumentType' @ [308:48] ==> val argumentType: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'let' @ [308:61] ==> @InlineOnly public inline fun <T, R> UnwrappedType.let(block: (UnwrappedType) -> UnwrappedType?): UnwrappedType? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> UnwrappedType
    <R> -> UnwrappedType?

'if (isApproximateDirectionToSuper(effectiveVariance, toSuper)) {
                            approximateToSuperType(it, conf, depth)
                        }
                        else {
                            approximateToSubType(it, conf, depth)
                        }' @ [309:25] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: UnwrappedType?, elseBranch: UnwrappedType?): UnwrappedType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> UnwrappedType?

'isApproximateDirectionToSuper' @ [309:29] ==> private final fun isApproximateDirectionToSuper(effectiveVariance: Variance, toSuper: Boolean): Boolean defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'effectiveVariance' @ [309:59] ==> val effectiveVariance: Variance? defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'toSuper' @ [309:78] ==> value-parameter toSuper: Boolean defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'approximateToSuperType' @ [310:29] ==> private final fun approximateToSuperType(type: UnwrappedType, conf: TypeApproximatorConfiguration, depth: Int): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'it' @ [310:52] ==> value-parameter it: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType.<anonymous>[ValueParameterDescriptorImpl]

'conf' @ [310:56] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'depth' @ [310:62] ==> value-parameter depth: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'approximateToSubType' @ [313:29] ==> private final fun approximateToSubType(type: UnwrappedType, conf: TypeApproximatorConfiguration, depth: Int): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'it' @ [313:50] ==> value-parameter it: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType.<anonymous>[ValueParameterDescriptorImpl]

'conf' @ [313:54] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'depth' @ [313:60] ==> value-parameter depth: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'if (parameter.variance == Variance.INVARIANT) {
                        newArguments[index] = TypeProjectionImpl(effectiveVariance, approximatedArgument)
                    } else {
                        newArguments[index] = approximatedArgument.asTypeProjection()
                    }' @ [317:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'parameter' @ [317:25] ==> val parameter: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'variance' @ [317:35] ==> public final val TypeParameterDescriptor.variance: Variance[MyPropertyDescriptor]

'INVARIANT' @ [317:56] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'newArguments' @ [318:25] ==> val newArguments: Array<TypeProjection?> defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'index' @ [318:38] ==> val index: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'TypeProjectionImpl' @ [318:47] ==> public constructor TypeProjectionImpl(@NotNull p0: Variance, @NotNull p1: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'effectiveVariance' @ [318:66] ==> val effectiveVariance: Variance? defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'approximatedArgument' @ [318:85] ==> val approximatedArgument: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'newArguments' @ [320:25] ==> val newArguments: Array<TypeProjection?> defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'index' @ [320:38] ==> val index: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'approximatedArgument' @ [320:47] ==> val approximatedArgument: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'asTypeProjection' @ [320:68] ==> public fun KotlinType.asTypeProjection(): TypeProjection defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'INVARIANT' @ [323:26] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'!' @ [324:25] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'toSuper' @ [324:26] ==> value-parameter toSuper: Boolean defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'approximateToSubType' @ [326:41] ==> private final fun approximateToSubType(type: UnwrappedType, conf: TypeApproximatorConfiguration, depth: Int): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'argumentType' @ [326:62] ==> val argumentType: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'conf' @ [326:76] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'depth' @ [326:82] ==> value-parameter depth: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'!' @ [329:29] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'NewKotlinTypeChecker' @ [329:30] ==> public object NewKotlinTypeChecker : KotlinTypeChecker defined in org.jetbrains.kotlin.types.checker[FakeCallableDescriptorForObject]

'equalTypes' @ [329:51] ==> public open fun equalTypes(a: KotlinType, b: KotlinType): Boolean defined in org.jetbrains.kotlin.types.checker.NewKotlinTypeChecker[DeserializedSimpleFunctionDescriptor]

'argumentType' @ [329:62] ==> val argumentType: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'toSubType' @ [329:76] ==> val toSubType: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'type' @ [329:95] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'defaultResult' @ [329:100] ==> private final fun SimpleType.defaultResult(toSuper: Boolean): SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'toSuper' @ [329:114] ==> value-parameter toSuper: Boolean defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'newArguments' @ [332:25] ==> val newArguments: Array<TypeProjection?> defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'index' @ [332:38] ==> val index: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'toSubType' @ [332:47] ==> val toSubType: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'asTypeProjection' @ [332:57] ==> public fun KotlinType.asTypeProjection(): TypeProjection defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'argumentType' @ [347:25] ==> val argumentType: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'approximateToSubType' @ [348:39] ==> private final fun approximateToSubType(type: UnwrappedType, conf: TypeApproximatorConfiguration, depth: Int): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'argumentType' @ [348:60] ==> val argumentType: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'conf' @ [348:74] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'depth' @ [348:80] ==> value-parameter depth: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'!' @ [349:29] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'subType' @ [349:30] ==> val subType: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'isTrivialSub' @ [349:38] ==> private final fun UnwrappedType.isTrivialSub(): Boolean defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'newArguments' @ [350:29] ==> val newArguments: Array<TypeProjection?> defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'index' @ [350:42] ==> val index: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'TypeProjectionImpl' @ [350:51] ==> public constructor TypeProjectionImpl(@NotNull p0: Variance, @NotNull p1: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'IN_VARIANCE' @ [350:79] ==> enum entry IN_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'subType' @ [350:92] ==> val subType: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'approximateToSuperType' @ [355:49] ==> private final fun approximateToSuperType(type: UnwrappedType, conf: TypeApproximatorConfiguration, depth: Int): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'argumentType' @ [355:72] ==> val argumentType: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'conf' @ [355:86] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'depth' @ [355:92] ==> value-parameter depth: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'approximatedSuperType' @ [356:25] ==> val approximatedSuperType: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'isTrivialSuper' @ [356:47] ==> private final fun UnwrappedType.isTrivialSuper(): Boolean defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'approximateToSubType' @ [357:51] ==> private final fun approximateToSubType(type: UnwrappedType, conf: TypeApproximatorConfiguration, depth: Int): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'argumentType' @ [357:72] ==> val argumentType: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'conf' @ [357:86] ==> value-parameter conf: TypeApproximatorConfiguration defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'depth' @ [357:92] ==> value-parameter depth: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'!' @ [358:29] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'approximatedSubType' @ [358:30] ==> val approximatedSubType: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'isTrivialSub' @ [358:50] ==> private final fun UnwrappedType.isTrivialSub(): Boolean defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'newArguments' @ [359:29] ==> val newArguments: Array<TypeProjection?> defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'index' @ [359:42] ==> val index: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'TypeProjectionImpl' @ [359:51] ==> public constructor TypeProjectionImpl(@NotNull p0: Variance, @NotNull p1: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'IN_VARIANCE' @ [359:79] ==> enum entry IN_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'approximatedSubType' @ [359:92] ==> val approximatedSubType: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'newArguments' @ [364:21] ==> val newArguments: Array<TypeProjection?> defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'index' @ [364:34] ==> val index: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'TypeProjectionImpl' @ [364:43] ==> public constructor TypeProjectionImpl(@NotNull p0: Variance, @NotNull p1: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'OUT_VARIANCE' @ [364:71] ==> enum entry OUT_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'approximatedSuperType' @ [364:85] ==> val approximatedSuperType: UnwrappedType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'newArguments' @ [369:13] ==> val newArguments: Array<TypeProjection?> defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'all' @ [369:26] ==> public inline fun <T> Array<out TypeProjection?>.all(predicate: (TypeProjection?) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection?

'it' @ [369:32] ==> value-parameter it: TypeProjection? defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType.<anonymous>[ValueParameterDescriptorImpl]

'arguments' @ [371:32] ==> val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'mapIndexed' @ [371:42] ==> public inline fun <T, R> Iterable<TypeProjection>.mapIndexed(transform: (index: Int, TypeProjection) -> TypeProjection): List<TypeProjection> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection
    <R> -> TypeProjection

'newArguments' @ [371:77] ==> val newArguments: Array<TypeProjection?> defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'index' @ [371:90] ==> value-parameter index: Int defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType.<anonymous>[ValueParameterDescriptorImpl]

'oldArgument' @ [371:100] ==> value-parameter oldArgument: TypeProjection defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [372:16] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[ValueParameterDescriptorImpl]

'replace' @ [372:21] ==> @JvmOverloads public fun SimpleType.replace(newArguments: List<TypeProjection> = ..., newAnnotations: Annotations = ...): SimpleType defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'newArgumentsList' @ [372:29] ==> val newArgumentsList: List<TypeProjection> defined in org.jetbrains.kotlin.types.TypeApproximator.approximateParametrizedType[LocalVariableDescriptor]

'if (toSuper) builtIns.nullableAnyType else {
        if (isMarkedNullable) builtIns.nullableNothingType else builtIns.nothingType
    }' @ [375:62] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: SimpleType, elseBranch: SimpleType): SimpleType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> SimpleType

'toSuper' @ [375:66] ==> value-parameter toSuper: Boolean defined in org.jetbrains.kotlin.types.TypeApproximator.defaultResult[ValueParameterDescriptorImpl]

'builtIns' @ [375:75] ==> public val KotlinType.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.types.typeUtil[DeserializedPropertyDescriptor]

'nullableAnyType' @ [375:84] ==> public final val KotlinBuiltIns.nullableAnyType: SimpleType[MyPropertyDescriptor]

'if (isMarkedNullable) builtIns.nullableNothingType else builtIns.nothingType' @ [376:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: SimpleType, elseBranch: SimpleType): SimpleType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> SimpleType

'isMarkedNullable' @ [376:13] ==> public abstract val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'builtIns' @ [376:31] ==> public val KotlinType.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.types.typeUtil[DeserializedPropertyDescriptor]

'nullableNothingType' @ [376:40] ==> public final val KotlinBuiltIns.nullableNothingType: SimpleType[MyPropertyDescriptor]

'builtIns' @ [376:65] ==> public val KotlinType.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.types.typeUtil[DeserializedPropertyDescriptor]

'nothingType' @ [376:74] ==> public final val KotlinBuiltIns.nothingType: SimpleType[MyPropertyDescriptor]

'upperIfFlexible' @ [380:50] ==> public fun KotlinType.upperIfFlexible(): SimpleType defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'isNullableAny' @ [380:68] ==> public fun KotlinType.isNullableAny(): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'lowerIfFlexible' @ [383:48] ==> public fun KotlinType.lowerIfFlexible(): SimpleType defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'isNothing' @ [383:66] ==> public fun KotlinType.isNothing(): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'when (this) {
            is SimpleType -> typeDepth()
            is FlexibleType -> Math.max(lowerBound.typeDepth(), upperBound.typeDepth())
        }' @ [387:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Int, entry1: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Int

'this' @ [387:15] ==> <this> defined in org.jetbrains.kotlin.types.typeDepth[ReceiverParameterDescriptorImpl]

'typeDepth' @ [388:30] ==> internal fun SimpleType.typeDepth(): Int defined in org.jetbrains.kotlin.types in file TypeApproximator.kt[SimpleFunctionDescriptorImpl]

'max' @ [389:37] ==> public open fun max(p0: Int, p1: Int): Int defined in java.lang.Math[JavaMethodDescriptor]

'lowerBound' @ [389:41] ==> public final val lowerBound: SimpleType defined in org.jetbrains.kotlin.types.FlexibleType[DeserializedPropertyDescriptor]

'typeDepth' @ [389:52] ==> internal fun SimpleType.typeDepth(): Int defined in org.jetbrains.kotlin.types in file TypeApproximator.kt[SimpleFunctionDescriptorImpl]

'upperBound' @ [389:65] ==> public final val upperBound: SimpleType defined in org.jetbrains.kotlin.types.FlexibleType[DeserializedPropertyDescriptor]

'typeDepth' @ [389:76] ==> internal fun SimpleType.typeDepth(): Int defined in org.jetbrains.kotlin.types in file TypeApproximator.kt[SimpleFunctionDescriptorImpl]

'this' @ [393:9] ==> <this> defined in org.jetbrains.kotlin.types.typeDepth[ReceiverParameterDescriptorImpl]

'arguments' @ [395:26] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'asSequence' @ [395:36] ==> public fun <T> Iterable<TypeProjection>.asSequence(): Sequence<TypeProjection> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection

'map' @ [395:49] ==> public fun <T, R> Sequence<TypeProjection>.map(transform: (TypeProjection) -> Int): Sequence<Int> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection
    <R> -> Int

'if (it.isStarProjection) 1 else it.type.unwrap().typeDepth()' @ [396:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Int, elseBranch: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Int

'it' @ [396:13] ==> value-parameter it: TypeProjection defined in org.jetbrains.kotlin.types.typeDepth.<anonymous>[ValueParameterDescriptorImpl]

'isStarProjection' @ [396:16] ==> public final val TypeProjection.isStarProjection: Boolean[MyPropertyDescriptor]

'it' @ [396:41] ==> value-parameter it: TypeProjection defined in org.jetbrains.kotlin.types.typeDepth.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [396:44] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'unwrap' @ [396:49] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'typeDepth' @ [396:58] ==> internal fun UnwrappedType.typeDepth(): Int defined in org.jetbrains.kotlin.types in file TypeApproximator.kt[SimpleFunctionDescriptorImpl]

'max' @ [397:7] ==> public fun <T : Comparable<Int>> Sequence<Int>.max(): Int? defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Comparable<T>> -> Int

'maxInArguments' @ [399:12] ==> val maxInArguments: Int defined in org.jetbrains.kotlin.types.typeDepth[LocalVariableDescriptor]

