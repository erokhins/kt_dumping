'variableWithConstraints' @ [46:37] ==> public final val variableWithConstraints: VariableWithConstraints defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.NodeWithDirection[PropertyDescriptorImpl]

'direction' @ [46:65] ==> public final val direction: TypeVariableDirectionCalculator.ResolveDirection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.NodeWithDirection[PropertyDescriptorImpl]

'HashMap' @ [49:30] ==> public final fun <K, V> <init>(): HashMap<Variable /* = VariableWithConstraints */, TypeVariableDirectionCalculator.ResolveDirection> /* = HashMap<Variable /* = VariableWithConstraints */, TypeVariableDirectionCalculator.ResolveDirection> */ defined in kotlin.collections.HashMap[TypeAliasConstructorDescriptorImpl]
Inferred types:
    <K> -> VariableWithConstraints
    <V> -> ResolveDirection

'setupDirections' @ [52:9] ==> private final fun setupDirections(topReturnType: UnwrappedType): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator[SimpleFunctionDescriptorImpl]

'topLevelType' @ [52:25] ==> value-parameter topLevelType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.<init>[ValueParameterDescriptorImpl]

'directions' @ [56:13] ==> private final val directions: HashMap<Variable /* = VariableWithConstraints */, TypeVariableDirectionCalculator.ResolveDirection> /* = HashMap<Variable /* = VariableWithConstraints */, TypeVariableDirectionCalculator.ResolveDirection> */ defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator[PropertyDescriptorImpl]

'getOrDefault' @ [56:24] ==> public open fun getOrDefault(key: Variable /* = VariableWithConstraints */, defaultValue: TypeVariableDirectionCalculator.ResolveDirection): TypeVariableDirectionCalculator.ResolveDirection defined in java.util.HashMap[JavaMethodDescriptor]

'typeVariable' @ [56:37] ==> value-parameter typeVariable: Variable /* = VariableWithConstraints */ defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.getDirection[ValueParameterDescriptorImpl]

'UNKNOWN' @ [56:68] ==> enum entry UNKNOWN defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.ResolveDirection[FakeCallableDescriptorForObject]

'topReturnType' @ [59:9] ==> value-parameter topReturnType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.setupDirections[ValueParameterDescriptorImpl]

'visitType' @ [59:23] ==> private final fun UnwrappedType.visitType(startDirection: TypeVariableDirectionCalculator.ResolveDirection, action: (variable: Variable /* = VariableWithConstraints */, direction: TypeVariableDirectionCalculator.ResolveDirection) -> Unit): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator[SimpleFunctionDescriptorImpl]

'TO_SUBTYPE' @ [59:50] ==> enum entry TO_SUBTYPE defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.ResolveDirection[FakeCallableDescriptorForObject]

'enterToNode' @ [60:13] ==> private final fun enterToNode(variable: Variable /* = VariableWithConstraints */, direction: TypeVariableDirectionCalculator.ResolveDirection): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator[SimpleFunctionDescriptorImpl]

'variableWithConstraints' @ [60:25] ==> value-parameter variableWithConstraints: Variable /* = VariableWithConstraints */ defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.setupDirections.<anonymous>[ValueParameterDescriptorImpl]

'direction' @ [60:50] ==> value-parameter direction: TypeVariableDirectionCalculator.ResolveDirection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.setupDirections.<anonymous>[ValueParameterDescriptorImpl]

'postponedKtPrimitives' @ [62:35] ==> private final val postponedKtPrimitives: List<PostponedResolvedAtom> defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator[PropertyDescriptorImpl]

'postponedArgument' @ [63:31] ==> val postponedArgument: PostponedResolvedAtom defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.setupDirections[LocalVariableDescriptor]

'inputTypes' @ [63:49] ==> public abstract val inputTypes: Collection<UnwrappedType> defined in org.jetbrains.kotlin.resolve.calls.model.PostponedResolvedAtom[PropertyDescriptorImpl]

'inputType' @ [64:17] ==> val inputType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.setupDirections[LocalVariableDescriptor]

'visitType' @ [64:27] ==> private final fun UnwrappedType.visitType(startDirection: TypeVariableDirectionCalculator.ResolveDirection, action: (variable: Variable /* = VariableWithConstraints */, direction: TypeVariableDirectionCalculator.ResolveDirection) -> Unit): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator[SimpleFunctionDescriptorImpl]

'TO_SUBTYPE' @ [64:54] ==> enum entry TO_SUBTYPE defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.ResolveDirection[FakeCallableDescriptorForObject]

'enterToNode' @ [65:21] ==> private final fun enterToNode(variable: Variable /* = VariableWithConstraints */, direction: TypeVariableDirectionCalculator.ResolveDirection): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator[SimpleFunctionDescriptorImpl]

'variableWithConstraints' @ [65:33] ==> value-parameter variableWithConstraints: Variable /* = VariableWithConstraints */ defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.setupDirections.<anonymous>[ValueParameterDescriptorImpl]

'direction' @ [65:58] ==> value-parameter direction: TypeVariableDirectionCalculator.ResolveDirection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.setupDirections.<anonymous>[ValueParameterDescriptorImpl]

'direction' @ [72:13] ==> value-parameter direction: TypeVariableDirectionCalculator.ResolveDirection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.enterToNode[ValueParameterDescriptorImpl]

'UNKNOWN' @ [72:43] ==> enum entry UNKNOWN defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.ResolveDirection[FakeCallableDescriptorForObject]

'directions' @ [74:24] ==> private final val directions: HashMap<Variable /* = VariableWithConstraints */, TypeVariableDirectionCalculator.ResolveDirection> /* = HashMap<Variable /* = VariableWithConstraints */, TypeVariableDirectionCalculator.ResolveDirection> */ defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator[PropertyDescriptorImpl]

'variable' @ [74:35] ==> value-parameter variable: Variable /* = VariableWithConstraints */ defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.enterToNode[ValueParameterDescriptorImpl]

'previous' @ [75:13] ==> val previous: TypeVariableDirectionCalculator.ResolveDirection? defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.enterToNode[LocalVariableDescriptor]

'previous' @ [76:17] ==> val previous: TypeVariableDirectionCalculator.ResolveDirection? defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.enterToNode[LocalVariableDescriptor]

'direction' @ [76:29] ==> value-parameter direction: TypeVariableDirectionCalculator.ResolveDirection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.enterToNode[ValueParameterDescriptorImpl]

'directions' @ [77:17] ==> private final val directions: HashMap<Variable /* = VariableWithConstraints */, TypeVariableDirectionCalculator.ResolveDirection> /* = HashMap<Variable /* = VariableWithConstraints */, TypeVariableDirectionCalculator.ResolveDirection> */ defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator[PropertyDescriptorImpl]

'variable' @ [77:28] ==> value-parameter variable: Variable /* = VariableWithConstraints */ defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.enterToNode[ValueParameterDescriptorImpl]

'UNKNOWN' @ [77:57] ==> enum entry UNKNOWN defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.ResolveDirection[FakeCallableDescriptorForObject]

'directions' @ [82:9] ==> private final val directions: HashMap<Variable /* = VariableWithConstraints */, TypeVariableDirectionCalculator.ResolveDirection> /* = HashMap<Variable /* = VariableWithConstraints */, TypeVariableDirectionCalculator.ResolveDirection> */ defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator[PropertyDescriptorImpl]

'variable' @ [82:20] ==> value-parameter variable: Variable /* = VariableWithConstraints */ defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.enterToNode[ValueParameterDescriptorImpl]

'direction' @ [82:32] ==> value-parameter direction: TypeVariableDirectionCalculator.ResolveDirection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.enterToNode[ValueParameterDescriptorImpl]

'component1' @ [84:15] ==> public final operator fun component1(): VariableWithConstraints defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.NodeWithDirection[SimpleFunctionDescriptorImpl]

'component2' @ [84:30] ==> public final operator fun component2(): TypeVariableDirectionCalculator.ResolveDirection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.NodeWithDirection[SimpleFunctionDescriptorImpl]

'getConstraintDependencies' @ [84:49] ==> private final fun getConstraintDependencies(variable: Variable /* = VariableWithConstraints */, direction: TypeVariableDirectionCalculator.ResolveDirection): List<TypeVariableDirectionCalculator.NodeWithDirection> defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator[SimpleFunctionDescriptorImpl]

'variable' @ [84:75] ==> value-parameter variable: Variable /* = VariableWithConstraints */ defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.enterToNode[ValueParameterDescriptorImpl]

'direction' @ [84:85] ==> value-parameter direction: TypeVariableDirectionCalculator.ResolveDirection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.enterToNode[ValueParameterDescriptorImpl]

'enterToNode' @ [85:13] ==> private final fun enterToNode(variable: Variable /* = VariableWithConstraints */, direction: TypeVariableDirectionCalculator.ResolveDirection): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator[SimpleFunctionDescriptorImpl]

'otherVariable' @ [85:25] ==> val otherVariable: VariableWithConstraints defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.enterToNode[LocalVariableDescriptor]

'otherDirection' @ [85:40] ==> val otherDirection: TypeVariableDirectionCalculator.ResolveDirection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.enterToNode[LocalVariableDescriptor]

'SmartList' @ [93:13] ==> public constructor SmartList<E : (Any..Any?)>() defined in org.jetbrains.kotlin.utils.SmartList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> NodeWithDirection

'also' @ [93:44] ==> @InlineOnly @SinceKotlin public inline fun <T> SmartList<TypeVariableDirectionCalculator.NodeWithDirection>.also(block: (SmartList<TypeVariableDirectionCalculator.NodeWithDirection>) -> Unit): SmartList<TypeVariableDirectionCalculator.NodeWithDirection> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SmartList<NodeWithDirection>

'variable' @ [94:36] ==> value-parameter variable: Variable /* = VariableWithConstraints */ defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.getConstraintDependencies[ValueParameterDescriptorImpl]

'constraints' @ [94:45] ==> public abstract val constraints: List<Constraint> defined in org.jetbrains.kotlin.resolve.calls.inference.model.VariableWithConstraints[PropertyDescriptorImpl]

'!' @ [95:25] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isInterestingConstraint' @ [95:26] ==> private final fun isInterestingConstraint(direction: TypeVariableDirectionCalculator.ResolveDirection, constraint: Constraint): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator[SimpleFunctionDescriptorImpl]

'direction' @ [95:50] ==> value-parameter direction: TypeVariableDirectionCalculator.ResolveDirection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.getConstraintDependencies[ValueParameterDescriptorImpl]

'constraint' @ [95:61] ==> val constraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.getConstraintDependencies.<anonymous>[LocalVariableDescriptor]

'constraint' @ [97:21] ==> val constraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.getConstraintDependencies.<anonymous>[LocalVariableDescriptor]

'type' @ [97:32] ==> public final val type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'visitType' @ [97:37] ==> private final fun UnwrappedType.visitType(startDirection: TypeVariableDirectionCalculator.ResolveDirection, action: (variable: Variable /* = VariableWithConstraints */, direction: TypeVariableDirectionCalculator.ResolveDirection) -> Unit): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator[SimpleFunctionDescriptorImpl]

'direction' @ [97:47] ==> value-parameter direction: TypeVariableDirectionCalculator.ResolveDirection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.getConstraintDependencies[ValueParameterDescriptorImpl]

'result' @ [98:25] ==> value-parameter result: SmartList<TypeVariableDirectionCalculator.NodeWithDirection> defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.getConstraintDependencies.<anonymous>[ValueParameterDescriptorImpl]

'add' @ [98:32] ==> public open fun add(element: (TypeVariableDirectionCalculator.NodeWithDirection..TypeVariableDirectionCalculator.NodeWithDirection?)): Boolean defined in org.jetbrains.kotlin.utils.SmartList[JavaMethodDescriptor]

'NodeWithDirection' @ [98:36] ==> public constructor NodeWithDirection(variableWithConstraints: VariableWithConstraints, direction: TypeVariableDirectionCalculator.ResolveDirection) defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.NodeWithDirection[ClassConstructorDescriptorImpl]

'nodeVariable' @ [98:54] ==> value-parameter nodeVariable: Variable /* = VariableWithConstraints */ defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.getConstraintDependencies.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'nodeDirection' @ [98:68] ==> value-parameter nodeDirection: TypeVariableDirectionCalculator.ResolveDirection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.getConstraintDependencies.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'!' @ [105:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'direction' @ [105:15] ==> value-parameter direction: TypeVariableDirectionCalculator.ResolveDirection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.isInterestingConstraint[ValueParameterDescriptorImpl]

'TO_SUBTYPE' @ [105:45] ==> enum entry TO_SUBTYPE defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.ResolveDirection[FakeCallableDescriptorForObject]

'constraint' @ [105:59] ==> value-parameter constraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.isInterestingConstraint[ValueParameterDescriptorImpl]

'kind' @ [105:70] ==> public final val kind: ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'UPPER' @ [105:93] ==> enum entry UPPER defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'!' @ [106:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'direction' @ [106:15] ==> value-parameter direction: TypeVariableDirectionCalculator.ResolveDirection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.isInterestingConstraint[ValueParameterDescriptorImpl]

'TO_SUPERTYPE' @ [106:45] ==> enum entry TO_SUPERTYPE defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.ResolveDirection[FakeCallableDescriptorForObject]

'constraint' @ [106:61] ==> value-parameter constraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.isInterestingConstraint[ValueParameterDescriptorImpl]

'kind' @ [106:72] ==> public final val kind: ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'LOWER' @ [106:95] ==> enum entry LOWER defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'when (this) {
                is SimpleType -> visitType(startDirection, action)
                is FlexibleType -> {
                    lowerBound.visitType(startDirection, action)
                    upperBound.visitType(startDirection, action)
                }
            }' @ [109:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'this' @ [109:19] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.visitType[ReceiverParameterDescriptorImpl]

'visitType' @ [110:34] ==> private final fun SimpleType.visitType(startDirection: TypeVariableDirectionCalculator.ResolveDirection, action: (variable: Variable /* = VariableWithConstraints */, direction: TypeVariableDirectionCalculator.ResolveDirection) -> Unit): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator[SimpleFunctionDescriptorImpl]

'startDirection' @ [110:44] ==> value-parameter startDirection: TypeVariableDirectionCalculator.ResolveDirection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.visitType[ValueParameterDescriptorImpl]

'action' @ [110:60] ==> value-parameter action: (variable: Variable /* = VariableWithConstraints */, direction: TypeVariableDirectionCalculator.ResolveDirection) -> Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.visitType[ValueParameterDescriptorImpl]

'lowerBound' @ [112:21] ==> public final val lowerBound: SimpleType defined in org.jetbrains.kotlin.types.FlexibleType[DeserializedPropertyDescriptor]

'visitType' @ [112:32] ==> private final fun SimpleType.visitType(startDirection: TypeVariableDirectionCalculator.ResolveDirection, action: (variable: Variable /* = VariableWithConstraints */, direction: TypeVariableDirectionCalculator.ResolveDirection) -> Unit): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator[SimpleFunctionDescriptorImpl]

'startDirection' @ [112:42] ==> value-parameter startDirection: TypeVariableDirectionCalculator.ResolveDirection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.visitType[ValueParameterDescriptorImpl]

'action' @ [112:58] ==> value-parameter action: (variable: Variable /* = VariableWithConstraints */, direction: TypeVariableDirectionCalculator.ResolveDirection) -> Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.visitType[ValueParameterDescriptorImpl]

'upperBound' @ [113:21] ==> public final val upperBound: SimpleType defined in org.jetbrains.kotlin.types.FlexibleType[DeserializedPropertyDescriptor]

'visitType' @ [113:32] ==> private final fun SimpleType.visitType(startDirection: TypeVariableDirectionCalculator.ResolveDirection, action: (variable: Variable /* = VariableWithConstraints */, direction: TypeVariableDirectionCalculator.ResolveDirection) -> Unit): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator[SimpleFunctionDescriptorImpl]

'startDirection' @ [113:42] ==> value-parameter startDirection: TypeVariableDirectionCalculator.ResolveDirection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.visitType[ValueParameterDescriptorImpl]

'action' @ [113:58] ==> value-parameter action: (variable: Variable /* = VariableWithConstraints */, direction: TypeVariableDirectionCalculator.ResolveDirection) -> Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.visitType[ValueParameterDescriptorImpl]

'isIntersectionType' @ [118:13] ==> public val SimpleType.isIntersectionType: Boolean defined in org.jetbrains.kotlin.types.checker[DeserializedPropertyDescriptor]

'constructor' @ [119:13] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'supertypes' @ [119:25] ==> public final val TypeConstructor.supertypes: Collection<(KotlinType..KotlinType?)>[MyPropertyDescriptor]

'forEach' @ [119:36] ==> @HidesMembers public inline fun <T> Iterable<(KotlinType..KotlinType?)>.forEach(action: ((KotlinType..KotlinType?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)

'it' @ [120:17] ==> value-parameter it: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.visitType.<anonymous>[ValueParameterDescriptorImpl]

'unwrap' @ [120:20] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'visitType' @ [120:29] ==> private final fun UnwrappedType.visitType(startDirection: TypeVariableDirectionCalculator.ResolveDirection, action: (variable: Variable /* = VariableWithConstraints */, direction: TypeVariableDirectionCalculator.ResolveDirection) -> Unit): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator[SimpleFunctionDescriptorImpl]

'startDirection' @ [120:39] ==> value-parameter startDirection: TypeVariableDirectionCalculator.ResolveDirection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.visitType[ValueParameterDescriptorImpl]

'action' @ [120:55] ==> value-parameter action: (variable: Variable /* = VariableWithConstraints */, direction: TypeVariableDirectionCalculator.ResolveDirection) -> Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.visitType[ValueParameterDescriptorImpl]

'arguments' @ [125:13] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'isEmpty' @ [125:23] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'c' @ [126:13] ==> private final val c: VariableFixationFinder.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator[PropertyDescriptorImpl]

'notFixedTypeVariables' @ [126:15] ==> public abstract val notFixedTypeVariables: Map<TypeConstructor, VariableWithConstraints> defined in org.jetbrains.kotlin.resolve.calls.inference.components.VariableFixationFinder.Context[PropertyDescriptorImpl]

'constructor' @ [126:37] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'let' @ [126:51] ==> @InlineOnly public inline fun <T, R> VariableWithConstraints.let(block: (VariableWithConstraints) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> VariableWithConstraints
    <R> -> Unit

'invoke' @ [127:17] ==> public abstract operator fun invoke(variable: Variable /* = @ParameterName VariableWithConstraints */, direction: @ParameterName TypeVariableDirectionCalculator.ResolveDirection): Unit defined in kotlin.Function2[FunctionInvokeDescriptor]

'it' @ [127:24] ==> value-parameter it: VariableWithConstraints defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.visitType.<anonymous>[ValueParameterDescriptorImpl]

'startDirection' @ [127:28] ==> value-parameter startDirection: TypeVariableDirectionCalculator.ResolveDirection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.visitType[ValueParameterDescriptorImpl]

'constructor' @ [132:26] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'parameters' @ [132:38] ==> public final val TypeConstructor.parameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'parameters' @ [133:13] ==> val parameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.visitType[LocalVariableDescriptor]

'size' @ [133:24] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'arguments' @ [133:32] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'size' @ [133:42] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'component1' @ [135:15] ==> public final operator fun component1(): TypeProjection defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [135:25] ==> public final operator fun component2(): (TypeParameterDescriptor..TypeParameterDescriptor?) defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'arguments' @ [135:39] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'zip' @ [135:49] ==> public infix fun <T, R> Iterable<TypeProjection>.zip(other: Iterable<(TypeParameterDescriptor..TypeParameterDescriptor?)>): List<Pair<TypeProjection, (TypeParameterDescriptor..TypeParameterDescriptor?)>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection
    <R> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)

'parameters' @ [135:53] ==> val parameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.visitType[LocalVariableDescriptor]

'argument' @ [136:17] ==> val argument: TypeProjection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.visitType[LocalVariableDescriptor]

'isStarProjection' @ [136:26] ==> public final val TypeProjection.isStarProjection: Boolean[MyPropertyDescriptor]

'?:' @ [138:28] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: Variance?, right: Variance): Variance[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> Variance

'effectiveVariance' @ [138:49] ==> public final fun effectiveVariance(declared: Variance, useSite: Variance): Variance? defined in org.jetbrains.kotlin.types.checker.NewKotlinTypeChecker[DeserializedSimpleFunctionDescriptor]

'parameter' @ [138:67] ==> val parameter: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.visitType[LocalVariableDescriptor]

'variance' @ [138:77] ==> public final val TypeParameterDescriptor.variance: Variance[MyPropertyDescriptor]

'argument' @ [138:87] ==> val argument: TypeProjection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.visitType[LocalVariableDescriptor]

'projectionKind' @ [138:96] ==> public final val TypeProjection.projectionKind: Variance[MyPropertyDescriptor]

'INVARIANT' @ [138:124] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'when (variance) {
                Variance.INVARIANT -> ResolveDirection.UNKNOWN
                Variance.OUT_VARIANCE -> startDirection
                Variance.IN_VARIANCE -> startDirection.opposite()
            }' @ [139:34] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: TypeVariableDirectionCalculator.ResolveDirection, entry1: TypeVariableDirectionCalculator.ResolveDirection, entry2: TypeVariableDirectionCalculator.ResolveDirection): TypeVariableDirectionCalculator.ResolveDirection[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> ResolveDirection

'variance' @ [139:40] ==> val variance: Variance defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.visitType[LocalVariableDescriptor]

'INVARIANT' @ [140:26] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'UNKNOWN' @ [140:56] ==> enum entry UNKNOWN defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.ResolveDirection[FakeCallableDescriptorForObject]

'OUT_VARIANCE' @ [141:26] ==> enum entry OUT_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'startDirection' @ [141:42] ==> value-parameter startDirection: TypeVariableDirectionCalculator.ResolveDirection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.visitType[ValueParameterDescriptorImpl]

'IN_VARIANCE' @ [142:26] ==> enum entry IN_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'startDirection' @ [142:41] ==> value-parameter startDirection: TypeVariableDirectionCalculator.ResolveDirection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.visitType[ValueParameterDescriptorImpl]

'opposite' @ [142:56] ==> private final fun TypeVariableDirectionCalculator.ResolveDirection.opposite(): TypeVariableDirectionCalculator.ResolveDirection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator[SimpleFunctionDescriptorImpl]

'argument' @ [145:13] ==> val argument: TypeProjection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.visitType[LocalVariableDescriptor]

'type' @ [145:22] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'unwrap' @ [145:27] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'visitType' @ [145:36] ==> private final fun UnwrappedType.visitType(startDirection: TypeVariableDirectionCalculator.ResolveDirection, action: (variable: Variable /* = VariableWithConstraints */, direction: TypeVariableDirectionCalculator.ResolveDirection) -> Unit): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator[SimpleFunctionDescriptorImpl]

'innerDirection' @ [145:46] ==> val innerDirection: TypeVariableDirectionCalculator.ResolveDirection defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.visitType[LocalVariableDescriptor]

'action' @ [145:62] ==> value-parameter action: (variable: Variable /* = VariableWithConstraints */, direction: TypeVariableDirectionCalculator.ResolveDirection) -> Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.visitType[ValueParameterDescriptorImpl]

'when (this) {
        ResolveDirection.UNKNOWN -> ResolveDirection.UNKNOWN
        ResolveDirection.TO_SUPERTYPE -> ResolveDirection.TO_SUBTYPE
        ResolveDirection.TO_SUBTYPE -> ResolveDirection.TO_SUPERTYPE
    }' @ [149:47] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: TypeVariableDirectionCalculator.ResolveDirection, entry1: TypeVariableDirectionCalculator.ResolveDirection, entry2: TypeVariableDirectionCalculator.ResolveDirection): TypeVariableDirectionCalculator.ResolveDirection[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> ResolveDirection

'this' @ [149:53] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.opposite[ReceiverParameterDescriptorImpl]

'UNKNOWN' @ [150:26] ==> enum entry UNKNOWN defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.ResolveDirection[FakeCallableDescriptorForObject]

'UNKNOWN' @ [150:54] ==> enum entry UNKNOWN defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.ResolveDirection[FakeCallableDescriptorForObject]

'TO_SUPERTYPE' @ [151:26] ==> enum entry TO_SUPERTYPE defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.ResolveDirection[FakeCallableDescriptorForObject]

'TO_SUBTYPE' @ [151:59] ==> enum entry TO_SUBTYPE defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.ResolveDirection[FakeCallableDescriptorForObject]

'TO_SUBTYPE' @ [152:26] ==> enum entry TO_SUBTYPE defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.ResolveDirection[FakeCallableDescriptorForObject]

'TO_SUPERTYPE' @ [152:57] ==> enum entry TO_SUPERTYPE defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeVariableDirectionCalculator.ResolveDirection[FakeCallableDescriptorForObject]

