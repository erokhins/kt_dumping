'NewTypeSubstitutorByConstructorMap' @ [27:51] ==> public constructor NewTypeSubstitutorByConstructorMap(map: Map<TypeConstructor, UnwrappedType>) defined in org.jetbrains.kotlin.resolve.calls.inference.components.NewTypeSubstitutorByConstructorMap[ClassConstructorDescriptorImpl]

'fixedTypeVariables' @ [27:86] ==> public abstract val fixedTypeVariables: Map<TypeConstructor, UnwrappedType> defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintStorage[PropertyDescriptorImpl]

'entries' @ [27:105] ==> public abstract val entries: Set<Map.Entry<TypeConstructor, UnwrappedType>> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'associate' @ [27:113] ==> public inline fun <T, K, V> Iterable<Map.Entry<TypeConstructor, UnwrappedType>>.associate(transform: (Map.Entry<TypeConstructor, UnwrappedType>) -> Pair<TypeConstructor, UnwrappedType>): Map<TypeConstructor, UnwrappedType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Entry<TypeConstructor, UnwrappedType>
    <K> -> TypeConstructor
    <V> -> UnwrappedType

'it' @ [28:5] ==> value-parameter it: Map.Entry<TypeConstructor, UnwrappedType> defined in org.jetbrains.kotlin.resolve.calls.inference.buildCurrentSubstitutor.<anonymous>[ValueParameterDescriptorImpl]

'key' @ [28:8] ==> public abstract val key: TypeConstructor defined in kotlin.collections.Map.Entry[DeserializedPropertyDescriptor]

'it' @ [28:15] ==> value-parameter it: Map.Entry<TypeConstructor, UnwrappedType> defined in org.jetbrains.kotlin.resolve.calls.inference.buildCurrentSubstitutor.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [28:18] ==> public abstract val value: UnwrappedType defined in kotlin.collections.Map.Entry[DeserializedPropertyDescriptor]

'fixedTypeVariables' @ [32:33] ==> public abstract val fixedTypeVariables: Map<TypeConstructor, UnwrappedType> defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintStorage[PropertyDescriptorImpl]

'entries' @ [32:52] ==> public abstract val entries: Set<Map.Entry<TypeConstructor, UnwrappedType>> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'associate' @ [32:60] ==> public inline fun <T, K, V> Iterable<Map.Entry<TypeConstructor, UnwrappedType>>.associate(transform: (Map.Entry<TypeConstructor, UnwrappedType>) -> Pair<TypeConstructor, UnwrappedType>): Map<TypeConstructor, UnwrappedType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Entry<TypeConstructor, UnwrappedType>
    <K> -> TypeConstructor
    <V> -> UnwrappedType

'it' @ [33:9] ==> value-parameter it: Map.Entry<TypeConstructor, UnwrappedType> defined in org.jetbrains.kotlin.resolve.calls.inference.buildResultingSubstitutor.<anonymous>[ValueParameterDescriptorImpl]

'key' @ [33:12] ==> public abstract val key: TypeConstructor defined in kotlin.collections.Map.Entry[DeserializedPropertyDescriptor]

'it' @ [33:19] ==> value-parameter it: Map.Entry<TypeConstructor, UnwrappedType> defined in org.jetbrains.kotlin.resolve.calls.inference.buildResultingSubstitutor.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [33:22] ==> public abstract val value: UnwrappedType defined in kotlin.collections.Map.Entry[DeserializedPropertyDescriptor]

'notFixedTypeVariables' @ [35:36] ==> public abstract val notFixedTypeVariables: Map<TypeConstructor, VariableWithConstraints> defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintStorage[PropertyDescriptorImpl]

'entries' @ [35:58] ==> public abstract val entries: Set<Map.Entry<TypeConstructor, VariableWithConstraints>> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'associate' @ [35:66] ==> public inline fun <T, K, V> Iterable<Map.Entry<TypeConstructor, VariableWithConstraints>>.associate(transform: (Map.Entry<TypeConstructor, VariableWithConstraints>) -> Pair<TypeConstructor, SimpleType>): Map<TypeConstructor, SimpleType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Entry<TypeConstructor, VariableWithConstraints>
    <K> -> TypeConstructor
    <V> -> SimpleType

'component1' @ [35:79] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<TypeConstructor, VariableWithConstraints>.component1(): TypeConstructor defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> TypeConstructor
    <V> -> VariableWithConstraints

'component2' @ [35:101] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<TypeConstructor, VariableWithConstraints>.component2(): VariableWithConstraints defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> TypeConstructor
    <V> -> VariableWithConstraints

'freshTypeConstructor' @ [36:9] ==> val freshTypeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.buildResultingSubstitutor.<anonymous>[LocalVariableDescriptor]

'createErrorTypeWithCustomConstructor' @ [36:44] ==> @NotNull public open fun createErrorTypeWithCustomConstructor(@NotNull p0: String, @NotNull p1: TypeConstructor): SimpleType defined in org.jetbrains.kotlin.types.ErrorUtils[JavaMethodDescriptor]

'typeVariable' @ [36:100] ==> val typeVariable: VariableWithConstraints defined in org.jetbrains.kotlin.resolve.calls.inference.buildResultingSubstitutor.<anonymous>[LocalVariableDescriptor]

'typeVariable' @ [36:113] ==> public abstract val typeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.model.VariableWithConstraints[PropertyDescriptorImpl]

'freshTypeConstructor' @ [36:126] ==> public final val freshTypeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewTypeVariable[PropertyDescriptorImpl]

'NewTypeSubstitutorByConstructorMap' @ [39:12] ==> public constructor NewTypeSubstitutorByConstructorMap(map: Map<TypeConstructor, UnwrappedType>) defined in org.jetbrains.kotlin.resolve.calls.inference.components.NewTypeSubstitutorByConstructorMap[ClassConstructorDescriptorImpl]

'currentSubstitutorMap' @ [39:47] ==> val currentSubstitutorMap: Map<TypeConstructor, UnwrappedType> defined in org.jetbrains.kotlin.resolve.calls.inference.buildResultingSubstitutor[LocalVariableDescriptor]

'uninferredSubstitutorMap' @ [39:71] ==> val uninferredSubstitutorMap: Map<TypeConstructor, SimpleType> defined in org.jetbrains.kotlin.resolve.calls.inference.buildResultingSubstitutor[LocalVariableDescriptor]

'returnType' @ [44:9] ==> public final val CallableDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'let' @ [44:21] ==> @InlineOnly public inline fun <T, R> KotlinType.let(block: (KotlinType) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType
    <R> -> Nothing

'it' @ [44:34] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.<get-returnTypeOrNothing>.<anonymous>[ValueParameterDescriptorImpl]

'unwrap' @ [44:37] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'builtIns' @ [46:16] ==> public val DeclarationDescriptor.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'nothingType' @ [46:25] ==> public final val KotlinBuiltIns.nothingType: SimpleType[MyPropertyDescriptor]

'safeSubstitute' @ [49:70] ==> @NotNull public open fun safeSubstitute(@NotNull p0: KotlinType, @NotNull p1: Variance): KotlinType defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'type' @ [49:85] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.substitute[ValueParameterDescriptorImpl]

'INVARIANT' @ [49:100] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'unwrap' @ [49:111] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'TypeSubstitution' @ [52:40] ==> public constructor TypeSubstitution() defined in org.jetbrains.kotlin.types.TypeSubstitution[DeserializedClassConstructorDescriptor]

'substitutor' @ [54:90] ==> value-parameter substitutor: NewTypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.inference.substitute[ValueParameterDescriptorImpl]

'safeSubstitute' @ [54:102] ==> public open fun safeSubstitute(type: UnwrappedType): UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.NewTypeSubstitutor[SimpleFunctionDescriptorImpl]

'topLevelType' @ [54:117] ==> value-parameter topLevelType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.substitute.<no name provided>.prepareTopLevelType[ValueParameterDescriptorImpl]

'unwrap' @ [54:130] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'substitute' @ [56:12] ==> public abstract fun substitute(substitutor: TypeSubstitutor): (CallableDescriptor..CallableDescriptor?) defined in org.jetbrains.kotlin.descriptors.CallableDescriptor[DeserializedSimpleFunctionDescriptor]

'create' @ [56:39] ==> @NotNull public open fun create(@NotNull p0: TypeSubstitution): TypeSubstitutor defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'wrappedSubstitution' @ [56:46] ==> val wrappedSubstitution: <no name provided> defined in org.jetbrains.kotlin.resolve.calls.inference.substitute[LocalVariableDescriptor]

'TypeSubstitution' @ [60:40] ==> public constructor TypeSubstitution() defined in org.jetbrains.kotlin.types.TypeSubstitution[DeserializedClassConstructorDescriptor]

'substitutor' @ [64:17] ==> value-parameter substitutor: NewTypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.inference.substituteAndApproximateCapturedTypes[ValueParameterDescriptorImpl]

'safeSubstitute' @ [64:29] ==> public open fun safeSubstitute(type: UnwrappedType): UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.NewTypeSubstitutor[SimpleFunctionDescriptorImpl]

'topLevelType' @ [64:44] ==> value-parameter topLevelType: KotlinType defined in org.jetbrains.kotlin.resolve.calls.inference.substituteAndApproximateCapturedTypes.<no name provided>.prepareTopLevelType[ValueParameterDescriptorImpl]

'unwrap' @ [64:57] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'let' @ [64:67] ==> @InlineOnly public inline fun <T, R> UnwrappedType.let(block: (UnwrappedType) -> UnwrappedType): UnwrappedType defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> UnwrappedType
    <R> -> UnwrappedType

'TypeApproximator' @ [65:21] ==> public constructor TypeApproximator() defined in org.jetbrains.kotlin.types.TypeApproximator[ClassConstructorDescriptorImpl]

'approximateToSuperType' @ [65:40] ==> public final fun approximateToSuperType(type: UnwrappedType, conf: TypeApproximatorConfiguration): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'substitutedType' @ [65:63] ==> value-parameter substitutedType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.substituteAndApproximateCapturedTypes.<no name provided>.prepareTopLevelType.<anonymous>[ValueParameterDescriptorImpl]

'CapturedTypesApproximation' @ [65:110] ==> public object CapturedTypesApproximation : TypeApproximatorConfiguration.AbstractCapturedTypesApproximation defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration[FakeCallableDescriptorForObject]

'substitutedType' @ [66:21] ==> value-parameter substitutedType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.substituteAndApproximateCapturedTypes.<no name provided>.prepareTopLevelType.<anonymous>[ValueParameterDescriptorImpl]

'substitute' @ [70:12] ==> public abstract fun substitute(substitutor: TypeSubstitutor): (CallableDescriptor..CallableDescriptor?) defined in org.jetbrains.kotlin.descriptors.CallableDescriptor[DeserializedSimpleFunctionDescriptor]

'create' @ [70:39] ==> @NotNull public open fun create(@NotNull p0: TypeSubstitution): TypeSubstitutor defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'wrappedSubstitution' @ [70:46] ==> val wrappedSubstitution: <no name provided> defined in org.jetbrains.kotlin.resolve.calls.inference.substituteAndApproximateCapturedTypes[LocalVariableDescriptor]

'subList' @ [73:60] ==> public abstract fun subList(fromIndex: Int, toIndex: Int): MutableList<E> defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'newSize' @ [73:68] ==> value-parameter newSize: Int defined in org.jetbrains.kotlin.resolve.calls.inference.trimToSize[ValueParameterDescriptorImpl]

'size' @ [73:77] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'clear' @ [73:83] ==> public abstract fun clear(): Unit defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

