'InitialConstraint' @ [47:33] ==> public constructor InitialConstraint(a: UnwrappedType, b: UnwrappedType, constraintKind: ConstraintKind, position: ConstraintPosition) defined in org.jetbrains.kotlin.resolve.calls.inference.model.InitialConstraint[ClassConstructorDescriptorImpl]

'lowerType' @ [47:51] ==> value-parameter lowerType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialSubtypeConstraint[ValueParameterDescriptorImpl]

'upperType' @ [47:62] ==> value-parameter upperType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialSubtypeConstraint[ValueParameterDescriptorImpl]

'UPPER' @ [47:73] ==> enum entry UPPER defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'position' @ [47:80] ==> value-parameter position: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialSubtypeConstraint[ValueParameterDescriptorImpl]

'IncorporationConstraintPosition' @ [48:37] ==> public constructor IncorporationConstraintPosition(from: ConstraintPosition, initialConstraint: InitialConstraint) defined in org.jetbrains.kotlin.resolve.calls.inference.model.IncorporationConstraintPosition[ClassConstructorDescriptorImpl]

'position' @ [48:69] ==> value-parameter position: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialSubtypeConstraint[ValueParameterDescriptorImpl]

'initialConstraint' @ [48:79] ==> val initialConstraint: InitialConstraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialSubtypeConstraint[LocalVariableDescriptor]

'c' @ [49:9] ==> value-parameter c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialSubtypeConstraint[ValueParameterDescriptorImpl]

'addInitialConstraint' @ [49:11] ==> public abstract fun addInitialConstraint(initialConstraint: InitialConstraint): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.Context[SimpleFunctionDescriptorImpl]

'initialConstraint' @ [49:32] ==> val initialConstraint: InitialConstraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialSubtypeConstraint[LocalVariableDescriptor]

'updateAllowedTypeDepth' @ [50:9] ==> private final fun updateAllowedTypeDepth(c: ConstraintInjector.Context, initialType: UnwrappedType): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector[SimpleFunctionDescriptorImpl]

'c' @ [50:32] ==> value-parameter c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialSubtypeConstraint[ValueParameterDescriptorImpl]

'lowerType' @ [50:35] ==> value-parameter lowerType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialSubtypeConstraint[ValueParameterDescriptorImpl]

'updateAllowedTypeDepth' @ [51:9] ==> private final fun updateAllowedTypeDepth(c: ConstraintInjector.Context, initialType: UnwrappedType): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector[SimpleFunctionDescriptorImpl]

'c' @ [51:32] ==> value-parameter c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialSubtypeConstraint[ValueParameterDescriptorImpl]

'upperType' @ [51:35] ==> value-parameter upperType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialSubtypeConstraint[ValueParameterDescriptorImpl]

'addSubTypeConstraintAndIncorporateIt' @ [52:9] ==> private final fun addSubTypeConstraintAndIncorporateIt(c: ConstraintInjector.Context, lowerType: UnwrappedType, upperType: UnwrappedType, incorporatePosition: IncorporationConstraintPosition): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector[SimpleFunctionDescriptorImpl]

'c' @ [52:46] ==> value-parameter c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialSubtypeConstraint[ValueParameterDescriptorImpl]

'lowerType' @ [52:49] ==> value-parameter lowerType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialSubtypeConstraint[ValueParameterDescriptorImpl]

'upperType' @ [52:60] ==> value-parameter upperType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialSubtypeConstraint[ValueParameterDescriptorImpl]

'incorporationPosition' @ [52:71] ==> val incorporationPosition: IncorporationConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialSubtypeConstraint[LocalVariableDescriptor]

'InitialConstraint' @ [56:33] ==> public constructor InitialConstraint(a: UnwrappedType, b: UnwrappedType, constraintKind: ConstraintKind, position: ConstraintPosition) defined in org.jetbrains.kotlin.resolve.calls.inference.model.InitialConstraint[ClassConstructorDescriptorImpl]

'a' @ [56:51] ==> value-parameter a: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialEqualityConstraint[ValueParameterDescriptorImpl]

'b' @ [56:54] ==> value-parameter b: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialEqualityConstraint[ValueParameterDescriptorImpl]

'EQUALITY' @ [56:72] ==> enum entry EQUALITY defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'position' @ [56:82] ==> value-parameter position: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialEqualityConstraint[ValueParameterDescriptorImpl]

'IncorporationConstraintPosition' @ [57:37] ==> public constructor IncorporationConstraintPosition(from: ConstraintPosition, initialConstraint: InitialConstraint) defined in org.jetbrains.kotlin.resolve.calls.inference.model.IncorporationConstraintPosition[ClassConstructorDescriptorImpl]

'position' @ [57:69] ==> value-parameter position: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialEqualityConstraint[ValueParameterDescriptorImpl]

'initialConstraint' @ [57:79] ==> val initialConstraint: InitialConstraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialEqualityConstraint[LocalVariableDescriptor]

'c' @ [58:9] ==> value-parameter c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialEqualityConstraint[ValueParameterDescriptorImpl]

'addInitialConstraint' @ [58:11] ==> public abstract fun addInitialConstraint(initialConstraint: InitialConstraint): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.Context[SimpleFunctionDescriptorImpl]

'initialConstraint' @ [58:32] ==> val initialConstraint: InitialConstraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialEqualityConstraint[LocalVariableDescriptor]

'updateAllowedTypeDepth' @ [59:9] ==> private final fun updateAllowedTypeDepth(c: ConstraintInjector.Context, initialType: UnwrappedType): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector[SimpleFunctionDescriptorImpl]

'c' @ [59:32] ==> value-parameter c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialEqualityConstraint[ValueParameterDescriptorImpl]

'a' @ [59:35] ==> value-parameter a: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialEqualityConstraint[ValueParameterDescriptorImpl]

'updateAllowedTypeDepth' @ [60:9] ==> private final fun updateAllowedTypeDepth(c: ConstraintInjector.Context, initialType: UnwrappedType): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector[SimpleFunctionDescriptorImpl]

'c' @ [60:32] ==> value-parameter c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialEqualityConstraint[ValueParameterDescriptorImpl]

'b' @ [60:35] ==> value-parameter b: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialEqualityConstraint[ValueParameterDescriptorImpl]

'addSubTypeConstraintAndIncorporateIt' @ [61:9] ==> private final fun addSubTypeConstraintAndIncorporateIt(c: ConstraintInjector.Context, lowerType: UnwrappedType, upperType: UnwrappedType, incorporatePosition: IncorporationConstraintPosition): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector[SimpleFunctionDescriptorImpl]

'c' @ [61:46] ==> value-parameter c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialEqualityConstraint[ValueParameterDescriptorImpl]

'a' @ [61:49] ==> value-parameter a: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialEqualityConstraint[ValueParameterDescriptorImpl]

'b' @ [61:52] ==> value-parameter b: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialEqualityConstraint[ValueParameterDescriptorImpl]

'incorporationPosition' @ [61:55] ==> val incorporationPosition: IncorporationConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialEqualityConstraint[LocalVariableDescriptor]

'addSubTypeConstraintAndIncorporateIt' @ [62:9] ==> private final fun addSubTypeConstraintAndIncorporateIt(c: ConstraintInjector.Context, lowerType: UnwrappedType, upperType: UnwrappedType, incorporatePosition: IncorporationConstraintPosition): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector[SimpleFunctionDescriptorImpl]

'c' @ [62:46] ==> value-parameter c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialEqualityConstraint[ValueParameterDescriptorImpl]

'b' @ [62:49] ==> value-parameter b: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialEqualityConstraint[ValueParameterDescriptorImpl]

'a' @ [62:52] ==> value-parameter a: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialEqualityConstraint[ValueParameterDescriptorImpl]

'incorporationPosition' @ [62:55] ==> val incorporationPosition: IncorporationConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addInitialEqualityConstraint[LocalVariableDescriptor]

'Stack' @ [67:38] ==> public constructor Stack<E : (Any..Any?)>() defined in java.util.Stack[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> Pair<NewTypeVariable, Constraint>

'TypeCheckerContext' @ [68:34] ==> public constructor TypeCheckerContext(c: ConstraintInjector.Context, position: IncorporationConstraintPosition, baseLowerType: UnwrappedType, baseUpperType: UnwrappedType, possibleNewConstraints: MutableList<Pair<NewTypeVariable, Constraint>>) defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[ClassConstructorDescriptorImpl]

'c' @ [68:53] ==> value-parameter c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addSubTypeConstraintAndIncorporateIt[ValueParameterDescriptorImpl]

'incorporatePosition' @ [68:56] ==> value-parameter incorporatePosition: IncorporationConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addSubTypeConstraintAndIncorporateIt[ValueParameterDescriptorImpl]

'lowerType' @ [68:77] ==> value-parameter lowerType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addSubTypeConstraintAndIncorporateIt[ValueParameterDescriptorImpl]

'upperType' @ [68:88] ==> value-parameter upperType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addSubTypeConstraintAndIncorporateIt[ValueParameterDescriptorImpl]

'possibleNewConstraints' @ [68:99] ==> val possibleNewConstraints: Stack<Pair<NewTypeVariable, Constraint>> defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addSubTypeConstraintAndIncorporateIt[LocalVariableDescriptor]

'typeCheckerContext' @ [69:9] ==> val typeCheckerContext: ConstraintInjector.TypeCheckerContext defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addSubTypeConstraintAndIncorporateIt[LocalVariableDescriptor]

'runIsSubtypeOf' @ [69:28] ==> public final fun runIsSubtypeOf(lowerType: UnwrappedType, upperType: UnwrappedType): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[SimpleFunctionDescriptorImpl]

'lowerType' @ [69:43] ==> value-parameter lowerType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addSubTypeConstraintAndIncorporateIt[ValueParameterDescriptorImpl]

'upperType' @ [69:54] ==> value-parameter upperType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addSubTypeConstraintAndIncorporateIt[ValueParameterDescriptorImpl]

'possibleNewConstraints' @ [71:16] ==> val possibleNewConstraints: Stack<Pair<NewTypeVariable, Constraint>> defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addSubTypeConstraintAndIncorporateIt[LocalVariableDescriptor]

'isNotEmpty' @ [71:39] ==> @InlineOnly public inline fun <T> Collection<(Pair<NewTypeVariable, Constraint>..Pair<NewTypeVariable, Constraint>?)>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.Pair<org.jetbrains.kotlin.resolve.calls.inference.model.NewTypeVariable, org.jetbrains.kotlin.resolve.calls.inference.model.Constraint>..kotlin.Pair<org.jetbrains.kotlin.resolve.calls.inference.model.NewTypeVariable, org.jetbrains.kotlin.resolve.calls.inference.model.Constraint>?)

'component1' @ [72:18] ==> public final operator fun component1(): NewTypeVariable defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [72:32] ==> public final operator fun component2(): Constraint defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'possibleNewConstraints' @ [72:46] ==> val possibleNewConstraints: Stack<Pair<NewTypeVariable, Constraint>> defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addSubTypeConstraintAndIncorporateIt[LocalVariableDescriptor]

'pop' @ [72:69] ==> public open fun pop(): (Pair<NewTypeVariable, Constraint>..Pair<NewTypeVariable, Constraint>?) defined in java.util.Stack[JavaMethodDescriptor]

'c' @ [73:17] ==> value-parameter c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addSubTypeConstraintAndIncorporateIt[ValueParameterDescriptorImpl]

'shouldWeSkipConstraint' @ [73:19] ==> private final fun ConstraintInjector.Context.shouldWeSkipConstraint(typeVariable: NewTypeVariable, constraint: Constraint): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector[SimpleFunctionDescriptorImpl]

'typeVariable' @ [73:42] ==> val typeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addSubTypeConstraintAndIncorporateIt[LocalVariableDescriptor]

'constraint' @ [73:56] ==> val constraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addSubTypeConstraintAndIncorporateIt[LocalVariableDescriptor]

'c' @ [75:31] ==> value-parameter c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addSubTypeConstraintAndIncorporateIt[ValueParameterDescriptorImpl]

'notFixedTypeVariables' @ [75:33] ==> public abstract val notFixedTypeVariables: MutableMap<TypeConstructor, MutableVariableWithConstraints> defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.Context[PropertyDescriptorImpl]

'typeVariable' @ [75:55] ==> val typeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addSubTypeConstraintAndIncorporateIt[LocalVariableDescriptor]

'freshTypeConstructor' @ [75:68] ==> public final val freshTypeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewTypeVariable[PropertyDescriptorImpl]

'typeCheckerContext' @ [75:93] ==> val typeCheckerContext: ConstraintInjector.TypeCheckerContext defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addSubTypeConstraintAndIncorporateIt[LocalVariableDescriptor]

'fixedTypeVariable' @ [75:112] ==> public final fun fixedTypeVariable(variable: NewTypeVariable): Nothing defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[SimpleFunctionDescriptorImpl]

'typeVariable' @ [75:130] ==> val typeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addSubTypeConstraintAndIncorporateIt[LocalVariableDescriptor]

'constraints' @ [78:13] ==> val constraints: MutableVariableWithConstraints defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addSubTypeConstraintAndIncorporateIt[LocalVariableDescriptor]

'addConstraint' @ [78:25] ==> public final fun addConstraint(constraint: Constraint): Constraint? defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableVariableWithConstraints[SimpleFunctionDescriptorImpl]

'constraint' @ [78:39] ==> val constraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addSubTypeConstraintAndIncorporateIt[LocalVariableDescriptor]

'let' @ [78:52] ==> @InlineOnly public inline fun <T, R> Constraint.let(block: (Constraint) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Constraint
    <R> -> Unit

'constraintIncorporator' @ [79:17] ==> public final val constraintIncorporator: ConstraintIncorporator defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector[PropertyDescriptorImpl]

'incorporate' @ [79:40] ==> public final fun incorporate(c: ConstraintIncorporator.Context, typeVariable: NewTypeVariable, constraint: Constraint): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintIncorporator[SimpleFunctionDescriptorImpl]

'typeCheckerContext' @ [79:52] ==> val typeCheckerContext: ConstraintInjector.TypeCheckerContext defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addSubTypeConstraintAndIncorporateIt[LocalVariableDescriptor]

'typeVariable' @ [79:72] ==> val typeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addSubTypeConstraintAndIncorporateIt[LocalVariableDescriptor]

'it' @ [79:86] ==> value-parameter it: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.addSubTypeConstraintAndIncorporateIt.<anonymous>[ValueParameterDescriptorImpl]

'c' @ [85:9] ==> value-parameter c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.updateAllowedTypeDepth[ValueParameterDescriptorImpl]

'maxTypeDepthFromInitialConstraints' @ [85:11] ==> public abstract var maxTypeDepthFromInitialConstraints: Int defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.Context[PropertyDescriptorImpl]

'max' @ [85:53] ==> public open fun max(p0: Int, p1: Int): Int defined in java.lang.Math[JavaMethodDescriptor]

'c' @ [85:57] ==> value-parameter c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.updateAllowedTypeDepth[ValueParameterDescriptorImpl]

'maxTypeDepthFromInitialConstraints' @ [85:59] ==> public abstract var maxTypeDepthFromInitialConstraints: Int defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.Context[PropertyDescriptorImpl]

'initialType' @ [85:95] ==> value-parameter initialType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.updateAllowedTypeDepth[ValueParameterDescriptorImpl]

'typeDepth' @ [85:107] ==> internal fun UnwrappedType.typeDepth(): Int defined in org.jetbrains.kotlin.types[SimpleFunctionDescriptorImpl]

'assert' @ [89:9] ==> @InlineOnly public inline fun assert(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'constraint' @ [89:16] ==> value-parameter constraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.shouldWeSkipConstraint[ValueParameterDescriptorImpl]

'kind' @ [89:27] ==> public final val kind: ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'EQUALITY' @ [89:50] ==> enum entry EQUALITY defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'constraint' @ [91:30] ==> value-parameter constraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.shouldWeSkipConstraint[ValueParameterDescriptorImpl]

'type' @ [91:41] ==> public final val type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'!' @ [92:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isAllowedType' @ [92:14] ==> private final fun ConstraintInjector.Context.isAllowedType(type: UnwrappedType): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector[SimpleFunctionDescriptorImpl]

'constraintType' @ [92:28] ==> val constraintType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.shouldWeSkipConstraint[LocalVariableDescriptor]

'constraintType' @ [94:13] ==> val constraintType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.shouldWeSkipConstraint[LocalVariableDescriptor]

'constructor' @ [94:28] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.UnwrappedType[DeserializedPropertyDescriptor]

'typeVariable' @ [94:43] ==> value-parameter typeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.shouldWeSkipConstraint[ValueParameterDescriptorImpl]

'freshTypeConstructor' @ [94:56] ==> public final val freshTypeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewTypeVariable[PropertyDescriptorImpl]

'constraintType' @ [95:17] ==> val constraintType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.shouldWeSkipConstraint[LocalVariableDescriptor]

'lowerIfFlexible' @ [95:32] ==> public fun KotlinType.lowerIfFlexible(): SimpleType defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'isMarkedNullable' @ [95:50] ==> public abstract val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'constraint' @ [95:70] ==> value-parameter constraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.shouldWeSkipConstraint[ValueParameterDescriptorImpl]

'kind' @ [95:81] ==> public final val kind: ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'LOWER' @ [95:89] ==> enum entry LOWER defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'constraintType' @ [100:13] ==> val constraintType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.shouldWeSkipConstraint[LocalVariableDescriptor]

'constraint' @ [101:17] ==> value-parameter constraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.shouldWeSkipConstraint[ValueParameterDescriptorImpl]

'kind' @ [101:28] ==> public final val kind: ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'UPPER' @ [101:36] ==> enum entry UPPER defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'constraintType' @ [101:45] ==> val constraintType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.shouldWeSkipConstraint[LocalVariableDescriptor]

'isNullableAny' @ [101:60] ==> public fun KotlinType.isNullableAny(): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'constraint' @ [102:17] ==> value-parameter constraint: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.shouldWeSkipConstraint[ValueParameterDescriptorImpl]

'kind' @ [102:28] ==> public final val kind: ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'LOWER' @ [102:36] ==> enum entry LOWER defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'constraintType' @ [102:45] ==> val constraintType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.shouldWeSkipConstraint[LocalVariableDescriptor]

'isNothing' @ [102:60] ==> public fun KotlinType.isNothing(): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'type' @ [108:62] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.isAllowedType[ValueParameterDescriptorImpl]

'typeDepth' @ [108:67] ==> internal fun UnwrappedType.typeDepth(): Int defined in org.jetbrains.kotlin.types[SimpleFunctionDescriptorImpl]

'maxTypeDepthFromInitialConstraints' @ [108:82] ==> public abstract var maxTypeDepthFromInitialConstraints: Int defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.Context[PropertyDescriptorImpl]

'ALLOWED_DEPTH_DELTA_FOR_INCORPORATION' @ [108:119] ==> private final val ALLOWED_DEPTH_DELTA_FOR_INCORPORATION: Int defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector[PropertyDescriptorImpl]

'TypeCheckerContextForConstraintSystem' @ [116:9] ==> public constructor TypeCheckerContextForConstraintSystem() defined in org.jetbrains.kotlin.resolve.calls.inference.components.TypeCheckerContextForConstraintSystem[ClassConstructorDescriptorImpl]

'with' @ [119:13] ==> @InlineOnly public inline fun <T, R> with(receiver: NewKotlinTypeChecker, block: NewKotlinTypeChecker.() -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> NewKotlinTypeChecker
    <R> -> Unit

'NewKotlinTypeChecker' @ [119:18] ==> public object NewKotlinTypeChecker : KotlinTypeChecker defined in org.jetbrains.kotlin.types.checker[FakeCallableDescriptorForObject]

'!' @ [120:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'this@TypeCheckerContext' @ [120:22] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[LazyClassReceiverParameterDescriptor]

'isSubtypeOf' @ [120:46] ==> public final fun TypeCheckerContext.isSubtypeOf(subType: UnwrappedType, superType: UnwrappedType): Boolean defined in org.jetbrains.kotlin.types.checker.NewKotlinTypeChecker[DeserializedSimpleFunctionDescriptor]

'lowerType' @ [120:58] ==> value-parameter lowerType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.runIsSubtypeOf[ValueParameterDescriptorImpl]

'upperType' @ [120:69] ==> value-parameter upperType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.runIsSubtypeOf[ValueParameterDescriptorImpl]

'c' @ [122:21] ==> public final val c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[PropertyDescriptorImpl]

'addError' @ [122:23] ==> public abstract fun addError(error: KotlinCallDiagnostic): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.Context[SimpleFunctionDescriptorImpl]

'NewConstraintError' @ [122:32] ==> public constructor NewConstraintError(lowerType: UnwrappedType, upperType: UnwrappedType, position: IncorporationConstraintPosition) defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintError[ClassConstructorDescriptorImpl]

'lowerType' @ [122:51] ==> value-parameter lowerType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.runIsSubtypeOf[ValueParameterDescriptorImpl]

'upperType' @ [122:62] ==> value-parameter upperType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.runIsSubtypeOf[ValueParameterDescriptorImpl]

'position' @ [122:73] ==> public final val position: IncorporationConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[PropertyDescriptorImpl]

'c' @ [128:68] ==> public final val c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[PropertyDescriptorImpl]

'allTypeVariables' @ [128:70] ==> public abstract val allTypeVariables: Map<TypeConstructor, NewTypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.Context[PropertyDescriptorImpl]

'containsKey' @ [128:87] ==> public abstract fun containsKey(key: TypeConstructor): Boolean defined in kotlin.collections.Map[DeserializedSimpleFunctionDescriptor]

'type' @ [128:99] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.isMyTypeVariable[ValueParameterDescriptorImpl]

'constructor' @ [128:104] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.SimpleType[DeserializedPropertyDescriptor]

'addConstraint' @ [130:17] ==> private final fun addConstraint(typeVariableConstructor: TypeConstructor, type: UnwrappedType, kind: ConstraintKind): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[SimpleFunctionDescriptorImpl]

'typeVariable' @ [130:31] ==> value-parameter typeVariable: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addUpperConstraint[ValueParameterDescriptorImpl]

'superType' @ [130:45] ==> value-parameter superType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addUpperConstraint[ValueParameterDescriptorImpl]

'UPPER' @ [130:56] ==> enum entry UPPER defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'addConstraint' @ [133:17] ==> private final fun addConstraint(typeVariableConstructor: TypeConstructor, type: UnwrappedType, kind: ConstraintKind): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[SimpleFunctionDescriptorImpl]

'typeVariable' @ [133:31] ==> value-parameter typeVariable: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addLowerConstraint[ValueParameterDescriptorImpl]

'subType' @ [133:45] ==> value-parameter subType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addLowerConstraint[ValueParameterDescriptorImpl]

'LOWER' @ [133:54] ==> enum entry LOWER defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'when ((type as? NewCapturedType)?.captureStatus) {
                    null, CaptureStatus.FROM_EXPRESSION -> false
                    CaptureStatus.FOR_SUBTYPING -> true
                    CaptureStatus.FOR_INCORPORATION ->
                        error("Captured type for incorporation shouldn't escape from incorporation: $type\n" + renderBaseConstraint())
                }' @ [136:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean, entry2: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'type' @ [136:24] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.isCapturedTypeFromSubtyping[ValueParameterDescriptorImpl]

'captureStatus' @ [136:51] ==> public final val captureStatus: CaptureStatus defined in org.jetbrains.kotlin.types.checker.NewCapturedType[DeserializedPropertyDescriptor]

'FROM_EXPRESSION' @ [137:41] ==> enum entry FROM_EXPRESSION defined in org.jetbrains.kotlin.types.checker.CaptureStatus[FakeCallableDescriptorForObject]

'FOR_SUBTYPING' @ [138:35] ==> enum entry FOR_SUBTYPING defined in org.jetbrains.kotlin.types.checker.CaptureStatus[FakeCallableDescriptorForObject]

'FOR_INCORPORATION' @ [139:35] ==> enum entry FOR_INCORPORATION defined in org.jetbrains.kotlin.types.checker.CaptureStatus[FakeCallableDescriptorForObject]

'error' @ [140:25] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'+' @ [140:31] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'type' @ [140:102] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.isCapturedTypeFromSubtyping[ValueParameterDescriptorImpl]

'renderBaseConstraint' @ [140:112] ==> private final fun renderBaseConstraint(): String defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[SimpleFunctionDescriptorImpl]

'c' @ [144:32] ==> public final val c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[PropertyDescriptorImpl]

'allTypeVariables' @ [144:34] ==> public abstract val allTypeVariables: Map<TypeConstructor, NewTypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.Context[PropertyDescriptorImpl]

'typeVariableConstructor' @ [144:51] ==> value-parameter typeVariableConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addConstraint[ValueParameterDescriptorImpl]

'error' @ [145:35] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'typeVariableConstructor' @ [145:79] ==> value-parameter typeVariableConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addConstraint[ValueParameterDescriptorImpl]

'c' @ [145:106] ==> public final val c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[PropertyDescriptorImpl]

'allTypeVariables' @ [145:108] ==> public abstract val allTypeVariables: Map<TypeConstructor, NewTypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.Context[PropertyDescriptorImpl]

'values' @ [145:125] ==> public abstract val values: Collection<NewTypeVariable> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'type' @ [147:30] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addConstraint[ValueParameterDescriptorImpl]

'type' @ [148:17] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addConstraint[ValueParameterDescriptorImpl]

'contains' @ [148:22] ==> public fun KotlinType.contains(predicate: (UnwrappedType) -> Boolean): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'this' @ [148:31] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[LazyClassReceiverParameterDescriptor]

'kind' @ [150:21] ==> value-parameter kind: ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addConstraint[ValueParameterDescriptorImpl]

'UPPER' @ [150:29] ==> enum entry UPPER defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'typeApproximator' @ [151:35] ==> public final val typeApproximator: TypeApproximator defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector[PropertyDescriptorImpl]

'approximateToSubType' @ [151:52] ==> public final fun approximateToSubType(type: UnwrappedType, conf: TypeApproximatorConfiguration): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'type' @ [151:73] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addConstraint[ValueParameterDescriptorImpl]

'SubtypeCapturedTypesApproximation' @ [151:109] ==> public object SubtypeCapturedTypesApproximation : TypeApproximatorConfiguration.AbstractCapturedTypesApproximation defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration[FakeCallableDescriptorForObject]

'subType' @ [152:25] ==> val subType: UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addConstraint[LocalVariableDescriptor]

'!' @ [152:44] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isNothingOrNullableNothing' @ [152:60] ==> public open fun isNothingOrNullableNothing(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'subType' @ [152:87] ==> val subType: UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addConstraint[LocalVariableDescriptor]

'targetType' @ [153:25] ==> var targetType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addConstraint[LocalVariableDescriptor]

'subType' @ [153:38] ==> val subType: UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addConstraint[LocalVariableDescriptor]

'kind' @ [157:21] ==> value-parameter kind: ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addConstraint[ValueParameterDescriptorImpl]

'LOWER' @ [157:29] ==> enum entry LOWER defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'typeApproximator' @ [158:37] ==> public final val typeApproximator: TypeApproximator defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector[PropertyDescriptorImpl]

'approximateToSuperType' @ [158:54] ==> public final fun approximateToSuperType(type: UnwrappedType, conf: TypeApproximatorConfiguration): UnwrappedType? defined in org.jetbrains.kotlin.types.TypeApproximator[SimpleFunctionDescriptorImpl]

'type' @ [158:77] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addConstraint[ValueParameterDescriptorImpl]

'SubtypeCapturedTypesApproximation' @ [158:113] ==> public object SubtypeCapturedTypesApproximation : TypeApproximatorConfiguration.AbstractCapturedTypesApproximation defined in org.jetbrains.kotlin.types.TypeApproximatorConfiguration[FakeCallableDescriptorForObject]

'superType' @ [159:25] ==> val superType: UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addConstraint[LocalVariableDescriptor]

'!' @ [159:46] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isAnyOrNullableAny' @ [159:62] ==> public open fun isAnyOrNullableAny(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'superType' @ [159:81] ==> val superType: UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addConstraint[LocalVariableDescriptor]

'targetType' @ [160:25] ==> var targetType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addConstraint[LocalVariableDescriptor]

'superType' @ [160:38] ==> val superType: UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addConstraint[LocalVariableDescriptor]

'targetType' @ [164:21] ==> var targetType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addConstraint[LocalVariableDescriptor]

'type' @ [164:36] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addConstraint[ValueParameterDescriptorImpl]

'c' @ [165:21] ==> public final val c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[PropertyDescriptorImpl]

'addError' @ [165:23] ==> public abstract fun addError(error: KotlinCallDiagnostic): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.Context[SimpleFunctionDescriptorImpl]

'CapturedTypeFromSubtyping' @ [165:32] ==> public constructor CapturedTypeFromSubtyping(typeVariable: NewTypeVariable, constraintType: UnwrappedType, position: ConstraintPosition) defined in org.jetbrains.kotlin.resolve.calls.inference.model.CapturedTypeFromSubtyping[ClassConstructorDescriptorImpl]

'typeVariable' @ [165:58] ==> val typeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addConstraint[LocalVariableDescriptor]

'type' @ [165:72] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addConstraint[ValueParameterDescriptorImpl]

'position' @ [165:78] ==> public final val position: IncorporationConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[PropertyDescriptorImpl]

'possibleNewConstraints' @ [170:13] ==> public final val possibleNewConstraints: MutableList<Pair<NewTypeVariable, Constraint>> defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[PropertyDescriptorImpl]

'add' @ [170:36] ==> public abstract fun add(element: Pair<NewTypeVariable, Constraint>): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'typeVariable' @ [170:40] ==> val typeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addConstraint[LocalVariableDescriptor]

'Constraint' @ [170:56] ==> public constructor Constraint(kind: ConstraintKind, type: UnwrappedType, position: IncorporationConstraintPosition, typeHashCode: Int = ...) defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[ClassConstructorDescriptorImpl]

'kind' @ [170:67] ==> value-parameter kind: ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addConstraint[ValueParameterDescriptorImpl]

'targetType' @ [170:73] ==> var targetType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addConstraint[LocalVariableDescriptor]

'position' @ [170:85] ==> public final val position: IncorporationConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[PropertyDescriptorImpl]

'c' @ [175:17] ==> public final val c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[PropertyDescriptorImpl]

'isAllowedType' @ [175:19] ==> private final fun ConstraintInjector.Context.isAllowedType(type: UnwrappedType): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector[SimpleFunctionDescriptorImpl]

'lowerType' @ [175:33] ==> value-parameter lowerType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addNewIncorporatedConstraint[ValueParameterDescriptorImpl]

'c' @ [175:47] ==> public final val c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[PropertyDescriptorImpl]

'isAllowedType' @ [175:49] ==> private final fun ConstraintInjector.Context.isAllowedType(type: UnwrappedType): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector[SimpleFunctionDescriptorImpl]

'upperType' @ [175:63] ==> value-parameter upperType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addNewIncorporatedConstraint[ValueParameterDescriptorImpl]

'runIsSubtypeOf' @ [176:17] ==> public final fun runIsSubtypeOf(lowerType: UnwrappedType, upperType: UnwrappedType): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[SimpleFunctionDescriptorImpl]

'lowerType' @ [176:32] ==> value-parameter lowerType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addNewIncorporatedConstraint[ValueParameterDescriptorImpl]

'upperType' @ [176:43] ==> value-parameter upperType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.addNewIncorporatedConstraint[ValueParameterDescriptorImpl]

'c' @ [181:21] ==> public final val c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[PropertyDescriptorImpl]

'notFixedTypeVariables' @ [181:23] ==> public abstract val notFixedTypeVariables: MutableMap<TypeConstructor, MutableVariableWithConstraints> defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.Context[PropertyDescriptorImpl]

'values' @ [181:45] ==> public abstract val values: MutableCollection<MutableVariableWithConstraints> defined in kotlin.collections.MutableMap[DeserializedPropertyDescriptor]

'c' @ [184:32] ==> public final val c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[PropertyDescriptorImpl]

'allTypeVariables' @ [184:34] ==> public abstract val allTypeVariables: Map<TypeConstructor, NewTypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.Context[PropertyDescriptorImpl]

'typeConstructor' @ [184:51] ==> value-parameter typeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.getTypeVariable[ValueParameterDescriptorImpl]

'typeVariable' @ [185:17] ==> val typeVariable: NewTypeVariable? defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.getTypeVariable[LocalVariableDescriptor]

'!' @ [185:41] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'c' @ [185:42] ==> public final val c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[PropertyDescriptorImpl]

'notFixedTypeVariables' @ [185:44] ==> public abstract val notFixedTypeVariables: MutableMap<TypeConstructor, MutableVariableWithConstraints> defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.Context[PropertyDescriptorImpl]

'containsKey' @ [185:66] ==> public abstract fun containsKey(key: TypeConstructor): Boolean defined in kotlin.collections.MutableMap[DeserializedSimpleFunctionDescriptor]

'typeConstructor' @ [185:78] ==> value-parameter typeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.getTypeVariable[ValueParameterDescriptorImpl]

'fixedTypeVariable' @ [186:17] ==> public final fun fixedTypeVariable(variable: NewTypeVariable): Nothing defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[SimpleFunctionDescriptorImpl]

'typeVariable' @ [186:35] ==> val typeVariable: NewTypeVariable? defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.getTypeVariable[LocalVariableDescriptor]

'typeVariable' @ [188:20] ==> val typeVariable: NewTypeVariable? defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.getTypeVariable[LocalVariableDescriptor]

'c' @ [192:17] ==> public final val c: ConstraintInjector.Context defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[PropertyDescriptorImpl]

'notFixedTypeVariables' @ [192:19] ==> public abstract val notFixedTypeVariables: MutableMap<TypeConstructor, MutableVariableWithConstraints> defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.Context[PropertyDescriptorImpl]

'typeVariable' @ [192:41] ==> value-parameter typeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.getConstraintsForVariable[ValueParameterDescriptorImpl]

'freshTypeConstructor' @ [192:54] ==> public final val freshTypeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewTypeVariable[PropertyDescriptorImpl]

'constraints' @ [192:77] ==> public open val constraints: List<Constraint> defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableVariableWithConstraints[PropertyDescriptorImpl]

'fixedTypeVariable' @ [193:20] ==> public final fun fixedTypeVariable(variable: NewTypeVariable): Nothing defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[SimpleFunctionDescriptorImpl]

'typeVariable' @ [193:38] ==> value-parameter typeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.getConstraintsForVariable[ValueParameterDescriptorImpl]

'error' @ [196:13] ==> @InlineOnly public inline fun error(message: Any): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]

'+' @ [196:19] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'variable' @ [196:35] ==> value-parameter variable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext.fixedTypeVariable[ValueParameterDescriptorImpl]

'renderBaseConstraint' @ [197:19] ==> private final fun renderBaseConstraint(): String defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[SimpleFunctionDescriptorImpl]

'baseLowerType' @ [200:65] ==> public final val baseLowerType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[PropertyDescriptorImpl]

'baseUpperType' @ [200:83] ==> public final val baseUpperType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[PropertyDescriptorImpl]

'position' @ [200:113] ==> public final val position: IncorporationConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector.TypeCheckerContext[PropertyDescriptorImpl]

