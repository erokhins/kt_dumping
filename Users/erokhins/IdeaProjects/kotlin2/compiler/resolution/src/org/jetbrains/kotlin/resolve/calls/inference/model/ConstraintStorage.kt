'emptyMap' @ [57:86] ==> public fun <K, V> emptyMap(): Map<TypeConstructor, NewTypeVariable> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> TypeConstructor
    <V> -> NewTypeVariable

'emptyMap' @ [58:99] ==> public fun <K, V> emptyMap(): Map<TypeConstructor, VariableWithConstraints> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> TypeConstructor
    <V> -> VariableWithConstraints

'emptyList' @ [59:74] ==> public fun <T> emptyList(): List<InitialConstraint> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> InitialConstraint

'emptyList' @ [61:65] ==> public fun <T> emptyList(): List<KotlinCallDiagnostic> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinCallDiagnostic

'emptyMap' @ [62:86] ==> public fun <K, V> emptyMap(): Map<TypeConstructor, UnwrappedType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> TypeConstructor
    <V> -> UnwrappedType

'type' @ [76:33] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint.<init>[ValueParameterDescriptorImpl]

'hashCode' @ [76:38] ==> public final fun hashCode(): Int defined in org.jetbrains.kotlin.types.UnwrappedType[DeserializedSimpleFunctionDescriptor]

'this' @ [79:13] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[LazyClassReceiverParameterDescriptor]

'other' @ [79:22] ==> value-parameter other: Any? defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint.equals[ValueParameterDescriptorImpl]

'other' @ [80:13] ==> value-parameter other: Any? defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint.equals[ValueParameterDescriptorImpl]

'javaClass' @ [80:20] ==> public val <T : Any> Any.javaClass: Class<Any> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> Any

'javaClass' @ [80:33] ==> public val <T : Any> Constraint.javaClass: Class<Constraint> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> Constraint

'other' @ [82:9] ==> value-parameter other: Any? defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint.equals[ValueParameterDescriptorImpl]

'typeHashCode' @ [84:13] ==> public final val typeHashCode: Int defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'other' @ [84:29] ==> value-parameter other: Any? defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint.equals[ValueParameterDescriptorImpl]

'typeHashCode' @ [84:35] ==> public final val typeHashCode: Int defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'kind' @ [85:13] ==> public final val kind: ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'other' @ [85:21] ==> value-parameter other: Any? defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint.equals[ValueParameterDescriptorImpl]

'kind' @ [85:27] ==> public final val kind: ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'position' @ [86:13] ==> public final val position: IncorporationConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'other' @ [86:25] ==> value-parameter other: Any? defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint.equals[ValueParameterDescriptorImpl]

'position' @ [86:31] ==> public final val position: IncorporationConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'type' @ [87:13] ==> public final val type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'other' @ [87:21] ==> value-parameter other: Any? defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint.equals[ValueParameterDescriptorImpl]

'type' @ [87:27] ==> public final val type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'typeHashCode' @ [92:31] ==> public final val typeHashCode: Int defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'kind' @ [94:33] ==> public final val kind: ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'type' @ [94:39] ==> public final val type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'position' @ [94:51] ==> public final val position: IncorporationConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'when (constraintKind) {
            ConstraintKind.EQUALITY -> "=="
            ConstraintKind.LOWER -> ":>"
            ConstraintKind.UPPER -> "<:"
        }' @ [110:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: String, entry1: String, entry2: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> String

'constraintKind' @ [110:15] ==> public final val constraintKind: ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.model.InitialConstraint[PropertyDescriptorImpl]

'EQUALITY' @ [111:28] ==> enum entry EQUALITY defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'LOWER' @ [112:28] ==> enum entry LOWER defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'UPPER' @ [113:28] ==> enum entry UPPER defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'a' @ [115:18] ==> public final val a: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.InitialConstraint[PropertyDescriptorImpl]

'sign' @ [115:21] ==> val sign: String defined in org.jetbrains.kotlin.resolve.calls.inference.model.InitialConstraint.toString[LocalVariableDescriptor]

'b' @ [115:27] ==> public final val b: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.InitialConstraint[PropertyDescriptorImpl]

'position' @ [115:35] ==> public final val position: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.model.InitialConstraint[PropertyDescriptorImpl]

'substitutor' @ [120:16] ==> value-parameter substitutor: TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.inference.model.checkConstraint[ValueParameterDescriptorImpl]

'substitute' @ [120:28] ==> public fun TypeSubstitutor.substitute(type: UnwrappedType): UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference in file InferenceUtils.kt[SimpleFunctionDescriptorImpl]

'a' @ [120:39] ==> public final val a: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.InitialConstraint[PropertyDescriptorImpl]

'substitutor' @ [121:16] ==> value-parameter substitutor: TypeSubstitutor defined in org.jetbrains.kotlin.resolve.calls.inference.model.checkConstraint[ValueParameterDescriptorImpl]

'substitute' @ [121:28] ==> public fun TypeSubstitutor.substitute(type: UnwrappedType): UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference in file InferenceUtils.kt[SimpleFunctionDescriptorImpl]

'a' @ [121:39] ==> public final val a: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.InitialConstraint[PropertyDescriptorImpl]

'checkConstraint' @ [122:12] ==> public fun checkConstraint(constraintType: UnwrappedType, constraintKind: ConstraintKind, resultType: UnwrappedType): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.model in file ConstraintStorage.kt[SimpleFunctionDescriptorImpl]

'newB' @ [122:28] ==> val newB: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.checkConstraint[LocalVariableDescriptor]

'constraintKind' @ [122:34] ==> public final val constraintKind: ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.model.InitialConstraint[PropertyDescriptorImpl]

'newA' @ [122:50] ==> val newA: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.checkConstraint[LocalVariableDescriptor]

'DEFAULT' @ [126:41] ==> public final val DEFAULT: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaPropertyDescriptor]

'when (constraintKind) {
        ConstraintKind.EQUALITY -> typeChecker.equalTypes(constraintType, resultType)
        ConstraintKind.LOWER -> typeChecker.isSubtypeOf(constraintType, resultType)
        ConstraintKind.UPPER -> typeChecker.isSubtypeOf(resultType, constraintType)
    }' @ [127:12] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean, entry2: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'constraintKind' @ [127:18] ==> value-parameter constraintKind: ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.model.checkConstraint[ValueParameterDescriptorImpl]

'EQUALITY' @ [128:24] ==> enum entry EQUALITY defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'typeChecker' @ [128:36] ==> val typeChecker: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.resolve.calls.inference.model.checkConstraint[LocalVariableDescriptor]

'equalTypes' @ [128:48] ==> public abstract fun equalTypes(@NotNull p0: KotlinType, @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaMethodDescriptor]

'constraintType' @ [128:59] ==> value-parameter constraintType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.checkConstraint[ValueParameterDescriptorImpl]

'resultType' @ [128:75] ==> value-parameter resultType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.checkConstraint[ValueParameterDescriptorImpl]

'LOWER' @ [129:24] ==> enum entry LOWER defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'typeChecker' @ [129:33] ==> val typeChecker: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.resolve.calls.inference.model.checkConstraint[LocalVariableDescriptor]

'isSubtypeOf' @ [129:45] ==> public abstract fun isSubtypeOf(@NotNull p0: KotlinType, @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaMethodDescriptor]

'constraintType' @ [129:57] ==> value-parameter constraintType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.checkConstraint[ValueParameterDescriptorImpl]

'resultType' @ [129:73] ==> value-parameter resultType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.checkConstraint[ValueParameterDescriptorImpl]

'UPPER' @ [130:24] ==> enum entry UPPER defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'typeChecker' @ [130:33] ==> val typeChecker: (KotlinTypeChecker..KotlinTypeChecker?) defined in org.jetbrains.kotlin.resolve.calls.inference.model.checkConstraint[LocalVariableDescriptor]

'isSubtypeOf' @ [130:45] ==> public abstract fun isSubtypeOf(@NotNull p0: KotlinType, @NotNull p1: KotlinType): Boolean defined in org.jetbrains.kotlin.types.checker.KotlinTypeChecker[JavaMethodDescriptor]

'resultType' @ [130:57] ==> value-parameter resultType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.checkConstraint[ValueParameterDescriptorImpl]

'constraintType' @ [130:69] ==> value-parameter constraintType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.checkConstraint[ValueParameterDescriptorImpl]

