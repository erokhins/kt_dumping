'MutableConstraintStorage' @ [51:27] ==> public constructor MutableConstraintStorage() defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[ClassConstructorDescriptorImpl]

'BUILDING' @ [52:31] ==> enum entry BUILDING defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'SmartList' @ [53:74] ==> public constructor SmartList<E : (Any..Any?)>() defined in org.jetbrains.kotlin.utils.SmartList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> (org.jetbrains.kotlin.resolve.calls.inference.model.NewTypeVariable..org.jetbrains.kotlin.resolve.calls.inference.model.NewTypeVariable?)

'assert' @ [63:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'state' @ [63:16] ==> private final var state: NewConstraintSystemImpl.State defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'allowedState' @ [63:25] ==> value-parameter vararg allowedState: NewConstraintSystemImpl.State defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.checkState[ValueParameterDescriptorImpl]

'state' @ [64:21] ==> private final var state: NewConstraintSystemImpl.State defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'allowedState' @ [64:60] ==> value-parameter vararg allowedState: NewConstraintSystemImpl.State defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.checkState[ValueParameterDescriptorImpl]

'joinToString' @ [64:73] ==> public fun <T> Array<out NewConstraintSystemImpl.State>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((NewConstraintSystemImpl.State) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> State

'storage' @ [69:17] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'errors' @ [69:25] ==> public open val errors: MutableList<KotlinCallDiagnostic> defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'apply' @ [71:33] ==> @InlineOnly public inline fun <T> NewConstraintSystemImpl.apply(block: NewConstraintSystemImpl.() -> Unit): NewConstraintSystemImpl defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> NewConstraintSystemImpl

'checkState' @ [71:41] ==> private final fun checkState(vararg allowedState: NewConstraintSystemImpl.State): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'BUILDING' @ [71:58] ==> enum entry BUILDING defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'COMPLETION' @ [71:74] ==> enum entry COMPLETION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'checkState' @ [74:9] ==> private final fun checkState(vararg allowedState: NewConstraintSystemImpl.State): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'BUILDING' @ [74:26] ==> enum entry BUILDING defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'FREEZED' @ [74:42] ==> enum entry FREEZED defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'state' @ [75:9] ==> private final var state: NewConstraintSystemImpl.State defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'FREEZED' @ [75:23] ==> enum entry FREEZED defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'storage' @ [76:16] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'apply' @ [79:57] ==> @InlineOnly public inline fun <T> NewConstraintSystemImpl.apply(block: NewConstraintSystemImpl.() -> Unit): NewConstraintSystemImpl defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> NewConstraintSystemImpl

'checkState' @ [79:65] ==> private final fun checkState(vararg allowedState: NewConstraintSystemImpl.State): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'BUILDING' @ [79:82] ==> enum entry BUILDING defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'apply' @ [81:58] ==> @InlineOnly public inline fun <T> NewConstraintSystemImpl.apply(block: NewConstraintSystemImpl.() -> Unit): NewConstraintSystemImpl defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> NewConstraintSystemImpl

'checkState' @ [81:66] ==> private final fun checkState(vararg allowedState: NewConstraintSystemImpl.State): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'BUILDING' @ [81:83] ==> enum entry BUILDING defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'checkState' @ [85:9] ==> private final fun checkState(vararg allowedState: NewConstraintSystemImpl.State): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'BUILDING' @ [85:26] ==> enum entry BUILDING defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'COMPLETION' @ [85:42] ==> enum entry COMPLETION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'TRANSACTION' @ [85:60] ==> enum entry TRANSACTION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'transactionRegisterVariable' @ [87:9] ==> private final fun transactionRegisterVariable(variable: NewTypeVariable): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'variable' @ [87:37] ==> value-parameter variable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.registerVariable[ValueParameterDescriptorImpl]

'storage' @ [88:9] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'allTypeVariables' @ [88:17] ==> public open val allTypeVariables: MutableMap<TypeConstructor, NewTypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'variable' @ [88:34] ==> value-parameter variable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.registerVariable[ValueParameterDescriptorImpl]

'freshTypeConstructor' @ [88:43] ==> public final val freshTypeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewTypeVariable[PropertyDescriptorImpl]

'variable' @ [88:67] ==> value-parameter variable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.registerVariable[ValueParameterDescriptorImpl]

'storage' @ [89:9] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'notFixedTypeVariables' @ [89:17] ==> public open val notFixedTypeVariables: MutableMap<TypeConstructor, MutableVariableWithConstraints> defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'variable' @ [89:39] ==> value-parameter variable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.registerVariable[ValueParameterDescriptorImpl]

'freshTypeConstructor' @ [89:48] ==> public final val freshTypeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewTypeVariable[PropertyDescriptorImpl]

'MutableVariableWithConstraints' @ [89:72] ==> public constructor MutableVariableWithConstraints(typeVariable: NewTypeVariable, constraints: Collection<Constraint> = ...) defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableVariableWithConstraints[ClassConstructorDescriptorImpl]

'variable' @ [89:103] ==> value-parameter variable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.registerVariable[ValueParameterDescriptorImpl]

'constraintInjector' @ [93:13] ==> private final val constraintInjector: ConstraintInjector defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'addInitialSubtypeConstraint' @ [93:32] ==> public final fun addInitialSubtypeConstraint(c: ConstraintInjector.Context, lowerType: UnwrappedType, upperType: UnwrappedType, position: ConstraintPosition): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector[SimpleFunctionDescriptorImpl]

'apply' @ [93:60] ==> @InlineOnly public inline fun <T> NewConstraintSystemImpl.apply(block: NewConstraintSystemImpl.() -> Unit): NewConstraintSystemImpl defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> NewConstraintSystemImpl

'checkState' @ [93:68] ==> private final fun checkState(vararg allowedState: NewConstraintSystemImpl.State): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'BUILDING' @ [93:85] ==> enum entry BUILDING defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'COMPLETION' @ [93:101] ==> enum entry COMPLETION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'TRANSACTION' @ [93:119] ==> enum entry TRANSACTION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'lowerType' @ [93:135] ==> value-parameter lowerType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.addSubtypeConstraint[ValueParameterDescriptorImpl]

'upperType' @ [93:146] ==> value-parameter upperType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.addSubtypeConstraint[ValueParameterDescriptorImpl]

'position' @ [93:157] ==> value-parameter position: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.addSubtypeConstraint[ValueParameterDescriptorImpl]

'constraintInjector' @ [96:13] ==> private final val constraintInjector: ConstraintInjector defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'addInitialEqualityConstraint' @ [96:32] ==> public final fun addInitialEqualityConstraint(c: ConstraintInjector.Context, a: UnwrappedType, b: UnwrappedType, position: ConstraintPosition): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector[SimpleFunctionDescriptorImpl]

'apply' @ [96:61] ==> @InlineOnly public inline fun <T> NewConstraintSystemImpl.apply(block: NewConstraintSystemImpl.() -> Unit): NewConstraintSystemImpl defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> NewConstraintSystemImpl

'checkState' @ [96:69] ==> private final fun checkState(vararg allowedState: NewConstraintSystemImpl.State): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'BUILDING' @ [96:86] ==> enum entry BUILDING defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'COMPLETION' @ [96:102] ==> enum entry COMPLETION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'TRANSACTION' @ [96:120] ==> enum entry TRANSACTION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'a' @ [96:136] ==> value-parameter a: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.addEqualityConstraint[ValueParameterDescriptorImpl]

'b' @ [96:139] ==> value-parameter b: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.addEqualityConstraint[ValueParameterDescriptorImpl]

'position' @ [96:142] ==> value-parameter position: ConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.addEqualityConstraint[ValueParameterDescriptorImpl]

'checkState' @ [99:9] ==> private final fun checkState(vararg allowedState: NewConstraintSystemImpl.State): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'BUILDING' @ [99:26] ==> enum entry BUILDING defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'COMPLETION' @ [99:42] ==> enum entry COMPLETION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'TRANSACTION' @ [99:60] ==> enum entry TRANSACTION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'notFixedTypeVariables' @ [100:39] ==> public open val notFixedTypeVariables: MutableMap<TypeConstructor, MutableVariableWithConstraints> defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'type' @ [100:61] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.getProperSuperTypeConstructors[ValueParameterDescriptorImpl]

'constructor' @ [100:66] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.UnwrappedType[DeserializedPropertyDescriptor]

'listOf' @ [100:89] ==> public fun <T> listOf(element: TypeConstructor): List<TypeConstructor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeConstructor

'type' @ [100:96] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.getProperSuperTypeConstructors[ValueParameterDescriptorImpl]

'constructor' @ [100:101] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.UnwrappedType[DeserializedPropertyDescriptor]

'variableWithConstraints' @ [102:16] ==> val variableWithConstraints: MutableVariableWithConstraints defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.getProperSuperTypeConstructors[LocalVariableDescriptor]

'constraints' @ [102:40] ==> public open val constraints: List<Constraint> defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableVariableWithConstraints[PropertyDescriptorImpl]

'mapNotNull' @ [102:52] ==> public inline fun <T, R : Any> Iterable<Constraint>.mapNotNull(transform: (Constraint) -> TypeConstructor?): List<TypeConstructor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Constraint
    <R : Any> -> TypeConstructor

'it' @ [103:17] ==> value-parameter it: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.getProperSuperTypeConstructors.<anonymous>[ValueParameterDescriptorImpl]

'kind' @ [103:20] ==> public final val kind: ConstraintKind defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'LOWER' @ [103:43] ==> enum entry LOWER defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintKind[FakeCallableDescriptorForObject]

'it' @ [104:13] ==> value-parameter it: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.getProperSuperTypeConstructors.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [104:16] ==> public final val type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'constructor' @ [104:21] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.UnwrappedType[DeserializedPropertyDescriptor]

'takeUnless' @ [104:33] ==> @InlineOnly @SinceKotlin public inline fun <T> TypeConstructor.takeUnless(predicate: (TypeConstructor) -> Boolean): TypeConstructor? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeConstructor

'allTypeVariables' @ [104:46] ==> public open val allTypeVariables: Map<TypeConstructor, NewTypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'containsKey' @ [104:63] ==> public abstract fun containsKey(key: TypeConstructor): Boolean defined in kotlin.collections.Map[DeserializedSimpleFunctionDescriptor]

'it' @ [104:75] ==> value-parameter it: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.getProperSuperTypeConstructors.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'state' @ [110:13] ==> private final var state: NewConstraintSystemImpl.State defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'TRANSACTION' @ [110:28] ==> enum entry TRANSACTION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'typeVariablesTransaction' @ [111:9] ==> private final val typeVariablesTransaction: MutableList<NewTypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'add' @ [111:34] ==> public abstract fun add(element: NewTypeVariable): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'variable' @ [111:38] ==> value-parameter variable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.transactionRegisterVariable[ValueParameterDescriptorImpl]

'checkState' @ [115:9] ==> private final fun checkState(vararg allowedState: NewConstraintSystemImpl.State): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'TRANSACTION' @ [115:26] ==> enum entry TRANSACTION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'typeVariablesTransaction' @ [116:9] ==> private final val typeVariablesTransaction: MutableList<NewTypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'clear' @ [116:34] ==> public abstract fun clear(): Unit defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'state' @ [117:9] ==> private final var state: NewConstraintSystemImpl.State defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'beforeState' @ [117:17] ==> value-parameter beforeState: NewConstraintSystemImpl.State defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.closeTransaction[ValueParameterDescriptorImpl]

'checkState' @ [121:9] ==> private final fun checkState(vararg allowedState: NewConstraintSystemImpl.State): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'BUILDING' @ [121:26] ==> enum entry BUILDING defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'COMPLETION' @ [121:42] ==> enum entry COMPLETION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'state' @ [122:27] ==> private final var state: NewConstraintSystemImpl.State defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'storage' @ [123:44] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'initialConstraints' @ [123:52] ==> public open val initialConstraints: MutableList<InitialConstraint> defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'size' @ [123:71] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'storage' @ [124:33] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'errors' @ [124:41] ==> public open val errors: MutableList<KotlinCallDiagnostic> defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'size' @ [124:48] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'storage' @ [125:56] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'maxTypeDepthFromInitialConstraints' @ [125:64] ==> public open var maxTypeDepthFromInitialConstraints: Int defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'state' @ [127:9] ==> private final var state: NewConstraintSystemImpl.State defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'TRANSACTION' @ [127:23] ==> enum entry TRANSACTION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'invoke' @ [129:13] ==> public abstract operator fun ConstraintSystemOperation.invoke(): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'closeTransaction' @ [130:13] ==> private final fun closeTransaction(beforeState: NewConstraintSystemImpl.State): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'beforeState' @ [130:30] ==> val beforeState: NewConstraintSystemImpl.State defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.runTransaction[LocalVariableDescriptor]

'typeVariablesTransaction' @ [134:35] ==> private final val typeVariablesTransaction: MutableList<NewTypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'storage' @ [135:13] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'allTypeVariables' @ [135:21] ==> public open val allTypeVariables: MutableMap<TypeConstructor, NewTypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'remove' @ [135:38] ==> public abstract fun remove(key: TypeConstructor): NewTypeVariable? defined in kotlin.collections.MutableMap[DeserializedSimpleFunctionDescriptor]

'addedTypeVariable' @ [135:45] ==> val addedTypeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.runTransaction[LocalVariableDescriptor]

'freshTypeConstructor' @ [135:63] ==> public final val freshTypeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewTypeVariable[PropertyDescriptorImpl]

'storage' @ [136:13] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'notFixedTypeVariables' @ [136:21] ==> public open val notFixedTypeVariables: MutableMap<TypeConstructor, MutableVariableWithConstraints> defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'remove' @ [136:43] ==> public abstract fun remove(key: TypeConstructor): MutableVariableWithConstraints? defined in kotlin.collections.MutableMap[DeserializedSimpleFunctionDescriptor]

'addedTypeVariable' @ [136:50] ==> val addedTypeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.runTransaction[LocalVariableDescriptor]

'freshTypeConstructor' @ [136:68] ==> public final val freshTypeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewTypeVariable[PropertyDescriptorImpl]

'storage' @ [138:9] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'maxTypeDepthFromInitialConstraints' @ [138:17] ==> public open var maxTypeDepthFromInitialConstraints: Int defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'beforeMaxTypeDepthFromInitialConstraints' @ [138:54] ==> val beforeMaxTypeDepthFromInitialConstraints: Int defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.runTransaction[LocalVariableDescriptor]

'storage' @ [139:9] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'errors' @ [139:17] ==> public open val errors: MutableList<KotlinCallDiagnostic> defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'trimToSize' @ [139:24] ==> internal fun <E> MutableList<KotlinCallDiagnostic>.trimToSize(newSize: Int): Unit defined in org.jetbrains.kotlin.resolve.calls.inference[SimpleFunctionDescriptorImpl]
Inferred types:
    <E> -> KotlinCallDiagnostic

'beforeErrorsCount' @ [139:35] ==> val beforeErrorsCount: Int defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.runTransaction[LocalVariableDescriptor]

'storage' @ [141:39] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'initialConstraints' @ [141:47] ==> public open val initialConstraints: MutableList<InitialConstraint> defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'subList' @ [141:66] ==> public abstract fun subList(fromIndex: Int, toIndex: Int): MutableList<InitialConstraint> defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'beforeInitialConstraintCount' @ [141:74] ==> val beforeInitialConstraintCount: Int defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.runTransaction[LocalVariableDescriptor]

'storage' @ [141:104] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'initialConstraints' @ [141:112] ==> public open val initialConstraints: MutableList<InitialConstraint> defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'size' @ [141:131] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'addedInitialConstraints' @ [143:47] ==> val addedInitialConstraints: MutableList<InitialConstraint> defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.runTransaction[LocalVariableDescriptor]

'contains' @ [143:71] ==> public abstract fun contains(element: InitialConstraint): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'c' @ [143:80] ==> value-parameter c: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.runTransaction.<anonymous>[ValueParameterDescriptorImpl]

'position' @ [143:82] ==> public final val position: IncorporationConstraintPosition defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'initialConstraint' @ [143:91] ==> public final val initialConstraint: InitialConstraint defined in org.jetbrains.kotlin.resolve.calls.inference.model.IncorporationConstraintPosition[PropertyDescriptorImpl]

'storage' @ [145:40] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'notFixedTypeVariables' @ [145:48] ==> public open val notFixedTypeVariables: MutableMap<TypeConstructor, MutableVariableWithConstraints> defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'values' @ [145:70] ==> public abstract val values: MutableCollection<MutableVariableWithConstraints> defined in kotlin.collections.MutableMap[DeserializedPropertyDescriptor]

'variableWithConstraint' @ [146:13] ==> val variableWithConstraint: MutableVariableWithConstraints defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.runTransaction[LocalVariableDescriptor]

'removeLastConstraints' @ [146:36] ==> internal final fun removeLastConstraints(shouldRemove: (Constraint) -> Boolean): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableVariableWithConstraints[SimpleFunctionDescriptorImpl]

'shouldRemove' @ [146:58] ==> val shouldRemove: (Constraint) -> Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.runTransaction[LocalVariableDescriptor]

'addedInitialConstraints' @ [149:9] ==> val addedInitialConstraints: MutableList<InitialConstraint> defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.runTransaction[LocalVariableDescriptor]

'clear' @ [149:33] ==> public abstract fun clear(): Unit defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'closeTransaction' @ [150:9] ==> private final fun closeTransaction(beforeState: NewConstraintSystemImpl.State): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'beforeState' @ [150:26] ==> val beforeState: NewConstraintSystemImpl.State defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.runTransaction[LocalVariableDescriptor]

'diagnostics' @ [156:17] ==> public open val diagnostics: List<KotlinCallDiagnostic> defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'any' @ [156:29] ==> public inline fun <T> Iterable<KotlinCallDiagnostic>.any(predicate: (KotlinCallDiagnostic) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinCallDiagnostic

'!' @ [156:35] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'it' @ [156:36] ==> value-parameter it: KotlinCallDiagnostic defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.<get-hasContradiction>.<anonymous>[ValueParameterDescriptorImpl]

'candidateApplicability' @ [156:39] ==> public final val candidateApplicability: ResolutionCandidateApplicability defined in org.jetbrains.kotlin.resolve.calls.model.KotlinCallDiagnostic[PropertyDescriptorImpl]

'isSuccess' @ [156:62] ==> public val ResolutionCandidateApplicability.isSuccess: Boolean defined in org.jetbrains.kotlin.resolve.calls.tower in file TowerUtils.kt[PropertyDescriptorImpl]

'apply' @ [156:74] ==> @InlineOnly public inline fun <T> Boolean.apply(block: Boolean.() -> Unit): Boolean defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Boolean

'checkState' @ [156:82] ==> private final fun checkState(vararg allowedState: NewConstraintSystemImpl.State): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'FREEZED' @ [156:99] ==> enum entry FREEZED defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'BUILDING' @ [156:114] ==> enum entry BUILDING defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'COMPLETION' @ [156:130] ==> enum entry COMPLETION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'TRANSACTION' @ [156:148] ==> enum entry TRANSACTION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'storage' @ [159:9] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'allTypeVariables' @ [159:17] ==> public open val allTypeVariables: MutableMap<TypeConstructor, NewTypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'putAll' @ [159:34] ==> public abstract fun putAll(from: Map<out TypeConstructor, NewTypeVariable>): Unit defined in kotlin.collections.MutableMap[DeserializedSimpleFunctionDescriptor]

'otherSystem' @ [159:41] ==> value-parameter otherSystem: ConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.addOtherSystem[ValueParameterDescriptorImpl]

'allTypeVariables' @ [159:53] ==> public abstract val allTypeVariables: Map<TypeConstructor, NewTypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintStorage[PropertyDescriptorImpl]

'component1' @ [160:15] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<TypeConstructor, VariableWithConstraints>.component1(): TypeConstructor defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> TypeConstructor
    <V> -> VariableWithConstraints

'component2' @ [160:25] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<TypeConstructor, VariableWithConstraints>.component2(): VariableWithConstraints defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> TypeConstructor
    <V> -> VariableWithConstraints

'otherSystem' @ [160:41] ==> value-parameter otherSystem: ConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.addOtherSystem[ValueParameterDescriptorImpl]

'notFixedTypeVariables' @ [160:53] ==> public abstract val notFixedTypeVariables: Map<TypeConstructor, VariableWithConstraints> defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintStorage[PropertyDescriptorImpl]

'notFixedTypeVariables' @ [161:13] ==> public open val notFixedTypeVariables: MutableMap<TypeConstructor, MutableVariableWithConstraints> defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'variable' @ [161:35] ==> val variable: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.addOtherSystem[LocalVariableDescriptor]

'MutableVariableWithConstraints' @ [161:47] ==> public constructor MutableVariableWithConstraints(typeVariable: NewTypeVariable, constraints: Collection<Constraint> = ...) defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableVariableWithConstraints[ClassConstructorDescriptorImpl]

'constraints' @ [161:78] ==> val constraints: VariableWithConstraints defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.addOtherSystem[LocalVariableDescriptor]

'typeVariable' @ [161:90] ==> public abstract val typeVariable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.model.VariableWithConstraints[PropertyDescriptorImpl]

'constraints' @ [161:104] ==> val constraints: VariableWithConstraints defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.addOtherSystem[LocalVariableDescriptor]

'constraints' @ [161:116] ==> public abstract val constraints: List<Constraint> defined in org.jetbrains.kotlin.resolve.calls.inference.model.VariableWithConstraints[PropertyDescriptorImpl]

'storage' @ [163:9] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'initialConstraints' @ [163:17] ==> public open val initialConstraints: MutableList<InitialConstraint> defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'addAll' @ [163:36] ==> public abstract fun addAll(elements: Collection<InitialConstraint>): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'otherSystem' @ [163:43] ==> value-parameter otherSystem: ConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.addOtherSystem[ValueParameterDescriptorImpl]

'initialConstraints' @ [163:55] ==> public abstract val initialConstraints: List<InitialConstraint> defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintStorage[PropertyDescriptorImpl]

'storage' @ [164:9] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'maxTypeDepthFromInitialConstraints' @ [164:17] ==> public open var maxTypeDepthFromInitialConstraints: Int defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'max' @ [164:59] ==> public open fun max(p0: Int, p1: Int): Int defined in java.lang.Math[JavaMethodDescriptor]

'storage' @ [164:63] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'maxTypeDepthFromInitialConstraints' @ [164:71] ==> public open var maxTypeDepthFromInitialConstraints: Int defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'otherSystem' @ [164:107] ==> value-parameter otherSystem: ConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.addOtherSystem[ValueParameterDescriptorImpl]

'maxTypeDepthFromInitialConstraints' @ [164:119] ==> public abstract val maxTypeDepthFromInitialConstraints: Int defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintStorage[PropertyDescriptorImpl]

'storage' @ [165:9] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'errors' @ [165:17] ==> public open val errors: MutableList<KotlinCallDiagnostic> defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'addAll' @ [165:24] ==> public abstract fun addAll(elements: Collection<KotlinCallDiagnostic>): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'otherSystem' @ [165:31] ==> value-parameter otherSystem: ConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.addOtherSystem[ValueParameterDescriptorImpl]

'errors' @ [165:43] ==> public abstract val errors: List<KotlinCallDiagnostic> defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintStorage[PropertyDescriptorImpl]

'storage' @ [166:9] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'fixedTypeVariables' @ [166:17] ==> public open val fixedTypeVariables: MutableMap<TypeConstructor, UnwrappedType> defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'putAll' @ [166:36] ==> public abstract fun putAll(from: Map<out TypeConstructor, UnwrappedType>): Unit defined in kotlin.collections.MutableMap[DeserializedSimpleFunctionDescriptor]

'otherSystem' @ [166:43] ==> value-parameter otherSystem: ConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.addOtherSystem[ValueParameterDescriptorImpl]

'fixedTypeVariables' @ [166:55] ==> public abstract val fixedTypeVariables: Map<TypeConstructor, UnwrappedType> defined in org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintStorage[PropertyDescriptorImpl]

'checkState' @ [171:9] ==> private final fun checkState(vararg allowedState: NewConstraintSystemImpl.State): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'BUILDING' @ [171:26] ==> enum entry BUILDING defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'COMPLETION' @ [171:42] ==> enum entry COMPLETION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'TRANSACTION' @ [171:60] ==> enum entry TRANSACTION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'!' @ [172:16] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'type' @ [172:17] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.isProperType[ValueParameterDescriptorImpl]

'contains' @ [172:22] ==> public fun KotlinType.contains(predicate: (UnwrappedType) -> Boolean): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'storage' @ [173:13] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'allTypeVariables' @ [173:21] ==> public open val allTypeVariables: MutableMap<TypeConstructor, NewTypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'containsKey' @ [173:38] ==> public abstract fun containsKey(key: TypeConstructor): Boolean defined in kotlin.collections.MutableMap[DeserializedSimpleFunctionDescriptor]

'it' @ [173:50] ==> value-parameter it: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.isProperType.<anonymous>[ValueParameterDescriptorImpl]

'constructor' @ [173:53] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.UnwrappedType[DeserializedPropertyDescriptor]

'checkState' @ [178:9] ==> private final fun checkState(vararg allowedState: NewConstraintSystemImpl.State): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'BUILDING' @ [178:26] ==> enum entry BUILDING defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'COMPLETION' @ [178:42] ==> enum entry COMPLETION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'TRANSACTION' @ [178:60] ==> enum entry TRANSACTION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'notFixedTypeVariables' @ [179:16] ==> public open val notFixedTypeVariables: MutableMap<TypeConstructor, MutableVariableWithConstraints> defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'containsKey' @ [179:38] ==> public abstract fun containsKey(key: TypeConstructor): Boolean defined in kotlin.collections.MutableMap[DeserializedSimpleFunctionDescriptor]

'type' @ [179:50] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.isTypeVariable[ValueParameterDescriptorImpl]

'constructor' @ [179:55] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.UnwrappedType[DeserializedPropertyDescriptor]

'checkState' @ [184:9] ==> private final fun checkState(vararg allowedState: NewConstraintSystemImpl.State): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'BUILDING' @ [184:26] ==> enum entry BUILDING defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'COMPLETION' @ [184:42] ==> enum entry COMPLETION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'TRANSACTION' @ [184:60] ==> enum entry TRANSACTION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'storage' @ [185:16] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'allTypeVariables' @ [185:24] ==> public open val allTypeVariables: MutableMap<TypeConstructor, NewTypeVariable> defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'storage' @ [189:17] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'maxTypeDepthFromInitialConstraints' @ [189:25] ==> public open var maxTypeDepthFromInitialConstraints: Int defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'checkState' @ [191:13] ==> private final fun checkState(vararg allowedState: NewConstraintSystemImpl.State): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'BUILDING' @ [191:30] ==> enum entry BUILDING defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'COMPLETION' @ [191:46] ==> enum entry COMPLETION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'TRANSACTION' @ [191:64] ==> enum entry TRANSACTION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'storage' @ [192:13] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'maxTypeDepthFromInitialConstraints' @ [192:21] ==> public open var maxTypeDepthFromInitialConstraints: Int defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'value' @ [192:58] ==> value-parameter value: Int defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.<set-maxTypeDepthFromInitialConstraints>[ValueParameterDescriptorImpl]

'checkState' @ [196:9] ==> private final fun checkState(vararg allowedState: NewConstraintSystemImpl.State): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'BUILDING' @ [196:26] ==> enum entry BUILDING defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'COMPLETION' @ [196:42] ==> enum entry COMPLETION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'TRANSACTION' @ [196:60] ==> enum entry TRANSACTION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'storage' @ [197:9] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'initialConstraints' @ [197:17] ==> public open val initialConstraints: MutableList<InitialConstraint> defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'add' @ [197:36] ==> public abstract fun add(element: InitialConstraint): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'initialConstraint' @ [197:40] ==> value-parameter initialConstraint: InitialConstraint defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.addInitialConstraint[ValueParameterDescriptorImpl]

'checkState' @ [202:9] ==> private final fun checkState(vararg allowedState: NewConstraintSystemImpl.State): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'BUILDING' @ [202:26] ==> enum entry BUILDING defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'COMPLETION' @ [202:42] ==> enum entry COMPLETION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'TRANSACTION' @ [202:60] ==> enum entry TRANSACTION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'storage' @ [203:16] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'notFixedTypeVariables' @ [203:24] ==> public open val notFixedTypeVariables: MutableMap<TypeConstructor, MutableVariableWithConstraints> defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'checkState' @ [208:9] ==> private final fun checkState(vararg allowedState: NewConstraintSystemImpl.State): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'BUILDING' @ [208:26] ==> enum entry BUILDING defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'COMPLETION' @ [208:42] ==> enum entry COMPLETION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'TRANSACTION' @ [208:60] ==> enum entry TRANSACTION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'storage' @ [209:9] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'errors' @ [209:17] ==> public open val errors: MutableList<KotlinCallDiagnostic> defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'add' @ [209:24] ==> public abstract fun add(element: KotlinCallDiagnostic): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'error' @ [209:28] ==> value-parameter error: KotlinCallDiagnostic defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.addError[ValueParameterDescriptorImpl]

'checkState' @ [214:9] ==> private final fun checkState(vararg allowedState: NewConstraintSystemImpl.State): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'BUILDING' @ [214:26] ==> enum entry BUILDING defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'COMPLETION' @ [214:42] ==> enum entry COMPLETION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'eliminateSpecialIntersectionType' @ [216:32] ==> private final fun eliminateSpecialIntersectionType(variable: NewTypeVariable, type: UnwrappedType): UnwrappedType? defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'variable' @ [216:65] ==> value-parameter variable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.fixVariable[ValueParameterDescriptorImpl]

'resultType' @ [216:75] ==> value-parameter resultType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.fixVariable[ValueParameterDescriptorImpl]

'resultType' @ [216:90] ==> value-parameter resultType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.fixVariable[ValueParameterDescriptorImpl]

'constraintInjector' @ [217:9] ==> private final val constraintInjector: ConstraintInjector defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'addInitialEqualityConstraint' @ [217:28] ==> public final fun addInitialEqualityConstraint(c: ConstraintInjector.Context, a: UnwrappedType, b: UnwrappedType, position: ConstraintPosition): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintInjector[SimpleFunctionDescriptorImpl]

'this' @ [217:57] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[LazyClassReceiverParameterDescriptor]

'variable' @ [217:63] ==> value-parameter variable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.fixVariable[ValueParameterDescriptorImpl]

'defaultType' @ [217:72] ==> public final val defaultType: SimpleType defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewTypeVariable[PropertyDescriptorImpl]

'actualResultType' @ [217:85] ==> val actualResultType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.fixVariable[LocalVariableDescriptor]

'FixVariableConstraintPosition' @ [217:103] ==> public constructor FixVariableConstraintPosition(variable: NewTypeVariable) defined in org.jetbrains.kotlin.resolve.calls.inference.model.FixVariableConstraintPosition[ClassConstructorDescriptorImpl]

'variable' @ [217:133] ==> value-parameter variable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.fixVariable[ValueParameterDescriptorImpl]

'notFixedTypeVariables' @ [218:9] ==> public open val notFixedTypeVariables: MutableMap<TypeConstructor, MutableVariableWithConstraints> defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'remove' @ [218:31] ==> public abstract fun remove(key: TypeConstructor): MutableVariableWithConstraints? defined in kotlin.collections.MutableMap[DeserializedSimpleFunctionDescriptor]

'variable' @ [218:38] ==> value-parameter variable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.fixVariable[ValueParameterDescriptorImpl]

'freshTypeConstructor' @ [218:47] ==> public final val freshTypeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewTypeVariable[PropertyDescriptorImpl]

'notFixedTypeVariables' @ [220:40] ==> public open val notFixedTypeVariables: MutableMap<TypeConstructor, MutableVariableWithConstraints> defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'values' @ [220:62] ==> public abstract val values: MutableCollection<MutableVariableWithConstraints> defined in kotlin.collections.MutableMap[DeserializedPropertyDescriptor]

'variableWithConstraint' @ [221:13] ==> val variableWithConstraint: MutableVariableWithConstraints defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.fixVariable[LocalVariableDescriptor]

'removeConstrains' @ [221:36] ==> internal final fun removeConstrains(shouldRemove: (Constraint) -> Boolean): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableVariableWithConstraints[SimpleFunctionDescriptorImpl]

'it' @ [222:17] ==> value-parameter it: Constraint defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.fixVariable.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [222:20] ==> public final val type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.Constraint[PropertyDescriptorImpl]

'contains' @ [222:25] ==> public fun KotlinType.contains(predicate: (UnwrappedType) -> Boolean): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'it' @ [222:36] ==> value-parameter it: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.fixVariable.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'constructor' @ [222:39] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.UnwrappedType[DeserializedPropertyDescriptor]

'variable' @ [222:54] ==> value-parameter variable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.fixVariable[ValueParameterDescriptorImpl]

'freshTypeConstructor' @ [222:63] ==> public final val freshTypeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewTypeVariable[PropertyDescriptorImpl]

'storage' @ [226:9] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'fixedTypeVariables' @ [226:17] ==> public open val fixedTypeVariables: MutableMap<TypeConstructor, UnwrappedType> defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'variable' @ [226:36] ==> value-parameter variable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.fixVariable[ValueParameterDescriptorImpl]

'freshTypeConstructor' @ [226:45] ==> public final val freshTypeConstructor: TypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewTypeVariable[PropertyDescriptorImpl]

'actualResultType' @ [226:69] ==> val actualResultType: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.fixVariable[LocalVariableDescriptor]

'variable' @ [230:13] ==> value-parameter variable: NewTypeVariable defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.eliminateSpecialIntersectionType[ValueParameterDescriptorImpl]

'shouldBeDefinitelyNotNull' @ [230:22] ==> private final fun NewTypeVariable.shouldBeDefinitelyNotNull(): Boolean defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'type' @ [232:27] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.eliminateSpecialIntersectionType[ValueParameterDescriptorImpl]

'constructor' @ [232:32] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.UnwrappedType[DeserializedPropertyDescriptor]

'safeAs' @ [232:44] ==> public inline fun <reified T : Any> Any?.safeAs(): IntersectionTypeConstructor? defined in org.jetbrains.kotlin.utils.addToStdlib[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : Any> -> IntersectionTypeConstructor

'constructor' @ [234:13] ==> val constructor: IntersectionTypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.eliminateSpecialIntersectionType[LocalVariableDescriptor]

'supertypes' @ [234:25] ==> public final val IntersectionTypeConstructor.supertypes: Collection<(KotlinType..KotlinType?)>[MyPropertyDescriptor]

'size' @ [234:36] ==> public abstract val size: Int defined in kotlin.collections.Collection[DeserializedPropertyDescriptor]

'constructor' @ [235:26] ==> val constructor: IntersectionTypeConstructor defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.eliminateSpecialIntersectionType[LocalVariableDescriptor]

'supertypes' @ [235:38] ==> public final val IntersectionTypeConstructor.supertypes: Collection<(KotlinType..KotlinType?)>[MyPropertyDescriptor]

'singleOrNull' @ [235:49] ==> public inline fun <T> Iterable<(KotlinType..KotlinType?)>.singleOrNull(predicate: ((KotlinType..KotlinType?)) -> Boolean): KotlinType? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)

'it' @ [235:64] ==> value-parameter it: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.eliminateSpecialIntersectionType.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [235:70] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.eliminateSpecialIntersectionType[ValueParameterDescriptorImpl]

'builtIns' @ [235:75] ==> public val KotlinType.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.types.typeUtil[DeserializedPropertyDescriptor]

'anyType' @ [235:84] ==> public final val KotlinBuiltIns.anyType: SimpleType[MyPropertyDescriptor]

'actualType' @ [237:16] ==> val actualType: KotlinType? defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.eliminateSpecialIntersectionType[LocalVariableDescriptor]

'unwrap' @ [237:28] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[DeserializedSimpleFunctionDescriptor]

'when (this) {
            is TypeVariableFromCallableDescriptor -> originalTypeParameter.name.asString() == TYPE_PARAMETER_FOR_EXCLXCL
            is TypeVariableForLambdaReturnType -> false
        }' @ [241:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'this' @ [241:22] ==> <this> defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.shouldBeDefinitelyNotNull[ReceiverParameterDescriptorImpl]

'originalTypeParameter' @ [242:54] ==> public final val originalTypeParameter: TypeParameterDescriptor defined in org.jetbrains.kotlin.resolve.calls.inference.model.TypeVariableFromCallableDescriptor[PropertyDescriptorImpl]

'name' @ [242:76] ==> public final val TypeParameterDescriptor.name: Name[MyPropertyDescriptor]

'asString' @ [242:81] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'TYPE_PARAMETER_FOR_EXCLXCL' @ [242:95] ==> private final val TYPE_PARAMETER_FOR_EXCLXCL: String defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.Companion[PropertyDescriptorImpl]

'checkState' @ [249:9] ==> private final fun checkState(vararg allowedState: NewConstraintSystemImpl.State): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'BUILDING' @ [249:26] ==> enum entry BUILDING defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'COMPLETION' @ [249:42] ==> enum entry COMPLETION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'!' @ [250:16] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'type' @ [250:17] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.canBeProper[ValueParameterDescriptorImpl]

'contains' @ [250:22] ==> public fun KotlinType.contains(predicate: (UnwrappedType) -> Boolean): Boolean defined in org.jetbrains.kotlin.types.typeUtil[DeserializedSimpleFunctionDescriptor]

'storage' @ [250:33] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'notFixedTypeVariables' @ [250:41] ==> public open val notFixedTypeVariables: MutableMap<TypeConstructor, MutableVariableWithConstraints> defined in org.jetbrains.kotlin.resolve.calls.inference.model.MutableConstraintStorage[PropertyDescriptorImpl]

'containsKey' @ [250:63] ==> public abstract fun containsKey(key: TypeConstructor): Boolean defined in kotlin.collections.MutableMap[DeserializedSimpleFunctionDescriptor]

'it' @ [250:75] ==> value-parameter it: UnwrappedType defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.canBeProper.<anonymous>[ValueParameterDescriptorImpl]

'constructor' @ [250:78] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.UnwrappedType[DeserializedPropertyDescriptor]

'checkState' @ [255:9] ==> private final fun checkState(vararg allowedState: NewConstraintSystemImpl.State): Unit defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[SimpleFunctionDescriptorImpl]

'BUILDING' @ [255:26] ==> enum entry BUILDING defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'COMPLETION' @ [255:42] ==> enum entry COMPLETION defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl.State[FakeCallableDescriptorForObject]

'storage' @ [256:16] ==> private final val storage: MutableConstraintStorage defined in org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintSystemImpl[PropertyDescriptorImpl]

'buildCurrentSubstitutor' @ [256:24] ==> public fun ConstraintStorage.buildCurrentSubstitutor(): NewTypeSubstitutorByConstructorMap defined in org.jetbrains.kotlin.resolve.calls.inference in file InferenceUtils.kt[SimpleFunctionDescriptorImpl]

