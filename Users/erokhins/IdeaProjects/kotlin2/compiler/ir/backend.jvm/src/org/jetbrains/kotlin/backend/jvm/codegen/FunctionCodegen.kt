'classCodegen' @ [41:17] ==> private final val classCodegen: ClassCodegen defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'state' @ [41:30] ==> public final val state: GenerationState defined in org.jetbrains.kotlin.backend.jvm.codegen.ClassCodegen[PropertyDescriptorImpl]

'irFunction' @ [43:22] ==> private final val irFunction: IrFunction defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'descriptor' @ [43:33] ==> public abstract val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.ir.declarations.IrFunction[DeserializedPropertyDescriptor]

'doGenerate' @ [47:13] ==> private final fun doGenerate(): Unit defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[SimpleFunctionDescriptorImpl]

'RuntimeException' @ [50:19] ==> public final fun <init>(p0: (String..String?), p1: (Throwable..Throwable?)): RuntimeException /* = RuntimeException */ defined in kotlin.RuntimeException[TypeAliasConstructorDescriptorImpl]

'e' @ [50:39] ==> val e: Throwable defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.generate[LocalVariableDescriptor]

'message' @ [50:41] ==> public open val message: String? defined in kotlin.Throwable[DeserializedPropertyDescriptor]

'irFunction' @ [50:80] ==> private final val irFunction: IrFunction defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'dump' @ [50:91] ==> public fun IrElement.dump(): String defined in org.jetbrains.kotlin.ir.util[DeserializedSimpleFunctionDescriptor]

'e' @ [50:101] ==> val e: Throwable defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.generate[LocalVariableDescriptor]

'classCodegen' @ [55:25] ==> private final val classCodegen: ClassCodegen defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'typeMapper' @ [55:38] ==> public final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.backend.jvm.codegen.ClassCodegen[PropertyDescriptorImpl]

'mapSignatureWithGeneric' @ [55:49] ==> @NotNull public open fun mapSignatureWithGeneric(@NotNull p0: FunctionDescriptor, @NotNull p1: OwnerKind): JvmMethodGenericSignature defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'descriptor' @ [55:73] ==> public final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'OwnerKind' @ [55:85] ==> public companion object defined in org.jetbrains.kotlin.codegen.OwnerKind[FakeCallableDescriptorForObject]

'IMPLEMENTATION' @ [55:95] ==> enum entry IMPLEMENTATION defined in org.jetbrains.kotlin.codegen.OwnerKind[FakeCallableDescriptorForObject]

'isStaticMethod' @ [56:24] ==> public open fun isStaticMethod(p0: (OwnerKind..OwnerKind?), p1: (CallableMemberDescriptor..CallableMemberDescriptor?)): Boolean defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaMethodDescriptor]

'OwnerKind' @ [56:39] ==> public companion object defined in org.jetbrains.kotlin.codegen.OwnerKind[FakeCallableDescriptorForObject]

'getMemberOwnerKind' @ [56:49] ==> public final fun getMemberOwnerKind(descriptor: DeclarationDescriptor): OwnerKind defined in org.jetbrains.kotlin.codegen.OwnerKind.Companion[DeserializedSimpleFunctionDescriptor]

'classCodegen' @ [56:68] ==> private final val classCodegen: ClassCodegen defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'descriptor' @ [56:81] ==> public final val descriptor: ClassDescriptor defined in org.jetbrains.kotlin.backend.jvm.codegen.ClassCodegen[PropertyDescriptorImpl]

'descriptor' @ [56:94] ==> public final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'isStaticDeclaration' @ [57:40] ==> public open fun isStaticDeclaration(@NotNull p0: CallableDescriptor): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'descriptor' @ [57:60] ==> public final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'createFrameMapWithReceivers' @ [58:24] ==> public fun createFrameMapWithReceivers(state: GenerationState, function: FunctionDescriptor, signature: JvmMethodSignature, isStatic: Boolean): FrameMap defined in org.jetbrains.kotlin.backend.jvm.codegen in file FunctionCodegen.kt[SimpleFunctionDescriptorImpl]

'classCodegen' @ [58:52] ==> private final val classCodegen: ClassCodegen defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'state' @ [58:65] ==> public final val state: GenerationState defined in org.jetbrains.kotlin.backend.jvm.codegen.ClassCodegen[PropertyDescriptorImpl]

'descriptor' @ [58:72] ==> public final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'signature' @ [58:84] ==> val signature: JvmMethodGenericSignature defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.doGenerate[LocalVariableDescriptor]

'isStatic' @ [58:95] ==> val isStatic: Boolean defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.doGenerate[LocalVariableDescriptor]

'getMethodAsmFlags' @ [61:29] ==> public open fun getMethodAsmFlags(p0: (FunctionDescriptor..FunctionDescriptor?), p1: (OwnerKind..OwnerKind?), p2: (GenerationState..GenerationState?)): Int defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaMethodDescriptor]

'descriptor' @ [61:47] ==> public final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'OwnerKind' @ [61:59] ==> public companion object defined in org.jetbrains.kotlin.codegen.OwnerKind[FakeCallableDescriptorForObject]

'IMPLEMENTATION' @ [61:69] ==> enum entry IMPLEMENTATION defined in org.jetbrains.kotlin.codegen.OwnerKind[FakeCallableDescriptorForObject]

'state' @ [61:85] ==> public final val state: GenerationState defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'or' @ [61:92] ==> public final infix fun or(other: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'if (isStatic) Opcodes.ACC_STATIC else 0' @ [61:95] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Int, elseBranch: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Int

'isStatic' @ [61:99] ==> val isStatic: Boolean defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.doGenerate[LocalVariableDescriptor]

'ACC_STATIC' @ [61:117] ==> public const final val ACC_STATIC: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'xor' @ [61:136] ==> public final infix fun xor(other: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'if (DescriptorUtils.isAnnotationClass(descriptor.containingDeclaration)) Opcodes.ACC_FINAL else 0' @ [62:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Int, elseBranch: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Int

'isAnnotationClass' @ [62:37] ==> public open fun isAnnotationClass(@Nullable p0: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'descriptor' @ [62:55] ==> public final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'containingDeclaration' @ [62:66] ==> public final val FunctionDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'ACC_FINAL' @ [62:98] ==> public const final val ACC_FINAL: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'or' @ [63:11] ==> public final infix fun or(other: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'if (descriptor is JvmDescriptorWithExtraFlags) descriptor.extraFlags else 0' @ [63:14] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Int, elseBranch: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Int

'descriptor' @ [63:18] ==> public final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'descriptor' @ [63:61] ==> public final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'extraFlags' @ [63:72] ==> public abstract val extraFlags: Int defined in org.jetbrains.kotlin.backend.jvm.descriptors.JvmDescriptorWithExtraFlags[PropertyDescriptorImpl]

'isJvmInterface' @ [65:46] ==> public open fun isJvmInterface(p0: (DeclarationDescriptor..DeclarationDescriptor?)): Boolean defined in org.jetbrains.kotlin.codegen.JvmCodegenUtil[JavaMethodDescriptor]

'classCodegen' @ [65:61] ==> private final val classCodegen: ClassCodegen defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'descriptor' @ [65:74] ==> public final val descriptor: ClassDescriptor defined in org.jetbrains.kotlin.backend.jvm.codegen.ClassCodegen[PropertyDescriptorImpl]

'InitializersLowering' @ [65:89] ==> public companion object defined in org.jetbrains.kotlin.backend.jvm.lower.InitializersLowering[FakeCallableDescriptorForObject]

'clinitName' @ [65:110] ==> public final val clinitName: Name defined in org.jetbrains.kotlin.backend.jvm.lower.InitializersLowering.Companion[PropertyDescriptorImpl]

'descriptor' @ [65:124] ==> public final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'name' @ [65:135] ==> public final val FunctionDescriptor.name: Name[MyPropertyDescriptor]

'interfaceClInit' @ [66:13] ==> val interfaceClInit: Boolean defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.doGenerate[LocalVariableDescriptor]

'flags' @ [68:13] ==> var flags: Int defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.doGenerate[LocalVariableDescriptor]

'flags' @ [68:21] ==> var flags: Int defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.doGenerate[LocalVariableDescriptor]

'xor' @ [68:27] ==> public final infix fun xor(other: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'ACC_ABSTRACT' @ [68:39] ==> public const final val ACC_ABSTRACT: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'classCodegen' @ [70:29] ==> private final val classCodegen: ClassCodegen defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'visitor' @ [70:42] ==> public final val visitor: ClassBuilder defined in org.jetbrains.kotlin.backend.jvm.codegen.ClassCodegen[PropertyDescriptorImpl]

'newMethod' @ [70:50] ==> @NotNull public abstract fun newMethod(@NotNull p0: JvmDeclarationOrigin, p1: Int, @NotNull p2: String, @NotNull p3: String, @Nullable p4: String?, @Nullable p5: (Array<(String..String?)>?..Array<out (String..String?)>?)): MethodVisitor defined in org.jetbrains.kotlin.codegen.ClassBuilder[JavaMethodDescriptor]

'irFunction' @ [70:60] ==> private final val irFunction: IrFunction defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'OtherOrigin' @ [70:71] ==> internal val IrFunction.OtherOrigin: JvmDeclarationOrigin defined in org.jetbrains.kotlin.backend.jvm.codegen in file ClassCodegen.kt[PropertyDescriptorImpl]

'flags' @ [71:60] ==> var flags: Int defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.doGenerate[LocalVariableDescriptor]

'signature' @ [72:60] ==> val signature: JvmMethodGenericSignature defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.doGenerate[LocalVariableDescriptor]

'asmMethod' @ [72:70] ==> public final val JvmMethodGenericSignature.asmMethod: Method[MyPropertyDescriptor]

'name' @ [72:80] ==> public final val Method.name: (String..String?)[MyPropertyDescriptor]

'signature' @ [72:86] ==> val signature: JvmMethodGenericSignature defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.doGenerate[LocalVariableDescriptor]

'asmMethod' @ [72:96] ==> public final val JvmMethodGenericSignature.asmMethod: Method[MyPropertyDescriptor]

'descriptor' @ [72:106] ==> public final val Method.descriptor: (String..String?)[MyPropertyDescriptor]

'signature' @ [73:60] ==> val signature: JvmMethodGenericSignature defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.doGenerate[LocalVariableDescriptor]

'genericsSignature' @ [73:70] ==> public final val JvmMethodGenericSignature.genericsSignature: String?[MyPropertyDescriptor]

'generateMethodAnnotations' @ [75:25] ==> public open fun generateMethodAnnotations(@NotNull p0: FunctionDescriptor, p1: (Method..Method?), p2: (MethodVisitor..MethodVisitor?), @NotNull p3: InnerClassConsumer, @NotNull p4: KotlinTypeMapper): Unit defined in org.jetbrains.kotlin.codegen.FunctionCodegen[JavaMethodDescriptor]

'descriptor' @ [75:51] ==> public final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'signature' @ [75:63] ==> val signature: JvmMethodGenericSignature defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.doGenerate[LocalVariableDescriptor]

'asmMethod' @ [75:73] ==> public final val JvmMethodGenericSignature.asmMethod: Method[MyPropertyDescriptor]

'methodVisitor' @ [75:84] ==> val methodVisitor: MethodVisitor defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.doGenerate[LocalVariableDescriptor]

'classCodegen' @ [75:99] ==> private final val classCodegen: ClassCodegen defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'state' @ [75:113] ==> public final val state: GenerationState defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'typeMapper' @ [75:119] ==> public final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.state.GenerationState[DeserializedPropertyDescriptor]

'generateParameterAnnotations' @ [76:25] ==> public open fun generateParameterAnnotations(@NotNull p0: FunctionDescriptor, @NotNull p1: MethodVisitor, @NotNull p2: JvmMethodSignature, @NotNull p3: InnerClassConsumer, @NotNull p4: GenerationState): Unit defined in org.jetbrains.kotlin.codegen.FunctionCodegen[JavaMethodDescriptor]

'descriptor' @ [76:54] ==> public final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'methodVisitor' @ [76:66] ==> val methodVisitor: MethodVisitor defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.doGenerate[LocalVariableDescriptor]

'signature' @ [76:81] ==> val signature: JvmMethodGenericSignature defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.doGenerate[LocalVariableDescriptor]

'classCodegen' @ [76:92] ==> private final val classCodegen: ClassCodegen defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'state' @ [76:106] ==> public final val state: GenerationState defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'!' @ [78:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'state' @ [78:14] ==> public final val state: GenerationState defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'classBuilderMode' @ [78:20] ==> public final val classBuilderMode: ClassBuilderMode defined in org.jetbrains.kotlin.codegen.state.GenerationState[DeserializedPropertyDescriptor]

'generateBodies' @ [78:37] ==> public final val generateBodies: Boolean defined in org.jetbrains.kotlin.codegen.ClassBuilderMode[JavaPropertyDescriptor]

'flags' @ [78:55] ==> var flags: Int defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.doGenerate[LocalVariableDescriptor]

'and' @ [78:61] ==> public final infix fun and(other: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'ACC_ABSTRACT' @ [78:73] ==> public const final val ACC_ABSTRACT: Int defined in org.jetbrains.org.objectweb.asm.Opcodes[JavaPropertyDescriptor]

'generateAnnotationDefaultValueIfNeeded' @ [79:13] ==> private final fun generateAnnotationDefaultValueIfNeeded(methodVisitor: MethodVisitor): Unit defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[SimpleFunctionDescriptorImpl]

'methodVisitor' @ [79:52] ==> val methodVisitor: MethodVisitor defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.doGenerate[LocalVariableDescriptor]

'methodVisitor' @ [80:13] ==> val methodVisitor: MethodVisitor defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.doGenerate[LocalVariableDescriptor]

'visitEnd' @ [80:27] ==> public open fun visitEnd(): Unit defined in org.jetbrains.org.objectweb.asm.MethodVisitor[JavaMethodDescriptor]

'ExpressionCodegen' @ [84:9] ==> public constructor ExpressionCodegen(irFunction: IrFunction, frame: FrameMap, mv: InstructionAdapter, classCodegen: ClassCodegen) defined in org.jetbrains.kotlin.backend.jvm.codegen.ExpressionCodegen[ClassConstructorDescriptorImpl]

'irFunction' @ [84:27] ==> private final val irFunction: IrFunction defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'frameMap' @ [84:39] ==> val frameMap: FrameMap defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.doGenerate[LocalVariableDescriptor]

'InstructionAdapter' @ [84:49] ==> public constructor InstructionAdapter(p0: (MethodVisitor..MethodVisitor?)) defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaClassConstructorDescriptor]

'methodVisitor' @ [84:68] ==> val methodVisitor: MethodVisitor defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.doGenerate[LocalVariableDescriptor]

'classCodegen' @ [84:84] ==> private final val classCodegen: ClassCodegen defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'generate' @ [84:98] ==> public final fun generate(): Unit defined in org.jetbrains.kotlin.backend.jvm.codegen.ExpressionCodegen[SimpleFunctionDescriptorImpl]

'getDirectMember' @ [88:43] ==> @NotNull public open fun getDirectMember(@NotNull p0: CallableMemberDescriptor): CallableMemberDescriptor defined in org.jetbrains.kotlin.codegen.JvmCodegenUtil[JavaMethodDescriptor]

'descriptor' @ [88:59] ==> public final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'isAnnotationClass' @ [89:29] ==> public open fun isAnnotationClass(@Nullable p0: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'directMember' @ [89:47] ==> val directMember: CallableMemberDescriptor defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.generateAnnotationDefaultValueIfNeeded[LocalVariableDescriptor]

'containingDeclaration' @ [89:60] ==> public final val CallableMemberDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'directMember' @ [90:26] ==> val directMember: CallableMemberDescriptor defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.generateAnnotationDefaultValueIfNeeded[LocalVariableDescriptor]

'source' @ [90:39] ==> public final val CallableMemberDescriptor.source: SourceElement[MyPropertyDescriptor]

'source' @ [91:14] ==> val source: SourceElement defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.generateAnnotationDefaultValueIfNeeded[LocalVariableDescriptor]

'getPsi' @ [91:21] ==> public fun SourceElement.getPsi(): PsiElement? defined in org.jetbrains.kotlin.resolve.source[DeserializedSimpleFunctionDescriptor]

'defaultValue' @ [91:48] ==> public final val KtParameter.defaultValue: KtExpression?[MyPropertyDescriptor]

'apply' @ [91:62] ==> @InlineOnly public inline fun <T> KtExpression.apply(block: (KtExpression).() -> Unit): KtExpression defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtExpression

'this' @ [92:36] ==> <this> defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.generateAnnotationDefaultValueIfNeeded.<anonymous>[ReceiverParameterDescriptorImpl]

'getCompileTimeConstant' @ [93:79] ==> @Nullable public open fun getCompileTimeConstant(@NotNull p0: KtExpression, @NotNull p1: BindingContext, p2: Boolean, p3: Boolean): ConstantValue<*>? defined in org.jetbrains.kotlin.codegen.ExpressionCodegen[JavaMethodDescriptor]

'defaultValue' @ [94:25] ==> val defaultValue: KtExpression defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.generateAnnotationDefaultValueIfNeeded.<anonymous>[LocalVariableDescriptor]

'state' @ [94:39] ==> public final val state: GenerationState defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'bindingContext' @ [94:45] ==> public final val bindingContext: BindingContext defined in org.jetbrains.kotlin.codegen.state.GenerationState[DeserializedPropertyDescriptor]

'state' @ [94:67] ==> public final val state: GenerationState defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'shouldInlineConstVals' @ [94:73] ==> public final val shouldInlineConstVals: Boolean defined in org.jetbrains.kotlin.codegen.state.GenerationState[DeserializedPropertyDescriptor]

'assert' @ [95:17] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'!' @ [95:24] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'state' @ [95:25] ==> public final val state: GenerationState defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'classBuilderMode' @ [95:31] ==> public final val classBuilderMode: ClassBuilderMode defined in org.jetbrains.kotlin.codegen.state.GenerationState[DeserializedPropertyDescriptor]

'generateBodies' @ [95:48] ==> public final val generateBodies: Boolean defined in org.jetbrains.kotlin.codegen.ClassBuilderMode[JavaPropertyDescriptor]

'constant' @ [95:66] ==> val constant: ConstantValue<*>? defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.generateAnnotationDefaultValueIfNeeded.<anonymous>[LocalVariableDescriptor]

'+' @ [95:86] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'defaultValue' @ [95:160] ==> val defaultValue: KtExpression defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.generateAnnotationDefaultValueIfNeeded.<anonymous>[LocalVariableDescriptor]

'text' @ [95:173] ==> public final val KtExpression.text: (String..String?)[MyPropertyDescriptor]

'constant' @ [96:21] ==> val constant: ConstantValue<*>? defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.generateAnnotationDefaultValueIfNeeded.<anonymous>[LocalVariableDescriptor]

'forAnnotationDefaultValue' @ [97:63] ==> public open fun forAnnotationDefaultValue(@NotNull p0: MethodVisitor, @NotNull p1: InnerClassConsumer, @NotNull p2: KotlinTypeMapper): (AnnotationCodegen..AnnotationCodegen?) defined in org.jetbrains.kotlin.codegen.AnnotationCodegen[JavaMethodDescriptor]

'methodVisitor' @ [97:89] ==> value-parameter methodVisitor: MethodVisitor defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.generateAnnotationDefaultValueIfNeeded[ValueParameterDescriptorImpl]

'classCodegen' @ [97:104] ==> private final val classCodegen: ClassCodegen defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'state' @ [97:118] ==> public final val state: GenerationState defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'typeMapper' @ [97:124] ==> public final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.state.GenerationState[DeserializedPropertyDescriptor]

'annotationCodegen' @ [98:21] ==> val annotationCodegen: (AnnotationCodegen..AnnotationCodegen?) defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.generateAnnotationDefaultValueIfNeeded.<anonymous>[LocalVariableDescriptor]

'generateAnnotationDefaultValue' @ [98:39] ==> public open fun generateAnnotationDefaultValue(@NotNull p0: ConstantValue<*>, @NotNull p1: KotlinType): Unit defined in org.jetbrains.kotlin.codegen.AnnotationCodegen[JavaMethodDescriptor]

'constant' @ [98:70] ==> val constant: ConstantValue<*>? defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen.generateAnnotationDefaultValueIfNeeded.<anonymous>[LocalVariableDescriptor]

'descriptor' @ [98:80] ==> public final val descriptor: FunctionDescriptor defined in org.jetbrains.kotlin.backend.jvm.codegen.FunctionCodegen[PropertyDescriptorImpl]

'returnType' @ [98:91] ==> public final val FunctionDescriptor.returnType: KotlinType?[MyPropertyDescriptor]

'FrameMap' @ [111:20] ==> public constructor FrameMap() defined in org.jetbrains.kotlin.codegen.FrameMap[JavaClassConstructorDescriptor]

'!' @ [112:9] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isStatic' @ [112:10] ==> value-parameter isStatic: Boolean defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[ValueParameterDescriptorImpl]

'if (function is ClassConstructorDescriptor)
                    function.containingDeclaration.thisAsReceiverParameter
                else
                    function.dispatchReceiverParameter' @ [114:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: ReceiverParameterDescriptor?, elseBranch: ReceiverParameterDescriptor?): ReceiverParameterDescriptor?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> ReceiverParameterDescriptor?

'function' @ [114:21] ==> value-parameter function: FunctionDescriptor defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[ValueParameterDescriptorImpl]

'function' @ [115:21] ==> value-parameter function: FunctionDescriptor defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[ValueParameterDescriptorImpl]

'containingDeclaration' @ [115:30] ==> public final val ClassConstructorDescriptor.containingDeclaration: ClassDescriptor[MyPropertyDescriptor]

'thisAsReceiverParameter' @ [115:52] ==> public final val ClassDescriptor.thisAsReceiverParameter: ReceiverParameterDescriptor[MyPropertyDescriptor]

'function' @ [117:21] ==> value-parameter function: FunctionDescriptor defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[ValueParameterDescriptorImpl]

'dispatchReceiverParameter' @ [117:30] ==> public final val FunctionDescriptor.dispatchReceiverParameter: ReceiverParameterDescriptor?[MyPropertyDescriptor]

'frameMap' @ [119:9] ==> val frameMap: FrameMap defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[LocalVariableDescriptor]

'enter' @ [119:18] ==> public open fun enter(p0: (DeclarationDescriptor..DeclarationDescriptor?), p1: (Type..Type?)): Int defined in org.jetbrains.kotlin.codegen.FrameMap[JavaMethodDescriptor]

'descriptorForThis' @ [119:24] ==> val descriptorForThis: ReceiverParameterDescriptor? defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[LocalVariableDescriptor]

'OBJECT_TYPE' @ [119:52] ==> public final val OBJECT_TYPE: (Type..Type?) defined in org.jetbrains.kotlin.resolve.jvm.AsmTypes[JavaPropertyDescriptor]

'signature' @ [122:23] ==> value-parameter signature: JvmMethodSignature defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[ValueParameterDescriptorImpl]

'valueParameters' @ [122:33] ==> public final val JvmMethodSignature.valueParameters: (MutableList<(JvmMethodParameterSignature..JvmMethodParameterSignature?)>..List<(JvmMethodParameterSignature..JvmMethodParameterSignature?)>)[MyPropertyDescriptor]

'if (parameter.kind == JvmMethodParameterKind.RECEIVER) {
            val receiverParameter = function.extensionReceiverParameter
            if (receiverParameter != null) {
                frameMap.enter(receiverParameter, state.typeMapper.mapType(receiverParameter))
            }
            else {
                frameMap.enterTemp(parameter.asmType)
            }
        }
        else if (parameter.kind != JvmMethodParameterKind.VALUE) {
            frameMap.enterTemp(parameter.asmType)
        }' @ [123:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any, elseBranch: Any): Any[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any

'parameter' @ [123:13] ==> val parameter: (JvmMethodParameterSignature..JvmMethodParameterSignature?) defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[LocalVariableDescriptor]

'kind' @ [123:23] ==> public final val JvmMethodParameterSignature.kind: JvmMethodParameterKind[MyPropertyDescriptor]

'RECEIVER' @ [123:54] ==> enum entry RECEIVER defined in org.jetbrains.kotlin.resolve.jvm.jvmSignature.JvmMethodParameterKind[FakeCallableDescriptorForObject]

'function' @ [124:37] ==> value-parameter function: FunctionDescriptor defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[ValueParameterDescriptorImpl]

'extensionReceiverParameter' @ [124:46] ==> public final val FunctionDescriptor.extensionReceiverParameter: ReceiverParameterDescriptor?[MyPropertyDescriptor]

'if (receiverParameter != null) {
                frameMap.enter(receiverParameter, state.typeMapper.mapType(receiverParameter))
            }
            else {
                frameMap.enterTemp(parameter.asmType)
            }' @ [125:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Int, elseBranch: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Int

'receiverParameter' @ [125:17] ==> val receiverParameter: ReceiverParameterDescriptor? defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[LocalVariableDescriptor]

'frameMap' @ [126:17] ==> val frameMap: FrameMap defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[LocalVariableDescriptor]

'enter' @ [126:26] ==> public open fun enter(p0: (DeclarationDescriptor..DeclarationDescriptor?), p1: (Type..Type?)): Int defined in org.jetbrains.kotlin.codegen.FrameMap[JavaMethodDescriptor]

'receiverParameter' @ [126:32] ==> val receiverParameter: ReceiverParameterDescriptor? defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[LocalVariableDescriptor]

'state' @ [126:51] ==> value-parameter state: GenerationState defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[ValueParameterDescriptorImpl]

'typeMapper' @ [126:57] ==> public final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.state.GenerationState[DeserializedPropertyDescriptor]

'mapType' @ [126:68] ==> @NotNull public open fun mapType(@NotNull p0: CallableDescriptor): Type defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'receiverParameter' @ [126:76] ==> val receiverParameter: ReceiverParameterDescriptor? defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[LocalVariableDescriptor]

'frameMap' @ [129:17] ==> val frameMap: FrameMap defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[LocalVariableDescriptor]

'enterTemp' @ [129:26] ==> public open fun enterTemp(p0: (Type..Type?)): Int defined in org.jetbrains.kotlin.codegen.FrameMap[JavaMethodDescriptor]

'parameter' @ [129:36] ==> val parameter: (JvmMethodParameterSignature..JvmMethodParameterSignature?) defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[LocalVariableDescriptor]

'asmType' @ [129:46] ==> public final val JvmMethodParameterSignature.asmType: Type[MyPropertyDescriptor]

'parameter' @ [132:18] ==> val parameter: (JvmMethodParameterSignature..JvmMethodParameterSignature?) defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[LocalVariableDescriptor]

'kind' @ [132:28] ==> public final val JvmMethodParameterSignature.kind: JvmMethodParameterKind[MyPropertyDescriptor]

'VALUE' @ [132:59] ==> enum entry VALUE defined in org.jetbrains.kotlin.resolve.jvm.jvmSignature.JvmMethodParameterKind[FakeCallableDescriptorForObject]

'frameMap' @ [133:13] ==> val frameMap: FrameMap defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[LocalVariableDescriptor]

'enterTemp' @ [133:22] ==> public open fun enterTemp(p0: (Type..Type?)): Int defined in org.jetbrains.kotlin.codegen.FrameMap[JavaMethodDescriptor]

'parameter' @ [133:32] ==> val parameter: (JvmMethodParameterSignature..JvmMethodParameterSignature?) defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[LocalVariableDescriptor]

'asmType' @ [133:42] ==> public final val JvmMethodParameterSignature.asmType: Type[MyPropertyDescriptor]

'function' @ [137:23] ==> value-parameter function: FunctionDescriptor defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[ValueParameterDescriptorImpl]

'valueParameters' @ [137:32] ==> public final val FunctionDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'frameMap' @ [138:9] ==> val frameMap: FrameMap defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[LocalVariableDescriptor]

'enter' @ [138:18] ==> public open fun enter(p0: (DeclarationDescriptor..DeclarationDescriptor?), p1: (Type..Type?)): Int defined in org.jetbrains.kotlin.codegen.FrameMap[JavaMethodDescriptor]

'parameter' @ [138:24] ==> val parameter: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[LocalVariableDescriptor]

'state' @ [138:35] ==> value-parameter state: GenerationState defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[ValueParameterDescriptorImpl]

'typeMapper' @ [138:41] ==> public final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.state.GenerationState[DeserializedPropertyDescriptor]

'mapType' @ [138:52] ==> @NotNull public open fun mapType(@NotNull p0: CallableDescriptor): Type defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'parameter' @ [138:60] ==> val parameter: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[LocalVariableDescriptor]

'frameMap' @ [141:12] ==> val frameMap: FrameMap defined in org.jetbrains.kotlin.backend.jvm.codegen.createFrameMapWithReceivers[LocalVariableDescriptor]

