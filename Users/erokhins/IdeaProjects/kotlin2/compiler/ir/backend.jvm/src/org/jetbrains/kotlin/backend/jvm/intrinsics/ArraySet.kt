'IntrinsicMethod' @ [25:18] ==> public constructor IntrinsicMethod() defined in org.jetbrains.kotlin.backend.jvm.intrinsics.IntrinsicMethod[ClassConstructorDescriptorImpl]

'expressionType' @ [28:25] ==> public final fun expressionType(expression: IrExpression, context: JvmBackendContext): Type defined in org.jetbrains.kotlin.backend.jvm.intrinsics.IntrinsicMethod.Companion[SimpleFunctionDescriptorImpl]

'expression' @ [28:40] ==> value-parameter expression: IrMemberAccessExpression defined in org.jetbrains.kotlin.backend.jvm.intrinsics.ArraySet.toCallable[ValueParameterDescriptorImpl]

'dispatchReceiver' @ [28:51] ==> public abstract var dispatchReceiver: IrExpression? defined in org.jetbrains.kotlin.ir.expressions.IrMemberAccessExpression[DeserializedPropertyDescriptor]

'context' @ [28:71] ==> value-parameter context: JvmBackendContext defined in org.jetbrains.kotlin.backend.jvm.intrinsics.ArraySet.toCallable[ValueParameterDescriptorImpl]

'correctElementType' @ [29:35] ==> @NotNull public open fun correctElementType(@NotNull p0: Type): Type defined in org.jetbrains.kotlin.codegen.AsmUtil[JavaMethodDescriptor]

'arrayType' @ [29:54] ==> val arrayType: Type defined in org.jetbrains.kotlin.backend.jvm.intrinsics.ArraySet.toCallable[LocalVariableDescriptor]

'IrIntrinsicFunction' @ [30:16] ==> public companion object defined in org.jetbrains.kotlin.backend.jvm.intrinsics.IrIntrinsicFunction[FakeCallableDescriptorForObject]

'create' @ [30:36] ==> public final fun create(expression: IrMemberAccessExpression, signature: JvmMethodSignature, context: JvmBackendContext, argsTypes: List<Type> = ..., invokeInstuction: IrIntrinsicFunction.(InstructionAdapter) -> Unit): IrIntrinsicFunction defined in org.jetbrains.kotlin.backend.jvm.intrinsics.IrIntrinsicFunction.Companion[SimpleFunctionDescriptorImpl]

'expression' @ [30:43] ==> value-parameter expression: IrMemberAccessExpression defined in org.jetbrains.kotlin.backend.jvm.intrinsics.ArraySet.toCallable[ValueParameterDescriptorImpl]

'signature' @ [30:55] ==> value-parameter signature: JvmMethodSignature defined in org.jetbrains.kotlin.backend.jvm.intrinsics.ArraySet.toCallable[ValueParameterDescriptorImpl]

'context' @ [30:66] ==> value-parameter context: JvmBackendContext defined in org.jetbrains.kotlin.backend.jvm.intrinsics.ArraySet.toCallable[ValueParameterDescriptorImpl]

'listOf' @ [30:75] ==> public fun <T> listOf(vararg elements: Type): List<Type> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Type

'arrayType' @ [30:82] ==> val arrayType: Type defined in org.jetbrains.kotlin.backend.jvm.intrinsics.ArraySet.toCallable[LocalVariableDescriptor]

'INT_TYPE' @ [30:98] ==> public final val INT_TYPE: (Type..Type?) defined in org.jetbrains.org.objectweb.asm.Type[JavaPropertyDescriptor]

'elementType' @ [30:108] ==> val elementType: Type defined in org.jetbrains.kotlin.backend.jvm.intrinsics.ArraySet.toCallable[LocalVariableDescriptor]

'it' @ [31:13] ==> value-parameter it: InstructionAdapter defined in org.jetbrains.kotlin.backend.jvm.intrinsics.ArraySet.toCallable.<anonymous>[ValueParameterDescriptorImpl]

'astore' @ [31:16] ==> public open fun astore(p0: (Type..Type?)): Unit defined in org.jetbrains.org.objectweb.asm.commons.InstructionAdapter[JavaMethodDescriptor]

'elementType' @ [31:23] ==> val elementType: Type defined in org.jetbrains.kotlin.backend.jvm.intrinsics.ArraySet.toCallable[LocalVariableDescriptor]

