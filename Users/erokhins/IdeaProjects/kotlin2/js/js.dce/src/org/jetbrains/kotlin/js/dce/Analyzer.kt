'JsVisitor' @ [24:48] ==> public constructor JsVisitor() defined in org.jetbrains.kotlin.js.backend.ast.JsVisitor[DeserializedClassConstructorDescriptor]

'mutableSetOf' @ [25:38] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableSetOf(): MutableSet<JsFunction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsFunction

'mutableMapOf' @ [26:38] ==> @SinceKotlin @InlineOnly public inline fun <K, V> mutableMapOf(): MutableMap<JsName, JsFunction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> JsName
    <V> -> JsFunction

'mutableMapOf' @ [27:27] ==> @SinceKotlin @InlineOnly public inline fun <K, V> mutableMapOf(): MutableMap<JsNode, Context.Node> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> JsNode
    <V> -> Node

'mutableSetOf' @ [28:39] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableSetOf(): MutableSet<JsNode> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsNode

'mutableSetOf' @ [29:34] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableSetOf(): MutableSet<JsNode> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsNode

'mutableSetOf' @ [30:37] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableSetOf(): MutableSet<JsInvocation> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsInvocation

'mutableMapOf' @ [31:25] ==> @SinceKotlin @InlineOnly public inline fun <K, V> mutableMapOf(): MutableMap<JsStatement, String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> JsStatement
    <V> -> String

'mutableSetOf' @ [32:36] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableSetOf(): MutableSet<JsFunction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsFunction

'this@Analyzer' @ [35:57] ==> <this> defined in org.jetbrains.kotlin.js.dce.Analyzer[LazyClassReceiverParameterDescriptor]

'nodeMap' @ [35:71] ==> private final val nodeMap: MutableMap<JsNode, Context.Node> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'this@Analyzer' @ [37:63] ==> <this> defined in org.jetbrains.kotlin.js.dce.Analyzer[LazyClassReceiverParameterDescriptor]

'astNodesToEliminate' @ [37:77] ==> private final val astNodesToEliminate: MutableSet<JsNode> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'this@Analyzer' @ [39:58] ==> <this> defined in org.jetbrains.kotlin.js.dce.Analyzer[LazyClassReceiverParameterDescriptor]

'astNodesToSkip' @ [39:72] ==> private final val astNodesToSkip: MutableSet<JsNode> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'this@Analyzer' @ [41:64] ==> <this> defined in org.jetbrains.kotlin.js.dce.Analyzer[LazyClassReceiverParameterDescriptor]

'functionsToEnter' @ [41:78] ==> private final val functionsToEnter: MutableSet<JsFunction> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'this@Analyzer' @ [43:67] ==> <this> defined in org.jetbrains.kotlin.js.dce.Analyzer[LazyClassReceiverParameterDescriptor]

'invocationsToSkip' @ [43:81] ==> private final val invocationsToSkip: MutableSet<JsInvocation> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'x' @ [47:9] ==> value-parameter x: JsVars defined in org.jetbrains.kotlin.js.dce.Analyzer.visitVars[ValueParameterDescriptorImpl]

'vars' @ [47:11] ==> public final val JsVars.vars: (MutableList<(JsVars.JsVar..JsVars.JsVar?)>..List<(JsVars.JsVar..JsVars.JsVar?)>?)[MyPropertyDescriptor]

'forEach' @ [47:16] ==> @HidesMembers public inline fun <T> Iterable<(JsVars.JsVar..JsVars.JsVar?)>.forEach(action: ((JsVars.JsVar..JsVars.JsVar?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.js.backend.ast.JsVars.JsVar..org.jetbrains.kotlin.js.backend.ast.JsVars.JsVar?)

'accept' @ [47:26] ==> public open fun <T : JsNode?> accept(node: (JsVars.JsVar..JsVars.JsVar?)): Unit defined in org.jetbrains.kotlin.js.dce.Analyzer[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : JsNode?> -> (org.jetbrains.kotlin.js.backend.ast.JsVars.JsVar..org.jetbrains.kotlin.js.backend.ast.JsVars.JsVar?)

'it' @ [47:33] ==> value-parameter it: (JsVars.JsVar..JsVars.JsVar?) defined in org.jetbrains.kotlin.js.dce.Analyzer.visitVars.<anonymous>[ValueParameterDescriptorImpl]

'x' @ [51:19] ==> value-parameter x: JsVars.JsVar defined in org.jetbrains.kotlin.js.dce.Analyzer.visit[ValueParameterDescriptorImpl]

'initExpression' @ [51:21] ==> public final var JsVars.JsVar.initExpression: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'rhs' @ [52:13] ==> val rhs: (JsExpression..JsExpression?) defined in org.jetbrains.kotlin.js.dce.Analyzer.visit[LocalVariableDescriptor]

'processAssignment' @ [53:13] ==> private final fun processAssignment(node: JsNode?, lhs: JsExpression, rhs: JsExpression): Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer[SimpleFunctionDescriptorImpl]

'x' @ [53:31] ==> value-parameter x: JsVars.JsVar defined in org.jetbrains.kotlin.js.dce.Analyzer.visit[ValueParameterDescriptorImpl]

'x' @ [53:34] ==> value-parameter x: JsVars.JsVar defined in org.jetbrains.kotlin.js.dce.Analyzer.visit[ValueParameterDescriptorImpl]

'name' @ [53:36] ==> public final var JsVars.JsVar.name: (JsName..JsName?)[MyPropertyDescriptor]

'makeRef' @ [53:41] ==> @NotNull public open fun makeRef(): JsNameRef defined in org.jetbrains.kotlin.js.backend.ast.JsName[JavaMethodDescriptor]

'rhs' @ [53:52] ==> val rhs: (JsExpression..JsExpression?) defined in org.jetbrains.kotlin.js.dce.Analyzer.visit[LocalVariableDescriptor]

'let' @ [53:58] ==> @InlineOnly public inline fun <T, R> Context.Node.let(block: (Context.Node) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Node
    <R> -> Unit

'nodeMap' @ [53:64] ==> private final val nodeMap: MutableMap<JsNode, Context.Node> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'x' @ [53:72] ==> value-parameter x: JsVars.JsVar defined in org.jetbrains.kotlin.js.dce.Analyzer.visit[ValueParameterDescriptorImpl]

'it' @ [53:77] ==> value-parameter it: Context.Node defined in org.jetbrains.kotlin.js.dce.Analyzer.visit.<anonymous>[ValueParameterDescriptorImpl]

'x' @ [58:26] ==> value-parameter x: JsExpressionStatement defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[ValueParameterDescriptorImpl]

'expression' @ [58:28] ==> public final val JsExpressionStatement.expression: JsExpression[MyPropertyDescriptor]

'when (expression) {
            is JsBinaryOperation -> if (expression.operator == JsBinaryOperator.ASG) {
                processAssignment(x, expression.arg1, expression.arg2)?.let {
                    // Mark this statement with FQN extracted from assignment.
                    // Later, we eliminate such statements if corresponding FQN is reachable
                    nodeMap[x] = it
                }
            }
            is JsFunction -> expression.name?.let { context.nodes[it]?.original }?.let {
                nodeMap[x] = it
                it.functions += expression
            }
            is JsInvocation -> {
                val function = expression.qualifier

                // (function(params) { ... })(arguments), assume that params = arguments and walk its body
                if (function is JsFunction) {
                    enterFunction(function, expression.arguments)
                    return
                }

                // f(arguments), where f is a parameter of outer function and it always receives function() { } as an argument.
                if (function is JsNameRef && function.qualifier == null) {
                    val postponedFunction = function.name?.let { postponedFunctions[it] }
                    if (postponedFunction != null) {
                        enterFunction(postponedFunction, expression.arguments)
                        invocationsToSkip += expression
                        return
                    }
                }

                // Object.defineProperty()
                when {
                    context.isObjectDefineProperty(function) ->
                        handleObjectDefineProperty(x, expression.arguments.getOrNull(0), expression.arguments.getOrNull(1),
                                                   expression.arguments.getOrNull(2))

                // Kotlin.defineModule()
                    context.isDefineModule(function) ->
                        // (just remove it)
                        astNodesToEliminate += x
                    context.isAmdDefine(function) ->
                        handleAmdDefine(expression, expression.arguments)
                }
            }
        }' @ [59:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit?, entry1: Unit?, entry2: Unit?): Unit?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit?

'expression' @ [59:15] ==> val expression: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'expression' @ [60:41] ==> val expression: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'operator' @ [60:52] ==> public final val JsBinaryOperation.operator: JsBinaryOperator[MyPropertyDescriptor]

'ASG' @ [60:81] ==> enum entry ASG defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'processAssignment' @ [61:17] ==> private final fun processAssignment(node: JsNode?, lhs: JsExpression, rhs: JsExpression): Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer[SimpleFunctionDescriptorImpl]

'x' @ [61:35] ==> value-parameter x: JsExpressionStatement defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[ValueParameterDescriptorImpl]

'expression' @ [61:38] ==> val expression: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'arg1' @ [61:49] ==> public final var JsBinaryOperation.arg1: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'expression' @ [61:55] ==> val expression: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'arg2' @ [61:66] ==> public final var JsBinaryOperation.arg2: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'let' @ [61:73] ==> @InlineOnly public inline fun <T, R> Context.Node.let(block: (Context.Node) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Node
    <R> -> Unit

'nodeMap' @ [64:21] ==> private final val nodeMap: MutableMap<JsNode, Context.Node> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'x' @ [64:29] ==> value-parameter x: JsExpressionStatement defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[ValueParameterDescriptorImpl]

'it' @ [64:34] ==> value-parameter it: Context.Node defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement.<anonymous>[ValueParameterDescriptorImpl]

'expression' @ [67:30] ==> val expression: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'name' @ [67:41] ==> public final var JsFunction.name: (JsName..JsName?)[MyPropertyDescriptor]

'let' @ [67:47] ==> @InlineOnly public inline fun <T, R> JsName.let(block: (JsName) -> Context.Node?): Context.Node? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsName
    <R> -> Node?

'context' @ [67:53] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'nodes' @ [67:61] ==> public final val nodes: MutableMap<JsName, Context.Node> defined in org.jetbrains.kotlin.js.dce.Context[PropertyDescriptorImpl]

'it' @ [67:67] ==> value-parameter it: JsName defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement.<anonymous>[ValueParameterDescriptorImpl]

'original' @ [67:72] ==> public final var original: Context.Node defined in org.jetbrains.kotlin.js.dce.Context.Node[PropertyDescriptorImpl]

'let' @ [67:84] ==> @InlineOnly public inline fun <T, R> Context.Node.let(block: (Context.Node) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Node
    <R> -> Unit

'nodeMap' @ [68:17] ==> private final val nodeMap: MutableMap<JsNode, Context.Node> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'x' @ [68:25] ==> value-parameter x: JsExpressionStatement defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[ValueParameterDescriptorImpl]

'it' @ [68:30] ==> value-parameter it: Context.Node defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [69:17] ==> value-parameter it: Context.Node defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement.<anonymous>[ValueParameterDescriptorImpl]

'functions' @ [69:20] ==> public final val functions: MutableSet<JsFunction> defined in org.jetbrains.kotlin.js.dce.Context.Node[PropertyDescriptorImpl]

'expression' @ [69:33] ==> val expression: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'expression' @ [72:32] ==> val expression: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'qualifier' @ [72:43] ==> public final var JsInvocation.qualifier: JsExpression[MyPropertyDescriptor]

'function' @ [75:21] ==> val function: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'enterFunction' @ [76:21] ==> private final fun enterFunction(function: JsFunction, arguments: List<JsExpression>): Unit defined in org.jetbrains.kotlin.js.dce.Analyzer[SimpleFunctionDescriptorImpl]

'function' @ [76:35] ==> val function: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'expression' @ [76:45] ==> val expression: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'arguments' @ [76:56] ==> public final val JsInvocation.arguments: (MutableList<(JsExpression..JsExpression?)>..List<(JsExpression..JsExpression?)>)[MyPropertyDescriptor]

'function' @ [81:21] ==> val function: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'function' @ [81:46] ==> val function: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'qualifier' @ [81:55] ==> public final var JsNameRef.qualifier: JsExpression?[MyPropertyDescriptor]

'function' @ [82:45] ==> val function: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'name' @ [82:54] ==> public final var JsNameRef.name: JsName?[MyPropertyDescriptor]

'let' @ [82:60] ==> @InlineOnly public inline fun <T, R> JsName.let(block: (JsName) -> JsFunction?): JsFunction? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsName
    <R> -> JsFunction?

'postponedFunctions' @ [82:66] ==> private final val postponedFunctions: MutableMap<JsName, JsFunction> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'it' @ [82:85] ==> value-parameter it: JsName defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement.<anonymous>[ValueParameterDescriptorImpl]

'postponedFunction' @ [83:25] ==> val postponedFunction: JsFunction? defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'enterFunction' @ [84:25] ==> private final fun enterFunction(function: JsFunction, arguments: List<JsExpression>): Unit defined in org.jetbrains.kotlin.js.dce.Analyzer[SimpleFunctionDescriptorImpl]

'postponedFunction' @ [84:39] ==> val postponedFunction: JsFunction? defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'expression' @ [84:58] ==> val expression: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'arguments' @ [84:69] ==> public final val JsInvocation.arguments: (MutableList<(JsExpression..JsExpression?)>..List<(JsExpression..JsExpression?)>)[MyPropertyDescriptor]

'invocationsToSkip' @ [85:25] ==> private final val invocationsToSkip: MutableSet<JsInvocation> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'expression' @ [85:46] ==> val expression: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'when {
                    context.isObjectDefineProperty(function) ->
                        handleObjectDefineProperty(x, expression.arguments.getOrNull(0), expression.arguments.getOrNull(1),
                                                   expression.arguments.getOrNull(2))

                // Kotlin.defineModule()
                    context.isDefineModule(function) ->
                        // (just remove it)
                        astNodesToEliminate += x
                    context.isAmdDefine(function) ->
                        handleAmdDefine(expression, expression.arguments)
                }' @ [91:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'context' @ [92:21] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'isObjectDefineProperty' @ [92:29] ==> public fun Context.isObjectDefineProperty(function: JsExpression): Boolean defined in org.jetbrains.kotlin.js.dce in file util.kt[SimpleFunctionDescriptorImpl]

'function' @ [92:52] ==> val function: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'handleObjectDefineProperty' @ [93:25] ==> private final fun handleObjectDefineProperty(statement: JsStatement, target: JsExpression?, propertyName: JsExpression?, propertyDescriptor: JsExpression?): Unit defined in org.jetbrains.kotlin.js.dce.Analyzer[SimpleFunctionDescriptorImpl]

'x' @ [93:52] ==> value-parameter x: JsExpressionStatement defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[ValueParameterDescriptorImpl]

'expression' @ [93:55] ==> val expression: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'arguments' @ [93:66] ==> public final val JsInvocation.arguments: (MutableList<(JsExpression..JsExpression?)>..List<(JsExpression..JsExpression?)>)[MyPropertyDescriptor]

'getOrNull' @ [93:76] ==> public fun <T> List<(JsExpression..JsExpression?)>.getOrNull(index: Int): JsExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.js.backend.ast.JsExpression..org.jetbrains.kotlin.js.backend.ast.JsExpression?)

'expression' @ [93:90] ==> val expression: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'arguments' @ [93:101] ==> public final val JsInvocation.arguments: (MutableList<(JsExpression..JsExpression?)>..List<(JsExpression..JsExpression?)>)[MyPropertyDescriptor]

'getOrNull' @ [93:111] ==> public fun <T> List<(JsExpression..JsExpression?)>.getOrNull(index: Int): JsExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.js.backend.ast.JsExpression..org.jetbrains.kotlin.js.backend.ast.JsExpression?)

'expression' @ [94:52] ==> val expression: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'arguments' @ [94:63] ==> public final val JsInvocation.arguments: (MutableList<(JsExpression..JsExpression?)>..List<(JsExpression..JsExpression?)>)[MyPropertyDescriptor]

'getOrNull' @ [94:73] ==> public fun <T> List<(JsExpression..JsExpression?)>.getOrNull(index: Int): JsExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.js.backend.ast.JsExpression..org.jetbrains.kotlin.js.backend.ast.JsExpression?)

'context' @ [97:21] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'isDefineModule' @ [97:29] ==> public fun Context.isDefineModule(function: JsExpression): Boolean defined in org.jetbrains.kotlin.js.dce in file util.kt[SimpleFunctionDescriptorImpl]

'function' @ [97:44] ==> val function: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'astNodesToEliminate' @ [99:25] ==> private final val astNodesToEliminate: MutableSet<JsNode> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'x' @ [99:48] ==> value-parameter x: JsExpressionStatement defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[ValueParameterDescriptorImpl]

'context' @ [100:21] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'isAmdDefine' @ [100:29] ==> public fun Context.isAmdDefine(function: JsExpression): Boolean defined in org.jetbrains.kotlin.js.dce in file util.kt[SimpleFunctionDescriptorImpl]

'function' @ [100:41] ==> val function: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'handleAmdDefine' @ [101:25] ==> private final fun handleAmdDefine(invocation: JsInvocation, arguments: List<JsExpression>): Unit defined in org.jetbrains.kotlin.js.dce.Analyzer[SimpleFunctionDescriptorImpl]

'expression' @ [101:41] ==> val expression: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'expression' @ [101:53] ==> val expression: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.visitExpressionStatement[LocalVariableDescriptor]

'arguments' @ [101:64] ==> public final val JsInvocation.arguments: (MutableList<(JsExpression..JsExpression?)>..List<(JsExpression..JsExpression?)>)[MyPropertyDescriptor]

'target' @ [109:13] ==> value-parameter target: JsExpression? defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[ValueParameterDescriptorImpl]

'propertyName' @ [109:31] ==> value-parameter propertyName: JsExpression? defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[ValueParameterDescriptorImpl]

'propertyDescriptor' @ [109:67] ==> value-parameter propertyDescriptor: JsExpression? defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[ValueParameterDescriptorImpl]

'context' @ [110:26] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'extractNode' @ [110:34] ==> public final fun extractNode(expression: JsExpression): Context.Node? defined in org.jetbrains.kotlin.js.dce.Context[SimpleFunctionDescriptorImpl]

'target' @ [110:46] ==> value-parameter target: JsExpression? defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[ValueParameterDescriptorImpl]

'targetNode' @ [112:26] ==> val targetNode: Context.Node defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[LocalVariableDescriptor]

'member' @ [112:37] ==> public final fun member(name: String): Context.Node defined in org.jetbrains.kotlin.js.dce.Context.Node[SimpleFunctionDescriptorImpl]

'propertyName' @ [112:44] ==> value-parameter propertyName: JsExpression? defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[ValueParameterDescriptorImpl]

'value' @ [112:57] ==> public final val JsStringLiteral.value: (String..String?)[MyPropertyDescriptor]

'nodeMap' @ [113:9] ==> private final val nodeMap: MutableMap<JsNode, Context.Node> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'statement' @ [113:17] ==> value-parameter statement: JsStatement defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[ValueParameterDescriptorImpl]

'memberNode' @ [113:30] ==> val memberNode: Context.Node defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[LocalVariableDescriptor]

'memberNode' @ [114:9] ==> val memberNode: Context.Node defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[LocalVariableDescriptor]

'hasSideEffects' @ [114:20] ==> public final var hasSideEffects: Boolean defined in org.jetbrains.kotlin.js.dce.Context.Node[PropertyDescriptorImpl]

'if (propertyDescriptor is JsObjectLiteral) {
            for (initializer in propertyDescriptor.propertyInitializers) {
                // process as if it was instance.name = value
                processAssignment(statement, JsNameRef(propertyName.value, target), initializer.valueExpr)
            }
        }
        // Object.defineProperty(instance, name, Object.getOwnPropertyDescriptor(otherInstance))
        else if (propertyDescriptor is JsInvocation) {
            val function = propertyDescriptor.qualifier
            if (context.isObjectGetOwnPropertyDescriptor(function)) {
                val source = propertyDescriptor.arguments.getOrNull(0)
                val sourcePropertyName = propertyDescriptor.arguments.getOrNull(1)
                if (source != null && sourcePropertyName is JsStringLiteral) {
                    // process as if it was instance.name = otherInstance.name
                    processAssignment(statement, JsNameRef(propertyName.value, target), JsNameRef(sourcePropertyName.value, source))
                }
            }
        }' @ [117:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'propertyDescriptor' @ [117:13] ==> value-parameter propertyDescriptor: JsExpression? defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[ValueParameterDescriptorImpl]

'propertyDescriptor' @ [118:33] ==> value-parameter propertyDescriptor: JsExpression? defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[ValueParameterDescriptorImpl]

'propertyInitializers' @ [118:52] ==> public final val JsObjectLiteral.propertyInitializers: (MutableList<(JsPropertyInitializer..JsPropertyInitializer?)>..List<(JsPropertyInitializer..JsPropertyInitializer?)>?)[MyPropertyDescriptor]

'processAssignment' @ [120:17] ==> private final fun processAssignment(node: JsNode?, lhs: JsExpression, rhs: JsExpression): Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer[SimpleFunctionDescriptorImpl]

'statement' @ [120:35] ==> value-parameter statement: JsStatement defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[ValueParameterDescriptorImpl]

'JsNameRef' @ [120:46] ==> public constructor JsNameRef(@NotNull p0: String, p1: (JsExpression..JsExpression?)) defined in org.jetbrains.kotlin.js.backend.ast.JsNameRef[JavaClassConstructorDescriptor]

'propertyName' @ [120:56] ==> value-parameter propertyName: JsExpression? defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[ValueParameterDescriptorImpl]

'value' @ [120:69] ==> public final val JsStringLiteral.value: (String..String?)[MyPropertyDescriptor]

'target' @ [120:76] ==> value-parameter target: JsExpression? defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[ValueParameterDescriptorImpl]

'initializer' @ [120:85] ==> val initializer: (JsPropertyInitializer..JsPropertyInitializer?) defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[LocalVariableDescriptor]

'valueExpr' @ [120:97] ==> public final val JsPropertyInitializer.valueExpr: JsExpression[MyPropertyDescriptor]

'propertyDescriptor' @ [124:18] ==> value-parameter propertyDescriptor: JsExpression? defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[ValueParameterDescriptorImpl]

'propertyDescriptor' @ [125:28] ==> value-parameter propertyDescriptor: JsExpression? defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[ValueParameterDescriptorImpl]

'qualifier' @ [125:47] ==> public final var JsInvocation.qualifier: JsExpression[MyPropertyDescriptor]

'context' @ [126:17] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'isObjectGetOwnPropertyDescriptor' @ [126:25] ==> public fun Context.isObjectGetOwnPropertyDescriptor(function: JsExpression): Boolean defined in org.jetbrains.kotlin.js.dce in file util.kt[SimpleFunctionDescriptorImpl]

'function' @ [126:58] ==> val function: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[LocalVariableDescriptor]

'propertyDescriptor' @ [127:30] ==> value-parameter propertyDescriptor: JsExpression? defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[ValueParameterDescriptorImpl]

'arguments' @ [127:49] ==> public final val JsInvocation.arguments: (MutableList<(JsExpression..JsExpression?)>..List<(JsExpression..JsExpression?)>)[MyPropertyDescriptor]

'getOrNull' @ [127:59] ==> public fun <T> List<(JsExpression..JsExpression?)>.getOrNull(index: Int): JsExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.js.backend.ast.JsExpression..org.jetbrains.kotlin.js.backend.ast.JsExpression?)

'propertyDescriptor' @ [128:42] ==> value-parameter propertyDescriptor: JsExpression? defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[ValueParameterDescriptorImpl]

'arguments' @ [128:61] ==> public final val JsInvocation.arguments: (MutableList<(JsExpression..JsExpression?)>..List<(JsExpression..JsExpression?)>)[MyPropertyDescriptor]

'getOrNull' @ [128:71] ==> public fun <T> List<(JsExpression..JsExpression?)>.getOrNull(index: Int): JsExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.js.backend.ast.JsExpression..org.jetbrains.kotlin.js.backend.ast.JsExpression?)

'source' @ [129:21] ==> val source: JsExpression? defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[LocalVariableDescriptor]

'sourcePropertyName' @ [129:39] ==> val sourcePropertyName: JsExpression? defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[LocalVariableDescriptor]

'processAssignment' @ [131:21] ==> private final fun processAssignment(node: JsNode?, lhs: JsExpression, rhs: JsExpression): Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer[SimpleFunctionDescriptorImpl]

'statement' @ [131:39] ==> value-parameter statement: JsStatement defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[ValueParameterDescriptorImpl]

'JsNameRef' @ [131:50] ==> public constructor JsNameRef(@NotNull p0: String, p1: (JsExpression..JsExpression?)) defined in org.jetbrains.kotlin.js.backend.ast.JsNameRef[JavaClassConstructorDescriptor]

'propertyName' @ [131:60] ==> value-parameter propertyName: JsExpression? defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[ValueParameterDescriptorImpl]

'value' @ [131:73] ==> public final val JsStringLiteral.value: (String..String?)[MyPropertyDescriptor]

'target' @ [131:80] ==> value-parameter target: JsExpression? defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[ValueParameterDescriptorImpl]

'JsNameRef' @ [131:89] ==> public constructor JsNameRef(@NotNull p0: String, p1: (JsExpression..JsExpression?)) defined in org.jetbrains.kotlin.js.backend.ast.JsNameRef[JavaClassConstructorDescriptor]

'sourcePropertyName' @ [131:99] ==> val sourcePropertyName: JsExpression? defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[LocalVariableDescriptor]

'value' @ [131:118] ==> public final val JsStringLiteral.value: (String..String?)[MyPropertyDescriptor]

'source' @ [131:125] ==> val source: JsExpression? defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectDefineProperty[LocalVariableDescriptor]

'when (arguments.size) {
            2 -> arguments
            3 -> arguments.drop(1)
            else -> return
        }' @ [139:36] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: List<JsExpression>, entry1: List<JsExpression>, entry2: List<JsExpression>): List<JsExpression>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> List<JsExpression>

'arguments' @ [139:42] ==> value-parameter arguments: List<JsExpression> defined in org.jetbrains.kotlin.js.dce.Analyzer.handleAmdDefine[ValueParameterDescriptorImpl]

'size' @ [139:52] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'arguments' @ [140:18] ==> value-parameter arguments: List<JsExpression> defined in org.jetbrains.kotlin.js.dce.Analyzer.handleAmdDefine[ValueParameterDescriptorImpl]

'arguments' @ [141:18] ==> value-parameter arguments: List<JsExpression> defined in org.jetbrains.kotlin.js.dce.Analyzer.handleAmdDefine[ValueParameterDescriptorImpl]

'drop' @ [141:28] ==> public fun <T> Iterable<JsExpression>.drop(n: Int): List<JsExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsExpression

'argumentsWithoutName' @ [145:28] ==> val argumentsWithoutName: List<JsExpression> defined in org.jetbrains.kotlin.js.dce.Analyzer.handleAmdDefine[LocalVariableDescriptor]

'argumentsWithoutName' @ [149:27] ==> val argumentsWithoutName: List<JsExpression> defined in org.jetbrains.kotlin.js.dce.Analyzer.handleAmdDefine[LocalVariableDescriptor]

'when (functionRef) {
            is JsFunction -> functionRef
            is JsNameRef -> {
                if (functionRef.qualifier != null) return
                postponedFunctions[functionRef.name] ?: return
            }
            else -> return
        }' @ [150:24] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: JsFunction, entry1: JsFunction, entry2: JsFunction): JsFunction[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> JsFunction

'functionRef' @ [150:30] ==> val functionRef: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.handleAmdDefine[LocalVariableDescriptor]

'functionRef' @ [151:30] ==> val functionRef: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.handleAmdDefine[LocalVariableDescriptor]

'functionRef' @ [153:21] ==> val functionRef: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.handleAmdDefine[LocalVariableDescriptor]

'qualifier' @ [153:33] ==> public final var JsNameRef.qualifier: JsExpression?[MyPropertyDescriptor]

'postponedFunctions' @ [154:17] ==> private final val postponedFunctions: MutableMap<JsName, JsFunction> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'functionRef' @ [154:36] ==> val functionRef: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.handleAmdDefine[LocalVariableDescriptor]

'name' @ [154:48] ==> public final var JsNameRef.name: JsName?[MyPropertyDescriptor]

'dependencies' @ [159:31] ==> val dependencies: JsArrayLiteral defined in org.jetbrains.kotlin.js.dce.Analyzer.handleAmdDefine[LocalVariableDescriptor]

'expressions' @ [159:44] ==> public final val JsArrayLiteral.expressions: (MutableList<(JsExpression..JsExpression?)>..List<(JsExpression..JsExpression?)>?)[MyPropertyDescriptor]

'map' @ [160:18] ==> public inline fun <T, R> Iterable<(JsExpression..JsExpression?)>.map(transform: ((JsExpression..JsExpression?)) -> JsStringLiteral): List<JsStringLiteral> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.js.backend.ast.JsExpression..org.jetbrains.kotlin.js.backend.ast.JsExpression?)
    <R> -> JsStringLiteral

'it' @ [160:24] ==> value-parameter it: (JsExpression..JsExpression?) defined in org.jetbrains.kotlin.js.dce.Analyzer.handleAmdDefine.<anonymous>[ValueParameterDescriptorImpl]

'map' @ [161:18] ==> public inline fun <T, R> Iterable<JsStringLiteral>.map(transform: (JsStringLiteral) -> Context.Node): List<Context.Node> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsStringLiteral
    <R> -> Node

'if (it.value == "exports") context.currentModule else context.globalScope.member(it.value)' @ [161:24] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Context.Node, elseBranch: Context.Node): Context.Node[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Node

'it' @ [161:28] ==> value-parameter it: JsStringLiteral defined in org.jetbrains.kotlin.js.dce.Analyzer.handleAmdDefine.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [161:31] ==> public final val JsStringLiteral.value: (String..String?)[MyPropertyDescriptor]

'context' @ [161:51] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'currentModule' @ [161:59] ==> public final var currentModule: Context.Node defined in org.jetbrains.kotlin.js.dce.Context[PropertyDescriptorImpl]

'context' @ [161:78] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'globalScope' @ [161:86] ==> public final val globalScope: Context.Node defined in org.jetbrains.kotlin.js.dce.Context[PropertyDescriptorImpl]

'member' @ [161:98] ==> public final fun member(name: String): Context.Node defined in org.jetbrains.kotlin.js.dce.Context.Node[SimpleFunctionDescriptorImpl]

'it' @ [161:105] ==> value-parameter it: JsStringLiteral defined in org.jetbrains.kotlin.js.dce.Analyzer.handleAmdDefine.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [161:108] ==> public final val JsStringLiteral.value: (String..String?)[MyPropertyDescriptor]

'enterFunctionWithGivenNodes' @ [163:9] ==> private final fun enterFunctionWithGivenNodes(function: JsFunction, arguments: List<Context.Node>): Unit defined in org.jetbrains.kotlin.js.dce.Analyzer[SimpleFunctionDescriptorImpl]

'function' @ [163:37] ==> val function: JsFunction defined in org.jetbrains.kotlin.js.dce.Analyzer.handleAmdDefine[LocalVariableDescriptor]

'dependencyNodes' @ [163:47] ==> val dependencyNodes: List<Context.Node> defined in org.jetbrains.kotlin.js.dce.Analyzer.handleAmdDefine[LocalVariableDescriptor]

'astNodesToSkip' @ [164:9] ==> private final val astNodesToSkip: MutableSet<JsNode> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'invocation' @ [164:27] ==> value-parameter invocation: JsInvocation defined in org.jetbrains.kotlin.js.dce.Analyzer.handleAmdDefine[ValueParameterDescriptorImpl]

'qualifier' @ [164:38] ==> public final var JsInvocation.qualifier: JsExpression[MyPropertyDescriptor]

'moduleMapping' @ [168:25] ==> public final val moduleMapping: MutableMap<JsStatement, String> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'x' @ [168:39] ==> value-parameter x: JsBlock defined in org.jetbrains.kotlin.js.dce.Analyzer.visitBlock[ValueParameterDescriptorImpl]

'newModule' @ [169:13] ==> val newModule: String? defined in org.jetbrains.kotlin.js.dce.Analyzer.visitBlock[LocalVariableDescriptor]

'context' @ [170:13] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'currentModule' @ [170:21] ==> public final var currentModule: Context.Node defined in org.jetbrains.kotlin.js.dce.Context[PropertyDescriptorImpl]

'context' @ [170:37] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'globalScope' @ [170:45] ==> public final val globalScope: Context.Node defined in org.jetbrains.kotlin.js.dce.Context[PropertyDescriptorImpl]

'member' @ [170:57] ==> public final fun member(name: String): Context.Node defined in org.jetbrains.kotlin.js.dce.Context.Node[SimpleFunctionDescriptorImpl]

'newModule' @ [170:64] ==> val newModule: String? defined in org.jetbrains.kotlin.js.dce.Analyzer.visitBlock[LocalVariableDescriptor]

'x' @ [172:9] ==> value-parameter x: JsBlock defined in org.jetbrains.kotlin.js.dce.Analyzer.visitBlock[ValueParameterDescriptorImpl]

'statements' @ [172:11] ==> public final val JsBlock.statements: (MutableList<(JsStatement..JsStatement?)>..List<(JsStatement..JsStatement?)>)[MyPropertyDescriptor]

'forEach' @ [172:22] ==> @HidesMembers public inline fun <T> Iterable<(JsStatement..JsStatement?)>.forEach(action: ((JsStatement..JsStatement?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.js.backend.ast.JsStatement..org.jetbrains.kotlin.js.backend.ast.JsStatement?)

'accept' @ [172:32] ==> public open fun <T : JsNode?> accept(node: (JsStatement..JsStatement?)): Unit defined in org.jetbrains.kotlin.js.dce.Analyzer[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : JsNode?> -> (org.jetbrains.kotlin.js.backend.ast.JsStatement..org.jetbrains.kotlin.js.backend.ast.JsStatement?)

'it' @ [172:39] ==> value-parameter it: (JsStatement..JsStatement?) defined in org.jetbrains.kotlin.js.dce.Analyzer.visitBlock.<anonymous>[ValueParameterDescriptorImpl]

'accept' @ [176:9] ==> public open fun <T : JsNode?> accept(node: JsStatement): Unit defined in org.jetbrains.kotlin.js.dce.Analyzer[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : JsNode?> -> JsStatement

'x' @ [176:16] ==> value-parameter x: JsIf defined in org.jetbrains.kotlin.js.dce.Analyzer.visitIf[ValueParameterDescriptorImpl]

'thenStatement' @ [176:18] ==> public final var JsIf.thenStatement: JsStatement[MyPropertyDescriptor]

'x' @ [177:9] ==> value-parameter x: JsIf defined in org.jetbrains.kotlin.js.dce.Analyzer.visitIf[ValueParameterDescriptorImpl]

'elseStatement' @ [177:11] ==> public final var JsIf.elseStatement: JsStatement?[MyPropertyDescriptor]

'accept' @ [177:26] ==> public abstract fun accept(p0: (JsVisitor..JsVisitor?)): Unit defined in org.jetbrains.kotlin.js.backend.ast.JsStatement[JavaMethodDescriptor]

'this' @ [177:33] ==> <this> defined in org.jetbrains.kotlin.js.dce.Analyzer[LazyClassReceiverParameterDescriptor]

'x' @ [181:20] ==> value-parameter x: JsReturn defined in org.jetbrains.kotlin.js.dce.Analyzer.visitReturn[ValueParameterDescriptorImpl]

'expression' @ [181:22] ==> public final var JsReturn.expression: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'expr' @ [182:13] ==> val expr: (JsExpression..JsExpression?) defined in org.jetbrains.kotlin.js.dce.Analyzer.visitReturn[LocalVariableDescriptor]

'context' @ [183:13] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'extractNode' @ [183:21] ==> public final fun extractNode(expression: JsExpression): Context.Node? defined in org.jetbrains.kotlin.js.dce.Context[SimpleFunctionDescriptorImpl]

'expr' @ [183:33] ==> val expr: (JsExpression..JsExpression?) defined in org.jetbrains.kotlin.js.dce.Analyzer.visitReturn[LocalVariableDescriptor]

'let' @ [183:40] ==> @InlineOnly public inline fun <T, R> Context.Node.let(block: (Context.Node) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Node
    <R> -> Unit

'nodeMap' @ [184:17] ==> private final val nodeMap: MutableMap<JsNode, Context.Node> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'x' @ [184:25] ==> value-parameter x: JsReturn defined in org.jetbrains.kotlin.js.dce.Analyzer.visitReturn[ValueParameterDescriptorImpl]

'it' @ [184:30] ==> value-parameter it: Context.Node defined in org.jetbrains.kotlin.js.dce.Analyzer.visitReturn.<anonymous>[ValueParameterDescriptorImpl]

'context' @ [190:24] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'extractNode' @ [190:32] ==> public final fun extractNode(expression: JsExpression): Context.Node? defined in org.jetbrains.kotlin.js.dce.Context[SimpleFunctionDescriptorImpl]

'lhs' @ [190:44] ==> value-parameter lhs: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'context' @ [191:25] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'extractNode' @ [191:33] ==> public final fun extractNode(expression: JsExpression): Context.Node? defined in org.jetbrains.kotlin.js.dce.Context[SimpleFunctionDescriptorImpl]

'rhs' @ [191:45] ==> value-parameter rhs: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'if (leftNode != null && rightNode != null) {
            // If both left and right expressions are fully-qualified names, alias them
            leftNode.alias(rightNode)
            return leftNode
        }
        else if (leftNode != null) {
            // lhs = foo()
            when {
                rhs is JsInvocation -> {
                    val function = rhs.qualifier

                    // lhs = function(params) { ... }(arguments)
                    // see corresponding case in visitExpressionStatement
                    if (function is JsFunction) {
                        enterFunction(function, rhs.arguments)
                        astNodesToSkip += lhs
                        return null
                    }

                    // lhs = foo(arguments), where foo is a parameter of outer function that always take function literal
                    // see corresponding case in visitExpressionStatement
                    if (function is JsNameRef && function.qualifier == null) {
                        function.name?.let { postponedFunctions[it] }?.let {
                            enterFunction(it, rhs.arguments)
                            astNodesToSkip += lhs
                            return null
                        }
                    }

                    // lhs = Object.create(constructor)
                    if (context.isObjectFunction(function, "create")) {
                        // Do not alias lhs and constructor, make unidirectional dependency lhs -> constructor instead.
                        // Motivation: reachability of a base class does not imply reachability of its derived class
                        handleObjectCreate(leftNode, rhs.arguments.getOrNull(0))
                        return leftNode
                    }

                    // lhs = Kotlin.defineInlineFunction('fqn', function() { ... })
                    if (context.isDefineInlineFunction(function) && rhs.arguments.size == 2) {
                        leftNode.functions += rhs.arguments[1] as JsFunction
                        val defineInlineFunctionNode = context.extractNode(function)
                        if (defineInlineFunctionNode != null) {
                            leftNode.dependencies += defineInlineFunctionNode
                        }
                        return leftNode
                    }
                }
                rhs is JsBinaryOperation -> // Detect lhs = parent.child || (parent.child = {}), which is used to declare packages.
                    // Assume lhs = parent.child
                    if (rhs.operator == JsBinaryOperator.OR) {
                        val secondNode = context.extractNode(rhs.arg1)
                        val reassignment = rhs.arg2
                        if (reassignment is JsBinaryOperation && reassignment.operator == JsBinaryOperator.ASG) {
                            val reassignNode = context.extractNode(reassignment.arg1)
                            val reassignValue = reassignment.arg2
                            if (reassignNode == secondNode && reassignNode != null && reassignValue is JsObjectLiteral &&
                                reassignValue.propertyInitializers.isEmpty()
                                    ) {
                                return processAssignment(node, lhs, rhs.arg1)
                            }
                        }
                    }
                rhs is JsFunction -> {
                    // lhs = function() { ... }
                    // During reachability tracking phase: eliminate it if lhs is unreachable, traverse function otherwise
                    leftNode.functions += rhs
                    return leftNode
                }
                leftNode.qualifier?.memberName == Namer.METADATA -> {
                    // lhs.$metadata$ = expression
                    // During reachability tracking phase: eliminate it if lhs is unreachable, traverse expression
                    // It's commonly used to supply class's metadata
                    leftNode.expressions += rhs
                    return leftNode
                }
                rhs is JsObjectLiteral && rhs.propertyInitializers.isEmpty() -> return leftNode
            }

            val nodeInitializedByEmptyObject = extractVariableInitializedByEmptyObject(rhs)
            if (nodeInitializedByEmptyObject != null) {
                astNodesToSkip += rhs
                leftNode.alias(nodeInitializedByEmptyObject)
                return leftNode
            }
        }' @ [193:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'leftNode' @ [193:13] ==> val leftNode: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'rightNode' @ [193:33] ==> val rightNode: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'leftNode' @ [195:13] ==> val leftNode: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'alias' @ [195:22] ==> public final fun alias(other: Context.Node): Unit defined in org.jetbrains.kotlin.js.dce.Context.Node[SimpleFunctionDescriptorImpl]

'rightNode' @ [195:28] ==> val rightNode: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'leftNode' @ [196:20] ==> val leftNode: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'leftNode' @ [198:18] ==> val leftNode: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'when {
                rhs is JsInvocation -> {
                    val function = rhs.qualifier

                    // lhs = function(params) { ... }(arguments)
                    // see corresponding case in visitExpressionStatement
                    if (function is JsFunction) {
                        enterFunction(function, rhs.arguments)
                        astNodesToSkip += lhs
                        return null
                    }

                    // lhs = foo(arguments), where foo is a parameter of outer function that always take function literal
                    // see corresponding case in visitExpressionStatement
                    if (function is JsNameRef && function.qualifier == null) {
                        function.name?.let { postponedFunctions[it] }?.let {
                            enterFunction(it, rhs.arguments)
                            astNodesToSkip += lhs
                            return null
                        }
                    }

                    // lhs = Object.create(constructor)
                    if (context.isObjectFunction(function, "create")) {
                        // Do not alias lhs and constructor, make unidirectional dependency lhs -> constructor instead.
                        // Motivation: reachability of a base class does not imply reachability of its derived class
                        handleObjectCreate(leftNode, rhs.arguments.getOrNull(0))
                        return leftNode
                    }

                    // lhs = Kotlin.defineInlineFunction('fqn', function() { ... })
                    if (context.isDefineInlineFunction(function) && rhs.arguments.size == 2) {
                        leftNode.functions += rhs.arguments[1] as JsFunction
                        val defineInlineFunctionNode = context.extractNode(function)
                        if (defineInlineFunctionNode != null) {
                            leftNode.dependencies += defineInlineFunctionNode
                        }
                        return leftNode
                    }
                }
                rhs is JsBinaryOperation -> // Detect lhs = parent.child || (parent.child = {}), which is used to declare packages.
                    // Assume lhs = parent.child
                    if (rhs.operator == JsBinaryOperator.OR) {
                        val secondNode = context.extractNode(rhs.arg1)
                        val reassignment = rhs.arg2
                        if (reassignment is JsBinaryOperation && reassignment.operator == JsBinaryOperator.ASG) {
                            val reassignNode = context.extractNode(reassignment.arg1)
                            val reassignValue = reassignment.arg2
                            if (reassignNode == secondNode && reassignNode != null && reassignValue is JsObjectLiteral &&
                                reassignValue.propertyInitializers.isEmpty()
                                    ) {
                                return processAssignment(node, lhs, rhs.arg1)
                            }
                        }
                    }
                rhs is JsFunction -> {
                    // lhs = function() { ... }
                    // During reachability tracking phase: eliminate it if lhs is unreachable, traverse function otherwise
                    leftNode.functions += rhs
                    return leftNode
                }
                leftNode.qualifier?.memberName == Namer.METADATA -> {
                    // lhs.$metadata$ = expression
                    // During reachability tracking phase: eliminate it if lhs is unreachable, traverse expression
                    // It's commonly used to supply class's metadata
                    leftNode.expressions += rhs
                    return leftNode
                }
                rhs is JsObjectLiteral && rhs.propertyInitializers.isEmpty() -> return leftNode
            }' @ [200:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit, entry3: Unit, entry4: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'rhs' @ [201:17] ==> value-parameter rhs: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'rhs' @ [202:36] ==> value-parameter rhs: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'qualifier' @ [202:40] ==> public final var JsInvocation.qualifier: JsExpression[MyPropertyDescriptor]

'function' @ [206:25] ==> val function: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'enterFunction' @ [207:25] ==> private final fun enterFunction(function: JsFunction, arguments: List<JsExpression>): Unit defined in org.jetbrains.kotlin.js.dce.Analyzer[SimpleFunctionDescriptorImpl]

'function' @ [207:39] ==> val function: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'rhs' @ [207:49] ==> value-parameter rhs: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'arguments' @ [207:53] ==> public final val JsInvocation.arguments: (MutableList<(JsExpression..JsExpression?)>..List<(JsExpression..JsExpression?)>)[MyPropertyDescriptor]

'astNodesToSkip' @ [208:25] ==> private final val astNodesToSkip: MutableSet<JsNode> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'lhs' @ [208:43] ==> value-parameter lhs: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'function' @ [214:25] ==> val function: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'function' @ [214:50] ==> val function: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'qualifier' @ [214:59] ==> public final var JsNameRef.qualifier: JsExpression?[MyPropertyDescriptor]

'function' @ [215:25] ==> val function: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'name' @ [215:34] ==> public final var JsNameRef.name: JsName?[MyPropertyDescriptor]

'let' @ [215:40] ==> @InlineOnly public inline fun <T, R> JsName.let(block: (JsName) -> JsFunction?): JsFunction? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsName
    <R> -> JsFunction?

'postponedFunctions' @ [215:46] ==> private final val postponedFunctions: MutableMap<JsName, JsFunction> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'it' @ [215:65] ==> value-parameter it: JsName defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment.<anonymous>[ValueParameterDescriptorImpl]

'let' @ [215:72] ==> @InlineOnly public inline fun <T, R> JsFunction.let(block: (JsFunction) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsFunction
    <R> -> Nothing

'enterFunction' @ [216:29] ==> private final fun enterFunction(function: JsFunction, arguments: List<JsExpression>): Unit defined in org.jetbrains.kotlin.js.dce.Analyzer[SimpleFunctionDescriptorImpl]

'it' @ [216:43] ==> value-parameter it: JsFunction defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment.<anonymous>[ValueParameterDescriptorImpl]

'rhs' @ [216:47] ==> value-parameter rhs: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'arguments' @ [216:51] ==> public final val JsInvocation.arguments: (MutableList<(JsExpression..JsExpression?)>..List<(JsExpression..JsExpression?)>)[MyPropertyDescriptor]

'astNodesToSkip' @ [217:29] ==> private final val astNodesToSkip: MutableSet<JsNode> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'lhs' @ [217:47] ==> value-parameter lhs: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'context' @ [223:25] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'isObjectFunction' @ [223:33] ==> public fun Context.isObjectFunction(function: JsExpression, functionName: String): Boolean defined in org.jetbrains.kotlin.js.dce in file util.kt[SimpleFunctionDescriptorImpl]

'function' @ [223:50] ==> val function: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'handleObjectCreate' @ [226:25] ==> private final fun handleObjectCreate(target: Context.Node, arg: JsExpression?): Unit defined in org.jetbrains.kotlin.js.dce.Analyzer[SimpleFunctionDescriptorImpl]

'leftNode' @ [226:44] ==> val leftNode: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'rhs' @ [226:54] ==> value-parameter rhs: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'arguments' @ [226:58] ==> public final val JsInvocation.arguments: (MutableList<(JsExpression..JsExpression?)>..List<(JsExpression..JsExpression?)>)[MyPropertyDescriptor]

'getOrNull' @ [226:68] ==> public fun <T> List<(JsExpression..JsExpression?)>.getOrNull(index: Int): JsExpression? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.js.backend.ast.JsExpression..org.jetbrains.kotlin.js.backend.ast.JsExpression?)

'leftNode' @ [227:32] ==> val leftNode: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'context' @ [231:25] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'isDefineInlineFunction' @ [231:33] ==> public fun Context.isDefineInlineFunction(function: JsExpression): Boolean defined in org.jetbrains.kotlin.js.dce in file util.kt[SimpleFunctionDescriptorImpl]

'function' @ [231:56] ==> val function: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'rhs' @ [231:69] ==> value-parameter rhs: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'arguments' @ [231:73] ==> public final val JsInvocation.arguments: (MutableList<(JsExpression..JsExpression?)>..List<(JsExpression..JsExpression?)>)[MyPropertyDescriptor]

'size' @ [231:83] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'leftNode' @ [232:25] ==> val leftNode: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'functions' @ [232:34] ==> public final val functions: MutableSet<JsFunction> defined in org.jetbrains.kotlin.js.dce.Context.Node[PropertyDescriptorImpl]

'rhs' @ [232:47] ==> value-parameter rhs: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'arguments' @ [232:51] ==> public final val JsInvocation.arguments: (MutableList<(JsExpression..JsExpression?)>..List<(JsExpression..JsExpression?)>)[MyPropertyDescriptor]

'context' @ [233:56] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'extractNode' @ [233:64] ==> public final fun extractNode(expression: JsExpression): Context.Node? defined in org.jetbrains.kotlin.js.dce.Context[SimpleFunctionDescriptorImpl]

'function' @ [233:76] ==> val function: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'defineInlineFunctionNode' @ [234:29] ==> val defineInlineFunctionNode: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'leftNode' @ [235:29] ==> val leftNode: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'dependencies' @ [235:38] ==> public final val dependencies: MutableSet<Context.Node> defined in org.jetbrains.kotlin.js.dce.Context.Node[PropertyDescriptorImpl]

'defineInlineFunctionNode' @ [235:54] ==> val defineInlineFunctionNode: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'leftNode' @ [237:32] ==> val leftNode: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'rhs' @ [240:17] ==> value-parameter rhs: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'rhs' @ [242:25] ==> value-parameter rhs: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'operator' @ [242:29] ==> public final val JsBinaryOperation.operator: JsBinaryOperator[MyPropertyDescriptor]

'OR' @ [242:58] ==> enum entry OR defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'context' @ [243:42] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'extractNode' @ [243:50] ==> public final fun extractNode(expression: JsExpression): Context.Node? defined in org.jetbrains.kotlin.js.dce.Context[SimpleFunctionDescriptorImpl]

'rhs' @ [243:62] ==> value-parameter rhs: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'arg1' @ [243:66] ==> public final var JsBinaryOperation.arg1: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'rhs' @ [244:44] ==> value-parameter rhs: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'arg2' @ [244:48] ==> public final var JsBinaryOperation.arg2: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'reassignment' @ [245:29] ==> val reassignment: (JsExpression..JsExpression?) defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'reassignment' @ [245:66] ==> val reassignment: (JsExpression..JsExpression?) defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'operator' @ [245:79] ==> public final val JsBinaryOperation.operator: JsBinaryOperator[MyPropertyDescriptor]

'ASG' @ [245:108] ==> enum entry ASG defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'context' @ [246:48] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'extractNode' @ [246:56] ==> public final fun extractNode(expression: JsExpression): Context.Node? defined in org.jetbrains.kotlin.js.dce.Context[SimpleFunctionDescriptorImpl]

'reassignment' @ [246:68] ==> val reassignment: (JsExpression..JsExpression?) defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'arg1' @ [246:81] ==> public final var JsBinaryOperation.arg1: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'reassignment' @ [247:49] ==> val reassignment: (JsExpression..JsExpression?) defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'arg2' @ [247:62] ==> public final var JsBinaryOperation.arg2: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'reassignNode' @ [248:33] ==> val reassignNode: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'secondNode' @ [248:49] ==> val secondNode: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'reassignNode' @ [248:63] ==> val reassignNode: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'reassignValue' @ [248:87] ==> val reassignValue: (JsExpression..JsExpression?) defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'reassignValue' @ [249:33] ==> val reassignValue: (JsExpression..JsExpression?) defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'propertyInitializers' @ [249:47] ==> public final val JsObjectLiteral.propertyInitializers: (MutableList<(JsPropertyInitializer..JsPropertyInitializer?)>..List<(JsPropertyInitializer..JsPropertyInitializer?)>?)[MyPropertyDescriptor]

'isEmpty' @ [249:68] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'processAssignment' @ [251:40] ==> private final fun processAssignment(node: JsNode?, lhs: JsExpression, rhs: JsExpression): Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer[SimpleFunctionDescriptorImpl]

'node' @ [251:58] ==> value-parameter node: JsNode? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'lhs' @ [251:64] ==> value-parameter lhs: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'rhs' @ [251:69] ==> value-parameter rhs: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'arg1' @ [251:73] ==> public final var JsBinaryOperation.arg1: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'rhs' @ [255:17] ==> value-parameter rhs: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'leftNode' @ [258:21] ==> val leftNode: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'functions' @ [258:30] ==> public final val functions: MutableSet<JsFunction> defined in org.jetbrains.kotlin.js.dce.Context.Node[PropertyDescriptorImpl]

'rhs' @ [258:43] ==> value-parameter rhs: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'leftNode' @ [259:28] ==> val leftNode: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'leftNode' @ [261:17] ==> val leftNode: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'qualifier' @ [261:26] ==> public final var qualifier: Context.Qualifier? defined in org.jetbrains.kotlin.js.dce.Context.Node[PropertyDescriptorImpl]

'memberName' @ [261:37] ==> public final val memberName: String defined in org.jetbrains.kotlin.js.dce.Context.Qualifier[PropertyDescriptorImpl]

'METADATA' @ [261:57] ==> public const final val METADATA: String defined in org.jetbrains.kotlin.js.translate.context.Namer[JavaPropertyDescriptor]

'leftNode' @ [265:21] ==> val leftNode: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'expressions' @ [265:30] ==> public final val expressions: MutableSet<JsExpression> defined in org.jetbrains.kotlin.js.dce.Context.Node[PropertyDescriptorImpl]

'rhs' @ [265:45] ==> value-parameter rhs: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'leftNode' @ [266:28] ==> val leftNode: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'rhs' @ [268:17] ==> value-parameter rhs: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'rhs' @ [268:43] ==> value-parameter rhs: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'propertyInitializers' @ [268:47] ==> public final val JsObjectLiteral.propertyInitializers: (MutableList<(JsPropertyInitializer..JsPropertyInitializer?)>..List<(JsPropertyInitializer..JsPropertyInitializer?)>?)[MyPropertyDescriptor]

'isEmpty' @ [268:68] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'leftNode' @ [268:88] ==> val leftNode: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'extractVariableInitializedByEmptyObject' @ [271:48] ==> private final fun extractVariableInitializedByEmptyObject(expression: JsExpression): Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer[SimpleFunctionDescriptorImpl]

'rhs' @ [271:88] ==> value-parameter rhs: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'nodeInitializedByEmptyObject' @ [272:17] ==> val nodeInitializedByEmptyObject: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'astNodesToSkip' @ [273:17] ==> private final val astNodesToSkip: MutableSet<JsNode> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'rhs' @ [273:35] ==> value-parameter rhs: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[ValueParameterDescriptorImpl]

'leftNode' @ [274:17] ==> val leftNode: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'alias' @ [274:26] ==> public final fun alias(other: Context.Node): Unit defined in org.jetbrains.kotlin.js.dce.Context.Node[SimpleFunctionDescriptorImpl]

'nodeInitializedByEmptyObject' @ [274:32] ==> val nodeInitializedByEmptyObject: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'leftNode' @ [275:24] ==> val leftNode: Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer.processAssignment[LocalVariableDescriptor]

'arg' @ [282:13] ==> value-parameter arg: JsExpression? defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectCreate[ValueParameterDescriptorImpl]

'context' @ [284:29] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'extractNode' @ [284:37] ==> public final fun extractNode(expression: JsExpression): Context.Node? defined in org.jetbrains.kotlin.js.dce.Context[SimpleFunctionDescriptorImpl]

'arg' @ [284:49] ==> value-parameter arg: JsExpression? defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectCreate[ValueParameterDescriptorImpl]

'target' @ [285:9] ==> value-parameter target: Context.Node defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectCreate[ValueParameterDescriptorImpl]

'dependencies' @ [285:16] ==> public final val dependencies: MutableSet<Context.Node> defined in org.jetbrains.kotlin.js.dce.Context.Node[PropertyDescriptorImpl]

'prototypeNode' @ [285:32] ==> val prototypeNode: Context.Node defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectCreate[LocalVariableDescriptor]

'original' @ [285:46] ==> public final var original: Context.Node defined in org.jetbrains.kotlin.js.dce.Context.Node[PropertyDescriptorImpl]

'target' @ [286:9] ==> value-parameter target: Context.Node defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectCreate[ValueParameterDescriptorImpl]

'expressions' @ [286:16] ==> public final val expressions: MutableSet<JsExpression> defined in org.jetbrains.kotlin.js.dce.Context.Node[PropertyDescriptorImpl]

'arg' @ [286:31] ==> value-parameter arg: JsExpression? defined in org.jetbrains.kotlin.js.dce.Analyzer.handleObjectCreate[ValueParameterDescriptorImpl]

'expression' @ [293:13] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.extractVariableInitializedByEmptyObject[ValueParameterDescriptorImpl]

'expression' @ [295:24] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.extractVariableInitializedByEmptyObject[ValueParameterDescriptorImpl]

'testExpression' @ [295:35] ==> public final var JsConditional.testExpression: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'testExpr' @ [296:13] ==> val testExpr: JsBinaryOperation defined in org.jetbrains.kotlin.js.dce.Analyzer.extractVariableInitializedByEmptyObject[LocalVariableDescriptor]

'operator' @ [296:22] ==> public final val JsBinaryOperation.operator: JsBinaryOperator[MyPropertyDescriptor]

'REF_EQ' @ [296:51] ==> enum entry REF_EQ defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'testExpr' @ [298:27] ==> val testExpr: JsBinaryOperation defined in org.jetbrains.kotlin.js.dce.Analyzer.extractVariableInitializedByEmptyObject[LocalVariableDescriptor]

'arg1' @ [298:36] ==> public final var JsBinaryOperation.arg1: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'testExprLhs' @ [299:13] ==> val testExprLhs: JsPrefixOperation defined in org.jetbrains.kotlin.js.dce.Analyzer.extractVariableInitializedByEmptyObject[LocalVariableDescriptor]

'operator' @ [299:25] ==> public final val JsPrefixOperation.operator: (JsUnaryOperator..JsUnaryOperator?)[MyPropertyDescriptor]

'TYPEOF' @ [299:53] ==> enum entry TYPEOF defined in org.jetbrains.kotlin.js.backend.ast.JsUnaryOperator[FakeCallableDescriptorForObject]

'context' @ [300:28] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'extractNode' @ [300:36] ==> public final fun extractNode(expression: JsExpression): Context.Node? defined in org.jetbrains.kotlin.js.dce.Context[SimpleFunctionDescriptorImpl]

'testExprLhs' @ [300:48] ==> val testExprLhs: JsPrefixOperation defined in org.jetbrains.kotlin.js.dce.Analyzer.extractVariableInitializedByEmptyObject[LocalVariableDescriptor]

'arg' @ [300:60] ==> public final var JsPrefixOperation.arg: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'testExpr' @ [302:27] ==> val testExpr: JsBinaryOperation defined in org.jetbrains.kotlin.js.dce.Analyzer.extractVariableInitializedByEmptyObject[LocalVariableDescriptor]

'arg2' @ [302:36] ==> public final var JsBinaryOperation.arg2: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'testExprRhs' @ [303:13] ==> val testExprRhs: JsStringLiteral defined in org.jetbrains.kotlin.js.dce.Analyzer.extractVariableInitializedByEmptyObject[LocalVariableDescriptor]

'value' @ [303:25] ==> public final val JsStringLiteral.value: (String..String?)[MyPropertyDescriptor]

'expression' @ [305:24] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.extractVariableInitializedByEmptyObject[ValueParameterDescriptorImpl]

'thenExpression' @ [305:35] ==> public final var JsConditional.thenExpression: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'thenExpr' @ [306:13] ==> val thenExpr: JsObjectLiteral defined in org.jetbrains.kotlin.js.dce.Analyzer.extractVariableInitializedByEmptyObject[LocalVariableDescriptor]

'propertyInitializers' @ [306:22] ==> public final val JsObjectLiteral.propertyInitializers: (MutableList<(JsPropertyInitializer..JsPropertyInitializer?)>..List<(JsPropertyInitializer..JsPropertyInitializer?)>?)[MyPropertyDescriptor]

'isNotEmpty' @ [306:43] ==> @InlineOnly public inline fun <T> Collection<(JsPropertyInitializer..JsPropertyInitializer?)>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.js.backend.ast.JsPropertyInitializer..org.jetbrains.kotlin.js.backend.ast.JsPropertyInitializer?)

'context' @ [308:24] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'extractNode' @ [308:32] ==> public final fun extractNode(expression: JsExpression): Context.Node? defined in org.jetbrains.kotlin.js.dce.Context[SimpleFunctionDescriptorImpl]

'expression' @ [308:44] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.extractVariableInitializedByEmptyObject[ValueParameterDescriptorImpl]

'elseExpression' @ [308:55] ==> public final var JsConditional.elseExpression: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'testExprNode' @ [310:13] ==> val testExprNode: Context.Node defined in org.jetbrains.kotlin.js.dce.Analyzer.extractVariableInitializedByEmptyObject[LocalVariableDescriptor]

'original' @ [310:26] ==> public final var original: Context.Node defined in org.jetbrains.kotlin.js.dce.Context.Node[PropertyDescriptorImpl]

'elseNode' @ [310:38] ==> val elseNode: Context.Node defined in org.jetbrains.kotlin.js.dce.Analyzer.extractVariableInitializedByEmptyObject[LocalVariableDescriptor]

'original' @ [310:47] ==> public final var original: Context.Node defined in org.jetbrains.kotlin.js.dce.Context.Node[PropertyDescriptorImpl]

'testExprNode' @ [311:16] ==> val testExprNode: Context.Node defined in org.jetbrains.kotlin.js.dce.Analyzer.extractVariableInitializedByEmptyObject[LocalVariableDescriptor]

'original' @ [311:29] ==> public final var original: Context.Node defined in org.jetbrains.kotlin.js.dce.Context.Node[PropertyDescriptorImpl]

'functionsToEnter' @ [319:9] ==> private final val functionsToEnter: MutableSet<JsFunction> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'function' @ [319:29] ==> value-parameter function: JsFunction defined in org.jetbrains.kotlin.js.dce.Analyzer.enterFunction[ValueParameterDescriptorImpl]

'context' @ [320:9] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'addNodesForLocalVars' @ [320:17] ==> public final fun addNodesForLocalVars(names: Collection<JsName>): Unit defined in org.jetbrains.kotlin.js.dce.Context[SimpleFunctionDescriptorImpl]

'function' @ [320:38] ==> value-parameter function: JsFunction defined in org.jetbrains.kotlin.js.dce.Analyzer.enterFunction[ValueParameterDescriptorImpl]

'collectLocalVariables' @ [320:47] ==> public fun JsFunction.collectLocalVariables(): Set<JsName> defined in org.jetbrains.kotlin.js.inline.util[DeserializedSimpleFunctionDescriptor]

'component1' @ [322:15] ==> public final operator fun component1(): (JsParameter..JsParameter?) defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [322:22] ==> public final operator fun component2(): JsExpression defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'function' @ [322:30] ==> value-parameter function: JsFunction defined in org.jetbrains.kotlin.js.dce.Analyzer.enterFunction[ValueParameterDescriptorImpl]

'parameters' @ [322:39] ==> public final val JsFunction.parameters: (MutableList<(JsParameter..JsParameter?)>..List<(JsParameter..JsParameter?)>)[MyPropertyDescriptor]

'zip' @ [322:50] ==> public infix fun <T, R> Iterable<(JsParameter..JsParameter?)>.zip(other: Iterable<JsExpression>): List<Pair<(JsParameter..JsParameter?), JsExpression>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.js.backend.ast.JsParameter..org.jetbrains.kotlin.js.backend.ast.JsParameter?)
    <R> -> JsExpression

'arguments' @ [322:54] ==> value-parameter arguments: List<JsExpression> defined in org.jetbrains.kotlin.js.dce.Analyzer.enterFunction[ValueParameterDescriptorImpl]

'if (arg is JsFunction && arg.name == null && isProperFunctionalParameter(arg.body, param)) {
                postponedFunctions[param.name] = arg
            }
            else {
                if (processAssignment(function, param.name.makeRef(), arg) != null) {
                    astNodesToSkip += arg
                }
            }' @ [323:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'arg' @ [323:17] ==> val arg: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.enterFunction[LocalVariableDescriptor]

'arg' @ [323:38] ==> val arg: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.enterFunction[LocalVariableDescriptor]

'name' @ [323:42] ==> public final var JsFunction.name: (JsName..JsName?)[MyPropertyDescriptor]

'isProperFunctionalParameter' @ [323:58] ==> private final fun isProperFunctionalParameter(body: JsStatement, parameter: JsParameter): Boolean defined in org.jetbrains.kotlin.js.dce.Analyzer[SimpleFunctionDescriptorImpl]

'arg' @ [323:86] ==> val arg: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.enterFunction[LocalVariableDescriptor]

'body' @ [323:90] ==> public final var JsFunction.body: JsBlock[MyPropertyDescriptor]

'param' @ [323:96] ==> val param: (JsParameter..JsParameter?) defined in org.jetbrains.kotlin.js.dce.Analyzer.enterFunction[LocalVariableDescriptor]

'postponedFunctions' @ [324:17] ==> private final val postponedFunctions: MutableMap<JsName, JsFunction> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'param' @ [324:36] ==> val param: (JsParameter..JsParameter?) defined in org.jetbrains.kotlin.js.dce.Analyzer.enterFunction[LocalVariableDescriptor]

'name' @ [324:42] ==> public final var JsParameter.name: JsName[MyPropertyDescriptor]

'arg' @ [324:50] ==> val arg: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.enterFunction[LocalVariableDescriptor]

'processAssignment' @ [327:21] ==> private final fun processAssignment(node: JsNode?, lhs: JsExpression, rhs: JsExpression): Context.Node? defined in org.jetbrains.kotlin.js.dce.Analyzer[SimpleFunctionDescriptorImpl]

'function' @ [327:39] ==> value-parameter function: JsFunction defined in org.jetbrains.kotlin.js.dce.Analyzer.enterFunction[ValueParameterDescriptorImpl]

'param' @ [327:49] ==> val param: (JsParameter..JsParameter?) defined in org.jetbrains.kotlin.js.dce.Analyzer.enterFunction[LocalVariableDescriptor]

'name' @ [327:55] ==> public final var JsParameter.name: JsName[MyPropertyDescriptor]

'makeRef' @ [327:60] ==> @NotNull public open fun makeRef(): JsNameRef defined in org.jetbrains.kotlin.js.backend.ast.JsName[JavaMethodDescriptor]

'arg' @ [327:71] ==> val arg: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.enterFunction[LocalVariableDescriptor]

'astNodesToSkip' @ [328:21] ==> private final val astNodesToSkip: MutableSet<JsNode> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'arg' @ [328:39] ==> val arg: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.enterFunction[LocalVariableDescriptor]

'processFunction' @ [333:9] ==> private final fun processFunction(function: JsFunction): Unit defined in org.jetbrains.kotlin.js.dce.Analyzer[SimpleFunctionDescriptorImpl]

'function' @ [333:25] ==> value-parameter function: JsFunction defined in org.jetbrains.kotlin.js.dce.Analyzer.enterFunction[ValueParameterDescriptorImpl]

'functionsToEnter' @ [337:9] ==> private final val functionsToEnter: MutableSet<JsFunction> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'function' @ [337:29] ==> value-parameter function: JsFunction defined in org.jetbrains.kotlin.js.dce.Analyzer.enterFunctionWithGivenNodes[ValueParameterDescriptorImpl]

'context' @ [338:9] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'addNodesForLocalVars' @ [338:17] ==> public final fun addNodesForLocalVars(names: Collection<JsName>): Unit defined in org.jetbrains.kotlin.js.dce.Context[SimpleFunctionDescriptorImpl]

'function' @ [338:38] ==> value-parameter function: JsFunction defined in org.jetbrains.kotlin.js.dce.Analyzer.enterFunctionWithGivenNodes[ValueParameterDescriptorImpl]

'collectLocalVariables' @ [338:47] ==> public fun JsFunction.collectLocalVariables(): Set<JsName> defined in org.jetbrains.kotlin.js.inline.util[DeserializedSimpleFunctionDescriptor]

'component1' @ [340:15] ==> public final operator fun component1(): (JsParameter..JsParameter?) defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [340:22] ==> public final operator fun component2(): Context.Node defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'function' @ [340:30] ==> value-parameter function: JsFunction defined in org.jetbrains.kotlin.js.dce.Analyzer.enterFunctionWithGivenNodes[ValueParameterDescriptorImpl]

'parameters' @ [340:39] ==> public final val JsFunction.parameters: (MutableList<(JsParameter..JsParameter?)>..List<(JsParameter..JsParameter?)>)[MyPropertyDescriptor]

'zip' @ [340:50] ==> public infix fun <T, R> Iterable<(JsParameter..JsParameter?)>.zip(other: Iterable<Context.Node>): List<Pair<(JsParameter..JsParameter?), Context.Node>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.js.backend.ast.JsParameter..org.jetbrains.kotlin.js.backend.ast.JsParameter?)
    <R> -> Node

'arguments' @ [340:54] ==> value-parameter arguments: List<Context.Node> defined in org.jetbrains.kotlin.js.dce.Analyzer.enterFunctionWithGivenNodes[ValueParameterDescriptorImpl]

'context' @ [341:29] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'nodes' @ [341:37] ==> public final val nodes: MutableMap<JsName, Context.Node> defined in org.jetbrains.kotlin.js.dce.Context[PropertyDescriptorImpl]

'param' @ [341:43] ==> val param: (JsParameter..JsParameter?) defined in org.jetbrains.kotlin.js.dce.Analyzer.enterFunctionWithGivenNodes[LocalVariableDescriptor]

'name' @ [341:49] ==> public final var JsParameter.name: JsName[MyPropertyDescriptor]

'paramNode' @ [342:13] ==> val paramNode: Context.Node defined in org.jetbrains.kotlin.js.dce.Analyzer.enterFunctionWithGivenNodes[LocalVariableDescriptor]

'alias' @ [342:23] ==> public final fun alias(other: Context.Node): Unit defined in org.jetbrains.kotlin.js.dce.Context.Node[SimpleFunctionDescriptorImpl]

'arg' @ [342:29] ==> val arg: Context.Node defined in org.jetbrains.kotlin.js.dce.Analyzer.enterFunctionWithGivenNodes[LocalVariableDescriptor]

'processFunction' @ [345:9] ==> private final fun processFunction(function: JsFunction): Unit defined in org.jetbrains.kotlin.js.dce.Analyzer[SimpleFunctionDescriptorImpl]

'function' @ [345:25] ==> value-parameter function: JsFunction defined in org.jetbrains.kotlin.js.dce.Analyzer.enterFunctionWithGivenNodes[ValueParameterDescriptorImpl]

'processedFunctions' @ [349:13] ==> private final val processedFunctions: MutableSet<JsFunction> defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'add' @ [349:32] ==> public abstract fun add(element: JsFunction): Boolean defined in kotlin.collections.MutableSet[DeserializedSimpleFunctionDescriptor]

'function' @ [349:36] ==> value-parameter function: JsFunction defined in org.jetbrains.kotlin.js.dce.Analyzer.processFunction[ValueParameterDescriptorImpl]

'accept' @ [350:13] ==> public open fun <T : JsNode?> accept(node: JsBlock): Unit defined in org.jetbrains.kotlin.js.dce.Analyzer[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : JsNode?> -> JsBlock

'function' @ [350:20] ==> value-parameter function: JsFunction defined in org.jetbrains.kotlin.js.dce.Analyzer.processFunction[ValueParameterDescriptorImpl]

'body' @ [350:29] ==> public final var JsFunction.body: JsBlock[MyPropertyDescriptor]

'body' @ [360:9] ==> value-parameter body: JsStatement defined in org.jetbrains.kotlin.js.dce.Analyzer.isProperFunctionalParameter[ValueParameterDescriptorImpl]

'accept' @ [360:14] ==> public abstract fun accept(p0: (JsVisitor..JsVisitor?)): Unit defined in org.jetbrains.kotlin.js.backend.ast.JsStatement[JavaMethodDescriptor]

'RecursiveJsVisitor' @ [360:30] ==> public constructor RecursiveJsVisitor() defined in org.jetbrains.kotlin.js.backend.ast.RecursiveJsVisitor[JavaClassConstructorDescriptor]

'invocation' @ [362:33] ==> value-parameter invocation: JsInvocation defined in org.jetbrains.kotlin.js.dce.Analyzer.isProperFunctionalParameter.<no name provided>.visitInvocation[ValueParameterDescriptorImpl]

'qualifier' @ [362:44] ==> public final var JsInvocation.qualifier: JsExpression[MyPropertyDescriptor]

'qualifier' @ [363:21] ==> val qualifier: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.isProperFunctionalParameter.<no name provided>.visitInvocation[LocalVariableDescriptor]

'qualifier' @ [363:47] ==> val qualifier: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.isProperFunctionalParameter.<no name provided>.visitInvocation[LocalVariableDescriptor]

'qualifier' @ [363:57] ==> public final var JsNameRef.qualifier: JsExpression?[MyPropertyDescriptor]

'qualifier' @ [363:78] ==> val qualifier: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.isProperFunctionalParameter.<no name provided>.visitInvocation[LocalVariableDescriptor]

'name' @ [363:88] ==> public final var JsNameRef.name: JsName?[MyPropertyDescriptor]

'parameter' @ [363:96] ==> value-parameter parameter: JsParameter defined in org.jetbrains.kotlin.js.dce.Analyzer.isProperFunctionalParameter[ValueParameterDescriptorImpl]

'name' @ [363:106] ==> public final var JsParameter.name: JsName[MyPropertyDescriptor]

'invocation' @ [364:25] ==> value-parameter invocation: JsInvocation defined in org.jetbrains.kotlin.js.dce.Analyzer.isProperFunctionalParameter.<no name provided>.visitInvocation[ValueParameterDescriptorImpl]

'arguments' @ [364:36] ==> public final val JsInvocation.arguments: (MutableList<(JsExpression..JsExpression?)>..List<(JsExpression..JsExpression?)>)[MyPropertyDescriptor]

'all' @ [364:46] ==> public inline fun <T> Iterable<(JsExpression..JsExpression?)>.all(predicate: ((JsExpression..JsExpression?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.js.backend.ast.JsExpression..org.jetbrains.kotlin.js.backend.ast.JsExpression?)

'context' @ [364:52] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'extractNode' @ [364:60] ==> public final fun extractNode(expression: JsExpression): Context.Node? defined in org.jetbrains.kotlin.js.dce.Context[SimpleFunctionDescriptorImpl]

'it' @ [364:72] ==> value-parameter it: (JsExpression..JsExpression?) defined in org.jetbrains.kotlin.js.dce.Analyzer.isProperFunctionalParameter.<no name provided>.visitInvocation.<anonymous>[ValueParameterDescriptorImpl]

'context' @ [368:21] ==> private final val context: Context defined in org.jetbrains.kotlin.js.dce.Analyzer[PropertyDescriptorImpl]

'isAmdDefine' @ [368:29] ==> public fun Context.isAmdDefine(function: JsExpression): Boolean defined in org.jetbrains.kotlin.js.dce in file util.kt[SimpleFunctionDescriptorImpl]

'qualifier' @ [368:41] ==> val qualifier: JsExpression defined in org.jetbrains.kotlin.js.dce.Analyzer.isProperFunctionalParameter.<no name provided>.visitInvocation[LocalVariableDescriptor]

'super' @ [369:17] ==> <this> defined in org.jetbrains.kotlin.js.dce.Analyzer.isProperFunctionalParameter.<no name provided>[LazyClassReceiverParameterDescriptor]

'visitInvocation' @ [369:23] ==> public open fun visitInvocation(invocation: JsInvocation): Unit defined in org.jetbrains.kotlin.js.backend.ast.RecursiveJsVisitor[DeserializedSimpleFunctionDescriptor]

'invocation' @ [369:39] ==> value-parameter invocation: JsInvocation defined in org.jetbrains.kotlin.js.dce.Analyzer.isProperFunctionalParameter.<no name provided>.visitInvocation[ValueParameterDescriptorImpl]

'nameRef' @ [373:21] ==> value-parameter nameRef: JsNameRef defined in org.jetbrains.kotlin.js.dce.Analyzer.isProperFunctionalParameter.<no name provided>.visitNameRef[ValueParameterDescriptorImpl]

'name' @ [373:29] ==> public final var JsNameRef.name: JsName?[MyPropertyDescriptor]

'parameter' @ [373:37] ==> value-parameter parameter: JsParameter defined in org.jetbrains.kotlin.js.dce.Analyzer.isProperFunctionalParameter[ValueParameterDescriptorImpl]

'name' @ [373:47] ==> public final var JsParameter.name: JsName[MyPropertyDescriptor]

'result' @ [374:21] ==> var result: Boolean defined in org.jetbrains.kotlin.js.dce.Analyzer.isProperFunctionalParameter[LocalVariableDescriptor]

'super' @ [376:17] ==> <this> defined in org.jetbrains.kotlin.js.dce.Analyzer.isProperFunctionalParameter.<no name provided>[LazyClassReceiverParameterDescriptor]

'visitNameRef' @ [376:23] ==> public open fun visitNameRef(nameRef: JsNameRef): Unit defined in org.jetbrains.kotlin.js.backend.ast.RecursiveJsVisitor[DeserializedSimpleFunctionDescriptor]

'nameRef' @ [376:36] ==> value-parameter nameRef: JsNameRef defined in org.jetbrains.kotlin.js.dce.Analyzer.isProperFunctionalParameter.<no name provided>.visitNameRef[ValueParameterDescriptorImpl]

'result' @ [379:16] ==> var result: Boolean defined in org.jetbrains.kotlin.js.dce.Analyzer.isProperFunctionalParameter[LocalVariableDescriptor]

