'JvmOverloads' @ [41:5] ==> public constructor JvmOverloads() defined in kotlin.jvm.JvmOverloads[DeserializedClassConstructorDescriptor]

'JvmStatic' @ [42:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'translateCall' @ [47:16] ==> private fun translateCall(context: TranslationContext, resolvedCall: ResolvedCall<out FunctionDescriptor>, explicitReceivers: ExplicitReceivers): JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator in file CallTranslator.kt[SimpleFunctionDescriptorImpl]

'context' @ [47:30] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.translate[ValueParameterDescriptorImpl]

'resolvedCall' @ [47:39] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.translate[ValueParameterDescriptorImpl]

'ExplicitReceivers' @ [47:53] ==> public constructor ExplicitReceivers(extensionOrDispatchReceiver: JsExpression?, extensionReceiver: JsExpression? = ...) defined in org.jetbrains.kotlin.js.translate.callTranslator.ExplicitReceivers[ClassConstructorDescriptorImpl]

'extensionOrDispatchReceiver' @ [47:71] ==> value-parameter extensionOrDispatchReceiver: JsExpression? = ... defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.translate[ValueParameterDescriptorImpl]

'source' @ [47:101] ==> public open fun source(p0: (Any..Any?)): (JsExpression..JsExpression?) defined in org.jetbrains.kotlin.js.backend.ast.JsExpression[JavaMethodDescriptor]

'resolvedCall' @ [47:108] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.translate[ValueParameterDescriptorImpl]

'call' @ [47:121] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out FunctionDescriptor>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out FunctionDescriptor)

'callElement' @ [47:126] ==> public final val Call.callElement: KtElement[MyPropertyDescriptor]

'VariableAccessInfo' @ [54:34] ==> public constructor VariableAccessInfo(callInfo: CallInfo, value: JsExpression? = ...) defined in org.jetbrains.kotlin.js.translate.callTranslator.VariableAccessInfo[ClassConstructorDescriptorImpl]

'context' @ [54:53] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.translateGet[ValueParameterDescriptorImpl]

'getCallInfo' @ [54:61] ==> public fun TranslationContext.getCallInfo(resolvedCall: ResolvedCall<out CallableDescriptor>, extensionOrDispatchReceiver: JsExpression?): CallInfo defined in org.jetbrains.kotlin.js.translate.callTranslator in file CallInfo.kt[SimpleFunctionDescriptorImpl]

'resolvedCall' @ [54:73] ==> value-parameter resolvedCall: ResolvedCall<out VariableDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.translateGet[ValueParameterDescriptorImpl]

'extensionOrDispatchReceiver' @ [54:87] ==> value-parameter extensionOrDispatchReceiver: JsExpression? = ... defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.translateGet[ValueParameterDescriptorImpl]

'variableAccessInfo' @ [55:16] ==> val variableAccessInfo: VariableAccessInfo defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.translateGet[LocalVariableDescriptor]

'translateVariableAccess' @ [55:35] ==> public fun VariableAccessInfo.translateVariableAccess(): JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator in file VariableCallCases.kt[SimpleFunctionDescriptorImpl]

'source' @ [55:61] ==> public open fun source(p0: (Any..Any?)): (JsExpression..JsExpression?) defined in org.jetbrains.kotlin.js.backend.ast.JsExpression[JavaMethodDescriptor]

'resolvedCall' @ [55:68] ==> value-parameter resolvedCall: ResolvedCall<out VariableDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.translateGet[ValueParameterDescriptorImpl]

'call' @ [55:81] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out VariableDescriptor>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out VariableDescriptor)

'callElement' @ [55:86] ==> public final val Call.callElement: KtElement[MyPropertyDescriptor]

'VariableAccessInfo' @ [63:34] ==> public constructor VariableAccessInfo(callInfo: CallInfo, value: JsExpression? = ...) defined in org.jetbrains.kotlin.js.translate.callTranslator.VariableAccessInfo[ClassConstructorDescriptorImpl]

'context' @ [63:53] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.translateSet[ValueParameterDescriptorImpl]

'getCallInfo' @ [63:61] ==> public fun TranslationContext.getCallInfo(resolvedCall: ResolvedCall<out CallableDescriptor>, extensionOrDispatchReceiver: JsExpression?): CallInfo defined in org.jetbrains.kotlin.js.translate.callTranslator in file CallInfo.kt[SimpleFunctionDescriptorImpl]

'resolvedCall' @ [63:73] ==> value-parameter resolvedCall: ResolvedCall<out VariableDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.translateSet[ValueParameterDescriptorImpl]

'extensionOrDispatchReceiver' @ [63:87] ==> value-parameter extensionOrDispatchReceiver: JsExpression? = ... defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.translateSet[ValueParameterDescriptorImpl]

'value' @ [63:117] ==> value-parameter value: JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.translateSet[ValueParameterDescriptorImpl]

'variableAccessInfo' @ [64:16] ==> val variableAccessInfo: VariableAccessInfo defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.translateSet[LocalVariableDescriptor]

'translateVariableAccess' @ [64:35] ==> public fun VariableAccessInfo.translateVariableAccess(): JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator in file VariableCallCases.kt[SimpleFunctionDescriptorImpl]

'source' @ [64:61] ==> public open fun source(p0: (Any..Any?)): (JsExpression..JsExpression?) defined in org.jetbrains.kotlin.js.backend.ast.JsExpression[JavaMethodDescriptor]

'resolvedCall' @ [64:68] ==> value-parameter resolvedCall: ResolvedCall<out VariableDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.translateSet[ValueParameterDescriptorImpl]

'call' @ [64:81] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out VariableDescriptor>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out VariableDescriptor)

'callElement' @ [64:86] ==> public final val Call.callElement: KtElement[MyPropertyDescriptor]

'CallArgumentTranslator' @ [72:29] ==> public companion object defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[FakeCallableDescriptorForObject]

'ArgumentsInfo' @ [72:52] ==> public constructor ArgumentsInfo(valueArguments: List<JsExpression>, hasSpreadOperator: Boolean, cachedReceiver: TemporaryConstVariable?, reifiedArguments: List<JsExpression> = ...) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.ArgumentsInfo[ClassConstructorDescriptorImpl]

'args' @ [72:66] ==> value-parameter args: List<JsExpression> defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.buildCall[ValueParameterDescriptorImpl]

'context' @ [73:28] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.buildCall[ValueParameterDescriptorImpl]

'getNameForDescriptor' @ [73:36] ==> @NotNull public open fun getNameForDescriptor(@NotNull descriptor: DeclarationDescriptor): JsName defined in org.jetbrains.kotlin.js.translate.context.TranslationContext[JavaMethodDescriptor]

'functionDescriptor' @ [73:57] ==> value-parameter functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.buildCall[ValueParameterDescriptorImpl]

'isNativeObject' @ [74:41] ==> public open fun isNativeObject(@NotNull p0: DeclarationDescriptor): Boolean defined in org.jetbrains.kotlin.js.translate.utils.AnnotationsUtils[JavaMethodDescriptor]

'functionDescriptor' @ [74:56] ==> value-parameter functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.buildCall[ValueParameterDescriptorImpl]

'if (dispatchReceiver != null) {
            DefaultFunctionCallCase.buildDefaultCallWithDispatchReceiver(argumentsInfo, dispatchReceiver, functionName, isNative,
                                                                         hasSpreadOperator)
        } else {
            DefaultFunctionCallCase.buildDefaultCallWithoutReceiver(context, argumentsInfo, functionDescriptor, isNative, hasSpreadOperator)
        }' @ [76:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: JsExpression, elseBranch: JsExpression): JsExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> JsExpression

'dispatchReceiver' @ [76:20] ==> value-parameter dispatchReceiver: JsExpression? defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.buildCall[ValueParameterDescriptorImpl]

'buildDefaultCallWithDispatchReceiver' @ [77:37] ==> public final fun buildDefaultCallWithDispatchReceiver(argumentsInfo: CallArgumentTranslator.ArgumentsInfo, dispatchReceiver: JsExpression, functionName: JsName, isNative: Boolean, hasSpreadOperator: Boolean): JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator.DefaultFunctionCallCase[SimpleFunctionDescriptorImpl]

'argumentsInfo' @ [77:74] ==> val argumentsInfo: CallArgumentTranslator.ArgumentsInfo defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.buildCall[LocalVariableDescriptor]

'dispatchReceiver' @ [77:89] ==> value-parameter dispatchReceiver: JsExpression? defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.buildCall[ValueParameterDescriptorImpl]

'functionName' @ [77:107] ==> val functionName: JsName defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.buildCall[LocalVariableDescriptor]

'isNative' @ [77:121] ==> val isNative: Boolean defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.buildCall[LocalVariableDescriptor]

'hasSpreadOperator' @ [78:74] ==> val hasSpreadOperator: Boolean defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.buildCall[LocalVariableDescriptor]

'buildDefaultCallWithoutReceiver' @ [80:37] ==> public final fun buildDefaultCallWithoutReceiver(context: TranslationContext, argumentsInfo: CallArgumentTranslator.ArgumentsInfo, callableDescriptor: CallableDescriptor, isNative: Boolean, hasSpreadOperator: Boolean): JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator.DefaultFunctionCallCase[SimpleFunctionDescriptorImpl]

'context' @ [80:69] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.buildCall[ValueParameterDescriptorImpl]

'argumentsInfo' @ [80:78] ==> val argumentsInfo: CallArgumentTranslator.ArgumentsInfo defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.buildCall[LocalVariableDescriptor]

'functionDescriptor' @ [80:93] ==> value-parameter functionDescriptor: FunctionDescriptor defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.buildCall[ValueParameterDescriptorImpl]

'isNative' @ [80:113] ==> val isNative: Boolean defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.buildCall[LocalVariableDescriptor]

'hasSpreadOperator' @ [80:123] ==> val hasSpreadOperator: Boolean defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator.buildCall[LocalVariableDescriptor]

'this' @ [86:12] ==> <this> defined in org.jetbrains.kotlin.js.translate.callTranslator.expectedReceivers[ReceiverParameterDescriptorImpl]

'explicitReceiverKind' @ [86:17] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.explicitReceiverKind: ExplicitReceiverKind[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out CallableDescriptor)

'NO_EXPLICIT_RECEIVER' @ [86:41] ==> enum entry NO_EXPLICIT_RECEIVER defined in org.jetbrains.kotlin.resolve.calls.tasks.ExplicitReceiverKind[FakeCallableDescriptorForObject]

'resolvedCall' @ [94:9] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'assert' @ [95:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'explicitReceivers' @ [95:16] ==> value-parameter explicitReceivers: ExplicitReceivers defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'extensionReceiver' @ [95:34] ==> public final val extensionReceiver: JsExpression? defined in org.jetbrains.kotlin.js.translate.callTranslator.ExplicitReceivers[PropertyDescriptorImpl]

'resolvedCall' @ [96:28] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'variableCall' @ [96:41] ==> public abstract val variableCall: ResolvedCall<VariableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.model.VariableAsFunctionResolvedCall[DeserializedPropertyDescriptor]

'if (variableCall.expectedReceivers()) {
            val newReceiver = CallTranslator.translateGet(context, variableCall, explicitReceivers.extensionOrDispatchReceiver)
            translateFunctionCall(context, resolvedCall.functionCall, resolvedCall.variableCall, ExplicitReceivers(newReceiver))
        } else {
            val dispatchReceiver = CallTranslator.translateGet(context, variableCall, null)
            val isFunctionType = resolvedCall.variableCall.resultingDescriptor.type.isFunctionTypeOrSubtype
            val inlineCall = if (isFunctionType) resolvedCall.variableCall else resolvedCall
            if (explicitReceivers.extensionOrDispatchReceiver == null) {
                translateFunctionCall(context, resolvedCall.functionCall, inlineCall, ExplicitReceivers(dispatchReceiver))
            }
            else {
                translateFunctionCall(context, resolvedCall.functionCall, inlineCall,
                                      ExplicitReceivers(dispatchReceiver, explicitReceivers.extensionOrDispatchReceiver))
            }
        }' @ [98:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: JsExpression, elseBranch: JsExpression): JsExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> JsExpression

'variableCall' @ [98:20] ==> val variableCall: ResolvedCall<VariableDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[LocalVariableDescriptor]

'expectedReceivers' @ [98:33] ==> private fun ResolvedCall<out CallableDescriptor>.expectedReceivers(): Boolean defined in org.jetbrains.kotlin.js.translate.callTranslator in file CallTranslator.kt[SimpleFunctionDescriptorImpl]

'CallTranslator' @ [99:31] ==> public object CallTranslator defined in org.jetbrains.kotlin.js.translate.callTranslator in file CallTranslator.kt[FakeCallableDescriptorForObject]

'translateGet' @ [99:46] ==> public final fun translateGet(context: TranslationContext, resolvedCall: ResolvedCall<out VariableDescriptor>, extensionOrDispatchReceiver: JsExpression? = ...): JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator[SimpleFunctionDescriptorImpl]

'context' @ [99:59] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'variableCall' @ [99:68] ==> val variableCall: ResolvedCall<VariableDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[LocalVariableDescriptor]

'explicitReceivers' @ [99:82] ==> value-parameter explicitReceivers: ExplicitReceivers defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'extensionOrDispatchReceiver' @ [99:100] ==> public final val extensionOrDispatchReceiver: JsExpression? defined in org.jetbrains.kotlin.js.translate.callTranslator.ExplicitReceivers[PropertyDescriptorImpl]

'translateFunctionCall' @ [100:13] ==> private fun translateFunctionCall(context: TranslationContext, resolvedCall: ResolvedCall<out FunctionDescriptor>, inlineResolvedCall: ResolvedCall<out CallableDescriptor>, explicitReceivers: ExplicitReceivers): JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator in file CallTranslator.kt[SimpleFunctionDescriptorImpl]

'context' @ [100:35] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'resolvedCall' @ [100:44] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'functionCall' @ [100:57] ==> public abstract val functionCall: ResolvedCall<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.calls.model.VariableAsFunctionResolvedCall[DeserializedPropertyDescriptor]

'resolvedCall' @ [100:71] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'variableCall' @ [100:84] ==> public abstract val variableCall: ResolvedCall<VariableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.model.VariableAsFunctionResolvedCall[DeserializedPropertyDescriptor]

'ExplicitReceivers' @ [100:98] ==> public constructor ExplicitReceivers(extensionOrDispatchReceiver: JsExpression?, extensionReceiver: JsExpression? = ...) defined in org.jetbrains.kotlin.js.translate.callTranslator.ExplicitReceivers[ClassConstructorDescriptorImpl]

'newReceiver' @ [100:116] ==> val newReceiver: JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[LocalVariableDescriptor]

'CallTranslator' @ [102:36] ==> public object CallTranslator defined in org.jetbrains.kotlin.js.translate.callTranslator in file CallTranslator.kt[FakeCallableDescriptorForObject]

'translateGet' @ [102:51] ==> public final fun translateGet(context: TranslationContext, resolvedCall: ResolvedCall<out VariableDescriptor>, extensionOrDispatchReceiver: JsExpression? = ...): JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator.CallTranslator[SimpleFunctionDescriptorImpl]

'context' @ [102:64] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'variableCall' @ [102:73] ==> val variableCall: ResolvedCall<VariableDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[LocalVariableDescriptor]

'resolvedCall' @ [103:34] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'variableCall' @ [103:47] ==> public abstract val variableCall: ResolvedCall<VariableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.model.VariableAsFunctionResolvedCall[DeserializedPropertyDescriptor]

'resultingDescriptor' @ [103:60] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<VariableDescriptor>.resultingDescriptor: VariableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> VariableDescriptor

'type' @ [103:80] ==> public final val VariableDescriptor.type: KotlinType[MyPropertyDescriptor]

'isFunctionTypeOrSubtype' @ [103:85] ==> public val KotlinType.isFunctionTypeOrSubtype: Boolean defined in org.jetbrains.kotlin.builtins[DeserializedPropertyDescriptor]

'if (isFunctionType) resolvedCall.variableCall else resolvedCall' @ [104:30] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: ResolvedCall<out CallableDescriptor>, elseBranch: ResolvedCall<out CallableDescriptor>): ResolvedCall<out CallableDescriptor>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> ResolvedCall<out CallableDescriptor>

'isFunctionType' @ [104:34] ==> val isFunctionType: Boolean defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[LocalVariableDescriptor]

'resolvedCall' @ [104:50] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'variableCall' @ [104:63] ==> public abstract val variableCall: ResolvedCall<VariableDescriptor> defined in org.jetbrains.kotlin.resolve.calls.model.VariableAsFunctionResolvedCall[DeserializedPropertyDescriptor]

'resolvedCall' @ [104:81] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'if (explicitReceivers.extensionOrDispatchReceiver == null) {
                translateFunctionCall(context, resolvedCall.functionCall, inlineCall, ExplicitReceivers(dispatchReceiver))
            }
            else {
                translateFunctionCall(context, resolvedCall.functionCall, inlineCall,
                                      ExplicitReceivers(dispatchReceiver, explicitReceivers.extensionOrDispatchReceiver))
            }' @ [105:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: JsExpression, elseBranch: JsExpression): JsExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> JsExpression

'explicitReceivers' @ [105:17] ==> value-parameter explicitReceivers: ExplicitReceivers defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'extensionOrDispatchReceiver' @ [105:35] ==> public final val extensionOrDispatchReceiver: JsExpression? defined in org.jetbrains.kotlin.js.translate.callTranslator.ExplicitReceivers[PropertyDescriptorImpl]

'translateFunctionCall' @ [106:17] ==> private fun translateFunctionCall(context: TranslationContext, resolvedCall: ResolvedCall<out FunctionDescriptor>, inlineResolvedCall: ResolvedCall<out CallableDescriptor>, explicitReceivers: ExplicitReceivers): JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator in file CallTranslator.kt[SimpleFunctionDescriptorImpl]

'context' @ [106:39] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'resolvedCall' @ [106:48] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'functionCall' @ [106:61] ==> public abstract val functionCall: ResolvedCall<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.calls.model.VariableAsFunctionResolvedCall[DeserializedPropertyDescriptor]

'inlineCall' @ [106:75] ==> val inlineCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[LocalVariableDescriptor]

'ExplicitReceivers' @ [106:87] ==> public constructor ExplicitReceivers(extensionOrDispatchReceiver: JsExpression?, extensionReceiver: JsExpression? = ...) defined in org.jetbrains.kotlin.js.translate.callTranslator.ExplicitReceivers[ClassConstructorDescriptorImpl]

'dispatchReceiver' @ [106:105] ==> val dispatchReceiver: JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[LocalVariableDescriptor]

'translateFunctionCall' @ [109:17] ==> private fun translateFunctionCall(context: TranslationContext, resolvedCall: ResolvedCall<out FunctionDescriptor>, inlineResolvedCall: ResolvedCall<out CallableDescriptor>, explicitReceivers: ExplicitReceivers): JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator in file CallTranslator.kt[SimpleFunctionDescriptorImpl]

'context' @ [109:39] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'resolvedCall' @ [109:48] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'functionCall' @ [109:61] ==> public abstract val functionCall: ResolvedCall<FunctionDescriptor> defined in org.jetbrains.kotlin.resolve.calls.model.VariableAsFunctionResolvedCall[DeserializedPropertyDescriptor]

'inlineCall' @ [109:75] ==> val inlineCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[LocalVariableDescriptor]

'ExplicitReceivers' @ [110:39] ==> public constructor ExplicitReceivers(extensionOrDispatchReceiver: JsExpression?, extensionReceiver: JsExpression? = ...) defined in org.jetbrains.kotlin.js.translate.callTranslator.ExplicitReceivers[ClassConstructorDescriptorImpl]

'dispatchReceiver' @ [110:57] ==> val dispatchReceiver: JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[LocalVariableDescriptor]

'explicitReceivers' @ [110:75] ==> value-parameter explicitReceivers: ExplicitReceivers defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'extensionOrDispatchReceiver' @ [110:93] ==> public final val extensionOrDispatchReceiver: JsExpression? defined in org.jetbrains.kotlin.js.translate.callTranslator.ExplicitReceivers[PropertyDescriptorImpl]

'resolvedCall' @ [115:16] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'call' @ [115:29] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out FunctionDescriptor>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out FunctionDescriptor)

'call' @ [116:9] ==> val call: Call defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[LocalVariableDescriptor]

'callType' @ [116:14] ==> public final val Call.callType: Call.CallType[MyPropertyDescriptor]

'INVOKE' @ [116:35] ==> enum entry INVOKE defined in org.jetbrains.kotlin.psi.Call.CallType[FakeCallableDescriptorForObject]

'!' @ [116:45] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isInvokeCallOnVariable' @ [116:46] ==> public fun isInvokeCallOnVariable(call: Call): Boolean defined in org.jetbrains.kotlin.resolve.calls.callResolverUtil[DeserializedSimpleFunctionDescriptor]

'call' @ [116:69] ==> val call: Call defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[LocalVariableDescriptor]

'computeExplicitReceiversForInvoke' @ [117:42] ==> public fun computeExplicitReceiversForInvoke(context: TranslationContext, resolvedCall: ResolvedCall<out FunctionDescriptor>, explicitReceivers: ExplicitReceivers): ExplicitReceivers defined in org.jetbrains.kotlin.js.translate.callTranslator in file CallTranslator.kt[SimpleFunctionDescriptorImpl]

'context' @ [117:76] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'resolvedCall' @ [117:85] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'explicitReceivers' @ [117:99] ==> value-parameter explicitReceivers: ExplicitReceivers defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'translateFunctionCall' @ [118:16] ==> private fun translateFunctionCall(context: TranslationContext, resolvedCall: ResolvedCall<out FunctionDescriptor>, inlineResolvedCall: ResolvedCall<out CallableDescriptor>, explicitReceivers: ExplicitReceivers): JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator in file CallTranslator.kt[SimpleFunctionDescriptorImpl]

'context' @ [118:38] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'resolvedCall' @ [118:47] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'resolvedCall' @ [118:61] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'explicitReceiversForInvoke' @ [118:75] ==> val explicitReceiversForInvoke: ExplicitReceivers defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[LocalVariableDescriptor]

'translateFunctionCall' @ [121:12] ==> private fun translateFunctionCall(context: TranslationContext, resolvedCall: ResolvedCall<out FunctionDescriptor>, inlineResolvedCall: ResolvedCall<out CallableDescriptor>, explicitReceivers: ExplicitReceivers): JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator in file CallTranslator.kt[SimpleFunctionDescriptorImpl]

'context' @ [121:34] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'resolvedCall' @ [121:43] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'resolvedCall' @ [121:57] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'explicitReceivers' @ [121:71] ==> value-parameter explicitReceivers: ExplicitReceivers defined in org.jetbrains.kotlin.js.translate.callTranslator.translateCall[ValueParameterDescriptorImpl]

'context' @ [130:26] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.callTranslator.translateFunctionCall[ValueParameterDescriptorImpl]

'getCallInfo' @ [130:34] ==> public fun TranslationContext.getCallInfo(resolvedCall: ResolvedCall<out FunctionDescriptor>, explicitReceivers: ExplicitReceivers): FunctionCallInfo defined in org.jetbrains.kotlin.js.translate.callTranslator in file CallInfo.kt[SimpleFunctionDescriptorImpl]

'resolvedCall' @ [130:46] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateFunctionCall[ValueParameterDescriptorImpl]

'explicitReceivers' @ [130:60] ==> value-parameter explicitReceivers: ExplicitReceivers defined in org.jetbrains.kotlin.js.translate.callTranslator.translateFunctionCall[ValueParameterDescriptorImpl]

'translateFunctionCall' @ [130:79] ==> public fun FunctionCallInfo.translateFunctionCall(): JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator in file FunctionCallCases.kt[SimpleFunctionDescriptorImpl]

'shouldBeInlined' @ [132:34] ==> public open fun shouldBeInlined(@NotNull descriptor: CallableDescriptor, @NotNull context: TranslationContext): Boolean defined in org.jetbrains.kotlin.js.translate.reference.CallExpressionTranslator[JavaMethodDescriptor]

'inlineResolvedCall' @ [132:50] ==> value-parameter inlineResolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateFunctionCall[ValueParameterDescriptorImpl]

'resultingDescriptor' @ [132:69] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.resultingDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out CallableDescriptor)

'context' @ [132:90] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.callTranslator.translateFunctionCall[ValueParameterDescriptorImpl]

'setInlineCallMetadata' @ [133:9] ==> public fun setInlineCallMetadata(expression: JsExpression, psiElement: KtExpression, descriptor: CallableDescriptor, context: TranslationContext): Unit defined in org.jetbrains.kotlin.js.translate.utils in file inlineUtils.kt[SimpleFunctionDescriptorImpl]

'callExpression' @ [133:31] ==> val callExpression: JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator.translateFunctionCall[LocalVariableDescriptor]

'resolvedCall' @ [133:47] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateFunctionCall[ValueParameterDescriptorImpl]

'call' @ [133:60] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out FunctionDescriptor>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out FunctionDescriptor)

'callElement' @ [133:65] ==> public final val Call.callElement: KtElement[MyPropertyDescriptor]

'inlineResolvedCall' @ [134:31] ==> value-parameter inlineResolvedCall: ResolvedCall<out CallableDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateFunctionCall[ValueParameterDescriptorImpl]

'resultingDescriptor' @ [134:50] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out CallableDescriptor>.resultingDescriptor: CallableDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out CallableDescriptor)

'context' @ [134:71] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.callTranslator.translateFunctionCall[ValueParameterDescriptorImpl]

'resolvedCall' @ [137:9] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateFunctionCall[ValueParameterDescriptorImpl]

'resultingDescriptor' @ [137:22] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out FunctionDescriptor>.resultingDescriptor: FunctionDescriptor[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out FunctionDescriptor)

'isSuspend' @ [137:42] ==> public final val FunctionDescriptor.isSuspend: Boolean[MyPropertyDescriptor]

'if (context.isInStateMachine) {
            context.currentBlock.statements += JsAstUtils.asSyntheticStatement(callExpression.apply {
                isSuspend = true
                source = resolvedCall.call.callElement
            })
            val coroutineRef = TranslationUtils.translateContinuationArgument(context).apply { source = resolvedCall.call.callElement }
            return context.defineTemporary(JsNameRef("\$\$coroutineResult\$\$", coroutineRef).apply {
                sideEffects = SideEffectKind.DEPENDS_ON_STATE
                source = resolvedCall.call.callElement
                coroutineResult = true
            })
        }
        else {
            callExpression.isTailCallSuspend = true
        }' @ [138:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'context' @ [138:13] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.callTranslator.translateFunctionCall[ValueParameterDescriptorImpl]

'isInStateMachine' @ [138:21] ==> private val TranslationContext.isInStateMachine: Boolean defined in org.jetbrains.kotlin.js.translate.callTranslator in file CallTranslator.kt[PropertyDescriptorImpl]

'context' @ [139:13] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.callTranslator.translateFunctionCall[ValueParameterDescriptorImpl]

'currentBlock' @ [139:21] ==> public final val TranslationContext.currentBlock: JsBlock[MyPropertyDescriptor]

'statements' @ [139:34] ==> public final val JsBlock.statements: (MutableList<(JsStatement..JsStatement?)>..List<(JsStatement..JsStatement?)>)[MyPropertyDescriptor]

'asSyntheticStatement' @ [139:59] ==> public open fun asSyntheticStatement(@NotNull expression: JsExpression): (JsStatement..JsStatement?) defined in org.jetbrains.kotlin.js.translate.utils.JsAstUtils[JavaMethodDescriptor]

'callExpression' @ [139:80] ==> val callExpression: JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator.translateFunctionCall[LocalVariableDescriptor]

'apply' @ [139:95] ==> @InlineOnly public inline fun <T> JsExpression.apply(block: JsExpression.() -> Unit): JsExpression defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsExpression

'isSuspend' @ [140:17] ==> public var JsExpression.isSuspend: Boolean defined in org.jetbrains.kotlin.js.backend.ast.metadata[DeserializedPropertyDescriptor]

'source' @ [141:17] ==> public final var JsExpression.source: (Any..Any?)[MyPropertyDescriptor]

'resolvedCall' @ [141:26] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateFunctionCall[ValueParameterDescriptorImpl]

'call' @ [141:39] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out FunctionDescriptor>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out FunctionDescriptor)

'callElement' @ [141:44] ==> public final val Call.callElement: KtElement[MyPropertyDescriptor]

'translateContinuationArgument' @ [143:49] ==> @NotNull public open fun translateContinuationArgument(@NotNull context: TranslationContext): JsExpression defined in org.jetbrains.kotlin.js.translate.utils.TranslationUtils[JavaMethodDescriptor]

'context' @ [143:79] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.callTranslator.translateFunctionCall[ValueParameterDescriptorImpl]

'apply' @ [143:88] ==> @InlineOnly public inline fun <T> JsExpression.apply(block: (JsExpression).() -> Unit): JsExpression defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsExpression

'source' @ [143:96] ==> public final var JsExpression.source: (Any..Any?)[MyPropertyDescriptor]

'resolvedCall' @ [143:105] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateFunctionCall[ValueParameterDescriptorImpl]

'call' @ [143:118] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out FunctionDescriptor>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out FunctionDescriptor)

'callElement' @ [143:123] ==> public final val Call.callElement: KtElement[MyPropertyDescriptor]

'context' @ [144:20] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.callTranslator.translateFunctionCall[ValueParameterDescriptorImpl]

'defineTemporary' @ [144:28] ==> @NotNull public open fun defineTemporary(@NotNull initExpression: JsExpression): JsExpression defined in org.jetbrains.kotlin.js.translate.context.TranslationContext[JavaMethodDescriptor]

'JsNameRef' @ [144:44] ==> public constructor JsNameRef(@NotNull p0: String, p1: (JsExpression..JsExpression?)) defined in org.jetbrains.kotlin.js.backend.ast.JsNameRef[JavaClassConstructorDescriptor]

'coroutineRef' @ [144:81] ==> val coroutineRef: JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator.translateFunctionCall[LocalVariableDescriptor]

'apply' @ [144:95] ==> @InlineOnly public inline fun <T> JsNameRef.apply(block: JsNameRef.() -> Unit): JsNameRef defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsNameRef

'sideEffects' @ [145:17] ==> public var HasMetadata.sideEffects: SideEffectKind defined in org.jetbrains.kotlin.js.backend.ast.metadata[DeserializedPropertyDescriptor]

'DEPENDS_ON_STATE' @ [145:46] ==> enum entry DEPENDS_ON_STATE defined in org.jetbrains.kotlin.js.backend.ast.metadata.SideEffectKind[FakeCallableDescriptorForObject]

'source' @ [146:17] ==> public final var JsNameRef.source: (Any..Any?)[MyPropertyDescriptor]

'resolvedCall' @ [146:26] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.translateFunctionCall[ValueParameterDescriptorImpl]

'call' @ [146:39] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out FunctionDescriptor>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out FunctionDescriptor)

'callElement' @ [146:44] ==> public final val Call.callElement: KtElement[MyPropertyDescriptor]

'coroutineResult' @ [147:17] ==> public var JsNameRef.coroutineResult: Boolean defined in org.jetbrains.kotlin.js.backend.ast.metadata[DeserializedPropertyDescriptor]

'callExpression' @ [151:13] ==> val callExpression: JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator.translateFunctionCall[LocalVariableDescriptor]

'isTailCallSuspend' @ [151:28] ==> public var JsExpression.isTailCallSuspend: Boolean defined in org.jetbrains.kotlin.js.backend.ast.metadata[DeserializedPropertyDescriptor]

'callExpression' @ [154:12] ==> val callExpression: JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator.translateFunctionCall[LocalVariableDescriptor]

'==' @ [158:13] ==> public open fun equals(other: Any?): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'declarationDescriptor' @ [158:14] ==> public final val TranslationContext.declarationDescriptor: DeclarationDescriptor?[MyPropertyDescriptor]

'requiresStateMachineTransformation' @ [158:61] ==> public fun FunctionDescriptor.requiresStateMachineTransformation(context: TranslationContext): Boolean defined in org.jetbrains.kotlin.js.translate.utils in file utils.kt[SimpleFunctionDescriptorImpl]

'this' @ [158:96] ==> <this> defined in org.jetbrains.kotlin.js.translate.callTranslator.isInStateMachine[ReceiverParameterDescriptorImpl]

'resolvedCall' @ [165:23] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[ValueParameterDescriptorImpl]

'call' @ [165:36] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out FunctionDescriptor>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out FunctionDescriptor)

'callElement' @ [165:41] ==> public final val Call.callElement: KtElement[MyPropertyDescriptor]

'assert' @ [166:5] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'explicitReceivers' @ [166:12] ==> value-parameter explicitReceivers: ExplicitReceivers defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[ValueParameterDescriptorImpl]

'extensionReceiver' @ [166:30] ==> public final val extensionReceiver: JsExpression? defined in org.jetbrains.kotlin.js.translate.callTranslator.ExplicitReceivers[PropertyDescriptorImpl]

'callElement' @ [166:99] ==> val callElement: KtElement defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[LocalVariableDescriptor]

'receiver' @ [169:14] ==> value-parameter receiver: ReceiverValue? defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke.translateReceiverAsExpression[ValueParameterDescriptorImpl]

'let' @ [169:48] ==> @InlineOnly public inline fun <T, R> ExpressionReceiver.let(block: (ExpressionReceiver) -> JsExpression): JsExpression defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpressionReceiver
    <R> -> JsExpression

'translateAsExpression' @ [169:66] ==> @NotNull public open fun translateAsExpression(@NotNull expression: KtExpression, @NotNull context: TranslationContext): JsExpression defined in org.jetbrains.kotlin.js.translate.general.Translation[JavaMethodDescriptor]

'it' @ [169:88] ==> value-parameter it: ExpressionReceiver defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke.translateReceiverAsExpression.<anonymous>[ValueParameterDescriptorImpl]

'expression' @ [169:91] ==> public abstract val expression: KtExpression defined in org.jetbrains.kotlin.resolve.scopes.receivers.ExpressionReceiver[DeserializedPropertyDescriptor]

'context' @ [169:103] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[ValueParameterDescriptorImpl]

'resolvedCall' @ [171:28] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[ValueParameterDescriptorImpl]

'dispatchReceiver' @ [171:41] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out FunctionDescriptor>.dispatchReceiver: ReceiverValue?[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out FunctionDescriptor)

'resolvedCall' @ [172:29] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[ValueParameterDescriptorImpl]

'extensionReceiver' @ [172:42] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out FunctionDescriptor>.extensionReceiver: ReceiverValue?[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out FunctionDescriptor)

'if (dispatchReceiver != null && extensionReceiver != null && resolvedCall.explicitReceiverKind == BOTH_RECEIVERS) {
        assert(explicitReceivers.extensionOrDispatchReceiver != null) {
            "No explicit receiver for 'invoke' resolved call with both receivers: $callElement, text: ${callElement.text}" +
            "Dispatch receiver: $dispatchReceiver Extension receiver: $extensionReceiver"
        }
    }
    else {
        assert(explicitReceivers.extensionOrDispatchReceiver == null) {
            "Non trivial explicit receiver ${explicitReceivers.extensionOrDispatchReceiver}\n" +
            "for 'invoke' resolved call: $callElement, text: ${callElement.text}\n" +
            "Dispatch receiver: $dispatchReceiver Extension receiver: $extensionReceiver"
        }
    }' @ [174:5] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'dispatchReceiver' @ [174:9] ==> val dispatchReceiver: ReceiverValue? defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[LocalVariableDescriptor]

'extensionReceiver' @ [174:37] ==> val extensionReceiver: ReceiverValue? defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[LocalVariableDescriptor]

'resolvedCall' @ [174:66] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[ValueParameterDescriptorImpl]

'explicitReceiverKind' @ [174:79] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out FunctionDescriptor>.explicitReceiverKind: ExplicitReceiverKind[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out FunctionDescriptor)

'BOTH_RECEIVERS' @ [174:103] ==> enum entry BOTH_RECEIVERS defined in org.jetbrains.kotlin.resolve.calls.tasks.ExplicitReceiverKind[FakeCallableDescriptorForObject]

'assert' @ [175:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'explicitReceivers' @ [175:16] ==> value-parameter explicitReceivers: ExplicitReceivers defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[ValueParameterDescriptorImpl]

'extensionOrDispatchReceiver' @ [175:34] ==> public final val extensionOrDispatchReceiver: JsExpression? defined in org.jetbrains.kotlin.js.translate.callTranslator.ExplicitReceivers[PropertyDescriptorImpl]

'+' @ [176:13] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'callElement' @ [176:84] ==> val callElement: KtElement defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[LocalVariableDescriptor]

'callElement' @ [176:105] ==> val callElement: KtElement defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[LocalVariableDescriptor]

'text' @ [176:117] ==> public final val KtElement.text: (String..String?)[MyPropertyDescriptor]

'dispatchReceiver' @ [177:34] ==> val dispatchReceiver: ReceiverValue? defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[LocalVariableDescriptor]

'extensionReceiver' @ [177:72] ==> val extensionReceiver: ReceiverValue? defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[LocalVariableDescriptor]

'assert' @ [181:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'explicitReceivers' @ [181:16] ==> value-parameter explicitReceivers: ExplicitReceivers defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[ValueParameterDescriptorImpl]

'extensionOrDispatchReceiver' @ [181:34] ==> public final val extensionOrDispatchReceiver: JsExpression? defined in org.jetbrains.kotlin.js.translate.callTranslator.ExplicitReceivers[PropertyDescriptorImpl]

'+' @ [182:13] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'explicitReceivers' @ [182:46] ==> value-parameter explicitReceivers: ExplicitReceivers defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[ValueParameterDescriptorImpl]

'extensionOrDispatchReceiver' @ [182:64] ==> public final val extensionOrDispatchReceiver: JsExpression? defined in org.jetbrains.kotlin.js.translate.callTranslator.ExplicitReceivers[PropertyDescriptorImpl]

'callElement' @ [183:43] ==> val callElement: KtElement defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[LocalVariableDescriptor]

'callElement' @ [183:64] ==> val callElement: KtElement defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[LocalVariableDescriptor]

'text' @ [183:76] ==> public final val KtElement.text: (String..String?)[MyPropertyDescriptor]

'dispatchReceiver' @ [184:34] ==> val dispatchReceiver: ReceiverValue? defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[LocalVariableDescriptor]

'extensionReceiver' @ [184:72] ==> val extensionReceiver: ReceiverValue? defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[LocalVariableDescriptor]

'when (resolvedCall.explicitReceiverKind) {
        NO_EXPLICIT_RECEIVER -> ExplicitReceivers(null)
        DISPATCH_RECEIVER -> ExplicitReceivers(translateReceiverAsExpression(dispatchReceiver))
        EXTENSION_RECEIVER -> ExplicitReceivers(translateReceiverAsExpression(extensionReceiver))
        BOTH_RECEIVERS -> ExplicitReceivers(translateReceiverAsExpression(dispatchReceiver),
                                            translateReceiverAsExpression(extensionReceiver))
    }' @ [188:12] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: ExplicitReceivers, entry1: ExplicitReceivers, entry2: ExplicitReceivers, entry3: ExplicitReceivers): ExplicitReceivers[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> ExplicitReceivers

'resolvedCall' @ [188:18] ==> value-parameter resolvedCall: ResolvedCall<out FunctionDescriptor> defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[ValueParameterDescriptorImpl]

'explicitReceiverKind' @ [188:31] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out FunctionDescriptor>.explicitReceiverKind: ExplicitReceiverKind[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(out FunctionDescriptor)

'NO_EXPLICIT_RECEIVER' @ [189:9] ==> enum entry NO_EXPLICIT_RECEIVER defined in org.jetbrains.kotlin.resolve.calls.tasks.ExplicitReceiverKind[FakeCallableDescriptorForObject]

'ExplicitReceivers' @ [189:33] ==> public constructor ExplicitReceivers(extensionOrDispatchReceiver: JsExpression?, extensionReceiver: JsExpression? = ...) defined in org.jetbrains.kotlin.js.translate.callTranslator.ExplicitReceivers[ClassConstructorDescriptorImpl]

'DISPATCH_RECEIVER' @ [190:9] ==> enum entry DISPATCH_RECEIVER defined in org.jetbrains.kotlin.resolve.calls.tasks.ExplicitReceiverKind[FakeCallableDescriptorForObject]

'ExplicitReceivers' @ [190:30] ==> public constructor ExplicitReceivers(extensionOrDispatchReceiver: JsExpression?, extensionReceiver: JsExpression? = ...) defined in org.jetbrains.kotlin.js.translate.callTranslator.ExplicitReceivers[ClassConstructorDescriptorImpl]

'translateReceiverAsExpression' @ [190:48] ==> local final fun translateReceiverAsExpression(receiver: ReceiverValue?): JsExpression? defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[SimpleFunctionDescriptorImpl]

'dispatchReceiver' @ [190:78] ==> val dispatchReceiver: ReceiverValue? defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[LocalVariableDescriptor]

'EXTENSION_RECEIVER' @ [191:9] ==> enum entry EXTENSION_RECEIVER defined in org.jetbrains.kotlin.resolve.calls.tasks.ExplicitReceiverKind[FakeCallableDescriptorForObject]

'ExplicitReceivers' @ [191:31] ==> public constructor ExplicitReceivers(extensionOrDispatchReceiver: JsExpression?, extensionReceiver: JsExpression? = ...) defined in org.jetbrains.kotlin.js.translate.callTranslator.ExplicitReceivers[ClassConstructorDescriptorImpl]

'translateReceiverAsExpression' @ [191:49] ==> local final fun translateReceiverAsExpression(receiver: ReceiverValue?): JsExpression? defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[SimpleFunctionDescriptorImpl]

'extensionReceiver' @ [191:79] ==> val extensionReceiver: ReceiverValue? defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[LocalVariableDescriptor]

'BOTH_RECEIVERS' @ [192:9] ==> enum entry BOTH_RECEIVERS defined in org.jetbrains.kotlin.resolve.calls.tasks.ExplicitReceiverKind[FakeCallableDescriptorForObject]

'ExplicitReceivers' @ [192:27] ==> public constructor ExplicitReceivers(extensionOrDispatchReceiver: JsExpression?, extensionReceiver: JsExpression? = ...) defined in org.jetbrains.kotlin.js.translate.callTranslator.ExplicitReceivers[ClassConstructorDescriptorImpl]

'translateReceiverAsExpression' @ [192:45] ==> local final fun translateReceiverAsExpression(receiver: ReceiverValue?): JsExpression? defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[SimpleFunctionDescriptorImpl]

'dispatchReceiver' @ [192:75] ==> val dispatchReceiver: ReceiverValue? defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[LocalVariableDescriptor]

'translateReceiverAsExpression' @ [193:45] ==> local final fun translateReceiverAsExpression(receiver: ReceiverValue?): JsExpression? defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[SimpleFunctionDescriptorImpl]

'extensionReceiver' @ [193:75] ==> val extensionReceiver: ReceiverValue? defined in org.jetbrains.kotlin.js.translate.callTranslator.computeExplicitReceiversForInvoke[LocalVariableDescriptor]

'IllegalStateException' @ [199:78] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'this' @ [199:125] ==> <this> defined in org.jetbrains.kotlin.js.translate.callTranslator.CallCase.unsupported[ReceiverParameterDescriptorImpl]

'unsupported' @ [201:56] ==> protected open fun I.unsupported(message: String = ...): Nothing defined in org.jetbrains.kotlin.js.translate.callTranslator.CallCase[SimpleFunctionDescriptorImpl]

'unsupported' @ [203:61] ==> protected open fun I.unsupported(message: String = ...): Nothing defined in org.jetbrains.kotlin.js.translate.callTranslator.CallCase[SimpleFunctionDescriptorImpl]

'unsupported' @ [205:62] ==> protected open fun I.unsupported(message: String = ...): Nothing defined in org.jetbrains.kotlin.js.translate.callTranslator.CallCase[SimpleFunctionDescriptorImpl]

'unsupported' @ [207:58] ==> protected open fun I.unsupported(message: String = ...): Nothing defined in org.jetbrains.kotlin.js.translate.callTranslator.CallCase[SimpleFunctionDescriptorImpl]

'if (callInfo.dispatchReceiver == null) {
            if (callInfo.extensionReceiver == null)
                callInfo.noReceivers()
            else
                callInfo.extensionReceiver()
        } else {
            if (callInfo.extensionReceiver == null) {
                callInfo.dispatchReceiver()
            } else
                callInfo.bothReceivers()
        }' @ [210:22] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: JsExpression, elseBranch: JsExpression): JsExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> JsExpression

'callInfo' @ [210:26] ==> value-parameter callInfo: I defined in org.jetbrains.kotlin.js.translate.callTranslator.CallCase.translate[ValueParameterDescriptorImpl]

'dispatchReceiver' @ [210:35] ==> public abstract val dispatchReceiver: JsExpression? defined in org.jetbrains.kotlin.js.translate.callTranslator.CallInfo[PropertyDescriptorImpl]

'if (callInfo.extensionReceiver == null)
                callInfo.noReceivers()
            else
                callInfo.extensionReceiver()' @ [211:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: JsExpression, elseBranch: JsExpression): JsExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> JsExpression

'callInfo' @ [211:17] ==> value-parameter callInfo: I defined in org.jetbrains.kotlin.js.translate.callTranslator.CallCase.translate[ValueParameterDescriptorImpl]

'extensionReceiver' @ [211:26] ==> public abstract val extensionReceiver: JsExpression? defined in org.jetbrains.kotlin.js.translate.callTranslator.CallInfo[PropertyDescriptorImpl]

'callInfo' @ [212:17] ==> value-parameter callInfo: I defined in org.jetbrains.kotlin.js.translate.callTranslator.CallCase.translate[ValueParameterDescriptorImpl]

'noReceivers' @ [212:26] ==> protected open fun I.noReceivers(): JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator.CallCase[SimpleFunctionDescriptorImpl]

'callInfo' @ [214:17] ==> value-parameter callInfo: I defined in org.jetbrains.kotlin.js.translate.callTranslator.CallCase.translate[ValueParameterDescriptorImpl]

'extensionReceiver' @ [214:26] ==> protected open fun I.extensionReceiver(): JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator.CallCase[SimpleFunctionDescriptorImpl]

'if (callInfo.extensionReceiver == null) {
                callInfo.dispatchReceiver()
            } else
                callInfo.bothReceivers()' @ [216:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: JsExpression, elseBranch: JsExpression): JsExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> JsExpression

'callInfo' @ [216:17] ==> value-parameter callInfo: I defined in org.jetbrains.kotlin.js.translate.callTranslator.CallCase.translate[ValueParameterDescriptorImpl]

'extensionReceiver' @ [216:26] ==> public abstract val extensionReceiver: JsExpression? defined in org.jetbrains.kotlin.js.translate.callTranslator.CallInfo[PropertyDescriptorImpl]

'callInfo' @ [217:17] ==> value-parameter callInfo: I defined in org.jetbrains.kotlin.js.translate.callTranslator.CallCase.translate[ValueParameterDescriptorImpl]

'dispatchReceiver' @ [217:26] ==> protected open fun I.dispatchReceiver(): JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator.CallCase[SimpleFunctionDescriptorImpl]

'callInfo' @ [219:17] ==> value-parameter callInfo: I defined in org.jetbrains.kotlin.js.translate.callTranslator.CallCase.translate[ValueParameterDescriptorImpl]

'bothReceivers' @ [219:26] ==> protected open fun I.bothReceivers(): JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator.CallCase[SimpleFunctionDescriptorImpl]

'callInfo' @ [222:16] ==> value-parameter callInfo: I defined in org.jetbrains.kotlin.js.translate.callTranslator.CallCase.translate[ValueParameterDescriptorImpl]

'constructSafeCallIfNeeded' @ [222:25] ==> public abstract fun constructSafeCallIfNeeded(result: JsExpression): JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator.CallInfo[SimpleFunctionDescriptorImpl]

'result' @ [222:51] ==> val result: JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator.CallCase.translate[LocalVariableDescriptor]

'CallCase<FunctionCallInfo>' @ [226:35] ==> public constructor CallCase<in I : CallInfo>() defined in org.jetbrains.kotlin.js.translate.callTranslator.CallCase[ClassConstructorDescriptorImpl]
Inferred types:
    <in I : CallInfo> -> FunctionCallInfo

'CallCase<VariableAccessInfo>' @ [228:37] ==> public constructor CallCase<in I : CallInfo>() defined in org.jetbrains.kotlin.js.translate.callTranslator.CallCase[ClassConstructorDescriptorImpl]
Inferred types:
    <in I : CallInfo> -> VariableAccessInfo

'if (callInfo.canBeApply()) {
                    callInfo.getIntrinsic()
                } else {
                    null
                }' @ [237:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: JsExpression?, elseBranch: JsExpression?): JsExpression?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> JsExpression?

'callInfo' @ [237:21] ==> value-parameter callInfo: I defined in org.jetbrains.kotlin.js.translate.callTranslator.DelegateIntrinsic.intrinsic[ValueParameterDescriptorImpl]

'canBeApply' @ [237:30] ==> public open fun I.canBeApply(): Boolean defined in org.jetbrains.kotlin.js.translate.callTranslator.DelegateIntrinsic[SimpleFunctionDescriptorImpl]

'callInfo' @ [238:21] ==> value-parameter callInfo: I defined in org.jetbrains.kotlin.js.translate.callTranslator.DelegateIntrinsic.intrinsic[ValueParameterDescriptorImpl]

'getIntrinsic' @ [238:30] ==> private final fun I.getIntrinsic(): JsExpression? defined in org.jetbrains.kotlin.js.translate.callTranslator.DelegateIntrinsic[SimpleFunctionDescriptorImpl]

'if (result != null) {
            callInfo.constructSafeCallIfNeeded(result)
        } else {
            null
        }' @ [243:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: JsExpression?, elseBranch: JsExpression?): JsExpression?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> JsExpression?

'result' @ [243:20] ==> val result: JsExpression? defined in org.jetbrains.kotlin.js.translate.callTranslator.DelegateIntrinsic.intrinsic[LocalVariableDescriptor]

'callInfo' @ [244:13] ==> value-parameter callInfo: I defined in org.jetbrains.kotlin.js.translate.callTranslator.DelegateIntrinsic.intrinsic[ValueParameterDescriptorImpl]

'constructSafeCallIfNeeded' @ [244:22] ==> public abstract fun constructSafeCallIfNeeded(result: JsExpression): JsExpression defined in org.jetbrains.kotlin.js.translate.callTranslator.CallInfo[SimpleFunctionDescriptorImpl]

'result' @ [244:48] ==> val result: JsExpression? defined in org.jetbrains.kotlin.js.translate.callTranslator.DelegateIntrinsic.intrinsic[LocalVariableDescriptor]

'getDescriptor' @ [251:26] ==> public abstract fun I.getDescriptor(): CallableDescriptor defined in org.jetbrains.kotlin.js.translate.callTranslator.DelegateIntrinsic[SimpleFunctionDescriptorImpl]

'descriptor' @ [254:13] ==> val descriptor: CallableDescriptor defined in org.jetbrains.kotlin.js.translate.callTranslator.DelegateIntrinsic.getIntrinsic[LocalVariableDescriptor]

'context' @ [255:29] ==> public abstract val context: TranslationContext defined in org.jetbrains.kotlin.js.translate.callTranslator.CallInfo[PropertyDescriptorImpl]

'intrinsics' @ [255:37] ==> @NotNull public open fun intrinsics(): Intrinsics defined in org.jetbrains.kotlin.js.translate.context.TranslationContext[JavaMethodDescriptor]

'getFunctionIntrinsic' @ [255:50] ==> @NotNull public open fun getFunctionIntrinsic(@NotNull descriptor: FunctionDescriptor): FunctionIntrinsic defined in org.jetbrains.kotlin.js.translate.intrinsic.Intrinsics[JavaMethodDescriptor]

'descriptor' @ [255:71] ==> val descriptor: CallableDescriptor defined in org.jetbrains.kotlin.js.translate.callTranslator.DelegateIntrinsic.getIntrinsic[LocalVariableDescriptor]

'intrinsic' @ [256:17] ==> val intrinsic: FunctionIntrinsic defined in org.jetbrains.kotlin.js.translate.callTranslator.DelegateIntrinsic.getIntrinsic[LocalVariableDescriptor]

'exists' @ [256:27] ==> public open fun exists(): Boolean defined in org.jetbrains.kotlin.js.translate.intrinsic.functions.basic.FunctionIntrinsic[SimpleFunctionDescriptorImpl]

'intrinsic' @ [257:24] ==> val intrinsic: FunctionIntrinsic defined in org.jetbrains.kotlin.js.translate.callTranslator.DelegateIntrinsic.getIntrinsic[LocalVariableDescriptor]

'apply' @ [257:34] ==> public abstract fun apply(callInfo: CallInfo, arguments: List<JsExpression>, context: TranslationContext): JsExpression defined in org.jetbrains.kotlin.js.translate.intrinsic.functions.basic.FunctionIntrinsic[SimpleFunctionDescriptorImpl]

'this' @ [257:40] ==> <this> defined in org.jetbrains.kotlin.js.translate.callTranslator.DelegateIntrinsic.getIntrinsic[ReceiverParameterDescriptorImpl]

'getArgs' @ [257:46] ==> public abstract fun I.getArgs(): List<JsExpression> defined in org.jetbrains.kotlin.js.translate.callTranslator.DelegateIntrinsic[SimpleFunctionDescriptorImpl]

'context' @ [257:57] ==> public abstract val context: TranslationContext defined in org.jetbrains.kotlin.js.translate.callTranslator.CallInfo[PropertyDescriptorImpl]

