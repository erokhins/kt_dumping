'AbstractTranslator' @ [52:5] ==> protected/*protected and package*/ constructor AbstractTranslator(@NotNull context: TranslationContext) defined in org.jetbrains.kotlin.js.translate.general.AbstractTranslator[JavaClassConstructorDescriptor]

'context' @ [52:24] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.<init>[ValueParameterDescriptorImpl]

'listOf' @ [58:56] ==> @InlineOnly public inline fun <T> listOf(): List<JsExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsExpression

'reifiedArguments' @ [61:21] ==> public final val reifiedArguments: List<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.ArgumentsInfo[PropertyDescriptorImpl]

'valueArguments' @ [61:40] ==> public final val valueArguments: List<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.ArgumentsInfo[PropertyDescriptorImpl]

'isNativeObject' @ [64:57] ==> public open fun isNativeObject(@NotNull p0: DeclarationDescriptor): Boolean defined in org.jetbrains.kotlin.js.translate.utils.AnnotationsUtils[JavaMethodDescriptor]

'resolvedCall' @ [64:72] ==> private final val resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[PropertyDescriptorImpl]

'candidateDescriptor' @ [64:85] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.candidateDescriptor: (CallableDescriptor..CallableDescriptor?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(*)

'result' @ [67:17] ==> value-parameter result: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.removeLastUndefinedArguments[ValueParameterDescriptorImpl]

'lastIndex' @ [67:24] ==> public val <T> List<JsExpression>.lastIndex: Int defined in kotlin.collections[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> JsExpression

'i' @ [69:16] ==> var i: Int defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.removeLastUndefinedArguments[LocalVariableDescriptor]

'!' @ [70:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isUndefinedExpression' @ [70:29] ==> public open fun isUndefinedExpression(expression: (JsExpression..JsExpression?)): Boolean defined in org.jetbrains.kotlin.js.translate.utils.JsAstUtils[JavaMethodDescriptor]

'result' @ [70:51] ==> value-parameter result: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.removeLastUndefinedArguments[ValueParameterDescriptorImpl]

'i' @ [70:58] ==> var i: Int defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.removeLastUndefinedArguments[LocalVariableDescriptor]

'i' @ [73:13] ==> var i: Int defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.removeLastUndefinedArguments[LocalVariableDescriptor]

'result' @ [76:9] ==> value-parameter result: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.removeLastUndefinedArguments[ValueParameterDescriptorImpl]

'subList' @ [76:16] ==> public abstract fun subList(fromIndex: Int, toIndex: Int): MutableList<JsExpression> defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'i' @ [76:24] ==> var i: Int defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.removeLastUndefinedArguments[LocalVariableDescriptor]

'result' @ [76:31] ==> value-parameter result: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.removeLastUndefinedArguments[ValueParameterDescriptorImpl]

'size' @ [76:38] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'clear' @ [76:44] ==> public abstract fun clear(): Unit defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'resolvedCall' @ [80:31] ==> private final val resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[PropertyDescriptorImpl]

'resultingDescriptor' @ [80:44] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.resultingDescriptor: (CallableDescriptor..CallableDescriptor?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(*)

'valueParameters' @ [80:64] ==> public final val CallableDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'ArrayList' @ [84:49] ==> public constructor ArrayList<E : (Any..Any?)>(p0: Int) defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> JsExpression

'valueParameters' @ [84:59] ==> val valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'size' @ [84:75] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'resolvedCall' @ [85:37] ==> private final val resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[PropertyDescriptorImpl]

'valueArgumentsByIndex' @ [85:50] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.valueArgumentsByIndex: (MutableList<(ResolvedValueArgument..ResolvedValueArgument?)>?..List<(ResolvedValueArgument..ResolvedValueArgument?)>?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(*)

'IllegalStateException' @ [85:81] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'+' @ [86:17] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'resolvedCall' @ [86:66] ==> private final val resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[PropertyDescriptorImpl]

'resultingDescriptor' @ [86:79] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.resultingDescriptor: (CallableDescriptor..CallableDescriptor?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(*)

'translateUnresolvedArguments' @ [89:28] ==> private final fun translateUnresolvedArguments(context: TranslationContext, resolvedCall: ResolvedCall<*>): Map<ValueArgument, JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[SimpleFunctionDescriptorImpl]

'context' @ [89:57] ==> @NotNull protected/*protected and package*/ open fun context(): TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[JavaMethodDescriptor]

'resolvedCall' @ [89:68] ==> private final val resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[PropertyDescriptorImpl]

'valueParameters' @ [92:37] ==> val valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'valueArgumentsByIndex' @ [93:34] ==> val valueArgumentsByIndex: (MutableList<(ResolvedValueArgument..ResolvedValueArgument?)>..List<(ResolvedValueArgument..ResolvedValueArgument?)>) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'parameterDescriptor' @ [93:56] ==> val parameterDescriptor: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'index' @ [93:76] ==> public abstract val index: Int defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'if (actualArgument is VarargValueArgument) {

                val arguments = actualArgument.getArguments()

                if (!hasSpreadOperator) {
                    hasSpreadOperator = arguments.any { it.getSpreadElement() != null }
                }

                val varargElementType = parameterDescriptor.original.varargElementType!!
                varargPrimitiveType = KotlinBuiltIns.getPrimitiveType(varargElementType).takeUnless { varargElementType.isMarkedNullable }

                if (hasSpreadOperator) {
                    if (isNativeFunctionCall) {
                        argsBeforeVararg = result
                        result = mutableListOf<JsExpression>()
                        concatArguments = prepareConcatArguments(arguments,
                                                                 translateResolvedArgument(actualArgument, argsToJsExpr),
                                                                 null)
                    }
                    else {
                        result.addAll(translateVarargArgument(actualArgument,
                                                              argsToJsExpr,
                                                              actualArgument.arguments.size > 1,
                                                              varargPrimitiveType))
                    }
                }
                else {
                    if (isNativeFunctionCall) {
                        result.addAll(translateResolvedArgument(actualArgument, argsToJsExpr))
                    }
                    else {
                        result.addAll(translateVarargArgument(actualArgument, argsToJsExpr, true, varargPrimitiveType))
                    }
                }
            }
            else {
                result.addAll(translateResolvedArgument(actualArgument, argsToJsExpr))
            }' @ [95:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any, elseBranch: Any): Any[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any

'actualArgument' @ [95:17] ==> val actualArgument: (ResolvedValueArgument..ResolvedValueArgument?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'actualArgument' @ [97:33] ==> val actualArgument: (ResolvedValueArgument..ResolvedValueArgument?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'getArguments' @ [97:48] ==> @NotNull public abstract fun getArguments(): (MutableList<(ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>) defined in org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument[JavaMethodDescriptor]

'!' @ [99:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'hasSpreadOperator' @ [99:22] ==> var hasSpreadOperator: Boolean defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'hasSpreadOperator' @ [100:21] ==> var hasSpreadOperator: Boolean defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'arguments' @ [100:41] ==> val arguments: (MutableList<(ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'any' @ [100:51] ==> public inline fun <T> Iterable<(ValueArgument..ValueArgument?)>.any(predicate: ((ValueArgument..ValueArgument?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)

'it' @ [100:57] ==> value-parameter it: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate.<anonymous>[ValueParameterDescriptorImpl]

'getSpreadElement' @ [100:60] ==> public abstract fun getSpreadElement(): LeafPsiElement? defined in org.jetbrains.kotlin.psi.ValueArgument[DeserializedSimpleFunctionDescriptor]

'parameterDescriptor' @ [103:41] ==> val parameterDescriptor: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'original' @ [103:61] ==> public final val ValueParameterDescriptor.original: ValueParameterDescriptor[MyPropertyDescriptor]

'varargElementType' @ [103:70] ==> public abstract val varargElementType: KotlinType? defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'varargPrimitiveType' @ [104:17] ==> var varargPrimitiveType: PrimitiveType? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'getPrimitiveType' @ [104:54] ==> @Nullable public open fun getPrimitiveType(@NotNull p0: KotlinType): PrimitiveType? defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'varargElementType' @ [104:71] ==> val varargElementType: KotlinType defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'takeUnless' @ [104:90] ==> @InlineOnly @SinceKotlin public inline fun <T> PrimitiveType?.takeUnless(predicate: (PrimitiveType?) -> Boolean): PrimitiveType? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PrimitiveType?

'varargElementType' @ [104:103] ==> val varargElementType: KotlinType defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'isMarkedNullable' @ [104:121] ==> public abstract val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'if (hasSpreadOperator) {
                    if (isNativeFunctionCall) {
                        argsBeforeVararg = result
                        result = mutableListOf<JsExpression>()
                        concatArguments = prepareConcatArguments(arguments,
                                                                 translateResolvedArgument(actualArgument, argsToJsExpr),
                                                                 null)
                    }
                    else {
                        result.addAll(translateVarargArgument(actualArgument,
                                                              argsToJsExpr,
                                                              actualArgument.arguments.size > 1,
                                                              varargPrimitiveType))
                    }
                }
                else {
                    if (isNativeFunctionCall) {
                        result.addAll(translateResolvedArgument(actualArgument, argsToJsExpr))
                    }
                    else {
                        result.addAll(translateVarargArgument(actualArgument, argsToJsExpr, true, varargPrimitiveType))
                    }
                }' @ [106:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any, elseBranch: Any): Any[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any

'hasSpreadOperator' @ [106:21] ==> var hasSpreadOperator: Boolean defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'if (isNativeFunctionCall) {
                        argsBeforeVararg = result
                        result = mutableListOf<JsExpression>()
                        concatArguments = prepareConcatArguments(arguments,
                                                                 translateResolvedArgument(actualArgument, argsToJsExpr),
                                                                 null)
                    }
                    else {
                        result.addAll(translateVarargArgument(actualArgument,
                                                              argsToJsExpr,
                                                              actualArgument.arguments.size > 1,
                                                              varargPrimitiveType))
                    }' @ [107:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any, elseBranch: Any): Any[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any

'isNativeFunctionCall' @ [107:25] ==> private final val isNativeFunctionCall: Boolean defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[PropertyDescriptorImpl]

'argsBeforeVararg' @ [108:25] ==> var argsBeforeVararg: List<JsExpression>? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'result' @ [108:44] ==> var result: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'result' @ [109:25] ==> var result: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'mutableListOf' @ [109:34] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableListOf(): MutableList<JsExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsExpression

'concatArguments' @ [110:25] ==> var concatArguments: MutableList<JsExpression>? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'prepareConcatArguments' @ [110:43] ==> private final fun prepareConcatArguments(arguments: List<ValueArgument>, list: List<JsExpression>, varargPrimitiveType: PrimitiveType?): MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[SimpleFunctionDescriptorImpl]

'arguments' @ [110:66] ==> val arguments: (MutableList<(ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'translateResolvedArgument' @ [111:66] ==> private final fun translateResolvedArgument(resolvedArgument: ResolvedValueArgument, translatedArgs: Map<ValueArgument, JsExpression>): List<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion[SimpleFunctionDescriptorImpl]

'actualArgument' @ [111:92] ==> val actualArgument: (ResolvedValueArgument..ResolvedValueArgument?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'argsToJsExpr' @ [111:108] ==> val argsToJsExpr: Map<ValueArgument, JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'result' @ [115:25] ==> var result: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'addAll' @ [115:32] ==> public abstract fun addAll(elements: Collection<JsExpression>): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'translateVarargArgument' @ [115:39] ==> private final fun translateVarargArgument(resolvedArgument: ResolvedValueArgument, translatedArgs: Map<ValueArgument, JsExpression>, shouldWrapVarargInArray: Boolean, varargPrimitiveType: PrimitiveType?): List<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[SimpleFunctionDescriptorImpl]

'actualArgument' @ [115:63] ==> val actualArgument: (ResolvedValueArgument..ResolvedValueArgument?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'argsToJsExpr' @ [116:63] ==> val argsToJsExpr: Map<ValueArgument, JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'actualArgument' @ [117:63] ==> val actualArgument: (ResolvedValueArgument..ResolvedValueArgument?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'arguments' @ [117:78] ==> public final val VarargValueArgument.arguments: (MutableList<(ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>)[MyPropertyDescriptor]

'size' @ [117:88] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'varargPrimitiveType' @ [118:63] ==> var varargPrimitiveType: PrimitiveType? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'if (isNativeFunctionCall) {
                        result.addAll(translateResolvedArgument(actualArgument, argsToJsExpr))
                    }
                    else {
                        result.addAll(translateVarargArgument(actualArgument, argsToJsExpr, true, varargPrimitiveType))
                    }' @ [122:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Boolean, elseBranch: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Boolean

'isNativeFunctionCall' @ [122:25] ==> private final val isNativeFunctionCall: Boolean defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[PropertyDescriptorImpl]

'result' @ [123:25] ==> var result: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'addAll' @ [123:32] ==> public abstract fun addAll(elements: Collection<JsExpression>): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'translateResolvedArgument' @ [123:39] ==> private final fun translateResolvedArgument(resolvedArgument: ResolvedValueArgument, translatedArgs: Map<ValueArgument, JsExpression>): List<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion[SimpleFunctionDescriptorImpl]

'actualArgument' @ [123:65] ==> val actualArgument: (ResolvedValueArgument..ResolvedValueArgument?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'argsToJsExpr' @ [123:81] ==> val argsToJsExpr: Map<ValueArgument, JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'result' @ [126:25] ==> var result: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'addAll' @ [126:32] ==> public abstract fun addAll(elements: Collection<JsExpression>): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'translateVarargArgument' @ [126:39] ==> private final fun translateVarargArgument(resolvedArgument: ResolvedValueArgument, translatedArgs: Map<ValueArgument, JsExpression>, shouldWrapVarargInArray: Boolean, varargPrimitiveType: PrimitiveType?): List<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[SimpleFunctionDescriptorImpl]

'actualArgument' @ [126:63] ==> val actualArgument: (ResolvedValueArgument..ResolvedValueArgument?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'argsToJsExpr' @ [126:79] ==> val argsToJsExpr: Map<ValueArgument, JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'varargPrimitiveType' @ [126:99] ==> var varargPrimitiveType: PrimitiveType? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'result' @ [131:17] ==> var result: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'addAll' @ [131:24] ==> public abstract fun addAll(elements: Collection<JsExpression>): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'translateResolvedArgument' @ [131:31] ==> private final fun translateResolvedArgument(resolvedArgument: ResolvedValueArgument, translatedArgs: Map<ValueArgument, JsExpression>): List<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion[SimpleFunctionDescriptorImpl]

'actualArgument' @ [131:57] ==> val actualArgument: (ResolvedValueArgument..ResolvedValueArgument?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'argsToJsExpr' @ [131:73] ==> val argsToJsExpr: Map<ValueArgument, JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'isNativeFunctionCall' @ [135:13] ==> private final val isNativeFunctionCall: Boolean defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[PropertyDescriptorImpl]

'hasSpreadOperator' @ [135:37] ==> var hasSpreadOperator: Boolean defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'assert' @ [136:13] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'argsBeforeVararg' @ [136:20] ==> var argsBeforeVararg: List<JsExpression>? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'assert' @ [137:13] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'concatArguments' @ [137:20] ==> var concatArguments: MutableList<JsExpression>? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'!' @ [139:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'result' @ [139:18] ==> var result: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'isEmpty' @ [139:25] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'concatArguments' @ [140:17] ==> var concatArguments: MutableList<JsExpression>? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'add' @ [140:35] ==> public abstract fun add(element: JsExpression): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'toArray' @ [140:39] ==> private final fun toArray(varargPrimitiveType: PrimitiveType?, elements: List<JsExpression>): JsExpression defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[SimpleFunctionDescriptorImpl]

'result' @ [140:53] ==> var result: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'!' @ [143:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'argsBeforeVararg' @ [143:18] ==> var argsBeforeVararg: List<JsExpression>? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'isEmpty' @ [143:37] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'concatArguments' @ [144:17] ==> var concatArguments: MutableList<JsExpression>? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'add' @ [144:35] ==> public abstract fun add(index: Int, element: JsExpression): Unit defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'toArray' @ [144:42] ==> private final fun toArray(varargPrimitiveType: PrimitiveType?, elements: List<JsExpression>): JsExpression defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[SimpleFunctionDescriptorImpl]

'argsBeforeVararg' @ [144:56] ==> var argsBeforeVararg: List<JsExpression>? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'result' @ [147:13] ==> var result: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'mutableListOf' @ [147:22] ==> public fun <T> mutableListOf(vararg elements: JsExpression): MutableList<JsExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsExpression

'concatArgumentsIfNeeded' @ [147:36] ==> private final fun concatArgumentsIfNeeded(concatArguments: List<JsExpression>, varargPrimitiveType: PrimitiveType?, isMixed: Boolean): JsExpression defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion[SimpleFunctionDescriptorImpl]

'concatArguments' @ [147:60] ==> var concatArguments: MutableList<JsExpression>? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'varargPrimitiveType' @ [147:79] ==> var varargPrimitiveType: PrimitiveType? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'if (receiver != null) {
                cachedReceiver = context().getOrDeclareTemporaryConstVariable(receiver)
                result.add(0, cachedReceiver.reference())
            }
            else {
                result.add(0, JsNullLiteral())
            }' @ [149:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'receiver' @ [149:17] ==> private final val receiver: JsExpression? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[PropertyDescriptorImpl]

'cachedReceiver' @ [150:17] ==> var cachedReceiver: TemporaryConstVariable? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'context' @ [150:34] ==> @NotNull protected/*protected and package*/ open fun context(): TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[JavaMethodDescriptor]

'getOrDeclareTemporaryConstVariable' @ [150:44] ==> @NotNull public open fun getOrDeclareTemporaryConstVariable(@NotNull expression: JsExpression): TemporaryConstVariable defined in org.jetbrains.kotlin.js.translate.context.TranslationContext[JavaMethodDescriptor]

'receiver' @ [150:79] ==> private final val receiver: JsExpression? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[PropertyDescriptorImpl]

'result' @ [151:17] ==> var result: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'add' @ [151:24] ==> public abstract fun add(index: Int, element: JsExpression): Unit defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'cachedReceiver' @ [151:31] ==> var cachedReceiver: TemporaryConstVariable? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'reference' @ [151:46] ==> @NotNull public open fun reference(): JsNameRef defined in org.jetbrains.kotlin.js.translate.context.TemporaryConstVariable[JavaMethodDescriptor]

'result' @ [154:17] ==> var result: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'add' @ [154:24] ==> public abstract fun add(index: Int, element: JsExpression): Unit defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'JsNullLiteral' @ [154:31] ==> public constructor JsNullLiteral() defined in org.jetbrains.kotlin.js.backend.ast.JsNullLiteral[JavaClassConstructorDescriptor]

'resolvedCall' @ [158:34] ==> private final val resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[PropertyDescriptorImpl]

'resultingDescriptor' @ [158:47] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.resultingDescriptor: (CallableDescriptor..CallableDescriptor?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(*)

'callableDescriptor' @ [159:13] ==> val callableDescriptor: (CallableDescriptor..CallableDescriptor?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'callableDescriptor' @ [159:57] ==> val callableDescriptor: (CallableDescriptor..CallableDescriptor?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'isSuspend' @ [159:76] ==> public final val FunctionDescriptor.isSuspend: Boolean[MyPropertyDescriptor]

'translateContinuationArgument' @ [160:66] ==> @NotNull public open fun translateContinuationArgument(@NotNull context: TranslationContext): JsExpression defined in org.jetbrains.kotlin.js.translate.utils.TranslationUtils[JavaMethodDescriptor]

'context' @ [160:96] ==> @NotNull protected/*protected and package*/ open fun context(): TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[JavaMethodDescriptor]

'callableDescriptor' @ [161:17] ==> val callableDescriptor: (CallableDescriptor..CallableDescriptor?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'original' @ [161:36] ==> public final val FunctionDescriptor.original: FunctionDescriptor[MyPropertyDescriptor]

'isBuiltInSuspendCoroutineOrReturn' @ [161:45] ==> public fun FunctionDescriptor.isBuiltInSuspendCoroutineOrReturn(): Boolean defined in org.jetbrains.kotlin.backend.common[DeserializedSimpleFunctionDescriptor]

'context' @ [162:34] ==> @NotNull protected/*protected and package*/ open fun context(): TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[JavaMethodDescriptor]

'getNameForDescriptor' @ [162:44] ==> @NotNull public open fun getNameForDescriptor(@NotNull descriptor: DeclarationDescriptor): JsName defined in org.jetbrains.kotlin.js.translate.context.TranslationContext[JavaMethodDescriptor]

'getCoroutineProperty' @ [162:82] ==> @NotNull public open fun getCoroutineProperty(@NotNull context: TranslationContext, @NotNull name: String): PropertyDescriptor defined in org.jetbrains.kotlin.js.translate.utils.TranslationUtils[JavaMethodDescriptor]

'context' @ [162:103] ==> @NotNull protected/*protected and package*/ open fun context(): TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[JavaMethodDescriptor]

'continuationArg' @ [163:17] ==> var continuationArg: JsExpression defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'pureFqn' @ [163:46] ==> @NotNull public open fun pureFqn(@NotNull identifier: JsName, @Nullable qualifier: JsExpression?): JsNameRef defined in org.jetbrains.kotlin.js.translate.utils.JsAstUtils[JavaMethodDescriptor]

'facadeName' @ [163:54] ==> val facadeName: JsName defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'continuationArg' @ [163:66] ==> var continuationArg: JsExpression defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'result' @ [165:13] ==> var result: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'add' @ [165:20] ==> public abstract fun add(element: JsExpression): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'continuationArg' @ [165:24] ==> var continuationArg: JsExpression defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'removeLastUndefinedArguments' @ [168:9] ==> private final fun removeLastUndefinedArguments(result: MutableList<JsExpression>): Unit defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[SimpleFunctionDescriptorImpl]

'result' @ [168:38] ==> var result: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'ArgumentsInfo' @ [170:16] ==> public constructor ArgumentsInfo(valueArguments: List<JsExpression>, hasSpreadOperator: Boolean, cachedReceiver: TemporaryConstVariable?, reifiedArguments: List<JsExpression> = ...) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.ArgumentsInfo[ClassConstructorDescriptorImpl]

'result' @ [170:30] ==> var result: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'hasSpreadOperator' @ [170:38] ==> var hasSpreadOperator: Boolean defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'cachedReceiver' @ [170:57] ==> var cachedReceiver: TemporaryConstVariable? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translate[LocalVariableDescriptor]

'resolvedCall' @ [177:32] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments[ValueParameterDescriptorImpl]

'valueArguments' @ [177:45] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.valueArguments: (MutableMap<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>..Map<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(*)

'flatMap' @ [178:18] ==> public inline fun <K, V, R> Map<out (ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>.flatMap(transform: (Map.Entry<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>) -> Iterable<Pair<(ValueParameterDescriptor..ValueParameterDescriptor?), (ValueArgument..ValueArgument?)>>): List<Pair<(ValueParameterDescriptor..ValueParameterDescriptor?), (ValueArgument..ValueArgument?)>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)
    <V> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument..org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument?)
    <R> -> Pair<(org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?), (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)>

'component1' @ [178:29] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>.component1(): (ValueParameterDescriptor..ValueParameterDescriptor?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)
    <V> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument..org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument?)

'component2' @ [178:36] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(ValueParameterDescriptor..ValueParameterDescriptor?), (ResolvedValueArgument..ResolvedValueArgument?)>.component2(): (ResolvedValueArgument..ResolvedValueArgument?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)
    <V> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument..org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument?)

'args' @ [178:45] ==> val args: (ResolvedValueArgument..ResolvedValueArgument?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[LocalVariableDescriptor]

'arguments' @ [178:50] ==> public final val ResolvedValueArgument.arguments: (MutableList<(ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>)[MyPropertyDescriptor]

'map' @ [178:60] ==> public inline fun <T, R> Iterable<(ValueArgument..ValueArgument?)>.map(transform: ((ValueArgument..ValueArgument?)) -> Pair<(ValueParameterDescriptor..ValueParameterDescriptor?), (ValueArgument..ValueArgument?)>): List<Pair<(ValueParameterDescriptor..ValueParameterDescriptor?), (ValueArgument..ValueArgument?)>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)
    <R> -> Pair<(org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?), (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)>

'param' @ [178:66] ==> val param: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[LocalVariableDescriptor]

'it' @ [178:75] ==> value-parameter it: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'associate' @ [179:18] ==> public inline fun <T, K, V> Iterable<Pair<(ValueParameterDescriptor..ValueParameterDescriptor?), (ValueArgument..ValueArgument?)>>.associate(transform: (Pair<(ValueParameterDescriptor..ValueParameterDescriptor?), (ValueArgument..ValueArgument?)>) -> Pair<(ValueArgument..ValueArgument?), (ValueParameterDescriptor..ValueParameterDescriptor?)>): Map<(ValueArgument..ValueArgument?), (ValueParameterDescriptor..ValueParameterDescriptor?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<(org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?), (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)>
    <K> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)
    <V> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)

'component1' @ [179:31] ==> public final operator fun component1(): (ValueParameterDescriptor..ValueParameterDescriptor?) defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [179:38] ==> public final operator fun component2(): (ValueArgument..ValueArgument?) defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'arg' @ [179:46] ==> val arg: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[LocalVariableDescriptor]

'param' @ [179:53] ==> val param: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[LocalVariableDescriptor]

'resolvedCall' @ [181:32] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments[ValueParameterDescriptorImpl]

'call' @ [181:45] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(*)

'valueArguments' @ [181:50] ==> public final val Call.valueArguments: List<(ValueArgument..ValueArgument?)>[MyPropertyDescriptor]

'associate' @ [181:65] ==> public inline fun <T, K, V> Iterable<(ValueArgument..ValueArgument?)>.associate(transform: ((ValueArgument..ValueArgument?)) -> Pair<(ValueArgument..ValueArgument?), TranslationContext>): Map<(ValueArgument..ValueArgument?), TranslationContext> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)
    <K> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)
    <V> -> TranslationContext

'it' @ [181:77] ==> value-parameter it: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[ValueParameterDescriptorImpl]

'context' @ [181:83] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments[ValueParameterDescriptorImpl]

'innerBlock' @ [181:91] ==> @NotNull public open fun innerBlock(): TranslationContext defined in org.jetbrains.kotlin.js.translate.context.TranslationContext[JavaMethodDescriptor]

'resolvedCall' @ [183:22] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments[ValueParameterDescriptorImpl]

'call' @ [183:35] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(*)

'valueArguments' @ [183:40] ==> public final val Call.valueArguments: List<(ValueArgument..ValueArgument?)>[MyPropertyDescriptor]

'associate' @ [183:55] ==> public inline fun <T, K, V> Iterable<(ValueArgument..ValueArgument?)>.associate(transform: ((ValueArgument..ValueArgument?)) -> Pair<(ValueArgument..ValueArgument?), JsExpression>): Map<(ValueArgument..ValueArgument?), JsExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)
    <K> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)
    <V> -> JsExpression

'argumentContexts' @ [184:35] ==> val argumentContexts: Map<(ValueArgument..ValueArgument?), TranslationContext> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments[LocalVariableDescriptor]

'arg' @ [184:52] ==> value-parameter arg: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[ValueParameterDescriptorImpl]

'arg' @ [185:49] ==> value-parameter arg: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[ValueParameterDescriptorImpl]

'getArgumentExpression' @ [185:53] ==> @IfNotParsed public abstract fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.ValueArgument[DeserializedSimpleFunctionDescriptor]

'argsToParameters' @ [187:25] ==> val argsToParameters: Map<(ValueArgument..ValueArgument?), (ValueParameterDescriptor..ValueParameterDescriptor?)> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments[LocalVariableDescriptor]

'arg' @ [187:42] ==> value-parameter arg: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[ValueParameterDescriptorImpl]

'original' @ [187:49] ==> public final val ValueParameterDescriptor.original: ValueParameterDescriptor[MyPropertyDescriptor]

'if (resolvedCall.call.callType == Call.CallType.INVOKE) {
                DefaultBuiltIns.Instance.anyType
            }
            else {
                param.varargElementType ?: param.type
            }' @ [188:33] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType, elseBranch: KotlinType): KotlinType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType

'resolvedCall' @ [188:37] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments[ValueParameterDescriptorImpl]

'call' @ [188:50] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(*)

'callType' @ [188:55] ==> public final val Call.callType: Call.CallType[MyPropertyDescriptor]

'INVOKE' @ [188:81] ==> enum entry INVOKE defined in org.jetbrains.kotlin.psi.Call.CallType[FakeCallableDescriptorForObject]

'Instance' @ [189:33] ==> @JvmStatic public final val Instance: DefaultBuiltIns defined in org.jetbrains.kotlin.builtins.DefaultBuiltIns.Companion[DeserializedPropertyDescriptor]

'anyType' @ [189:42] ==> public final val DefaultBuiltIns.anyType: SimpleType[MyPropertyDescriptor]

'param' @ [192:17] ==> val param: ValueParameterDescriptor defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[LocalVariableDescriptor]

'varargElementType' @ [192:23] ==> public abstract val varargElementType: KotlinType? defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'param' @ [192:44] ==> val param: ValueParameterDescriptor defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[LocalVariableDescriptor]

'type' @ [192:50] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'context' @ [195:27] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments[ValueParameterDescriptorImpl]

'bindingContext' @ [195:35] ==> @NotNull public open fun bindingContext(): BindingContext defined in org.jetbrains.kotlin.js.translate.context.TranslationContext[JavaMethodDescriptor]

'getType' @ [195:52] ==> @Nullable public abstract fun getType(@NotNull p0: KtExpression): KotlinType? defined in org.jetbrains.kotlin.resolve.BindingContext[JavaMethodDescriptor]

'parenthisedArgumentExpression' @ [195:60] ==> val parenthisedArgumentExpression: KtExpression? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[LocalVariableDescriptor]

'translateAsExpression' @ [197:37] ==> @NotNull public open fun translateAsExpression(@NotNull expression: KtExpression, @NotNull context: TranslationContext): JsExpression defined in org.jetbrains.kotlin.js.translate.general.Translation[JavaMethodDescriptor]

'parenthisedArgumentExpression' @ [197:59] ==> val parenthisedArgumentExpression: KtExpression? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[LocalVariableDescriptor]

'argumentContext' @ [197:90] ==> val argumentContext: TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[LocalVariableDescriptor]

'arg' @ [199:13] ==> value-parameter arg: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[ValueParameterDescriptorImpl]

'boxCastIfNeeded' @ [199:37] ==> @NotNull public open fun boxCastIfNeeded(@NotNull e: JsExpression, @Nullable castFrom: KotlinType?, @Nullable castTo: KotlinType?): JsExpression defined in org.jetbrains.kotlin.js.translate.utils.TranslationUtils[JavaMethodDescriptor]

'argJs' @ [199:53] ==> val argJs: JsExpression defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[LocalVariableDescriptor]

'argType' @ [199:60] ==> val argType: KotlinType? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[LocalVariableDescriptor]

'parameterType' @ [199:69] ==> val parameterType: KotlinType defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[LocalVariableDescriptor]

'resolvedCall' @ [202:29] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments[ValueParameterDescriptorImpl]

'valueArgumentsByIndex' @ [202:42] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.valueArgumentsByIndex: (MutableList<(ResolvedValueArgument..ResolvedValueArgument?)>?..List<(ResolvedValueArgument..ResolvedValueArgument?)>?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(*)

'orEmpty' @ [202:64] ==> @InlineOnly public inline fun <T> List<(ResolvedValueArgument..ResolvedValueArgument?)>?.orEmpty(): List<(ResolvedValueArgument..ResolvedValueArgument?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument..org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument?)

'flatMap' @ [203:18] ==> public inline fun <T, R> Iterable<(ResolvedValueArgument..ResolvedValueArgument?)>.flatMap(transform: ((ResolvedValueArgument..ResolvedValueArgument?)) -> Iterable<(ValueArgument..ValueArgument?)>): List<(ValueArgument..ValueArgument?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument..org.jetbrains.kotlin.resolve.calls.model.ResolvedValueArgument?)
    <R> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)

'it' @ [203:28] ==> value-parameter it: (ResolvedValueArgument..ResolvedValueArgument?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[ValueParameterDescriptorImpl]

'arguments' @ [203:31] ==> public final val ResolvedValueArgument.arguments: (MutableList<(ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>)[MyPropertyDescriptor]

'withIndex' @ [204:18] ==> public fun <T> Iterable<(ValueArgument..ValueArgument?)>.withIndex(): Iterable<IndexedValue<(ValueArgument..ValueArgument?)>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)

'associate' @ [205:18] ==> public inline fun <T, K, V> Iterable<IndexedValue<(ValueArgument..ValueArgument?)>>.associate(transform: (IndexedValue<(ValueArgument..ValueArgument?)>) -> Pair<(ValueArgument..ValueArgument?), Int>): Map<(ValueArgument..ValueArgument?), Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> IndexedValue<(org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)>
    <K> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)
    <V> -> Int

'component1' @ [205:31] ==> public final operator fun component1(): Int defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'component2' @ [205:38] ==> public final operator fun component2(): (ValueArgument..ValueArgument?) defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'arg' @ [205:46] ==> val arg: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[LocalVariableDescriptor]

'index' @ [205:53] ==> val index: Int defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[LocalVariableDescriptor]

'resolvedCall' @ [206:35] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments[ValueParameterDescriptorImpl]

'call' @ [206:48] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(*)

'valueArguments' @ [206:53] ==> public final val Call.valueArguments: List<(ValueArgument..ValueArgument?)>[MyPropertyDescriptor]

'withIndex' @ [206:68] ==> public fun <T> Iterable<(ValueArgument..ValueArgument?)>.withIndex(): Iterable<IndexedValue<(ValueArgument..ValueArgument?)>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)

'none' @ [206:80] ==> public inline fun <T> Iterable<IndexedValue<(ValueArgument..ValueArgument?)>>.none(predicate: (IndexedValue<(ValueArgument..ValueArgument?)>) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> IndexedValue<(org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)>

'component1' @ [206:88] ==> public final operator fun component1(): Int defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'component2' @ [206:95] ==> public final operator fun component2(): (ValueArgument..ValueArgument?) defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'resolvedOrder' @ [206:103] ==> val resolvedOrder: Map<(ValueArgument..ValueArgument?), Int> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments[LocalVariableDescriptor]

'arg' @ [206:117] ==> val arg: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[LocalVariableDescriptor]

'index' @ [206:125] ==> val index: Int defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[LocalVariableDescriptor]

'argumentContexts' @ [208:13] ==> val argumentContexts: Map<(ValueArgument..ValueArgument?), TranslationContext> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments[LocalVariableDescriptor]

'values' @ [208:30] ==> public abstract val values: Collection<TranslationContext> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'any' @ [208:37] ==> public inline fun <T> Iterable<TranslationContext>.any(predicate: (TranslationContext) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TranslationContext

'!' @ [208:43] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'it' @ [208:44] ==> value-parameter it: TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[ValueParameterDescriptorImpl]

'currentBlockIsEmpty' @ [208:47] ==> public open fun currentBlockIsEmpty(): Boolean defined in org.jetbrains.kotlin.js.translate.context.TranslationContext[JavaMethodDescriptor]

'!' @ [208:74] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'argumentsAreOrdered' @ [208:75] ==> val argumentsAreOrdered: Boolean defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments[LocalVariableDescriptor]

'result' @ [209:13] ==> var result: Map<(ValueArgument..ValueArgument?), JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments[LocalVariableDescriptor]

'result' @ [209:22] ==> var result: Map<(ValueArgument..ValueArgument?), JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments[LocalVariableDescriptor]

'map' @ [209:29] ==> public inline fun <K, V, R> Map<out (ValueArgument..ValueArgument?), JsExpression>.map(transform: (Map.Entry<(ValueArgument..ValueArgument?), JsExpression>) -> Pair<(ValueArgument..ValueArgument?), JsExpression>): List<Pair<(ValueArgument..ValueArgument?), JsExpression>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)
    <V> -> JsExpression
    <R> -> Pair<(org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?), JsExpression>

'component1' @ [209:36] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(ValueArgument..ValueArgument?), JsExpression>.component1(): (ValueArgument..ValueArgument?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)
    <V> -> JsExpression

'component2' @ [209:41] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(ValueArgument..ValueArgument?), JsExpression>.component2(): JsExpression defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)
    <V> -> JsExpression

'argumentContexts' @ [210:39] ==> val argumentContexts: Map<(ValueArgument..ValueArgument?), TranslationContext> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments[LocalVariableDescriptor]

'arg' @ [210:56] ==> val arg: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[LocalVariableDescriptor]

'arg' @ [211:17] ==> val arg: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[LocalVariableDescriptor]

'argumentContext' @ [211:24] ==> val argumentContext: TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[LocalVariableDescriptor]

'cacheExpressionIfNeeded' @ [211:40] ==> @NotNull public open fun cacheExpressionIfNeeded(@NotNull expression: JsExpression): JsExpression defined in org.jetbrains.kotlin.js.translate.context.TranslationContext[JavaMethodDescriptor]

'expr' @ [211:64] ==> val expr: JsExpression defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[LocalVariableDescriptor]

'toMap' @ [212:15] ==> public fun <K, V> Iterable<Pair<(ValueArgument..ValueArgument?), JsExpression>>.toMap(): Map<(ValueArgument..ValueArgument?), JsExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)
    <V> -> JsExpression

'argumentContexts' @ [215:9] ==> val argumentContexts: Map<(ValueArgument..ValueArgument?), TranslationContext> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments[LocalVariableDescriptor]

'values' @ [215:26] ==> public abstract val values: Collection<TranslationContext> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'forEach' @ [215:33] ==> @HidesMembers public inline fun <T> Iterable<TranslationContext>.forEach(action: (TranslationContext) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TranslationContext

'context' @ [216:13] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments[ValueParameterDescriptorImpl]

'moveVarsFrom' @ [216:21] ==> public open fun moveVarsFrom(@NotNull context: TranslationContext): Unit defined in org.jetbrains.kotlin.js.translate.context.TranslationContext[JavaMethodDescriptor]

'it' @ [216:34] ==> value-parameter it: TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[ValueParameterDescriptorImpl]

'context' @ [217:13] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments[ValueParameterDescriptorImpl]

'addStatementsToCurrentBlockFrom' @ [217:21] ==> public open fun addStatementsToCurrentBlockFrom(@NotNull context: TranslationContext): Unit defined in org.jetbrains.kotlin.js.translate.context.TranslationContext[JavaMethodDescriptor]

'it' @ [217:53] ==> value-parameter it: TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments.<anonymous>[ValueParameterDescriptorImpl]

'result' @ [220:16] ==> var result: Map<(ValueArgument..ValueArgument?), JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateUnresolvedArguments[LocalVariableDescriptor]

'resolvedArgument' @ [229:25] ==> value-parameter resolvedArgument: ResolvedValueArgument defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateVarargArgument[ValueParameterDescriptorImpl]

'arguments' @ [229:42] ==> public final val ResolvedValueArgument.arguments: (MutableList<(ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>)[MyPropertyDescriptor]

'arguments' @ [230:13] ==> val arguments: (MutableList<(ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateVarargArgument[LocalVariableDescriptor]

'isEmpty' @ [230:23] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'if (shouldWrapVarargInArray) {
                return listOf(toArray(varargPrimitiveType, listOf<JsExpression>()))
            }
            else {
                listOf()
            }' @ [231:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<JsExpression>, elseBranch: List<JsExpression>): List<JsExpression>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<JsExpression>

'shouldWrapVarargInArray' @ [231:24] ==> value-parameter shouldWrapVarargInArray: Boolean defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateVarargArgument[ValueParameterDescriptorImpl]

'listOf' @ [232:24] ==> public fun <T> listOf(element: JsExpression): List<JsExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsExpression

'toArray' @ [232:31] ==> private final fun toArray(varargPrimitiveType: PrimitiveType?, elements: List<JsExpression>): JsExpression defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[SimpleFunctionDescriptorImpl]

'varargPrimitiveType' @ [232:39] ==> value-parameter varargPrimitiveType: PrimitiveType? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateVarargArgument[ValueParameterDescriptorImpl]

'listOf' @ [232:60] ==> @InlineOnly public inline fun <T> listOf(): List<JsExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsExpression

'listOf' @ [235:17] ==> @InlineOnly public inline fun <T> listOf(): List<JsExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsExpression

'translateResolvedArgument' @ [239:20] ==> private final fun translateResolvedArgument(resolvedArgument: ResolvedValueArgument, translatedArgs: Map<ValueArgument, JsExpression>): List<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion[SimpleFunctionDescriptorImpl]

'resolvedArgument' @ [239:46] ==> value-parameter resolvedArgument: ResolvedValueArgument defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateVarargArgument[ValueParameterDescriptorImpl]

'translatedArgs' @ [239:64] ==> value-parameter translatedArgs: Map<ValueArgument, JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateVarargArgument[ValueParameterDescriptorImpl]

'if (shouldWrapVarargInArray) {
            val concatArguments = prepareConcatArguments(arguments, list, varargPrimitiveType)
            val concatExpression = concatArgumentsIfNeeded(concatArguments, varargPrimitiveType, false)
            listOf(concatExpression)
        }
        else {
            listOf(JsAstUtils.invokeMethod(list[0], "slice"))
        }' @ [241:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<JsExpression>, elseBranch: List<JsExpression>): List<JsExpression>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<JsExpression>

'shouldWrapVarargInArray' @ [241:20] ==> value-parameter shouldWrapVarargInArray: Boolean defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateVarargArgument[ValueParameterDescriptorImpl]

'prepareConcatArguments' @ [242:35] ==> private final fun prepareConcatArguments(arguments: List<ValueArgument>, list: List<JsExpression>, varargPrimitiveType: PrimitiveType?): MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[SimpleFunctionDescriptorImpl]

'arguments' @ [242:58] ==> val arguments: (MutableList<(ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateVarargArgument[LocalVariableDescriptor]

'list' @ [242:69] ==> val list: List<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateVarargArgument[LocalVariableDescriptor]

'varargPrimitiveType' @ [242:75] ==> value-parameter varargPrimitiveType: PrimitiveType? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateVarargArgument[ValueParameterDescriptorImpl]

'concatArgumentsIfNeeded' @ [243:36] ==> private final fun concatArgumentsIfNeeded(concatArguments: List<JsExpression>, varargPrimitiveType: PrimitiveType?, isMixed: Boolean): JsExpression defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion[SimpleFunctionDescriptorImpl]

'concatArguments' @ [243:60] ==> val concatArguments: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateVarargArgument[LocalVariableDescriptor]

'varargPrimitiveType' @ [243:77] ==> value-parameter varargPrimitiveType: PrimitiveType? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateVarargArgument[ValueParameterDescriptorImpl]

'listOf' @ [244:13] ==> public fun <T> listOf(element: JsExpression): List<JsExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsExpression

'concatExpression' @ [244:20] ==> val concatExpression: JsExpression defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateVarargArgument[LocalVariableDescriptor]

'listOf' @ [247:13] ==> public fun <T> listOf(element: JsInvocation): List<JsInvocation> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsInvocation

'invokeMethod' @ [247:31] ==> @NotNull public open fun invokeMethod(@NotNull thisObject: JsExpression, @NotNull name: String, @NotNull vararg arguments: (JsExpression..JsExpression?)): JsInvocation defined in org.jetbrains.kotlin.js.translate.utils.JsAstUtils[JavaMethodDescriptor]

'list' @ [247:44] ==> val list: List<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.translateVarargArgument[LocalVariableDescriptor]

'ArrayFIF' @ [252:16] ==> public object ArrayFIF : CompositeFIF defined in org.jetbrains.kotlin.js.translate.intrinsic.functions.factories in file ArrayFIF.kt[FakeCallableDescriptorForObject]

'castOrCreatePrimitiveArray' @ [252:25] ==> public final fun castOrCreatePrimitiveArray(ctx: TranslationContext, type: PrimitiveType?, arg: JsArrayLiteral): JsExpression defined in org.jetbrains.kotlin.js.translate.intrinsic.functions.factories.ArrayFIF[SimpleFunctionDescriptorImpl]

'context' @ [252:52] ==> @NotNull protected/*protected and package*/ open fun context(): TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[JavaMethodDescriptor]

'varargPrimitiveType' @ [253:52] ==> value-parameter varargPrimitiveType: PrimitiveType? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.toArray[ValueParameterDescriptorImpl]

'JsArrayLiteral' @ [254:52] ==> public constructor JsArrayLiteral(p0: (MutableList<(JsExpression..JsExpression?)>..List<(JsExpression..JsExpression?)>?)) defined in org.jetbrains.kotlin.js.backend.ast.JsArrayLiteral[JavaClassConstructorDescriptor]

'elements' @ [254:67] ==> value-parameter elements: List<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.toArray[ValueParameterDescriptorImpl]

'apply' @ [254:77] ==> @InlineOnly public inline fun <T> JsArrayLiteral.apply(block: JsArrayLiteral.() -> Unit): JsArrayLiteral defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsArrayLiteral

'sideEffects' @ [254:85] ==> public var HasMetadata.sideEffects: SideEffectKind defined in org.jetbrains.kotlin.js.backend.ast.metadata[DeserializedPropertyDescriptor]

'PURE' @ [254:114] ==> enum entry PURE defined in org.jetbrains.kotlin.js.backend.ast.metadata.SideEffectKind[FakeCallableDescriptorForObject]

'assert' @ [262:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'arguments' @ [262:16] ==> value-parameter arguments: List<ValueArgument> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[ValueParameterDescriptorImpl]

'isNotEmpty' @ [262:26] ==> @InlineOnly public inline fun <T> Collection<ValueArgument>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ValueArgument

'assert' @ [263:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'arguments' @ [263:16] ==> value-parameter arguments: List<ValueArgument> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[ValueParameterDescriptorImpl]

'size' @ [263:26] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'list' @ [263:34] ==> value-parameter list: List<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[ValueParameterDescriptorImpl]

'size' @ [263:39] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'+' @ [263:47] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'arguments' @ [263:68] ==> value-parameter arguments: List<ValueArgument> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[ValueParameterDescriptorImpl]

'size' @ [263:78] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'list' @ [263:105] ==> value-parameter list: List<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[ValueParameterDescriptorImpl]

'size' @ [263:110] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'mutableListOf' @ [265:31] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableListOf(): MutableList<JsExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsExpression

'mutableListOf' @ [266:32] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableListOf(): MutableList<JsExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsExpression

'arguments' @ [268:20] ==> value-parameter arguments: List<ValueArgument> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[ValueParameterDescriptorImpl]

'size' @ [268:30] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'..' @ [269:23] ==> public final operator fun rangeTo(other: Int): IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'size' @ [269:26] ==> val size: Int defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[LocalVariableDescriptor]

'arguments' @ [270:33] ==> value-parameter arguments: List<ValueArgument> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[ValueParameterDescriptorImpl]

'index' @ [270:43] ==> val index: Int defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[LocalVariableDescriptor]

'list' @ [271:38] ==> value-parameter list: List<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[ValueParameterDescriptorImpl]

'index' @ [271:43] ==> val index: Int defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[LocalVariableDescriptor]

'if (valueArgument.getSpreadElement() != null) {
                if (lastArrayContent.size > 0) {
                    concatArguments.add(toArray(varargPrimitiveType, lastArrayContent))
                    lastArrayContent = mutableListOf<JsExpression>()
                }
                concatArguments.add(expressionArgument)
            }
            else {
                lastArrayContent.add(expressionArgument)
            }' @ [273:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Boolean, elseBranch: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Boolean

'valueArgument' @ [273:17] ==> val valueArgument: ValueArgument defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[LocalVariableDescriptor]

'getSpreadElement' @ [273:31] ==> public abstract fun getSpreadElement(): LeafPsiElement? defined in org.jetbrains.kotlin.psi.ValueArgument[DeserializedSimpleFunctionDescriptor]

'lastArrayContent' @ [274:21] ==> var lastArrayContent: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[LocalVariableDescriptor]

'size' @ [274:38] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'concatArguments' @ [275:21] ==> val concatArguments: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[LocalVariableDescriptor]

'add' @ [275:37] ==> public abstract fun add(element: JsExpression): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'toArray' @ [275:41] ==> private final fun toArray(varargPrimitiveType: PrimitiveType?, elements: List<JsExpression>): JsExpression defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[SimpleFunctionDescriptorImpl]

'varargPrimitiveType' @ [275:49] ==> value-parameter varargPrimitiveType: PrimitiveType? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[ValueParameterDescriptorImpl]

'lastArrayContent' @ [275:70] ==> var lastArrayContent: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[LocalVariableDescriptor]

'lastArrayContent' @ [276:21] ==> var lastArrayContent: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[LocalVariableDescriptor]

'mutableListOf' @ [276:40] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableListOf(): MutableList<JsExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsExpression

'concatArguments' @ [278:17] ==> val concatArguments: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[LocalVariableDescriptor]

'add' @ [278:33] ==> public abstract fun add(element: JsExpression): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'expressionArgument' @ [278:37] ==> val expressionArgument: JsExpression defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[LocalVariableDescriptor]

'lastArrayContent' @ [281:17] ==> var lastArrayContent: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[LocalVariableDescriptor]

'add' @ [281:34] ==> public abstract fun add(element: JsExpression): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'expressionArgument' @ [281:38] ==> val expressionArgument: JsExpression defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[LocalVariableDescriptor]

'lastArrayContent' @ [284:13] ==> var lastArrayContent: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[LocalVariableDescriptor]

'size' @ [284:30] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'concatArguments' @ [285:13] ==> val concatArguments: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[LocalVariableDescriptor]

'add' @ [285:29] ==> public abstract fun add(element: JsExpression): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'toArray' @ [285:33] ==> private final fun toArray(varargPrimitiveType: PrimitiveType?, elements: List<JsExpression>): JsExpression defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[SimpleFunctionDescriptorImpl]

'varargPrimitiveType' @ [285:41] ==> value-parameter varargPrimitiveType: PrimitiveType? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[ValueParameterDescriptorImpl]

'lastArrayContent' @ [285:62] ==> var lastArrayContent: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[LocalVariableDescriptor]

'concatArguments' @ [288:16] ==> val concatArguments: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.prepareConcatArguments[LocalVariableDescriptor]

'JvmStatic' @ [293:9] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'translate' @ [294:20] ==> @JvmStatic public final fun translate(resolvedCall: ResolvedCall<*>, receiver: JsExpression?, context: TranslationContext, block: JsBlock): CallArgumentTranslator.ArgumentsInfo defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion[SimpleFunctionDescriptorImpl]

'resolvedCall' @ [294:30] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.translate[ValueParameterDescriptorImpl]

'receiver' @ [294:44] ==> value-parameter receiver: JsExpression? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.translate[ValueParameterDescriptorImpl]

'context' @ [294:54] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.translate[ValueParameterDescriptorImpl]

'context' @ [294:63] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.translate[ValueParameterDescriptorImpl]

'dynamicContext' @ [294:71] ==> @NotNull public open fun dynamicContext(): DynamicContext defined in org.jetbrains.kotlin.js.translate.context.TranslationContext[JavaMethodDescriptor]

'jsBlock' @ [294:88] ==> @NotNull public open fun jsBlock(): JsBlock defined in org.jetbrains.kotlin.js.translate.context.DynamicContext[JavaMethodDescriptor]

'JvmStatic' @ [297:9] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'context' @ [299:32] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.translate[ValueParameterDescriptorImpl]

'innerBlock' @ [299:40] ==> @NotNull public open fun innerBlock(@NotNull block: JsBlock): TranslationContext defined in org.jetbrains.kotlin.js.translate.context.TranslationContext[JavaMethodDescriptor]

'block' @ [299:51] ==> value-parameter block: JsBlock defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.translate[ValueParameterDescriptorImpl]

'CallArgumentTranslator' @ [300:38] ==> private constructor CallArgumentTranslator(resolvedCall: ResolvedCall<*>, receiver: JsExpression?, context: TranslationContext) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[ClassConstructorDescriptorImpl]

'resolvedCall' @ [300:61] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.translate[ValueParameterDescriptorImpl]

'receiver' @ [300:75] ==> value-parameter receiver: JsExpression? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.translate[ValueParameterDescriptorImpl]

'innerContext' @ [300:85] ==> val innerContext: TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.translate[LocalVariableDescriptor]

'argumentTranslator' @ [301:26] ==> val argumentTranslator: CallArgumentTranslator defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.translate[LocalVariableDescriptor]

'translate' @ [301:45] ==> private final fun translate(): CallArgumentTranslator.ArgumentsInfo defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator[SimpleFunctionDescriptorImpl]

'context' @ [302:13] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.translate[ValueParameterDescriptorImpl]

'moveVarsFrom' @ [302:21] ==> public open fun moveVarsFrom(@NotNull context: TranslationContext): Unit defined in org.jetbrains.kotlin.js.translate.context.TranslationContext[JavaMethodDescriptor]

'innerContext' @ [302:34] ==> val innerContext: TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.translate[LocalVariableDescriptor]

'resolvedCall' @ [303:34] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.translate[ValueParameterDescriptorImpl]

'candidateDescriptor' @ [303:47] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.candidateDescriptor: (CallableDescriptor..CallableDescriptor?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(*)

'shouldBeInlined' @ [305:42] ==> public open fun shouldBeInlined(@NotNull descriptor: CallableDescriptor): Boolean defined in org.jetbrains.kotlin.js.translate.reference.CallExpressionTranslator[JavaMethodDescriptor]

'callDescriptor' @ [305:58] ==> val callDescriptor: (CallableDescriptor..CallableDescriptor?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.translate[LocalVariableDescriptor]

'resolvedCall' @ [306:32] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.translate[ValueParameterDescriptorImpl]

'typeArguments' @ [306:45] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.typeArguments: (MutableMap<(TypeParameterDescriptor..TypeParameterDescriptor?), (KotlinType..KotlinType?)>..Map<(TypeParameterDescriptor..TypeParameterDescriptor?), (KotlinType..KotlinType?)>)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(*)

'result' @ [307:24] ==> val result: CallArgumentTranslator.ArgumentsInfo defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.translate[LocalVariableDescriptor]

'copy' @ [307:31] ==> public final fun copy(valueArguments: List<JsExpression> = ..., hasSpreadOperator: Boolean = ..., cachedReceiver: TemporaryConstVariable? = ..., reifiedArguments: List<JsExpression> = ...): CallArgumentTranslator.ArgumentsInfo defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.ArgumentsInfo[SimpleFunctionDescriptorImpl]

'typeArgs' @ [307:55] ==> val typeArgs: (MutableMap<(TypeParameterDescriptor..TypeParameterDescriptor?), (KotlinType..KotlinType?)>..Map<(TypeParameterDescriptor..TypeParameterDescriptor?), (KotlinType..KotlinType?)>) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.translate[LocalVariableDescriptor]

'buildReifiedTypeArgs' @ [307:64] ==> public fun Map<TypeParameterDescriptor, KotlinType>.buildReifiedTypeArgs(context: TranslationContext): List<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference in file CallArgumentTranslator.kt[SimpleFunctionDescriptorImpl]

'context' @ [307:85] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.translate[ValueParameterDescriptorImpl]

'result' @ [310:20] ==> val result: CallArgumentTranslator.ArgumentsInfo defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.translate[LocalVariableDescriptor]

'resolvedArgument' @ [317:17] ==> value-parameter resolvedArgument: ResolvedValueArgument defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.translateResolvedArgument[ValueParameterDescriptorImpl]

'listOf' @ [317:66] ==> public fun <T> listOf(element: JsExpression): List<JsExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsExpression

'getUndefinedExpression' @ [317:79] ==> @NotNull public open fun getUndefinedExpression(): JsExpression defined in org.jetbrains.kotlin.js.translate.context.Namer[JavaMethodDescriptor]

'resolvedArgument' @ [318:20] ==> value-parameter resolvedArgument: ResolvedValueArgument defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.translateResolvedArgument[ValueParameterDescriptorImpl]

'arguments' @ [318:37] ==> public final val ResolvedValueArgument.arguments: (MutableList<(ValueArgument..ValueArgument?)>..List<(ValueArgument..ValueArgument?)>)[MyPropertyDescriptor]

'map' @ [318:47] ==> public inline fun <T, R> Iterable<(ValueArgument..ValueArgument?)>.map(transform: ((ValueArgument..ValueArgument?)) -> JsExpression): List<JsExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.ValueArgument..org.jetbrains.kotlin.psi.ValueArgument?)
    <R> -> JsExpression

'translatedArgs' @ [318:53] ==> value-parameter translatedArgs: Map<ValueArgument, JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.translateResolvedArgument[ValueParameterDescriptorImpl]

'it' @ [318:68] ==> value-parameter it: (ValueArgument..ValueArgument?) defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.translateResolvedArgument.<anonymous>[ValueParameterDescriptorImpl]

'assert' @ [326:13] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'concatArguments' @ [326:20] ==> value-parameter concatArguments: List<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.concatArgumentsIfNeeded[ValueParameterDescriptorImpl]

'isNotEmpty' @ [326:36] ==> @InlineOnly public inline fun <T> Collection<JsExpression>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsExpression

'if (concatArguments.size > 1) {
                if (varargPrimitiveType != null) {
                    val method = if (isMixed) "arrayConcat" else "primitiveArrayConcat"
                    JsAstUtils.invokeKotlinFunction(method, concatArguments[0],
                                                    *concatArguments.subList(1, concatArguments.size).toTypedArray())
                }
                else {
                    JsInvocation(JsNameRef("concat", concatArguments[0]), concatArguments.subList(1, concatArguments.size))
                }
            }
            else {
                concatArguments[0]
            }' @ [328:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: JsExpression, elseBranch: JsExpression): JsExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> JsExpression

'concatArguments' @ [328:24] ==> value-parameter concatArguments: List<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.concatArgumentsIfNeeded[ValueParameterDescriptorImpl]

'size' @ [328:40] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'if (varargPrimitiveType != null) {
                    val method = if (isMixed) "arrayConcat" else "primitiveArrayConcat"
                    JsAstUtils.invokeKotlinFunction(method, concatArguments[0],
                                                    *concatArguments.subList(1, concatArguments.size).toTypedArray())
                }
                else {
                    JsInvocation(JsNameRef("concat", concatArguments[0]), concatArguments.subList(1, concatArguments.size))
                }' @ [329:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: JsInvocation, elseBranch: JsInvocation): JsInvocation[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> JsInvocation

'varargPrimitiveType' @ [329:21] ==> value-parameter varargPrimitiveType: PrimitiveType? defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.concatArgumentsIfNeeded[ValueParameterDescriptorImpl]

'if (isMixed) "arrayConcat" else "primitiveArrayConcat"' @ [330:34] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'isMixed' @ [330:38] ==> value-parameter isMixed: Boolean defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.concatArgumentsIfNeeded[ValueParameterDescriptorImpl]

'invokeKotlinFunction' @ [331:32] ==> @NotNull public open fun invokeKotlinFunction(@NotNull name: String, @NotNull vararg argument: (JsExpression..JsExpression?)): JsInvocation defined in org.jetbrains.kotlin.js.translate.utils.JsAstUtils[JavaMethodDescriptor]

'method' @ [331:53] ==> val method: String defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.concatArgumentsIfNeeded[LocalVariableDescriptor]

'concatArguments' @ [331:61] ==> value-parameter concatArguments: List<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.concatArgumentsIfNeeded[ValueParameterDescriptorImpl]

'concatArguments' @ [332:54] ==> value-parameter concatArguments: List<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.concatArgumentsIfNeeded[ValueParameterDescriptorImpl]

'subList' @ [332:70] ==> public abstract fun subList(fromIndex: Int, toIndex: Int): List<JsExpression> defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'concatArguments' @ [332:81] ==> value-parameter concatArguments: List<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.concatArgumentsIfNeeded[ValueParameterDescriptorImpl]

'size' @ [332:97] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'toTypedArray' @ [332:103] ==> public inline fun <reified T> Collection<JsExpression>.toTypedArray(): Array<JsExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T> -> JsExpression

'JsInvocation' @ [335:21] ==> public constructor JsInvocation(@NotNull p0: JsExpression, @NotNull p1: (MutableList<out (JsExpression..JsExpression?)>..List<(JsExpression..JsExpression?)>)) defined in org.jetbrains.kotlin.js.backend.ast.JsInvocation[JavaClassConstructorDescriptor]

'JsNameRef' @ [335:34] ==> public constructor JsNameRef(@NotNull p0: String, p1: (JsExpression..JsExpression?)) defined in org.jetbrains.kotlin.js.backend.ast.JsNameRef[JavaClassConstructorDescriptor]

'concatArguments' @ [335:54] ==> value-parameter concatArguments: List<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.concatArgumentsIfNeeded[ValueParameterDescriptorImpl]

'concatArguments' @ [335:75] ==> value-parameter concatArguments: List<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.concatArgumentsIfNeeded[ValueParameterDescriptorImpl]

'subList' @ [335:91] ==> public abstract fun subList(fromIndex: Int, toIndex: Int): List<JsExpression> defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'concatArguments' @ [335:102] ==> value-parameter concatArguments: List<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.concatArgumentsIfNeeded[ValueParameterDescriptorImpl]

'size' @ [335:118] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'concatArguments' @ [339:17] ==> value-parameter concatArguments: List<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.CallArgumentTranslator.Companion.concatArgumentsIfNeeded[ValueParameterDescriptorImpl]

'mutableListOf' @ [346:32] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableListOf(): MutableList<JsExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsExpression

'newInstance' @ [347:47] ==> @NotNull public open fun newInstance(@NotNull context: TranslationContext): PatternTranslator defined in org.jetbrains.kotlin.js.translate.expression.PatternTranslator[JavaMethodDescriptor]

'context' @ [347:59] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.buildReifiedTypeArgs[ValueParameterDescriptorImpl]

'keys' @ [349:19] ==> public abstract val keys: Set<TypeParameterDescriptor> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'sortedBy' @ [349:24] ==> public inline fun <T, R : Comparable<Int>> Iterable<TypeParameterDescriptor>.sortedBy(crossinline selector: (TypeParameterDescriptor) -> Int?): List<TypeParameterDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeParameterDescriptor
    <R : Comparable<R>> -> Int

'it' @ [349:35] ==> value-parameter it: TypeParameterDescriptor defined in org.jetbrains.kotlin.js.translate.reference.buildReifiedTypeArgs.<anonymous>[ValueParameterDescriptorImpl]

'index' @ [349:38] ==> public final val TypeParameterDescriptor.index: Int[MyPropertyDescriptor]

'!' @ [350:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'param' @ [350:14] ==> val param: TypeParameterDescriptor defined in org.jetbrains.kotlin.js.translate.reference.buildReifiedTypeArgs[LocalVariableDescriptor]

'isReified' @ [350:20] ==> public final val TypeParameterDescriptor.isReified: Boolean[MyPropertyDescriptor]

'get' @ [352:28] ==> public abstract operator fun get(key: TypeParameterDescriptor): KotlinType? defined in kotlin.collections.Map[DeserializedSimpleFunctionDescriptor]

'param' @ [352:32] ==> val param: TypeParameterDescriptor defined in org.jetbrains.kotlin.js.translate.reference.buildReifiedTypeArgs[LocalVariableDescriptor]

'reifiedTypeArguments' @ [354:9] ==> val reifiedTypeArguments: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.buildReifiedTypeArgs[LocalVariableDescriptor]

'add' @ [354:30] ==> public abstract fun add(element: JsExpression): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'getReferenceToJsClass' @ [354:34] ==> public fun getReferenceToJsClass(type: KotlinType, context: TranslationContext): JsExpression defined in org.jetbrains.kotlin.js.translate.utils in file utils.kt[SimpleFunctionDescriptorImpl]

'argumentType' @ [354:56] ==> val argumentType: KotlinType defined in org.jetbrains.kotlin.js.translate.reference.buildReifiedTypeArgs[LocalVariableDescriptor]

'context' @ [354:70] ==> value-parameter context: TranslationContext defined in org.jetbrains.kotlin.js.translate.reference.buildReifiedTypeArgs[ValueParameterDescriptorImpl]

'patternTranslator' @ [356:31] ==> val patternTranslator: PatternTranslator defined in org.jetbrains.kotlin.js.translate.reference.buildReifiedTypeArgs[LocalVariableDescriptor]

'getIsTypeCheckCallable' @ [356:49] ==> @NotNull public open fun getIsTypeCheckCallable(@NotNull type: KotlinType): JsExpression defined in org.jetbrains.kotlin.js.translate.expression.PatternTranslator[JavaMethodDescriptor]

'argumentType' @ [356:72] ==> val argumentType: KotlinType defined in org.jetbrains.kotlin.js.translate.reference.buildReifiedTypeArgs[LocalVariableDescriptor]

'reifiedTypeArguments' @ [357:9] ==> val reifiedTypeArguments: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.buildReifiedTypeArgs[LocalVariableDescriptor]

'add' @ [357:30] ==> public abstract fun add(element: JsExpression): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'isCheckCallable' @ [357:34] ==> val isCheckCallable: JsExpression defined in org.jetbrains.kotlin.js.translate.reference.buildReifiedTypeArgs[LocalVariableDescriptor]

'reifiedTypeArguments' @ [360:12] ==> val reifiedTypeArguments: MutableList<JsExpression> defined in org.jetbrains.kotlin.js.translate.reference.buildReifiedTypeArgs[LocalVariableDescriptor]

