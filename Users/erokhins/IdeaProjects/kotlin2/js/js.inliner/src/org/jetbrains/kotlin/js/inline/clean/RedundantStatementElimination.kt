'root' @ [28:29] ==> private final val root: JsFunction defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[PropertyDescriptorImpl]

'collectLocalVariables' @ [28:34] ==> public fun JsFunction.collectLocalVariables(): Set<JsName> defined in org.jetbrains.kotlin.js.inline.util in file collectUtils.kt[SimpleFunctionDescriptorImpl]

'process' @ [32:9] ==> private final fun process(): Unit defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[SimpleFunctionDescriptorImpl]

'hasChanges' @ [33:16] ==> private final var hasChanges: Boolean defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[PropertyDescriptorImpl]

'JsVisitorWithContextImpl' @ [37:18] ==> public constructor JsVisitorWithContextImpl() defined in org.jetbrains.kotlin.js.backend.ast.JsVisitorWithContextImpl[JavaClassConstructorDescriptor]

'!' @ [39:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'x' @ [39:22] ==> value-parameter x: JsExpressionStatement defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>.visit[ValueParameterDescriptorImpl]

'expression' @ [39:24] ==> public final val JsExpressionStatement.expression: JsExpression[MyPropertyDescriptor]

'isSuspend' @ [39:35] ==> public var JsExpression.isSuspend: Boolean defined in org.jetbrains.kotlin.js.backend.ast.metadata[DeserializedPropertyDescriptor]

'x' @ [39:49] ==> value-parameter x: JsExpressionStatement defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>.visit[ValueParameterDescriptorImpl]

'synthetic' @ [39:51] ==> public var HasMetadata.synthetic: Boolean defined in org.jetbrains.kotlin.js.backend.ast.metadata[DeserializedPropertyDescriptor]

'x' @ [39:64] ==> value-parameter x: JsExpressionStatement defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>.visit[ValueParameterDescriptorImpl]

'expression' @ [39:66] ==> public final val JsExpressionStatement.expression: JsExpression[MyPropertyDescriptor]

'synthetic' @ [39:77] ==> public var HasMetadata.synthetic: Boolean defined in org.jetbrains.kotlin.js.backend.ast.metadata[DeserializedPropertyDescriptor]

'replace' @ [40:39] ==> private final fun replace(expression: JsExpression): List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[SimpleFunctionDescriptorImpl]

'x' @ [40:47] ==> value-parameter x: JsExpressionStatement defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>.visit[ValueParameterDescriptorImpl]

'expression' @ [40:49] ==> public final val JsExpressionStatement.expression: JsExpression[MyPropertyDescriptor]

'replacement' @ [41:25] ==> val replacement: List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>.visit[LocalVariableDescriptor]

'size' @ [41:37] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'replacement' @ [41:50] ==> val replacement: List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>.visit[LocalVariableDescriptor]

'x' @ [41:68] ==> value-parameter x: JsExpressionStatement defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>.visit[ValueParameterDescriptorImpl]

'expression' @ [41:70] ==> public final val JsExpressionStatement.expression: JsExpression[MyPropertyDescriptor]

'hasChanges' @ [42:25] ==> private final var hasChanges: Boolean defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[PropertyDescriptorImpl]

'ctx' @ [43:25] ==> value-parameter ctx: JsContext<JsNode> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>.visit[ValueParameterDescriptorImpl]

'addPrevious' @ [43:29] ==> public open fun <R : (JsNode..JsNode?)> addPrevious(p0: (MutableList<(JsExpressionStatement..JsExpressionStatement?)>..List<(JsExpressionStatement..JsExpressionStatement?)>?)): Unit defined in org.jetbrains.kotlin.js.backend.ast.JsContext[JavaMethodDescriptor]
Inferred types:
    <R : (JsNode..JsNode?)> -> (org.jetbrains.kotlin.js.backend.ast.JsExpressionStatement..org.jetbrains.kotlin.js.backend.ast.JsExpressionStatement?)

'replacement' @ [43:41] ==> val replacement: List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>.visit[LocalVariableDescriptor]

'map' @ [43:53] ==> public inline fun <T, R> Iterable<JsExpression>.map(transform: (JsExpression) -> JsExpressionStatement): List<JsExpressionStatement> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsExpression
    <R> -> JsExpressionStatement

'JsExpressionStatement' @ [43:59] ==> public constructor JsExpressionStatement(@NotNull p0: JsExpression) defined in org.jetbrains.kotlin.js.backend.ast.JsExpressionStatement[JavaClassConstructorDescriptor]

'it' @ [43:81] ==> value-parameter it: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>.visit.<anonymous>[ValueParameterDescriptorImpl]

'apply' @ [43:85] ==> @InlineOnly public inline fun <T> JsExpressionStatement.apply(block: JsExpressionStatement.() -> Unit): JsExpressionStatement defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsExpressionStatement

'synthetic' @ [43:93] ==> public var HasMetadata.synthetic: Boolean defined in org.jetbrains.kotlin.js.backend.ast.metadata[DeserializedPropertyDescriptor]

'ctx' @ [44:25] ==> value-parameter ctx: JsContext<JsNode> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>.visit[ValueParameterDescriptorImpl]

'removeMe' @ [44:29] ==> public abstract fun removeMe(): Unit defined in org.jetbrains.kotlin.js.backend.ast.JsContext[JavaMethodDescriptor]

'super' @ [47:24] ==> <this> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>[LazyClassReceiverParameterDescriptor]

'visit' @ [47:30] ==> public open fun visit(@NotNull p0: JsExpressionStatement, @NotNull p1: raw (JsContext<(JsNode..JsNode?)>..JsContext<*>)): Boolean defined in org.jetbrains.kotlin.js.backend.ast.JsVisitorWithContextImpl[JavaMethodDescriptor]

'x' @ [47:36] ==> value-parameter x: JsExpressionStatement defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>.visit[ValueParameterDescriptorImpl]

'ctx' @ [47:39] ==> value-parameter ctx: JsContext<JsNode> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>.visit[ValueParameterDescriptorImpl]

'!' @ [51:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'x' @ [51:22] ==> value-parameter x: JsBinaryOperation defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>.visit[ValueParameterDescriptorImpl]

'isSuspend' @ [51:24] ==> public var JsExpression.isSuspend: Boolean defined in org.jetbrains.kotlin.js.backend.ast.metadata[DeserializedPropertyDescriptor]

'x' @ [51:37] ==> value-parameter x: JsBinaryOperation defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>.visit[ValueParameterDescriptorImpl]

'operator' @ [51:39] ==> public final val JsBinaryOperation.operator: JsBinaryOperator[MyPropertyDescriptor]

'COMMA' @ [51:68] ==> enum entry COMMA defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'replace' @ [52:39] ==> private final fun replace(expression: JsExpression): List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[SimpleFunctionDescriptorImpl]

'x' @ [52:47] ==> value-parameter x: JsBinaryOperation defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>.visit[ValueParameterDescriptorImpl]

'arg1' @ [52:49] ==> public final var JsBinaryOperation.arg1: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'if (expressions.isEmpty()) {
                        x.arg2
                    }
                    else {
                        JsAstUtils.newSequence(expressions + x.arg2)
                    }' @ [53:39] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (JsExpression..JsExpression?), elseBranch: (JsExpression..JsExpression?)): (JsExpression..JsExpression?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (org.jetbrains.kotlin.js.backend.ast.JsExpression..org.jetbrains.kotlin.js.backend.ast.JsExpression?)

'expressions' @ [53:43] ==> val expressions: List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>.visit[LocalVariableDescriptor]

'isEmpty' @ [53:55] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'x' @ [54:25] ==> value-parameter x: JsBinaryOperation defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>.visit[ValueParameterDescriptorImpl]

'arg2' @ [54:27] ==> public final var JsBinaryOperation.arg2: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'newSequence' @ [57:36] ==> @NotNull public open fun newSequence(@NotNull expressions: (MutableList<(JsExpression..JsExpression?)>..List<(JsExpression..JsExpression?)>)): JsExpression defined in org.jetbrains.kotlin.js.translate.utils.JsAstUtils[JavaMethodDescriptor]

'expressions' @ [57:48] ==> val expressions: List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>.visit[LocalVariableDescriptor]

'x' @ [57:62] ==> value-parameter x: JsBinaryOperation defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>.visit[ValueParameterDescriptorImpl]

'arg2' @ [57:64] ==> public final var JsBinaryOperation.arg2: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'ctx' @ [59:21] ==> value-parameter ctx: JsContext<JsNode> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>.visit[ValueParameterDescriptorImpl]

'replaceMe' @ [59:25] ==> public abstract fun <R : (JsNode..JsNode?)> replaceMe(p0: (JsExpression..JsExpression?)): Unit defined in org.jetbrains.kotlin.js.backend.ast.JsContext[JavaMethodDescriptor]
Inferred types:
    <R : (JsNode..JsNode?)> -> (org.jetbrains.kotlin.js.backend.ast.JsExpression..org.jetbrains.kotlin.js.backend.ast.JsExpression?)

'replacement' @ [59:35] ==> val replacement: (JsExpression..JsExpression?) defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>.visit[LocalVariableDescriptor]

'super' @ [61:24] ==> <this> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>[LazyClassReceiverParameterDescriptor]

'visit' @ [61:30] ==> public open fun visit(@NotNull p0: JsBinaryOperation, @NotNull p1: raw (JsContext<(JsNode..JsNode?)>..JsContext<*>)): Boolean defined in org.jetbrains.kotlin.js.backend.ast.JsVisitorWithContextImpl[JavaMethodDescriptor]

'x' @ [61:36] ==> value-parameter x: JsBinaryOperation defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>.visit[ValueParameterDescriptorImpl]

'ctx' @ [61:39] ==> value-parameter ctx: JsContext<JsNode> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>.visit[ValueParameterDescriptorImpl]

'accept' @ [63:11] ==> public final fun <T : (JsNode..JsNode?)> accept(p0: (JsBlock..JsBlock?)): (JsBlock..JsBlock?) defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.process.<no name provided>[JavaMethodDescriptor]
Inferred types:
    <T : (JsNode..JsNode?)> -> (org.jetbrains.kotlin.js.backend.ast.JsBlock..org.jetbrains.kotlin.js.backend.ast.JsBlock?)

'root' @ [63:18] ==> private final val root: JsFunction defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[PropertyDescriptorImpl]

'body' @ [63:23] ==> public final var JsFunction.body: JsBlock[MyPropertyDescriptor]

'when (expression) {
            is JsNameRef -> {
                when {
                    expression.name in localVars -> {
                        listOf()
                    }
                    expression.sideEffects != SideEffectKind.AFFECTS_STATE -> {
                        val qualifier = expression.qualifier
                        if (qualifier != null) replace(qualifier) else listOf()
                    }
                    else -> {
                        listOf(expression)
                    }
                }
            }

            is JsUnaryOperation -> {
                when (expression.operator!!) {
                    JsUnaryOperator.BIT_NOT,
                    JsUnaryOperator.NOT,
                    JsUnaryOperator.TYPEOF,
                    JsUnaryOperator.VOID,
                    JsUnaryOperator.POS,
                    JsUnaryOperator.NEG -> replace(expression.arg)

                    JsUnaryOperator.DEC,
                    JsUnaryOperator.INC,
                    JsUnaryOperator.DELETE -> listOf(expression)
                }
            }

            is JsBinaryOperation -> {
                when (expression.operator) {
                    JsBinaryOperator.BIT_AND,
                    JsBinaryOperator.BIT_OR,
                    JsBinaryOperator.BIT_XOR,
                    JsBinaryOperator.COMMA,
                    JsBinaryOperator.ADD,
                    JsBinaryOperator.SUB,
                    JsBinaryOperator.MUL,
                    JsBinaryOperator.DIV,
                    JsBinaryOperator.MOD,
                    JsBinaryOperator.EQ,
                    JsBinaryOperator.NEQ,
                    JsBinaryOperator.REF_EQ,
                    JsBinaryOperator.REF_NEQ,
                    JsBinaryOperator.GT,
                    JsBinaryOperator.GTE,
                    JsBinaryOperator.LT,
                    JsBinaryOperator.LTE,
                    JsBinaryOperator.SHL,
                    JsBinaryOperator.SHR,
                    JsBinaryOperator.SHRU -> replace(expression.arg1) + replace(expression.arg2)

                    JsBinaryOperator.AND,
                    JsBinaryOperator.OR -> {
                        val right = replace(expression.arg2)
                        if (right.isEmpty()) replace(expression.arg1) else listOf(expression)
                    }

                    JsBinaryOperator.INOP,
                    JsBinaryOperator.INSTANCEOF -> listOf(expression)

                    JsBinaryOperator.ASG,
                    JsBinaryOperator.ASG_ADD,
                    JsBinaryOperator.ASG_SUB,
                    JsBinaryOperator.ASG_MUL,
                    JsBinaryOperator.ASG_DIV,
                    JsBinaryOperator.ASG_MOD,
                    JsBinaryOperator.ASG_BIT_AND,
                    JsBinaryOperator.ASG_BIT_OR,
                    JsBinaryOperator.ASG_BIT_XOR,
                    JsBinaryOperator.ASG_SHL,
                    JsBinaryOperator.ASG_SHR,
                    JsBinaryOperator.ASG_SHRU -> listOf(expression)
                }
            }

            is JsInvocation -> {
                if (expression.sideEffects != SideEffectKind.AFFECTS_STATE) {
                    replace(expression.qualifier) + replaceMany(expression.arguments)
                }
                else {
                    listOf(expression)
                }
            }

            is JsNew -> {
                if (expression.sideEffects != SideEffectKind.AFFECTS_STATE) {
                    replace(expression.constructorExpression) + replaceMany(expression.arguments)
                }
                else {
                    listOf(expression)
                }
            }

            is JsConditional -> {
                val thenExpr = replace(expression.thenExpression)
                val elseExpr = replace(expression.elseExpression)
                // TODO: consider case like this one: cond ? se() + 1 : se() + 2
                when {
                    thenExpr.isEmpty() && elseExpr.isEmpty() -> replace(expression.testExpression)
                    thenExpr.isEmpty() -> listOf(JsAstUtils.or(expression.testExpression, expression.elseExpression))
                    elseExpr.isEmpty() -> listOf(JsAstUtils.and(expression.testExpression, expression.thenExpression))
                    else -> listOf(expression)
                }
            }

            // Although it can be suspicious case, sometimes it really helps.
            // Consider the following case: `Kotlin.modules['foo'].bar()`, where `bar` is inlineable. Expression decomposer produces
            //   var $tmp = Kotlin.modules['foo'];
            //   $tmp.bar();
            // Then, inlined body of `bar` never uses `$tmp`, therefore we can eliminate it, so `Kotlin.modules['foo']` remains.
            // It's good to eliminate such useless expression.
            is JsArrayAccess -> {
                if (expression.sideEffects != SideEffectKind.AFFECTS_STATE) {
                    replace(expression.arrayExpression) + replace(expression.indexExpression)
                }
                else {
                    listOf(expression)
                }
            }

            is JsLiteral.JsValueLiteral -> listOf()

            is JsArrayLiteral -> replaceMany(expression.expressions)

            is JsObjectLiteral -> expression.propertyInitializers.flatMap { replace(it.labelExpr) + replace(it.valueExpr) }

            is JsFunction -> if (expression.name == null) listOf() else listOf(expression)

            else -> listOf(expression)
        }' @ [67:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: List<JsExpression>, entry1: List<JsExpression>, entry2: List<JsExpression>, entry3: List<JsExpression>, entry4: List<JsExpression>, entry5: List<JsExpression>, entry6: List<JsExpression>, entry7: List<JsExpression>, entry8: List<JsExpression>, entry9: List<JsExpression>, entry10: List<JsExpression>, entry11: List<JsExpression>): List<JsExpression>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> List<JsExpression>

'expression' @ [67:22] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'when {
                    expression.name in localVars -> {
                        listOf()
                    }
                    expression.sideEffects != SideEffectKind.AFFECTS_STATE -> {
                        val qualifier = expression.qualifier
                        if (qualifier != null) replace(qualifier) else listOf()
                    }
                    else -> {
                        listOf(expression)
                    }
                }' @ [69:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: List<JsExpression>, entry1: List<JsExpression>, entry2: List<JsExpression>): List<JsExpression>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> List<JsExpression>

'expression' @ [70:21] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'name' @ [70:32] ==> public final var JsNameRef.name: JsName?[MyPropertyDescriptor]

'localVars' @ [70:40] ==> private final val localVars: Set<JsName> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[PropertyDescriptorImpl]

'listOf' @ [71:25] ==> @InlineOnly public inline fun <T> listOf(): List<JsExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsExpression

'expression' @ [73:21] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'sideEffects' @ [73:32] ==> public var HasMetadata.sideEffects: SideEffectKind defined in org.jetbrains.kotlin.js.backend.ast.metadata[DeserializedPropertyDescriptor]

'AFFECTS_STATE' @ [73:62] ==> enum entry AFFECTS_STATE defined in org.jetbrains.kotlin.js.backend.ast.metadata.SideEffectKind[FakeCallableDescriptorForObject]

'expression' @ [74:41] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'qualifier' @ [74:52] ==> public final var JsNameRef.qualifier: JsExpression?[MyPropertyDescriptor]

'if (qualifier != null) replace(qualifier) else listOf()' @ [75:25] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<JsExpression>, elseBranch: List<JsExpression>): List<JsExpression>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<JsExpression>

'qualifier' @ [75:29] ==> val qualifier: JsExpression? defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[LocalVariableDescriptor]

'replace' @ [75:48] ==> private final fun replace(expression: JsExpression): List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[SimpleFunctionDescriptorImpl]

'qualifier' @ [75:56] ==> val qualifier: JsExpression? defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[LocalVariableDescriptor]

'listOf' @ [75:72] ==> @InlineOnly public inline fun <T> listOf(): List<JsExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsExpression

'listOf' @ [78:25] ==> public fun <T> listOf(element: JsNameRef): List<JsNameRef> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsNameRef

'expression' @ [78:32] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'when (expression.operator!!) {
                    JsUnaryOperator.BIT_NOT,
                    JsUnaryOperator.NOT,
                    JsUnaryOperator.TYPEOF,
                    JsUnaryOperator.VOID,
                    JsUnaryOperator.POS,
                    JsUnaryOperator.NEG -> replace(expression.arg)

                    JsUnaryOperator.DEC,
                    JsUnaryOperator.INC,
                    JsUnaryOperator.DELETE -> listOf(expression)
                }' @ [84:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: List<JsExpression>, entry1: List<JsExpression>): List<JsExpression>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> List<JsExpression>

'expression' @ [84:23] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'operator' @ [84:34] ==> public final val JsUnaryOperation.operator: (JsUnaryOperator..JsUnaryOperator?)[MyPropertyDescriptor]

'BIT_NOT' @ [85:37] ==> enum entry BIT_NOT defined in org.jetbrains.kotlin.js.backend.ast.JsUnaryOperator[FakeCallableDescriptorForObject]

'NOT' @ [86:37] ==> enum entry NOT defined in org.jetbrains.kotlin.js.backend.ast.JsUnaryOperator[FakeCallableDescriptorForObject]

'TYPEOF' @ [87:37] ==> enum entry TYPEOF defined in org.jetbrains.kotlin.js.backend.ast.JsUnaryOperator[FakeCallableDescriptorForObject]

'VOID' @ [88:37] ==> enum entry VOID defined in org.jetbrains.kotlin.js.backend.ast.JsUnaryOperator[FakeCallableDescriptorForObject]

'POS' @ [89:37] ==> enum entry POS defined in org.jetbrains.kotlin.js.backend.ast.JsUnaryOperator[FakeCallableDescriptorForObject]

'NEG' @ [90:37] ==> enum entry NEG defined in org.jetbrains.kotlin.js.backend.ast.JsUnaryOperator[FakeCallableDescriptorForObject]

'replace' @ [90:44] ==> private final fun replace(expression: JsExpression): List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[SimpleFunctionDescriptorImpl]

'expression' @ [90:52] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'arg' @ [90:63] ==> public final var JsUnaryOperation.arg: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'DEC' @ [92:37] ==> enum entry DEC defined in org.jetbrains.kotlin.js.backend.ast.JsUnaryOperator[FakeCallableDescriptorForObject]

'INC' @ [93:37] ==> enum entry INC defined in org.jetbrains.kotlin.js.backend.ast.JsUnaryOperator[FakeCallableDescriptorForObject]

'DELETE' @ [94:37] ==> enum entry DELETE defined in org.jetbrains.kotlin.js.backend.ast.JsUnaryOperator[FakeCallableDescriptorForObject]

'listOf' @ [94:47] ==> public fun <T> listOf(element: JsUnaryOperation): List<JsUnaryOperation> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsUnaryOperation

'expression' @ [94:54] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'when (expression.operator) {
                    JsBinaryOperator.BIT_AND,
                    JsBinaryOperator.BIT_OR,
                    JsBinaryOperator.BIT_XOR,
                    JsBinaryOperator.COMMA,
                    JsBinaryOperator.ADD,
                    JsBinaryOperator.SUB,
                    JsBinaryOperator.MUL,
                    JsBinaryOperator.DIV,
                    JsBinaryOperator.MOD,
                    JsBinaryOperator.EQ,
                    JsBinaryOperator.NEQ,
                    JsBinaryOperator.REF_EQ,
                    JsBinaryOperator.REF_NEQ,
                    JsBinaryOperator.GT,
                    JsBinaryOperator.GTE,
                    JsBinaryOperator.LT,
                    JsBinaryOperator.LTE,
                    JsBinaryOperator.SHL,
                    JsBinaryOperator.SHR,
                    JsBinaryOperator.SHRU -> replace(expression.arg1) + replace(expression.arg2)

                    JsBinaryOperator.AND,
                    JsBinaryOperator.OR -> {
                        val right = replace(expression.arg2)
                        if (right.isEmpty()) replace(expression.arg1) else listOf(expression)
                    }

                    JsBinaryOperator.INOP,
                    JsBinaryOperator.INSTANCEOF -> listOf(expression)

                    JsBinaryOperator.ASG,
                    JsBinaryOperator.ASG_ADD,
                    JsBinaryOperator.ASG_SUB,
                    JsBinaryOperator.ASG_MUL,
                    JsBinaryOperator.ASG_DIV,
                    JsBinaryOperator.ASG_MOD,
                    JsBinaryOperator.ASG_BIT_AND,
                    JsBinaryOperator.ASG_BIT_OR,
                    JsBinaryOperator.ASG_BIT_XOR,
                    JsBinaryOperator.ASG_SHL,
                    JsBinaryOperator.ASG_SHR,
                    JsBinaryOperator.ASG_SHRU -> listOf(expression)
                }' @ [99:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: List<JsExpression>, entry1: List<JsExpression>, entry2: List<JsExpression>, entry3: List<JsExpression>): List<JsExpression>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> List<JsExpression>

'expression' @ [99:23] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'operator' @ [99:34] ==> public final val JsBinaryOperation.operator: JsBinaryOperator[MyPropertyDescriptor]

'BIT_AND' @ [100:38] ==> enum entry BIT_AND defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'BIT_OR' @ [101:38] ==> enum entry BIT_OR defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'BIT_XOR' @ [102:38] ==> enum entry BIT_XOR defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'COMMA' @ [103:38] ==> enum entry COMMA defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'ADD' @ [104:38] ==> enum entry ADD defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'SUB' @ [105:38] ==> enum entry SUB defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'MUL' @ [106:38] ==> enum entry MUL defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'DIV' @ [107:38] ==> enum entry DIV defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'MOD' @ [108:38] ==> enum entry MOD defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'EQ' @ [109:38] ==> enum entry EQ defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'NEQ' @ [110:38] ==> enum entry NEQ defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'REF_EQ' @ [111:38] ==> enum entry REF_EQ defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'REF_NEQ' @ [112:38] ==> enum entry REF_NEQ defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'GT' @ [113:38] ==> enum entry GT defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'GTE' @ [114:38] ==> enum entry GTE defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'LT' @ [115:38] ==> enum entry LT defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'LTE' @ [116:38] ==> enum entry LTE defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'SHL' @ [117:38] ==> enum entry SHL defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'SHR' @ [118:38] ==> enum entry SHR defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'SHRU' @ [119:38] ==> enum entry SHRU defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'replace' @ [119:46] ==> private final fun replace(expression: JsExpression): List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[SimpleFunctionDescriptorImpl]

'expression' @ [119:54] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'arg1' @ [119:65] ==> public final var JsBinaryOperation.arg1: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'replace' @ [119:73] ==> private final fun replace(expression: JsExpression): List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[SimpleFunctionDescriptorImpl]

'expression' @ [119:81] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'arg2' @ [119:92] ==> public final var JsBinaryOperation.arg2: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'AND' @ [121:38] ==> enum entry AND defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'OR' @ [122:38] ==> enum entry OR defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'replace' @ [123:37] ==> private final fun replace(expression: JsExpression): List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[SimpleFunctionDescriptorImpl]

'expression' @ [123:45] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'arg2' @ [123:56] ==> public final var JsBinaryOperation.arg2: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'if (right.isEmpty()) replace(expression.arg1) else listOf(expression)' @ [124:25] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<JsExpression>, elseBranch: List<JsExpression>): List<JsExpression>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<JsExpression>

'right' @ [124:29] ==> val right: List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[LocalVariableDescriptor]

'isEmpty' @ [124:35] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'replace' @ [124:46] ==> private final fun replace(expression: JsExpression): List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[SimpleFunctionDescriptorImpl]

'expression' @ [124:54] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'arg1' @ [124:65] ==> public final var JsBinaryOperation.arg1: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'listOf' @ [124:76] ==> public fun <T> listOf(element: JsBinaryOperation): List<JsBinaryOperation> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsBinaryOperation

'expression' @ [124:83] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'INOP' @ [127:38] ==> enum entry INOP defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'INSTANCEOF' @ [128:38] ==> enum entry INSTANCEOF defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'listOf' @ [128:52] ==> public fun <T> listOf(element: JsBinaryOperation): List<JsBinaryOperation> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsBinaryOperation

'expression' @ [128:59] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'ASG' @ [130:38] ==> enum entry ASG defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'ASG_ADD' @ [131:38] ==> enum entry ASG_ADD defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'ASG_SUB' @ [132:38] ==> enum entry ASG_SUB defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'ASG_MUL' @ [133:38] ==> enum entry ASG_MUL defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'ASG_DIV' @ [134:38] ==> enum entry ASG_DIV defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'ASG_MOD' @ [135:38] ==> enum entry ASG_MOD defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'ASG_BIT_AND' @ [136:38] ==> enum entry ASG_BIT_AND defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'ASG_BIT_OR' @ [137:38] ==> enum entry ASG_BIT_OR defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'ASG_BIT_XOR' @ [138:38] ==> enum entry ASG_BIT_XOR defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'ASG_SHL' @ [139:38] ==> enum entry ASG_SHL defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'ASG_SHR' @ [140:38] ==> enum entry ASG_SHR defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'ASG_SHRU' @ [141:38] ==> enum entry ASG_SHRU defined in org.jetbrains.kotlin.js.backend.ast.JsBinaryOperator[FakeCallableDescriptorForObject]

'listOf' @ [141:50] ==> public fun <T> listOf(element: JsBinaryOperation): List<JsBinaryOperation> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsBinaryOperation

'expression' @ [141:57] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'if (expression.sideEffects != SideEffectKind.AFFECTS_STATE) {
                    replace(expression.qualifier) + replaceMany(expression.arguments)
                }
                else {
                    listOf(expression)
                }' @ [146:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<JsExpression>, elseBranch: List<JsExpression>): List<JsExpression>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<JsExpression>

'expression' @ [146:21] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'sideEffects' @ [146:32] ==> public var HasMetadata.sideEffects: SideEffectKind defined in org.jetbrains.kotlin.js.backend.ast.metadata[DeserializedPropertyDescriptor]

'AFFECTS_STATE' @ [146:62] ==> enum entry AFFECTS_STATE defined in org.jetbrains.kotlin.js.backend.ast.metadata.SideEffectKind[FakeCallableDescriptorForObject]

'replace' @ [147:21] ==> private final fun replace(expression: JsExpression): List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[SimpleFunctionDescriptorImpl]

'expression' @ [147:29] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'qualifier' @ [147:40] ==> public final var JsInvocation.qualifier: JsExpression[MyPropertyDescriptor]

'replaceMany' @ [147:53] ==> private final fun replaceMany(expressions: List<JsExpression>): List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[SimpleFunctionDescriptorImpl]

'expression' @ [147:65] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'arguments' @ [147:76] ==> public final val JsInvocation.arguments: (MutableList<(JsExpression..JsExpression?)>..List<(JsExpression..JsExpression?)>)[MyPropertyDescriptor]

'listOf' @ [150:21] ==> public fun <T> listOf(element: JsInvocation): List<JsInvocation> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsInvocation

'expression' @ [150:28] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'if (expression.sideEffects != SideEffectKind.AFFECTS_STATE) {
                    replace(expression.constructorExpression) + replaceMany(expression.arguments)
                }
                else {
                    listOf(expression)
                }' @ [155:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<JsExpression>, elseBranch: List<JsExpression>): List<JsExpression>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<JsExpression>

'expression' @ [155:21] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'sideEffects' @ [155:32] ==> public var HasMetadata.sideEffects: SideEffectKind defined in org.jetbrains.kotlin.js.backend.ast.metadata[DeserializedPropertyDescriptor]

'AFFECTS_STATE' @ [155:62] ==> enum entry AFFECTS_STATE defined in org.jetbrains.kotlin.js.backend.ast.metadata.SideEffectKind[FakeCallableDescriptorForObject]

'replace' @ [156:21] ==> private final fun replace(expression: JsExpression): List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[SimpleFunctionDescriptorImpl]

'expression' @ [156:29] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'constructorExpression' @ [156:40] ==> public final var JsNew.constructorExpression: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'replaceMany' @ [156:65] ==> private final fun replaceMany(expressions: List<JsExpression>): List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[SimpleFunctionDescriptorImpl]

'expression' @ [156:77] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'arguments' @ [156:88] ==> public final val JsNew.arguments: (MutableList<(JsExpression..JsExpression?)>..List<(JsExpression..JsExpression?)>?)[MyPropertyDescriptor]

'listOf' @ [159:21] ==> public fun <T> listOf(element: JsNew): List<JsNew> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsNew

'expression' @ [159:28] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'replace' @ [164:32] ==> private final fun replace(expression: JsExpression): List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[SimpleFunctionDescriptorImpl]

'expression' @ [164:40] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'thenExpression' @ [164:51] ==> public final var JsConditional.thenExpression: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'replace' @ [165:32] ==> private final fun replace(expression: JsExpression): List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[SimpleFunctionDescriptorImpl]

'expression' @ [165:40] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'elseExpression' @ [165:51] ==> public final var JsConditional.elseExpression: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'when {
                    thenExpr.isEmpty() && elseExpr.isEmpty() -> replace(expression.testExpression)
                    thenExpr.isEmpty() -> listOf(JsAstUtils.or(expression.testExpression, expression.elseExpression))
                    elseExpr.isEmpty() -> listOf(JsAstUtils.and(expression.testExpression, expression.thenExpression))
                    else -> listOf(expression)
                }' @ [167:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: List<JsExpression>, entry1: List<JsExpression>, entry2: List<JsExpression>, entry3: List<JsExpression>): List<JsExpression>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> List<JsExpression>

'thenExpr' @ [168:21] ==> val thenExpr: List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[LocalVariableDescriptor]

'isEmpty' @ [168:30] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'elseExpr' @ [168:43] ==> val elseExpr: List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[LocalVariableDescriptor]

'isEmpty' @ [168:52] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'replace' @ [168:65] ==> private final fun replace(expression: JsExpression): List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[SimpleFunctionDescriptorImpl]

'expression' @ [168:73] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'testExpression' @ [168:84] ==> public final var JsConditional.testExpression: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'thenExpr' @ [169:21] ==> val thenExpr: List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[LocalVariableDescriptor]

'isEmpty' @ [169:30] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'listOf' @ [169:43] ==> public fun <T> listOf(element: JsBinaryOperation): List<JsBinaryOperation> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsBinaryOperation

'or' @ [169:61] ==> @NotNull public open fun or(@NotNull op1: JsExpression, @NotNull op2: JsExpression): JsBinaryOperation defined in org.jetbrains.kotlin.js.translate.utils.JsAstUtils[JavaMethodDescriptor]

'expression' @ [169:64] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'testExpression' @ [169:75] ==> public final var JsConditional.testExpression: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'expression' @ [169:91] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'elseExpression' @ [169:102] ==> public final var JsConditional.elseExpression: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'elseExpr' @ [170:21] ==> val elseExpr: List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[LocalVariableDescriptor]

'isEmpty' @ [170:30] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'listOf' @ [170:43] ==> public fun <T> listOf(element: JsBinaryOperation): List<JsBinaryOperation> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsBinaryOperation

'and' @ [170:61] ==> @NotNull public open fun and(@NotNull op1: JsExpression, @NotNull op2: JsExpression): JsBinaryOperation defined in org.jetbrains.kotlin.js.translate.utils.JsAstUtils[JavaMethodDescriptor]

'expression' @ [170:65] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'testExpression' @ [170:76] ==> public final var JsConditional.testExpression: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'expression' @ [170:92] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'thenExpression' @ [170:103] ==> public final var JsConditional.thenExpression: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'listOf' @ [171:29] ==> public fun <T> listOf(element: JsConditional): List<JsConditional> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsConditional

'expression' @ [171:36] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'if (expression.sideEffects != SideEffectKind.AFFECTS_STATE) {
                    replace(expression.arrayExpression) + replace(expression.indexExpression)
                }
                else {
                    listOf(expression)
                }' @ [182:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<JsExpression>, elseBranch: List<JsExpression>): List<JsExpression>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<JsExpression>

'expression' @ [182:21] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'sideEffects' @ [182:32] ==> public var HasMetadata.sideEffects: SideEffectKind defined in org.jetbrains.kotlin.js.backend.ast.metadata[DeserializedPropertyDescriptor]

'AFFECTS_STATE' @ [182:62] ==> enum entry AFFECTS_STATE defined in org.jetbrains.kotlin.js.backend.ast.metadata.SideEffectKind[FakeCallableDescriptorForObject]

'replace' @ [183:21] ==> private final fun replace(expression: JsExpression): List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[SimpleFunctionDescriptorImpl]

'expression' @ [183:29] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'arrayExpression' @ [183:40] ==> public final var JsArrayAccess.arrayExpression: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'replace' @ [183:59] ==> private final fun replace(expression: JsExpression): List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[SimpleFunctionDescriptorImpl]

'expression' @ [183:67] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'indexExpression' @ [183:78] ==> public final var JsArrayAccess.indexExpression: (JsExpression..JsExpression?)[MyPropertyDescriptor]

'listOf' @ [186:21] ==> public fun <T> listOf(element: JsArrayAccess): List<JsArrayAccess> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsArrayAccess

'expression' @ [186:28] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'listOf' @ [190:44] ==> @InlineOnly public inline fun <T> listOf(): List<JsExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsExpression

'replaceMany' @ [192:34] ==> private final fun replaceMany(expressions: List<JsExpression>): List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[SimpleFunctionDescriptorImpl]

'expression' @ [192:46] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'expressions' @ [192:57] ==> public final val JsArrayLiteral.expressions: (MutableList<(JsExpression..JsExpression?)>..List<(JsExpression..JsExpression?)>?)[MyPropertyDescriptor]

'expression' @ [194:35] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'propertyInitializers' @ [194:46] ==> public final val JsObjectLiteral.propertyInitializers: (MutableList<(JsPropertyInitializer..JsPropertyInitializer?)>..List<(JsPropertyInitializer..JsPropertyInitializer?)>?)[MyPropertyDescriptor]

'flatMap' @ [194:67] ==> public inline fun <T, R> Iterable<(JsPropertyInitializer..JsPropertyInitializer?)>.flatMap(transform: ((JsPropertyInitializer..JsPropertyInitializer?)) -> Iterable<JsExpression>): List<JsExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.js.backend.ast.JsPropertyInitializer..org.jetbrains.kotlin.js.backend.ast.JsPropertyInitializer?)
    <R> -> JsExpression

'replace' @ [194:77] ==> private final fun replace(expression: JsExpression): List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[SimpleFunctionDescriptorImpl]

'it' @ [194:85] ==> value-parameter it: (JsPropertyInitializer..JsPropertyInitializer?) defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace.<anonymous>[ValueParameterDescriptorImpl]

'labelExpr' @ [194:88] ==> public final val JsPropertyInitializer.labelExpr: JsExpression[MyPropertyDescriptor]

'replace' @ [194:101] ==> private final fun replace(expression: JsExpression): List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[SimpleFunctionDescriptorImpl]

'it' @ [194:109] ==> value-parameter it: (JsPropertyInitializer..JsPropertyInitializer?) defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace.<anonymous>[ValueParameterDescriptorImpl]

'valueExpr' @ [194:112] ==> public final val JsPropertyInitializer.valueExpr: JsExpression[MyPropertyDescriptor]

'if (expression.name == null) listOf() else listOf(expression)' @ [196:30] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<JsExpression>, elseBranch: List<JsExpression>): List<JsExpression>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<JsExpression>

'expression' @ [196:34] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'name' @ [196:45] ==> public final var JsFunction.name: (JsName..JsName?)[MyPropertyDescriptor]

'listOf' @ [196:59] ==> @InlineOnly public inline fun <T> listOf(): List<JsExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsExpression

'listOf' @ [196:73] ==> public fun <T> listOf(element: JsFunction): List<JsFunction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsFunction

'expression' @ [196:80] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'listOf' @ [198:21] ==> public fun <T> listOf(element: JsExpression): List<JsExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsExpression

'expression' @ [198:28] ==> value-parameter expression: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replace[ValueParameterDescriptorImpl]

'expressions' @ [202:64] ==> value-parameter expressions: List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replaceMany[ValueParameterDescriptorImpl]

'flatMap' @ [202:76] ==> public inline fun <T, R> Iterable<JsExpression>.flatMap(transform: (JsExpression) -> Iterable<JsExpression>): List<JsExpression> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JsExpression
    <R> -> JsExpression

'replace' @ [202:86] ==> private final fun replace(expression: JsExpression): List<JsExpression> defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination[SimpleFunctionDescriptorImpl]

'it' @ [202:94] ==> value-parameter it: JsExpression defined in org.jetbrains.kotlin.js.inline.clean.RedundantStatementElimination.replaceMany.<anonymous>[ValueParameterDescriptorImpl]

