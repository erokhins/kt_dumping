'descriptor' @ [32:13] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[ValueParameterDescriptorImpl]

'descriptor' @ [33:38] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[ValueParameterDescriptorImpl]

'accessors' @ [33:49] ==> public final val PropertyDescriptor.accessors: (MutableList<(PropertyAccessorDescriptor..PropertyAccessorDescriptor?)>..List<(PropertyAccessorDescriptor..PropertyAccessorDescriptor?)>)[MyPropertyDescriptor]

'count' @ [33:59] ==> public inline fun <T> Iterable<(PropertyAccessorDescriptor..PropertyAccessorDescriptor?)>.count(predicate: ((PropertyAccessorDescriptor..PropertyAccessorDescriptor?)) -> Boolean): Int defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.PropertyAccessorDescriptor..org.jetbrains.kotlin.descriptors.PropertyAccessorDescriptor?)

'!=' @ [33:67] ==> public open fun equals(other: Any?): Boolean defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'getJsName' @ [33:84] ==> @Nullable public open fun getJsName(@NotNull descriptor: DeclarationDescriptor): String? defined in org.jetbrains.kotlin.js.translate.utils.AnnotationsUtils[JavaMethodDescriptor]

'it' @ [33:94] ==> value-parameter it: (PropertyAccessorDescriptor..PropertyAccessorDescriptor?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check.<anonymous>[ValueParameterDescriptorImpl]

'namedAccessorCount' @ [34:17] ==> val namedAccessorCount: Int defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[LocalVariableDescriptor]

'namedAccessorCount' @ [34:43] ==> val namedAccessorCount: Int defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[LocalVariableDescriptor]

'descriptor' @ [34:64] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[ValueParameterDescriptorImpl]

'accessors' @ [34:75] ==> public final val PropertyDescriptor.accessors: (MutableList<(PropertyAccessorDescriptor..PropertyAccessorDescriptor?)>..List<(PropertyAccessorDescriptor..PropertyAccessorDescriptor?)>)[MyPropertyDescriptor]

'size' @ [34:85] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'diagnosticHolder' @ [35:17] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[ValueParameterDescriptorImpl]

'report' @ [35:34] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'JS_NAME_IS_NOT_ON_ALL_ACCESSORS' @ [35:50] ==> public final val JS_NAME_IS_NOT_ON_ALL_ACCESSORS: (DiagnosticFactory0<(PsiElement..PsiElement?)>..DiagnosticFactory0<(PsiElement..PsiElement?)>?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.ErrorsJs[JavaPropertyDescriptor]

'on' @ [35:82] ==> @NotNull public open fun on(@NotNull p0: PsiElement): SimpleDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'declaration' @ [35:85] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[ValueParameterDescriptorImpl]

'?:' @ [39:22] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: AnnotationDescriptor?, right: AnnotationDescriptor): AnnotationDescriptor[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> AnnotationDescriptor

'getJsNameAnnotation' @ [39:39] ==> @Nullable public open fun getJsNameAnnotation(@NotNull descriptor: DeclarationDescriptor): AnnotationDescriptor? defined in org.jetbrains.kotlin.js.translate.utils.AnnotationsUtils[JavaMethodDescriptor]

'descriptor' @ [39:59] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[ValueParameterDescriptorImpl]

'jsName' @ [40:25] ==> val jsName: AnnotationDescriptor defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[LocalVariableDescriptor]

'source' @ [40:32] ==> public abstract val source: SourceElement defined in org.jetbrains.kotlin.descriptors.annotations.AnnotationDescriptor[DeserializedPropertyDescriptor]

'getPsi' @ [40:39] ==> public fun SourceElement.getPsi(): PsiElement? defined in org.jetbrains.kotlin.resolve.source[DeserializedSimpleFunctionDescriptor]

'declaration' @ [40:51] ==> value-parameter declaration: KtDeclaration defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[ValueParameterDescriptorImpl]

'!=' @ [42:13] ==> public open fun equals(other: Any?): Boolean defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'getNameForAnnotatedObject' @ [42:30] ==> @Nullable public open fun getNameForAnnotatedObject(@NotNull declarationDescriptor: DeclarationDescriptor, @NotNull annotation: PredefinedAnnotation): String? defined in org.jetbrains.kotlin.js.translate.utils.AnnotationsUtils[JavaMethodDescriptor]

'descriptor' @ [42:56] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[ValueParameterDescriptorImpl]

'PredefinedAnnotation' @ [42:68] ==> public companion object defined in org.jetbrains.kotlin.js.PredefinedAnnotation[FakeCallableDescriptorForObject]

'NATIVE' @ [42:89] ==> enum entry NATIVE defined in org.jetbrains.kotlin.js.PredefinedAnnotation[FakeCallableDescriptorForObject]

'diagnosticHolder' @ [43:13] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[ValueParameterDescriptorImpl]

'report' @ [43:30] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'JS_NAME_PROHIBITED_FOR_NAMED_NATIVE' @ [43:46] ==> public final val JS_NAME_PROHIBITED_FOR_NAMED_NATIVE: (DiagnosticFactory0<(PsiElement..PsiElement?)>..DiagnosticFactory0<(PsiElement..PsiElement?)>?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.ErrorsJs[JavaPropertyDescriptor]

'on' @ [43:82] ==> @NotNull public open fun on(@NotNull p0: PsiElement): SimpleDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'jsNamePsi' @ [43:85] ==> val jsNamePsi: PsiElement defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[LocalVariableDescriptor]

'descriptor' @ [46:13] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[ValueParameterDescriptorImpl]

'descriptor' @ [46:55] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[ValueParameterDescriptorImpl]

'overriddenDescriptors' @ [46:66] ==> public final var CallableMemberDescriptor.overriddenDescriptors: (MutableCollection<out (CallableMemberDescriptor..CallableMemberDescriptor?)>..Collection<(CallableMemberDescriptor..CallableMemberDescriptor?)>)[MyPropertyDescriptor]

'isNotEmpty' @ [46:88] ==> @InlineOnly public inline fun <T> Collection<(CallableMemberDescriptor..CallableMemberDescriptor?)>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.CallableMemberDescriptor..org.jetbrains.kotlin.descriptors.CallableMemberDescriptor?)

'diagnosticHolder' @ [47:13] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[ValueParameterDescriptorImpl]

'report' @ [47:30] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'JS_NAME_PROHIBITED_FOR_OVERRIDE' @ [47:46] ==> public final val JS_NAME_PROHIBITED_FOR_OVERRIDE: (DiagnosticFactory0<(PsiElement..PsiElement?)>..DiagnosticFactory0<(PsiElement..PsiElement?)>?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.ErrorsJs[JavaPropertyDescriptor]

'on' @ [47:78] ==> @NotNull public open fun on(@NotNull p0: PsiElement): SimpleDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'jsNamePsi' @ [47:81] ==> val jsNamePsi: PsiElement defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[LocalVariableDescriptor]

'when (descriptor) {
            is ConstructorDescriptor -> {
                if (descriptor.isPrimary) {
                    diagnosticHolder.report(ErrorsJs.JS_NAME_ON_PRIMARY_CONSTRUCTOR_PROHIBITED.on(jsNamePsi))
                }
            }
            is PropertyAccessorDescriptor -> {
                if (AnnotationsUtils.getJsName(descriptor.correspondingProperty) != null) {
                    diagnosticHolder.report(ErrorsJs.JS_NAME_ON_ACCESSOR_AND_PROPERTY.on(jsNamePsi))
                }
            }
            is PropertyDescriptor -> {
                if (descriptor.isExtension) {
                    diagnosticHolder.report(ErrorsJs.JS_NAME_PROHIBITED_FOR_EXTENSION_PROPERTY.on(jsNamePsi))
                }
            }
        }' @ [50:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'descriptor' @ [50:15] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[ValueParameterDescriptorImpl]

'descriptor' @ [52:21] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[ValueParameterDescriptorImpl]

'isPrimary' @ [52:32] ==> public final val ConstructorDescriptor.isPrimary: Boolean[MyPropertyDescriptor]

'diagnosticHolder' @ [53:21] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[ValueParameterDescriptorImpl]

'report' @ [53:38] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'JS_NAME_ON_PRIMARY_CONSTRUCTOR_PROHIBITED' @ [53:54] ==> public final val JS_NAME_ON_PRIMARY_CONSTRUCTOR_PROHIBITED: (DiagnosticFactory0<(PsiElement..PsiElement?)>..DiagnosticFactory0<(PsiElement..PsiElement?)>?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.ErrorsJs[JavaPropertyDescriptor]

'on' @ [53:96] ==> @NotNull public open fun on(@NotNull p0: PsiElement): SimpleDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'jsNamePsi' @ [53:99] ==> val jsNamePsi: PsiElement defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[LocalVariableDescriptor]

'!=' @ [57:21] ==> public open fun equals(other: Any?): Boolean defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'getJsName' @ [57:38] ==> @Nullable public open fun getJsName(@NotNull descriptor: DeclarationDescriptor): String? defined in org.jetbrains.kotlin.js.translate.utils.AnnotationsUtils[JavaMethodDescriptor]

'descriptor' @ [57:48] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[ValueParameterDescriptorImpl]

'correspondingProperty' @ [57:59] ==> public final val PropertyAccessorDescriptor.correspondingProperty: PropertyDescriptor[MyPropertyDescriptor]

'diagnosticHolder' @ [58:21] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[ValueParameterDescriptorImpl]

'report' @ [58:38] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'JS_NAME_ON_ACCESSOR_AND_PROPERTY' @ [58:54] ==> public final val JS_NAME_ON_ACCESSOR_AND_PROPERTY: (DiagnosticFactory0<(PsiElement..PsiElement?)>..DiagnosticFactory0<(PsiElement..PsiElement?)>?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.ErrorsJs[JavaPropertyDescriptor]

'on' @ [58:87] ==> @NotNull public open fun on(@NotNull p0: PsiElement): SimpleDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'jsNamePsi' @ [58:90] ==> val jsNamePsi: PsiElement defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[LocalVariableDescriptor]

'descriptor' @ [62:21] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[ValueParameterDescriptorImpl]

'isExtension' @ [62:32] ==> public val DeclarationDescriptor.isExtension: Boolean defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'diagnosticHolder' @ [63:21] ==> value-parameter diagnosticHolder: DiagnosticSink defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[ValueParameterDescriptorImpl]

'report' @ [63:38] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.diagnostics.DiagnosticSink[JavaMethodDescriptor]

'JS_NAME_PROHIBITED_FOR_EXTENSION_PROPERTY' @ [63:54] ==> public final val JS_NAME_PROHIBITED_FOR_EXTENSION_PROPERTY: (DiagnosticFactory0<(PsiElement..PsiElement?)>..DiagnosticFactory0<(PsiElement..PsiElement?)>?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.ErrorsJs[JavaPropertyDescriptor]

'on' @ [63:96] ==> @NotNull public open fun on(@NotNull p0: PsiElement): SimpleDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'jsNamePsi' @ [63:99] ==> val jsNamePsi: PsiElement defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsNameChecker.check[LocalVariableDescriptor]

