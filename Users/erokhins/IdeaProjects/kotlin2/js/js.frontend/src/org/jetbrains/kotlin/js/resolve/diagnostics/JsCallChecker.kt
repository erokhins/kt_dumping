'pattern' @ [56:70] ==> @NotNull public open fun pattern(@NotNull stringWithPattern: String): DescriptorPredicate defined in org.jetbrains.kotlin.js.patterns.PatternBuilder[JavaMethodDescriptor]

'JvmStatic' @ [58:9] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'resultingDescriptor' @ [59:30] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<F>.resultingDescriptor: F[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> F

'descriptor' @ [60:20] ==> val descriptor: F defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.Companion.isJsCall[LocalVariableDescriptor]

'JS_PATTERN' @ [60:62] ==> private final val JS_PATTERN: DescriptorPredicate defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.Companion[PropertyDescriptorImpl]

'test' @ [60:73] ==> public abstract fun test(p0: (FunctionDescriptor..FunctionDescriptor?)): Boolean defined in org.jetbrains.kotlin.js.patterns.DescriptorPredicate[JavaMethodDescriptor]

'descriptor' @ [60:78] ==> val descriptor: F defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.Companion.isJsCall[LocalVariableDescriptor]

'JvmStatic' @ [63:9] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'compileTimeConstant' @ [64:22] ==> value-parameter compileTimeConstant: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.Companion.extractStringValue[ValueParameterDescriptorImpl]

'constantValue' @ [64:76] ==> public final val constantValue: ConstantValue<Any?> defined in org.jetbrains.kotlin.resolve.constants.TypedCompileTimeConstant[DeserializedPropertyDescriptor]

'value' @ [64:108] ==> public open val value: String defined in org.jetbrains.kotlin.resolve.constants.StringValue[DeserializedPropertyDescriptor]

'context' @ [69:13] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[ValueParameterDescriptorImpl]

'isAnnotationContext' @ [69:21] ==> public final val isAnnotationContext: Boolean defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[DeserializedPropertyDescriptor]

'!' @ [69:44] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'resolvedCall' @ [69:45] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[ValueParameterDescriptorImpl]

'isJsCall' @ [69:58] ==> @JvmStatic public final fun <F : CallableDescriptor?> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.isJsCall(): Boolean defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.Companion[SimpleFunctionDescriptorImpl]
Inferred types:
    <F : CallableDescriptor?> -> Captured(*)

'resolvedCall' @ [71:26] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[ValueParameterDescriptorImpl]

'call' @ [71:39] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> Captured(*)

'callElement' @ [71:44] ==> public final val Call.callElement: KtElement[MyPropertyDescriptor]

'expression' @ [72:13] ==> val expression: KtElement defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[LocalVariableDescriptor]

'expression' @ [74:25] ==> val expression: KtElement defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[LocalVariableDescriptor]

'valueArgumentList' @ [74:36] ==> public final val KtCallExpression.valueArgumentList: KtValueArgumentList?[MyPropertyDescriptor]

'arguments' @ [74:55] ==> public final val KtValueArgumentList.arguments: (MutableList<(KtValueArgument..KtValueArgument?)>..List<(KtValueArgument..KtValueArgument?)>)[MyPropertyDescriptor]

'arguments' @ [75:24] ==> val arguments: (MutableList<(KtValueArgument..KtValueArgument?)>?..List<(KtValueArgument..KtValueArgument?)>?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[LocalVariableDescriptor]

'firstOrNull' @ [75:35] ==> public fun <T> List<(KtValueArgument..KtValueArgument?)>.firstOrNull(): KtValueArgument? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtValueArgument..org.jetbrains.kotlin.psi.KtValueArgument?)

'getArgumentExpression' @ [75:50] ==> @IfNotParsed @Nullable public open fun getArgumentExpression(): KtExpression? defined in org.jetbrains.kotlin.psi.KtValueArgument[JavaMethodDescriptor]

'create' @ [77:43] ==> @NotNull public open fun create(@NotNull p0: BindingTrace, p1: (String..String?)): TemporaryBindingTrace defined in org.jetbrains.kotlin.resolve.TemporaryBindingTrace[JavaMethodDescriptor]

'context' @ [77:50] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[ValueParameterDescriptorImpl]

'trace' @ [77:58] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[DeserializedPropertyDescriptor]

'constantExpressionEvaluator' @ [79:32] ==> private final val constantExpressionEvaluator: ConstantExpressionEvaluator defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker[PropertyDescriptorImpl]

'evaluateExpression' @ [79:60] ==> public final fun evaluateExpression(expression: KtExpression, trace: BindingTrace, expectedType: KotlinType? = ...): CompileTimeConstant<*>? defined in org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator[DeserializedSimpleFunctionDescriptor]

'argument' @ [79:79] ==> val argument: KtExpression defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[LocalVariableDescriptor]

'trace' @ [79:89] ==> val trace: TemporaryBindingTrace defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[LocalVariableDescriptor]

'NO_EXPECTED_TYPE' @ [79:106] ==> @NotNull public final val NO_EXPECTED_TYPE: SimpleType defined in org.jetbrains.kotlin.types.TypeUtils[JavaPropertyDescriptor]

'extractStringValue' @ [80:20] ==> @JvmStatic public final fun extractStringValue(compileTimeConstant: CompileTimeConstant<*>?): String? defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.Companion[SimpleFunctionDescriptorImpl]

'evaluationResult' @ [80:39] ==> val evaluationResult: CompileTimeConstant<*>? defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[LocalVariableDescriptor]

'code' @ [82:13] ==> val code: String? defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[LocalVariableDescriptor]

'context' @ [83:13] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[ValueParameterDescriptorImpl]

'trace' @ [83:21] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[DeserializedPropertyDescriptor]

'report' @ [83:27] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'JSCODE_ARGUMENT_SHOULD_BE_CONSTANT' @ [83:43] ==> public final val JSCODE_ARGUMENT_SHOULD_BE_CONSTANT: (DiagnosticFactory0<(KtExpression..KtExpression?)>..DiagnosticFactory0<(KtExpression..KtExpression?)>?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.ErrorsJs[JavaPropertyDescriptor]

'on' @ [83:78] ==> @NotNull public open fun on(@NotNull p0: KtExpression): SimpleDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'argument' @ [83:81] ==> val argument: KtExpression defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[LocalVariableDescriptor]

'trace' @ [87:9] ==> val trace: TemporaryBindingTrace defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[LocalVariableDescriptor]

'commit' @ [87:15] ==> public open fun commit(): Unit defined in org.jetbrains.kotlin.resolve.TemporaryBindingTrace[JavaMethodDescriptor]

'JsCodeErrorReporter' @ [89:29] ==> public constructor JsCodeErrorReporter(nodeToReport: KtExpression, code: String, trace: BindingTrace) defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter[ClassConstructorDescriptorImpl]

'argument' @ [89:49] ==> val argument: KtExpression defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[LocalVariableDescriptor]

'code' @ [89:59] ==> val code: String? defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[LocalVariableDescriptor]

'context' @ [89:65] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[ValueParameterDescriptorImpl]

'trace' @ [89:73] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[DeserializedPropertyDescriptor]

'JsFunctionScope' @ [92:31] ==> public constructor JsFunctionScope(parent: JsScope, description: String) defined in org.jetbrains.kotlin.js.backend.ast.JsFunctionScope[DeserializedClassConstructorDescriptor]

'JsRootScope' @ [92:47] ==> public constructor JsRootScope(p0: (JsProgram..JsProgram?)) defined in org.jetbrains.kotlin.js.backend.ast.JsRootScope[JavaClassConstructorDescriptor]

'JsProgram' @ [92:59] ==> public constructor JsProgram() defined in org.jetbrains.kotlin.js.backend.ast.JsProgram[JavaClassConstructorDescriptor]

'parse' @ [93:30] ==> public fun parse(code: String, reporter: ErrorReporter, scope: JsScope, fileName: String): List<JsStatement> defined in org.jetbrains.kotlin.js.parser[DeserializedSimpleFunctionDescriptor]

'code' @ [93:36] ==> val code: String? defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[LocalVariableDescriptor]

'errorReporter' @ [93:42] ==> val errorReporter: JsCodeErrorReporter defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[LocalVariableDescriptor]

'parserScope' @ [93:57] ==> val parserScope: JsFunctionScope defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[LocalVariableDescriptor]

'reportOn' @ [93:70] ==> value-parameter reportOn: PsiElement defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[ValueParameterDescriptorImpl]

'containingFile' @ [93:79] ==> public final val PsiElement.containingFile: (PsiFile..PsiFile?)[MyPropertyDescriptor]

'name' @ [93:95] ==> public final var PsiFile.name: String[MyPropertyDescriptor]

'statements' @ [95:17] ==> val statements: List<JsStatement> defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[LocalVariableDescriptor]

'isEmpty' @ [95:28] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'context' @ [96:17] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[ValueParameterDescriptorImpl]

'trace' @ [96:25] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[DeserializedPropertyDescriptor]

'report' @ [96:31] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'JSCODE_NO_JAVASCRIPT_PRODUCED' @ [96:47] ==> public final val JSCODE_NO_JAVASCRIPT_PRODUCED: (DiagnosticFactory0<(KtExpression..KtExpression?)>..DiagnosticFactory0<(KtExpression..KtExpression?)>?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.ErrorsJs[JavaPropertyDescriptor]

'on' @ [96:77] ==> @NotNull public open fun on(@NotNull p0: KtExpression): SimpleDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory0[JavaMethodDescriptor]

'argument' @ [96:80] ==> val argument: KtExpression defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[LocalVariableDescriptor]

'Suppress' @ [102:9] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'context' @ [103:9] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[ValueParameterDescriptorImpl]

'trace' @ [103:17] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[DeserializedPropertyDescriptor]

'record' @ [103:23] ==> public abstract fun <K : (Any..Any?), V : (Any..Any?)> record(p0: (WritableSlice<(ResolvedCall<out FunctionDescriptor>..ResolvedCall<out FunctionDescriptor>?), (LexicalScope..LexicalScope?)>..WritableSlice<(ResolvedCall<out FunctionDescriptor>..ResolvedCall<out FunctionDescriptor>?), (LexicalScope..LexicalScope?)>?), p1: (ResolvedCall<out FunctionDescriptor>..ResolvedCall<out FunctionDescriptor>?), p2: (LexicalScope..LexicalScope?)): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (org.jetbrains.kotlin.resolve.calls.model.ResolvedCall<out org.jetbrains.kotlin.descriptors.FunctionDescriptor>..org.jetbrains.kotlin.resolve.calls.model.ResolvedCall<out org.jetbrains.kotlin.descriptors.FunctionDescriptor>?)
    <V : (Any..Any?)> -> (org.jetbrains.kotlin.resolve.scopes.LexicalScope..org.jetbrains.kotlin.resolve.scopes.LexicalScope?)

'LEXICAL_SCOPE_FOR_JS' @ [103:30] ==> @JvmField public val LEXICAL_SCOPE_FOR_JS: BasicWritableSlice<ResolvedCall<out FunctionDescriptor>, LexicalScope> defined in org.jetbrains.kotlin.js.resolve in file bindingContextSlicesJs.kt[PropertyDescriptorImpl]

'resolvedCall' @ [103:52] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[ValueParameterDescriptorImpl]

'context' @ [103:102] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallChecker.check[ValueParameterDescriptorImpl]

'scope' @ [103:110] ==> public final val scope: LexicalScope defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[DeserializedPropertyDescriptor]

'report' @ [113:9] ==> private final fun report(diagnosticFactory: DiagnosticFactory1<KtExpression, JsCallData>, message: String, startPosition: CodePosition, endPosition: CodePosition): Unit defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter[SimpleFunctionDescriptorImpl]

'JSCODE_WARNING' @ [113:25] ==> public final val JSCODE_WARNING: (DiagnosticFactory1<(KtExpression..KtExpression?), (JsCallData..JsCallData?)>..DiagnosticFactory1<(KtExpression..KtExpression?), (JsCallData..JsCallData?)>?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.ErrorsJs[JavaPropertyDescriptor]

'message' @ [113:41] ==> value-parameter message: String defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter.warning[ValueParameterDescriptorImpl]

'startPosition' @ [113:50] ==> value-parameter startPosition: CodePosition defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter.warning[ValueParameterDescriptorImpl]

'endPosition' @ [113:65] ==> value-parameter endPosition: CodePosition defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter.warning[ValueParameterDescriptorImpl]

'report' @ [117:9] ==> private final fun report(diagnosticFactory: DiagnosticFactory1<KtExpression, JsCallData>, message: String, startPosition: CodePosition, endPosition: CodePosition): Unit defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter[SimpleFunctionDescriptorImpl]

'JSCODE_ERROR' @ [117:25] ==> public final val JSCODE_ERROR: (DiagnosticFactory1<(KtExpression..KtExpression?), (JsCallData..JsCallData?)>..DiagnosticFactory1<(KtExpression..KtExpression?), (JsCallData..JsCallData?)>?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.ErrorsJs[JavaPropertyDescriptor]

'message' @ [117:39] ==> value-parameter message: String defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter.error[ValueParameterDescriptorImpl]

'startPosition' @ [117:48] ==> value-parameter startPosition: CodePosition defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter.error[ValueParameterDescriptorImpl]

'endPosition' @ [117:63] ==> value-parameter endPosition: CodePosition defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter.error[ValueParameterDescriptorImpl]

'AbortParsingException' @ [118:15] ==> public constructor AbortParsingException() defined in com.google.gwt.dev.js.parserExceptions.AbortParsingException[DeserializedClassConstructorDescriptor]

'when {
            nodeToReport.isConstantStringLiteral -> {
                val reportRange = TextRange(startPosition.absoluteOffset, endPosition.absoluteOffset)
                JsCallData(reportRange, message)
            }
            else -> {
                val reportRange = nodeToReport.textRange
                val codeRange = TextRange(code.offsetOf(startPosition), code.offsetOf(endPosition))
                JsCallDataWithCode(reportRange, message, code, codeRange)
            }
        }' @ [127:20] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: JsCallData, entry1: JsCallData): JsCallData[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> JsCallData

'nodeToReport' @ [128:13] ==> private final val nodeToReport: KtExpression defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter[PropertyDescriptorImpl]

'isConstantStringLiteral' @ [128:26] ==> private val KtExpression.isConstantStringLiteral: Boolean defined in org.jetbrains.kotlin.js.resolve.diagnostics in file JsCallChecker.kt[PropertyDescriptorImpl]

'TextRange' @ [129:35] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'startPosition' @ [129:45] ==> value-parameter startPosition: CodePosition defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter.report[ValueParameterDescriptorImpl]

'absoluteOffset' @ [129:59] ==> private final val CodePosition.absoluteOffset: Int defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter[PropertyDescriptorImpl]

'endPosition' @ [129:75] ==> value-parameter endPosition: CodePosition defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter.report[ValueParameterDescriptorImpl]

'absoluteOffset' @ [129:87] ==> private final val CodePosition.absoluteOffset: Int defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter[PropertyDescriptorImpl]

'JsCallData' @ [130:17] ==> public constructor JsCallData(reportRange: TextRange, message: String) defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallData[ClassConstructorDescriptorImpl]

'reportRange' @ [130:28] ==> val reportRange: TextRange defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter.report[LocalVariableDescriptor]

'message' @ [130:41] ==> value-parameter message: String defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter.report[ValueParameterDescriptorImpl]

'nodeToReport' @ [133:35] ==> private final val nodeToReport: KtExpression defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter[PropertyDescriptorImpl]

'textRange' @ [133:48] ==> public final val KtExpression.textRange: (TextRange..TextRange?)[MyPropertyDescriptor]

'TextRange' @ [134:33] ==> public constructor TextRange(p0: Int, p1: Int) defined in com.intellij.openapi.util.TextRange[JavaClassConstructorDescriptor]

'code' @ [134:43] ==> private final val code: String defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter[PropertyDescriptorImpl]

'offsetOf' @ [134:48] ==> private fun String.offsetOf(position: CodePosition): Int defined in org.jetbrains.kotlin.js.resolve.diagnostics in file JsCallChecker.kt[SimpleFunctionDescriptorImpl]

'startPosition' @ [134:57] ==> value-parameter startPosition: CodePosition defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter.report[ValueParameterDescriptorImpl]

'code' @ [134:73] ==> private final val code: String defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter[PropertyDescriptorImpl]

'offsetOf' @ [134:78] ==> private fun String.offsetOf(position: CodePosition): Int defined in org.jetbrains.kotlin.js.resolve.diagnostics in file JsCallChecker.kt[SimpleFunctionDescriptorImpl]

'endPosition' @ [134:87] ==> value-parameter endPosition: CodePosition defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter.report[ValueParameterDescriptorImpl]

'JsCallDataWithCode' @ [135:17] ==> public constructor JsCallDataWithCode(reportRange: TextRange, message: String, code: String, codeRange: TextRange) defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallDataWithCode[ClassConstructorDescriptorImpl]

'reportRange' @ [135:36] ==> val reportRange: (TextRange..TextRange?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter.report[LocalVariableDescriptor]

'message' @ [135:49] ==> value-parameter message: String defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter.report[ValueParameterDescriptorImpl]

'code' @ [135:58] ==> private final val code: String defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter[PropertyDescriptorImpl]

'codeRange' @ [135:64] ==> val codeRange: TextRange defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter.report[LocalVariableDescriptor]

'diagnosticFactory' @ [139:38] ==> value-parameter diagnosticFactory: DiagnosticFactory1<KtExpression, JsCallData> defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter.report[ValueParameterDescriptorImpl]

'on' @ [139:56] ==> @NotNull public open fun on(@NotNull p0: KtExpression, @NotNull p1: JsCallData): ParametrizedDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory1[JavaMethodDescriptor]

'nodeToReport' @ [139:59] ==> private final val nodeToReport: KtExpression defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter[PropertyDescriptorImpl]

'data' @ [139:73] ==> val data: JsCallData defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter.report[LocalVariableDescriptor]

'trace' @ [140:9] ==> private final val trace: BindingTrace defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter[PropertyDescriptorImpl]

'report' @ [140:15] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'parametrizedDiagnostic' @ [140:22] ==> val parametrizedDiagnostic: ParametrizedDiagnostic<(KtExpression..KtExpression?)> defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter.report[LocalVariableDescriptor]

'nodeToReport' @ [145:32] ==> private final val nodeToReport: KtExpression defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter[PropertyDescriptorImpl]

'firstChild' @ [145:45] ==> public final val KtExpression.firstChild: (PsiElement..PsiElement?)[MyPropertyDescriptor]

'textLength' @ [145:56] ==> public final val PsiElement.textLength: Int[MyPropertyDescriptor]

'nodeToReport' @ [146:20] ==> private final val nodeToReport: KtExpression defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter[PropertyDescriptorImpl]

'textOffset' @ [146:33] ==> public final val KtExpression.textOffset: Int[MyPropertyDescriptor]

'quotesLength' @ [146:46] ==> val quotesLength: Int defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter.<get-absoluteOffset>[LocalVariableDescriptor]

'code' @ [146:61] ==> private final val code: String defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter[PropertyDescriptorImpl]

'offsetOf' @ [146:66] ==> private fun String.offsetOf(position: CodePosition): Int defined in org.jetbrains.kotlin.js.resolve.diagnostics in file JsCallChecker.kt[SimpleFunctionDescriptorImpl]

'this' @ [146:75] ==> <this> defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCodeErrorReporter.absoluteOffset[ReceiverParameterDescriptorImpl]

'i' @ [159:12] ==> var i: Int defined in org.jetbrains.kotlin.js.resolve.diagnostics.offsetOf[LocalVariableDescriptor]

'length' @ [159:16] ==> public open val length: Int defined in kotlin.String[DeserializedPropertyDescriptor]

'this' @ [160:17] ==> <this> defined in org.jetbrains.kotlin.js.resolve.diagnostics.offsetOf[ReceiverParameterDescriptorImpl]

'i' @ [160:22] ==> var i: Int defined in org.jetbrains.kotlin.js.resolve.diagnostics.offsetOf[LocalVariableDescriptor]

'lineCount' @ [162:13] ==> var lineCount: Int defined in org.jetbrains.kotlin.js.resolve.diagnostics.offsetOf[LocalVariableDescriptor]

'position' @ [162:26] ==> value-parameter position: CodePosition defined in org.jetbrains.kotlin.js.resolve.diagnostics.offsetOf[ValueParameterDescriptorImpl]

'line' @ [162:35] ==> public final val line: Int defined in com.google.gwt.dev.js.rhino.CodePosition[DeserializedPropertyDescriptor]

'offsetInLine' @ [162:43] ==> var offsetInLine: Int defined in org.jetbrains.kotlin.js.resolve.diagnostics.offsetOf[LocalVariableDescriptor]

'position' @ [162:59] ==> value-parameter position: CodePosition defined in org.jetbrains.kotlin.js.resolve.diagnostics.offsetOf[ValueParameterDescriptorImpl]

'offset' @ [162:68] ==> public final val offset: Int defined in com.google.gwt.dev.js.rhino.CodePosition[DeserializedPropertyDescriptor]

'i' @ [163:20] ==> var i: Int defined in org.jetbrains.kotlin.js.resolve.diagnostics.offsetOf[LocalVariableDescriptor]

'i' @ [166:9] ==> var i: Int defined in org.jetbrains.kotlin.js.resolve.diagnostics.offsetOf[LocalVariableDescriptor]

'offsetInLine' @ [167:9] ==> var offsetInLine: Int defined in org.jetbrains.kotlin.js.resolve.diagnostics.offsetOf[LocalVariableDescriptor]

'isEndOfLine' @ [169:13] ==> public open fun isEndOfLine(p0: Int): Boolean defined in com.google.gwt.dev.js.rhino.Utils[JavaMethodDescriptor]

'c' @ [169:25] ==> val c: Char defined in org.jetbrains.kotlin.js.resolve.diagnostics.offsetOf[LocalVariableDescriptor]

'toInt' @ [169:27] ==> public final fun toInt(): Int defined in kotlin.Char[DeserializedSimpleFunctionDescriptor]

'offsetInLine' @ [170:13] ==> var offsetInLine: Int defined in org.jetbrains.kotlin.js.resolve.diagnostics.offsetOf[LocalVariableDescriptor]

'lineCount' @ [171:13] ==> var lineCount: Int defined in org.jetbrains.kotlin.js.resolve.diagnostics.offsetOf[LocalVariableDescriptor]

'assert' @ [172:13] ==> @InlineOnly public inline fun assert(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'lineCount' @ [172:20] ==> var lineCount: Int defined in org.jetbrains.kotlin.js.resolve.diagnostics.offsetOf[LocalVariableDescriptor]

'position' @ [172:33] ==> value-parameter position: CodePosition defined in org.jetbrains.kotlin.js.resolve.diagnostics.offsetOf[ValueParameterDescriptorImpl]

'line' @ [172:42] ==> public final val line: Int defined in com.google.gwt.dev.js.rhino.CodePosition[DeserializedPropertyDescriptor]

'length' @ [176:12] ==> public open val length: Int defined in kotlin.String[DeserializedPropertyDescriptor]

'this' @ [180:13] ==> <this> defined in org.jetbrains.kotlin.js.resolve.diagnostics.isConstantStringLiteral[ReceiverParameterDescriptorImpl]

'entries' @ [180:51] ==> public final val KtStringTemplateExpression.entries: (Array<(KtStringTemplateEntry..KtStringTemplateEntry?)>..Array<out (KtStringTemplateEntry..KtStringTemplateEntry?)>)[MyPropertyDescriptor]

'all' @ [180:59] ==> public inline fun <T> Array<out (KtStringTemplateEntry..KtStringTemplateEntry?)>.all(predicate: ((KtStringTemplateEntry..KtStringTemplateEntry?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtStringTemplateEntry..org.jetbrains.kotlin.psi.KtStringTemplateEntry?)

'it' @ [180:65] ==> value-parameter it: (KtStringTemplateEntry..KtStringTemplateEntry?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.<get-isConstantStringLiteral>.<anonymous>[ValueParameterDescriptorImpl]

'JsCallData' @ [189:5] ==> public constructor JsCallData(reportRange: TextRange, message: String) defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallData[ClassConstructorDescriptorImpl]

'reportRange' @ [189:16] ==> value-parameter reportRange: TextRange defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallDataWithCode.<init>[ValueParameterDescriptorImpl]

'message' @ [189:29] ==> value-parameter message: String defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsCallDataWithCode.<init>[ValueParameterDescriptorImpl]

