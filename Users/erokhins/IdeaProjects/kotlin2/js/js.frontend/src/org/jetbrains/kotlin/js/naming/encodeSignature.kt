'StringBuilder' @ [28:15] ==> public final fun <init>(): StringBuilder /* = StringBuilder */ defined in kotlin.text.StringBuilder[TypeAliasConstructorDescriptorImpl]

'nameTypeParameters' @ [30:30] ==> private fun nameTypeParameters(descriptor: DeclarationDescriptor): Map<TypeParameterDescriptor, String> defined in org.jetbrains.kotlin.js.naming in file encodeSignature.kt[SimpleFunctionDescriptorImpl]

'descriptor' @ [30:49] ==> value-parameter descriptor: CallableDescriptor defined in org.jetbrains.kotlin.js.naming.encodeSignature[ValueParameterDescriptorImpl]

'descriptor' @ [31:29] ==> value-parameter descriptor: CallableDescriptor defined in org.jetbrains.kotlin.js.naming.encodeSignature[ValueParameterDescriptorImpl]

'typeParameters' @ [31:40] ==> public final val CallableDescriptor.typeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'filter' @ [31:55] ==> public inline fun <T> Iterable<(TypeParameterDescriptor..TypeParameterDescriptor?)>.filter(predicate: ((TypeParameterDescriptor..TypeParameterDescriptor?)) -> Boolean): List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)

'!' @ [31:64] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'it' @ [31:65] ==> value-parameter it: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.js.naming.encodeSignature.<anonymous>[ValueParameterDescriptorImpl]

'isCapturedFromOuterDeclaration' @ [31:68] ==> public final val TypeParameterDescriptor.isCapturedFromOuterDeclaration: Boolean[MyPropertyDescriptor]

'toSet' @ [31:101] ==> public fun <T> Iterable<(TypeParameterDescriptor..TypeParameterDescriptor?)>.toSet(): Set<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)

'currentParameters' @ [32:30] ==> val currentParameters: Set<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'toMutableSet' @ [32:48] ==> public fun <T> Iterable<(TypeParameterDescriptor..TypeParameterDescriptor?)>.toMutableSet(): MutableSet<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)

'usedTypeParameters' @ [34:9] ==> val usedTypeParameters: MutableSet<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'typeParameter' @ [34:31] ==> value-parameter typeParameter: TypeParameterDescriptor defined in org.jetbrains.kotlin.js.naming.encodeSignature.<anonymous>[ValueParameterDescriptorImpl]

'original' @ [34:45] ==> public final val TypeParameterDescriptor.original: TypeParameterDescriptor[MyPropertyDescriptor]

'typeParameterNames' @ [35:9] ==> val typeParameterNames: Map<TypeParameterDescriptor, String> defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'typeParameter' @ [35:28] ==> value-parameter typeParameter: TypeParameterDescriptor defined in org.jetbrains.kotlin.js.naming.encodeSignature.<anonymous>[ValueParameterDescriptorImpl]

'original' @ [35:42] ==> public final val TypeParameterDescriptor.original: TypeParameterDescriptor[MyPropertyDescriptor]

'descriptor' @ [38:29] ==> value-parameter descriptor: CallableDescriptor defined in org.jetbrains.kotlin.js.naming.encodeSignature[ValueParameterDescriptorImpl]

'extensionReceiverParameter' @ [38:40] ==> public final val CallableDescriptor.extensionReceiverParameter: ReceiverParameterDescriptor?[MyPropertyDescriptor]

'receiverParameter' @ [39:9] ==> val receiverParameter: ReceiverParameterDescriptor? defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'sig' @ [40:9] ==> val sig: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'encodeForSignature' @ [40:13] ==> private fun StringBuilder /* = StringBuilder */.encodeForSignature(type: KotlinType, typeParameterNamer: (TypeParameterDescriptor) -> String): StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.js.naming in file encodeSignature.kt[SimpleFunctionDescriptorImpl]

'receiverParameter' @ [40:32] ==> val receiverParameter: ReceiverParameterDescriptor? defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'type' @ [40:50] ==> public final val ReceiverParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'typeParameterNamer' @ [40:56] ==> val typeParameterNamer: (TypeParameterDescriptor) -> String defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'append' @ [40:76] ==> public open fun append(p0: Char): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'descriptor' @ [43:28] ==> value-parameter descriptor: CallableDescriptor defined in org.jetbrains.kotlin.js.naming.encodeSignature[ValueParameterDescriptorImpl]

'valueParameters' @ [43:39] ==> public final val CallableDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'valueParameter' @ [44:13] ==> val valueParameter: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'index' @ [44:28] ==> public abstract val index: Int defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'sig' @ [45:13] ==> val sig: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'append' @ [45:17] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'valueParameter' @ [47:13] ==> val valueParameter: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'varargElementType' @ [47:28] ==> public abstract val varargElementType: KotlinType? defined in org.jetbrains.kotlin.descriptors.ValueParameterDescriptor[DeserializedPropertyDescriptor]

'sig' @ [48:13] ==> val sig: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'append' @ [48:17] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'sig' @ [50:9] ==> val sig: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'encodeForSignature' @ [50:13] ==> private fun StringBuilder /* = StringBuilder */.encodeForSignature(type: KotlinType, typeParameterNamer: (TypeParameterDescriptor) -> String): StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.js.naming in file encodeSignature.kt[SimpleFunctionDescriptorImpl]

'valueParameter' @ [50:32] ==> val valueParameter: (ValueParameterDescriptor..ValueParameterDescriptor?) defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'type' @ [50:47] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'typeParameterNamer' @ [50:53] ==> val typeParameterNamer: (TypeParameterDescriptor) -> String defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'typeParameterNames' @ [54:27] ==> val typeParameterNames: Map<TypeParameterDescriptor, String> defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'keys' @ [54:46] ==> public abstract val keys: Set<TypeParameterDescriptor> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'asSequence' @ [54:51] ==> public fun <T> Iterable<TypeParameterDescriptor>.asSequence(): Sequence<TypeParameterDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeParameterDescriptor

'filter' @ [54:64] ==> public fun <T> Sequence<TypeParameterDescriptor>.filter(predicate: (TypeParameterDescriptor) -> Boolean): Sequence<TypeParameterDescriptor> defined in kotlin.sequences[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeParameterDescriptor

'it' @ [54:73] ==> value-parameter it: TypeParameterDescriptor defined in org.jetbrains.kotlin.js.naming.encodeSignature.<anonymous>[ValueParameterDescriptorImpl]

'usedTypeParameters' @ [54:79] ==> val usedTypeParameters: MutableSet<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'typeParameter' @ [55:27] ==> val typeParameter: TypeParameterDescriptor defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'upperBounds' @ [55:41] ==> public final val TypeParameterDescriptor.upperBounds: (MutableList<(KotlinType..KotlinType?)>..List<(KotlinType..KotlinType?)>)[MyPropertyDescriptor]

'filter' @ [55:53] ==> public inline fun <T> Iterable<(KotlinType..KotlinType?)>.filter(predicate: ((KotlinType..KotlinType?)) -> Boolean): List<(KotlinType..KotlinType?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)

'!' @ [55:62] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isNullableAny' @ [55:78] ==> public open fun isNullableAny(@NotNull p0: KotlinType): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'it' @ [55:92] ==> value-parameter it: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.js.naming.encodeSignature.<anonymous>[ValueParameterDescriptorImpl]

'upperBounds' @ [56:13] ==> val upperBounds: List<(KotlinType..KotlinType?)> defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'isEmpty' @ [56:25] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'typeParameter' @ [56:38] ==> val typeParameter: TypeParameterDescriptor defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'currentParameters' @ [56:56] ==> val currentParameters: Set<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'sig' @ [58:9] ==> val sig: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'append' @ [58:13] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'if (first) "|" else ","' @ [58:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'first' @ [58:24] ==> var first: Boolean defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'append' @ [58:45] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'typeParameterNames' @ [58:52] ==> val typeParameterNames: Map<TypeParameterDescriptor, String> defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'typeParameter' @ [58:71] ==> val typeParameter: TypeParameterDescriptor defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'first' @ [59:9] ==> var first: Boolean defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'upperBounds' @ [60:13] ==> val upperBounds: List<(KotlinType..KotlinType?)> defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'isEmpty' @ [60:25] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'sig' @ [62:9] ==> val sig: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'append' @ [62:13] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'component1' @ [63:15] ==> public final operator fun component1(): Int defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'component2' @ [63:27] ==> public final operator fun component2(): (KotlinType..KotlinType?) defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'upperBounds' @ [63:42] ==> val upperBounds: List<(KotlinType..KotlinType?)> defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'withIndex' @ [63:54] ==> public fun <T> Iterable<(KotlinType..KotlinType?)>.withIndex(): Iterable<IndexedValue<(KotlinType..KotlinType?)>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)

'boundIndex' @ [64:17] ==> val boundIndex: Int defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'sig' @ [65:17] ==> val sig: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'append' @ [65:21] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'sig' @ [67:13] ==> val sig: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'encodeForSignature' @ [67:17] ==> private fun StringBuilder /* = StringBuilder */.encodeForSignature(type: KotlinType, typeParameterNamer: (TypeParameterDescriptor) -> String): StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.js.naming in file encodeSignature.kt[SimpleFunctionDescriptorImpl]

'upperBound' @ [67:36] ==> val upperBound: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'typeParameterNamer' @ [67:48] ==> val typeParameterNamer: (TypeParameterDescriptor) -> String defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'sig' @ [71:12] ==> val sig: StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.js.naming.encodeSignature[LocalVariableDescriptor]

'toString' @ [71:16] ==> public open fun toString(): String defined in java.lang.StringBuilder[JavaMethodDescriptor]

'type' @ [78:23] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.js.naming.encodeForSignature[ValueParameterDescriptorImpl]

'constructor' @ [78:28] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'declarationDescriptor' @ [78:40] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'declaration' @ [79:9] ==> val declaration: ClassifierDescriptor defined in org.jetbrains.kotlin.js.naming.encodeForSignature[LocalVariableDescriptor]

'append' @ [80:16] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'invoke' @ [80:23] ==> public abstract operator fun invoke(p1: TypeParameterDescriptor): String defined in kotlin.Function1[FunctionInvokeDescriptor]

'declaration' @ [80:42] ==> val declaration: ClassifierDescriptor defined in org.jetbrains.kotlin.js.naming.encodeForSignature[LocalVariableDescriptor]

'append' @ [83:5] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'getFqName' @ [83:28] ==> @NotNull public open fun getFqName(@NotNull p0: DeclarationDescriptor): FqNameUnsafe defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'declaration' @ [83:38] ==> val declaration: ClassifierDescriptor defined in org.jetbrains.kotlin.js.naming.encodeForSignature[LocalVariableDescriptor]

'asString' @ [83:51] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.FqNameUnsafe[JavaMethodDescriptor]

'declaration' @ [85:22] ==> val declaration: ClassifierDescriptor defined in org.jetbrains.kotlin.js.naming.encodeForSignature[LocalVariableDescriptor]

'typeConstructor' @ [85:34] ==> public final val ClassifierDescriptor.typeConstructor: TypeConstructor[MyPropertyDescriptor]

'parameters' @ [85:50] ==> public final val TypeConstructor.parameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'type' @ [86:9] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.js.naming.encodeForSignature[ValueParameterDescriptorImpl]

'arguments' @ [86:14] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'isNotEmpty' @ [86:24] ==> @InlineOnly public inline fun <T> Collection<TypeProjection>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection

'parameters' @ [86:40] ==> val parameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.js.naming.encodeForSignature[LocalVariableDescriptor]

'isNotEmpty' @ [86:51] ==> @InlineOnly public inline fun <T> Collection<(TypeParameterDescriptor..TypeParameterDescriptor?)>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)

'append' @ [87:9] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'component1' @ [88:15] ==> public final operator fun component1(): TypeProjection defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [88:25] ==> public final operator fun component2(): (TypeParameterDescriptor..TypeParameterDescriptor?) defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'type' @ [88:39] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.js.naming.encodeForSignature[ValueParameterDescriptorImpl]

'arguments' @ [88:44] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'zip' @ [88:54] ==> public infix fun <T, R> Iterable<TypeProjection>.zip(other: Iterable<(TypeParameterDescriptor..TypeParameterDescriptor?)>): List<Pair<TypeProjection, (TypeParameterDescriptor..TypeParameterDescriptor?)>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection
    <R> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)

'parameters' @ [88:58] ==> val parameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in org.jetbrains.kotlin.js.naming.encodeForSignature[LocalVariableDescriptor]

'parameter' @ [89:17] ==> val parameter: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.js.naming.encodeForSignature[LocalVariableDescriptor]

'index' @ [89:27] ==> public final val TypeParameterDescriptor.index: Int[MyPropertyDescriptor]

'append' @ [90:17] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'encodeForSignature' @ [92:13] ==> private fun StringBuilder /* = StringBuilder */.encodeForSignature(projection: TypeProjection, parameter: TypeParameterDescriptor, typeParameterNamer: (TypeParameterDescriptor) -> String): StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.js.naming in file encodeSignature.kt[SimpleFunctionDescriptorImpl]

'argument' @ [92:32] ==> val argument: TypeProjection defined in org.jetbrains.kotlin.js.naming.encodeForSignature[LocalVariableDescriptor]

'parameter' @ [92:42] ==> val parameter: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.js.naming.encodeForSignature[LocalVariableDescriptor]

'typeParameterNamer' @ [92:53] ==> value-parameter typeParameterNamer: (TypeParameterDescriptor) -> String defined in org.jetbrains.kotlin.js.naming.encodeForSignature[ValueParameterDescriptorImpl]

'append' @ [94:9] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'type' @ [97:9] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.js.naming.encodeForSignature[ValueParameterDescriptorImpl]

'isMarkedNullable' @ [97:14] ==> public abstract val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'append' @ [98:9] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'this' @ [101:12] ==> <this> defined in org.jetbrains.kotlin.js.naming.encodeForSignature[ReceiverParameterDescriptorImpl]

'if (projection.isStarProjection) {
        append("*")
    }
    else {
        when (getEffectiveVariance(parameter.variance, projection.projectionKind)) {
            Variance.IN_VARIANCE -> append("-")
            Variance.OUT_VARIANCE -> append("+")
            Variance.INVARIANT -> {}
        }
        encodeForSignature(projection.type, typeParameterNamer)
    }' @ [109:12] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: StringBuilder /* = StringBuilder */, elseBranch: StringBuilder /* = StringBuilder */): StringBuilder /* = StringBuilder */[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> StringBuilder

'projection' @ [109:16] ==> value-parameter projection: TypeProjection defined in org.jetbrains.kotlin.js.naming.encodeForSignature[ValueParameterDescriptorImpl]

'isStarProjection' @ [109:27] ==> public final val TypeProjection.isStarProjection: Boolean[MyPropertyDescriptor]

'append' @ [110:9] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'when (getEffectiveVariance(parameter.variance, projection.projectionKind)) {
            Variance.IN_VARIANCE -> append("-")
            Variance.OUT_VARIANCE -> append("+")
            Variance.INVARIANT -> {}
        }' @ [113:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: (Any..Any?), entry1: (Any..Any?), entry2: (Any..Any?)): (Any..Any?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> (kotlin.Any..kotlin.Any?)

'getEffectiveVariance' @ [113:15] ==> public fun getEffectiveVariance(parameterVariance: Variance, projectionKind: Variance): Variance defined in org.jetbrains.kotlin.types[DeserializedSimpleFunctionDescriptor]

'parameter' @ [113:36] ==> value-parameter parameter: TypeParameterDescriptor defined in org.jetbrains.kotlin.js.naming.encodeForSignature[ValueParameterDescriptorImpl]

'variance' @ [113:46] ==> public final val TypeParameterDescriptor.variance: Variance[MyPropertyDescriptor]

'projection' @ [113:56] ==> value-parameter projection: TypeProjection defined in org.jetbrains.kotlin.js.naming.encodeForSignature[ValueParameterDescriptorImpl]

'projectionKind' @ [113:67] ==> public final val TypeProjection.projectionKind: Variance[MyPropertyDescriptor]

'IN_VARIANCE' @ [114:22] ==> enum entry IN_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'append' @ [114:37] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'OUT_VARIANCE' @ [115:22] ==> enum entry OUT_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'append' @ [115:38] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'INVARIANT' @ [116:22] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'encodeForSignature' @ [118:9] ==> private fun StringBuilder /* = StringBuilder */.encodeForSignature(type: KotlinType, typeParameterNamer: (TypeParameterDescriptor) -> String): StringBuilder /* = StringBuilder */ defined in org.jetbrains.kotlin.js.naming in file encodeSignature.kt[SimpleFunctionDescriptorImpl]

'projection' @ [118:28] ==> value-parameter projection: TypeProjection defined in org.jetbrains.kotlin.js.naming.encodeForSignature[ValueParameterDescriptorImpl]

'type' @ [118:39] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'typeParameterNamer' @ [118:45] ==> value-parameter typeParameterNamer: (TypeParameterDescriptor) -> String defined in org.jetbrains.kotlin.js.naming.encodeForSignature[ValueParameterDescriptorImpl]

'mutableMapOf' @ [123:18] ==> @SinceKotlin @InlineOnly public inline fun <K, V> mutableMapOf(): MutableMap<TypeParameterDescriptor, String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> TypeParameterDescriptor
    <V> -> String

'component1' @ [124:11] ==> public final operator fun component1(): Int defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'component2' @ [124:22] ==> public final operator fun component2(): List<TypeParameterDescriptor> defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'collectTypeParameters' @ [124:31] ==> private fun collectTypeParameters(descriptor: DeclarationDescriptor): List<List<TypeParameterDescriptor>> defined in org.jetbrains.kotlin.js.naming in file encodeSignature.kt[SimpleFunctionDescriptorImpl]

'descriptor' @ [124:53] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.js.naming.nameTypeParameters[ValueParameterDescriptorImpl]

'withIndex' @ [124:65] ==> public fun <T> Iterable<List<TypeParameterDescriptor>>.withIndex(): Iterable<IndexedValue<List<TypeParameterDescriptor>>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> List<TypeParameterDescriptor>

'component1' @ [125:15] ==> public final operator fun component1(): Int defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'component2' @ [125:28] ==> public final operator fun component2(): TypeParameterDescriptor defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'list' @ [125:46] ==> val list: List<TypeParameterDescriptor> defined in org.jetbrains.kotlin.js.naming.nameTypeParameters[LocalVariableDescriptor]

'withIndex' @ [125:51] ==> public fun <T> Iterable<TypeParameterDescriptor>.withIndex(): Iterable<IndexedValue<TypeParameterDescriptor>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeParameterDescriptor

'result' @ [126:13] ==> val result: MutableMap<TypeParameterDescriptor, String> defined in org.jetbrains.kotlin.js.naming.nameTypeParameters[LocalVariableDescriptor]

'typeParameter' @ [126:20] ==> val typeParameter: TypeParameterDescriptor defined in org.jetbrains.kotlin.js.naming.nameTypeParameters[LocalVariableDescriptor]

'listIndex' @ [126:39] ==> val listIndex: Int defined in org.jetbrains.kotlin.js.naming.nameTypeParameters[LocalVariableDescriptor]

'indexInList' @ [126:50] ==> val indexInList: Int defined in org.jetbrains.kotlin.js.naming.nameTypeParameters[LocalVariableDescriptor]

'result' @ [129:12] ==> val result: MutableMap<TypeParameterDescriptor, String> defined in org.jetbrains.kotlin.js.naming.nameTypeParameters[LocalVariableDescriptor]

'descriptor' @ [133:53] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.js.naming.collectTypeParameters[ValueParameterDescriptorImpl]

'mutableListOf' @ [134:18] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableListOf(): MutableList<List<TypeParameterDescriptor>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> List<TypeParameterDescriptor>

'currentDescriptor' @ [135:12] ==> var currentDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.js.naming.collectTypeParameters[LocalVariableDescriptor]

'getOwnTypeParameters' @ [136:9] ==> private fun getOwnTypeParameters(descriptor: DeclarationDescriptor): List<TypeParameterDescriptor>? defined in org.jetbrains.kotlin.js.naming in file encodeSignature.kt[SimpleFunctionDescriptorImpl]

'currentDescriptor' @ [136:30] ==> var currentDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.js.naming.collectTypeParameters[LocalVariableDescriptor]

'let' @ [136:50] ==> @InlineOnly public inline fun <T, R> List<TypeParameterDescriptor>.let(block: (List<TypeParameterDescriptor>) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> List<TypeParameterDescriptor>
    <R> -> Unit

'result' @ [136:56] ==> val result: MutableList<List<TypeParameterDescriptor>> defined in org.jetbrains.kotlin.js.naming.collectTypeParameters[LocalVariableDescriptor]

'it' @ [136:66] ==> value-parameter it: List<TypeParameterDescriptor> defined in org.jetbrains.kotlin.js.naming.collectTypeParameters.<anonymous>[ValueParameterDescriptorImpl]

'currentDescriptor' @ [137:9] ==> var currentDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.js.naming.collectTypeParameters[LocalVariableDescriptor]

'if (currentDescriptor is ConstructorDescriptor) {
            currentDescriptor.constructedClass.containingDeclaration
        }
        else {
            currentDescriptor.containingDeclaration
        }' @ [137:29] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: DeclarationDescriptor?, elseBranch: DeclarationDescriptor?): DeclarationDescriptor?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> DeclarationDescriptor?

'currentDescriptor' @ [137:33] ==> var currentDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.js.naming.collectTypeParameters[LocalVariableDescriptor]

'currentDescriptor' @ [138:13] ==> var currentDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.js.naming.collectTypeParameters[LocalVariableDescriptor]

'constructedClass' @ [138:31] ==> public final val ConstructorDescriptor.constructedClass: ClassDescriptor[MyPropertyDescriptor]

'containingDeclaration' @ [138:48] ==> public final val ClassDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'currentDescriptor' @ [141:13] ==> var currentDescriptor: DeclarationDescriptor? defined in org.jetbrains.kotlin.js.naming.collectTypeParameters[LocalVariableDescriptor]

'containingDeclaration' @ [141:31] ==> public final val DeclarationDescriptor.containingDeclaration: DeclarationDescriptor?[MyPropertyDescriptor]

'result' @ [144:12] ==> val result: MutableList<List<TypeParameterDescriptor>> defined in org.jetbrains.kotlin.js.naming.collectTypeParameters[LocalVariableDescriptor]

'when (descriptor) {
            is ClassDescriptor -> descriptor.declaredTypeParameters.filter { !it.isCapturedFromOuterDeclaration }
            is PropertyAccessorDescriptor -> getOwnTypeParameters(descriptor.correspondingProperty)
            is CallableDescriptor -> descriptor.typeParameters.filter { !it.isCapturedFromOuterDeclaration }
            else -> null
        }' @ [148:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: List<TypeParameterDescriptor>?, entry1: List<TypeParameterDescriptor>?, entry2: List<TypeParameterDescriptor>?, entry3: List<TypeParameterDescriptor>?): List<TypeParameterDescriptor>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> List<TypeParameterDescriptor>?

'descriptor' @ [148:15] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.js.naming.getOwnTypeParameters[ValueParameterDescriptorImpl]

'descriptor' @ [149:35] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.js.naming.getOwnTypeParameters[ValueParameterDescriptorImpl]

'declaredTypeParameters' @ [149:46] ==> public final val ClassDescriptor.declaredTypeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'filter' @ [149:69] ==> public inline fun <T> Iterable<(TypeParameterDescriptor..TypeParameterDescriptor?)>.filter(predicate: ((TypeParameterDescriptor..TypeParameterDescriptor?)) -> Boolean): List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)

'!' @ [149:78] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'it' @ [149:79] ==> value-parameter it: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.js.naming.getOwnTypeParameters.<anonymous>[ValueParameterDescriptorImpl]

'isCapturedFromOuterDeclaration' @ [149:82] ==> public final val TypeParameterDescriptor.isCapturedFromOuterDeclaration: Boolean[MyPropertyDescriptor]

'getOwnTypeParameters' @ [150:46] ==> private fun getOwnTypeParameters(descriptor: DeclarationDescriptor): List<TypeParameterDescriptor>? defined in org.jetbrains.kotlin.js.naming in file encodeSignature.kt[SimpleFunctionDescriptorImpl]

'descriptor' @ [150:67] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.js.naming.getOwnTypeParameters[ValueParameterDescriptorImpl]

'correspondingProperty' @ [150:78] ==> public final val PropertyAccessorDescriptor.correspondingProperty: PropertyDescriptor[MyPropertyDescriptor]

'descriptor' @ [151:38] ==> value-parameter descriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.js.naming.getOwnTypeParameters[ValueParameterDescriptorImpl]

'typeParameters' @ [151:49] ==> public final val CallableDescriptor.typeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'filter' @ [151:64] ==> public inline fun <T> Iterable<(TypeParameterDescriptor..TypeParameterDescriptor?)>.filter(predicate: ((TypeParameterDescriptor..TypeParameterDescriptor?)) -> Boolean): List<(TypeParameterDescriptor..TypeParameterDescriptor?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)

'!' @ [151:73] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'it' @ [151:74] ==> value-parameter it: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.js.naming.getOwnTypeParameters.<anonymous>[ValueParameterDescriptorImpl]

'isCapturedFromOuterDeclaration' @ [151:77] ==> public final val TypeParameterDescriptor.isCapturedFromOuterDeclaration: Boolean[MyPropertyDescriptor]

