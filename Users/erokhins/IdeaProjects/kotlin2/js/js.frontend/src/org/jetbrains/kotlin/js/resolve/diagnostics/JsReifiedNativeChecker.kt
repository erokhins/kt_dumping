'resolvedCall' @ [27:32] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsReifiedNativeChecker.check[ValueParameterDescriptorImpl]

'call' @ [27:45] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'typeArgumentList' @ [27:50] ==> public final val Call.typeArgumentList: KtTypeArgumentList?[MyPropertyDescriptor]

'arguments' @ [27:68] ==> public final val KtTypeArgumentList.arguments: (MutableList<(KtTypeProjection..KtTypeProjection?)>..List<(KtTypeProjection..KtTypeProjection?)>)[MyPropertyDescriptor]

'component1' @ [28:15] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(TypeParameterDescriptor..TypeParameterDescriptor?), (KotlinType..KotlinType?)>.component1(): (TypeParameterDescriptor..TypeParameterDescriptor?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)
    <V> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)

'component2' @ [28:26] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<(TypeParameterDescriptor..TypeParameterDescriptor?), (KotlinType..KotlinType?)>.component2(): (KotlinType..KotlinType?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)
    <V> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)

'resolvedCall' @ [28:38] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsReifiedNativeChecker.check[ValueParameterDescriptorImpl]

'typeArguments' @ [28:51] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.typeArguments: (MutableMap<(TypeParameterDescriptor..TypeParameterDescriptor?), (KotlinType..KotlinType?)>..Map<(TypeParameterDescriptor..TypeParameterDescriptor?), (KotlinType..KotlinType?)>)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'!' @ [29:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'typeParam' @ [29:18] ==> val typeParam: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsReifiedNativeChecker.check[LocalVariableDescriptor]

'isReified' @ [29:28] ==> public final val TypeParameterDescriptor.isReified: Boolean[MyPropertyDescriptor]

'typeArg' @ [31:37] ==> val typeArg: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsReifiedNativeChecker.check[LocalVariableDescriptor]

'constructor' @ [31:45] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'declarationDescriptor' @ [31:57] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'typeArgDescriptor' @ [32:17] ==> val typeArgDescriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsReifiedNativeChecker.check[LocalVariableDescriptor]

'isNativeInterface' @ [32:63] ==> public open fun isNativeInterface(@NotNull descriptor: DeclarationDescriptor): Boolean defined in org.jetbrains.kotlin.js.translate.utils.AnnotationsUtils[JavaMethodDescriptor]

'typeArgDescriptor' @ [32:81] ==> val typeArgDescriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsReifiedNativeChecker.check[LocalVariableDescriptor]

'if (typeArgumentList != null) {
                    typeArgumentList[typeParam.index].typeReference
                }
                else {
                    resolvedCall.call.callElement
                }' @ [33:39] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KtElement?, elseBranch: KtElement?): KtElement?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KtElement?

'typeArgumentList' @ [33:43] ==> val typeArgumentList: (MutableList<(KtTypeProjection..KtTypeProjection?)>?..List<(KtTypeProjection..KtTypeProjection?)>?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsReifiedNativeChecker.check[LocalVariableDescriptor]

'typeArgumentList' @ [34:21] ==> val typeArgumentList: (MutableList<(KtTypeProjection..KtTypeProjection?)>?..List<(KtTypeProjection..KtTypeProjection?)>?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsReifiedNativeChecker.check[LocalVariableDescriptor]

'typeParam' @ [34:38] ==> val typeParam: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsReifiedNativeChecker.check[LocalVariableDescriptor]

'index' @ [34:48] ==> public final val TypeParameterDescriptor.index: Int[MyPropertyDescriptor]

'typeReference' @ [34:55] ==> public final val KtTypeProjection.typeReference: KtTypeReference?[MyPropertyDescriptor]

'resolvedCall' @ [37:21] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsReifiedNativeChecker.check[ValueParameterDescriptorImpl]

'call' @ [37:34] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'callElement' @ [37:39] ==> public final val Call.callElement: KtElement[MyPropertyDescriptor]

'context' @ [40:17] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsReifiedNativeChecker.check[ValueParameterDescriptorImpl]

'trace' @ [40:25] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[DeserializedPropertyDescriptor]

'report' @ [40:31] ==> public abstract fun report(@NotNull p0: Diagnostic): Unit defined in org.jetbrains.kotlin.resolve.BindingTrace[JavaMethodDescriptor]

'NATIVE_INTERFACE_AS_REIFIED_TYPE_ARGUMENT' @ [40:47] ==> public final val NATIVE_INTERFACE_AS_REIFIED_TYPE_ARGUMENT: (DiagnosticFactory1<(PsiElement..PsiElement?), (KotlinType..KotlinType?)>..DiagnosticFactory1<(PsiElement..PsiElement?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.ErrorsJs[JavaPropertyDescriptor]

'on' @ [40:89] ==> @NotNull public open fun on(@NotNull p0: PsiElement, @NotNull p1: KotlinType): ParametrizedDiagnostic<(PsiElement..PsiElement?)> defined in org.jetbrains.kotlin.diagnostics.DiagnosticFactory1[JavaMethodDescriptor]

'typeArgumentPsi' @ [40:92] ==> val typeArgumentPsi: KtElement? defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsReifiedNativeChecker.check[LocalVariableDescriptor]

'typeArg' @ [40:111] ==> val typeArg: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsReifiedNativeChecker.check[LocalVariableDescriptor]

