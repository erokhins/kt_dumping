'checkReifieidTypeParameters' @ [30:9] ==> private final fun checkReifieidTypeParameters(call: ResolvedCall<*>, reportOn: PsiElement, context: CallCheckerContext): Unit defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker[SimpleFunctionDescriptorImpl]

'resolvedCall' @ [30:37] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.check[ValueParameterDescriptorImpl]

'reportOn' @ [30:51] ==> value-parameter reportOn: PsiElement defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.check[ValueParameterDescriptorImpl]

'context' @ [30:61] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.check[ValueParameterDescriptorImpl]

'extractModuleCallee' @ [32:22] ==> private final fun extractModuleCallee(call: ResolvedCall<*>): DeclarationDescriptor? defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker[SimpleFunctionDescriptorImpl]

'resolvedCall' @ [32:42] ==> value-parameter resolvedCall: ResolvedCall<*> defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.check[ValueParameterDescriptorImpl]

'context' @ [33:30] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.check[ValueParameterDescriptorImpl]

'trace' @ [33:38] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[DeserializedPropertyDescriptor]

'bindingContext' @ [33:44] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'context' @ [34:36] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.check[ValueParameterDescriptorImpl]

'scope' @ [34:44] ==> public final val scope: LexicalScope defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[DeserializedPropertyDescriptor]

'ownerDescriptor' @ [34:50] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'checkJsModuleUsage' @ [35:9] ==> public fun checkJsModuleUsage(bindingContext: BindingContext, diagnosticSink: DiagnosticSink, container: DeclarationDescriptor, callee: DeclarationDescriptor, reportOn: PsiElement): Unit defined in org.jetbrains.kotlin.js.resolve.diagnostics in file JsModuleCheckUtil.kt[SimpleFunctionDescriptorImpl]

'bindingContext' @ [35:28] ==> val bindingContext: BindingContext defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.check[LocalVariableDescriptor]

'context' @ [35:44] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.check[ValueParameterDescriptorImpl]

'trace' @ [35:52] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[DeserializedPropertyDescriptor]

'containingDescriptor' @ [35:59] ==> val containingDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.check[LocalVariableDescriptor]

'callee' @ [35:81] ==> val callee: DeclarationDescriptor defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.check[LocalVariableDescriptor]

'reportOn' @ [35:89] ==> value-parameter reportOn: PsiElement defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.check[ValueParameterDescriptorImpl]

'call' @ [39:22] ==> value-parameter call: ResolvedCall<*> defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.extractModuleCallee[ValueParameterDescriptorImpl]

'resultingDescriptor' @ [39:27] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.resultingDescriptor: (CallableDescriptor..CallableDescriptor?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'isTopLevelDeclaration' @ [40:29] ==> public open fun isTopLevelDeclaration(@Nullable p0: DeclarationDescriptor?): Boolean defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]

'callee' @ [40:51] ==> val callee: (CallableDescriptor..CallableDescriptor?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.extractModuleCallee[LocalVariableDescriptor]

'callee' @ [40:67] ==> val callee: (CallableDescriptor..CallableDescriptor?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.extractModuleCallee[LocalVariableDescriptor]

'call' @ [42:24] ==> value-parameter call: ResolvedCall<*> defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.extractModuleCallee[ValueParameterDescriptorImpl]

'dispatchReceiver' @ [42:29] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.dispatchReceiver: ReceiverValue?[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'callee' @ [42:56] ==> val callee: (CallableDescriptor..CallableDescriptor?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.extractModuleCallee[LocalVariableDescriptor]

'receiver' @ [43:13] ==> val receiver: ReceiverValue defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.extractModuleCallee[LocalVariableDescriptor]

'receiver' @ [43:52] ==> val receiver: ReceiverValue defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.extractModuleCallee[LocalVariableDescriptor]

'classQualifier' @ [43:61] ==> public final val classQualifier: ClassifierQualifier defined in org.jetbrains.kotlin.resolve.scopes.receivers.ClassValueReceiver[DeserializedPropertyDescriptor]

'descriptor' @ [43:76] ==> public abstract val descriptor: ClassifierDescriptorWithTypeParameters defined in org.jetbrains.kotlin.resolve.scopes.receivers.ClassifierQualifier[DeserializedPropertyDescriptor]

'context' @ [49:36] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.checkReifieidTypeParameters[ValueParameterDescriptorImpl]

'scope' @ [49:44] ==> public final val scope: LexicalScope defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[DeserializedPropertyDescriptor]

'ownerDescriptor' @ [49:50] ==> public abstract val ownerDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.resolve.scopes.LexicalScope[DeserializedPropertyDescriptor]

'call' @ [50:26] ==> value-parameter call: ResolvedCall<*> defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.checkReifieidTypeParameters[ValueParameterDescriptorImpl]

'candidateDescriptor' @ [50:31] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.candidateDescriptor: (CallableDescriptor..CallableDescriptor?)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'typeParameters' @ [50:51] ==> public final val CallableDescriptor.typeParameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'map' @ [50:66] ==> public inline fun <T, R> Iterable<(TypeParameterDescriptor..TypeParameterDescriptor?)>.map(transform: ((TypeParameterDescriptor..TypeParameterDescriptor?)) -> TypeParameterDescriptor): List<TypeParameterDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)
    <R> -> TypeParameterDescriptor

'it' @ [50:72] ==> value-parameter it: (TypeParameterDescriptor..TypeParameterDescriptor?) defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.checkReifieidTypeParameters.<anonymous>[ValueParameterDescriptorImpl]

'original' @ [50:75] ==> public final val TypeParameterDescriptor.original: TypeParameterDescriptor[MyPropertyDescriptor]

'withIndex' @ [50:86] ==> public fun <T> Iterable<TypeParameterDescriptor>.withIndex(): Iterable<IndexedValue<TypeParameterDescriptor>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeParameterDescriptor

'filter' @ [50:98] ==> public inline fun <T> Iterable<IndexedValue<TypeParameterDescriptor>>.filter(predicate: (IndexedValue<TypeParameterDescriptor>) -> Boolean): List<IndexedValue<TypeParameterDescriptor>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> IndexedValue<TypeParameterDescriptor>

'component1' @ [50:108] ==> public final operator fun component1(): Int defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'component2' @ [50:111] ==> public final operator fun component2(): TypeParameterDescriptor defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'param' @ [50:121] ==> val param: TypeParameterDescriptor defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.checkReifieidTypeParameters.<anonymous>[LocalVariableDescriptor]

'isReified' @ [50:127] ==> public final val TypeParameterDescriptor.isReified: Boolean[MyPropertyDescriptor]

'call' @ [51:29] ==> value-parameter call: ResolvedCall<*> defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.checkReifieidTypeParameters[ValueParameterDescriptorImpl]

'call' @ [51:34] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.call: Call[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'typeArgumentList' @ [51:39] ==> public final val Call.typeArgumentList: KtTypeArgumentList?[MyPropertyDescriptor]

'let' @ [52:19] ==> @InlineOnly public inline fun <T, R> KtTypeArgumentList.let(block: (KtTypeArgumentList) -> Map<TypeParameterDescriptor, KtTypeReference?>): Map<TypeParameterDescriptor, KtTypeReference?> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtTypeArgumentList
    <R> -> Map<TypeParameterDescriptor, KtTypeReference?>

'typeParams' @ [52:33] ==> val typeParams: List<IndexedValue<TypeParameterDescriptor>> defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.checkReifieidTypeParameters[LocalVariableDescriptor]

'associate' @ [52:44] ==> public inline fun <T, K, V> Iterable<IndexedValue<TypeParameterDescriptor>>.associate(transform: (IndexedValue<TypeParameterDescriptor>) -> Pair<TypeParameterDescriptor, KtTypeReference?>): Map<TypeParameterDescriptor, KtTypeReference?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> IndexedValue<TypeParameterDescriptor>
    <K> -> TypeParameterDescriptor
    <V> -> KtTypeReference?

'component1' @ [52:57] ==> public final operator fun component1(): Int defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'component2' @ [52:64] ==> public final operator fun component2(): TypeParameterDescriptor defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'param' @ [52:74] ==> val param: TypeParameterDescriptor defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.checkReifieidTypeParameters.<anonymous>.<anonymous>[LocalVariableDescriptor]

'original' @ [52:80] ==> public final val TypeParameterDescriptor.original: TypeParameterDescriptor[MyPropertyDescriptor]

'args' @ [52:92] ==> value-parameter args: KtTypeArgumentList defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.checkReifieidTypeParameters.<anonymous>[ValueParameterDescriptorImpl]

'arguments' @ [52:97] ==> public final val KtTypeArgumentList.arguments: (MutableList<(KtTypeProjection..KtTypeProjection?)>..List<(KtTypeProjection..KtTypeProjection?)>)[MyPropertyDescriptor]

'index' @ [52:107] ==> val index: Int defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.checkReifieidTypeParameters.<anonymous>.<anonymous>[LocalVariableDescriptor]

'typeReference' @ [52:114] ==> public final val KtTypeProjection.typeReference: KtTypeReference?[MyPropertyDescriptor]

'orEmpty' @ [53:18] ==> @InlineOnly public inline fun <K, V> Map<TypeParameterDescriptor, KtTypeReference?>?.orEmpty(): Map<TypeParameterDescriptor, KtTypeReference?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> TypeParameterDescriptor
    <V> -> KtTypeReference?

'typeParams' @ [54:27] ==> val typeParams: List<IndexedValue<TypeParameterDescriptor>> defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.checkReifieidTypeParameters[LocalVariableDescriptor]

'map' @ [54:38] ==> public inline fun <T, R> Iterable<IndexedValue<TypeParameterDescriptor>>.map(transform: (IndexedValue<TypeParameterDescriptor>) -> TypeParameterDescriptor): List<TypeParameterDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> IndexedValue<TypeParameterDescriptor>
    <R> -> TypeParameterDescriptor

'component1' @ [54:45] ==> public final operator fun component1(): Int defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'component2' @ [54:48] ==> public final operator fun component2(): TypeParameterDescriptor defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'param' @ [54:58] ==> val param: TypeParameterDescriptor defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.checkReifieidTypeParameters.<anonymous>[LocalVariableDescriptor]

'original' @ [54:64] ==> public final val TypeParameterDescriptor.original: TypeParameterDescriptor[MyPropertyDescriptor]

'typeArguments' @ [55:26] ==> val typeArguments: Map<TypeParameterDescriptor, KtTypeReference?> defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.checkReifieidTypeParameters[LocalVariableDescriptor]

'typeParam' @ [55:40] ==> val typeParam: TypeParameterDescriptor defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.checkReifieidTypeParameters[LocalVariableDescriptor]

'reportOn' @ [55:54] ==> value-parameter reportOn: PsiElement defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.checkReifieidTypeParameters[ValueParameterDescriptorImpl]

'call' @ [56:32] ==> value-parameter call: ResolvedCall<*> defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.checkReifieidTypeParameters[ValueParameterDescriptorImpl]

'typeArguments' @ [56:37] ==> public final val <D : (CallableDescriptor..CallableDescriptor?)> ResolvedCall<out (CallableDescriptor..CallableDescriptor?)>.typeArguments: (MutableMap<(TypeParameterDescriptor..TypeParameterDescriptor?), (KotlinType..KotlinType?)>..Map<(TypeParameterDescriptor..TypeParameterDescriptor?), (KotlinType..KotlinType?)>)[MyPropertyDescriptor]
Inferred types:
    <D : (CallableDescriptor..CallableDescriptor?)> -> (org.jetbrains.kotlin.descriptors.CallableDescriptor..org.jetbrains.kotlin.descriptors.CallableDescriptor?)

'typeParam' @ [56:51] ==> val typeParam: TypeParameterDescriptor defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.checkReifieidTypeParameters[LocalVariableDescriptor]

'typeArgument' @ [57:37] ==> val typeArgument: KotlinType defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.checkReifieidTypeParameters[LocalVariableDescriptor]

'constructor' @ [57:50] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'declarationDescriptor' @ [57:62] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'checkJsModuleUsage' @ [58:13] ==> public fun checkJsModuleUsage(bindingContext: BindingContext, diagnosticSink: DiagnosticSink, container: DeclarationDescriptor, callee: DeclarationDescriptor, reportOn: PsiElement): Unit defined in org.jetbrains.kotlin.js.resolve.diagnostics in file JsModuleCheckUtil.kt[SimpleFunctionDescriptorImpl]

'context' @ [58:32] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.checkReifieidTypeParameters[ValueParameterDescriptorImpl]

'trace' @ [58:40] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[DeserializedPropertyDescriptor]

'bindingContext' @ [58:46] ==> public final val BindingTrace.bindingContext: BindingContext[MyPropertyDescriptor]

'context' @ [58:62] ==> value-parameter context: CallCheckerContext defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.checkReifieidTypeParameters[ValueParameterDescriptorImpl]

'trace' @ [58:70] ==> public final val trace: BindingTrace defined in org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext[DeserializedPropertyDescriptor]

'containingDescriptor' @ [58:77] ==> val containingDescriptor: DeclarationDescriptor defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.checkReifieidTypeParameters[LocalVariableDescriptor]

'typeArgumentClass' @ [58:99] ==> val typeArgumentClass: ClassDescriptor defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.checkReifieidTypeParameters[LocalVariableDescriptor]

'argPsi' @ [58:118] ==> val argPsi: PsiElement defined in org.jetbrains.kotlin.js.resolve.diagnostics.JsModuleCallChecker.checkReifieidTypeParameters[LocalVariableDescriptor]

