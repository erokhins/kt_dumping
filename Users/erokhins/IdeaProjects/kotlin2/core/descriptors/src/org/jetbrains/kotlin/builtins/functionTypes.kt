'invoke' @ [40:9] ==> public abstract operator fun invoke(p1: KotlinType): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'this' @ [40:19] ==> <this> defined in org.jetbrains.kotlin.builtins.isTypeOrSubtypeOf[ReceiverParameterDescriptorImpl]

'dfsFromNode' @ [41:13] ==> public open fun <N : (Any..Any?), R : (Any..Any?)> dfsFromNode(@NotNull p0: KotlinType, @NotNull p1: DFS.Neighbors<(KotlinType..KotlinType?)>, @NotNull p2: DFS.Visited<(KotlinType..KotlinType?)>, @NotNull p3: DFS.NodeHandler<(KotlinType..KotlinType?), (Boolean..Boolean?)>): (Boolean..Boolean?) defined in org.jetbrains.kotlin.utils.DFS[JavaMethodDescriptor]
Inferred types:
    <N : (Any..Any?)> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)
    <R : (Any..Any?)> -> (kotlin.Boolean..kotlin.Boolean?)

'this' @ [42:17] ==> <this> defined in org.jetbrains.kotlin.builtins.isTypeOrSubtypeOf[ReceiverParameterDescriptorImpl]

'Neighbors' @ [43:21] ==> public final fun <N : (Any..Any?)> Neighbors(function: ((KotlinType..KotlinType?)) -> (MutableIterable<(KotlinType..KotlinType?)>..Iterable<(KotlinType..KotlinType?)>)): DFS.Neighbors<(KotlinType..KotlinType?)> defined in org.jetbrains.kotlin.utils.DFS[SimpleFunctionDescriptorImpl]
Inferred types:
    <N : (Any..Any?)> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)

'it' @ [43:33] ==> value-parameter it: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.builtins.isTypeOrSubtypeOf.<anonymous>[ValueParameterDescriptorImpl]

'constructor' @ [43:36] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[PropertyDescriptorImpl]

'supertypes' @ [43:48] ==> public final val TypeConstructor.supertypes: Collection<(KotlinType..KotlinType?)>[MyPropertyDescriptor]

'VisitedWithSet' @ [44:21] ==> public constructor VisitedWithSet<N : (Any..Any?)>() defined in org.jetbrains.kotlin.utils.DFS.VisitedWithSet[JavaClassConstructorDescriptor]
Inferred types:
    <N : (Any..Any?)> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)

'DFS.AbstractNodeHandler<KotlinType, Boolean>' @ [45:26] ==> public constructor AbstractNodeHandler<N : (Any..Any?), R : (Any..Any?)>() defined in org.jetbrains.kotlin.utils.DFS.AbstractNodeHandler[JavaClassConstructorDescriptor]
Inferred types:
    <N : (Any..Any?)> -> KotlinType
    <R : (Any..Any?)> -> Boolean

'invoke' @ [49:29] ==> public abstract operator fun invoke(p1: KotlinType): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'current' @ [49:39] ==> value-parameter current: KotlinType defined in org.jetbrains.kotlin.builtins.isTypeOrSubtypeOf.<no name provided>.beforeChildren[ValueParameterDescriptorImpl]

'result' @ [50:29] ==> private final var result: Boolean defined in org.jetbrains.kotlin.builtins.isTypeOrSubtypeOf.<no name provided>[PropertyDescriptorImpl]

'!' @ [52:32] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'result' @ [52:33] ==> private final var result: Boolean defined in org.jetbrains.kotlin.builtins.isTypeOrSubtypeOf.<no name provided>[PropertyDescriptorImpl]

'result' @ [55:45] ==> private final var result: Boolean defined in org.jetbrains.kotlin.builtins.isTypeOrSubtypeOf.<no name provided>[PropertyDescriptorImpl]

'isTypeOrSubtypeOf' @ [60:13] ==> private fun KotlinType.isTypeOrSubtypeOf(predicate: (KotlinType) -> Boolean): Boolean defined in org.jetbrains.kotlin.builtins in file functionTypes.kt[SimpleFunctionDescriptorImpl]

'it' @ [60:33] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.builtins.<get-isFunctionTypeOrSubtype>.<anonymous>[ValueParameterDescriptorImpl]

'isFunctionType' @ [60:36] ==> public val KotlinType.isFunctionType: Boolean defined in org.jetbrains.kotlin.builtins in file functionTypes.kt[PropertyDescriptorImpl]

'isTypeOrSubtypeOf' @ [63:13] ==> private fun KotlinType.isTypeOrSubtypeOf(predicate: (KotlinType) -> Boolean): Boolean defined in org.jetbrains.kotlin.builtins in file functionTypes.kt[SimpleFunctionDescriptorImpl]

'it' @ [63:33] ==> value-parameter it: KotlinType defined in org.jetbrains.kotlin.builtins.<get-isBuiltinFunctionalTypeOrSubtype>.<anonymous>[ValueParameterDescriptorImpl]

'isBuiltinFunctionalType' @ [63:36] ==> public val KotlinType.isBuiltinFunctionalType: Boolean defined in org.jetbrains.kotlin.builtins in file functionTypes.kt[PropertyDescriptorImpl]

'constructor' @ [66:13] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[PropertyDescriptorImpl]

'declarationDescriptor' @ [66:25] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'getFunctionalClassKind' @ [66:48] ==> public fun DeclarationDescriptor.getFunctionalClassKind(): FunctionClassDescriptor.Kind? defined in org.jetbrains.kotlin.builtins in file functionTypes.kt[SimpleFunctionDescriptorImpl]

'Function' @ [66:105] ==> enum entry Function defined in org.jetbrains.kotlin.builtins.functions.FunctionClassDescriptor.Kind[FakeCallableDescriptorForObject]

'constructor' @ [69:13] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[PropertyDescriptorImpl]

'declarationDescriptor' @ [69:25] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'getFunctionalClassKind' @ [69:48] ==> public fun DeclarationDescriptor.getFunctionalClassKind(): FunctionClassDescriptor.Kind? defined in org.jetbrains.kotlin.builtins in file functionTypes.kt[SimpleFunctionDescriptorImpl]

'SuspendFunction' @ [69:105] ==> enum entry SuspendFunction defined in org.jetbrains.kotlin.builtins.functions.FunctionClassDescriptor.Kind[FakeCallableDescriptorForObject]

'constructor' @ [73:20] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[PropertyDescriptorImpl]

'declarationDescriptor' @ [73:32] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'getFunctionalClassKind' @ [73:55] ==> public fun DeclarationDescriptor.getFunctionalClassKind(): FunctionClassDescriptor.Kind? defined in org.jetbrains.kotlin.builtins in file functionTypes.kt[SimpleFunctionDescriptorImpl]

'kind' @ [74:16] ==> val kind: FunctionClassDescriptor.Kind? defined in org.jetbrains.kotlin.builtins.<get-isBuiltinFunctionalType>[LocalVariableDescriptor]

'Function' @ [74:53] ==> enum entry Function defined in org.jetbrains.kotlin.builtins.functions.FunctionClassDescriptor.Kind[FakeCallableDescriptorForObject]

'kind' @ [75:16] ==> val kind: FunctionClassDescriptor.Kind? defined in org.jetbrains.kotlin.builtins.<get-isBuiltinFunctionalType>[LocalVariableDescriptor]

'SuspendFunction' @ [75:53] ==> enum entry SuspendFunction defined in org.jetbrains.kotlin.builtins.functions.FunctionClassDescriptor.Kind[FakeCallableDescriptorForObject]

'!' @ [79:9] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'classId' @ [79:10] ==> value-parameter classId: ClassId defined in org.jetbrains.kotlin.builtins.isBuiltinFunctionClass[ValueParameterDescriptorImpl]

'startsWith' @ [79:18] ==> public open fun startsWith(@NotNull segment: Name): Boolean defined in org.jetbrains.kotlin.name.ClassId[JavaMethodDescriptor]

'BUILT_INS_PACKAGE_NAME' @ [79:44] ==> public final val BUILT_INS_PACKAGE_NAME: (Name..Name?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaPropertyDescriptor]

'classId' @ [81:16] ==> value-parameter classId: ClassId defined in org.jetbrains.kotlin.builtins.isBuiltinFunctionClass[ValueParameterDescriptorImpl]

'asSingleFqName' @ [81:24] ==> @NotNull public open fun asSingleFqName(): FqName defined in org.jetbrains.kotlin.name.ClassId[JavaMethodDescriptor]

'toUnsafe' @ [81:41] ==> @NotNull public open fun toUnsafe(): FqNameUnsafe defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'getFunctionalClassKind' @ [81:52] ==> private fun FqNameUnsafe.getFunctionalClassKind(): FunctionClassDescriptor.Kind? defined in org.jetbrains.kotlin.builtins in file functionTypes.kt[SimpleFunctionDescriptorImpl]

'kind' @ [82:12] ==> val kind: FunctionClassDescriptor.Kind? defined in org.jetbrains.kotlin.builtins.isBuiltinFunctionClass[LocalVariableDescriptor]

'Function' @ [82:49] ==> enum entry Function defined in org.jetbrains.kotlin.builtins.functions.FunctionClassDescriptor.Kind[FakeCallableDescriptorForObject]

'kind' @ [83:12] ==> val kind: FunctionClassDescriptor.Kind? defined in org.jetbrains.kotlin.builtins.isBuiltinFunctionClass[LocalVariableDescriptor]

'SuspendFunction' @ [83:49] ==> enum entry SuspendFunction defined in org.jetbrains.kotlin.builtins.functions.FunctionClassDescriptor.Kind[FakeCallableDescriptorForObject]

'isFunctionType' @ [87:13] ==> public val KotlinType.isFunctionType: Boolean defined in org.jetbrains.kotlin.builtins in file functionTypes.kt[PropertyDescriptorImpl]

'!' @ [87:31] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isTypeAnnotatedWithExtensionFunctionType' @ [87:32] ==> private val KotlinType.isTypeAnnotatedWithExtensionFunctionType: Boolean defined in org.jetbrains.kotlin.builtins in file functionTypes.kt[PropertyDescriptorImpl]

'isFunctionType' @ [90:13] ==> public val KotlinType.isFunctionType: Boolean defined in org.jetbrains.kotlin.builtins in file functionTypes.kt[PropertyDescriptorImpl]

'isTypeAnnotatedWithExtensionFunctionType' @ [90:31] ==> private val KotlinType.isTypeAnnotatedWithExtensionFunctionType: Boolean defined in org.jetbrains.kotlin.builtins in file functionTypes.kt[PropertyDescriptorImpl]

'isBuiltinFunctionalType' @ [93:13] ==> public val KotlinType.isBuiltinFunctionalType: Boolean defined in org.jetbrains.kotlin.builtins in file functionTypes.kt[PropertyDescriptorImpl]

'isTypeAnnotatedWithExtensionFunctionType' @ [93:40] ==> private val KotlinType.isTypeAnnotatedWithExtensionFunctionType: Boolean defined in org.jetbrains.kotlin.builtins in file functionTypes.kt[PropertyDescriptorImpl]

'annotations' @ [96:13] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.types.KotlinType[PropertyDescriptorImpl]

'findAnnotation' @ [96:25] ==> public open fun findAnnotation(fqName: FqName): AnnotationDescriptor? defined in org.jetbrains.kotlin.descriptors.annotations.Annotations[SimpleFunctionDescriptorImpl]

'FQ_NAMES' @ [96:55] ==> public final val FQ_NAMES: (KotlinBuiltIns.FqNames..KotlinBuiltIns.FqNames?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaPropertyDescriptor]

'extensionFunctionType' @ [96:64] ==> public final val extensionFunctionType: (FqName..FqName?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns.FqNames[JavaPropertyDescriptor]

'fqName' @ [103:12] ==> value-parameter fqName: FqNameUnsafe defined in org.jetbrains.kotlin.builtins.isNumberedFunctionClassFqName[ValueParameterDescriptorImpl]

'startsWith' @ [103:19] ==> public open fun startsWith(@NotNull segment: Name): Boolean defined in org.jetbrains.kotlin.name.FqNameUnsafe[JavaMethodDescriptor]

'BUILT_INS_PACKAGE_NAME' @ [103:45] ==> public final val BUILT_INS_PACKAGE_NAME: (Name..Name?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaPropertyDescriptor]

'fqName' @ [104:12] ==> value-parameter fqName: FqNameUnsafe defined in org.jetbrains.kotlin.builtins.isNumberedFunctionClassFqName[ValueParameterDescriptorImpl]

'getFunctionalClassKind' @ [104:19] ==> private fun FqNameUnsafe.getFunctionalClassKind(): FunctionClassDescriptor.Kind? defined in org.jetbrains.kotlin.builtins in file functionTypes.kt[SimpleFunctionDescriptorImpl]

'Function' @ [104:76] ==> enum entry Function defined in org.jetbrains.kotlin.builtins.functions.FunctionClassDescriptor.Kind[FakeCallableDescriptorForObject]

'this' @ [108:9] ==> <this> defined in org.jetbrains.kotlin.builtins.getFunctionalClassKind[ReceiverParameterDescriptorImpl]

'!' @ [109:9] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isUnderKotlinPackage' @ [109:25] ==> public open fun isUnderKotlinPackage(@NotNull descriptor: DeclarationDescriptor): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'this' @ [109:46] ==> <this> defined in org.jetbrains.kotlin.builtins.getFunctionalClassKind[ReceiverParameterDescriptorImpl]

'fqNameUnsafe' @ [111:12] ==> public val DeclarationDescriptor.fqNameUnsafe: FqNameUnsafe defined in org.jetbrains.kotlin.resolve.descriptorUtil in file DescriptorUtils.kt[PropertyDescriptorImpl]

'getFunctionalClassKind' @ [111:25] ==> private fun FqNameUnsafe.getFunctionalClassKind(): FunctionClassDescriptor.Kind? defined in org.jetbrains.kotlin.builtins in file functionTypes.kt[SimpleFunctionDescriptorImpl]

'!' @ [115:9] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isSafe' @ [115:10] ==> public final val FqNameUnsafe.isSafe: Boolean[MyPropertyDescriptor]

'isRoot' @ [115:20] ==> public final val FqNameUnsafe.isRoot: Boolean[MyPropertyDescriptor]

'BuiltInFictitiousFunctionClassFactory' @ [117:12] ==> public companion object defined in org.jetbrains.kotlin.builtins.functions.BuiltInFictitiousFunctionClassFactory[FakeCallableDescriptorForObject]

'getFunctionalClassKind' @ [117:50] ==> @JvmStatic public final fun getFunctionalClassKind(className: String, packageFqName: FqName): FunctionClassDescriptor.Kind? defined in org.jetbrains.kotlin.builtins.functions.BuiltInFictitiousFunctionClassFactory.Companion[SimpleFunctionDescriptorImpl]

'shortName' @ [117:73] ==> @NotNull public open fun shortName(): Name defined in org.jetbrains.kotlin.name.FqNameUnsafe[JavaMethodDescriptor]

'asString' @ [117:85] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'toSafe' @ [117:97] ==> @NotNull public open fun toSafe(): FqName defined in org.jetbrains.kotlin.name.FqNameUnsafe[JavaMethodDescriptor]

'parent' @ [117:106] ==> @NotNull public open fun parent(): FqName defined in org.jetbrains.kotlin.name.FqName[JavaMethodDescriptor]

'assert' @ [122:5] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'isBuiltinFunctionalType' @ [122:12] ==> public val KotlinType.isBuiltinFunctionalType: Boolean defined in org.jetbrains.kotlin.builtins in file functionTypes.kt[PropertyDescriptorImpl]

'this' @ [122:62] ==> <this> defined in org.jetbrains.kotlin.builtins.getReceiverTypeFromFunctionType[ReceiverParameterDescriptorImpl]

'if (isTypeAnnotatedWithExtensionFunctionType) arguments.first().type else null' @ [123:12] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType?, elseBranch: KotlinType?): KotlinType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType?

'isTypeAnnotatedWithExtensionFunctionType' @ [123:16] ==> private val KotlinType.isTypeAnnotatedWithExtensionFunctionType: Boolean defined in org.jetbrains.kotlin.builtins in file functionTypes.kt[PropertyDescriptorImpl]

'arguments' @ [123:58] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[PropertyDescriptorImpl]

'first' @ [123:68] ==> public fun <T> List<TypeProjection>.first(): TypeProjection defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection

'type' @ [123:76] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'assert' @ [127:5] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'isBuiltinFunctionalType' @ [127:12] ==> public val KotlinType.isBuiltinFunctionalType: Boolean defined in org.jetbrains.kotlin.builtins in file functionTypes.kt[PropertyDescriptorImpl]

'this' @ [127:62] ==> <this> defined in org.jetbrains.kotlin.builtins.getReturnTypeFromFunctionType[ReceiverParameterDescriptorImpl]

'arguments' @ [128:12] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[PropertyDescriptorImpl]

'last' @ [128:22] ==> public fun <T> List<TypeProjection>.last(): TypeProjection defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection

'type' @ [128:29] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'assert' @ [132:5] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'isBuiltinFunctionalType' @ [132:12] ==> public val KotlinType.isBuiltinFunctionalType: Boolean defined in org.jetbrains.kotlin.builtins in file functionTypes.kt[PropertyDescriptorImpl]

'this' @ [132:62] ==> <this> defined in org.jetbrains.kotlin.builtins.replaceReturnType[ReceiverParameterDescriptorImpl]

'arguments' @ [133:38] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[PropertyDescriptorImpl]

'toMutableList' @ [133:48] ==> public fun <T> Collection<TypeProjection>.toMutableList(): MutableList<TypeProjection> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection

'apply' @ [133:64] ==> @InlineOnly public inline fun <T> MutableList<TypeProjection>.apply(block: MutableList<TypeProjection>.() -> Unit): MutableList<TypeProjection> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> MutableList<TypeProjection>

'set' @ [133:72] ==> public abstract operator fun set(index: Int, element: TypeProjection): TypeProjection defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'size' @ [133:76] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'TypeProjectionImpl' @ [133:86] ==> public constructor TypeProjectionImpl(@NotNull type: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'newReturnType' @ [133:105] ==> value-parameter newReturnType: KotlinType defined in org.jetbrains.kotlin.builtins.replaceReturnType[ValueParameterDescriptorImpl]

'replace' @ [134:12] ==> @JvmOverloads public fun KotlinType.replace(newArguments: List<TypeProjection> = ..., newAnnotations: Annotations = ...): KotlinType defined in org.jetbrains.kotlin.types in file TypeSubstitution.kt[SimpleFunctionDescriptorImpl]

'argumentsWithNewReturnType' @ [134:35] ==> val argumentsWithNewReturnType: MutableList<TypeProjection> defined in org.jetbrains.kotlin.builtins.replaceReturnType[LocalVariableDescriptor]

'assert' @ [138:5] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'isBuiltinFunctionalType' @ [138:12] ==> public val KotlinType.isBuiltinFunctionalType: Boolean defined in org.jetbrains.kotlin.builtins in file functionTypes.kt[PropertyDescriptorImpl]

'this' @ [138:62] ==> <this> defined in org.jetbrains.kotlin.builtins.getValueParameterTypesFromFunctionType[ReceiverParameterDescriptorImpl]

'arguments' @ [139:21] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[PropertyDescriptorImpl]

'if (isBuiltinExtensionFunctionalType) 1 else 0' @ [140:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Int, elseBranch: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Int

'isBuiltinExtensionFunctionalType' @ [140:21] ==> public val KotlinType.isBuiltinExtensionFunctionalType: Boolean defined in org.jetbrains.kotlin.builtins in file functionTypes.kt[PropertyDescriptorImpl]

'arguments' @ [141:16] ==> val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.builtins.getValueParameterTypesFromFunctionType[LocalVariableDescriptor]

'size' @ [141:26] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'assert' @ [142:5] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'first' @ [142:12] ==> val first: Int defined in org.jetbrains.kotlin.builtins.getValueParameterTypesFromFunctionType[LocalVariableDescriptor]

'last' @ [142:21] ==> val last: Int defined in org.jetbrains.kotlin.builtins.getValueParameterTypesFromFunctionType[LocalVariableDescriptor]

'this' @ [142:59] ==> <this> defined in org.jetbrains.kotlin.builtins.getValueParameterTypesFromFunctionType[ReceiverParameterDescriptorImpl]

'arguments' @ [143:12] ==> val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.builtins.getValueParameterTypesFromFunctionType[LocalVariableDescriptor]

'subList' @ [143:22] ==> public abstract fun subList(fromIndex: Int, toIndex: Int): List<TypeProjection> defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'first' @ [143:30] ==> val first: Int defined in org.jetbrains.kotlin.builtins.getValueParameterTypesFromFunctionType[LocalVariableDescriptor]

'last' @ [143:37] ==> val last: Int defined in org.jetbrains.kotlin.builtins.getValueParameterTypesFromFunctionType[LocalVariableDescriptor]

'annotations' @ [147:22] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.types.KotlinType[PropertyDescriptorImpl]

'findAnnotation' @ [147:34] ==> public open fun findAnnotation(fqName: FqName): AnnotationDescriptor? defined in org.jetbrains.kotlin.descriptors.annotations.Annotations[SimpleFunctionDescriptorImpl]

'FQ_NAMES' @ [147:64] ==> public final val FQ_NAMES: (KotlinBuiltIns.FqNames..KotlinBuiltIns.FqNames?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaPropertyDescriptor]

'parameterName' @ [147:73] ==> public final val parameterName: (FqName..FqName?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns.FqNames[JavaPropertyDescriptor]

'?:' @ [148:16] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: String?, right: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> String

'annotation' @ [148:17] ==> val annotation: AnnotationDescriptor defined in org.jetbrains.kotlin.builtins.extractParameterNameFromFunctionTypeArgument[LocalVariableDescriptor]

'allValueArguments' @ [148:28] ==> public abstract val allValueArguments: Map<Name, ConstantValue<*>> defined in org.jetbrains.kotlin.descriptors.annotations.AnnotationDescriptor[PropertyDescriptorImpl]

'values' @ [148:46] ==> public abstract val values: Collection<ConstantValue<*>> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'singleOrNull' @ [148:53] ==> public fun <T> Iterable<ConstantValue<*>>.singleOrNull(): ConstantValue<*>? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ConstantValue<*>

'value' @ [149:26] ==> public open val value: String defined in org.jetbrains.kotlin.resolve.constants.StringValue[PropertyDescriptorImpl]

'takeIf' @ [150:26] ==> @InlineOnly @SinceKotlin public inline fun <T> String.takeIf(predicate: (String) -> Boolean): String? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'isValidIdentifier' @ [150:40] ==> public open fun isValidIdentifier(@NotNull name: String): Boolean defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'it' @ [150:58] ==> value-parameter it: String defined in org.jetbrains.kotlin.builtins.extractParameterNameFromFunctionTypeArgument.<anonymous>[ValueParameterDescriptorImpl]

'identifier' @ [152:17] ==> @NotNull public open fun identifier(@NotNull name: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'name' @ [152:28] ==> val name: String defined in org.jetbrains.kotlin.builtins.extractParameterNameFromFunctionTypeArgument[LocalVariableDescriptor]

'ArrayList' @ [162:21] ==> public constructor ArrayList<E : (Any..Any?)>(p0: Int) defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> TypeProjection

'parameterTypes' @ [162:47] ==> value-parameter parameterTypes: List<KotlinType> defined in org.jetbrains.kotlin.builtins.getFunctionTypeArgumentProjections[ValueParameterDescriptorImpl]

'size' @ [162:62] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'if (receiverType != null) 1 else 0' @ [162:70] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Int, elseBranch: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Int

'receiverType' @ [162:74] ==> value-parameter receiverType: KotlinType? defined in org.jetbrains.kotlin.builtins.getFunctionTypeArgumentProjections[ValueParameterDescriptorImpl]

'arguments' @ [164:5] ==> val arguments: ArrayList<TypeProjection> defined in org.jetbrains.kotlin.builtins.getFunctionTypeArgumentProjections[LocalVariableDescriptor]

'addIfNotNull' @ [164:15] ==> public fun <T : Any> MutableCollection<TypeProjection>.addIfNotNull(t: TypeProjection?): Unit defined in org.jetbrains.kotlin.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> TypeProjection

'receiverType' @ [164:28] ==> value-parameter receiverType: KotlinType? defined in org.jetbrains.kotlin.builtins.getFunctionTypeArgumentProjections[ValueParameterDescriptorImpl]

'asTypeProjection' @ [164:42] ==> public fun KotlinType.asTypeProjection(): TypeProjection defined in org.jetbrains.kotlin.types.typeUtil in file TypeUtils.kt[SimpleFunctionDescriptorImpl]

'parameterTypes' @ [166:5] ==> value-parameter parameterTypes: List<KotlinType> defined in org.jetbrains.kotlin.builtins.getFunctionTypeArgumentProjections[ValueParameterDescriptorImpl]

'mapIndexedTo' @ [166:20] ==> public inline fun <T, R, C : MutableCollection<in TypeProjection>> Iterable<KotlinType>.mapIndexedTo(destination: ArrayList<TypeProjection>, transform: (index: Int, KotlinType) -> TypeProjection): ArrayList<TypeProjection> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KotlinType
    <R> -> TypeProjection
    <C : MutableCollection<in R>> -> ArrayList<TypeProjection>

'arguments' @ [166:33] ==> val arguments: ArrayList<TypeProjection> defined in org.jetbrains.kotlin.builtins.getFunctionTypeArgumentProjections[LocalVariableDescriptor]

'parameterNames' @ [167:20] ==> value-parameter parameterNames: List<Name>? defined in org.jetbrains.kotlin.builtins.getFunctionTypeArgumentProjections[ValueParameterDescriptorImpl]

'get' @ [167:36] ==> public abstract operator fun get(index: Int): Name defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'index' @ [167:40] ==> value-parameter index: Int defined in org.jetbrains.kotlin.builtins.getFunctionTypeArgumentProjections.<anonymous>[ValueParameterDescriptorImpl]

'takeUnless' @ [167:48] ==> @InlineOnly @SinceKotlin public inline fun <T> Name.takeUnless(predicate: (Name) -> Boolean): Name? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Name

'it' @ [167:61] ==> value-parameter it: Name defined in org.jetbrains.kotlin.builtins.getFunctionTypeArgumentProjections.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'isSpecial' @ [167:64] ==> public final val Name.isSpecial: Boolean[MyPropertyDescriptor]

'if (name != null) {
            val parameterNameAnnotation = BuiltInAnnotationDescriptor(
                    builtIns,
                    KotlinBuiltIns.FQ_NAMES.parameterName,
                    mapOf(Name.identifier("name") to ConstantValueFactory(builtIns).createStringValue(name.asString()))
            )
            type.replaceAnnotations(AnnotationsImpl(type.annotations + parameterNameAnnotation))
        }
        else {
            type
        }' @ [168:25] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: KotlinType, elseBranch: KotlinType): KotlinType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> KotlinType

'name' @ [168:29] ==> val name: Name? defined in org.jetbrains.kotlin.builtins.getFunctionTypeArgumentProjections.<anonymous>[LocalVariableDescriptor]

'BuiltInAnnotationDescriptor' @ [169:43] ==> public constructor BuiltInAnnotationDescriptor(builtIns: KotlinBuiltIns, fqName: FqName, allValueArguments: Map<Name, ConstantValue<*>>) defined in org.jetbrains.kotlin.descriptors.annotations.BuiltInAnnotationDescriptor[ClassConstructorDescriptorImpl]

'builtIns' @ [170:21] ==> value-parameter builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.builtins.getFunctionTypeArgumentProjections[ValueParameterDescriptorImpl]

'FQ_NAMES' @ [171:36] ==> public final val FQ_NAMES: (KotlinBuiltIns.FqNames..KotlinBuiltIns.FqNames?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaPropertyDescriptor]

'parameterName' @ [171:45] ==> public final val parameterName: (FqName..FqName?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns.FqNames[JavaPropertyDescriptor]

'mapOf' @ [172:21] ==> public fun <K, V> mapOf(pair: Pair<Name, StringValue>): Map<Name, StringValue> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Name
    <V> -> StringValue

'to' @ [172:27] ==> public infix fun <A, B> Name.to(that: StringValue): Pair<Name, StringValue> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Name
    <B> -> StringValue

'identifier' @ [172:32] ==> @NotNull public open fun identifier(@NotNull name: String): Name defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'ConstantValueFactory' @ [172:54] ==> public constructor ConstantValueFactory(builtins: KotlinBuiltIns) defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[ClassConstructorDescriptorImpl]

'builtIns' @ [172:75] ==> value-parameter builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.builtins.getFunctionTypeArgumentProjections[ValueParameterDescriptorImpl]

'createStringValue' @ [172:85] ==> public final fun createStringValue(value: String): StringValue defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[SimpleFunctionDescriptorImpl]

'name' @ [172:103] ==> val name: Name? defined in org.jetbrains.kotlin.builtins.getFunctionTypeArgumentProjections.<anonymous>[LocalVariableDescriptor]

'asString' @ [172:108] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'type' @ [174:13] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.builtins.getFunctionTypeArgumentProjections.<anonymous>[ValueParameterDescriptorImpl]

'replaceAnnotations' @ [174:18] ==> public fun KotlinType.replaceAnnotations(newAnnotations: Annotations): KotlinType defined in org.jetbrains.kotlin.types.typeUtil in file TypeUtils.kt[SimpleFunctionDescriptorImpl]

'AnnotationsImpl' @ [174:37] ==> public constructor AnnotationsImpl(annotations: List<AnnotationDescriptor>) defined in org.jetbrains.kotlin.descriptors.annotations.AnnotationsImpl[ClassConstructorDescriptorImpl]

'type' @ [174:53] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.builtins.getFunctionTypeArgumentProjections.<anonymous>[ValueParameterDescriptorImpl]

'annotations' @ [174:58] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.types.KotlinType[PropertyDescriptorImpl]

'parameterNameAnnotation' @ [174:72] ==> val parameterNameAnnotation: BuiltInAnnotationDescriptor defined in org.jetbrains.kotlin.builtins.getFunctionTypeArgumentProjections.<anonymous>[LocalVariableDescriptor]

'type' @ [177:13] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.builtins.getFunctionTypeArgumentProjections.<anonymous>[ValueParameterDescriptorImpl]

'typeToUse' @ [179:9] ==> val typeToUse: KotlinType defined in org.jetbrains.kotlin.builtins.getFunctionTypeArgumentProjections.<anonymous>[LocalVariableDescriptor]

'asTypeProjection' @ [179:19] ==> public fun KotlinType.asTypeProjection(): TypeProjection defined in org.jetbrains.kotlin.types.typeUtil in file TypeUtils.kt[SimpleFunctionDescriptorImpl]

'arguments' @ [182:5] ==> val arguments: ArrayList<TypeProjection> defined in org.jetbrains.kotlin.builtins.getFunctionTypeArgumentProjections[LocalVariableDescriptor]

'add' @ [182:15] ==> public open fun add(element: TypeProjection): Boolean defined in java.util.ArrayList[JavaMethodDescriptor]

'returnType' @ [182:19] ==> value-parameter returnType: KotlinType defined in org.jetbrains.kotlin.builtins.getFunctionTypeArgumentProjections[ValueParameterDescriptorImpl]

'asTypeProjection' @ [182:30] ==> public fun KotlinType.asTypeProjection(): TypeProjection defined in org.jetbrains.kotlin.types.typeUtil in file TypeUtils.kt[SimpleFunctionDescriptorImpl]

'arguments' @ [184:12] ==> val arguments: ArrayList<TypeProjection> defined in org.jetbrains.kotlin.builtins.getFunctionTypeArgumentProjections[LocalVariableDescriptor]

'JvmOverloads' @ [187:1] ==> public constructor JvmOverloads() defined in kotlin.jvm.JvmOverloads[DeserializedClassConstructorDescriptor]

'getFunctionTypeArgumentProjections' @ [197:21] ==> public fun getFunctionTypeArgumentProjections(receiverType: KotlinType?, parameterTypes: List<KotlinType>, parameterNames: List<Name>?, returnType: KotlinType, builtIns: KotlinBuiltIns): List<TypeProjection> defined in org.jetbrains.kotlin.builtins in file functionTypes.kt[SimpleFunctionDescriptorImpl]

'receiverType' @ [197:56] ==> value-parameter receiverType: KotlinType? defined in org.jetbrains.kotlin.builtins.createFunctionType[ValueParameterDescriptorImpl]

'parameterTypes' @ [197:70] ==> value-parameter parameterTypes: List<KotlinType> defined in org.jetbrains.kotlin.builtins.createFunctionType[ValueParameterDescriptorImpl]

'parameterNames' @ [197:86] ==> value-parameter parameterNames: List<Name>? defined in org.jetbrains.kotlin.builtins.createFunctionType[ValueParameterDescriptorImpl]

'returnType' @ [197:102] ==> value-parameter returnType: KotlinType defined in org.jetbrains.kotlin.builtins.createFunctionType[ValueParameterDescriptorImpl]

'builtIns' @ [197:114] ==> value-parameter builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.builtins.createFunctionType[ValueParameterDescriptorImpl]

'parameterTypes' @ [198:16] ==> value-parameter parameterTypes: List<KotlinType> defined in org.jetbrains.kotlin.builtins.createFunctionType[ValueParameterDescriptorImpl]

'size' @ [198:31] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'if (receiverType == null) size else size + 1' @ [199:26] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Int, elseBranch: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Int

'receiverType' @ [199:30] ==> value-parameter receiverType: KotlinType? defined in org.jetbrains.kotlin.builtins.createFunctionType[ValueParameterDescriptorImpl]

'size' @ [199:52] ==> val size: Int defined in org.jetbrains.kotlin.builtins.createFunctionType[LocalVariableDescriptor]

'size' @ [199:62] ==> val size: Int defined in org.jetbrains.kotlin.builtins.createFunctionType[LocalVariableDescriptor]

'if (suspendFunction) builtIns.getSuspendFunction(parameterCount) else builtIns.getFunction(parameterCount)' @ [200:27] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: ClassDescriptor, elseBranch: ClassDescriptor): ClassDescriptor[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> ClassDescriptor

'suspendFunction' @ [200:31] ==> value-parameter suspendFunction: Boolean = ... defined in org.jetbrains.kotlin.builtins.createFunctionType[ValueParameterDescriptorImpl]

'builtIns' @ [200:48] ==> value-parameter builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.builtins.createFunctionType[ValueParameterDescriptorImpl]

'getSuspendFunction' @ [200:57] ==> @NotNull public open fun getSuspendFunction(parameterCount: Int): ClassDescriptor defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'parameterCount' @ [200:76] ==> val parameterCount: Int defined in org.jetbrains.kotlin.builtins.createFunctionType[LocalVariableDescriptor]

'builtIns' @ [200:97] ==> value-parameter builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.builtins.createFunctionType[ValueParameterDescriptorImpl]

'getFunction' @ [200:106] ==> @NotNull public open fun getFunction(parameterCount: Int): ClassDescriptor defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'parameterCount' @ [200:118] ==> val parameterCount: Int defined in org.jetbrains.kotlin.builtins.createFunctionType[LocalVariableDescriptor]

'if (receiverType == null || annotations.findAnnotation(KotlinBuiltIns.FQ_NAMES.extensionFunctionType) != null) {
                annotations
            }
            else {
                AnnotationsImpl(annotations +
                                BuiltInAnnotationDescriptor(builtIns, KotlinBuiltIns.FQ_NAMES.extensionFunctionType, emptyMap()))
            }' @ [204:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Annotations, elseBranch: Annotations): Annotations[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Annotations

'receiverType' @ [204:17] ==> value-parameter receiverType: KotlinType? defined in org.jetbrains.kotlin.builtins.createFunctionType[ValueParameterDescriptorImpl]

'annotations' @ [204:41] ==> value-parameter annotations: Annotations defined in org.jetbrains.kotlin.builtins.createFunctionType[ValueParameterDescriptorImpl]

'findAnnotation' @ [204:53] ==> public open fun findAnnotation(fqName: FqName): AnnotationDescriptor? defined in org.jetbrains.kotlin.descriptors.annotations.Annotations[SimpleFunctionDescriptorImpl]

'FQ_NAMES' @ [204:83] ==> public final val FQ_NAMES: (KotlinBuiltIns.FqNames..KotlinBuiltIns.FqNames?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaPropertyDescriptor]

'extensionFunctionType' @ [204:92] ==> public final val extensionFunctionType: (FqName..FqName?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns.FqNames[JavaPropertyDescriptor]

'annotations' @ [205:17] ==> value-parameter annotations: Annotations defined in org.jetbrains.kotlin.builtins.createFunctionType[ValueParameterDescriptorImpl]

'AnnotationsImpl' @ [208:17] ==> public constructor AnnotationsImpl(annotations: List<AnnotationDescriptor>) defined in org.jetbrains.kotlin.descriptors.annotations.AnnotationsImpl[ClassConstructorDescriptorImpl]

'annotations' @ [208:33] ==> value-parameter annotations: Annotations defined in org.jetbrains.kotlin.builtins.createFunctionType[ValueParameterDescriptorImpl]

'BuiltInAnnotationDescriptor' @ [209:33] ==> public constructor BuiltInAnnotationDescriptor(builtIns: KotlinBuiltIns, fqName: FqName, allValueArguments: Map<Name, ConstantValue<*>>) defined in org.jetbrains.kotlin.descriptors.annotations.BuiltInAnnotationDescriptor[ClassConstructorDescriptorImpl]

'builtIns' @ [209:61] ==> value-parameter builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.builtins.createFunctionType[ValueParameterDescriptorImpl]

'FQ_NAMES' @ [209:86] ==> public final val FQ_NAMES: (KotlinBuiltIns.FqNames..KotlinBuiltIns.FqNames?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaPropertyDescriptor]

'extensionFunctionType' @ [209:95] ==> public final val extensionFunctionType: (FqName..FqName?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns.FqNames[JavaPropertyDescriptor]

'emptyMap' @ [209:118] ==> public fun <K, V> emptyMap(): Map<Name, ConstantValue<*>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Name
    <V> -> ConstantValue<*>

'KotlinTypeFactory' @ [212:12] ==> public object KotlinTypeFactory defined in org.jetbrains.kotlin.types in file KotlinTypeFactory.kt[FakeCallableDescriptorForObject]

'simpleNotNullType' @ [212:30] ==> @JvmStatic public final fun simpleNotNullType(annotations: Annotations, descriptor: ClassDescriptor, arguments: List<TypeProjection>): SimpleType defined in org.jetbrains.kotlin.types.KotlinTypeFactory[SimpleFunctionDescriptorImpl]

'typeAnnotations' @ [212:48] ==> val typeAnnotations: Annotations defined in org.jetbrains.kotlin.builtins.createFunctionType[LocalVariableDescriptor]

'classDescriptor' @ [212:65] ==> val classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.builtins.createFunctionType[LocalVariableDescriptor]

'arguments' @ [212:82] ==> val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.builtins.createFunctionType[LocalVariableDescriptor]

