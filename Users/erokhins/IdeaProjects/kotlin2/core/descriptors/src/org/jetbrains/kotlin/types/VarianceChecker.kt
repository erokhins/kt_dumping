'DO_NOTHING_3' @ [38:71] ==> public val DO_NOTHING_3: (Any?, Any?, Any?) -> Unit defined in org.jetbrains.kotlin.utils[DeserializedPropertyDescriptor]

'flexibleBounds' @ [41:5] ==> public open val flexibleBounds: Pair<D, D>? defined in org.jetbrains.kotlin.types.TypeHolder[PropertyDescriptorImpl]

'let' @ [41:21] ==> @InlineOnly public inline fun <T, R> Pair<D, D>.let(block: (Pair<D, D>) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<D, D>
    <R> -> Nothing

'it' @ [42:16] ==> value-parameter it: Pair<D, D> defined in org.jetbrains.kotlin.types.checkTypePosition.<anonymous>[ValueParameterDescriptorImpl]

'first' @ [42:19] ==> public final val first: D defined in kotlin.Pair[DeserializedPropertyDescriptor]

'checkTypePosition' @ [42:25] ==> public fun <D : TypeHolder<D>> D.checkTypePosition(position: Variance, reportError: (TypeParameterDescriptor, D, Variance) -> Unit = ..., customVariance: (TypeParameterDescriptor) -> Variance? = ...): Boolean defined in org.jetbrains.kotlin.types[SimpleFunctionDescriptorImpl]
Inferred types:
    <D : TypeHolder<D>> -> D

'position' @ [42:43] ==> value-parameter position: Variance defined in org.jetbrains.kotlin.types.checkTypePosition[ValueParameterDescriptorImpl]

'reportError' @ [42:53] ==> value-parameter reportError: (TypeParameterDescriptor, D, Variance) -> Unit = ... defined in org.jetbrains.kotlin.types.checkTypePosition[ValueParameterDescriptorImpl]

'customVariance' @ [42:66] ==> value-parameter customVariance: (TypeParameterDescriptor) -> Variance? = ... defined in org.jetbrains.kotlin.types.checkTypePosition[ValueParameterDescriptorImpl]

'it' @ [43:21] ==> value-parameter it: Pair<D, D> defined in org.jetbrains.kotlin.types.checkTypePosition.<anonymous>[ValueParameterDescriptorImpl]

'second' @ [43:24] ==> public final val second: D defined in kotlin.Pair[DeserializedPropertyDescriptor]

'checkTypePosition' @ [43:31] ==> public fun <D : TypeHolder<D>> D.checkTypePosition(position: Variance, reportError: (TypeParameterDescriptor, D, Variance) -> Unit = ..., customVariance: (TypeParameterDescriptor) -> Variance? = ...): Boolean defined in org.jetbrains.kotlin.types[SimpleFunctionDescriptorImpl]
Inferred types:
    <D : TypeHolder<D>> -> D

'position' @ [43:49] ==> value-parameter position: Variance defined in org.jetbrains.kotlin.types.checkTypePosition[ValueParameterDescriptorImpl]

'reportError' @ [43:59] ==> value-parameter reportError: (TypeParameterDescriptor, D, Variance) -> Unit = ... defined in org.jetbrains.kotlin.types.checkTypePosition[ValueParameterDescriptorImpl]

'customVariance' @ [43:72] ==> value-parameter customVariance: (TypeParameterDescriptor) -> Variance? = ... defined in org.jetbrains.kotlin.types.checkTypePosition[ValueParameterDescriptorImpl]

'type' @ [46:32] ==> public abstract val type: KotlinType defined in org.jetbrains.kotlin.types.TypeHolder[PropertyDescriptorImpl]

'constructor' @ [46:37] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[PropertyDescriptorImpl]

'declarationDescriptor' @ [46:49] ==> public final val TypeConstructor.declarationDescriptor: ClassifierDescriptor?[MyPropertyDescriptor]

'classifierDescriptor' @ [47:9] ==> val classifierDescriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.types.checkTypePosition[LocalVariableDescriptor]

'invoke' @ [48:35] ==> public abstract operator fun invoke(p1: TypeParameterDescriptor): Variance? defined in kotlin.Function1[FunctionInvokeDescriptor]

'classifierDescriptor' @ [48:50] ==> val classifierDescriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.types.checkTypePosition[LocalVariableDescriptor]

'classifierDescriptor' @ [48:75] ==> val classifierDescriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.types.checkTypePosition[LocalVariableDescriptor]

'variance' @ [48:96] ==> public final val TypeParameterDescriptor.variance: Variance[MyPropertyDescriptor]

'!' @ [49:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'declarationVariance' @ [49:14] ==> val declarationVariance: Variance defined in org.jetbrains.kotlin.types.checkTypePosition[LocalVariableDescriptor]

'allowsPosition' @ [49:34] ==> public final fun allowsPosition(position: Variance): Boolean defined in org.jetbrains.kotlin.types.Variance[SimpleFunctionDescriptorImpl]

'position' @ [49:49] ==> value-parameter position: Variance defined in org.jetbrains.kotlin.types.checkTypePosition[ValueParameterDescriptorImpl]

'!' @ [50:16] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'type' @ [50:17] ==> public abstract val type: KotlinType defined in org.jetbrains.kotlin.types.TypeHolder[PropertyDescriptorImpl]

'annotations' @ [50:22] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.types.KotlinType[PropertyDescriptorImpl]

'hasAnnotation' @ [50:34] ==> public open fun hasAnnotation(fqName: FqName): Boolean defined in org.jetbrains.kotlin.descriptors.annotations.Annotations[SimpleFunctionDescriptorImpl]

'FQ_NAMES' @ [50:93] ==> public final val FQ_NAMES: (KotlinBuiltIns.FqNames..KotlinBuiltIns.FqNames?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaPropertyDescriptor]

'unsafeVariance' @ [50:102] ==> public final val unsafeVariance: (FqName..FqName?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns.FqNames[JavaPropertyDescriptor]

'invoke' @ [51:13] ==> public abstract operator fun invoke(p1: TypeParameterDescriptor, p2: D, p3: Variance): Unit defined in kotlin.Function3[FunctionInvokeDescriptor]

'classifierDescriptor' @ [51:25] ==> val classifierDescriptor: ClassifierDescriptor? defined in org.jetbrains.kotlin.types.checkTypePosition[LocalVariableDescriptor]

'this' @ [51:47] ==> <this> defined in org.jetbrains.kotlin.types.checkTypePosition[ReceiverParameterDescriptorImpl]

'position' @ [51:53] ==> value-parameter position: Variance defined in org.jetbrains.kotlin.types.checkTypePosition[ValueParameterDescriptorImpl]

'declarationVariance' @ [53:16] ==> val declarationVariance: Variance defined in org.jetbrains.kotlin.types.checkTypePosition[LocalVariableDescriptor]

'allowsPosition' @ [53:36] ==> public final fun allowsPosition(position: Variance): Boolean defined in org.jetbrains.kotlin.types.Variance[SimpleFunctionDescriptorImpl]

'position' @ [53:51] ==> value-parameter position: Variance defined in org.jetbrains.kotlin.types.checkTypePosition[ValueParameterDescriptorImpl]

'arguments' @ [57:22] ==> public abstract val arguments: List<TypeHolderArgument<D>?> defined in org.jetbrains.kotlin.types.TypeHolder[PropertyDescriptorImpl]

'argument' @ [58:13] ==> val argument: TypeHolderArgument<D>? defined in org.jetbrains.kotlin.types.checkTypePosition[LocalVariableDescriptor]

'typeParameter' @ [58:23] ==> public abstract val typeParameter: TypeParameterDescriptor? defined in org.jetbrains.kotlin.types.TypeHolderArgument[PropertyDescriptorImpl]

'argument' @ [58:48] ==> val argument: TypeHolderArgument<D>? defined in org.jetbrains.kotlin.types.checkTypePosition[LocalVariableDescriptor]

'projection' @ [58:57] ==> public abstract val projection: TypeProjection defined in org.jetbrains.kotlin.types.TypeHolderArgument[PropertyDescriptorImpl]

'isStarProjection' @ [58:68] ==> public final val TypeProjection.isStarProjection: Boolean[MyPropertyDescriptor]

'!!' @ [60:30] ==> public final fun <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-EXCLEXCL-RESOLVE>`(baseExpr: TypeCheckingProcedure.EnrichedProjectionKind?): TypeCheckingProcedure.EnrichedProjectionKind[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-EXCLEXCL-RESOLVE>`> -> EnrichedProjectionKind

'getEffectiveProjectionKind' @ [60:52] ==> public open fun getEffectiveProjectionKind(@NotNull typeParameter: TypeParameterDescriptor, @NotNull typeArgument: TypeProjection): (TypeCheckingProcedure.EnrichedProjectionKind..TypeCheckingProcedure.EnrichedProjectionKind?) defined in org.jetbrains.kotlin.types.checker.TypeCheckingProcedure[JavaMethodDescriptor]

'argument' @ [60:79] ==> val argument: TypeHolderArgument<D>? defined in org.jetbrains.kotlin.types.checkTypePosition[LocalVariableDescriptor]

'typeParameter' @ [60:88] ==> public abstract val typeParameter: TypeParameterDescriptor? defined in org.jetbrains.kotlin.types.TypeHolderArgument[PropertyDescriptorImpl]

'argument' @ [60:105] ==> val argument: TypeHolderArgument<D>? defined in org.jetbrains.kotlin.types.checkTypePosition[LocalVariableDescriptor]

'projection' @ [60:114] ==> public abstract val projection: TypeProjection defined in org.jetbrains.kotlin.types.TypeHolderArgument[PropertyDescriptorImpl]

'when (projectionKind) {
            EnrichedProjectionKind.OUT -> position
            EnrichedProjectionKind.IN -> position.opposite()
            EnrichedProjectionKind.INV -> Variance.INVARIANT
            EnrichedProjectionKind.STAR -> null // CONFLICTING_PROJECTION error was reported
        }' @ [61:27] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Variance?, entry1: Variance?, entry2: Variance?, entry3: Variance?): Variance?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Variance?

'projectionKind' @ [61:33] ==> val projectionKind: TypeCheckingProcedure.EnrichedProjectionKind defined in org.jetbrains.kotlin.types.checkTypePosition[LocalVariableDescriptor]

'OUT' @ [62:36] ==> enum entry OUT defined in org.jetbrains.kotlin.types.checker.TypeCheckingProcedure.EnrichedProjectionKind[FakeCallableDescriptorForObject]

'position' @ [62:43] ==> value-parameter position: Variance defined in org.jetbrains.kotlin.types.checkTypePosition[ValueParameterDescriptorImpl]

'IN' @ [63:36] ==> enum entry IN defined in org.jetbrains.kotlin.types.checker.TypeCheckingProcedure.EnrichedProjectionKind[FakeCallableDescriptorForObject]

'position' @ [63:42] ==> value-parameter position: Variance defined in org.jetbrains.kotlin.types.checkTypePosition[ValueParameterDescriptorImpl]

'opposite' @ [63:51] ==> public final fun opposite(): Variance defined in org.jetbrains.kotlin.types.Variance[SimpleFunctionDescriptorImpl]

'INV' @ [64:36] ==> enum entry INV defined in org.jetbrains.kotlin.types.checker.TypeCheckingProcedure.EnrichedProjectionKind[FakeCallableDescriptorForObject]

'INVARIANT' @ [64:52] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'STAR' @ [65:36] ==> enum entry STAR defined in org.jetbrains.kotlin.types.checker.TypeCheckingProcedure.EnrichedProjectionKind[FakeCallableDescriptorForObject]

'newPosition' @ [67:13] ==> val newPosition: Variance? defined in org.jetbrains.kotlin.types.checkTypePosition[LocalVariableDescriptor]

'noError' @ [68:13] ==> var noError: Boolean defined in org.jetbrains.kotlin.types.checkTypePosition[LocalVariableDescriptor]

'noError' @ [68:23] ==> var noError: Boolean defined in org.jetbrains.kotlin.types.checkTypePosition[LocalVariableDescriptor]

'argument' @ [68:35] ==> val argument: TypeHolderArgument<D>? defined in org.jetbrains.kotlin.types.checkTypePosition[LocalVariableDescriptor]

'holder' @ [68:44] ==> public abstract val holder: D defined in org.jetbrains.kotlin.types.TypeHolderArgument[PropertyDescriptorImpl]

'checkTypePosition' @ [68:51] ==> public fun <D : TypeHolder<D>> D.checkTypePosition(position: Variance, reportError: (TypeParameterDescriptor, D, Variance) -> Unit = ..., customVariance: (TypeParameterDescriptor) -> Variance? = ...): Boolean defined in org.jetbrains.kotlin.types[SimpleFunctionDescriptorImpl]
Inferred types:
    <D : TypeHolder<D>> -> D

'newPosition' @ [68:69] ==> val newPosition: Variance? defined in org.jetbrains.kotlin.types.checkTypePosition[LocalVariableDescriptor]

'reportError' @ [68:82] ==> value-parameter reportError: (TypeParameterDescriptor, D, Variance) -> Unit = ... defined in org.jetbrains.kotlin.types.checkTypePosition[ValueParameterDescriptorImpl]

'customVariance' @ [68:95] ==> value-parameter customVariance: (TypeParameterDescriptor) -> Variance? = ... defined in org.jetbrains.kotlin.types.checkTypePosition[ValueParameterDescriptorImpl]

'noError' @ [71:12] ==> var noError: Boolean defined in org.jetbrains.kotlin.types.checkTypePosition[LocalVariableDescriptor]

