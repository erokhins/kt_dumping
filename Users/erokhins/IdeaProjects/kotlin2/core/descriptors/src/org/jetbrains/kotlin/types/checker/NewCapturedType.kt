'NewKotlinTypeChecker' @ [32:22] ==> public object NewKotlinTypeChecker : KotlinTypeChecker defined in org.jetbrains.kotlin.types.checker in file NewKotlinTypeChecker.kt[FakeCallableDescriptorForObject]

'transformToNewType' @ [32:43] ==> public final fun transformToNewType(type: SimpleType): SimpleType defined in org.jetbrains.kotlin.types.checker.NewKotlinTypeChecker[SimpleFunctionDescriptorImpl]

'argumentType' @ [32:62] ==> value-parameter argumentType: UnwrappedType defined in org.jetbrains.kotlin.types.checker.prepareArgumentTypeRegardingCaptureTypes[ValueParameterDescriptorImpl]

'lowerIfFlexible' @ [32:75] ==> public fun KotlinType.lowerIfFlexible(): SimpleType defined in org.jetbrains.kotlin.types in file flexibleTypes.kt[SimpleFunctionDescriptorImpl]

'simpleType' @ [33:9] ==> val simpleType: SimpleType defined in org.jetbrains.kotlin.types.checker.prepareArgumentTypeRegardingCaptureTypes[LocalVariableDescriptor]

'constructor' @ [33:20] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.SimpleType[PropertyDescriptorImpl]

'simpleType' @ [35:34] ==> val simpleType: SimpleType defined in org.jetbrains.kotlin.types.checker.prepareArgumentTypeRegardingCaptureTypes[LocalVariableDescriptor]

'constructor' @ [35:45] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.SimpleType[PropertyDescriptorImpl]

'supertypes' @ [35:57] ==> public final val TypeConstructor.supertypes: Collection<(KotlinType..KotlinType?)>[MyPropertyDescriptor]

'map' @ [35:68] ==> public inline fun <T, R> Iterable<(KotlinType..KotlinType?)>.map(transform: ((KotlinType..KotlinType?)) -> UnwrappedType): List<UnwrappedType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)
    <R> -> UnwrappedType

'prepareArgumentTypeRegardingCaptureTypes' @ [36:13] ==> public fun prepareArgumentTypeRegardingCaptureTypes(argumentType: UnwrappedType): UnwrappedType? defined in org.jetbrains.kotlin.types.checker in file NewCapturedType.kt[SimpleFunctionDescriptorImpl]

'it' @ [36:54] ==> value-parameter it: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.types.checker.prepareArgumentTypeRegardingCaptureTypes.<anonymous>[ValueParameterDescriptorImpl]

'unwrap' @ [36:57] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[SimpleFunctionDescriptorImpl]

'apply' @ [36:68] ==> @InlineOnly public inline fun <T> UnwrappedType.apply(block: UnwrappedType.() -> Unit): UnwrappedType defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> UnwrappedType

'changed' @ [36:76] ==> var changed: Boolean defined in org.jetbrains.kotlin.types.checker.prepareArgumentTypeRegardingCaptureTypes[LocalVariableDescriptor]

'it' @ [36:96] ==> value-parameter it: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.types.checker.prepareArgumentTypeRegardingCaptureTypes.<anonymous>[ValueParameterDescriptorImpl]

'unwrap' @ [36:99] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[SimpleFunctionDescriptorImpl]

'!' @ [38:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'changed' @ [38:14] ==> var changed: Boolean defined in org.jetbrains.kotlin.types.checker.prepareArgumentTypeRegardingCaptureTypes[LocalVariableDescriptor]

'intersectTypes' @ [39:16] ==> public fun intersectTypes(types: List<UnwrappedType>): UnwrappedType defined in org.jetbrains.kotlin.types.checker[SimpleFunctionDescriptorImpl]

'preparedSuperTypes' @ [39:31] ==> val preparedSuperTypes: List<UnwrappedType> defined in org.jetbrains.kotlin.types.checker.prepareArgumentTypeRegardingCaptureTypes[LocalVariableDescriptor]

'makeNullableAsSpecified' @ [39:51] ==> public abstract fun makeNullableAsSpecified(newNullability: Boolean): UnwrappedType defined in org.jetbrains.kotlin.types.UnwrappedType[SimpleFunctionDescriptorImpl]

'simpleType' @ [39:75] ==> val simpleType: SimpleType defined in org.jetbrains.kotlin.types.checker.prepareArgumentTypeRegardingCaptureTypes[LocalVariableDescriptor]

'isMarkedNullable' @ [39:86] ==> public abstract val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.SimpleType[PropertyDescriptorImpl]

'simpleType' @ [41:9] ==> val simpleType: SimpleType defined in org.jetbrains.kotlin.types.checker.prepareArgumentTypeRegardingCaptureTypes[LocalVariableDescriptor]

'simpleType' @ [43:16] ==> val simpleType: SimpleType defined in org.jetbrains.kotlin.types.checker.prepareArgumentTypeRegardingCaptureTypes[LocalVariableDescriptor]

'constructor' @ [43:27] ==> public open val constructor: NewCapturedTypeConstructor defined in org.jetbrains.kotlin.types.checker.NewCapturedType[PropertyDescriptorImpl]

'supertypes' @ [43:39] ==> public final val NewCapturedTypeConstructor.supertypes: List<UnwrappedType>[MyPropertyDescriptor]

'takeIf' @ [43:50] ==> @InlineOnly @SinceKotlin public inline fun <T> List<UnwrappedType>.takeIf(predicate: (List<UnwrappedType>) -> Boolean): List<UnwrappedType>? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> List<UnwrappedType>

'it' @ [43:59] ==> value-parameter it: List<UnwrappedType> defined in org.jetbrains.kotlin.types.checker.prepareArgumentTypeRegardingCaptureTypes.<anonymous>[ValueParameterDescriptorImpl]

'isNotEmpty' @ [43:62] ==> @InlineOnly public inline fun <T> Collection<UnwrappedType>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> UnwrappedType

'let' @ [43:78] ==> @InlineOnly public inline fun <T, R> List<UnwrappedType>.let(block: (List<UnwrappedType>) -> UnwrappedType): UnwrappedType defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> List<UnwrappedType>
    <R> -> UnwrappedType

'intersectTypes' @ [44:13] ==> public fun intersectTypes(types: List<UnwrappedType>): UnwrappedType defined in org.jetbrains.kotlin.types.checker[SimpleFunctionDescriptorImpl]

'it' @ [44:28] ==> value-parameter it: List<UnwrappedType> defined in org.jetbrains.kotlin.types.checker.prepareArgumentTypeRegardingCaptureTypes.<anonymous>[ValueParameterDescriptorImpl]

'makeNullableAsSpecified' @ [44:32] ==> public abstract fun makeNullableAsSpecified(newNullability: Boolean): UnwrappedType defined in org.jetbrains.kotlin.types.UnwrappedType[SimpleFunctionDescriptorImpl]

'simpleType' @ [44:56] ==> val simpleType: SimpleType defined in org.jetbrains.kotlin.types.checker.prepareArgumentTypeRegardingCaptureTypes[LocalVariableDescriptor]

'isMarkedNullable' @ [44:67] ==> public abstract val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.SimpleType[PropertyDescriptorImpl]

'argumentType' @ [45:14] ==> value-parameter argumentType: UnwrappedType defined in org.jetbrains.kotlin.types.checker.prepareArgumentTypeRegardingCaptureTypes[ValueParameterDescriptorImpl]

'builtIns' @ [45:27] ==> public val KotlinType.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.types.typeUtil in file TypeUtils.kt[PropertyDescriptorImpl]

'nullableAnyType' @ [45:36] ==> public final val KotlinBuiltIns.nullableAnyType: SimpleType[MyPropertyDescriptor]

'captureFromExpression' @ [47:12] ==> public fun captureFromExpression(type: SimpleType): UnwrappedType? defined in org.jetbrains.kotlin.types.checker in file NewCapturedType.kt[SimpleFunctionDescriptorImpl]

'simpleType' @ [47:34] ==> val simpleType: SimpleType defined in org.jetbrains.kotlin.types.checker.prepareArgumentTypeRegardingCaptureTypes[LocalVariableDescriptor]

'when (type) {
    is SimpleType -> captureFromExpression(type)
    // i.e. if there is nothing to capture -- no changes, if there is something -- use lowerBound as base type
    is FlexibleType -> captureFromExpression(type.lowerBound)
}' @ [50:66] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: UnwrappedType?, entry1: UnwrappedType?): UnwrappedType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> UnwrappedType?

'type' @ [50:72] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.checker.captureFromExpression[ValueParameterDescriptorImpl]

'captureFromExpression' @ [51:22] ==> public fun captureFromExpression(type: SimpleType): UnwrappedType? defined in org.jetbrains.kotlin.types.checker in file NewCapturedType.kt[SimpleFunctionDescriptorImpl]

'type' @ [51:44] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.checker.captureFromExpression[ValueParameterDescriptorImpl]

'captureFromExpression' @ [53:24] ==> public fun captureFromExpression(type: SimpleType): UnwrappedType? defined in org.jetbrains.kotlin.types.checker in file NewCapturedType.kt[SimpleFunctionDescriptorImpl]

'type' @ [53:46] ==> value-parameter type: UnwrappedType defined in org.jetbrains.kotlin.types.checker.captureFromExpression[ValueParameterDescriptorImpl]

'lowerBound' @ [53:51] ==> public final val lowerBound: SimpleType defined in org.jetbrains.kotlin.types.FlexibleType[PropertyDescriptorImpl]

'type' @ [57:27] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.checker.captureFromExpression[ValueParameterDescriptorImpl]

'constructor' @ [57:32] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.SimpleType[PropertyDescriptorImpl]

'typeConstructor' @ [58:9] ==> val typeConstructor: TypeConstructor defined in org.jetbrains.kotlin.types.checker.captureFromExpression[LocalVariableDescriptor]

'typeConstructor' @ [60:34] ==> val typeConstructor: TypeConstructor defined in org.jetbrains.kotlin.types.checker.captureFromExpression[LocalVariableDescriptor]

'supertypes' @ [60:50] ==> public final val IntersectionTypeConstructor.supertypes: Collection<(KotlinType..KotlinType?)>[MyPropertyDescriptor]

'map' @ [60:61] ==> public inline fun <T, R> Iterable<(KotlinType..KotlinType?)>.map(transform: ((KotlinType..KotlinType?)) -> UnwrappedType): List<UnwrappedType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)
    <R> -> UnwrappedType

'captureFromExpression' @ [61:13] ==> public fun captureFromExpression(type: UnwrappedType): UnwrappedType? defined in org.jetbrains.kotlin.types.checker in file NewCapturedType.kt[SimpleFunctionDescriptorImpl]

'it' @ [61:35] ==> value-parameter it: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.types.checker.captureFromExpression.<anonymous>[ValueParameterDescriptorImpl]

'unwrap' @ [61:38] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[SimpleFunctionDescriptorImpl]

'apply' @ [61:49] ==> @InlineOnly public inline fun <T> UnwrappedType.apply(block: UnwrappedType.() -> Unit): UnwrappedType defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> UnwrappedType

'changed' @ [61:57] ==> var changed: Boolean defined in org.jetbrains.kotlin.types.checker.captureFromExpression[LocalVariableDescriptor]

'it' @ [61:77] ==> value-parameter it: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.types.checker.captureFromExpression.<anonymous>[ValueParameterDescriptorImpl]

'unwrap' @ [61:80] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[SimpleFunctionDescriptorImpl]

'!' @ [63:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'changed' @ [63:14] ==> var changed: Boolean defined in org.jetbrains.kotlin.types.checker.captureFromExpression[LocalVariableDescriptor]

'intersectTypes' @ [64:16] ==> public fun intersectTypes(types: List<UnwrappedType>): UnwrappedType defined in org.jetbrains.kotlin.types.checker[SimpleFunctionDescriptorImpl]

'capturedSupertypes' @ [64:31] ==> val capturedSupertypes: List<UnwrappedType> defined in org.jetbrains.kotlin.types.checker.captureFromExpression[LocalVariableDescriptor]

'makeNullableAsSpecified' @ [64:51] ==> public abstract fun makeNullableAsSpecified(newNullability: Boolean): UnwrappedType defined in org.jetbrains.kotlin.types.UnwrappedType[SimpleFunctionDescriptorImpl]

'type' @ [64:75] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.checker.captureFromExpression[ValueParameterDescriptorImpl]

'isMarkedNullable' @ [64:80] ==> public abstract val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.SimpleType[PropertyDescriptorImpl]

'captureFromArguments' @ [66:12] ==> public fun captureFromArguments(type: SimpleType, status: CaptureStatus, acceptNewCapturedType: (argumentIndex: Int, NewCapturedType) -> Unit = ...): SimpleType? defined in org.jetbrains.kotlin.types.checker[SimpleFunctionDescriptorImpl]

'type' @ [66:33] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.checker.captureFromExpression[ValueParameterDescriptorImpl]

'FROM_EXPRESSION' @ [66:53] ==> enum entry FROM_EXPRESSION defined in org.jetbrains.kotlin.types.checker.CaptureStatus[FakeCallableDescriptorForObject]

'DO_NOTHING_2' @ [73:82] ==> public val DO_NOTHING_2: (Any?, Any?) -> Unit defined in org.jetbrains.kotlin.utils[DeserializedPropertyDescriptor]

'type' @ [75:9] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.checker.captureFromArguments[ValueParameterDescriptorImpl]

'arguments' @ [75:14] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.SimpleType[PropertyDescriptorImpl]

'size' @ [75:24] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'type' @ [75:32] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.checker.captureFromArguments[ValueParameterDescriptorImpl]

'constructor' @ [75:37] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.SimpleType[PropertyDescriptorImpl]

'parameters' @ [75:49] ==> public final val TypeConstructor.parameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'size' @ [75:60] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'type' @ [77:21] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.checker.captureFromArguments[ValueParameterDescriptorImpl]

'arguments' @ [77:26] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.SimpleType[PropertyDescriptorImpl]

'arguments' @ [78:9] ==> val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.checker.captureFromArguments[LocalVariableDescriptor]

'all' @ [78:19] ==> public inline fun <T> Iterable<TypeProjection>.all(predicate: (TypeProjection) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection

'it' @ [78:25] ==> value-parameter it: TypeProjection defined in org.jetbrains.kotlin.types.checker.captureFromArguments.<anonymous>[ValueParameterDescriptorImpl]

'projectionKind' @ [78:28] ==> public final val TypeProjection.projectionKind: Variance[MyPropertyDescriptor]

'INVARIANT' @ [78:55] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'arguments' @ [80:24] ==> val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.checker.captureFromArguments[LocalVariableDescriptor]

'map' @ [80:34] ==> public inline fun <T, R> Iterable<TypeProjection>.map(transform: (TypeProjection) -> TypeProjection): List<TypeProjection> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection
    <R> -> TypeProjection

'projection' @ [82:13] ==> value-parameter projection: TypeProjection defined in org.jetbrains.kotlin.types.checker.captureFromArguments.<anonymous>[ValueParameterDescriptorImpl]

'projectionKind' @ [82:24] ==> public final val TypeProjection.projectionKind: Variance[MyPropertyDescriptor]

'INVARIANT' @ [82:51] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'projection' @ [82:73] ==> value-parameter projection: TypeProjection defined in org.jetbrains.kotlin.types.checker.captureFromArguments.<anonymous>[ValueParameterDescriptorImpl]

'if (!projection.isStarProjection && projection.projectionKind == Variance.IN_VARIANCE) {
            projection.type.unwrap()
        } else null' @ [84:25] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: UnwrappedType?, elseBranch: UnwrappedType?): UnwrappedType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> UnwrappedType?

'!' @ [84:29] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'projection' @ [84:30] ==> value-parameter projection: TypeProjection defined in org.jetbrains.kotlin.types.checker.captureFromArguments.<anonymous>[ValueParameterDescriptorImpl]

'isStarProjection' @ [84:41] ==> public final val TypeProjection.isStarProjection: Boolean[MyPropertyDescriptor]

'projection' @ [84:61] ==> value-parameter projection: TypeProjection defined in org.jetbrains.kotlin.types.checker.captureFromArguments.<anonymous>[ValueParameterDescriptorImpl]

'projectionKind' @ [84:72] ==> public final val TypeProjection.projectionKind: Variance[MyPropertyDescriptor]

'IN_VARIANCE' @ [84:99] ==> enum entry IN_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'projection' @ [85:13] ==> value-parameter projection: TypeProjection defined in org.jetbrains.kotlin.types.checker.captureFromArguments.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [85:24] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'unwrap' @ [85:29] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[SimpleFunctionDescriptorImpl]

'NewCapturedType' @ [88:9] ==> internal constructor NewCapturedType(captureStatus: CaptureStatus, lowerType: UnwrappedType?, projection: TypeProjection) defined in org.jetbrains.kotlin.types.checker.NewCapturedType[ClassConstructorDescriptorImpl]

'status' @ [88:25] ==> value-parameter status: CaptureStatus defined in org.jetbrains.kotlin.types.checker.captureFromArguments[ValueParameterDescriptorImpl]

'lowerType' @ [88:33] ==> val lowerType: UnwrappedType? defined in org.jetbrains.kotlin.types.checker.captureFromArguments.<anonymous>[LocalVariableDescriptor]

'projection' @ [88:44] ==> value-parameter projection: TypeProjection defined in org.jetbrains.kotlin.types.checker.captureFromArguments.<anonymous>[ValueParameterDescriptorImpl]

'asTypeProjection' @ [88:56] ==> public fun KotlinType.asTypeProjection(): TypeProjection defined in org.jetbrains.kotlin.types.typeUtil in file TypeUtils.kt[SimpleFunctionDescriptorImpl]

'TypeConstructorSubstitution' @ [91:23] ==> public companion object defined in org.jetbrains.kotlin.types.TypeConstructorSubstitution[FakeCallableDescriptorForObject]

'create' @ [91:51] ==> @JvmStatic public final fun create(typeConstructor: TypeConstructor, arguments: List<TypeProjection>): TypeSubstitution defined in org.jetbrains.kotlin.types.TypeConstructorSubstitution.Companion[SimpleFunctionDescriptorImpl]

'type' @ [91:58] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.checker.captureFromArguments[ValueParameterDescriptorImpl]

'constructor' @ [91:63] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.SimpleType[PropertyDescriptorImpl]

'newArguments' @ [91:76] ==> val newArguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.checker.captureFromArguments[LocalVariableDescriptor]

'buildSubstitutor' @ [91:90] ==> public final fun buildSubstitutor(): TypeSubstitutor defined in org.jetbrains.kotlin.types.TypeSubstitution[SimpleFunctionDescriptorImpl]

'arguments' @ [92:19] ==> val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.checker.captureFromArguments[LocalVariableDescriptor]

'indices' @ [92:29] ==> public val Collection<*>.indices: IntRange defined in kotlin.collections[DeserializedPropertyDescriptor]

'arguments' @ [93:29] ==> val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.checker.captureFromArguments[LocalVariableDescriptor]

'index' @ [93:39] ==> val index: Int defined in org.jetbrains.kotlin.types.checker.captureFromArguments[LocalVariableDescriptor]

'newArguments' @ [94:29] ==> val newArguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.checker.captureFromArguments[LocalVariableDescriptor]

'index' @ [94:42] ==> val index: Int defined in org.jetbrains.kotlin.types.checker.captureFromArguments[LocalVariableDescriptor]

'oldProjection' @ [96:13] ==> val oldProjection: TypeProjection defined in org.jetbrains.kotlin.types.checker.captureFromArguments[LocalVariableDescriptor]

'projectionKind' @ [96:27] ==> public final val TypeProjection.projectionKind: Variance[MyPropertyDescriptor]

'INVARIANT' @ [96:54] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'type' @ [97:27] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.checker.captureFromArguments[ValueParameterDescriptorImpl]

'constructor' @ [97:32] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.SimpleType[PropertyDescriptorImpl]

'parameters' @ [97:44] ==> public final val TypeConstructor.parameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'index' @ [97:55] ==> val index: Int defined in org.jetbrains.kotlin.types.checker.captureFromArguments[LocalVariableDescriptor]

'upperBounds' @ [97:62] ==> public final val TypeParameterDescriptor.upperBounds: (MutableList<(KotlinType..KotlinType?)>..List<(KotlinType..KotlinType?)>)[MyPropertyDescriptor]

'map' @ [97:74] ==> public inline fun <T, R> Iterable<(KotlinType..KotlinType?)>.map(transform: ((KotlinType..KotlinType?)) -> UnwrappedType): List<UnwrappedType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.types.KotlinType..org.jetbrains.kotlin.types.KotlinType?)
    <R> -> UnwrappedType

'NewKotlinTypeChecker' @ [98:13] ==> public object NewKotlinTypeChecker : KotlinTypeChecker defined in org.jetbrains.kotlin.types.checker in file NewKotlinTypeChecker.kt[FakeCallableDescriptorForObject]

'transformToNewType' @ [98:34] ==> public final fun transformToNewType(type: UnwrappedType): UnwrappedType defined in org.jetbrains.kotlin.types.checker.NewKotlinTypeChecker[SimpleFunctionDescriptorImpl]

'substitutor' @ [98:53] ==> val substitutor: TypeSubstitutor defined in org.jetbrains.kotlin.types.checker.captureFromArguments[LocalVariableDescriptor]

'safeSubstitute' @ [98:65] ==> @NotNull public open fun safeSubstitute(@NotNull type: KotlinType, @NotNull howThisTypeIsUsed: Variance): KotlinType defined in org.jetbrains.kotlin.types.TypeSubstitutor[JavaMethodDescriptor]

'it' @ [98:80] ==> value-parameter it: (KotlinType..KotlinType?) defined in org.jetbrains.kotlin.types.checker.captureFromArguments.<anonymous>[ValueParameterDescriptorImpl]

'INVARIANT' @ [98:93] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'unwrap' @ [98:104] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[SimpleFunctionDescriptorImpl]

'!' @ [100:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'oldProjection' @ [100:14] ==> val oldProjection: TypeProjection defined in org.jetbrains.kotlin.types.checker.captureFromArguments[LocalVariableDescriptor]

'isStarProjection' @ [100:28] ==> public final val TypeProjection.isStarProjection: Boolean[MyPropertyDescriptor]

'oldProjection' @ [100:48] ==> val oldProjection: TypeProjection defined in org.jetbrains.kotlin.types.checker.captureFromArguments[LocalVariableDescriptor]

'projectionKind' @ [100:62] ==> public final val TypeProjection.projectionKind: Variance[MyPropertyDescriptor]

'OUT_VARIANCE' @ [100:89] ==> enum entry OUT_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'upperBounds' @ [101:13] ==> var upperBounds: List<UnwrappedType> defined in org.jetbrains.kotlin.types.checker.captureFromArguments[LocalVariableDescriptor]

'NewKotlinTypeChecker' @ [101:28] ==> public object NewKotlinTypeChecker : KotlinTypeChecker defined in org.jetbrains.kotlin.types.checker in file NewKotlinTypeChecker.kt[FakeCallableDescriptorForObject]

'transformToNewType' @ [101:49] ==> public final fun transformToNewType(type: UnwrappedType): UnwrappedType defined in org.jetbrains.kotlin.types.checker.NewKotlinTypeChecker[SimpleFunctionDescriptorImpl]

'oldProjection' @ [101:68] ==> val oldProjection: TypeProjection defined in org.jetbrains.kotlin.types.checker.captureFromArguments[LocalVariableDescriptor]

'type' @ [101:82] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'unwrap' @ [101:87] ==> public abstract fun unwrap(): UnwrappedType defined in org.jetbrains.kotlin.types.KotlinType[SimpleFunctionDescriptorImpl]

'newProjection' @ [104:28] ==> val newProjection: TypeProjection defined in org.jetbrains.kotlin.types.checker.captureFromArguments[LocalVariableDescriptor]

'type' @ [104:42] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'capturedType' @ [105:9] ==> val capturedType: NewCapturedType defined in org.jetbrains.kotlin.types.checker.captureFromArguments[LocalVariableDescriptor]

'constructor' @ [105:22] ==> public open val constructor: NewCapturedTypeConstructor defined in org.jetbrains.kotlin.types.checker.NewCapturedType[PropertyDescriptorImpl]

'initializeSupertypes' @ [105:34] ==> public final fun initializeSupertypes(supertypes: List<UnwrappedType>): Unit defined in org.jetbrains.kotlin.types.checker.NewCapturedTypeConstructor[SimpleFunctionDescriptorImpl]

'upperBounds' @ [105:55] ==> var upperBounds: List<UnwrappedType> defined in org.jetbrains.kotlin.types.checker.captureFromArguments[LocalVariableDescriptor]

'invoke' @ [106:9] ==> public abstract operator fun invoke(argumentIndex: @ParameterName Int, p2: NewCapturedType): Unit defined in kotlin.Function2[FunctionInvokeDescriptor]

'index' @ [106:31] ==> val index: Int defined in org.jetbrains.kotlin.types.checker.captureFromArguments[LocalVariableDescriptor]

'capturedType' @ [106:38] ==> val capturedType: NewCapturedType defined in org.jetbrains.kotlin.types.checker.captureFromArguments[LocalVariableDescriptor]

'KotlinTypeFactory' @ [109:12] ==> public object KotlinTypeFactory defined in org.jetbrains.kotlin.types in file KotlinTypeFactory.kt[FakeCallableDescriptorForObject]

'simpleType' @ [109:30] ==> @JvmStatic public final fun simpleType(annotations: Annotations, constructor: TypeConstructor, arguments: List<TypeProjection>, nullable: Boolean): SimpleType defined in org.jetbrains.kotlin.types.KotlinTypeFactory[SimpleFunctionDescriptorImpl]

'type' @ [109:41] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.checker.captureFromArguments[ValueParameterDescriptorImpl]

'annotations' @ [109:46] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.types.SimpleType[PropertyDescriptorImpl]

'type' @ [109:59] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.checker.captureFromArguments[ValueParameterDescriptorImpl]

'constructor' @ [109:64] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.SimpleType[PropertyDescriptorImpl]

'newArguments' @ [109:77] ==> val newArguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.checker.captureFromArguments[LocalVariableDescriptor]

'type' @ [109:91] ==> value-parameter type: SimpleType defined in org.jetbrains.kotlin.types.checker.captureFromArguments[ValueParameterDescriptorImpl]

'isMarkedNullable' @ [109:96] ==> public abstract val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.SimpleType[PropertyDescriptorImpl]

'Annotations' @ [130:49] ==> public companion object defined in org.jetbrains.kotlin.descriptors.annotations.Annotations[FakeCallableDescriptorForObject]

'EMPTY' @ [130:61] ==> public final val EMPTY: Annotations defined in org.jetbrains.kotlin.descriptors.annotations.Annotations.Companion[PropertyDescriptorImpl]

'SimpleType' @ [132:4] ==> public constructor SimpleType() defined in org.jetbrains.kotlin.types.SimpleType[ClassConstructorDescriptorImpl]

'this' @ [134:13] ==> public constructor NewCapturedType(captureStatus: CaptureStatus, constructor: NewCapturedTypeConstructor, lowerType: UnwrappedType?, annotations: Annotations = ..., isMarkedNullable: Boolean = ...) defined in org.jetbrains.kotlin.types.checker.NewCapturedType[ClassConstructorDescriptorImpl]

'captureStatus' @ [134:18] ==> value-parameter captureStatus: CaptureStatus defined in org.jetbrains.kotlin.types.checker.NewCapturedType.<init>[ValueParameterDescriptorImpl]

'NewCapturedTypeConstructor' @ [134:33] ==> public constructor NewCapturedTypeConstructor(projection: TypeProjection, supertypes: List<UnwrappedType>? = ...) defined in org.jetbrains.kotlin.types.checker.NewCapturedTypeConstructor[ClassConstructorDescriptorImpl]

'projection' @ [134:60] ==> value-parameter projection: TypeProjection defined in org.jetbrains.kotlin.types.checker.NewCapturedType.<init>[ValueParameterDescriptorImpl]

'lowerType' @ [134:73] ==> value-parameter lowerType: UnwrappedType? defined in org.jetbrains.kotlin.types.checker.NewCapturedType.<init>[ValueParameterDescriptorImpl]

'listOf' @ [136:58] ==> @InlineOnly public inline fun <T> listOf(): List<TypeProjection> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection

'createErrorScope' @ [139:28] ==> @NotNull public open fun createErrorScope(@NotNull debugMessage: String, throwExceptions: Boolean): MemberScope defined in org.jetbrains.kotlin.types.ErrorUtils[JavaMethodDescriptor]

'NewCapturedType' @ [142:13] ==> public constructor NewCapturedType(captureStatus: CaptureStatus, constructor: NewCapturedTypeConstructor, lowerType: UnwrappedType?, annotations: Annotations = ..., isMarkedNullable: Boolean = ...) defined in org.jetbrains.kotlin.types.checker.NewCapturedType[ClassConstructorDescriptorImpl]

'captureStatus' @ [142:29] ==> public final val captureStatus: CaptureStatus defined in org.jetbrains.kotlin.types.checker.NewCapturedType[PropertyDescriptorImpl]

'constructor' @ [142:44] ==> public open val constructor: NewCapturedTypeConstructor defined in org.jetbrains.kotlin.types.checker.NewCapturedType[PropertyDescriptorImpl]

'lowerType' @ [142:57] ==> public final val lowerType: UnwrappedType? defined in org.jetbrains.kotlin.types.checker.NewCapturedType[PropertyDescriptorImpl]

'newAnnotations' @ [142:68] ==> value-parameter newAnnotations: Annotations defined in org.jetbrains.kotlin.types.checker.NewCapturedType.replaceAnnotations[ValueParameterDescriptorImpl]

'isMarkedNullable' @ [142:84] ==> public open val isMarkedNullable: Boolean defined in org.jetbrains.kotlin.types.checker.NewCapturedType[PropertyDescriptorImpl]

'NewCapturedType' @ [145:13] ==> public constructor NewCapturedType(captureStatus: CaptureStatus, constructor: NewCapturedTypeConstructor, lowerType: UnwrappedType?, annotations: Annotations = ..., isMarkedNullable: Boolean = ...) defined in org.jetbrains.kotlin.types.checker.NewCapturedType[ClassConstructorDescriptorImpl]

'captureStatus' @ [145:29] ==> public final val captureStatus: CaptureStatus defined in org.jetbrains.kotlin.types.checker.NewCapturedType[PropertyDescriptorImpl]

'constructor' @ [145:44] ==> public open val constructor: NewCapturedTypeConstructor defined in org.jetbrains.kotlin.types.checker.NewCapturedType[PropertyDescriptorImpl]

'lowerType' @ [145:57] ==> public final val lowerType: UnwrappedType? defined in org.jetbrains.kotlin.types.checker.NewCapturedType[PropertyDescriptorImpl]

'annotations' @ [145:68] ==> public open val annotations: Annotations defined in org.jetbrains.kotlin.types.checker.NewCapturedType[PropertyDescriptorImpl]

'newNullability' @ [145:81] ==> value-parameter newNullability: Boolean defined in org.jetbrains.kotlin.types.checker.NewCapturedType.makeNullableAsSpecified[ValueParameterDescriptorImpl]

'assert' @ [150:9] ==> @InlineOnly public inline fun assert(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'this' @ [150:16] ==> <this> defined in org.jetbrains.kotlin.types.checker.NewCapturedTypeConstructor[LazyClassReceiverParameterDescriptor]

'supertypes' @ [150:21] ==> private final var supertypes: List<UnwrappedType>? defined in org.jetbrains.kotlin.types.checker.NewCapturedTypeConstructor[PropertyDescriptorImpl]

'this' @ [151:48] ==> <this> defined in org.jetbrains.kotlin.types.checker.NewCapturedTypeConstructor[LazyClassReceiverParameterDescriptor]

'supertypes' @ [151:53] ==> private final var supertypes: List<UnwrappedType>? defined in org.jetbrains.kotlin.types.checker.NewCapturedTypeConstructor[PropertyDescriptorImpl]

'supertypes' @ [151:78] ==> value-parameter supertypes: List<UnwrappedType> defined in org.jetbrains.kotlin.types.checker.NewCapturedTypeConstructor.initializeSupertypes[ValueParameterDescriptorImpl]

'this' @ [153:9] ==> <this> defined in org.jetbrains.kotlin.types.checker.NewCapturedTypeConstructor[LazyClassReceiverParameterDescriptor]

'supertypes' @ [153:14] ==> private final var supertypes: List<UnwrappedType>? defined in org.jetbrains.kotlin.types.checker.NewCapturedTypeConstructor[PropertyDescriptorImpl]

'supertypes' @ [153:27] ==> value-parameter supertypes: List<UnwrappedType> defined in org.jetbrains.kotlin.types.checker.NewCapturedTypeConstructor.initializeSupertypes[ValueParameterDescriptorImpl]

'supertypes' @ [156:36] ==> private final var supertypes: List<UnwrappedType>? defined in org.jetbrains.kotlin.types.checker.NewCapturedTypeConstructor[PropertyDescriptorImpl]

'emptyList' @ [156:50] ==> public fun <T> emptyList(): List<UnwrappedType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> UnwrappedType

'emptyList' @ [157:67] ==> public fun <T> emptyList(): List<TypeParameterDescriptor> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeParameterDescriptor

'projection' @ [162:50] ==> public final val projection: TypeProjection defined in org.jetbrains.kotlin.types.checker.NewCapturedTypeConstructor[PropertyDescriptorImpl]

'type' @ [162:61] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'builtIns' @ [162:66] ==> public val KotlinType.builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.types.typeUtil in file TypeUtils.kt[PropertyDescriptorImpl]

'projection' @ [164:46] ==> public final val projection: TypeProjection defined in org.jetbrains.kotlin.types.checker.NewCapturedTypeConstructor[PropertyDescriptorImpl]

