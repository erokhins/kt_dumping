'FqName' @ [32:46] ==> public constructor FqName(@NotNull p0: String) defined in org.jetbrains.kotlin.name.FqName[JavaClassConstructorDescriptor]

'FqName' @ [33:37] ==> public constructor FqName(@NotNull p0: String) defined in org.jetbrains.kotlin.name.FqName[JavaClassConstructorDescriptor]

'FqName' @ [34:45] ==> public constructor FqName(@NotNull p0: String) defined in org.jetbrains.kotlin.name.FqName[JavaClassConstructorDescriptor]

'!=' @ [45:79] ==> public open fun equals(other: Any?): Boolean defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'applicability' @ [45:80] ==> private final val applicability: Int defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.TypeQualifierWithApplicability[PropertyDescriptorImpl]

'shl' @ [45:99] ==> public final infix fun shl(bitCount: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'elementType' @ [45:105] ==> value-parameter elementType: AnnotationTypeQualifierResolver.QualifierApplicabilityType defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.TypeQualifierWithApplicability.isApplicableTo[ValueParameterDescriptorImpl]

'ordinal' @ [45:117] ==> public final val ordinal: Int defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.QualifierApplicabilityType[DeserializedPropertyDescriptor]

'typeQualifier' @ [47:37] ==> private final val typeQualifier: AnnotationDescriptor defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.TypeQualifierWithApplicability[PropertyDescriptorImpl]

'values' @ [48:64] ==> public final fun values(): Array<AnnotationTypeQualifierResolver.QualifierApplicabilityType> defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.QualifierApplicabilityType[SimpleFunctionDescriptorImpl]

'filter' @ [48:73] ==> public inline fun <T> Array<out AnnotationTypeQualifierResolver.QualifierApplicabilityType>.filter(predicate: (AnnotationTypeQualifierResolver.QualifierApplicabilityType) -> Boolean): List<AnnotationTypeQualifierResolver.QualifierApplicabilityType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> QualifierApplicabilityType

'this' @ [48:80] ==> <this> defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.TypeQualifierWithApplicability[LazyClassReceiverParameterDescriptor]

'isApplicableTo' @ [48:86] ==> private final fun isApplicableTo(elementType: AnnotationTypeQualifierResolver.QualifierApplicabilityType): Boolean defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.TypeQualifierWithApplicability[SimpleFunctionDescriptorImpl]

'storageManager' @ [52:13] ==> value-parameter storageManager: StorageManager defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.<init>[ValueParameterDescriptorImpl]

'createMemoizedFunctionWithNullableValues' @ [52:28] ==> public abstract fun <K, V : Any> createMemoizedFunctionWithNullableValues(compute: (classDescriptor: ClassDescriptor) -> AnnotationDescriptor?): MemoizedFunctionToNullable<@ParameterName ClassDescriptor, AnnotationDescriptor> defined in org.jetbrains.kotlin.storage.StorageManager[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> [@kotlin.ParameterName] ClassDescriptor
    <V : Any> -> AnnotationDescriptor

'this' @ [52:69] ==> <this> defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver[LazyClassReceiverParameterDescriptor]

'computeTypeQualifierNickname' @ [52:75] ==> private final fun computeTypeQualifierNickname(classDescriptor: ClassDescriptor): AnnotationDescriptor? defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver[SimpleFunctionDescriptorImpl]

'!' @ [55:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'classDescriptor' @ [55:14] ==> value-parameter classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.computeTypeQualifierNickname[ValueParameterDescriptorImpl]

'annotations' @ [55:30] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.descriptors.ClassDescriptor[DeserializedPropertyDescriptor]

'hasAnnotation' @ [55:42] ==> public open fun hasAnnotation(fqName: FqName): Boolean defined in org.jetbrains.kotlin.descriptors.annotations.Annotations[DeserializedSimpleFunctionDescriptor]

'TYPE_QUALIFIER_NICKNAME_FQNAME' @ [55:56] ==> private val TYPE_QUALIFIER_NICKNAME_FQNAME: FqName defined in org.jetbrains.kotlin.load.java in file AnnotationTypeQualifierResolver.kt[PropertyDescriptorImpl]

'classDescriptor' @ [57:16] ==> value-parameter classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.computeTypeQualifierNickname[ValueParameterDescriptorImpl]

'annotations' @ [57:32] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.descriptors.ClassDescriptor[DeserializedPropertyDescriptor]

'firstNotNullResult' @ [57:44] ==> public inline fun <T, R : Any> Iterable<AnnotationDescriptor>.firstNotNullResult(transform: (AnnotationDescriptor) -> AnnotationDescriptor?): AnnotationDescriptor? defined in org.jetbrains.kotlin.utils.addToStdlib[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> AnnotationDescriptor
    <R : Any> -> AnnotationDescriptor

'this' @ [57:63] ==> <this> defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver[LazyClassReceiverParameterDescriptor]

'resolveTypeQualifierAnnotation' @ [57:69] ==> public final fun resolveTypeQualifierAnnotation(annotationDescriptor: AnnotationDescriptor): AnnotationDescriptor? defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver[SimpleFunctionDescriptorImpl]

'classDescriptor' @ [61:13] ==> value-parameter classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.resolveTypeQualifierNickname[ValueParameterDescriptorImpl]

'kind' @ [61:29] ==> public final val ClassDescriptor.kind: ClassKind[MyPropertyDescriptor]

'ANNOTATION_CLASS' @ [61:47] ==> enum entry ANNOTATION_CLASS defined in org.jetbrains.kotlin.descriptors.ClassKind[FakeCallableDescriptorForObject]

'invoke' @ [63:16] ==> public abstract fun invoke(classDescriptor: @ParameterName ClassDescriptor): AnnotationDescriptor? defined in org.jetbrains.kotlin.storage.MemoizedFunctionToNullable[FunctionInvokeDescriptor]

'classDescriptor' @ [63:34] ==> value-parameter classDescriptor: ClassDescriptor defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.resolveTypeQualifierNickname[ValueParameterDescriptorImpl]

'jsr305State' @ [67:13] ==> public final val jsr305State: Jsr305State defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver[PropertyDescriptorImpl]

'isIgnored' @ [67:25] ==> public final fun isIgnored(): Boolean defined in org.jetbrains.kotlin.utils.Jsr305State[DeserializedSimpleFunctionDescriptor]

'annotationDescriptor' @ [71:31] ==> value-parameter annotationDescriptor: AnnotationDescriptor defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.resolveTypeQualifierAnnotation[ValueParameterDescriptorImpl]

'annotationClass' @ [71:52] ==> public val AnnotationDescriptor.annotationClass: ClassDescriptor? defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'annotationClass' @ [72:13] ==> val annotationClass: ClassDescriptor defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.resolveTypeQualifierAnnotation[LocalVariableDescriptor]

'isAnnotatedWithTypeQualifier' @ [72:29] ==> private val ClassDescriptor.isAnnotatedWithTypeQualifier: Boolean defined in org.jetbrains.kotlin.load.java in file AnnotationTypeQualifierResolver.kt[PropertyDescriptorImpl]

'annotationDescriptor' @ [72:66] ==> value-parameter annotationDescriptor: AnnotationDescriptor defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.resolveTypeQualifierAnnotation[ValueParameterDescriptorImpl]

'resolveTypeQualifierNickname' @ [74:16] ==> private final fun resolveTypeQualifierNickname(classDescriptor: ClassDescriptor): AnnotationDescriptor? defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver[SimpleFunctionDescriptorImpl]

'annotationClass' @ [74:45] ==> val annotationClass: ClassDescriptor defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.resolveTypeQualifierAnnotation[LocalVariableDescriptor]

'jsr305State' @ [78:13] ==> public final val jsr305State: Jsr305State defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver[PropertyDescriptorImpl]

'isIgnored' @ [78:25] ==> public final fun isIgnored(): Boolean defined in org.jetbrains.kotlin.utils.Jsr305State[DeserializedSimpleFunctionDescriptor]

'annotationDescriptor' @ [83:17] ==> value-parameter annotationDescriptor: AnnotationDescriptor defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.resolveTypeQualifierDefaultAnnotation[ValueParameterDescriptorImpl]

'annotationClass' @ [83:38] ==> public val AnnotationDescriptor.annotationClass: ClassDescriptor? defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'takeIf' @ [83:55] ==> @InlineOnly @SinceKotlin public inline fun <T> ClassDescriptor.takeIf(predicate: (ClassDescriptor) -> Boolean): ClassDescriptor? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ClassDescriptor

'it' @ [83:64] ==> value-parameter it: ClassDescriptor defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.resolveTypeQualifierDefaultAnnotation.<anonymous>[ValueParameterDescriptorImpl]

'annotations' @ [83:67] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.descriptors.ClassDescriptor[DeserializedPropertyDescriptor]

'hasAnnotation' @ [83:79] ==> public open fun hasAnnotation(fqName: FqName): Boolean defined in org.jetbrains.kotlin.descriptors.annotations.Annotations[DeserializedSimpleFunctionDescriptor]

'TYPE_QUALIFIER_DEFAULT_FQNAME' @ [83:93] ==> private val TYPE_QUALIFIER_DEFAULT_FQNAME: FqName defined in org.jetbrains.kotlin.load.java in file AnnotationTypeQualifierResolver.kt[PropertyDescriptorImpl]

'annotationDescriptor' @ [87:17] ==> value-parameter annotationDescriptor: AnnotationDescriptor defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.resolveTypeQualifierDefaultAnnotation[ValueParameterDescriptorImpl]

'annotationClass' @ [87:38] ==> public val AnnotationDescriptor.annotationClass: ClassDescriptor? defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'annotations' @ [88:26] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.descriptors.ClassDescriptor[DeserializedPropertyDescriptor]

'findAnnotation' @ [88:38] ==> public open fun findAnnotation(fqName: FqName): AnnotationDescriptor? defined in org.jetbrains.kotlin.descriptors.annotations.Annotations[DeserializedSimpleFunctionDescriptor]

'TYPE_QUALIFIER_DEFAULT_FQNAME' @ [88:53] ==> private val TYPE_QUALIFIER_DEFAULT_FQNAME: FqName defined in org.jetbrains.kotlin.load.java in file AnnotationTypeQualifierResolver.kt[PropertyDescriptorImpl]

'allValueArguments' @ [89:26] ==> public abstract val allValueArguments: Map<Name, ConstantValue<*>> defined in org.jetbrains.kotlin.descriptors.annotations.AnnotationDescriptor[DeserializedPropertyDescriptor]

'flatMap' @ [90:26] ==> public inline fun <K, V, R> Map<out Name, ConstantValue<*>>.flatMap(transform: (Map.Entry<Name, ConstantValue<*>>) -> Iterable<AnnotationTypeQualifierResolver.QualifierApplicabilityType>): List<AnnotationTypeQualifierResolver.QualifierApplicabilityType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Name
    <V> -> ConstantValue<*>
    <R> -> QualifierApplicabilityType

'component1' @ [90:37] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<Name, ConstantValue<*>>.component1(): Name defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Name
    <V> -> ConstantValue<*>

'component2' @ [90:48] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<Name, ConstantValue<*>>.component2(): ConstantValue<*> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> Name
    <V> -> ConstantValue<*>

'if (parameter == JvmAnnotationNames.DEFAULT_ANNOTATION_MEMBER_NAME)
                                argument.mapConstantToQualifierApplicabilityTypes()
                            else
                                emptyList()' @ [91:29] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: List<AnnotationTypeQualifierResolver.QualifierApplicabilityType>, elseBranch: List<AnnotationTypeQualifierResolver.QualifierApplicabilityType>): List<AnnotationTypeQualifierResolver.QualifierApplicabilityType>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> List<QualifierApplicabilityType>

'parameter' @ [91:33] ==> val parameter: Name defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.resolveTypeQualifierDefaultAnnotation.<anonymous>[LocalVariableDescriptor]

'DEFAULT_ANNOTATION_MEMBER_NAME' @ [91:65] ==> public final val DEFAULT_ANNOTATION_MEMBER_NAME: (Name..Name?) defined in org.jetbrains.kotlin.load.java.JvmAnnotationNames[JavaPropertyDescriptor]

'argument' @ [92:33] ==> val argument: ConstantValue<*> defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.resolveTypeQualifierDefaultAnnotation.<anonymous>[LocalVariableDescriptor]

'mapConstantToQualifierApplicabilityTypes' @ [92:42] ==> private final fun ConstantValue<*>.mapConstantToQualifierApplicabilityTypes(): List<AnnotationTypeQualifierResolver.QualifierApplicabilityType> defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver[SimpleFunctionDescriptorImpl]

'emptyList' @ [94:33] ==> public fun <T> emptyList(): List<AnnotationTypeQualifierResolver.QualifierApplicabilityType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> QualifierApplicabilityType

'fold' @ [96:26] ==> public inline fun <T, R> Iterable<AnnotationTypeQualifierResolver.QualifierApplicabilityType>.fold(initial: Int, operation: (acc: Int, AnnotationTypeQualifierResolver.QualifierApplicabilityType) -> Int): Int defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> QualifierApplicabilityType
    <R> -> Int

'acc' @ [96:67] ==> value-parameter acc: Int defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.resolveTypeQualifierDefaultAnnotation.<anonymous>[ValueParameterDescriptorImpl]

'shl' @ [96:75] ==> public final infix fun shl(bitCount: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'applicabilityType' @ [96:81] ==> value-parameter applicabilityType: AnnotationTypeQualifierResolver.QualifierApplicabilityType defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.resolveTypeQualifierDefaultAnnotation.<anonymous>[ValueParameterDescriptorImpl]

'ordinal' @ [96:99] ==> public final val ordinal: Int defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.QualifierApplicabilityType[DeserializedPropertyDescriptor]

'typeQualifierDefaultAnnotatedClass' @ [99:17] ==> val typeQualifierDefaultAnnotatedClass: ClassDescriptor defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.resolveTypeQualifierDefaultAnnotation[LocalVariableDescriptor]

'annotations' @ [99:52] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.descriptors.ClassDescriptor[DeserializedPropertyDescriptor]

'firstNotNullResult' @ [99:64] ==> public inline fun <T, R : Any> Iterable<AnnotationDescriptor>.firstNotNullResult(transform: (AnnotationDescriptor) -> AnnotationDescriptor?): AnnotationDescriptor? defined in org.jetbrains.kotlin.utils.addToStdlib[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> AnnotationDescriptor
    <R : Any> -> AnnotationDescriptor

'this' @ [99:83] ==> <this> defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver[LazyClassReceiverParameterDescriptor]

'resolveTypeQualifierAnnotation' @ [99:89] ==> public final fun resolveTypeQualifierAnnotation(annotationDescriptor: AnnotationDescriptor): AnnotationDescriptor? defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver[SimpleFunctionDescriptorImpl]

'TypeQualifierWithApplicability' @ [101:16] ==> public constructor TypeQualifierWithApplicability(typeQualifier: AnnotationDescriptor, applicability: Int) defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.TypeQualifierWithApplicability[ClassConstructorDescriptorImpl]

'typeQualifier' @ [101:47] ==> val typeQualifier: AnnotationDescriptor defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.resolveTypeQualifierDefaultAnnotation[LocalVariableDescriptor]

'elementTypesMask' @ [101:62] ==> val elementTypesMask: Int defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.resolveTypeQualifierDefaultAnnotation[LocalVariableDescriptor]

'when (this) {
            is ArrayValue -> value.flatMap { it.mapConstantToQualifierApplicabilityTypes() }
            is EnumValue -> listOfNotNull(
                    when (value.name.identifier) {
                        "METHOD" -> QualifierApplicabilityType.METHOD_RETURN_TYPE
                        "FIELD" -> QualifierApplicabilityType.FIELD
                        "PARAMETER" -> QualifierApplicabilityType.VALUE_PARAMETER
                        "TYPE_USE" -> QualifierApplicabilityType.TYPE_USE
                        else -> null
                    }
            )
            else -> emptyList()
        }' @ [105:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: List<AnnotationTypeQualifierResolver.QualifierApplicabilityType>, entry1: List<AnnotationTypeQualifierResolver.QualifierApplicabilityType>, entry2: List<AnnotationTypeQualifierResolver.QualifierApplicabilityType>): List<AnnotationTypeQualifierResolver.QualifierApplicabilityType>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> List<QualifierApplicabilityType>

'this' @ [105:15] ==> <this> defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.mapConstantToQualifierApplicabilityTypes[ReceiverParameterDescriptorImpl]

'value' @ [106:30] ==> public open val value: List<ConstantValue<*>> defined in org.jetbrains.kotlin.resolve.constants.ArrayValue[DeserializedPropertyDescriptor]

'flatMap' @ [106:36] ==> public inline fun <T, R> Iterable<ConstantValue<*>>.flatMap(transform: (ConstantValue<*>) -> Iterable<AnnotationTypeQualifierResolver.QualifierApplicabilityType>): List<AnnotationTypeQualifierResolver.QualifierApplicabilityType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ConstantValue<*>
    <R> -> QualifierApplicabilityType

'it' @ [106:46] ==> value-parameter it: ConstantValue<*> defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.mapConstantToQualifierApplicabilityTypes.<anonymous>[ValueParameterDescriptorImpl]

'mapConstantToQualifierApplicabilityTypes' @ [106:49] ==> private final fun ConstantValue<*>.mapConstantToQualifierApplicabilityTypes(): List<AnnotationTypeQualifierResolver.QualifierApplicabilityType> defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver[SimpleFunctionDescriptorImpl]

'listOfNotNull' @ [107:29] ==> public fun <T : Any> listOfNotNull(element: AnnotationTypeQualifierResolver.QualifierApplicabilityType?): List<AnnotationTypeQualifierResolver.QualifierApplicabilityType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> QualifierApplicabilityType

'when (value.name.identifier) {
                        "METHOD" -> QualifierApplicabilityType.METHOD_RETURN_TYPE
                        "FIELD" -> QualifierApplicabilityType.FIELD
                        "PARAMETER" -> QualifierApplicabilityType.VALUE_PARAMETER
                        "TYPE_USE" -> QualifierApplicabilityType.TYPE_USE
                        else -> null
                    }' @ [108:21] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: AnnotationTypeQualifierResolver.QualifierApplicabilityType?, entry1: AnnotationTypeQualifierResolver.QualifierApplicabilityType?, entry2: AnnotationTypeQualifierResolver.QualifierApplicabilityType?, entry3: AnnotationTypeQualifierResolver.QualifierApplicabilityType?, entry4: AnnotationTypeQualifierResolver.QualifierApplicabilityType?): AnnotationTypeQualifierResolver.QualifierApplicabilityType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> QualifierApplicabilityType?

'value' @ [108:27] ==> public open val value: ClassDescriptor defined in org.jetbrains.kotlin.resolve.constants.EnumValue[DeserializedPropertyDescriptor]

'name' @ [108:33] ==> public final val ClassDescriptor.name: Name[MyPropertyDescriptor]

'identifier' @ [108:38] ==> public final val Name.identifier: String[MyPropertyDescriptor]

'METHOD_RETURN_TYPE' @ [109:64] ==> enum entry METHOD_RETURN_TYPE defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.QualifierApplicabilityType[FakeCallableDescriptorForObject]

'FIELD' @ [110:63] ==> enum entry FIELD defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.QualifierApplicabilityType[FakeCallableDescriptorForObject]

'VALUE_PARAMETER' @ [111:67] ==> enum entry VALUE_PARAMETER defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.QualifierApplicabilityType[FakeCallableDescriptorForObject]

'TYPE_USE' @ [112:66] ==> enum entry TYPE_USE defined in org.jetbrains.kotlin.load.java.AnnotationTypeQualifierResolver.QualifierApplicabilityType[FakeCallableDescriptorForObject]

'emptyList' @ [116:21] ==> public fun <T> emptyList(): List<AnnotationTypeQualifierResolver.QualifierApplicabilityType> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> QualifierApplicabilityType

'setOf' @ [120:40] ==> public fun <T> setOf(vararg elements: FqName): Set<FqName> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FqName

'JAVAX_NONNULL_ANNOTATION' @ [120:46] ==> public val JAVAX_NONNULL_ANNOTATION: FqName defined in org.jetbrains.kotlin.load.java in file JvmAnnotationNames.kt[PropertyDescriptorImpl]

'JAVAX_CHECKFORNULL_ANNOTATION' @ [120:72] ==> public val JAVAX_CHECKFORNULL_ANNOTATION: FqName defined in org.jetbrains.kotlin.load.java in file JvmAnnotationNames.kt[PropertyDescriptorImpl]

'fqNameSafe' @ [123:13] ==> public val DeclarationDescriptor.fqNameSafe: FqName defined in org.jetbrains.kotlin.resolve.descriptorUtil[DeserializedPropertyDescriptor]

'BUILT_IN_TYPE_QUALIFIER_FQ_NAMES' @ [123:27] ==> public val BUILT_IN_TYPE_QUALIFIER_FQ_NAMES: Set<FqName> defined in org.jetbrains.kotlin.load.java in file AnnotationTypeQualifierResolver.kt[PropertyDescriptorImpl]

'annotations' @ [123:63] ==> public abstract val annotations: Annotations defined in org.jetbrains.kotlin.descriptors.ClassDescriptor[DeserializedPropertyDescriptor]

'hasAnnotation' @ [123:75] ==> public open fun hasAnnotation(fqName: FqName): Boolean defined in org.jetbrains.kotlin.descriptors.annotations.Annotations[DeserializedSimpleFunctionDescriptor]

'TYPE_QUALIFIER_FQNAME' @ [123:89] ==> private val TYPE_QUALIFIER_FQNAME: FqName defined in org.jetbrains.kotlin.load.java in file AnnotationTypeQualifierResolver.kt[PropertyDescriptorImpl]

