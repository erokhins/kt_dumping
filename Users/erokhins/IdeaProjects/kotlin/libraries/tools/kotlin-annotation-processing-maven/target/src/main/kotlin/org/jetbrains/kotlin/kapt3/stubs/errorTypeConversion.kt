'gotTypeElement' @ [40:16] ==> value-parameter gotTypeElement: KtTypeElement? = ... defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[ValueParameterDescriptorImpl]

'reference' @ [40:34] ==> value-parameter reference: KtTypeReference? defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[ValueParameterDescriptorImpl]

'typeElement' @ [40:45] ==> public final val typeElement: KtTypeElement? defined in org.jetbrains.kotlin.psi.KtTypeReference[DeserializedPropertyDescriptor]

'reference' @ [42:9] ==> value-parameter reference: KtTypeReference? defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[ValueParameterDescriptorImpl]

'converter' @ [43:26] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[ValueParameterDescriptorImpl]

'kaptContext' @ [43:36] ==> public final val kaptContext: KaptContext<GenerationState> defined in org.jetbrains.kotlin.kapt3.stubs.ClassFileToSourceStubConverter[PropertyDescriptorImpl]

'bindingContext' @ [43:48] ==> public final val bindingContext: BindingContext defined in org.jetbrains.kotlin.kapt3.KaptContext[PropertyDescriptorImpl]

'TYPE' @ [43:78] ==> public final val TYPE: (WritableSlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>..WritableSlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'reference' @ [43:84] ==> value-parameter reference: KtTypeReference? defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[ValueParameterDescriptorImpl]

'kotlinType' @ [44:13] ==> val kotlinType: KotlinType? defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[LocalVariableDescriptor]

'!' @ [44:35] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'kotlinType' @ [44:36] ==> val kotlinType: KotlinType? defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[LocalVariableDescriptor]

'containsErrorTypes' @ [44:47] ==> public fun KotlinType.containsErrorTypes(allowedDepth: Int = ...): Boolean defined in org.jetbrains.kotlin.kapt3.stubs in file errorTypeConversion.kt[SimpleFunctionDescriptorImpl]

'BothSignatureWriter' @ [45:35] ==> public constructor BothSignatureWriter(@NotNull p0: BothSignatureWriter.Mode) defined in org.jetbrains.kotlin.codegen.signature.BothSignatureWriter[JavaClassConstructorDescriptor]

'TYPE' @ [45:80] ==> enum entry TYPE defined in org.jetbrains.kotlin.codegen.signature.BothSignatureWriter.Mode[FakeCallableDescriptorForObject]

'converter' @ [46:13] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[ValueParameterDescriptorImpl]

'kaptContext' @ [46:23] ==> public final val kaptContext: KaptContext<GenerationState> defined in org.jetbrains.kotlin.kapt3.stubs.ClassFileToSourceStubConverter[PropertyDescriptorImpl]

'generationState' @ [46:35] ==> public final val generationState: GenerationState defined in org.jetbrains.kotlin.kapt3.KaptContext[PropertyDescriptorImpl]

'typeMapper' @ [46:51] ==> public final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.state.GenerationState[DeserializedPropertyDescriptor]

'mapType' @ [46:62] ==> @NotNull public open fun mapType(@NotNull p0: KotlinType, @Nullable p1: JvmSignatureWriter?, @NotNull p2: TypeMappingMode): Type defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'kotlinType' @ [46:70] ==> val kotlinType: KotlinType? defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[LocalVariableDescriptor]

'signatureWriter' @ [46:82] ==> val signatureWriter: BothSignatureWriter defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[LocalVariableDescriptor]

'if (shouldBeBoxed) TypeMappingMode.GENERIC_ARGUMENT else TypeMappingMode.DEFAULT' @ [47:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: TypeMappingMode, elseBranch: TypeMappingMode): TypeMappingMode[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> TypeMappingMode

'shouldBeBoxed' @ [47:25] ==> value-parameter shouldBeBoxed: Boolean = ... defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[ValueParameterDescriptorImpl]

'GENERIC_ARGUMENT' @ [47:56] ==> @field:JvmField public final val GENERIC_ARGUMENT: TypeMappingMode defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion[DeserializedPropertyDescriptor]

'DEFAULT' @ [47:94] ==> @field:JvmField public final val DEFAULT: TypeMappingMode defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion[DeserializedPropertyDescriptor]

'SignatureParser' @ [49:20] ==> public constructor SignatureParser(treeMaker: KaptTreeMaker) defined in org.jetbrains.kotlin.kapt3.stubs.SignatureParser[ClassConstructorDescriptorImpl]

'converter' @ [49:36] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[ValueParameterDescriptorImpl]

'treeMaker' @ [49:46] ==> public final val treeMaker: KaptTreeMaker defined in org.jetbrains.kotlin.kapt3.stubs.ClassFileToSourceStubConverter[PropertyDescriptorImpl]

'parseFieldSignature' @ [49:57] ==> public final fun parseFieldSignature(signature: String?, rawType: JCTree.JCExpression): JCTree.JCExpression defined in org.jetbrains.kotlin.kapt3.stubs.SignatureParser[SimpleFunctionDescriptorImpl]

'signatureWriter' @ [50:21] ==> val signatureWriter: BothSignatureWriter defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[LocalVariableDescriptor]

'toString' @ [50:37] ==> public open fun toString(): String defined in org.jetbrains.kotlin.codegen.signature.BothSignatureWriter[JavaMethodDescriptor]

'getDefaultTypeForUnknownType' @ [50:49] ==> private fun getDefaultTypeForUnknownType(converter: ClassFileToSourceStubConverter): JCTree.JCExpression defined in org.jetbrains.kotlin.kapt3.stubs in file errorTypeConversion.kt[SimpleFunctionDescriptorImpl]

'converter' @ [50:78] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[ValueParameterDescriptorImpl]

'when (type) {
        is KtUserType -> convertUserType(type, converter, reference)
        is KtNullableType -> {
            // Prevent infinite recursion
            val innerType = type.innerType ?: return getDefaultTypeForUnknownType(converter)
            convertKtType(reference, converter, shouldBeBoxed = true, gotTypeElement = innerType)
        }
        is KtFunctionType -> convertFunctionType(type, converter)
        else -> getDefaultTypeForUnknownType(converter)
    }' @ [54:12] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: JCTree.JCExpression, entry1: JCTree.JCExpression, entry2: JCTree.JCExpression, entry3: JCTree.JCExpression): JCTree.JCExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> JCExpression

'type' @ [54:18] ==> val type: KtTypeElement? defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[LocalVariableDescriptor]

'convertUserType' @ [55:26] ==> private fun convertUserType(type: KtUserType, converter: ClassFileToSourceStubConverter, reference: KtTypeReference?): JCTree.JCExpression defined in org.jetbrains.kotlin.kapt3.stubs in file errorTypeConversion.kt[SimpleFunctionDescriptorImpl]

'type' @ [55:42] ==> val type: KtTypeElement? defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[LocalVariableDescriptor]

'converter' @ [55:48] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[ValueParameterDescriptorImpl]

'reference' @ [55:59] ==> value-parameter reference: KtTypeReference? defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[ValueParameterDescriptorImpl]

'type' @ [58:29] ==> val type: KtTypeElement? defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[LocalVariableDescriptor]

'innerType' @ [58:34] ==> public final val KtNullableType.innerType: KtTypeElement?[MyPropertyDescriptor]

'getDefaultTypeForUnknownType' @ [58:54] ==> private fun getDefaultTypeForUnknownType(converter: ClassFileToSourceStubConverter): JCTree.JCExpression defined in org.jetbrains.kotlin.kapt3.stubs in file errorTypeConversion.kt[SimpleFunctionDescriptorImpl]

'converter' @ [58:83] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[ValueParameterDescriptorImpl]

'convertKtType' @ [59:13] ==> internal fun convertKtType(reference: KtTypeReference?, converter: ClassFileToSourceStubConverter, shouldBeBoxed: Boolean = ..., gotTypeElement: KtTypeElement? = ...): JCTree.JCExpression defined in org.jetbrains.kotlin.kapt3.stubs in file errorTypeConversion.kt[SimpleFunctionDescriptorImpl]

'reference' @ [59:27] ==> value-parameter reference: KtTypeReference? defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[ValueParameterDescriptorImpl]

'converter' @ [59:38] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[ValueParameterDescriptorImpl]

'innerType' @ [59:88] ==> val innerType: KtTypeElement defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[LocalVariableDescriptor]

'convertFunctionType' @ [61:30] ==> private fun convertFunctionType(type: KtFunctionType, converter: ClassFileToSourceStubConverter): JCTree.JCExpression defined in org.jetbrains.kotlin.kapt3.stubs in file errorTypeConversion.kt[SimpleFunctionDescriptorImpl]

'type' @ [61:50] ==> val type: KtTypeElement? defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[LocalVariableDescriptor]

'converter' @ [61:56] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[ValueParameterDescriptorImpl]

'getDefaultTypeForUnknownType' @ [62:17] ==> private fun getDefaultTypeForUnknownType(converter: ClassFileToSourceStubConverter): JCTree.JCExpression defined in org.jetbrains.kotlin.kapt3.stubs in file errorTypeConversion.kt[SimpleFunctionDescriptorImpl]

'converter' @ [62:46] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertKtType[ValueParameterDescriptorImpl]

'converter' @ [66:87] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.getDefaultTypeForUnknownType[ValueParameterDescriptorImpl]

'treeMaker' @ [66:97] ==> public final val treeMaker: KaptTreeMaker defined in org.jetbrains.kotlin.kapt3.stubs.ClassFileToSourceStubConverter[PropertyDescriptorImpl]

'FqName' @ [66:107] ==> public final fun FqName(internalOrFqName: String): JCTree.JCExpression defined in org.jetbrains.kotlin.kapt3.javac.KaptTreeMaker[SimpleFunctionDescriptorImpl]

'type' @ [69:31] ==> value-parameter type: KtUserType defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[ValueParameterDescriptorImpl]

'qualifier' @ [69:36] ==> public final val KtUserType.qualifier: KtUserType?[MyPropertyDescriptor]

'let' @ [69:47] ==> @InlineOnly public inline fun <T, R> KtUserType.let(block: (KtUserType) -> JCTree.JCExpression): JCTree.JCExpression defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtUserType
    <R> -> JCExpression

'convertUserType' @ [69:53] ==> private fun convertUserType(type: KtUserType, converter: ClassFileToSourceStubConverter, reference: KtTypeReference?): JCTree.JCExpression defined in org.jetbrains.kotlin.kapt3.stubs in file errorTypeConversion.kt[SimpleFunctionDescriptorImpl]

'it' @ [69:69] ==> value-parameter it: KtUserType defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType.<anonymous>[ValueParameterDescriptorImpl]

'converter' @ [69:73] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[ValueParameterDescriptorImpl]

'type' @ [70:26] ==> value-parameter type: KtUserType defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[ValueParameterDescriptorImpl]

'referencedName' @ [70:31] ==> public final val KtUserType.referencedName: String?[MyPropertyDescriptor]

'converter' @ [71:21] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[ValueParameterDescriptorImpl]

'treeMaker' @ [71:31] ==> public final val treeMaker: KaptTreeMaker defined in org.jetbrains.kotlin.kapt3.stubs.ClassFileToSourceStubConverter[PropertyDescriptorImpl]

'if (qualifierExpression == null) {
        // This could be List<SomeErrorType> or similar. List should be converted to java.util.List in this case.
        val referenceTarget = converter.kaptContext.bindingContext[BindingContext.REFERENCE_TARGET, type.referenceExpression]
        if (referenceTarget is ClassDescriptor) {
            treeMaker.FqName(converter.kaptContext.generationState.typeMapper.mapType(referenceTarget.defaultType).internalName)
        }
        else {
            treeMaker.SimpleName(referencedName)
        }
    } else {
        treeMaker.Select(qualifierExpression, treeMaker.name(referencedName))
    }' @ [73:26] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (JCTree.JCExpression..JCTree.JCExpression?), elseBranch: (JCTree.JCExpression..JCTree.JCExpression?)): (JCTree.JCExpression..JCTree.JCExpression?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (com.sun.tools.javac.tree.JCTree.JCExpression..com.sun.tools.javac.tree.JCTree.JCExpression?)

'qualifierExpression' @ [73:30] ==> val qualifierExpression: JCTree.JCExpression? defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[LocalVariableDescriptor]

'converter' @ [75:31] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[ValueParameterDescriptorImpl]

'kaptContext' @ [75:41] ==> public final val kaptContext: KaptContext<GenerationState> defined in org.jetbrains.kotlin.kapt3.stubs.ClassFileToSourceStubConverter[PropertyDescriptorImpl]

'bindingContext' @ [75:53] ==> public final val bindingContext: BindingContext defined in org.jetbrains.kotlin.kapt3.KaptContext[PropertyDescriptorImpl]

'REFERENCE_TARGET' @ [75:83] ==> public final val REFERENCE_TARGET: (WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>..WritableSlice<(KtReferenceExpression..KtReferenceExpression?), (DeclarationDescriptor..DeclarationDescriptor?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'type' @ [75:101] ==> value-parameter type: KtUserType defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[ValueParameterDescriptorImpl]

'referenceExpression' @ [75:106] ==> public final val KtUserType.referenceExpression: KtSimpleNameExpression?[MyPropertyDescriptor]

'if (referenceTarget is ClassDescriptor) {
            treeMaker.FqName(converter.kaptContext.generationState.typeMapper.mapType(referenceTarget.defaultType).internalName)
        }
        else {
            treeMaker.SimpleName(referencedName)
        }' @ [76:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: JCTree.JCExpression, elseBranch: JCTree.JCExpression): JCTree.JCExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> JCExpression

'referenceTarget' @ [76:13] ==> val referenceTarget: DeclarationDescriptor? defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[LocalVariableDescriptor]

'treeMaker' @ [77:13] ==> val treeMaker: KaptTreeMaker defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[LocalVariableDescriptor]

'FqName' @ [77:23] ==> public final fun FqName(internalOrFqName: String): JCTree.JCExpression defined in org.jetbrains.kotlin.kapt3.javac.KaptTreeMaker[SimpleFunctionDescriptorImpl]

'converter' @ [77:30] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[ValueParameterDescriptorImpl]

'kaptContext' @ [77:40] ==> public final val kaptContext: KaptContext<GenerationState> defined in org.jetbrains.kotlin.kapt3.stubs.ClassFileToSourceStubConverter[PropertyDescriptorImpl]

'generationState' @ [77:52] ==> public final val generationState: GenerationState defined in org.jetbrains.kotlin.kapt3.KaptContext[PropertyDescriptorImpl]

'typeMapper' @ [77:68] ==> public final val typeMapper: KotlinTypeMapper defined in org.jetbrains.kotlin.codegen.state.GenerationState[DeserializedPropertyDescriptor]

'mapType' @ [77:79] ==> @NotNull public open fun mapType(@NotNull p0: KotlinType): Type defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'referenceTarget' @ [77:87] ==> val referenceTarget: DeclarationDescriptor? defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[LocalVariableDescriptor]

'defaultType' @ [77:103] ==> public final val ClassDescriptor.defaultType: SimpleType[MyPropertyDescriptor]

'internalName' @ [77:116] ==> public final val Type.internalName: (String..String?)[MyPropertyDescriptor]

'treeMaker' @ [80:13] ==> val treeMaker: KaptTreeMaker defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[LocalVariableDescriptor]

'SimpleName' @ [80:23] ==> public final fun SimpleName(name: String): JCTree.JCExpression defined in org.jetbrains.kotlin.kapt3.javac.KaptTreeMaker[SimpleFunctionDescriptorImpl]

'referencedName' @ [80:34] ==> val referencedName: String defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[LocalVariableDescriptor]

'treeMaker' @ [83:9] ==> val treeMaker: KaptTreeMaker defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[LocalVariableDescriptor]

'Select' @ [83:19] ==> public open fun Select(p0: (JCTree.JCExpression..JCTree.JCExpression?), p1: (Name..Name?)): (JCTree.JCFieldAccess..JCTree.JCFieldAccess?) defined in org.jetbrains.kotlin.kapt3.javac.KaptTreeMaker[JavaMethodDescriptor]

'qualifierExpression' @ [83:26] ==> val qualifierExpression: JCTree.JCExpression? defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[LocalVariableDescriptor]

'treeMaker' @ [83:47] ==> val treeMaker: KaptTreeMaker defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[LocalVariableDescriptor]

'name' @ [83:57] ==> public final fun name(name: String): Name defined in org.jetbrains.kotlin.kapt3.javac.KaptTreeMaker[SimpleFunctionDescriptorImpl]

'referencedName' @ [83:62] ==> val referencedName: String defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[LocalVariableDescriptor]

'type' @ [86:21] ==> value-parameter type: KtUserType defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[ValueParameterDescriptorImpl]

'typeArguments' @ [86:26] ==> public final val KtUserType.typeArguments: (MutableList<(KtTypeProjection..KtTypeProjection?)>..List<(KtTypeProjection..KtTypeProjection?)>)[MyPropertyDescriptor]

'arguments' @ [87:9] ==> val arguments: (MutableList<(KtTypeProjection..KtTypeProjection?)>..List<(KtTypeProjection..KtTypeProjection?)>) defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[LocalVariableDescriptor]

'isEmpty' @ [87:19] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'baseExpression' @ [88:16] ==> val baseExpression: (JCTree.JCExpression..JCTree.JCExpression?) defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[LocalVariableDescriptor]

'reference' @ [91:20] ==> value-parameter reference: KtTypeReference? defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[ValueParameterDescriptorImpl]

'let' @ [91:31] ==> @InlineOnly public inline fun <T, R> KtTypeReference.let(block: (KtTypeReference) -> KotlinType?): KotlinType? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtTypeReference
    <R> -> KotlinType?

'converter' @ [91:37] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[ValueParameterDescriptorImpl]

'kaptContext' @ [91:47] ==> public final val kaptContext: KaptContext<GenerationState> defined in org.jetbrains.kotlin.kapt3.stubs.ClassFileToSourceStubConverter[PropertyDescriptorImpl]

'bindingContext' @ [91:59] ==> public final val bindingContext: BindingContext defined in org.jetbrains.kotlin.kapt3.KaptContext[PropertyDescriptorImpl]

'TYPE' @ [91:89] ==> public final val TYPE: (WritableSlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>..WritableSlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'it' @ [91:95] ==> value-parameter it: KtTypeReference defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType.<anonymous>[ValueParameterDescriptorImpl]

'treeMaker' @ [93:12] ==> val treeMaker: KaptTreeMaker defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[LocalVariableDescriptor]

'TypeApply' @ [93:22] ==> public open fun TypeApply(p0: (JCTree.JCExpression..JCTree.JCExpression?), p1: (List<(JCTree.JCExpression..JCTree.JCExpression?)>..List<(JCTree.JCExpression..JCTree.JCExpression?)>?)): (JCTree.JCTypeApply..JCTree.JCTypeApply?) defined in org.jetbrains.kotlin.kapt3.javac.KaptTreeMaker[JavaMethodDescriptor]

'baseExpression' @ [93:32] ==> val baseExpression: (JCTree.JCExpression..JCTree.JCExpression?) defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[LocalVariableDescriptor]

'mapJListIndexed' @ [93:48] ==> internal inline fun <T, R> mapJListIndexed(values: Iterable<(KtTypeProjection..KtTypeProjection?)>?, f: (Int, (KtTypeProjection..KtTypeProjection?)) -> JCTree.JCExpression?): List<(JCTree.JCExpression..JCTree.JCExpression?)> defined in org.jetbrains.kotlin.kapt3[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtTypeProjection..org.jetbrains.kotlin.psi.KtTypeProjection?)
    <R> -> (com.sun.tools.javac.tree.JCTree.JCExpression..com.sun.tools.javac.tree.JCTree.JCExpression?)

'arguments' @ [93:64] ==> val arguments: (MutableList<(KtTypeProjection..KtTypeProjection?)>..List<(KtTypeProjection..KtTypeProjection?)>) defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[LocalVariableDescriptor]

'projection' @ [94:28] ==> value-parameter projection: (KtTypeProjection..KtTypeProjection?) defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType.<anonymous>[ValueParameterDescriptorImpl]

'typeReference' @ [94:39] ==> public final val KtTypeProjection.typeReference: KtTypeReference?[MyPropertyDescriptor]

'let' @ [94:54] ==> @InlineOnly public inline fun <T, R> KtTypeReference.let(block: (KtTypeReference) -> KotlinType?): KotlinType? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KtTypeReference
    <R> -> KotlinType?

'converter' @ [94:60] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[ValueParameterDescriptorImpl]

'kaptContext' @ [94:70] ==> public final val kaptContext: KaptContext<GenerationState> defined in org.jetbrains.kotlin.kapt3.stubs.ClassFileToSourceStubConverter[PropertyDescriptorImpl]

'bindingContext' @ [94:82] ==> public final val bindingContext: BindingContext defined in org.jetbrains.kotlin.kapt3.KaptContext[PropertyDescriptorImpl]

'TYPE' @ [94:112] ==> public final val TYPE: (WritableSlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>..WritableSlice<(KtTypeReference..KtTypeReference?), (KotlinType..KotlinType?)>?) defined in org.jetbrains.kotlin.resolve.BindingContext[JavaPropertyDescriptor]

'it' @ [94:118] ==> value-parameter it: KtTypeReference defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'argumentType' @ [95:29] ==> val argumentType: KotlinType? defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType.<anonymous>[LocalVariableDescriptor]

'constructor' @ [95:43] ==> public abstract val constructor: TypeConstructor defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'parameters' @ [95:56] ==> public final val TypeConstructor.parameters: List<(TypeParameterDescriptor..TypeParameterDescriptor?)>[MyPropertyDescriptor]

'getOrNull' @ [95:68] ==> public fun <T> List<(TypeParameterDescriptor..TypeParameterDescriptor?)>.getOrNull(index: Int): TypeParameterDescriptor? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.TypeParameterDescriptor..org.jetbrains.kotlin.descriptors.TypeParameterDescriptor?)

'index' @ [95:78] ==> value-parameter index: Int defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType.<anonymous>[ValueParameterDescriptorImpl]

'baseType' @ [96:24] ==> val baseType: KotlinType? defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[LocalVariableDescriptor]

'arguments' @ [96:34] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'getOrNull' @ [96:45] ==> public fun <T> List<TypeProjection>.getOrNull(index: Int): TypeProjection? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection

'index' @ [96:55] ==> value-parameter index: Int defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType.<anonymous>[ValueParameterDescriptorImpl]

'if (argument != null && typeParameter != null) {
            val argumentMode = TypeMappingMode.GENERIC_ARGUMENT.updateArgumentModeFromAnnotations(argument.type)
            KotlinTypeMapper.getVarianceForWildcard(typeParameter, argument, argumentMode)
        }
        else {
            null
        }' @ [98:24] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Variance?, elseBranch: Variance?): Variance?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Variance?

'argument' @ [98:28] ==> val argument: TypeProjection? defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType.<anonymous>[LocalVariableDescriptor]

'typeParameter' @ [98:48] ==> val typeParameter: TypeParameterDescriptor? defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType.<anonymous>[LocalVariableDescriptor]

'TypeMappingMode' @ [99:32] ==> public companion object defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode[FakeCallableDescriptorForObject]

'GENERIC_ARGUMENT' @ [99:48] ==> @field:JvmField public final val GENERIC_ARGUMENT: TypeMappingMode defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion[DeserializedPropertyDescriptor]

'updateArgumentModeFromAnnotations' @ [99:65] ==> public fun TypeMappingMode.updateArgumentModeFromAnnotations(type: KotlinType): TypeMappingMode defined in org.jetbrains.kotlin.codegen.state[DeserializedSimpleFunctionDescriptor]

'argument' @ [99:99] ==> val argument: TypeProjection? defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType.<anonymous>[LocalVariableDescriptor]

'type' @ [99:108] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'getVarianceForWildcard' @ [100:30] ==> @NotNull public open fun getVarianceForWildcard(@NotNull p0: TypeParameterDescriptor, @NotNull p1: TypeProjection, @NotNull p2: TypeMappingMode): Variance defined in org.jetbrains.kotlin.codegen.state.KotlinTypeMapper[JavaMethodDescriptor]

'typeParameter' @ [100:53] ==> val typeParameter: TypeParameterDescriptor? defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType.<anonymous>[LocalVariableDescriptor]

'argument' @ [100:68] ==> val argument: TypeProjection? defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType.<anonymous>[LocalVariableDescriptor]

'argumentMode' @ [100:78] ==> val argumentMode: TypeMappingMode defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType.<anonymous>[LocalVariableDescriptor]

'convertTypeProjection' @ [106:9] ==> private fun convertTypeProjection(type: KtTypeProjection, variance: Variance?, converter: ClassFileToSourceStubConverter): JCTree.JCExpression defined in org.jetbrains.kotlin.kapt3.stubs in file errorTypeConversion.kt[SimpleFunctionDescriptorImpl]

'projection' @ [106:31] ==> value-parameter projection: (KtTypeProjection..KtTypeProjection?) defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType.<anonymous>[ValueParameterDescriptorImpl]

'variance' @ [106:43] ==> val variance: Variance? defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType.<anonymous>[LocalVariableDescriptor]

'converter' @ [106:53] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertUserType[ValueParameterDescriptorImpl]

'type' @ [111:21] ==> value-parameter type: KtTypeProjection defined in org.jetbrains.kotlin.kapt3.stubs.convertTypeProjection[ValueParameterDescriptorImpl]

'typeReference' @ [111:26] ==> public final val KtTypeProjection.typeReference: KtTypeReference?[MyPropertyDescriptor]

'converter' @ [112:21] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertTypeProjection[ValueParameterDescriptorImpl]

'treeMaker' @ [112:31] ==> public final val treeMaker: KaptTreeMaker defined in org.jetbrains.kotlin.kapt3.stubs.ClassFileToSourceStubConverter[PropertyDescriptorImpl]

'type' @ [113:26] ==> value-parameter type: KtTypeProjection defined in org.jetbrains.kotlin.kapt3.stubs.convertTypeProjection[ValueParameterDescriptorImpl]

'projectionKind' @ [113:31] ==> public final val KtTypeProjection.projectionKind: KtProjectionKind[MyPropertyDescriptor]

'variance' @ [115:9] ==> value-parameter variance: Variance? defined in org.jetbrains.kotlin.kapt3.stubs.convertTypeProjection[ValueParameterDescriptorImpl]

'INVARIANT' @ [115:31] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'convertKtType' @ [116:16] ==> internal fun convertKtType(reference: KtTypeReference?, converter: ClassFileToSourceStubConverter, shouldBeBoxed: Boolean = ..., gotTypeElement: KtTypeElement? = ...): JCTree.JCExpression defined in org.jetbrains.kotlin.kapt3.stubs in file errorTypeConversion.kt[SimpleFunctionDescriptorImpl]

'reference' @ [116:30] ==> val reference: KtTypeReference? defined in org.jetbrains.kotlin.kapt3.stubs.convertTypeProjection[LocalVariableDescriptor]

'converter' @ [116:41] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertTypeProjection[ValueParameterDescriptorImpl]

'when {
        projectionKind === KtProjectionKind.STAR -> treeMaker.Wildcard(treeMaker.TypeBoundKind(BoundKind.UNBOUND), null)
        projectionKind === KtProjectionKind.IN || variance === Variance.IN_VARIANCE ->
            treeMaker.Wildcard(treeMaker.TypeBoundKind(BoundKind.SUPER), convertKtType(reference, converter, shouldBeBoxed = true))
        projectionKind === KtProjectionKind.OUT || variance === Variance.OUT_VARIANCE ->
            treeMaker.Wildcard(treeMaker.TypeBoundKind(BoundKind.EXTENDS), convertKtType(reference, converter, shouldBeBoxed = true))
        else -> convertKtType(reference, converter, shouldBeBoxed = true) // invariant
    }' @ [119:12] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: JCTree.JCExpression, entry1: JCTree.JCExpression, entry2: JCTree.JCExpression, entry3: JCTree.JCExpression): JCTree.JCExpression[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> JCExpression

'projectionKind' @ [120:9] ==> val projectionKind: KtProjectionKind defined in org.jetbrains.kotlin.kapt3.stubs.convertTypeProjection[LocalVariableDescriptor]

'STAR' @ [120:45] ==> enum entry STAR defined in org.jetbrains.kotlin.psi.KtProjectionKind[FakeCallableDescriptorForObject]

'treeMaker' @ [120:53] ==> val treeMaker: KaptTreeMaker defined in org.jetbrains.kotlin.kapt3.stubs.convertTypeProjection[LocalVariableDescriptor]

'Wildcard' @ [120:63] ==> public open fun Wildcard(p0: (JCTree.TypeBoundKind..JCTree.TypeBoundKind?), p1: (JCTree..JCTree?)): (JCTree.JCWildcard..JCTree.JCWildcard?) defined in org.jetbrains.kotlin.kapt3.javac.KaptTreeMaker[JavaMethodDescriptor]

'treeMaker' @ [120:72] ==> val treeMaker: KaptTreeMaker defined in org.jetbrains.kotlin.kapt3.stubs.convertTypeProjection[LocalVariableDescriptor]

'TypeBoundKind' @ [120:82] ==> public open fun TypeBoundKind(p0: (BoundKind..BoundKind?)): (JCTree.TypeBoundKind..JCTree.TypeBoundKind?) defined in org.jetbrains.kotlin.kapt3.javac.KaptTreeMaker[JavaMethodDescriptor]

'UNBOUND' @ [120:106] ==> enum entry UNBOUND defined in com.sun.tools.javac.code.BoundKind[FakeCallableDescriptorForObject]

'projectionKind' @ [121:9] ==> val projectionKind: KtProjectionKind defined in org.jetbrains.kotlin.kapt3.stubs.convertTypeProjection[LocalVariableDescriptor]

'IN' @ [121:45] ==> enum entry IN defined in org.jetbrains.kotlin.psi.KtProjectionKind[FakeCallableDescriptorForObject]

'variance' @ [121:51] ==> value-parameter variance: Variance? defined in org.jetbrains.kotlin.kapt3.stubs.convertTypeProjection[ValueParameterDescriptorImpl]

'IN_VARIANCE' @ [121:73] ==> enum entry IN_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'treeMaker' @ [122:13] ==> val treeMaker: KaptTreeMaker defined in org.jetbrains.kotlin.kapt3.stubs.convertTypeProjection[LocalVariableDescriptor]

'Wildcard' @ [122:23] ==> public open fun Wildcard(p0: (JCTree.TypeBoundKind..JCTree.TypeBoundKind?), p1: (JCTree..JCTree?)): (JCTree.JCWildcard..JCTree.JCWildcard?) defined in org.jetbrains.kotlin.kapt3.javac.KaptTreeMaker[JavaMethodDescriptor]

'treeMaker' @ [122:32] ==> val treeMaker: KaptTreeMaker defined in org.jetbrains.kotlin.kapt3.stubs.convertTypeProjection[LocalVariableDescriptor]

'TypeBoundKind' @ [122:42] ==> public open fun TypeBoundKind(p0: (BoundKind..BoundKind?)): (JCTree.TypeBoundKind..JCTree.TypeBoundKind?) defined in org.jetbrains.kotlin.kapt3.javac.KaptTreeMaker[JavaMethodDescriptor]

'SUPER' @ [122:66] ==> enum entry SUPER defined in com.sun.tools.javac.code.BoundKind[FakeCallableDescriptorForObject]

'convertKtType' @ [122:74] ==> internal fun convertKtType(reference: KtTypeReference?, converter: ClassFileToSourceStubConverter, shouldBeBoxed: Boolean = ..., gotTypeElement: KtTypeElement? = ...): JCTree.JCExpression defined in org.jetbrains.kotlin.kapt3.stubs in file errorTypeConversion.kt[SimpleFunctionDescriptorImpl]

'reference' @ [122:88] ==> val reference: KtTypeReference? defined in org.jetbrains.kotlin.kapt3.stubs.convertTypeProjection[LocalVariableDescriptor]

'converter' @ [122:99] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertTypeProjection[ValueParameterDescriptorImpl]

'projectionKind' @ [123:9] ==> val projectionKind: KtProjectionKind defined in org.jetbrains.kotlin.kapt3.stubs.convertTypeProjection[LocalVariableDescriptor]

'OUT' @ [123:45] ==> enum entry OUT defined in org.jetbrains.kotlin.psi.KtProjectionKind[FakeCallableDescriptorForObject]

'variance' @ [123:52] ==> value-parameter variance: Variance? defined in org.jetbrains.kotlin.kapt3.stubs.convertTypeProjection[ValueParameterDescriptorImpl]

'OUT_VARIANCE' @ [123:74] ==> enum entry OUT_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'treeMaker' @ [124:13] ==> val treeMaker: KaptTreeMaker defined in org.jetbrains.kotlin.kapt3.stubs.convertTypeProjection[LocalVariableDescriptor]

'Wildcard' @ [124:23] ==> public open fun Wildcard(p0: (JCTree.TypeBoundKind..JCTree.TypeBoundKind?), p1: (JCTree..JCTree?)): (JCTree.JCWildcard..JCTree.JCWildcard?) defined in org.jetbrains.kotlin.kapt3.javac.KaptTreeMaker[JavaMethodDescriptor]

'treeMaker' @ [124:32] ==> val treeMaker: KaptTreeMaker defined in org.jetbrains.kotlin.kapt3.stubs.convertTypeProjection[LocalVariableDescriptor]

'TypeBoundKind' @ [124:42] ==> public open fun TypeBoundKind(p0: (BoundKind..BoundKind?)): (JCTree.TypeBoundKind..JCTree.TypeBoundKind?) defined in org.jetbrains.kotlin.kapt3.javac.KaptTreeMaker[JavaMethodDescriptor]

'EXTENDS' @ [124:66] ==> enum entry EXTENDS defined in com.sun.tools.javac.code.BoundKind[FakeCallableDescriptorForObject]

'convertKtType' @ [124:76] ==> internal fun convertKtType(reference: KtTypeReference?, converter: ClassFileToSourceStubConverter, shouldBeBoxed: Boolean = ..., gotTypeElement: KtTypeElement? = ...): JCTree.JCExpression defined in org.jetbrains.kotlin.kapt3.stubs in file errorTypeConversion.kt[SimpleFunctionDescriptorImpl]

'reference' @ [124:90] ==> val reference: KtTypeReference? defined in org.jetbrains.kotlin.kapt3.stubs.convertTypeProjection[LocalVariableDescriptor]

'converter' @ [124:101] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertTypeProjection[ValueParameterDescriptorImpl]

'convertKtType' @ [125:17] ==> internal fun convertKtType(reference: KtTypeReference?, converter: ClassFileToSourceStubConverter, shouldBeBoxed: Boolean = ..., gotTypeElement: KtTypeElement? = ...): JCTree.JCExpression defined in org.jetbrains.kotlin.kapt3.stubs in file errorTypeConversion.kt[SimpleFunctionDescriptorImpl]

'reference' @ [125:31] ==> val reference: KtTypeReference? defined in org.jetbrains.kotlin.kapt3.stubs.convertTypeProjection[LocalVariableDescriptor]

'converter' @ [125:42] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertTypeProjection[ValueParameterDescriptorImpl]

'type' @ [130:24] ==> value-parameter type: KtFunctionType defined in org.jetbrains.kotlin.kapt3.stubs.convertFunctionType[ValueParameterDescriptorImpl]

'receiverTypeReference' @ [130:29] ==> public final val KtFunctionType.receiverTypeReference: KtTypeReference?[MyPropertyDescriptor]

'mapJList' @ [131:26] ==> internal inline fun <T, R> mapJList(values: Iterable<(KtParameter..KtParameter?)>?, f: ((KtParameter..KtParameter?)) -> JCTree.JCExpression?): List<JCTree.JCExpression> defined in org.jetbrains.kotlin.kapt3[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> (org.jetbrains.kotlin.psi.KtParameter..org.jetbrains.kotlin.psi.KtParameter?)
    <R> -> JCExpression

'type' @ [131:35] ==> value-parameter type: KtFunctionType defined in org.jetbrains.kotlin.kapt3.stubs.convertFunctionType[ValueParameterDescriptorImpl]

'parameters' @ [131:40] ==> public final val KtFunctionType.parameters: (MutableList<(KtParameter..KtParameter?)>..List<(KtParameter..KtParameter?)>)[MyPropertyDescriptor]

'convertKtType' @ [131:54] ==> internal fun convertKtType(reference: KtTypeReference?, converter: ClassFileToSourceStubConverter, shouldBeBoxed: Boolean = ..., gotTypeElement: KtTypeElement? = ...): JCTree.JCExpression defined in org.jetbrains.kotlin.kapt3.stubs in file errorTypeConversion.kt[SimpleFunctionDescriptorImpl]

'it' @ [131:68] ==> value-parameter it: (KtParameter..KtParameter?) defined in org.jetbrains.kotlin.kapt3.stubs.convertFunctionType.<anonymous>[ValueParameterDescriptorImpl]

'typeReference' @ [131:71] ==> public final var KtParameter.typeReference: KtTypeReference?[MyPropertyDescriptor]

'converter' @ [131:86] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertFunctionType[ValueParameterDescriptorImpl]

'convertKtType' @ [132:22] ==> internal fun convertKtType(reference: KtTypeReference?, converter: ClassFileToSourceStubConverter, shouldBeBoxed: Boolean = ..., gotTypeElement: KtTypeElement? = ...): JCTree.JCExpression defined in org.jetbrains.kotlin.kapt3.stubs in file errorTypeConversion.kt[SimpleFunctionDescriptorImpl]

'type' @ [132:36] ==> value-parameter type: KtFunctionType defined in org.jetbrains.kotlin.kapt3.stubs.convertFunctionType[ValueParameterDescriptorImpl]

'returnTypeReference' @ [132:41] ==> public final val KtFunctionType.returnTypeReference: KtTypeReference?[MyPropertyDescriptor]

'converter' @ [132:62] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertFunctionType[ValueParameterDescriptorImpl]

'receiverType' @ [134:9] ==> val receiverType: KtTypeReference? defined in org.jetbrains.kotlin.kapt3.stubs.convertFunctionType[LocalVariableDescriptor]

'parameterTypes' @ [135:9] ==> var parameterTypes: List<JCTree.JCExpression> defined in org.jetbrains.kotlin.kapt3.stubs.convertFunctionType[LocalVariableDescriptor]

'parameterTypes' @ [135:26] ==> var parameterTypes: List<JCTree.JCExpression> defined in org.jetbrains.kotlin.kapt3.stubs.convertFunctionType[LocalVariableDescriptor]

'prepend' @ [135:41] ==> public open fun prepend(p0: (JCTree.JCExpression..JCTree.JCExpression?)): (List<(JCTree.JCExpression..JCTree.JCExpression?)>..List<(JCTree.JCExpression..JCTree.JCExpression?)>?) defined in com.sun.tools.javac.util.List[JavaMethodDescriptor]

'convertKtType' @ [135:49] ==> internal fun convertKtType(reference: KtTypeReference?, converter: ClassFileToSourceStubConverter, shouldBeBoxed: Boolean = ..., gotTypeElement: KtTypeElement? = ...): JCTree.JCExpression defined in org.jetbrains.kotlin.kapt3.stubs in file errorTypeConversion.kt[SimpleFunctionDescriptorImpl]

'receiverType' @ [135:63] ==> val receiverType: KtTypeReference? defined in org.jetbrains.kotlin.kapt3.stubs.convertFunctionType[LocalVariableDescriptor]

'converter' @ [135:77] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertFunctionType[ValueParameterDescriptorImpl]

'parameterTypes' @ [138:5] ==> var parameterTypes: List<JCTree.JCExpression> defined in org.jetbrains.kotlin.kapt3.stubs.convertFunctionType[LocalVariableDescriptor]

'parameterTypes' @ [138:22] ==> var parameterTypes: List<JCTree.JCExpression> defined in org.jetbrains.kotlin.kapt3.stubs.convertFunctionType[LocalVariableDescriptor]

'append' @ [138:37] ==> public open fun append(p0: (JCTree.JCExpression..JCTree.JCExpression?)): (List<(JCTree.JCExpression..JCTree.JCExpression?)>..List<(JCTree.JCExpression..JCTree.JCExpression?)>?) defined in com.sun.tools.javac.util.List[JavaMethodDescriptor]

'returnType' @ [138:44] ==> val returnType: JCTree.JCExpression defined in org.jetbrains.kotlin.kapt3.stubs.convertFunctionType[LocalVariableDescriptor]

'converter' @ [140:21] ==> value-parameter converter: ClassFileToSourceStubConverter defined in org.jetbrains.kotlin.kapt3.stubs.convertFunctionType[ValueParameterDescriptorImpl]

'treeMaker' @ [140:31] ==> public final val treeMaker: KaptTreeMaker defined in org.jetbrains.kotlin.kapt3.stubs.ClassFileToSourceStubConverter[PropertyDescriptorImpl]

'treeMaker' @ [141:12] ==> val treeMaker: KaptTreeMaker defined in org.jetbrains.kotlin.kapt3.stubs.convertFunctionType[LocalVariableDescriptor]

'TypeApply' @ [141:22] ==> public open fun TypeApply(p0: (JCTree.JCExpression..JCTree.JCExpression?), p1: (List<(JCTree.JCExpression..JCTree.JCExpression?)>..List<(JCTree.JCExpression..JCTree.JCExpression?)>?)): (JCTree.JCTypeApply..JCTree.JCTypeApply?) defined in org.jetbrains.kotlin.kapt3.javac.KaptTreeMaker[JavaMethodDescriptor]

'treeMaker' @ [141:32] ==> val treeMaker: KaptTreeMaker defined in org.jetbrains.kotlin.kapt3.stubs.convertFunctionType[LocalVariableDescriptor]

'SimpleName' @ [141:42] ==> public final fun SimpleName(name: String): JCTree.JCExpression defined in org.jetbrains.kotlin.kapt3.javac.KaptTreeMaker[SimpleFunctionDescriptorImpl]

'+' @ [141:53] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'parameterTypes' @ [141:67] ==> var parameterTypes: List<JCTree.JCExpression> defined in org.jetbrains.kotlin.kapt3.stubs.convertFunctionType[LocalVariableDescriptor]

'size' @ [141:82] ==> public open val size: Int defined in com.sun.tools.javac.util.List[JavaPropertyDescriptor]

'parameterTypes' @ [141:94] ==> var parameterTypes: List<JCTree.JCExpression> defined in org.jetbrains.kotlin.kapt3.stubs.convertFunctionType[LocalVariableDescriptor]

'allowedDepth' @ [146:9] ==> value-parameter allowedDepth: Int = ... defined in org.jetbrains.kotlin.kapt3.stubs.containsErrorTypes[ValueParameterDescriptorImpl]

'this' @ [150:9] ==> <this> defined in org.jetbrains.kotlin.kapt3.stubs.containsErrorTypes[ReceiverParameterDescriptorImpl]

'isError' @ [150:14] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types[DeserializedPropertyDescriptor]

'this' @ [151:9] ==> <this> defined in org.jetbrains.kotlin.kapt3.stubs.containsErrorTypes[ReceiverParameterDescriptorImpl]

'arguments' @ [151:14] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[DeserializedPropertyDescriptor]

'any' @ [151:24] ==> public inline fun <T> Iterable<TypeProjection>.any(predicate: (TypeProjection) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjection

'!' @ [151:30] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'it' @ [151:31] ==> value-parameter it: TypeProjection defined in org.jetbrains.kotlin.kapt3.stubs.containsErrorTypes.<anonymous>[ValueParameterDescriptorImpl]

'isStarProjection' @ [151:34] ==> public final val TypeProjection.isStarProjection: Boolean[MyPropertyDescriptor]

'it' @ [151:54] ==> value-parameter it: TypeProjection defined in org.jetbrains.kotlin.kapt3.stubs.containsErrorTypes.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [151:57] ==> public final val TypeProjection.type: KotlinType[MyPropertyDescriptor]

'containsErrorTypes' @ [151:62] ==> public fun KotlinType.containsErrorTypes(allowedDepth: Int = ...): Boolean defined in org.jetbrains.kotlin.kapt3.stubs in file errorTypeConversion.kt[SimpleFunctionDescriptorImpl]

'allowedDepth' @ [151:81] ==> value-parameter allowedDepth: Int = ... defined in org.jetbrains.kotlin.kapt3.stubs.containsErrorTypes[ValueParameterDescriptorImpl]

