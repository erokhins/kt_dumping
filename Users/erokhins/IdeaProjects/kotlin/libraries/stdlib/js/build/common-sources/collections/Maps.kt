'kotlin.jvm.JvmMultifileClass' @ [1:1] ==> public constructor JvmMultifileClass() defined in kotlin.jvm.JvmMultifileClass[ClassConstructorDescriptorImpl]

'kotlin.jvm.JvmName' @ [2:1] ==> public constructor JvmName(name: String) defined in kotlin.jvm.JvmName[ClassConstructorDescriptorImpl]

'other' @ [9:49] ==> value-parameter other: Any? defined in kotlin.collections.EmptyMap.equals[ValueParameterDescriptorImpl]

'other' @ [9:70] ==> value-parameter other: Any? defined in kotlin.collections.EmptyMap.equals[ValueParameterDescriptorImpl]

'isEmpty' @ [9:76] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.Map[SimpleFunctionDescriptorImpl]

'EmptySet' @ [19:65] ==> internal object EmptySet : Set<Nothing>, Serializable defined in kotlin.collections in file Sets.kt[FakeCallableDescriptorForObject]

'EmptySet' @ [20:42] ==> internal object EmptySet : Set<Nothing>, Serializable defined in kotlin.collections in file Sets.kt[FakeCallableDescriptorForObject]

'EmptyList' @ [21:54] ==> internal object EmptyList : List<Nothing>, Serializable, RandomAccess defined in kotlin.collections in file Collections.kt[FakeCallableDescriptorForObject]

'EmptyMap' @ [23:38] ==> private object EmptyMap : Map<Any?, Nothing>, Serializable defined in kotlin.collections in file Maps.kt[FakeCallableDescriptorForObject]

'Suppress' @ [32:43] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'EmptyMap' @ [32:72] ==> private object EmptyMap : Map<Any?, Nothing>, Serializable defined in kotlin.collections in file Maps.kt[FakeCallableDescriptorForObject]

'if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()' @ [46:64] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Map<K, V>, elseBranch: Map<K, V>): Map<K, V>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Map<K, V>

'pairs' @ [46:68] ==> value-parameter vararg pairs: Pair<K, V> defined in kotlin.collections.mapOf[ValueParameterDescriptorImpl]

'size' @ [46:74] ==> public final val size: Int defined in kotlin.Array[DeserializedPropertyDescriptor]

'pairs' @ [46:84] ==> value-parameter vararg pairs: Pair<K, V> defined in kotlin.collections.mapOf[ValueParameterDescriptorImpl]

'toMap' @ [46:90] ==> public fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: LinkedHashMap<K, V>): LinkedHashMap<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V
    <M : MutableMap<in K, in V>> -> LinkedHashMap<K, V>

'LinkedHashMap' @ [46:96] ==> public constructor LinkedHashMap<K, V>(initialCapacity: Int, loadFactor: Float = ...) defined in kotlin.collections.LinkedHashMap[ClassConstructorDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'mapCapacity' @ [46:110] ==> @PublishedApi internal fun mapCapacity(expectedSize: Int): Int defined in kotlin.collections in file Maps.kt[SimpleFunctionDescriptorImpl]

'pairs' @ [46:122] ==> value-parameter vararg pairs: Pair<K, V> defined in kotlin.collections.mapOf[ValueParameterDescriptorImpl]

'size' @ [46:128] ==> public final val size: Int defined in kotlin.Array[DeserializedPropertyDescriptor]

'emptyMap' @ [46:141] ==> public fun <K, V> emptyMap(): Map<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'kotlin.internal.InlineOnly' @ [54:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'emptyMap' @ [55:47] ==> public fun <K, V> emptyMap(): Map<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'SinceKotlin' @ [74:1] ==> public constructor SinceKotlin(version: String) defined in kotlin.SinceKotlin[DeserializedClassConstructorDescriptor]

'kotlin.internal.InlineOnly' @ [75:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'LinkedHashMap' @ [76:61] ==> public constructor LinkedHashMap<K, V>() defined in kotlin.collections.LinkedHashMap[ClassConstructorDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'LinkedHashMap' @ [90:11] ==> public constructor LinkedHashMap<K, V>(initialCapacity: Int, loadFactor: Float = ...) defined in kotlin.collections.LinkedHashMap[ClassConstructorDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'mapCapacity' @ [90:31] ==> @PublishedApi internal fun mapCapacity(expectedSize: Int): Int defined in kotlin.collections in file Maps.kt[SimpleFunctionDescriptorImpl]

'pairs' @ [90:43] ==> value-parameter vararg pairs: Pair<K, V> defined in kotlin.collections.mutableMapOf[ValueParameterDescriptorImpl]

'size' @ [90:49] ==> public final val size: Int defined in kotlin.Array[DeserializedPropertyDescriptor]

'apply' @ [90:56] ==> @InlineOnly public inline fun <T> LinkedHashMap<K, V>.apply(block: LinkedHashMap<K, V>.() -> Unit): LinkedHashMap<K, V> defined in kotlin[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> LinkedHashMap<K, V>

'putAll' @ [90:64] ==> public fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'pairs' @ [90:71] ==> value-parameter vararg pairs: Pair<K, V> defined in kotlin.collections.mutableMapOf[ValueParameterDescriptorImpl]

'SinceKotlin' @ [95:1] ==> public constructor SinceKotlin(version: String) defined in kotlin.SinceKotlin[DeserializedClassConstructorDescriptor]

'kotlin.internal.InlineOnly' @ [96:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'HashMap' @ [97:55] ==> public constructor HashMap<K, V>() defined in kotlin.collections.HashMap[ClassConstructorDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'HashMap' @ [106:11] ==> public constructor HashMap<K, V>(initialCapacity: Int, loadFactor: Float = ...) defined in kotlin.collections.HashMap[ClassConstructorDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'mapCapacity' @ [106:25] ==> @PublishedApi internal fun mapCapacity(expectedSize: Int): Int defined in kotlin.collections in file Maps.kt[SimpleFunctionDescriptorImpl]

'pairs' @ [106:37] ==> value-parameter vararg pairs: Pair<K, V> defined in kotlin.collections.hashMapOf[ValueParameterDescriptorImpl]

'size' @ [106:43] ==> public final val size: Int defined in kotlin.Array[DeserializedPropertyDescriptor]

'apply' @ [106:50] ==> @InlineOnly public inline fun <T> HashMap<K, V>.apply(block: HashMap<K, V>.() -> Unit): HashMap<K, V> defined in kotlin[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> HashMap<K, V>

'putAll' @ [106:58] ==> public fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'pairs' @ [106:65] ==> value-parameter vararg pairs: Pair<K, V> defined in kotlin.collections.hashMapOf[ValueParameterDescriptorImpl]

'SinceKotlin' @ [111:1] ==> public constructor SinceKotlin(version: String) defined in kotlin.SinceKotlin[DeserializedClassConstructorDescriptor]

'kotlin.internal.InlineOnly' @ [112:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'LinkedHashMap' @ [113:63] ==> public constructor LinkedHashMap<K, V>() defined in kotlin.collections.LinkedHashMap[ClassConstructorDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'pairs' @ [126:11] ==> value-parameter vararg pairs: Pair<K, V> defined in kotlin.collections.linkedMapOf[ValueParameterDescriptorImpl]

'toMap' @ [126:17] ==> public fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: LinkedHashMap<K, V>): LinkedHashMap<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V
    <M : MutableMap<in K, in V>> -> LinkedHashMap<K, V>

'LinkedHashMap' @ [126:23] ==> public constructor LinkedHashMap<K, V>(initialCapacity: Int, loadFactor: Float = ...) defined in kotlin.collections.LinkedHashMap[ClassConstructorDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'mapCapacity' @ [126:37] ==> @PublishedApi internal fun mapCapacity(expectedSize: Int): Int defined in kotlin.collections in file Maps.kt[SimpleFunctionDescriptorImpl]

'pairs' @ [126:49] ==> value-parameter vararg pairs: Pair<K, V> defined in kotlin.collections.linkedMapOf[ValueParameterDescriptorImpl]

'size' @ [126:55] ==> public final val size: Int defined in kotlin.Array[DeserializedPropertyDescriptor]

'PublishedApi' @ [133:1] ==> public constructor PublishedApi() defined in kotlin.PublishedApi[DeserializedClassConstructorDescriptor]

'expectedSize' @ [135:9] ==> value-parameter expectedSize: Int defined in kotlin.collections.mapCapacity[ValueParameterDescriptorImpl]

'expectedSize' @ [136:16] ==> value-parameter expectedSize: Int defined in kotlin.collections.mapCapacity[ValueParameterDescriptorImpl]

'expectedSize' @ [138:9] ==> value-parameter expectedSize: Int defined in kotlin.collections.mapCapacity[ValueParameterDescriptorImpl]

'INT_MAX_POWER_OF_TWO' @ [138:24] ==> private const val INT_MAX_POWER_OF_TWO: Int defined in kotlin.collections in file Maps.kt[PropertyDescriptorImpl]

'expectedSize' @ [139:16] ==> value-parameter expectedSize: Int defined in kotlin.collections.mapCapacity[ValueParameterDescriptorImpl]

'expectedSize' @ [139:31] ==> value-parameter expectedSize: Int defined in kotlin.collections.mapCapacity[ValueParameterDescriptorImpl]

'Int' @ [141:12] ==> public companion object defined in kotlin.Int[FakeCallableDescriptorForObject]

'MAX_VALUE' @ [141:16] ==> public const final val MAX_VALUE: Int defined in kotlin.Int.Companion[DeserializedPropertyDescriptor]

'Int' @ [144:47] ==> public companion object defined in kotlin.Int[FakeCallableDescriptorForObject]

'MAX_VALUE' @ [144:51] ==> public const final val MAX_VALUE: Int defined in kotlin.Int.Companion[DeserializedPropertyDescriptor]

'kotlin.internal.InlineOnly' @ [147:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'!' @ [148:64] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isEmpty' @ [148:65] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.Map[SimpleFunctionDescriptorImpl]

'kotlin.internal.InlineOnly' @ [153:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'this' @ [154:61] ==> <this> defined in kotlin.collections.orEmpty[ReceiverParameterDescriptorImpl]

'emptyMap' @ [154:69] ==> public fun <K, V> emptyMap(): Map<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'kotlin.internal.InlineOnly' @ [161:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'kotlin.internal.OnlyInputTypes' @ [162:29] ==> public constructor OnlyInputTypes() defined in kotlin.internal.OnlyInputTypes[ClassConstructorDescriptorImpl]

'containsKey' @ [162:110] ==> @InlineOnly public inline fun <@OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <@OnlyInputTypes K> -> K

'key' @ [162:122] ==> value-parameter key: K defined in kotlin.collections.contains[ValueParameterDescriptorImpl]

'kotlin.internal.InlineOnly' @ [167:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'kotlin.internal.OnlyInputTypes' @ [168:29] ==> public constructor OnlyInputTypes() defined in kotlin.internal.OnlyInputTypes[ClassConstructorDescriptorImpl]

'Suppress' @ [169:11] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'this' @ [169:40] ==> <this> defined in kotlin.collections.get[ReceiverParameterDescriptorImpl]

'get' @ [169:59] ==> public abstract operator fun get(key: K): V? defined in kotlin.collections.Map[SimpleFunctionDescriptorImpl]

'key' @ [169:63] ==> value-parameter key: K defined in kotlin.collections.get[ValueParameterDescriptorImpl]

'kotlin.internal.InlineOnly' @ [174:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'put' @ [176:5] ==> public abstract fun put(key: K, value: V): V? defined in kotlin.collections.MutableMap[SimpleFunctionDescriptorImpl]

'key' @ [176:9] ==> value-parameter key: K defined in kotlin.collections.set[ValueParameterDescriptorImpl]

'value' @ [176:14] ==> value-parameter value: V defined in kotlin.collections.set[ValueParameterDescriptorImpl]

'kotlin.internal.InlineOnly' @ [184:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'kotlin.internal.OnlyInputTypes' @ [185:20] ==> public constructor OnlyInputTypes() defined in kotlin.internal.OnlyInputTypes[ClassConstructorDescriptorImpl]

'Suppress' @ [186:11] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'this' @ [186:40] ==> <this> defined in kotlin.collections.containsKey[ReceiverParameterDescriptorImpl]

'containsKey' @ [186:59] ==> public abstract fun containsKey(key: K): Boolean defined in kotlin.collections.Map[SimpleFunctionDescriptorImpl]

'key' @ [186:71] ==> value-parameter key: K defined in kotlin.collections.containsKey[ValueParameterDescriptorImpl]

'Suppress' @ [193:1] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'kotlin.internal.InlineOnly' @ [194:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'kotlin.internal.OnlyInputTypes' @ [195:23] ==> public constructor OnlyInputTypes() defined in kotlin.internal.OnlyInputTypes[ClassConstructorDescriptorImpl]

'this' @ [195:103] ==> <this> defined in kotlin.collections.containsValue[ReceiverParameterDescriptorImpl]

'containsValue' @ [195:108] ==> public abstract fun containsValue(value: V): Boolean defined in kotlin.collections.Map[SimpleFunctionDescriptorImpl]

'value' @ [195:122] ==> value-parameter value: V defined in kotlin.collections.containsValue[ValueParameterDescriptorImpl]

'kotlin.internal.InlineOnly' @ [205:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'kotlin.internal.OnlyInputTypes' @ [206:20] ==> public constructor OnlyInputTypes() defined in kotlin.internal.OnlyInputTypes[ClassConstructorDescriptorImpl]

'Suppress' @ [207:11] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'this' @ [207:40] ==> <this> defined in kotlin.collections.remove[ReceiverParameterDescriptorImpl]

'remove' @ [207:66] ==> public abstract fun remove(key: K): V? defined in kotlin.collections.MutableMap[SimpleFunctionDescriptorImpl]

'key' @ [207:73] ==> value-parameter key: K defined in kotlin.collections.remove[ValueParameterDescriptorImpl]

'kotlin.internal.InlineOnly' @ [219:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'key' @ [220:69] ==> public abstract val key: K defined in kotlin.collections.Map.Entry[PropertyDescriptorImpl]

'kotlin.internal.InlineOnly' @ [232:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'value' @ [233:69] ==> public abstract val value: V defined in kotlin.collections.Map.Entry[PropertyDescriptorImpl]

'kotlin.internal.InlineOnly' @ [238:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'Pair' @ [239:65] ==> public constructor Pair<out A, out B>(first: K, second: V) defined in kotlin.Pair[ClassConstructorDescriptorImpl]
Inferred types:
    <out A> -> K
    <out B> -> V

'key' @ [239:70] ==> public abstract val key: K defined in kotlin.collections.Map.Entry[PropertyDescriptorImpl]

'value' @ [239:75] ==> public abstract val value: V defined in kotlin.collections.Map.Entry[PropertyDescriptorImpl]

'kotlin.internal.InlineOnly' @ [246:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'get' @ [247:82] ==> public abstract operator fun get(key: K): V? defined in kotlin.collections.Map[SimpleFunctionDescriptorImpl]

'key' @ [247:86] ==> value-parameter key: K defined in kotlin.collections.getOrElse[ValueParameterDescriptorImpl]

'invoke' @ [247:94] ==> public abstract operator fun invoke(): V defined in kotlin.Function0[FunctionInvokeDescriptor]

'get' @ [251:17] ==> public abstract operator fun get(key: K): V? defined in kotlin.collections.Map[SimpleFunctionDescriptorImpl]

'key' @ [251:21] ==> value-parameter key: K defined in kotlin.collections.getOrElseNullable[ValueParameterDescriptorImpl]

'if (value == null && !containsKey(key)) {
        return defaultValue()
    } else {
        @Suppress("UNCHECKED_CAST")
        return value as V
    }' @ [252:5] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nothing, elseBranch: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nothing

'value' @ [252:9] ==> val value: V? defined in kotlin.collections.getOrElseNullable[LocalVariableDescriptor]

'!' @ [252:26] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'containsKey' @ [252:27] ==> public abstract fun containsKey(key: K): Boolean defined in kotlin.collections.Map[SimpleFunctionDescriptorImpl]

'key' @ [252:39] ==> value-parameter key: K defined in kotlin.collections.getOrElseNullable[ValueParameterDescriptorImpl]

'invoke' @ [253:16] ==> public abstract operator fun invoke(): V defined in kotlin.Function0[FunctionInvokeDescriptor]

'Suppress' @ [255:9] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'value' @ [256:16] ==> val value: V? defined in kotlin.collections.getOrElseNullable[LocalVariableDescriptor]

'SinceKotlin' @ [269:1] ==> public constructor SinceKotlin(version: String) defined in kotlin.SinceKotlin[DeserializedClassConstructorDescriptor]

'getOrImplicitDefault' @ [270:51] ==> @JvmName @PublishedApi internal fun <K, V> Map<K, V>.getOrImplicitDefault(key: K): V defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'key' @ [270:72] ==> value-parameter key: K defined in kotlin.collections.getValue[ValueParameterDescriptorImpl]

'get' @ [279:17] ==> public abstract fun get(key: K): V? defined in kotlin.collections.MutableMap[SimpleFunctionDescriptorImpl]

'key' @ [279:21] ==> value-parameter key: K defined in kotlin.collections.getOrPut[ValueParameterDescriptorImpl]

'if (value == null) {
        val answer = defaultValue()
        put(key, answer)
        answer
    } else {
        value
    }' @ [280:12] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: V, elseBranch: V): V[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> V

'value' @ [280:16] ==> val value: V? defined in kotlin.collections.getOrPut[LocalVariableDescriptor]

'invoke' @ [281:22] ==> public abstract operator fun invoke(): V defined in kotlin.Function0[FunctionInvokeDescriptor]

'put' @ [282:9] ==> public abstract fun put(key: K, value: V): V? defined in kotlin.collections.MutableMap[SimpleFunctionDescriptorImpl]

'key' @ [282:13] ==> value-parameter key: K defined in kotlin.collections.getOrPut[ValueParameterDescriptorImpl]

'answer' @ [282:18] ==> val answer: V defined in kotlin.collections.getOrPut[LocalVariableDescriptor]

'answer' @ [283:9] ==> val answer: V defined in kotlin.collections.getOrPut[LocalVariableDescriptor]

'value' @ [285:9] ==> val value: V? defined in kotlin.collections.getOrPut[LocalVariableDescriptor]

'kotlin.internal.InlineOnly' @ [294:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'entries' @ [295:89] ==> public abstract val entries: Set<Map.Entry<K, V>> defined in kotlin.collections.Map[PropertyDescriptorImpl]

'iterator' @ [295:97] ==> public abstract fun iterator(): Iterator<Map.Entry<K, V>> defined in kotlin.collections.Set[SimpleFunctionDescriptorImpl]

'kotlin.jvm.JvmName' @ [301:1] ==> public constructor JvmName(name: String) defined in kotlin.jvm.JvmName[ClassConstructorDescriptorImpl]

'kotlin.internal.InlineOnly' @ [302:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'entries' @ [303:113] ==> public abstract val entries: MutableSet<MutableMap.MutableEntry<K, V>> defined in kotlin.collections.MutableMap[PropertyDescriptorImpl]

'iterator' @ [303:121] ==> public abstract fun iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> defined in kotlin.collections.MutableSet[SimpleFunctionDescriptorImpl]

'entries' @ [310:12] ==> public abstract val entries: Set<Map.Entry<K, V>> defined in kotlin.collections.Map[PropertyDescriptorImpl]

'associateByTo' @ [310:20] ==> public inline fun <T, K, V, M : MutableMap<in K, in R>> Iterable<Map.Entry<K, V>>.associateByTo(destination: M, keySelector: (Map.Entry<K, V>) -> K, valueTransform: (Map.Entry<K, V>) -> R): M defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> Entry<K, V>
    <K> -> K
    <V> -> R
    <M : MutableMap<in K, in V>> -> M

'destination' @ [310:34] ==> value-parameter destination: M defined in kotlin.collections.mapValuesTo[ValueParameterDescriptorImpl]

'it' @ [310:49] ==> value-parameter it: Map.Entry<K, V> defined in kotlin.collections.mapValuesTo.<anonymous>[ValueParameterDescriptorImpl]

'key' @ [310:52] ==> public abstract val key: K defined in kotlin.collections.Map.Entry[PropertyDescriptorImpl]

'transform' @ [310:59] ==> value-parameter transform: (Map.Entry<K, V>) -> R defined in kotlin.collections.mapValuesTo[ValueParameterDescriptorImpl]

'entries' @ [321:12] ==> public abstract val entries: Set<Map.Entry<K, V>> defined in kotlin.collections.Map[PropertyDescriptorImpl]

'associateByTo' @ [321:20] ==> public inline fun <T, K, V, M : MutableMap<in R, in V>> Iterable<Map.Entry<K, V>>.associateByTo(destination: M, keySelector: (Map.Entry<K, V>) -> R, valueTransform: (Map.Entry<K, V>) -> V): M defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> Entry<K, V>
    <K> -> R
    <V> -> V
    <M : MutableMap<in K, in V>> -> M

'destination' @ [321:34] ==> value-parameter destination: M defined in kotlin.collections.mapKeysTo[ValueParameterDescriptorImpl]

'transform' @ [321:47] ==> value-parameter transform: (Map.Entry<K, V>) -> R defined in kotlin.collections.mapKeysTo[ValueParameterDescriptorImpl]

'it' @ [321:60] ==> value-parameter it: Map.Entry<K, V> defined in kotlin.collections.mapKeysTo.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [321:63] ==> public abstract val value: V defined in kotlin.collections.Map.Entry[PropertyDescriptorImpl]

'component1' @ [328:11] ==> public final operator fun component1(): K defined in kotlin.Pair[SimpleFunctionDescriptorImpl]

'component2' @ [328:16] ==> public final operator fun component2(): V defined in kotlin.Pair[SimpleFunctionDescriptorImpl]

'pairs' @ [328:26] ==> value-parameter pairs: Array<out Pair<K, V>> defined in kotlin.collections.putAll[ValueParameterDescriptorImpl]

'put' @ [329:9] ==> public abstract fun put(key: K, value: V): Any? defined in kotlin.collections.MutableMap[SimpleFunctionDescriptorImpl]

'key' @ [329:13] ==> val key: K defined in kotlin.collections.putAll[LocalVariableDescriptor]

'value' @ [329:18] ==> val value: V defined in kotlin.collections.putAll[LocalVariableDescriptor]

'component1' @ [337:11] ==> public final operator fun component1(): K defined in kotlin.Pair[SimpleFunctionDescriptorImpl]

'component2' @ [337:16] ==> public final operator fun component2(): V defined in kotlin.Pair[SimpleFunctionDescriptorImpl]

'pairs' @ [337:26] ==> value-parameter pairs: Iterable<Pair<K, V>> defined in kotlin.collections.putAll[ValueParameterDescriptorImpl]

'put' @ [338:9] ==> public abstract fun put(key: K, value: V): Any? defined in kotlin.collections.MutableMap[SimpleFunctionDescriptorImpl]

'key' @ [338:13] ==> val key: K defined in kotlin.collections.putAll[LocalVariableDescriptor]

'value' @ [338:18] ==> val value: V defined in kotlin.collections.putAll[LocalVariableDescriptor]

'component1' @ [346:11] ==> public final operator fun component1(): K defined in kotlin.Pair[SimpleFunctionDescriptorImpl]

'component2' @ [346:16] ==> public final operator fun component2(): V defined in kotlin.Pair[SimpleFunctionDescriptorImpl]

'pairs' @ [346:26] ==> value-parameter pairs: Sequence<Pair<K, V>> defined in kotlin.collections.putAll[ValueParameterDescriptorImpl]

'put' @ [347:9] ==> public abstract fun put(key: K, value: V): Any? defined in kotlin.collections.MutableMap[SimpleFunctionDescriptorImpl]

'key' @ [347:13] ==> val key: K defined in kotlin.collections.putAll[LocalVariableDescriptor]

'value' @ [347:18] ==> val value: V defined in kotlin.collections.putAll[LocalVariableDescriptor]

'mapValuesTo' @ [360:12] ==> public inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: LinkedHashMap<K, R>, transform: (Map.Entry<K, V>) -> R): LinkedHashMap<K, R> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V
    <R> -> R
    <M : MutableMap<in K, in R>> -> LinkedHashMap<K, R>

'LinkedHashMap' @ [360:24] ==> public constructor LinkedHashMap<K, V>(initialCapacity: Int, loadFactor: Float = ...) defined in kotlin.collections.LinkedHashMap[ClassConstructorDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> R

'mapCapacity' @ [360:44] ==> @PublishedApi internal fun mapCapacity(expectedSize: Int): Int defined in kotlin.collections in file Maps.kt[SimpleFunctionDescriptorImpl]

'size' @ [360:56] ==> public abstract val size: Int defined in kotlin.collections.Map[PropertyDescriptorImpl]

'transform' @ [360:64] ==> value-parameter transform: (Map.Entry<K, V>) -> R defined in kotlin.collections.mapValues[ValueParameterDescriptorImpl]

'mapKeysTo' @ [375:12] ==> public inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: LinkedHashMap<R, V>, transform: (Map.Entry<K, V>) -> R): LinkedHashMap<R, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V
    <R> -> R
    <M : MutableMap<in R, in V>> -> LinkedHashMap<R, V>

'LinkedHashMap' @ [375:22] ==> public constructor LinkedHashMap<K, V>(initialCapacity: Int, loadFactor: Float = ...) defined in kotlin.collections.LinkedHashMap[ClassConstructorDescriptorImpl]
Inferred types:
    <K> -> R
    <V> -> V

'mapCapacity' @ [375:42] ==> @PublishedApi internal fun mapCapacity(expectedSize: Int): Int defined in kotlin.collections in file Maps.kt[SimpleFunctionDescriptorImpl]

'size' @ [375:54] ==> public abstract val size: Int defined in kotlin.collections.Map[PropertyDescriptorImpl]

'transform' @ [375:62] ==> value-parameter transform: (Map.Entry<K, V>) -> R defined in kotlin.collections.mapKeys[ValueParameterDescriptorImpl]

'LinkedHashMap' @ [384:18] ==> public constructor LinkedHashMap<K, V>() defined in kotlin.collections.LinkedHashMap[ClassConstructorDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'this' @ [385:19] ==> <this> defined in kotlin.collections.filterKeys[ReceiverParameterDescriptorImpl]

'invoke' @ [386:13] ==> public abstract operator fun invoke(p1: K): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'entry' @ [386:23] ==> val entry: Map.Entry<K, V> defined in kotlin.collections.filterKeys[LocalVariableDescriptor]

'key' @ [386:29] ==> public abstract val key: K defined in kotlin.collections.Map.Entry[PropertyDescriptorImpl]

'result' @ [387:13] ==> val result: LinkedHashMap<K, V> defined in kotlin.collections.filterKeys[LocalVariableDescriptor]

'put' @ [387:20] ==> public open fun put(key: K, value: V): V? defined in kotlin.collections.LinkedHashMap[SimpleFunctionDescriptorImpl]

'entry' @ [387:24] ==> val entry: Map.Entry<K, V> defined in kotlin.collections.filterKeys[LocalVariableDescriptor]

'key' @ [387:30] ==> public abstract val key: K defined in kotlin.collections.Map.Entry[PropertyDescriptorImpl]

'entry' @ [387:35] ==> val entry: Map.Entry<K, V> defined in kotlin.collections.filterKeys[LocalVariableDescriptor]

'value' @ [387:41] ==> public abstract val value: V defined in kotlin.collections.Map.Entry[PropertyDescriptorImpl]

'result' @ [390:12] ==> val result: LinkedHashMap<K, V> defined in kotlin.collections.filterKeys[LocalVariableDescriptor]

'LinkedHashMap' @ [399:18] ==> public constructor LinkedHashMap<K, V>() defined in kotlin.collections.LinkedHashMap[ClassConstructorDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'this' @ [400:19] ==> <this> defined in kotlin.collections.filterValues[ReceiverParameterDescriptorImpl]

'invoke' @ [401:13] ==> public abstract operator fun invoke(p1: V): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'entry' @ [401:23] ==> val entry: Map.Entry<K, V> defined in kotlin.collections.filterValues[LocalVariableDescriptor]

'value' @ [401:29] ==> public abstract val value: V defined in kotlin.collections.Map.Entry[PropertyDescriptorImpl]

'result' @ [402:13] ==> val result: LinkedHashMap<K, V> defined in kotlin.collections.filterValues[LocalVariableDescriptor]

'put' @ [402:20] ==> public open fun put(key: K, value: V): V? defined in kotlin.collections.LinkedHashMap[SimpleFunctionDescriptorImpl]

'entry' @ [402:24] ==> val entry: Map.Entry<K, V> defined in kotlin.collections.filterValues[LocalVariableDescriptor]

'key' @ [402:30] ==> public abstract val key: K defined in kotlin.collections.Map.Entry[PropertyDescriptorImpl]

'entry' @ [402:35] ==> val entry: Map.Entry<K, V> defined in kotlin.collections.filterValues[LocalVariableDescriptor]

'value' @ [402:41] ==> public abstract val value: V defined in kotlin.collections.Map.Entry[PropertyDescriptorImpl]

'result' @ [405:12] ==> val result: LinkedHashMap<K, V> defined in kotlin.collections.filterValues[LocalVariableDescriptor]

'this' @ [415:21] ==> <this> defined in kotlin.collections.filterTo[ReceiverParameterDescriptorImpl]

'invoke' @ [416:13] ==> public abstract operator fun invoke(p1: Map.Entry<K, V>): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'element' @ [416:23] ==> val element: Map.Entry<K, V> defined in kotlin.collections.filterTo[LocalVariableDescriptor]

'destination' @ [417:13] ==> value-parameter destination: M defined in kotlin.collections.filterTo[ValueParameterDescriptorImpl]

'put' @ [417:25] ==> public abstract fun put(key: K, value: V): Any? defined in kotlin.collections.MutableMap[SimpleFunctionDescriptorImpl]

'element' @ [417:29] ==> val element: Map.Entry<K, V> defined in kotlin.collections.filterTo[LocalVariableDescriptor]

'key' @ [417:37] ==> public abstract val key: K defined in kotlin.collections.Map.Entry[PropertyDescriptorImpl]

'element' @ [417:42] ==> val element: Map.Entry<K, V> defined in kotlin.collections.filterTo[LocalVariableDescriptor]

'value' @ [417:50] ==> public abstract val value: V defined in kotlin.collections.Map.Entry[PropertyDescriptorImpl]

'destination' @ [420:12] ==> value-parameter destination: M defined in kotlin.collections.filterTo[ValueParameterDescriptorImpl]

'filterTo' @ [429:12] ==> public inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: LinkedHashMap<K, V>, predicate: (Map.Entry<K, V>) -> Boolean): LinkedHashMap<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V
    <M : MutableMap<in K, in V>> -> LinkedHashMap<K, V>

'LinkedHashMap' @ [429:21] ==> public constructor LinkedHashMap<K, V>() defined in kotlin.collections.LinkedHashMap[ClassConstructorDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'predicate' @ [429:44] ==> value-parameter predicate: (Map.Entry<K, V>) -> Boolean defined in kotlin.collections.filter[ValueParameterDescriptorImpl]

'this' @ [438:21] ==> <this> defined in kotlin.collections.filterNotTo[ReceiverParameterDescriptorImpl]

'!' @ [439:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'invoke' @ [439:14] ==> public abstract operator fun invoke(p1: Map.Entry<K, V>): Boolean defined in kotlin.Function1[FunctionInvokeDescriptor]

'element' @ [439:24] ==> val element: Map.Entry<K, V> defined in kotlin.collections.filterNotTo[LocalVariableDescriptor]

'destination' @ [440:13] ==> value-parameter destination: M defined in kotlin.collections.filterNotTo[ValueParameterDescriptorImpl]

'put' @ [440:25] ==> public abstract fun put(key: K, value: V): Any? defined in kotlin.collections.MutableMap[SimpleFunctionDescriptorImpl]

'element' @ [440:29] ==> val element: Map.Entry<K, V> defined in kotlin.collections.filterNotTo[LocalVariableDescriptor]

'key' @ [440:37] ==> public abstract val key: K defined in kotlin.collections.Map.Entry[PropertyDescriptorImpl]

'element' @ [440:42] ==> val element: Map.Entry<K, V> defined in kotlin.collections.filterNotTo[LocalVariableDescriptor]

'value' @ [440:50] ==> public abstract val value: V defined in kotlin.collections.Map.Entry[PropertyDescriptorImpl]

'destination' @ [443:12] ==> value-parameter destination: M defined in kotlin.collections.filterNotTo[ValueParameterDescriptorImpl]

'filterNotTo' @ [452:12] ==> public inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: LinkedHashMap<K, V>, predicate: (Map.Entry<K, V>) -> Boolean): LinkedHashMap<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V
    <M : MutableMap<in K, in V>> -> LinkedHashMap<K, V>

'LinkedHashMap' @ [452:24] ==> public constructor LinkedHashMap<K, V>() defined in kotlin.collections.LinkedHashMap[ClassConstructorDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'predicate' @ [452:47] ==> value-parameter predicate: (Map.Entry<K, V>) -> Boolean defined in kotlin.collections.filterNot[ValueParameterDescriptorImpl]

'this' @ [461:9] ==> <this> defined in kotlin.collections.toMap[ReceiverParameterDescriptorImpl]

'when (size) {
            0 -> emptyMap()
            1 -> mapOf(if (this is List) this[0] else iterator().next())
            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))
        }' @ [462:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Map<K, V>, entry1: Map<K, V>, entry2: Map<K, V>): Map<K, V>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Map<K, V>

'size' @ [462:22] ==> public abstract val size: Int defined in kotlin.collections.Collection[PropertyDescriptorImpl]

'emptyMap' @ [463:18] ==> public fun <K, V> emptyMap(): Map<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'mapOf' @ [464:18] ==> public fun <K, V> mapOf(pair: Pair<K, V>): Map<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'if (this is List) this[0] else iterator().next()' @ [464:24] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Pair<K, V>, elseBranch: Pair<K, V>): Pair<K, V>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Pair<K, V>

'this' @ [464:28] ==> <this> defined in kotlin.collections.toMap[ReceiverParameterDescriptorImpl]

'this' @ [464:42] ==> <this> defined in kotlin.collections.toMap[ReceiverParameterDescriptorImpl]

'iterator' @ [464:55] ==> public abstract operator fun iterator(): Iterator<Pair<K, V>> defined in kotlin.collections.Iterable[SimpleFunctionDescriptorImpl]

'next' @ [464:66] ==> public abstract operator fun next(): Pair<K, V> defined in kotlin.collections.Iterator[SimpleFunctionDescriptorImpl]

'toMap' @ [465:21] ==> public fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: LinkedHashMap<K, V>): LinkedHashMap<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V
    <M : MutableMap<in K, in V>> -> LinkedHashMap<K, V>

'LinkedHashMap' @ [465:27] ==> public constructor LinkedHashMap<K, V>(initialCapacity: Int, loadFactor: Float = ...) defined in kotlin.collections.LinkedHashMap[ClassConstructorDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'mapCapacity' @ [465:47] ==> @PublishedApi internal fun mapCapacity(expectedSize: Int): Int defined in kotlin.collections in file Maps.kt[SimpleFunctionDescriptorImpl]

'size' @ [465:59] ==> public abstract val size: Int defined in kotlin.collections.Collection[PropertyDescriptorImpl]

'toMap' @ [468:12] ==> public fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: LinkedHashMap<K, V>): LinkedHashMap<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V
    <M : MutableMap<in K, in V>> -> LinkedHashMap<K, V>

'LinkedHashMap' @ [468:18] ==> public constructor LinkedHashMap<K, V>() defined in kotlin.collections.LinkedHashMap[ClassConstructorDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'optimizeReadOnlyMap' @ [468:41] ==> internal fun <K, V> Map<K, V>.optimizeReadOnlyMap(): Map<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'destination' @ [475:11] ==> value-parameter destination: M defined in kotlin.collections.toMap[ValueParameterDescriptorImpl]

'apply' @ [475:23] ==> @InlineOnly public inline fun <T> M.apply(block: M.() -> Unit): M defined in kotlin[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> M

'putAll' @ [475:31] ==> public fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'this@toMap' @ [475:38] ==> <this> defined in kotlin.collections.toMap[ReceiverParameterDescriptorImpl]

'when(size) {
    0 -> emptyMap()
    1 -> mapOf(this[0])
    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))
}' @ [482:62] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Map<K, V>, entry1: Map<K, V>, entry2: Map<K, V>): Map<K, V>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Map<K, V>

'size' @ [482:67] ==> public final val size: Int defined in kotlin.Array[DeserializedPropertyDescriptor]

'emptyMap' @ [483:10] ==> public fun <K, V> emptyMap(): Map<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'mapOf' @ [484:10] ==> public fun <K, V> mapOf(pair: Pair<K, V>): Map<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'this' @ [484:16] ==> <this> defined in kotlin.collections.toMap[ReceiverParameterDescriptorImpl]

'toMap' @ [485:13] ==> public fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: LinkedHashMap<K, V>): LinkedHashMap<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V
    <M : MutableMap<in K, in V>> -> LinkedHashMap<K, V>

'LinkedHashMap' @ [485:19] ==> public constructor LinkedHashMap<K, V>(initialCapacity: Int, loadFactor: Float = ...) defined in kotlin.collections.LinkedHashMap[ClassConstructorDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'mapCapacity' @ [485:39] ==> @PublishedApi internal fun mapCapacity(expectedSize: Int): Int defined in kotlin.collections in file Maps.kt[SimpleFunctionDescriptorImpl]

'size' @ [485:51] ==> public final val size: Int defined in kotlin.Array[DeserializedPropertyDescriptor]

'destination' @ [492:11] ==> value-parameter destination: M defined in kotlin.collections.toMap[ValueParameterDescriptorImpl]

'apply' @ [492:23] ==> @InlineOnly public inline fun <T> M.apply(block: M.() -> Unit): M defined in kotlin[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> M

'putAll' @ [492:31] ==> public fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'this@toMap' @ [492:38] ==> <this> defined in kotlin.collections.toMap[ReceiverParameterDescriptorImpl]

'toMap' @ [499:61] ==> public fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: LinkedHashMap<K, V>): LinkedHashMap<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V
    <M : MutableMap<in K, in V>> -> LinkedHashMap<K, V>

'LinkedHashMap' @ [499:67] ==> public constructor LinkedHashMap<K, V>() defined in kotlin.collections.LinkedHashMap[ClassConstructorDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'optimizeReadOnlyMap' @ [499:90] ==> internal fun <K, V> Map<K, V>.optimizeReadOnlyMap(): Map<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'destination' @ [505:11] ==> value-parameter destination: M defined in kotlin.collections.toMap[ValueParameterDescriptorImpl]

'apply' @ [505:23] ==> @InlineOnly public inline fun <T> M.apply(block: M.() -> Unit): M defined in kotlin[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> M

'putAll' @ [505:31] ==> public fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'this@toMap' @ [505:38] ==> <this> defined in kotlin.collections.toMap[ReceiverParameterDescriptorImpl]

'SinceKotlin' @ [512:1] ==> public constructor SinceKotlin(version: String) defined in kotlin.SinceKotlin[DeserializedClassConstructorDescriptor]

'when (size) {
    0 -> emptyMap()
    1 -> toSingletonMap()
    else -> toMutableMap()
}' @ [513:54] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Map<K, V>, entry1: Map<K, V>, entry2: Map<K, V>): Map<K, V>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Map<K, V>

'size' @ [513:60] ==> public abstract val size: Int defined in kotlin.collections.Map[PropertyDescriptorImpl]

'emptyMap' @ [514:10] ==> public fun <K, V> emptyMap(): Map<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'toSingletonMap' @ [515:10] ==> internal inline fun <K, V> Map<out K, V>.toSingletonMap(): Map<K, V> defined in kotlin[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'toMutableMap' @ [516:13] ==> @SinceKotlin public fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'SinceKotlin' @ [524:1] ==> public constructor SinceKotlin(version: String) defined in kotlin.SinceKotlin[DeserializedClassConstructorDescriptor]

'LinkedHashMap' @ [525:68] ==> public constructor LinkedHashMap<K, V>(original: Map<out K, V>) defined in kotlin.collections.LinkedHashMap[ClassConstructorDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'this' @ [525:82] ==> <this> defined in kotlin.collections.toMutableMap[ReceiverParameterDescriptorImpl]

'SinceKotlin' @ [530:1] ==> public constructor SinceKotlin(version: String) defined in kotlin.SinceKotlin[DeserializedClassConstructorDescriptor]

'destination' @ [532:11] ==> value-parameter destination: M defined in kotlin.collections.toMap[ValueParameterDescriptorImpl]

'apply' @ [532:23] ==> @InlineOnly public inline fun <T> M.apply(block: M.() -> Unit): M defined in kotlin[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> M

'putAll' @ [532:31] ==> public abstract fun putAll(from: Map<out K, V>): Unit defined in kotlin.collections.MutableMap[SimpleFunctionDescriptorImpl]

'this@toMap' @ [532:38] ==> <this> defined in kotlin.collections.toMap[ReceiverParameterDescriptorImpl]

'if (this.isEmpty()) mapOf(pair) else LinkedHashMap<K, V>(this).apply { put(pair.first, pair.second) }' @ [541:11] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Map<K, V>, elseBranch: Map<K, V>): Map<K, V>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Map<K, V>

'this' @ [541:15] ==> <this> defined in kotlin.collections.plus[ReceiverParameterDescriptorImpl]

'isEmpty' @ [541:20] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.Map[SimpleFunctionDescriptorImpl]

'mapOf' @ [541:31] ==> public fun <K, V> mapOf(pair: Pair<K, V>): Map<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'pair' @ [541:37] ==> value-parameter pair: Pair<K, V> defined in kotlin.collections.plus[ValueParameterDescriptorImpl]

'LinkedHashMap' @ [541:48] ==> public constructor LinkedHashMap<K, V>(original: Map<out K, V>) defined in kotlin.collections.LinkedHashMap[ClassConstructorDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'this' @ [541:68] ==> <this> defined in kotlin.collections.plus[ReceiverParameterDescriptorImpl]

'apply' @ [541:74] ==> @InlineOnly public inline fun <T> LinkedHashMap<K, V>.apply(block: LinkedHashMap<K, V>.() -> Unit): LinkedHashMap<K, V> defined in kotlin[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> LinkedHashMap<K, V>

'put' @ [541:82] ==> public open fun put(key: K, value: V): V? defined in kotlin.collections.LinkedHashMap[SimpleFunctionDescriptorImpl]

'pair' @ [541:86] ==> value-parameter pair: Pair<K, V> defined in kotlin.collections.plus[ValueParameterDescriptorImpl]

'first' @ [541:91] ==> public final val first: K defined in kotlin.Pair[PropertyDescriptorImpl]

'pair' @ [541:98] ==> value-parameter pair: Pair<K, V> defined in kotlin.collections.plus[ValueParameterDescriptorImpl]

'second' @ [541:103] ==> public final val second: V defined in kotlin.Pair[PropertyDescriptorImpl]

'if (this.isEmpty()) pairs.toMap() else LinkedHashMap<K, V>(this).apply { putAll(pairs) }' @ [550:11] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Map<K, V>, elseBranch: Map<K, V>): Map<K, V>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Map<K, V>

'this' @ [550:15] ==> <this> defined in kotlin.collections.plus[ReceiverParameterDescriptorImpl]

'isEmpty' @ [550:20] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.Map[SimpleFunctionDescriptorImpl]

'pairs' @ [550:31] ==> value-parameter pairs: Iterable<Pair<K, V>> defined in kotlin.collections.plus[ValueParameterDescriptorImpl]

'toMap' @ [550:37] ==> public fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'LinkedHashMap' @ [550:50] ==> public constructor LinkedHashMap<K, V>(original: Map<out K, V>) defined in kotlin.collections.LinkedHashMap[ClassConstructorDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'this' @ [550:70] ==> <this> defined in kotlin.collections.plus[ReceiverParameterDescriptorImpl]

'apply' @ [550:76] ==> @InlineOnly public inline fun <T> LinkedHashMap<K, V>.apply(block: LinkedHashMap<K, V>.() -> Unit): LinkedHashMap<K, V> defined in kotlin[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> LinkedHashMap<K, V>

'putAll' @ [550:84] ==> public fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'pairs' @ [550:91] ==> value-parameter pairs: Iterable<Pair<K, V>> defined in kotlin.collections.plus[ValueParameterDescriptorImpl]

'if (this.isEmpty()) pairs.toMap() else LinkedHashMap<K, V>(this).apply { putAll(pairs) }' @ [559:11] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Map<K, V>, elseBranch: Map<K, V>): Map<K, V>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Map<K, V>

'this' @ [559:15] ==> <this> defined in kotlin.collections.plus[ReceiverParameterDescriptorImpl]

'isEmpty' @ [559:20] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.Map[SimpleFunctionDescriptorImpl]

'pairs' @ [559:31] ==> value-parameter pairs: Array<out Pair<K, V>> defined in kotlin.collections.plus[ValueParameterDescriptorImpl]

'toMap' @ [559:37] ==> public fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'LinkedHashMap' @ [559:50] ==> public constructor LinkedHashMap<K, V>(original: Map<out K, V>) defined in kotlin.collections.LinkedHashMap[ClassConstructorDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'this' @ [559:70] ==> <this> defined in kotlin.collections.plus[ReceiverParameterDescriptorImpl]

'apply' @ [559:76] ==> @InlineOnly public inline fun <T> LinkedHashMap<K, V>.apply(block: LinkedHashMap<K, V>.() -> Unit): LinkedHashMap<K, V> defined in kotlin[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> LinkedHashMap<K, V>

'putAll' @ [559:84] ==> public fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'pairs' @ [559:91] ==> value-parameter pairs: Array<out Pair<K, V>> defined in kotlin.collections.plus[ValueParameterDescriptorImpl]

'LinkedHashMap' @ [568:11] ==> public constructor LinkedHashMap<K, V>(original: Map<out K, V>) defined in kotlin.collections.LinkedHashMap[ClassConstructorDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'this' @ [568:31] ==> <this> defined in kotlin.collections.plus[ReceiverParameterDescriptorImpl]

'apply' @ [568:37] ==> @InlineOnly public inline fun <T> LinkedHashMap<K, V>.apply(block: LinkedHashMap<K, V>.() -> Unit): LinkedHashMap<K, V> defined in kotlin[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> LinkedHashMap<K, V>

'putAll' @ [568:45] ==> public fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'pairs' @ [568:52] ==> value-parameter pairs: Sequence<Pair<K, V>> defined in kotlin.collections.plus[ValueParameterDescriptorImpl]

'optimizeReadOnlyMap' @ [568:61] ==> internal fun <K, V> Map<K, V>.optimizeReadOnlyMap(): Map<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'LinkedHashMap' @ [577:11] ==> public constructor LinkedHashMap<K, V>(original: Map<out K, V>) defined in kotlin.collections.LinkedHashMap[ClassConstructorDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'this' @ [577:31] ==> <this> defined in kotlin.collections.plus[ReceiverParameterDescriptorImpl]

'apply' @ [577:37] ==> @InlineOnly public inline fun <T> LinkedHashMap<K, V>.apply(block: LinkedHashMap<K, V>.() -> Unit): LinkedHashMap<K, V> defined in kotlin[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> LinkedHashMap<K, V>

'putAll' @ [577:45] ==> public open fun putAll(from: Map<out K, V>): Unit defined in kotlin.collections.LinkedHashMap[SimpleFunctionDescriptorImpl]

'map' @ [577:52] ==> value-parameter map: Map<out K, V> defined in kotlin.collections.plus[ValueParameterDescriptorImpl]

'kotlin.internal.InlineOnly' @ [583:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'put' @ [585:5] ==> public abstract fun put(key: K, value: V): Any? defined in kotlin.collections.MutableMap[SimpleFunctionDescriptorImpl]

'pair' @ [585:9] ==> value-parameter pair: Pair<K, V> defined in kotlin.collections.plusAssign[ValueParameterDescriptorImpl]

'first' @ [585:14] ==> public final val first: K defined in kotlin.Pair[PropertyDescriptorImpl]

'pair' @ [585:21] ==> value-parameter pair: Pair<K, V> defined in kotlin.collections.plusAssign[ValueParameterDescriptorImpl]

'second' @ [585:26] ==> public final val second: V defined in kotlin.Pair[PropertyDescriptorImpl]

'kotlin.internal.InlineOnly' @ [591:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'putAll' @ [593:5] ==> public fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'pairs' @ [593:12] ==> value-parameter pairs: Iterable<Pair<K, V>> defined in kotlin.collections.plusAssign[ValueParameterDescriptorImpl]

'kotlin.internal.InlineOnly' @ [599:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'putAll' @ [601:5] ==> public fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'pairs' @ [601:12] ==> value-parameter pairs: Array<out Pair<K, V>> defined in kotlin.collections.plusAssign[ValueParameterDescriptorImpl]

'kotlin.internal.InlineOnly' @ [607:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'putAll' @ [609:5] ==> public fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'pairs' @ [609:12] ==> value-parameter pairs: Sequence<Pair<K, V>> defined in kotlin.collections.plusAssign[ValueParameterDescriptorImpl]

'kotlin.internal.InlineOnly' @ [615:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'putAll' @ [617:5] ==> public abstract fun putAll(from: Map<out K, V>): Unit defined in kotlin.collections.MutableMap[SimpleFunctionDescriptorImpl]

'map' @ [617:12] ==> value-parameter map: Map<K, V> defined in kotlin.collections.plusAssign[ValueParameterDescriptorImpl]

'SinceKotlin' @ [625:1] ==> public constructor SinceKotlin(version: String) defined in kotlin.SinceKotlin[DeserializedClassConstructorDescriptor]

'this' @ [627:11] ==> <this> defined in kotlin.collections.minus[ReceiverParameterDescriptorImpl]

'toMutableMap' @ [627:16] ==> @SinceKotlin public fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'apply' @ [627:31] ==> @InlineOnly public inline fun <T> MutableMap<K, V>.apply(block: MutableMap<K, V>.() -> Unit): MutableMap<K, V> defined in kotlin[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> MutableMap<K, V>

'minusAssign' @ [627:39] ==> @SinceKotlin @InlineOnly public operator inline fun <K, V> MutableMap<K, V>.minusAssign(key: K): Unit defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'key' @ [627:51] ==> value-parameter key: K defined in kotlin.collections.minus[ValueParameterDescriptorImpl]

'optimizeReadOnlyMap' @ [627:58] ==> internal fun <K, V> Map<K, V>.optimizeReadOnlyMap(): Map<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'SinceKotlin' @ [635:1] ==> public constructor SinceKotlin(version: String) defined in kotlin.SinceKotlin[DeserializedClassConstructorDescriptor]

'this' @ [637:11] ==> <this> defined in kotlin.collections.minus[ReceiverParameterDescriptorImpl]

'toMutableMap' @ [637:16] ==> @SinceKotlin public fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'apply' @ [637:31] ==> @InlineOnly public inline fun <T> MutableMap<K, V>.apply(block: MutableMap<K, V>.() -> Unit): MutableMap<K, V> defined in kotlin[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> MutableMap<K, V>

'minusAssign' @ [637:39] ==> @SinceKotlin @InlineOnly public operator inline fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>): Unit defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'keys' @ [637:51] ==> value-parameter keys: Iterable<K> defined in kotlin.collections.minus[ValueParameterDescriptorImpl]

'optimizeReadOnlyMap' @ [637:59] ==> internal fun <K, V> Map<K, V>.optimizeReadOnlyMap(): Map<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'SinceKotlin' @ [645:1] ==> public constructor SinceKotlin(version: String) defined in kotlin.SinceKotlin[DeserializedClassConstructorDescriptor]

'this' @ [647:11] ==> <this> defined in kotlin.collections.minus[ReceiverParameterDescriptorImpl]

'toMutableMap' @ [647:16] ==> @SinceKotlin public fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'apply' @ [647:31] ==> @InlineOnly public inline fun <T> MutableMap<K, V>.apply(block: MutableMap<K, V>.() -> Unit): MutableMap<K, V> defined in kotlin[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> MutableMap<K, V>

'minusAssign' @ [647:39] ==> @SinceKotlin @InlineOnly public operator inline fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>): Unit defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'keys' @ [647:51] ==> value-parameter keys: Array<out K> defined in kotlin.collections.minus[ValueParameterDescriptorImpl]

'optimizeReadOnlyMap' @ [647:59] ==> internal fun <K, V> Map<K, V>.optimizeReadOnlyMap(): Map<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'SinceKotlin' @ [655:1] ==> public constructor SinceKotlin(version: String) defined in kotlin.SinceKotlin[DeserializedClassConstructorDescriptor]

'this' @ [657:11] ==> <this> defined in kotlin.collections.minus[ReceiverParameterDescriptorImpl]

'toMutableMap' @ [657:16] ==> @SinceKotlin public fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'apply' @ [657:31] ==> @InlineOnly public inline fun <T> MutableMap<K, V>.apply(block: MutableMap<K, V>.() -> Unit): MutableMap<K, V> defined in kotlin[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> MutableMap<K, V>

'minusAssign' @ [657:39] ==> @SinceKotlin @InlineOnly public operator inline fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>): Unit defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'keys' @ [657:51] ==> value-parameter keys: Sequence<K> defined in kotlin.collections.minus[ValueParameterDescriptorImpl]

'optimizeReadOnlyMap' @ [657:59] ==> internal fun <K, V> Map<K, V>.optimizeReadOnlyMap(): Map<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'SinceKotlin' @ [662:1] ==> public constructor SinceKotlin(version: String) defined in kotlin.SinceKotlin[DeserializedClassConstructorDescriptor]

'kotlin.internal.InlineOnly' @ [663:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'remove' @ [665:5] ==> public abstract fun remove(key: K): V? defined in kotlin.collections.MutableMap[SimpleFunctionDescriptorImpl]

'key' @ [665:12] ==> value-parameter key: K defined in kotlin.collections.minusAssign[ValueParameterDescriptorImpl]

'SinceKotlin' @ [671:1] ==> public constructor SinceKotlin(version: String) defined in kotlin.SinceKotlin[DeserializedClassConstructorDescriptor]

'kotlin.internal.InlineOnly' @ [672:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'this' @ [674:5] ==> <this> defined in kotlin.collections.minusAssign[ReceiverParameterDescriptorImpl]

'keys' @ [674:10] ==> public abstract val keys: MutableSet<K> defined in kotlin.collections.MutableMap[PropertyDescriptorImpl]

'removeAll' @ [674:15] ==> public fun <T> MutableCollection<in K>.removeAll(elements: Iterable<K>): Boolean defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> K

'keys' @ [674:25] ==> value-parameter keys: Iterable<K> defined in kotlin.collections.minusAssign[ValueParameterDescriptorImpl]

'SinceKotlin' @ [680:1] ==> public constructor SinceKotlin(version: String) defined in kotlin.SinceKotlin[DeserializedClassConstructorDescriptor]

'kotlin.internal.InlineOnly' @ [681:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'this' @ [683:5] ==> <this> defined in kotlin.collections.minusAssign[ReceiverParameterDescriptorImpl]

'keys' @ [683:10] ==> public abstract val keys: MutableSet<K> defined in kotlin.collections.MutableMap[PropertyDescriptorImpl]

'removeAll' @ [683:15] ==> public fun <T> MutableCollection<in K>.removeAll(elements: Array<out K>): Boolean defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> K

'keys' @ [683:25] ==> value-parameter keys: Array<out K> defined in kotlin.collections.minusAssign[ValueParameterDescriptorImpl]

'SinceKotlin' @ [689:1] ==> public constructor SinceKotlin(version: String) defined in kotlin.SinceKotlin[DeserializedClassConstructorDescriptor]

'kotlin.internal.InlineOnly' @ [690:1] ==> public constructor InlineOnly() defined in kotlin.internal.InlineOnly[ClassConstructorDescriptorImpl]

'this' @ [692:5] ==> <this> defined in kotlin.collections.minusAssign[ReceiverParameterDescriptorImpl]

'keys' @ [692:10] ==> public abstract val keys: MutableSet<K> defined in kotlin.collections.MutableMap[PropertyDescriptorImpl]

'removeAll' @ [692:15] ==> public fun <T> MutableCollection<in K>.removeAll(elements: Sequence<K>): Boolean defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <T> -> K

'keys' @ [692:25] ==> value-parameter keys: Sequence<K> defined in kotlin.collections.minusAssign[ValueParameterDescriptorImpl]

'when (size) {
    0 -> emptyMap()
    1 -> toSingletonMapOrSelf()
    else -> this
}' @ [697:55] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Map<K, V>, entry1: Map<K, V>, entry2: Map<K, V>): Map<K, V>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Map<K, V>

'size' @ [697:61] ==> public abstract val size: Int defined in kotlin.collections.Map[PropertyDescriptorImpl]

'emptyMap' @ [698:10] ==> public fun <K, V> emptyMap(): Map<K, V> defined in kotlin.collections[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'toSingletonMapOrSelf' @ [699:10] ==> internal inline fun <K, V> Map<K, V>.toSingletonMapOrSelf(): Map<K, V> defined in kotlin[SimpleFunctionDescriptorImpl]
Inferred types:
    <K> -> K
    <V> -> V

'this' @ [700:13] ==> <this> defined in kotlin.collections.optimizeReadOnlyMap[ReceiverParameterDescriptorImpl]

