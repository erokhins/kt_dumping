'JvmFunctionSignature' @ [53:51] ==> private constructor JvmFunctionSignature() defined in kotlin.reflect.jvm.internal.JvmFunctionSignature[ClassConstructorDescriptorImpl]

'signature' @ [54:40] ==> public final val signature: String defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.KotlinFunction[PropertyDescriptorImpl]

'substringBefore' @ [54:50] ==> public fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = ...): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'signature' @ [55:40] ==> public final val signature: String defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.KotlinFunction[PropertyDescriptorImpl]

'substring' @ [55:50] ==> @InlineOnly public inline fun String.substring(startIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'signature' @ [55:60] ==> public final val signature: String defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.KotlinFunction[PropertyDescriptorImpl]

'indexOf' @ [55:70] ==> public fun CharSequence.indexOf(char: Char, startIndex: Int = ..., ignoreCase: Boolean = ...): Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'signature' @ [57:43] ==> public final val signature: String defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.KotlinFunction[PropertyDescriptorImpl]

'JvmFunctionSignature' @ [60:54] ==> private constructor JvmFunctionSignature() defined in kotlin.reflect.jvm.internal.JvmFunctionSignature[ClassConstructorDescriptorImpl]

'signature' @ [61:45] ==> public final val signature: String defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.KotlinConstructor[PropertyDescriptorImpl]

'substring' @ [61:55] ==> @InlineOnly public inline fun String.substring(startIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'signature' @ [61:65] ==> public final val signature: String defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.KotlinConstructor[PropertyDescriptorImpl]

'indexOf' @ [61:75] ==> public fun CharSequence.indexOf(char: Char, startIndex: Int = ..., ignoreCase: Boolean = ...): Int defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'signature' @ [63:43] ==> public final val signature: String defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.KotlinConstructor[PropertyDescriptorImpl]

'JvmFunctionSignature' @ [66:44] ==> private constructor JvmFunctionSignature() defined in kotlin.reflect.jvm.internal.JvmFunctionSignature[ClassConstructorDescriptorImpl]

'method' @ [67:43] ==> public final val method: Method defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.JavaMethod[PropertyDescriptorImpl]

'signature' @ [67:50] ==> private val Method.signature: String defined in kotlin.reflect.jvm.internal in file RuntimeTypeMapper.kt[PropertyDescriptorImpl]

'JvmFunctionSignature' @ [70:62] ==> private constructor JvmFunctionSignature() defined in kotlin.reflect.jvm.internal.JvmFunctionSignature[ClassConstructorDescriptorImpl]

'constructor' @ [72:17] ==> public final val constructor: Constructor<*> defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.JavaConstructor[PropertyDescriptorImpl]

'parameterTypes' @ [72:29] ==> public final val <T : (Any..Any?)> Constructor<out (Any..Any?)>.parameterTypes: (Array<(Class<*>..Class<*>?)>..Array<out (Class<*>..Class<*>?)>?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Captured(*)

'joinToString' @ [72:44] ==> public fun <T> Array<out (Class<*>..Class<*>?)>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: (((Class<*>..Class<*>?)) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (java.lang.Class<*>..java.lang.Class<*>?)

'it' @ [72:111] ==> value-parameter it: (Class<*>..Class<*>?) defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.JavaConstructor.asString.<anonymous>[ValueParameterDescriptorImpl]

'desc' @ [72:114] ==> public val Class<*>.desc: String defined in org.jetbrains.kotlin.load.java.structure.reflect in file reflectClassUtil.kt[PropertyDescriptorImpl]

'JvmFunctionSignature' @ [75:65] ==> private constructor JvmFunctionSignature() defined in kotlin.reflect.jvm.internal.JvmFunctionSignature[ClassConstructorDescriptorImpl]

'jClass' @ [77:23] ==> public final val jClass: Class<*> defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.FakeJavaAnnotationConstructor[PropertyDescriptorImpl]

'declaredMethods' @ [77:30] ==> public final val <T : (Any..Any?)> Class<out (Any..Any?)>.declaredMethods: (Array<(Method..Method?)>..Array<out (Method..Method?)>?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Captured(*)

'sortedBy' @ [77:46] ==> public inline fun <T, R : Comparable<String>> Array<out (Method..Method?)>.sortedBy(crossinline selector: ((Method..Method?)) -> String?): List<(Method..Method?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (java.lang.reflect.Method..java.lang.reflect.Method?)
    <R : Comparable<R>> -> String

'it' @ [77:57] ==> value-parameter it: (Method..Method?) defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.FakeJavaAnnotationConstructor.methods.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [77:60] ==> public final val Method.name: (String..String?)[MyPropertyDescriptor]

'methods' @ [80:17] ==> public final val methods: List<(Method..Method?)> defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.FakeJavaAnnotationConstructor[PropertyDescriptorImpl]

'joinToString' @ [80:25] ==> public fun <T> Iterable<(Method..Method?)>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: (((Method..Method?)) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (java.lang.reflect.Method..java.lang.reflect.Method?)

'it' @ [80:92] ==> value-parameter it: (Method..Method?) defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.FakeJavaAnnotationConstructor.asString.<anonymous>[ValueParameterDescriptorImpl]

'returnType' @ [80:95] ==> public final val Method.returnType: (Class<*>..Class<*>?)[MyPropertyDescriptor]

'desc' @ [80:106] ==> public val Class<*>.desc: String defined in org.jetbrains.kotlin.load.java.structure.reflect in file reflectClassUtil.kt[PropertyDescriptorImpl]

'JvmFunctionSignature' @ [83:65] ==> private constructor JvmFunctionSignature() defined in kotlin.reflect.jvm.internal.JvmFunctionSignature[ClassConstructorDescriptorImpl]

'signature' @ [86:43] ==> private final val signature: String defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.BuiltInFunction[PropertyDescriptorImpl]

'BuiltInFunction' @ [88:74] ==> public constructor BuiltInFunction(signature: String) defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.BuiltInFunction[ClassConstructorDescriptorImpl]

'signature' @ [88:90] ==> value-parameter signature: String defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.BuiltInFunction.Predefined.<init>[ValueParameterDescriptorImpl]

'member' @ [89:84] ==> private final val member: Member defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.BuiltInFunction.Predefined[PropertyDescriptorImpl]

'JvmPropertySignature' @ [107:9] ==> private constructor JvmPropertySignature() defined in kotlin.reflect.jvm.internal.JvmPropertySignature[ClassConstructorDescriptorImpl]

'if (signature.hasGetter()) {
            nameResolver.getString(signature.getter.name) + nameResolver.getString(signature.getter.desc)
        }
        else {
            val (name, desc) =
                    JvmProtoBufUtil.getJvmFieldSignature(proto, nameResolver, typeTable) ?:
                    throw KotlinReflectionInternalError("No field signature for property: $descriptor")
            JvmAbi.getterName(name) + getManglingSuffix() + "()" + desc
        }' @ [108:38] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'signature' @ [108:42] ==> public final val signature: JvmProtoBuf.JvmPropertySignature defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty[PropertyDescriptorImpl]

'hasGetter' @ [108:52] ==> public open fun hasGetter(): Boolean defined in org.jetbrains.kotlin.serialization.jvm.JvmProtoBuf.JvmPropertySignature[JavaMethodDescriptor]

'nameResolver' @ [109:13] ==> public final val nameResolver: NameResolver defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty[PropertyDescriptorImpl]

'getString' @ [109:26] ==> @NotNull public abstract fun getString(index: Int): String defined in org.jetbrains.kotlin.serialization.deserialization.NameResolver[JavaMethodDescriptor]

'signature' @ [109:36] ==> public final val signature: JvmProtoBuf.JvmPropertySignature defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty[PropertyDescriptorImpl]

'getter' @ [109:46] ==> public final val JvmProtoBuf.JvmPropertySignature.getter: (JvmProtoBuf.JvmMethodSignature..JvmProtoBuf.JvmMethodSignature?)[MyPropertyDescriptor]

'name' @ [109:53] ==> public final val JvmProtoBuf.JvmMethodSignature.name: Int[MyPropertyDescriptor]

'nameResolver' @ [109:61] ==> public final val nameResolver: NameResolver defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty[PropertyDescriptorImpl]

'getString' @ [109:74] ==> @NotNull public abstract fun getString(index: Int): String defined in org.jetbrains.kotlin.serialization.deserialization.NameResolver[JavaMethodDescriptor]

'signature' @ [109:84] ==> public final val signature: JvmProtoBuf.JvmPropertySignature defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty[PropertyDescriptorImpl]

'getter' @ [109:94] ==> public final val JvmProtoBuf.JvmPropertySignature.getter: (JvmProtoBuf.JvmMethodSignature..JvmProtoBuf.JvmMethodSignature?)[MyPropertyDescriptor]

'desc' @ [109:101] ==> public final val JvmProtoBuf.JvmMethodSignature.desc: Int[MyPropertyDescriptor]

'component1' @ [112:18] ==> public final operator fun component1(): String defined in org.jetbrains.kotlin.serialization.jvm.JvmProtoBufUtil.PropertySignature[SimpleFunctionDescriptorImpl]

'component2' @ [112:24] ==> public final operator fun component2(): String defined in org.jetbrains.kotlin.serialization.jvm.JvmProtoBufUtil.PropertySignature[SimpleFunctionDescriptorImpl]

'?:' @ [113:21] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: JvmProtoBufUtil.PropertySignature?, right: JvmProtoBufUtil.PropertySignature): JvmProtoBufUtil.PropertySignature[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> PropertySignature

'getJvmFieldSignature' @ [113:37] ==> public final fun getJvmFieldSignature(proto: ProtoBuf.Property, nameResolver: NameResolver, typeTable: TypeTable): JvmProtoBufUtil.PropertySignature? defined in org.jetbrains.kotlin.serialization.jvm.JvmProtoBufUtil[SimpleFunctionDescriptorImpl]

'proto' @ [113:58] ==> public final val proto: ProtoBuf.Property defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty[PropertyDescriptorImpl]

'nameResolver' @ [113:65] ==> public final val nameResolver: NameResolver defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty[PropertyDescriptorImpl]

'typeTable' @ [113:79] ==> public final val typeTable: TypeTable defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty[PropertyDescriptorImpl]

'KotlinReflectionInternalError' @ [114:27] ==> public constructor KotlinReflectionInternalError(message: String) defined in kotlin.reflect.jvm.internal.KotlinReflectionInternalError[ClassConstructorDescriptorImpl]

'descriptor' @ [114:92] ==> public final val descriptor: PropertyDescriptor defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty[PropertyDescriptorImpl]

'+' @ [115:13] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'getterName' @ [115:20] ==> @NotNull public open fun getterName(@NotNull propertyName: String): String defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaMethodDescriptor]

'name' @ [115:31] ==> val name: String defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty.string[LocalVariableDescriptor]

'getManglingSuffix' @ [115:39] ==> private final fun getManglingSuffix(): String defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty[SimpleFunctionDescriptorImpl]

'desc' @ [115:68] ==> val desc: String defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty.string[LocalVariableDescriptor]

'descriptor' @ [119:41] ==> public final val descriptor: PropertyDescriptor defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty[PropertyDescriptorImpl]

'containingDeclaration' @ [119:52] ==> public final val PropertyDescriptor.containingDeclaration: DeclarationDescriptor[MyPropertyDescriptor]

'descriptor' @ [120:17] ==> public final val descriptor: PropertyDescriptor defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty[PropertyDescriptorImpl]

'visibility' @ [120:28] ==> public final val PropertyDescriptor.visibility: Visibility[MyPropertyDescriptor]

'INTERNAL' @ [120:55] ==> @NotNull public final val INTERNAL: Visibility defined in org.jetbrains.kotlin.descriptors.Visibilities[JavaPropertyDescriptor]

'containingDeclaration' @ [120:67] ==> val containingDeclaration: DeclarationDescriptor defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty.getManglingSuffix[LocalVariableDescriptor]

'containingDeclaration' @ [121:34] ==> val containingDeclaration: DeclarationDescriptor defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty.getManglingSuffix[LocalVariableDescriptor]

'classProto' @ [121:56] ==> public final val classProto: ProtoBuf.Class defined in org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedClassDescriptor[PropertyDescriptorImpl]

'if (classProto.hasExtension(JvmProtoBuf.classModuleName))
                            nameResolver.getString(classProto.getExtension(JvmProtoBuf.classModuleName))
                        else JvmAbi.DEFAULT_MODULE_NAME' @ [123:25] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'classProto' @ [123:29] ==> val classProto: ProtoBuf.Class defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty.getManglingSuffix[LocalVariableDescriptor]

'hasExtension' @ [123:40] ==> public final fun <Type : (Any..Any?)> hasExtension(p0: (GeneratedMessageLite.GeneratedExtension<(ProtoBuf.Class..ProtoBuf.Class?), (Int..Int?)>..GeneratedMessageLite.GeneratedExtension<(ProtoBuf.Class..ProtoBuf.Class?), (Int..Int?)>?)): Boolean defined in org.jetbrains.kotlin.serialization.ProtoBuf.Class[JavaMethodDescriptor]
Inferred types:
    <Type : (Any..Any?)> -> (kotlin.Int..kotlin.Int?)

'classModuleName' @ [123:65] ==> public final val classModuleName: (GeneratedMessageLite.GeneratedExtension<(ProtoBuf.Class..ProtoBuf.Class?), (Int..Int?)>..GeneratedMessageLite.GeneratedExtension<(ProtoBuf.Class..ProtoBuf.Class?), (Int..Int?)>?) defined in org.jetbrains.kotlin.serialization.jvm.JvmProtoBuf[JavaPropertyDescriptor]

'nameResolver' @ [124:29] ==> public final val nameResolver: NameResolver defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty[PropertyDescriptorImpl]

'getString' @ [124:42] ==> @NotNull public abstract fun getString(index: Int): String defined in org.jetbrains.kotlin.serialization.deserialization.NameResolver[JavaMethodDescriptor]

'classProto' @ [124:52] ==> val classProto: ProtoBuf.Class defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty.getManglingSuffix[LocalVariableDescriptor]

'getExtension' @ [124:63] ==> public final fun <Type : (Any..Any?)> getExtension(p0: (GeneratedMessageLite.GeneratedExtension<(ProtoBuf.Class..ProtoBuf.Class?), (Int..Int?)>..GeneratedMessageLite.GeneratedExtension<(ProtoBuf.Class..ProtoBuf.Class?), (Int..Int?)>?)): (Int..Int?) defined in org.jetbrains.kotlin.serialization.ProtoBuf.Class[JavaMethodDescriptor]
Inferred types:
    <Type : (Any..Any?)> -> (kotlin.Int..kotlin.Int?)

'classModuleName' @ [124:88] ==> public final val classModuleName: (GeneratedMessageLite.GeneratedExtension<(ProtoBuf.Class..ProtoBuf.Class?), (Int..Int?)>..GeneratedMessageLite.GeneratedExtension<(ProtoBuf.Class..ProtoBuf.Class?), (Int..Int?)>?) defined in org.jetbrains.kotlin.serialization.jvm.JvmProtoBuf[JavaPropertyDescriptor]

'DEFAULT_MODULE_NAME' @ [125:37] ==> public const final val DEFAULT_MODULE_NAME: String defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaPropertyDescriptor]

'+' @ [126:24] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'sanitizeAsJavaIdentifier' @ [126:40] ==> @JvmStatic public final fun sanitizeAsJavaIdentifier(name: String): String defined in org.jetbrains.kotlin.name.NameUtils[SimpleFunctionDescriptorImpl]

'moduleName' @ [126:65] ==> val moduleName: String defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty.getManglingSuffix[LocalVariableDescriptor]

'descriptor' @ [128:17] ==> public final val descriptor: PropertyDescriptor defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty[PropertyDescriptorImpl]

'visibility' @ [128:28] ==> public final val PropertyDescriptor.visibility: Visibility[MyPropertyDescriptor]

'PRIVATE' @ [128:55] ==> @NotNull public final val PRIVATE: Visibility defined in org.jetbrains.kotlin.descriptors.Visibilities[JavaPropertyDescriptor]

'containingDeclaration' @ [128:66] ==> val containingDeclaration: DeclarationDescriptor defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty.getManglingSuffix[LocalVariableDescriptor]

'descriptor' @ [129:42] ==> public final val descriptor: PropertyDescriptor defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty[PropertyDescriptorImpl]

'containerSource' @ [129:88] ==> public open val containerSource: DeserializedContainerSource? defined in org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedPropertyDescriptor[PropertyDescriptorImpl]

'packagePartSource' @ [130:21] ==> val packagePartSource: DeserializedContainerSource? defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty.getManglingSuffix[LocalVariableDescriptor]

'packagePartSource' @ [130:66] ==> val packagePartSource: DeserializedContainerSource? defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty.getManglingSuffix[LocalVariableDescriptor]

'facadeClassName' @ [130:84] ==> public final val facadeClassName: JvmClassName? defined in org.jetbrains.kotlin.load.kotlin.JvmPackagePartSource[PropertyDescriptorImpl]

'+' @ [131:28] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'packagePartSource' @ [131:34] ==> val packagePartSource: DeserializedContainerSource? defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty.getManglingSuffix[LocalVariableDescriptor]

'simpleName' @ [131:52] ==> public final val simpleName: Name defined in org.jetbrains.kotlin.load.kotlin.JvmPackagePartSource[PropertyDescriptorImpl]

'asString' @ [131:63] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'string' @ [138:43] ==> private final val string: String defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty[PropertyDescriptorImpl]

'JvmPropertySignature' @ [141:85] ==> private constructor JvmPropertySignature() defined in kotlin.reflect.jvm.internal.JvmPropertySignature[ClassConstructorDescriptorImpl]

'getterMethod' @ [142:43] ==> public final val getterMethod: Method defined in kotlin.reflect.jvm.internal.JvmPropertySignature.JavaMethodProperty[PropertyDescriptorImpl]

'signature' @ [142:56] ==> private val Method.signature: String defined in kotlin.reflect.jvm.internal in file RuntimeTypeMapper.kt[PropertyDescriptorImpl]

'JvmPropertySignature' @ [145:41] ==> private constructor JvmPropertySignature() defined in kotlin.reflect.jvm.internal.JvmPropertySignature[ClassConstructorDescriptorImpl]

'+' @ [147:17] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'getterName' @ [147:24] ==> @NotNull public open fun getterName(@NotNull propertyName: String): String defined in org.jetbrains.kotlin.load.java.JvmAbi[JavaMethodDescriptor]

'field' @ [147:35] ==> public final val field: Field defined in kotlin.reflect.jvm.internal.JvmPropertySignature.JavaField[PropertyDescriptorImpl]

'name' @ [147:41] ==> public final val Field.name: (String..String?)[MyPropertyDescriptor]

'field' @ [149:17] ==> public final val field: Field defined in kotlin.reflect.jvm.internal.JvmPropertySignature.JavaField[PropertyDescriptorImpl]

'type' @ [149:23] ==> public final val Field.type: (Class<*>..Class<*>?)[MyPropertyDescriptor]

'desc' @ [149:28] ==> public val Class<*>.desc: String defined in org.jetbrains.kotlin.load.java.structure.reflect in file reflectClassUtil.kt[PropertyDescriptorImpl]

'name' @ [154:13] ==> public final val Method.name: (String..String?)[MyPropertyDescriptor]

'parameterTypes' @ [155:13] ==> public final val Method.parameterTypes: (Array<(Class<*>..Class<*>?)>..Array<out (Class<*>..Class<*>?)>?)[MyPropertyDescriptor]

'joinToString' @ [155:28] ==> public fun <T> Array<out (Class<*>..Class<*>?)>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: (((Class<*>..Class<*>?)) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (java.lang.Class<*>..java.lang.Class<*>?)

'it' @ [155:88] ==> value-parameter it: (Class<*>..Class<*>?) defined in kotlin.reflect.jvm.internal.<get-signature>.<anonymous>[ValueParameterDescriptorImpl]

'desc' @ [155:91] ==> public val Class<*>.desc: String defined in org.jetbrains.kotlin.load.java.structure.reflect in file reflectClassUtil.kt[PropertyDescriptorImpl]

'returnType' @ [156:13] ==> public final val Method.returnType: (Class<*>..Class<*>?)[MyPropertyDescriptor]

'desc' @ [156:24] ==> public val Class<*>.desc: String defined in org.jetbrains.kotlin.load.java.structure.reflect in file reflectClassUtil.kt[PropertyDescriptorImpl]

'unwrapFakeOverride' @ [162:40] ==> @NotNull @SuppressWarnings public open fun <D : (CallableMemberDescriptor..CallableMemberDescriptor?)> unwrapFakeOverride(@NotNull descriptor: FunctionDescriptor): FunctionDescriptor defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]
Inferred types:
    <D : (CallableMemberDescriptor..CallableMemberDescriptor?)> -> FunctionDescriptor

'possiblySubstitutedFunction' @ [162:59] ==> value-parameter possiblySubstitutedFunction: FunctionDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[ValueParameterDescriptorImpl]

'original' @ [162:88] ==> public final val FunctionDescriptor.original: FunctionDescriptor[MyPropertyDescriptor]

'when (function) {
            is DeserializedCallableMemberDescriptor -> {
                mapIntrinsicFunctionSignature(function)?.let {
                    return it
                }

                val proto = function.proto
                if (proto is ProtoBuf.Function) {
                    JvmProtoBufUtil.getJvmMethodSignature(proto, function.nameResolver, function.typeTable)?.let { signature ->
                        return JvmFunctionSignature.KotlinFunction(signature)
                    }
                }
                if (proto is ProtoBuf.Constructor) {
                    JvmProtoBufUtil.getJvmConstructorSignature(proto, function.nameResolver, function.typeTable)?.let { signature ->
                        return JvmFunctionSignature.KotlinConstructor(signature)
                    }
                }
                // If it's a deserialized function but has no JVM signature, it must be from built-ins
                throw KotlinReflectionInternalError("Reflection on built-in Kotlin types is not yet fully supported. " +
                                                    "No metadata found for $function")
            }
            is JavaMethodDescriptor -> {
                val method = ((function.source as? JavaSourceElement)?.javaElement as? ReflectJavaMethod)?.member ?:
                             throw KotlinReflectionInternalError("Incorrect resolution sequence for Java method $function")

                return JvmFunctionSignature.JavaMethod(method)
            }
            is JavaClassConstructorDescriptor -> {
                val element = (function.source as? JavaSourceElement)?.javaElement
                return when {
                    element is ReflectJavaConstructor ->
                        JvmFunctionSignature.JavaConstructor(element.member)
                    element is ReflectJavaClass && element.isAnnotationType ->
                        JvmFunctionSignature.FakeJavaAnnotationConstructor(element.element)
                    else -> throw KotlinReflectionInternalError("Incorrect resolution sequence for Java constructor $function ($element)")
                }
            }
            else -> throw KotlinReflectionInternalError("Unknown origin of $function (${function.javaClass})")
        }' @ [164:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Nothing, entry1: Nothing, entry2: Nothing, entry3: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Nothing

'function' @ [164:15] ==> val function: FunctionDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'mapIntrinsicFunctionSignature' @ [166:17] ==> private final fun mapIntrinsicFunctionSignature(function: FunctionDescriptor): JvmFunctionSignature? defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper[SimpleFunctionDescriptorImpl]

'function' @ [166:47] ==> val function: FunctionDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'let' @ [166:58] ==> @InlineOnly public inline fun <T, R> JvmFunctionSignature.let(block: (JvmFunctionSignature) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JvmFunctionSignature
    <R> -> Nothing

'it' @ [167:28] ==> value-parameter it: JvmFunctionSignature defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature.<anonymous>[ValueParameterDescriptorImpl]

'function' @ [170:29] ==> val function: FunctionDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'proto' @ [170:38] ==> public abstract val proto: MessageLite defined in org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedCallableMemberDescriptor[PropertyDescriptorImpl]

'proto' @ [171:21] ==> val proto: MessageLite defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'JvmProtoBufUtil' @ [172:21] ==> public object JvmProtoBufUtil defined in org.jetbrains.kotlin.serialization.jvm in file JvmProtoBufUtil.kt[FakeCallableDescriptorForObject]

'getJvmMethodSignature' @ [172:37] ==> public final fun getJvmMethodSignature(proto: ProtoBuf.Function, nameResolver: NameResolver, typeTable: TypeTable): String? defined in org.jetbrains.kotlin.serialization.jvm.JvmProtoBufUtil[SimpleFunctionDescriptorImpl]

'proto' @ [172:59] ==> val proto: MessageLite defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'function' @ [172:66] ==> val function: FunctionDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'nameResolver' @ [172:75] ==> public abstract val nameResolver: NameResolver defined in org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedCallableMemberDescriptor[PropertyDescriptorImpl]

'function' @ [172:89] ==> val function: FunctionDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'typeTable' @ [172:98] ==> public abstract val typeTable: TypeTable defined in org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedCallableMemberDescriptor[PropertyDescriptorImpl]

'let' @ [172:110] ==> @InlineOnly public inline fun <T, R> String.let(block: (String) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String
    <R> -> Nothing

'KotlinFunction' @ [173:53] ==> public constructor KotlinFunction(signature: String) defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.KotlinFunction[ClassConstructorDescriptorImpl]

'signature' @ [173:68] ==> value-parameter signature: String defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature.<anonymous>[ValueParameterDescriptorImpl]

'proto' @ [176:21] ==> val proto: MessageLite defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'JvmProtoBufUtil' @ [177:21] ==> public object JvmProtoBufUtil defined in org.jetbrains.kotlin.serialization.jvm in file JvmProtoBufUtil.kt[FakeCallableDescriptorForObject]

'getJvmConstructorSignature' @ [177:37] ==> public final fun getJvmConstructorSignature(proto: ProtoBuf.Constructor, nameResolver: NameResolver, typeTable: TypeTable): String? defined in org.jetbrains.kotlin.serialization.jvm.JvmProtoBufUtil[SimpleFunctionDescriptorImpl]

'proto' @ [177:64] ==> val proto: MessageLite defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'function' @ [177:71] ==> val function: FunctionDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'nameResolver' @ [177:80] ==> public abstract val nameResolver: NameResolver defined in org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedCallableMemberDescriptor[PropertyDescriptorImpl]

'function' @ [177:94] ==> val function: FunctionDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'typeTable' @ [177:103] ==> public abstract val typeTable: TypeTable defined in org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedCallableMemberDescriptor[PropertyDescriptorImpl]

'let' @ [177:115] ==> @InlineOnly public inline fun <T, R> String.let(block: (String) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String
    <R> -> Nothing

'KotlinConstructor' @ [178:53] ==> public constructor KotlinConstructor(signature: String) defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.KotlinConstructor[ClassConstructorDescriptorImpl]

'signature' @ [178:71] ==> value-parameter signature: String defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature.<anonymous>[ValueParameterDescriptorImpl]

'KotlinReflectionInternalError' @ [182:23] ==> public constructor KotlinReflectionInternalError(message: String) defined in kotlin.reflect.jvm.internal.KotlinReflectionInternalError[ClassConstructorDescriptorImpl]

'+' @ [182:53] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'function' @ [183:77] ==> val function: FunctionDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'?:' @ [186:30] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: Method?, right: Method): Method[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> Method

'function' @ [186:32] ==> val function: FunctionDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'source' @ [186:41] ==> public final val JavaMethodDescriptor.source: SourceElement[MyPropertyDescriptor]

'javaElement' @ [186:72] ==> public abstract val javaElement: JavaElement defined in org.jetbrains.kotlin.load.java.sources.JavaSourceElement[PropertyDescriptorImpl]

'member' @ [186:108] ==> public open val member: Method defined in org.jetbrains.kotlin.load.java.structure.reflect.ReflectJavaMethod[PropertyDescriptorImpl]

'KotlinReflectionInternalError' @ [187:36] ==> public constructor KotlinReflectionInternalError(message: String) defined in kotlin.reflect.jvm.internal.KotlinReflectionInternalError[ClassConstructorDescriptorImpl]

'function' @ [187:114] ==> val function: FunctionDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'JavaMethod' @ [189:45] ==> public constructor JavaMethod(method: Method) defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.JavaMethod[ClassConstructorDescriptorImpl]

'method' @ [189:56] ==> val method: Method defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'function' @ [192:32] ==> val function: FunctionDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'source' @ [192:41] ==> public final val JavaClassConstructorDescriptor.source: SourceElement[MyPropertyDescriptor]

'javaElement' @ [192:72] ==> public abstract val javaElement: JavaElement defined in org.jetbrains.kotlin.load.java.sources.JavaSourceElement[PropertyDescriptorImpl]

'when {
                    element is ReflectJavaConstructor ->
                        JvmFunctionSignature.JavaConstructor(element.member)
                    element is ReflectJavaClass && element.isAnnotationType ->
                        JvmFunctionSignature.FakeJavaAnnotationConstructor(element.element)
                    else -> throw KotlinReflectionInternalError("Incorrect resolution sequence for Java constructor $function ($element)")
                }' @ [193:24] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: JvmFunctionSignature, entry1: JvmFunctionSignature, entry2: JvmFunctionSignature): JvmFunctionSignature[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> JvmFunctionSignature

'element' @ [194:21] ==> val element: JavaElement? defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'JavaConstructor' @ [195:46] ==> public constructor JavaConstructor(constructor: Constructor<*>) defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.JavaConstructor[ClassConstructorDescriptorImpl]

'element' @ [195:62] ==> val element: JavaElement? defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'member' @ [195:70] ==> public open val member: Constructor<*> defined in org.jetbrains.kotlin.load.java.structure.reflect.ReflectJavaConstructor[PropertyDescriptorImpl]

'element' @ [196:21] ==> val element: JavaElement? defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'element' @ [196:52] ==> val element: JavaElement? defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'isAnnotationType' @ [196:60] ==> public open val isAnnotationType: Boolean defined in org.jetbrains.kotlin.load.java.structure.reflect.ReflectJavaClass[PropertyDescriptorImpl]

'FakeJavaAnnotationConstructor' @ [197:46] ==> public constructor FakeJavaAnnotationConstructor(jClass: Class<*>) defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.FakeJavaAnnotationConstructor[ClassConstructorDescriptorImpl]

'element' @ [197:76] ==> val element: JavaElement? defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'element' @ [197:84] ==> public open val element: Class<*> defined in org.jetbrains.kotlin.load.java.structure.reflect.ReflectJavaClass[PropertyDescriptorImpl]

'KotlinReflectionInternalError' @ [198:35] ==> public constructor KotlinReflectionInternalError(message: String) defined in kotlin.reflect.jvm.internal.KotlinReflectionInternalError[ClassConstructorDescriptorImpl]

'function' @ [198:118] ==> val function: FunctionDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'element' @ [198:129] ==> val element: JavaElement? defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'KotlinReflectionInternalError' @ [201:27] ==> public constructor KotlinReflectionInternalError(message: String) defined in kotlin.reflect.jvm.internal.KotlinReflectionInternalError[ClassConstructorDescriptorImpl]

'function' @ [201:77] ==> val function: FunctionDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'function' @ [201:89] ==> val function: FunctionDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapSignature[LocalVariableDescriptor]

'javaClass' @ [201:98] ==> public val <T : Any> FunctionDescriptor.javaClass: Class<FunctionDescriptor> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> FunctionDescriptor

'unwrapFakeOverride' @ [206:40] ==> @NotNull @SuppressWarnings public open fun <D : (CallableMemberDescriptor..CallableMemberDescriptor?)> unwrapFakeOverride(@NotNull descriptor: PropertyDescriptor): PropertyDescriptor defined in org.jetbrains.kotlin.resolve.DescriptorUtils[JavaMethodDescriptor]
Inferred types:
    <D : (CallableMemberDescriptor..CallableMemberDescriptor?)> -> PropertyDescriptor

'possiblyOverriddenProperty' @ [206:59] ==> value-parameter possiblyOverriddenProperty: PropertyDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapPropertySignature[ValueParameterDescriptorImpl]

'original' @ [206:87] ==> public final val PropertyDescriptor.original: PropertyDescriptor[MyPropertyDescriptor]

'when (property) {
            is DeserializedPropertyDescriptor -> {
                val proto = property.proto
                if (!proto.hasExtension(JvmProtoBuf.propertySignature)) {
                    // If this property has no JVM signature, it must be from built-ins
                    throw KotlinReflectionInternalError("Reflection on built-in Kotlin types is not yet fully supported. " +
                                                        "No metadata found for $property")
                }
                JvmPropertySignature.KotlinProperty(
                        property, proto, proto.getExtension(JvmProtoBuf.propertySignature), property.nameResolver, property.typeTable
                )
            }
            is JavaPropertyDescriptor -> {
                val element = (property.source as? JavaSourceElement)?.javaElement
                when (element) {
                    is ReflectJavaField -> JvmPropertySignature.JavaField(element.member)
                    is ReflectJavaMethod -> JvmPropertySignature.JavaMethodProperty(
                            element.member,
                            ((property.setter?.source as? JavaSourceElement)?.javaElement as? ReflectJavaMethod)?.member
                    )
                    else -> throw KotlinReflectionInternalError("Incorrect resolution sequence for Java field $property (source = $element)")
                }
            }
            else -> {
                throw KotlinReflectionInternalError("Unknown origin of $property (${property.javaClass})")
            }
        }' @ [207:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: JvmPropertySignature, entry1: JvmPropertySignature, entry2: JvmPropertySignature): JvmPropertySignature[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> JvmPropertySignature

'property' @ [207:22] ==> val property: PropertyDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapPropertySignature[LocalVariableDescriptor]

'property' @ [209:29] ==> val property: PropertyDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapPropertySignature[LocalVariableDescriptor]

'proto' @ [209:38] ==> public open val proto: ProtoBuf.Property defined in org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedPropertyDescriptor[PropertyDescriptorImpl]

'!' @ [210:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'proto' @ [210:22] ==> val proto: ProtoBuf.Property defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapPropertySignature[LocalVariableDescriptor]

'hasExtension' @ [210:28] ==> public final fun <Type : (Any..Any?)> hasExtension(p0: (GeneratedMessageLite.GeneratedExtension<(ProtoBuf.Property..ProtoBuf.Property?), (JvmProtoBuf.JvmPropertySignature..JvmProtoBuf.JvmPropertySignature?)>..GeneratedMessageLite.GeneratedExtension<(ProtoBuf.Property..ProtoBuf.Property?), (JvmProtoBuf.JvmPropertySignature..JvmProtoBuf.JvmPropertySignature?)>?)): Boolean defined in org.jetbrains.kotlin.serialization.ProtoBuf.Property[JavaMethodDescriptor]
Inferred types:
    <Type : (Any..Any?)> -> (org.jetbrains.kotlin.serialization.jvm.JvmProtoBuf.JvmPropertySignature..org.jetbrains.kotlin.serialization.jvm.JvmProtoBuf.JvmPropertySignature?)

'propertySignature' @ [210:53] ==> public final val propertySignature: (GeneratedMessageLite.GeneratedExtension<(ProtoBuf.Property..ProtoBuf.Property?), (JvmProtoBuf.JvmPropertySignature..JvmProtoBuf.JvmPropertySignature?)>..GeneratedMessageLite.GeneratedExtension<(ProtoBuf.Property..ProtoBuf.Property?), (JvmProtoBuf.JvmPropertySignature..JvmProtoBuf.JvmPropertySignature?)>?) defined in org.jetbrains.kotlin.serialization.jvm.JvmProtoBuf[JavaPropertyDescriptor]

'KotlinReflectionInternalError' @ [212:27] ==> public constructor KotlinReflectionInternalError(message: String) defined in kotlin.reflect.jvm.internal.KotlinReflectionInternalError[ClassConstructorDescriptorImpl]

'+' @ [212:57] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'property' @ [213:81] ==> val property: PropertyDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapPropertySignature[LocalVariableDescriptor]

'KotlinProperty' @ [215:38] ==> public constructor KotlinProperty(descriptor: PropertyDescriptor, proto: ProtoBuf.Property, signature: JvmProtoBuf.JvmPropertySignature, nameResolver: NameResolver, typeTable: TypeTable) defined in kotlin.reflect.jvm.internal.JvmPropertySignature.KotlinProperty[ClassConstructorDescriptorImpl]

'property' @ [216:25] ==> val property: PropertyDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapPropertySignature[LocalVariableDescriptor]

'proto' @ [216:35] ==> val proto: ProtoBuf.Property defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapPropertySignature[LocalVariableDescriptor]

'proto' @ [216:42] ==> val proto: ProtoBuf.Property defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapPropertySignature[LocalVariableDescriptor]

'getExtension' @ [216:48] ==> public final fun <Type : (Any..Any?)> getExtension(p0: (GeneratedMessageLite.GeneratedExtension<(ProtoBuf.Property..ProtoBuf.Property?), (JvmProtoBuf.JvmPropertySignature..JvmProtoBuf.JvmPropertySignature?)>..GeneratedMessageLite.GeneratedExtension<(ProtoBuf.Property..ProtoBuf.Property?), (JvmProtoBuf.JvmPropertySignature..JvmProtoBuf.JvmPropertySignature?)>?)): (JvmProtoBuf.JvmPropertySignature..JvmProtoBuf.JvmPropertySignature?) defined in org.jetbrains.kotlin.serialization.ProtoBuf.Property[JavaMethodDescriptor]
Inferred types:
    <Type : (Any..Any?)> -> (org.jetbrains.kotlin.serialization.jvm.JvmProtoBuf.JvmPropertySignature..org.jetbrains.kotlin.serialization.jvm.JvmProtoBuf.JvmPropertySignature?)

'propertySignature' @ [216:73] ==> public final val propertySignature: (GeneratedMessageLite.GeneratedExtension<(ProtoBuf.Property..ProtoBuf.Property?), (JvmProtoBuf.JvmPropertySignature..JvmProtoBuf.JvmPropertySignature?)>..GeneratedMessageLite.GeneratedExtension<(ProtoBuf.Property..ProtoBuf.Property?), (JvmProtoBuf.JvmPropertySignature..JvmProtoBuf.JvmPropertySignature?)>?) defined in org.jetbrains.kotlin.serialization.jvm.JvmProtoBuf[JavaPropertyDescriptor]

'property' @ [216:93] ==> val property: PropertyDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapPropertySignature[LocalVariableDescriptor]

'nameResolver' @ [216:102] ==> public open val nameResolver: NameResolver defined in org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedPropertyDescriptor[PropertyDescriptorImpl]

'property' @ [216:116] ==> val property: PropertyDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapPropertySignature[LocalVariableDescriptor]

'typeTable' @ [216:125] ==> public open val typeTable: TypeTable defined in org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedPropertyDescriptor[PropertyDescriptorImpl]

'property' @ [220:32] ==> val property: PropertyDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapPropertySignature[LocalVariableDescriptor]

'source' @ [220:41] ==> public final val JavaPropertyDescriptor.source: SourceElement[MyPropertyDescriptor]

'javaElement' @ [220:72] ==> public abstract val javaElement: JavaElement defined in org.jetbrains.kotlin.load.java.sources.JavaSourceElement[PropertyDescriptorImpl]

'when (element) {
                    is ReflectJavaField -> JvmPropertySignature.JavaField(element.member)
                    is ReflectJavaMethod -> JvmPropertySignature.JavaMethodProperty(
                            element.member,
                            ((property.setter?.source as? JavaSourceElement)?.javaElement as? ReflectJavaMethod)?.member
                    )
                    else -> throw KotlinReflectionInternalError("Incorrect resolution sequence for Java field $property (source = $element)")
                }' @ [221:17] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: JvmPropertySignature, entry1: JvmPropertySignature, entry2: JvmPropertySignature): JvmPropertySignature[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> JvmPropertySignature

'element' @ [221:23] ==> val element: JavaElement? defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapPropertySignature[LocalVariableDescriptor]

'JavaField' @ [222:65] ==> public constructor JavaField(field: Field) defined in kotlin.reflect.jvm.internal.JvmPropertySignature.JavaField[ClassConstructorDescriptorImpl]

'element' @ [222:75] ==> val element: JavaElement? defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapPropertySignature[LocalVariableDescriptor]

'member' @ [222:83] ==> public open val member: Field defined in org.jetbrains.kotlin.load.java.structure.reflect.ReflectJavaField[PropertyDescriptorImpl]

'JavaMethodProperty' @ [223:66] ==> public constructor JavaMethodProperty(getterMethod: Method, setterMethod: Method?) defined in kotlin.reflect.jvm.internal.JvmPropertySignature.JavaMethodProperty[ClassConstructorDescriptorImpl]

'element' @ [224:29] ==> val element: JavaElement? defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapPropertySignature[LocalVariableDescriptor]

'member' @ [224:37] ==> public open val member: Method defined in org.jetbrains.kotlin.load.java.structure.reflect.ReflectJavaMethod[PropertyDescriptorImpl]

'property' @ [225:31] ==> val property: PropertyDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapPropertySignature[LocalVariableDescriptor]

'setter' @ [225:40] ==> public abstract val setter: PropertySetterDescriptor? defined in org.jetbrains.kotlin.descriptors.PropertyDescriptor[JavaPropertyDescriptor]

'source' @ [225:48] ==> public final val PropertySetterDescriptor.source: SourceElement[MyPropertyDescriptor]

'javaElement' @ [225:79] ==> public abstract val javaElement: JavaElement defined in org.jetbrains.kotlin.load.java.sources.JavaSourceElement[PropertyDescriptorImpl]

'member' @ [225:115] ==> public open val member: Method defined in org.jetbrains.kotlin.load.java.structure.reflect.ReflectJavaMethod[PropertyDescriptorImpl]

'KotlinReflectionInternalError' @ [227:35] ==> public constructor KotlinReflectionInternalError(message: String) defined in kotlin.reflect.jvm.internal.KotlinReflectionInternalError[ClassConstructorDescriptorImpl]

'property' @ [227:112] ==> val property: PropertyDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapPropertySignature[LocalVariableDescriptor]

'element' @ [227:132] ==> val element: JavaElement? defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapPropertySignature[LocalVariableDescriptor]

'KotlinReflectionInternalError' @ [231:23] ==> public constructor KotlinReflectionInternalError(message: String) defined in kotlin.reflect.jvm.internal.KotlinReflectionInternalError[ClassConstructorDescriptorImpl]

'property' @ [231:73] ==> val property: PropertyDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapPropertySignature[LocalVariableDescriptor]

'property' @ [231:85] ==> val property: PropertyDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapPropertySignature[LocalVariableDescriptor]

'javaClass' @ [231:94] ==> public val <T : Any> PropertyDescriptor.javaClass: Class<PropertyDescriptor> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> PropertyDescriptor

'function' @ [237:26] ==> value-parameter function: FunctionDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapIntrinsicFunctionSignature[ValueParameterDescriptorImpl]

'valueParameters' @ [237:35] ==> public final val FunctionDescriptor.valueParameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>)[MyPropertyDescriptor]

'when (function.name.asString()) {
            "equals" -> if (parameters.size == 1 && KotlinBuiltIns.isNullableAny(parameters.single().type)) {
                return JvmFunctionSignature.BuiltInFunction.Predefined("equals(Ljava/lang/Object;)Z",
                                                                       Any::class.java.getDeclaredMethod("equals", Any::class.java))
            }
            "hashCode" -> if (parameters.isEmpty()) {
                return JvmFunctionSignature.BuiltInFunction.Predefined("hashCode()I",
                                                                       Any::class.java.getDeclaredMethod("hashCode"))
            }
            "toString" -> if (parameters.isEmpty()) {
                return JvmFunctionSignature.BuiltInFunction.Predefined("toString()Ljava/lang/String;",
                                                                       Any::class.java.getDeclaredMethod("toString"))
            }
            // TODO: generalize and support other functions from built-ins
        }' @ [239:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit, entry2: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'function' @ [239:15] ==> value-parameter function: FunctionDescriptor defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapIntrinsicFunctionSignature[ValueParameterDescriptorImpl]

'name' @ [239:24] ==> public final val FunctionDescriptor.name: Name[MyPropertyDescriptor]

'asString' @ [239:29] ==> @NotNull public open fun asString(): String defined in org.jetbrains.kotlin.name.Name[JavaMethodDescriptor]

'parameters' @ [240:29] ==> val parameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>) defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapIntrinsicFunctionSignature[LocalVariableDescriptor]

'size' @ [240:40] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'isNullableAny' @ [240:68] ==> public open fun isNullableAny(@NotNull type: KotlinType): Boolean defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'parameters' @ [240:82] ==> val parameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>) defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapIntrinsicFunctionSignature[LocalVariableDescriptor]

'single' @ [240:93] ==> public fun <T> List<(ValueParameterDescriptor..ValueParameterDescriptor?)>.single(): (ValueParameterDescriptor..ValueParameterDescriptor?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.jetbrains.kotlin.descriptors.ValueParameterDescriptor..org.jetbrains.kotlin.descriptors.ValueParameterDescriptor?)

'type' @ [240:102] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'Predefined' @ [241:61] ==> public constructor Predefined(signature: String, member: Member) defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.BuiltInFunction.Predefined[ClassConstructorDescriptorImpl]

'Any' @ [242:72] ==> public constructor Any() defined in kotlin.Any[DeserializedClassConstructorDescriptor]

'java' @ [242:83] ==> public val <T> KClass<Any>.java: Class<Any> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> Any

'getDeclaredMethod' @ [242:88] ==> public open fun getDeclaredMethod(p0: (String..String?), vararg p1: (Class<*>..Class<*>?)): (Method..Method?) defined in java.lang.Class[JavaMethodDescriptor]

'Any' @ [242:116] ==> public constructor Any() defined in kotlin.Any[DeserializedClassConstructorDescriptor]

'java' @ [242:127] ==> public val <T> KClass<Any>.java: Class<Any> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> Any

'parameters' @ [244:31] ==> val parameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>) defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapIntrinsicFunctionSignature[LocalVariableDescriptor]

'isEmpty' @ [244:42] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'Predefined' @ [245:61] ==> public constructor Predefined(signature: String, member: Member) defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.BuiltInFunction.Predefined[ClassConstructorDescriptorImpl]

'Any' @ [246:72] ==> public constructor Any() defined in kotlin.Any[DeserializedClassConstructorDescriptor]

'java' @ [246:83] ==> public val <T> KClass<Any>.java: Class<Any> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> Any

'getDeclaredMethod' @ [246:88] ==> public open fun getDeclaredMethod(p0: (String..String?), vararg p1: (Class<*>..Class<*>?)): (Method..Method?) defined in java.lang.Class[JavaMethodDescriptor]

'parameters' @ [248:31] ==> val parameters: (MutableList<(ValueParameterDescriptor..ValueParameterDescriptor?)>..List<(ValueParameterDescriptor..ValueParameterDescriptor?)>) defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapIntrinsicFunctionSignature[LocalVariableDescriptor]

'isEmpty' @ [248:42] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'Predefined' @ [249:61] ==> public constructor Predefined(signature: String, member: Member) defined in kotlin.reflect.jvm.internal.JvmFunctionSignature.BuiltInFunction.Predefined[ClassConstructorDescriptorImpl]

'Any' @ [250:72] ==> public constructor Any() defined in kotlin.Any[DeserializedClassConstructorDescriptor]

'java' @ [250:83] ==> public val <T> KClass<Any>.java: Class<Any> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> Any

'getDeclaredMethod' @ [250:88] ==> public open fun getDeclaredMethod(p0: (String..String?), vararg p1: (Class<*>..Class<*>?)): (Method..Method?) defined in java.lang.Class[JavaMethodDescriptor]

'klass' @ [259:13] ==> value-parameter klass: Class<*> defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapJvmClassToKotlinClassId[ValueParameterDescriptorImpl]

'isArray' @ [259:19] ==> public final val <T : (Any..Any?)> Class<out (Any..Any?)>.isArray: Boolean[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Captured(*)

'klass' @ [260:13] ==> value-parameter klass: Class<*> defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapJvmClassToKotlinClassId[ValueParameterDescriptorImpl]

'componentType' @ [260:19] ==> public final val <T : (Any..Any?)> Class<out (Any..Any?)>.componentType: (Class<*>..Class<*>?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Captured(*)

'primitiveType' @ [260:33] ==> private final val Class<*>.primitiveType: PrimitiveType? defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper[PropertyDescriptorImpl]

'let' @ [260:48] ==> @InlineOnly public inline fun <T, R> PrimitiveType.let(block: (PrimitiveType) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PrimitiveType
    <R> -> Nothing

'ClassId' @ [261:24] ==> public constructor ClassId(@NotNull packageFqName: FqName, @NotNull topLevelName: Name) defined in org.jetbrains.kotlin.name.ClassId[JavaClassConstructorDescriptor]

'BUILT_INS_PACKAGE_FQ_NAME' @ [261:47] ==> public final val BUILT_INS_PACKAGE_FQ_NAME: (FqName..FqName?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaPropertyDescriptor]

'it' @ [261:74] ==> value-parameter it: PrimitiveType defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapJvmClassToKotlinClassId.<anonymous>[ValueParameterDescriptorImpl]

'arrayTypeName' @ [261:77] ==> public final val PrimitiveType.arrayTypeName: Name[MyPropertyDescriptor]

'topLevel' @ [263:28] ==> @NotNull public open fun topLevel(@NotNull topLevelFqName: FqName): ClassId defined in org.jetbrains.kotlin.name.ClassId[JavaMethodDescriptor]

'FQ_NAMES' @ [263:52] ==> public final val FQ_NAMES: (KotlinBuiltIns.FqNames..KotlinBuiltIns.FqNames?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaPropertyDescriptor]

'array' @ [263:61] ==> public final val array: (FqNameUnsafe..FqNameUnsafe?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns.FqNames[JavaPropertyDescriptor]

'toSafe' @ [263:67] ==> @NotNull public open fun toSafe(): FqName defined in org.jetbrains.kotlin.name.FqNameUnsafe[JavaMethodDescriptor]

'klass' @ [266:9] ==> value-parameter klass: Class<*> defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapJvmClassToKotlinClassId[ValueParameterDescriptorImpl]

'primitiveType' @ [266:15] ==> private final val Class<*>.primitiveType: PrimitiveType? defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper[PropertyDescriptorImpl]

'let' @ [266:30] ==> @InlineOnly public inline fun <T, R> PrimitiveType.let(block: (PrimitiveType) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PrimitiveType
    <R> -> Nothing

'ClassId' @ [267:20] ==> public constructor ClassId(@NotNull packageFqName: FqName, @NotNull topLevelName: Name) defined in org.jetbrains.kotlin.name.ClassId[JavaClassConstructorDescriptor]

'BUILT_INS_PACKAGE_FQ_NAME' @ [267:43] ==> public final val BUILT_INS_PACKAGE_FQ_NAME: (FqName..FqName?) defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaPropertyDescriptor]

'it' @ [267:70] ==> value-parameter it: PrimitiveType defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapJvmClassToKotlinClassId.<anonymous>[ValueParameterDescriptorImpl]

'typeName' @ [267:73] ==> public final val PrimitiveType.typeName: Name[MyPropertyDescriptor]

'klass' @ [270:23] ==> value-parameter klass: Class<*> defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapJvmClassToKotlinClassId[ValueParameterDescriptorImpl]

'classId' @ [270:29] ==> public val Class<*>.classId: ClassId defined in org.jetbrains.kotlin.load.java.structure.reflect in file reflectClassUtil.kt[PropertyDescriptorImpl]

'!' @ [271:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'classId' @ [271:14] ==> val classId: ClassId defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapJvmClassToKotlinClassId[LocalVariableDescriptor]

'isLocal' @ [271:22] ==> public final val ClassId.isLocal: Boolean[MyPropertyDescriptor]

'JavaToKotlinClassMap' @ [272:13] ==> public object JavaToKotlinClassMap : PlatformToKotlinClassMap defined in org.jetbrains.kotlin.platform in file JavaToKotlinClassMap.kt[FakeCallableDescriptorForObject]

'mapJavaToKotlin' @ [272:34] ==> public final fun mapJavaToKotlin(fqName: FqName): ClassId? defined in org.jetbrains.kotlin.platform.JavaToKotlinClassMap[SimpleFunctionDescriptorImpl]

'classId' @ [272:50] ==> val classId: ClassId defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapJvmClassToKotlinClassId[LocalVariableDescriptor]

'asSingleFqName' @ [272:58] ==> @NotNull public open fun asSingleFqName(): FqName defined in org.jetbrains.kotlin.name.ClassId[JavaMethodDescriptor]

'let' @ [272:77] ==> @InlineOnly public inline fun <T, R> ClassId.let(block: (ClassId) -> Nothing): Nothing defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ClassId
    <R> -> Nothing

'it' @ [272:90] ==> value-parameter it: ClassId defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapJvmClassToKotlinClassId.<anonymous>[ValueParameterDescriptorImpl]

'classId' @ [275:16] ==> val classId: ClassId defined in kotlin.reflect.jvm.internal.RuntimeTypeMapper.mapJvmClassToKotlinClassId[LocalVariableDescriptor]

'if (isPrimitive) JvmPrimitiveType.get(simpleName).primitiveType else null' @ [279:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: PrimitiveType?, elseBranch: PrimitiveType?): PrimitiveType?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> PrimitiveType?

'isPrimitive' @ [279:21] ==> public final val <T : (Any..Any?)> Class<out (Any..Any?)>.isPrimitive: Boolean[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Captured(*)

'get' @ [279:51] ==> @NotNull public open fun get(@NotNull name: String): JvmPrimitiveType defined in org.jetbrains.kotlin.resolve.jvm.JvmPrimitiveType[JavaMethodDescriptor]

'simpleName' @ [279:55] ==> public final val <T : (Any..Any?)> Class<out (Any..Any?)>.simpleName: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Captured(*)

'primitiveType' @ [279:67] ==> public final val JvmPrimitiveType.primitiveType: PrimitiveType[MyPropertyDescriptor]

