'c' @ [46:28] ==> private final val c: LazyJavaResolverContext defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'storageManager' @ [46:30] ==> public final val storageManager: StorageManager defined in org.jetbrains.kotlin.load.java.lazy.LazyJavaResolverContext[PropertyDescriptorImpl]

'createNullableLazyValue' @ [46:45] ==> public abstract fun <T : Any> createNullableLazyValue(computable: () -> FqName?): NullableLazyValue<FqName> defined in org.jetbrains.kotlin.storage.StorageManager[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> FqName

'javaAnnotation' @ [47:9] ==> private final val javaAnnotation: JavaAnnotation defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'classId' @ [47:24] ==> public abstract val classId: ClassId? defined in org.jetbrains.kotlin.load.java.structure.JavaAnnotation[PropertyDescriptorImpl]

'asSingleFqName' @ [47:33] ==> @NotNull public open fun asSingleFqName(): FqName defined in org.jetbrains.kotlin.name.ClassId[JavaMethodDescriptor]

'c' @ [50:26] ==> private final val c: LazyJavaResolverContext defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'storageManager' @ [50:28] ==> public final val storageManager: StorageManager defined in org.jetbrains.kotlin.load.java.lazy.LazyJavaResolverContext[PropertyDescriptorImpl]

'createLazyValue' @ [50:43] ==> public abstract fun <T : Any> createLazyValue(computable: () -> SimpleType): NotNullLazyValue<SimpleType> defined in org.jetbrains.kotlin.storage.StorageManager[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> SimpleType

'fqName' @ [51:22] ==> public open val fqName: FqName? defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'createErrorType' @ [51:66] ==> @NotNull public open fun createErrorType(@NotNull debugMessage: String): SimpleType defined in org.jetbrains.kotlin.types.ErrorUtils[JavaMethodDescriptor]

'javaAnnotation' @ [51:95] ==> private final val javaAnnotation: JavaAnnotation defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'?:' @ [52:31] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: ClassDescriptor?, right: ClassDescriptor?): ClassDescriptor?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> ClassDescriptor?

'mapJavaToKotlin' @ [52:52] ==> public final fun mapJavaToKotlin(fqName: FqName, builtIns: KotlinBuiltIns): ClassDescriptor? defined in org.jetbrains.kotlin.platform.JavaToKotlinClassMap[SimpleFunctionDescriptorImpl]

'fqName' @ [52:68] ==> val fqName: FqName defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.type.<anonymous>[LocalVariableDescriptor]

'c' @ [52:76] ==> private final val c: LazyJavaResolverContext defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'module' @ [52:78] ==> public final val module: ModuleDescriptor defined in org.jetbrains.kotlin.load.java.lazy.LazyJavaResolverContext[PropertyDescriptorImpl]

'builtIns' @ [52:85] ==> public abstract val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.descriptors.ModuleDescriptor[PropertyDescriptorImpl]

'javaAnnotation' @ [53:34] ==> private final val javaAnnotation: JavaAnnotation defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'resolve' @ [53:49] ==> public abstract fun resolve(): JavaClass? defined in org.jetbrains.kotlin.load.java.structure.JavaAnnotation[SimpleFunctionDescriptorImpl]

'let' @ [53:60] ==> @InlineOnly public inline fun <T, R> JavaClass.let(block: (JavaClass) -> ClassDescriptor?): ClassDescriptor? defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JavaClass
    <R> -> ClassDescriptor?

'c' @ [53:79] ==> private final val c: LazyJavaResolverContext defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'components' @ [53:81] ==> public final val components: JavaResolverComponents defined in org.jetbrains.kotlin.load.java.lazy.LazyJavaResolverContext[PropertyDescriptorImpl]

'moduleClassResolver' @ [53:92] ==> public final val moduleClassResolver: ModuleClassResolver defined in org.jetbrains.kotlin.load.java.lazy.JavaResolverComponents[PropertyDescriptorImpl]

'resolveClass' @ [53:112] ==> public abstract fun resolveClass(javaClass: JavaClass): ClassDescriptor? defined in org.jetbrains.kotlin.load.java.lazy.ModuleClassResolver[SimpleFunctionDescriptorImpl]

'javaClass' @ [53:125] ==> value-parameter javaClass: JavaClass defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.type.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'createTypeForMissingDependencies' @ [54:34] ==> private final fun createTypeForMissingDependencies(fqName: FqName): ClassDescriptor defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[SimpleFunctionDescriptorImpl]

'fqName' @ [54:67] ==> val fqName: FqName defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.type.<anonymous>[LocalVariableDescriptor]

'annotationClass' @ [55:9] ==> val annotationClass: ClassDescriptor defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.type.<anonymous>[LocalVariableDescriptor]

'defaultType' @ [55:25] ==> public final val ClassDescriptor.defaultType: SimpleType[MyPropertyDescriptor]

'c' @ [58:27] ==> private final val c: LazyJavaResolverContext defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'components' @ [58:29] ==> public final val components: JavaResolverComponents defined in org.jetbrains.kotlin.load.java.lazy.LazyJavaResolverContext[PropertyDescriptorImpl]

'sourceElementFactory' @ [58:40] ==> public final val sourceElementFactory: JavaSourceElementFactory defined in org.jetbrains.kotlin.load.java.lazy.JavaResolverComponents[PropertyDescriptorImpl]

'source' @ [58:61] ==> public abstract fun source(javaElement: JavaElement): JavaSourceElement defined in org.jetbrains.kotlin.load.java.sources.JavaSourceElementFactory[SimpleFunctionDescriptorImpl]

'javaAnnotation' @ [58:68] ==> private final val javaAnnotation: JavaAnnotation defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'ConstantValueFactory' @ [60:27] ==> public constructor ConstantValueFactory(builtins: KotlinBuiltIns) defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[ClassConstructorDescriptorImpl]

'c' @ [60:48] ==> private final val c: LazyJavaResolverContext defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'module' @ [60:50] ==> public final val module: ModuleDescriptor defined in org.jetbrains.kotlin.load.java.lazy.LazyJavaResolverContext[PropertyDescriptorImpl]

'builtIns' @ [60:57] ==> public abstract val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.descriptors.ModuleDescriptor[PropertyDescriptorImpl]

'c' @ [62:39] ==> private final val c: LazyJavaResolverContext defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'storageManager' @ [62:41] ==> public final val storageManager: StorageManager defined in org.jetbrains.kotlin.load.java.lazy.LazyJavaResolverContext[PropertyDescriptorImpl]

'createLazyValue' @ [62:56] ==> public abstract fun <T : Any> createLazyValue(computable: () -> Map<(Name..Name?), ConstantValue<*>>): NotNullLazyValue<Map<(Name..Name?), ConstantValue<*>>> defined in org.jetbrains.kotlin.storage.StorageManager[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> Map<(org.jetbrains.kotlin.name.Name..org.jetbrains.kotlin.name.Name?), ConstantValue<*>>

'javaAnnotation' @ [63:9] ==> private final val javaAnnotation: JavaAnnotation defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'arguments' @ [63:24] ==> public abstract val arguments: Collection<JavaAnnotationArgument> defined in org.jetbrains.kotlin.load.java.structure.JavaAnnotation[PropertyDescriptorImpl]

'mapNotNull' @ [63:34] ==> public inline fun <T, R : Any> Iterable<JavaAnnotationArgument>.mapNotNull(transform: (JavaAnnotationArgument) -> Pair<(Name..Name?), ConstantValue<*>>?): List<Pair<(Name..Name?), ConstantValue<*>>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JavaAnnotationArgument
    <R : Any> -> Pair<(org.jetbrains.kotlin.name.Name..org.jetbrains.kotlin.name.Name?), ConstantValue<*>>

'arg' @ [64:24] ==> value-parameter arg: JavaAnnotationArgument defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.allValueArguments.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [64:28] ==> public abstract val name: Name? defined in org.jetbrains.kotlin.load.java.structure.JavaAnnotationArgument[PropertyDescriptorImpl]

'DEFAULT_ANNOTATION_MEMBER_NAME' @ [64:36] ==> public final val DEFAULT_ANNOTATION_MEMBER_NAME: (Name..Name?) defined in org.jetbrains.kotlin.load.java.JvmAnnotationNames[JavaPropertyDescriptor]

'resolveAnnotationArgument' @ [65:13] ==> private final fun resolveAnnotationArgument(argument: JavaAnnotationArgument?): ConstantValue<*>? defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[SimpleFunctionDescriptorImpl]

'arg' @ [65:39] ==> value-parameter arg: JavaAnnotationArgument defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.allValueArguments.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'let' @ [65:45] ==> @InlineOnly public inline fun <T, R> ConstantValue<*>.let(block: (ConstantValue<*>) -> Pair<(Name..Name?), ConstantValue<*>>): Pair<(Name..Name?), ConstantValue<*>> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ConstantValue<*>
    <R> -> Pair<(org.jetbrains.kotlin.name.Name..org.jetbrains.kotlin.name.Name?), ConstantValue<*>>

'name' @ [65:60] ==> val name: (Name..Name?) defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.allValueArguments.<anonymous>.<anonymous>[LocalVariableDescriptor]

'value' @ [65:68] ==> value-parameter value: ConstantValue<*> defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.allValueArguments.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'toMap' @ [66:11] ==> public fun <K, V> Iterable<Pair<(Name..Name?), ConstantValue<*>>>.toMap(): Map<(Name..Name?), ConstantValue<*>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (org.jetbrains.kotlin.name.Name..org.jetbrains.kotlin.name.Name?)
    <V> -> ConstantValue<*>

'when (argument) {
            is JavaLiteralAnnotationArgument -> factory.createConstantValue(argument.value)
            is JavaEnumValueAnnotationArgument -> resolveFromEnumValue(argument.resolve(), argument.entryName)
            is JavaArrayAnnotationArgument -> resolveFromArray(argument.name ?: DEFAULT_ANNOTATION_MEMBER_NAME, argument.getElements())
            is JavaAnnotationAsAnnotationArgument -> resolveFromAnnotation(argument.getAnnotation())
            is JavaClassObjectAnnotationArgument -> resolveFromJavaClassObjectType(argument.getReferencedType())
            else -> null
        }' @ [70:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: ConstantValue<*>?, entry1: ConstantValue<*>?, entry2: ConstantValue<*>?, entry3: ConstantValue<*>?, entry4: ConstantValue<*>?, entry5: ConstantValue<*>?): ConstantValue<*>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> ConstantValue<*>?

'argument' @ [70:22] ==> value-parameter argument: JavaAnnotationArgument? defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveAnnotationArgument[ValueParameterDescriptorImpl]

'factory' @ [71:49] ==> private final val factory: ConstantValueFactory defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'createConstantValue' @ [71:57] ==> public final fun createConstantValue(value: Any?): ConstantValue<*>? defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[SimpleFunctionDescriptorImpl]

'argument' @ [71:77] ==> value-parameter argument: JavaAnnotationArgument? defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveAnnotationArgument[ValueParameterDescriptorImpl]

'value' @ [71:86] ==> public abstract val value: Any? defined in org.jetbrains.kotlin.load.java.structure.JavaLiteralAnnotationArgument[PropertyDescriptorImpl]

'resolveFromEnumValue' @ [72:51] ==> private final fun resolveFromEnumValue(element: JavaField?, entryName: Name?): ConstantValue<*>? defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[SimpleFunctionDescriptorImpl]

'argument' @ [72:72] ==> value-parameter argument: JavaAnnotationArgument? defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveAnnotationArgument[ValueParameterDescriptorImpl]

'resolve' @ [72:81] ==> public abstract fun resolve(): JavaField? defined in org.jetbrains.kotlin.load.java.structure.JavaEnumValueAnnotationArgument[SimpleFunctionDescriptorImpl]

'argument' @ [72:92] ==> value-parameter argument: JavaAnnotationArgument? defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveAnnotationArgument[ValueParameterDescriptorImpl]

'entryName' @ [72:101] ==> public abstract val entryName: Name? defined in org.jetbrains.kotlin.load.java.structure.JavaEnumValueAnnotationArgument[PropertyDescriptorImpl]

'resolveFromArray' @ [73:47] ==> private final fun resolveFromArray(argumentName: Name, elements: List<JavaAnnotationArgument>): ConstantValue<*>? defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[SimpleFunctionDescriptorImpl]

'argument' @ [73:64] ==> value-parameter argument: JavaAnnotationArgument? defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveAnnotationArgument[ValueParameterDescriptorImpl]

'name' @ [73:73] ==> public abstract val name: Name? defined in org.jetbrains.kotlin.load.java.structure.JavaAnnotationArgument[PropertyDescriptorImpl]

'DEFAULT_ANNOTATION_MEMBER_NAME' @ [73:81] ==> public final val DEFAULT_ANNOTATION_MEMBER_NAME: (Name..Name?) defined in org.jetbrains.kotlin.load.java.JvmAnnotationNames[JavaPropertyDescriptor]

'argument' @ [73:113] ==> value-parameter argument: JavaAnnotationArgument? defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveAnnotationArgument[ValueParameterDescriptorImpl]

'getElements' @ [73:122] ==> public abstract fun getElements(): List<JavaAnnotationArgument> defined in org.jetbrains.kotlin.load.java.structure.JavaArrayAnnotationArgument[SimpleFunctionDescriptorImpl]

'resolveFromAnnotation' @ [74:54] ==> private final fun resolveFromAnnotation(javaAnnotation: JavaAnnotation): ConstantValue<*> defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[SimpleFunctionDescriptorImpl]

'argument' @ [74:76] ==> value-parameter argument: JavaAnnotationArgument? defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveAnnotationArgument[ValueParameterDescriptorImpl]

'getAnnotation' @ [74:85] ==> public abstract fun getAnnotation(): JavaAnnotation defined in org.jetbrains.kotlin.load.java.structure.JavaAnnotationAsAnnotationArgument[SimpleFunctionDescriptorImpl]

'resolveFromJavaClassObjectType' @ [75:53] ==> private final fun resolveFromJavaClassObjectType(javaType: JavaType): ConstantValue<*>? defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[SimpleFunctionDescriptorImpl]

'argument' @ [75:84] ==> value-parameter argument: JavaAnnotationArgument? defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveAnnotationArgument[ValueParameterDescriptorImpl]

'getReferencedType' @ [75:93] ==> public abstract fun getReferencedType(): JavaType defined in org.jetbrains.kotlin.load.java.structure.JavaClassObjectAnnotationArgument[SimpleFunctionDescriptorImpl]

'factory' @ [81:16] ==> private final val factory: ConstantValueFactory defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'createAnnotationValue' @ [81:24] ==> public final fun createAnnotationValue(value: AnnotationDescriptor): AnnotationValue defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[SimpleFunctionDescriptorImpl]

'LazyJavaAnnotationDescriptor' @ [81:46] ==> public constructor LazyJavaAnnotationDescriptor(c: LazyJavaResolverContext, javaAnnotation: JavaAnnotation) defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[ClassConstructorDescriptorImpl]

'c' @ [81:75] ==> private final val c: LazyJavaResolverContext defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'javaAnnotation' @ [81:78] ==> value-parameter javaAnnotation: JavaAnnotation defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveFromAnnotation[ValueParameterDescriptorImpl]

'type' @ [85:13] ==> public open val type: SimpleType defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'isError' @ [85:18] ==> public val KotlinType.isError: Boolean defined in org.jetbrains.kotlin.types in file KotlinType.kt[PropertyDescriptorImpl]

'?:' @ [88:17] ==> public final fun <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-ELVIS-RESOLVE>`(left: KotlinType?, right: KotlinType): KotlinType[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-ELVIS-RESOLVE>`> -> KotlinType

'getAnnotationParameterByName' @ [88:41] ==> @Nullable public open fun getAnnotationParameterByName(@NotNull name: Name, @NotNull annotationClass: ClassDescriptor): ValueParameterDescriptor? defined in org.jetbrains.kotlin.load.java.components.DescriptorResolverUtils[JavaMethodDescriptor]

'argumentName' @ [88:70] ==> value-parameter argumentName: Name defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveFromArray[ValueParameterDescriptorImpl]

'annotationClass' @ [88:84] ==> public val AnnotationDescriptor.annotationClass: ClassDescriptor? defined in org.jetbrains.kotlin.resolve.descriptorUtil in file DescriptorUtils.kt[PropertyDescriptorImpl]

'type' @ [88:104] ==> public final val ValueParameterDescriptor.type: KotlinType[MyPropertyDescriptor]

'c' @ [90:21] ==> private final val c: LazyJavaResolverContext defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'components' @ [90:23] ==> public final val components: JavaResolverComponents defined in org.jetbrains.kotlin.load.java.lazy.LazyJavaResolverContext[PropertyDescriptorImpl]

'module' @ [90:34] ==> public final val module: ModuleDescriptor defined in org.jetbrains.kotlin.load.java.lazy.JavaResolverComponents[PropertyDescriptorImpl]

'builtIns' @ [90:41] ==> public abstract val builtIns: KotlinBuiltIns defined in org.jetbrains.kotlin.descriptors.ModuleDescriptor[PropertyDescriptorImpl]

'getArrayType' @ [90:50] ==> @NotNull public open fun getArrayType(@NotNull projectionType: Variance, @NotNull argument: KotlinType): SimpleType defined in org.jetbrains.kotlin.builtins.KotlinBuiltIns[JavaMethodDescriptor]

'INVARIANT' @ [91:34] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'createErrorType' @ [92:36] ==> @NotNull public open fun createErrorType(@NotNull debugMessage: String): SimpleType defined in org.jetbrains.kotlin.types.ErrorUtils[JavaMethodDescriptor]

'elements' @ [95:22] ==> value-parameter elements: List<JavaAnnotationArgument> defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveFromArray[ValueParameterDescriptorImpl]

'map' @ [95:31] ==> public inline fun <T, R> Iterable<JavaAnnotationArgument>.map(transform: (JavaAnnotationArgument) -> ConstantValue<Any?>): List<ConstantValue<Any?>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> JavaAnnotationArgument
    <R> -> ConstantValue<Any?>

'resolveAnnotationArgument' @ [96:25] ==> private final fun resolveAnnotationArgument(argument: JavaAnnotationArgument?): ConstantValue<*>? defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[SimpleFunctionDescriptorImpl]

'argument' @ [96:51] ==> value-parameter argument: JavaAnnotationArgument defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveFromArray.<anonymous>[ValueParameterDescriptorImpl]

'factory' @ [96:64] ==> private final val factory: ConstantValueFactory defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'createNullValue' @ [96:72] ==> public final fun createNullValue(): NullValue defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[SimpleFunctionDescriptorImpl]

'factory' @ [99:16] ==> private final val factory: ConstantValueFactory defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'createArrayValue' @ [99:24] ==> public final fun createArrayValue(value: List<ConstantValue<*>>, type: KotlinType): ArrayValue defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[SimpleFunctionDescriptorImpl]

'values' @ [99:41] ==> val values: List<ConstantValue<Any?>> defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveFromArray[LocalVariableDescriptor]

'arrayType' @ [99:49] ==> val arrayType: KotlinType defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveFromArray[LocalVariableDescriptor]

'element' @ [103:13] ==> value-parameter element: JavaField? defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveFromEnumValue[ValueParameterDescriptorImpl]

'!' @ [103:32] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'element' @ [103:33] ==> value-parameter element: JavaField? defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveFromEnumValue[ValueParameterDescriptorImpl]

'isEnumEntry' @ [103:41] ==> public abstract val isEnumEntry: Boolean defined in org.jetbrains.kotlin.load.java.structure.JavaField[PropertyDescriptorImpl]

'entryName' @ [104:17] ==> value-parameter entryName: Name? defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveFromEnumValue[ValueParameterDescriptorImpl]

'factory' @ [105:20] ==> private final val factory: ConstantValueFactory defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'createEnumValue' @ [105:28] ==> public final fun createEnumValue(enumEntryClass: ClassDescriptor): EnumValue defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[SimpleFunctionDescriptorImpl]

'createErrorClassWithExactName' @ [105:55] ==> @NotNull public open fun createErrorClassWithExactName(@NotNull name: Name): ClassDescriptor defined in org.jetbrains.kotlin.types.ErrorUtils[JavaMethodDescriptor]

'entryName' @ [105:85] ==> value-parameter entryName: Name? defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveFromEnumValue[ValueParameterDescriptorImpl]

'element' @ [108:35] ==> value-parameter element: JavaField? defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveFromEnumValue[ValueParameterDescriptorImpl]

'containingClass' @ [108:43] ==> public abstract val containingClass: JavaClass defined in org.jetbrains.kotlin.load.java.structure.JavaField[PropertyDescriptorImpl]

'c' @ [110:25] ==> private final val c: LazyJavaResolverContext defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'components' @ [110:27] ==> public final val components: JavaResolverComponents defined in org.jetbrains.kotlin.load.java.lazy.LazyJavaResolverContext[PropertyDescriptorImpl]

'moduleClassResolver' @ [110:38] ==> public final val moduleClassResolver: ModuleClassResolver defined in org.jetbrains.kotlin.load.java.lazy.JavaResolverComponents[PropertyDescriptorImpl]

'resolveClass' @ [110:58] ==> public abstract fun resolveClass(javaClass: JavaClass): ClassDescriptor? defined in org.jetbrains.kotlin.load.java.lazy.ModuleClassResolver[SimpleFunctionDescriptorImpl]

'containingJavaClass' @ [110:71] ==> val containingJavaClass: JavaClass defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveFromEnumValue[LocalVariableDescriptor]

'enumClass' @ [112:26] ==> val enumClass: ClassDescriptor defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveFromEnumValue[LocalVariableDescriptor]

'unsubstitutedInnerClassesScope' @ [112:36] ==> public final val ClassDescriptor.unsubstitutedInnerClassesScope: MemberScope[MyPropertyDescriptor]

'getContributedClassifier' @ [112:67] ==> public abstract fun getContributedClassifier(name: Name, location: LookupLocation): ClassifierDescriptor? defined in org.jetbrains.kotlin.resolve.scopes.MemberScope[SimpleFunctionDescriptorImpl]

'element' @ [112:92] ==> value-parameter element: JavaField? defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveFromEnumValue[ValueParameterDescriptorImpl]

'name' @ [112:100] ==> public abstract val name: Name defined in org.jetbrains.kotlin.load.java.structure.JavaField[PropertyDescriptorImpl]

'FROM_JAVA_LOADER' @ [112:123] ==> enum entry FROM_JAVA_LOADER defined in org.jetbrains.kotlin.incremental.components.NoLookupLocation[FakeCallableDescriptorForObject]

'factory' @ [115:16] ==> private final val factory: ConstantValueFactory defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'createEnumValue' @ [115:24] ==> public final fun createEnumValue(enumEntryClass: ClassDescriptor): EnumValue defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[SimpleFunctionDescriptorImpl]

'classifier' @ [115:40] ==> val classifier: ClassDescriptor defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveFromEnumValue[LocalVariableDescriptor]

'makeNotNullable' @ [120:30] ==> @NotNull public open fun makeNotNullable(@NotNull type: KotlinType): KotlinType defined in org.jetbrains.kotlin.types.TypeUtils[JavaMethodDescriptor]

'c' @ [120:46] ==> private final val c: LazyJavaResolverContext defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'typeResolver' @ [120:48] ==> public final val typeResolver: JavaTypeResolver defined in org.jetbrains.kotlin.load.java.lazy.LazyJavaResolverContext[PropertyDescriptorImpl]

'transformJavaType' @ [120:61] ==> public final fun transformJavaType(javaType: JavaType, attr: JavaTypeAttributes): KotlinType defined in org.jetbrains.kotlin.load.java.lazy.types.JavaTypeResolver[SimpleFunctionDescriptorImpl]

'javaType' @ [121:17] ==> value-parameter javaType: JavaType defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveFromJavaClassObjectType[ValueParameterDescriptorImpl]

'toAttributes' @ [122:34] ==> public fun TypeUsage.toAttributes(isForAnnotationParameter: Boolean = ..., upperBoundForTypeParameter: TypeParameterDescriptor? = ...): JavaTypeAttributes defined in org.jetbrains.kotlin.load.java.lazy.types in file JavaTypeResolver.kt[SimpleFunctionDescriptorImpl]

'c' @ [125:23] ==> private final val c: LazyJavaResolverContext defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'module' @ [125:25] ==> public final val module: ModuleDescriptor defined in org.jetbrains.kotlin.load.java.lazy.LazyJavaResolverContext[PropertyDescriptorImpl]

'resolveTopLevelClass' @ [125:32] ==> public fun ModuleDescriptor.resolveTopLevelClass(topLevelClassFqName: FqName, location: LookupLocation): ClassDescriptor? defined in org.jetbrains.kotlin.resolve.descriptorUtil in file DescriptorUtils.kt[SimpleFunctionDescriptorImpl]

'FqName' @ [125:53] ==> public constructor FqName(@NotNull fqName: String) defined in org.jetbrains.kotlin.name.FqName[JavaClassConstructorDescriptor]

'FOR_NON_TRACKED_SCOPE' @ [125:97] ==> enum entry FOR_NON_TRACKED_SCOPE defined in org.jetbrains.kotlin.incremental.components.NoLookupLocation[FakeCallableDescriptorForObject]

'listOf' @ [127:25] ==> public fun <T> listOf(element: TypeProjectionImpl): List<TypeProjectionImpl> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeProjectionImpl

'TypeProjectionImpl' @ [127:32] ==> public constructor TypeProjectionImpl(@NotNull type: KotlinType) defined in org.jetbrains.kotlin.types.TypeProjectionImpl[JavaClassConstructorDescriptor]

'type' @ [127:51] ==> val type: KotlinType defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveFromJavaClassObjectType[LocalVariableDescriptor]

'KotlinTypeFactory' @ [129:35] ==> public object KotlinTypeFactory defined in org.jetbrains.kotlin.types in file KotlinTypeFactory.kt[FakeCallableDescriptorForObject]

'simpleNotNullType' @ [129:53] ==> @JvmStatic public final fun simpleNotNullType(annotations: Annotations, descriptor: ClassDescriptor, arguments: List<TypeProjection>): SimpleType defined in org.jetbrains.kotlin.types.KotlinTypeFactory[SimpleFunctionDescriptorImpl]

'EMPTY' @ [129:83] ==> public final val EMPTY: Annotations defined in org.jetbrains.kotlin.descriptors.annotations.Annotations.Companion[PropertyDescriptorImpl]

'jlClass' @ [129:90] ==> val jlClass: ClassDescriptor defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveFromJavaClassObjectType[LocalVariableDescriptor]

'arguments' @ [129:99] ==> val arguments: List<TypeProjectionImpl> defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveFromJavaClassObjectType[LocalVariableDescriptor]

'factory' @ [131:16] ==> private final val factory: ConstantValueFactory defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'createKClassValue' @ [131:24] ==> public final fun createKClassValue(type: KotlinType): KClassValue defined in org.jetbrains.kotlin.resolve.constants.ConstantValueFactory[SimpleFunctionDescriptorImpl]

'javaClassObjectType' @ [131:42] ==> val javaClassObjectType: SimpleType defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.resolveFromJavaClassObjectType[LocalVariableDescriptor]

'DescriptorRenderer' @ [135:16] ==> public companion object defined in org.jetbrains.kotlin.renderer.DescriptorRenderer[FakeCallableDescriptorForObject]

'FQ_NAMES_IN_TYPES' @ [135:35] ==> @JvmField public final val FQ_NAMES_IN_TYPES: DescriptorRenderer defined in org.jetbrains.kotlin.renderer.DescriptorRenderer.Companion[PropertyDescriptorImpl]

'renderAnnotation' @ [135:53] ==> public abstract fun renderAnnotation(annotation: AnnotationDescriptor, target: AnnotationUseSiteTarget? = ...): String defined in org.jetbrains.kotlin.renderer.DescriptorRenderer[SimpleFunctionDescriptorImpl]

'this' @ [135:70] ==> <this> defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[LazyClassReceiverParameterDescriptor]

'c' @ [139:13] ==> private final val c: LazyJavaResolverContext defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'module' @ [139:15] ==> public final val module: ModuleDescriptor defined in org.jetbrains.kotlin.load.java.lazy.LazyJavaResolverContext[PropertyDescriptorImpl]

'findNonGenericClassAcrossDependencies' @ [139:22] ==> public fun ModuleDescriptor.findNonGenericClassAcrossDependencies(classId: ClassId, notFoundClasses: NotFoundClasses): ClassDescriptor defined in org.jetbrains.kotlin.descriptors in file findClassInModule.kt[SimpleFunctionDescriptorImpl]

'topLevel' @ [140:29] ==> @NotNull public open fun topLevel(@NotNull topLevelFqName: FqName): ClassId defined in org.jetbrains.kotlin.name.ClassId[JavaMethodDescriptor]

'fqName' @ [140:38] ==> value-parameter fqName: FqName defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor.createTypeForMissingDependencies[ValueParameterDescriptorImpl]

'c' @ [141:21] ==> private final val c: LazyJavaResolverContext defined in org.jetbrains.kotlin.load.java.lazy.descriptors.LazyJavaAnnotationDescriptor[PropertyDescriptorImpl]

'components' @ [141:23] ==> public final val components: JavaResolverComponents defined in org.jetbrains.kotlin.load.java.lazy.LazyJavaResolverContext[PropertyDescriptorImpl]

'deserializedDescriptorResolver' @ [141:34] ==> public final val deserializedDescriptorResolver: DeserializedDescriptorResolver defined in org.jetbrains.kotlin.load.java.lazy.JavaResolverComponents[PropertyDescriptorImpl]

'components' @ [141:65] ==> public final lateinit var components: DeserializationComponents defined in org.jetbrains.kotlin.load.kotlin.DeserializedDescriptorResolver[PropertyDescriptorImpl]

'notFoundClasses' @ [141:76] ==> public final val notFoundClasses: NotFoundClasses defined in org.jetbrains.kotlin.serialization.deserialization.DeserializationComponents[PropertyDescriptorImpl]

