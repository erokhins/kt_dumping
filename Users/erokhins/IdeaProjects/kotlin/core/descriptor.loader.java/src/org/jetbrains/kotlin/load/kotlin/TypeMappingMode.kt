'genericArgumentMode' @ [30:74] ==> value-parameter genericArgumentMode: TypeMappingMode? = ... defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.<init>[ValueParameterDescriptorImpl]

'genericArgumentMode' @ [31:70] ==> value-parameter genericArgumentMode: TypeMappingMode? = ... defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.<init>[ValueParameterDescriptorImpl]

'JvmField' @ [37:9] ==> public constructor JvmField() defined in kotlin.jvm.JvmField[DeserializedClassConstructorDescriptor]

'TypeMappingMode' @ [38:32] ==> private constructor TypeMappingMode(needPrimitiveBoxing: Boolean = ..., isForAnnotationParameter: Boolean = ..., skipDeclarationSiteWildcards: Boolean = ..., skipDeclarationSiteWildcardsIfPossible: Boolean = ..., genericArgumentMode: TypeMappingMode? = ..., kotlinCollectionsToJavaCollections: Boolean = ..., genericContravariantArgumentMode: TypeMappingMode? = ..., genericInvariantArgumentMode: TypeMappingMode? = ...) defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode[ClassConstructorDescriptorImpl]

'JvmField' @ [43:9] ==> public constructor JvmField() defined in kotlin.jvm.JvmField[DeserializedClassConstructorDescriptor]

'TypeMappingMode' @ [44:23] ==> private constructor TypeMappingMode(needPrimitiveBoxing: Boolean = ..., isForAnnotationParameter: Boolean = ..., skipDeclarationSiteWildcards: Boolean = ..., skipDeclarationSiteWildcardsIfPossible: Boolean = ..., genericArgumentMode: TypeMappingMode? = ..., kotlinCollectionsToJavaCollections: Boolean = ..., genericContravariantArgumentMode: TypeMappingMode? = ..., genericInvariantArgumentMode: TypeMappingMode? = ...) defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode[ClassConstructorDescriptorImpl]

'GENERIC_ARGUMENT' @ [44:61] ==> @JvmField public final val GENERIC_ARGUMENT: TypeMappingMode defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion[PropertyDescriptorImpl]

'JvmField' @ [50:9] ==> public constructor JvmField() defined in kotlin.jvm.JvmField[DeserializedClassConstructorDescriptor]

'TypeMappingMode' @ [51:26] ==> private constructor TypeMappingMode(needPrimitiveBoxing: Boolean = ..., isForAnnotationParameter: Boolean = ..., skipDeclarationSiteWildcards: Boolean = ..., skipDeclarationSiteWildcardsIfPossible: Boolean = ..., genericArgumentMode: TypeMappingMode? = ..., kotlinCollectionsToJavaCollections: Boolean = ..., genericContravariantArgumentMode: TypeMappingMode? = ..., genericInvariantArgumentMode: TypeMappingMode? = ...) defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode[ClassConstructorDescriptorImpl]

'GENERIC_ARGUMENT' @ [51:101] ==> @JvmField public final val GENERIC_ARGUMENT: TypeMappingMode defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion[PropertyDescriptorImpl]

'JvmField' @ [53:9] ==> public constructor JvmField() defined in kotlin.jvm.JvmField[DeserializedClassConstructorDescriptor]

'TypeMappingMode' @ [54:51] ==> private constructor TypeMappingMode(needPrimitiveBoxing: Boolean = ..., isForAnnotationParameter: Boolean = ..., skipDeclarationSiteWildcards: Boolean = ..., skipDeclarationSiteWildcardsIfPossible: Boolean = ..., genericArgumentMode: TypeMappingMode? = ..., kotlinCollectionsToJavaCollections: Boolean = ..., genericContravariantArgumentMode: TypeMappingMode? = ..., genericInvariantArgumentMode: TypeMappingMode? = ...) defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode[ClassConstructorDescriptorImpl]

'GENERIC_ARGUMENT' @ [56:39] ==> @JvmField public final val GENERIC_ARGUMENT: TypeMappingMode defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion[PropertyDescriptorImpl]

'JvmField' @ [64:9] ==> public constructor JvmField() defined in kotlin.jvm.JvmField[DeserializedClassConstructorDescriptor]

'TypeMappingMode' @ [65:36] ==> private constructor TypeMappingMode(needPrimitiveBoxing: Boolean = ..., isForAnnotationParameter: Boolean = ..., skipDeclarationSiteWildcards: Boolean = ..., skipDeclarationSiteWildcardsIfPossible: Boolean = ..., genericArgumentMode: TypeMappingMode? = ..., kotlinCollectionsToJavaCollections: Boolean = ..., genericContravariantArgumentMode: TypeMappingMode? = ..., genericInvariantArgumentMode: TypeMappingMode? = ...) defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode[ClassConstructorDescriptorImpl]

'TypeMappingMode' @ [68:39] ==> private constructor TypeMappingMode(needPrimitiveBoxing: Boolean = ..., isForAnnotationParameter: Boolean = ..., skipDeclarationSiteWildcards: Boolean = ..., skipDeclarationSiteWildcardsIfPossible: Boolean = ..., genericArgumentMode: TypeMappingMode? = ..., kotlinCollectionsToJavaCollections: Boolean = ..., genericContravariantArgumentMode: TypeMappingMode? = ..., genericInvariantArgumentMode: TypeMappingMode? = ...) defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode[ClassConstructorDescriptorImpl]

'GENERIC_ARGUMENT' @ [68:110] ==> @JvmField public final val GENERIC_ARGUMENT: TypeMappingMode defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion[PropertyDescriptorImpl]

'JvmStatic' @ [71:9] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'if (isAnnotationMethod) VALUE_FOR_ANNOTATION else DEFAULT' @ [74:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: TypeMappingMode, elseBranch: TypeMappingMode): TypeMappingMode[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> TypeMappingMode

'isAnnotationMethod' @ [74:17] ==> value-parameter isAnnotationMethod: Boolean defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion.getModeForReturnTypeNoGeneric[ValueParameterDescriptorImpl]

'VALUE_FOR_ANNOTATION' @ [74:37] ==> @JvmField public final val VALUE_FOR_ANNOTATION: TypeMappingMode defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion[PropertyDescriptorImpl]

'DEFAULT' @ [74:63] ==> @JvmField public final val DEFAULT: TypeMappingMode defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion[PropertyDescriptorImpl]

'JvmStatic' @ [76:9] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'getOptimalModeForSignaturePart' @ [79:13] ==> private final fun getOptimalModeForSignaturePart(type: KotlinType, isForAnnotationParameter: Boolean, canBeUsedInSupertypePosition: Boolean): TypeMappingMode defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion[SimpleFunctionDescriptorImpl]

'type' @ [79:44] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion.getOptimalModeForValueParameter[ValueParameterDescriptorImpl]

'JvmStatic' @ [81:9] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'getOptimalModeForSignaturePart' @ [85:13] ==> private final fun getOptimalModeForSignaturePart(type: KotlinType, isForAnnotationParameter: Boolean, canBeUsedInSupertypePosition: Boolean): TypeMappingMode defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion[SimpleFunctionDescriptorImpl]

'type' @ [85:44] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion.getOptimalModeForReturnType[ValueParameterDescriptorImpl]

'isAnnotationMethod' @ [85:77] ==> value-parameter isAnnotationMethod: Boolean defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion.getOptimalModeForReturnType[ValueParameterDescriptorImpl]

'type' @ [92:17] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion.getOptimalModeForSignaturePart[ValueParameterDescriptorImpl]

'arguments' @ [92:22] ==> public abstract val arguments: List<TypeProjection> defined in org.jetbrains.kotlin.types.KotlinType[PropertyDescriptorImpl]

'isEmpty' @ [92:32] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'DEFAULT' @ [92:50] ==> @JvmField public final val DEFAULT: TypeMappingMode defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion[PropertyDescriptorImpl]

'if (!canBeUsedInSupertypePosition)
                    TypeMappingMode(
                            isForAnnotationParameter = isForAnnotationParameter,
                            skipDeclarationSiteWildcards = false,
                            skipDeclarationSiteWildcardsIfPossible = true)
                else
                    null' @ [95:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: TypeMappingMode?, elseBranch: TypeMappingMode?): TypeMappingMode?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> TypeMappingMode?

'!' @ [95:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'canBeUsedInSupertypePosition' @ [95:22] ==> value-parameter canBeUsedInSupertypePosition: Boolean defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion.getOptimalModeForSignaturePart[ValueParameterDescriptorImpl]

'TypeMappingMode' @ [96:21] ==> private constructor TypeMappingMode(needPrimitiveBoxing: Boolean = ..., isForAnnotationParameter: Boolean = ..., skipDeclarationSiteWildcards: Boolean = ..., skipDeclarationSiteWildcardsIfPossible: Boolean = ..., genericArgumentMode: TypeMappingMode? = ..., kotlinCollectionsToJavaCollections: Boolean = ..., genericContravariantArgumentMode: TypeMappingMode? = ..., genericInvariantArgumentMode: TypeMappingMode? = ...) defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode[ClassConstructorDescriptorImpl]

'isForAnnotationParameter' @ [97:56] ==> value-parameter isForAnnotationParameter: Boolean defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion.getOptimalModeForSignaturePart[ValueParameterDescriptorImpl]

'if (canBeUsedInSupertypePosition)
                        getOptimalModeForSignaturePart(type, isForAnnotationParameter, canBeUsedInSupertypePosition = false)
                    else
                        null' @ [104:21] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: TypeMappingMode?, elseBranch: TypeMappingMode?): TypeMappingMode?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> TypeMappingMode?

'canBeUsedInSupertypePosition' @ [104:25] ==> value-parameter canBeUsedInSupertypePosition: Boolean defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion.getOptimalModeForSignaturePart[ValueParameterDescriptorImpl]

'getOptimalModeForSignaturePart' @ [105:25] ==> private final fun getOptimalModeForSignaturePart(type: KotlinType, isForAnnotationParameter: Boolean, canBeUsedInSupertypePosition: Boolean): TypeMappingMode defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion[SimpleFunctionDescriptorImpl]

'type' @ [105:56] ==> value-parameter type: KotlinType defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion.getOptimalModeForSignaturePart[ValueParameterDescriptorImpl]

'isForAnnotationParameter' @ [105:62] ==> value-parameter isForAnnotationParameter: Boolean defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion.getOptimalModeForSignaturePart[ValueParameterDescriptorImpl]

'TypeMappingMode' @ [109:20] ==> private constructor TypeMappingMode(needPrimitiveBoxing: Boolean = ..., isForAnnotationParameter: Boolean = ..., skipDeclarationSiteWildcards: Boolean = ..., skipDeclarationSiteWildcardsIfPossible: Boolean = ..., genericArgumentMode: TypeMappingMode? = ..., kotlinCollectionsToJavaCollections: Boolean = ..., genericContravariantArgumentMode: TypeMappingMode? = ..., genericInvariantArgumentMode: TypeMappingMode? = ...) defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode[ClassConstructorDescriptorImpl]

'isForAnnotationParameter' @ [110:48] ==> value-parameter isForAnnotationParameter: Boolean defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion.getOptimalModeForSignaturePart[ValueParameterDescriptorImpl]

'!' @ [111:52] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'canBeUsedInSupertypePosition' @ [111:53] ==> value-parameter canBeUsedInSupertypePosition: Boolean defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion.getOptimalModeForSignaturePart[ValueParameterDescriptorImpl]

'contravariantArgumentMode' @ [113:56] ==> val contravariantArgumentMode: TypeMappingMode? defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion.getOptimalModeForSignaturePart[LocalVariableDescriptor]

'invariantArgumentMode' @ [114:52] ==> val invariantArgumentMode: TypeMappingMode? defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion.getOptimalModeForSignaturePart[LocalVariableDescriptor]

'JvmStatic' @ [117:9] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'TypeMappingMode' @ [122:13] ==> private constructor TypeMappingMode(needPrimitiveBoxing: Boolean = ..., isForAnnotationParameter: Boolean = ..., skipDeclarationSiteWildcards: Boolean = ..., skipDeclarationSiteWildcardsIfPossible: Boolean = ..., genericArgumentMode: TypeMappingMode? = ..., kotlinCollectionsToJavaCollections: Boolean = ..., genericContravariantArgumentMode: TypeMappingMode? = ..., genericInvariantArgumentMode: TypeMappingMode? = ...) defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode[ClassConstructorDescriptorImpl]

'isForAnnotationParameter' @ [123:44] ==> value-parameter isForAnnotationParameter: Boolean defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion.createWithConstantDeclarationSiteWildcardsMode[ValueParameterDescriptorImpl]

'skipDeclarationSiteWildcards' @ [124:48] ==> value-parameter skipDeclarationSiteWildcards: Boolean defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion.createWithConstantDeclarationSiteWildcardsMode[ValueParameterDescriptorImpl]

'fallbackMode' @ [125:39] ==> value-parameter fallbackMode: TypeMappingMode? = ... defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.Companion.createWithConstantDeclarationSiteWildcardsMode[ValueParameterDescriptorImpl]

'when (effectiveVariance) {
                Variance.IN_VARIANCE -> genericContravariantArgumentMode ?: this
                Variance.INVARIANT -> genericInvariantArgumentMode ?: this
                else -> genericArgumentMode ?: this
            }' @ [129:13] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: TypeMappingMode, entry1: TypeMappingMode, entry2: TypeMappingMode): TypeMappingMode[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> TypeMappingMode

'effectiveVariance' @ [129:19] ==> value-parameter effectiveVariance: Variance defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode.toGenericArgumentMode[ValueParameterDescriptorImpl]

'IN_VARIANCE' @ [130:26] ==> enum entry IN_VARIANCE defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'genericContravariantArgumentMode' @ [130:41] ==> private final val genericContravariantArgumentMode: TypeMappingMode? defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode[PropertyDescriptorImpl]

'this' @ [130:77] ==> <this> defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode[LazyClassReceiverParameterDescriptor]

'INVARIANT' @ [131:26] ==> enum entry INVARIANT defined in org.jetbrains.kotlin.types.Variance[FakeCallableDescriptorForObject]

'genericInvariantArgumentMode' @ [131:39] ==> private final val genericInvariantArgumentMode: TypeMappingMode? defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode[PropertyDescriptorImpl]

'this' @ [131:71] ==> <this> defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode[LazyClassReceiverParameterDescriptor]

'genericArgumentMode' @ [132:25] ==> private final val genericArgumentMode: TypeMappingMode? defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode[PropertyDescriptorImpl]

'this' @ [132:48] ==> <this> defined in org.jetbrains.kotlin.load.kotlin.TypeMappingMode[LazyClassReceiverParameterDescriptor]

