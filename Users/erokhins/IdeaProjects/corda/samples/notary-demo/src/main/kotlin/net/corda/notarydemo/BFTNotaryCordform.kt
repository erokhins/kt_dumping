'BFTNotaryCordform' @ [20:33] ==> public object BFTNotaryCordform : CordformDefinition defined in net.corda.notarydemo in file BFTNotaryCordform.kt[FakeCallableDescriptorForObject]

'runNodes' @ [20:51] ==> public fun CordformDefinition.runNodes(): Unit defined in net.corda.demorun[SimpleFunctionDescriptorImpl]

'createNotaryNames' @ [23:27] ==> internal fun createNotaryNames(clusterSize: Int): List<X500Name> defined in net.corda.notarydemo[SimpleFunctionDescriptorImpl]

'clusterSize' @ [23:45] ==> private val clusterSize: Int defined in net.corda.notarydemo in file BFTNotaryCordform.kt[PropertyDescriptorImpl]

'CordformDefinition' @ [25:28] ==> public constructor CordformDefinition(p0: (Path..Path?), p1: (X500Name..X500Name?)) defined in net.corda.cordform.CordformDefinition[JavaClassConstructorDescriptor]

'/' @ [25:47] ==> public operator fun String.div(other: String): Path defined in net.corda.core.internal[DeserializedSimpleFunctionDescriptor]

'notaryNames' @ [25:78] ==> private val notaryNames: List<X500Name> defined in net.corda.notarydemo in file BFTNotaryCordform.kt[PropertyDescriptorImpl]

'X500Name' @ [26:31] ==> public constructor X500Name(p0: (String..String?)) defined in org.bouncycastle.asn1.x500.X500Name[JavaClassConstructorDescriptor]

'ServiceInfo' @ [27:37] ==> public constructor ServiceInfo(type: ServiceType, name: X500Name? = ...) defined in net.corda.core.node.services.ServiceInfo[DeserializedClassConstructorDescriptor]

'BFTNonValidatingNotaryService' @ [27:49] ==> public companion object defined in net.corda.node.services.transactions.BFTNonValidatingNotaryService[FakeCallableDescriptorForObject]

'type' @ [27:79] ==> public final val type: ServiceType defined in net.corda.node.services.transactions.BFTNonValidatingNotaryService.Companion[DeserializedPropertyDescriptor]

'clusterName' @ [27:85] ==> private final val clusterName: X500Name defined in net.corda.notarydemo.BFTNotaryCordform[PropertyDescriptorImpl]

'node' @ [30:9] ==> public fun CordformDefinition.node(configure: CordformNode.() -> Unit): Unit defined in net.corda.demorun.util[SimpleFunctionDescriptorImpl]

'name' @ [31:13] ==> public fun CordformNode.name(name: X500Name): Unit defined in net.corda.demorun.util[SimpleFunctionDescriptorImpl]

'ALICE' @ [31:18] ==> public val ALICE: Party defined in net.corda.testing[DeserializedPropertyDescriptor]

'name' @ [31:24] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'p2pPort' @ [32:13] ==> public open fun p2pPort(p0: (Int..Int?)): Unit defined in net.corda.cordform.CordformNode[JavaMethodDescriptor]

'rpcPort' @ [33:13] ==> public open fun rpcPort(p0: (Int..Int?)): Unit defined in net.corda.cordform.CordformNode[JavaMethodDescriptor]

'rpcUsers' @ [34:13] ==> public fun CordformNode.rpcUsers(vararg users: User): Unit defined in net.corda.demorun.util[SimpleFunctionDescriptorImpl]

'notaryDemoUser' @ [34:22] ==> public val notaryDemoUser: User defined in net.corda.notarydemo in file SingleNotaryCordform.kt[PropertyDescriptorImpl]

'node' @ [36:9] ==> public fun CordformDefinition.node(configure: CordformNode.() -> Unit): Unit defined in net.corda.demorun.util[SimpleFunctionDescriptorImpl]

'name' @ [37:13] ==> public fun CordformNode.name(name: X500Name): Unit defined in net.corda.demorun.util[SimpleFunctionDescriptorImpl]

'BOB' @ [37:18] ==> public val BOB: Party defined in net.corda.testing[DeserializedPropertyDescriptor]

'name' @ [37:22] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'p2pPort' @ [38:13] ==> public open fun p2pPort(p0: (Int..Int?)): Unit defined in net.corda.cordform.CordformNode[JavaMethodDescriptor]

'rpcPort' @ [39:13] ==> public open fun rpcPort(p0: (Int..Int?)): Unit defined in net.corda.cordform.CordformNode[JavaMethodDescriptor]

'until' @ [41:33] ==> public infix fun Int.until(to: Int): IntRange defined in kotlin.ranges[DeserializedSimpleFunctionDescriptor]

'clusterSize' @ [41:41] ==> private val clusterSize: Int defined in net.corda.notarydemo in file BFTNotaryCordform.kt[PropertyDescriptorImpl]

'stream' @ [41:54] ==> public fun IntProgression.stream(parallel: Boolean = ...): IntStream defined in net.corda.core.internal[DeserializedSimpleFunctionDescriptor]

'mapToObj' @ [41:63] ==> public final fun <U : (Any..Any?)> mapToObj(p0: ((Int) -> (NetworkHostAndPort..NetworkHostAndPort?)..((Int) -> (NetworkHostAndPort..NetworkHostAndPort?))?)): (Stream<(NetworkHostAndPort..NetworkHostAndPort?)>..Stream<(NetworkHostAndPort..NetworkHostAndPort?)>?) defined in java.util.stream.IntStream[MyFunctionDescriptor]
Inferred types:
    <U : (Any..Any?)> -> NetworkHostAndPort

'NetworkHostAndPort' @ [41:74] ==> public constructor NetworkHostAndPort(host: String, port: Int) defined in net.corda.core.utilities.NetworkHostAndPort[DeserializedClassConstructorDescriptor]

'+' @ [41:106] ==> public final operator fun plus(other: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'it' @ [41:114] ==> value-parameter it: Int defined in net.corda.notarydemo.BFTNotaryCordform.<init>.<anonymous>[ValueParameterDescriptorImpl]

'toTypedArray' @ [41:125] ==> public inline fun <reified T> Stream<out (NetworkHostAndPort..NetworkHostAndPort?)>.toTypedArray(): Array<(NetworkHostAndPort..NetworkHostAndPort?)> defined in net.corda.core.internal[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T> -> (net.corda.core.utilities.NetworkHostAndPort..net.corda.core.utilities.NetworkHostAndPort?)

'node' @ [42:78] ==> public fun CordformDefinition.node(configure: CordformNode.() -> Unit): Unit defined in net.corda.demorun.util[SimpleFunctionDescriptorImpl]

'name' @ [43:13] ==> public fun CordformNode.name(name: X500Name): Unit defined in net.corda.demorun.util[SimpleFunctionDescriptorImpl]

'notaryNames' @ [43:18] ==> private val notaryNames: List<X500Name> defined in net.corda.notarydemo in file BFTNotaryCordform.kt[PropertyDescriptorImpl]

'replicaId' @ [43:30] ==> value-parameter replicaId: Int defined in net.corda.notarydemo.BFTNotaryCordform.<init>.notaryNode[ValueParameterDescriptorImpl]

'advertisedServices' @ [44:13] ==> public fun CordformNode.advertisedServices(vararg services: ServiceInfo): Unit defined in net.corda.demorun.util[SimpleFunctionDescriptorImpl]

'advertisedService' @ [44:32] ==> private final val advertisedService: ServiceInfo defined in net.corda.notarydemo.BFTNotaryCordform[PropertyDescriptorImpl]

'notaryClusterAddresses' @ [45:13] ==> public fun CordformNode.notaryClusterAddresses(vararg addresses: NetworkHostAndPort): Unit defined in net.corda.demorun.util[SimpleFunctionDescriptorImpl]

'clusterAddresses' @ [45:37] ==> val clusterAddresses: Array<(NetworkHostAndPort..NetworkHostAndPort?)> defined in net.corda.notarydemo.BFTNotaryCordform.<init>[LocalVariableDescriptor]

'bftReplicaId' @ [46:13] ==> public open fun bftReplicaId(p0: (Int..Int?)): Unit defined in net.corda.cordform.CordformNode[JavaMethodDescriptor]

'replicaId' @ [46:26] ==> value-parameter replicaId: Int defined in net.corda.notarydemo.BFTNotaryCordform.<init>.notaryNode[ValueParameterDescriptorImpl]

'invoke' @ [47:13] ==> public abstract operator fun CordformNode.invoke(): Unit defined in kotlin.Function1[FunctionInvokeDescriptor]

'notaryNode' @ [49:9] ==> local final fun notaryNode(replicaId: Int, configure: CordformNode.() -> Unit): Unit defined in net.corda.notarydemo.BFTNotaryCordform.<init>[SimpleFunctionDescriptorImpl]

'p2pPort' @ [50:13] ==> public open fun p2pPort(p0: (Int..Int?)): Unit defined in net.corda.cordform.CordformNode[JavaMethodDescriptor]

'rpcPort' @ [51:13] ==> public open fun rpcPort(p0: (Int..Int?)): Unit defined in net.corda.cordform.CordformNode[JavaMethodDescriptor]

'notaryNode' @ [53:9] ==> local final fun notaryNode(replicaId: Int, configure: CordformNode.() -> Unit): Unit defined in net.corda.notarydemo.BFTNotaryCordform.<init>[SimpleFunctionDescriptorImpl]

'p2pPort' @ [54:13] ==> public open fun p2pPort(p0: (Int..Int?)): Unit defined in net.corda.cordform.CordformNode[JavaMethodDescriptor]

'rpcPort' @ [55:13] ==> public open fun rpcPort(p0: (Int..Int?)): Unit defined in net.corda.cordform.CordformNode[JavaMethodDescriptor]

'notaryNode' @ [57:9] ==> local final fun notaryNode(replicaId: Int, configure: CordformNode.() -> Unit): Unit defined in net.corda.notarydemo.BFTNotaryCordform.<init>[SimpleFunctionDescriptorImpl]

'p2pPort' @ [58:13] ==> public open fun p2pPort(p0: (Int..Int?)): Unit defined in net.corda.cordform.CordformNode[JavaMethodDescriptor]

'rpcPort' @ [59:13] ==> public open fun rpcPort(p0: (Int..Int?)): Unit defined in net.corda.cordform.CordformNode[JavaMethodDescriptor]

'notaryNode' @ [61:9] ==> local final fun notaryNode(replicaId: Int, configure: CordformNode.() -> Unit): Unit defined in net.corda.notarydemo.BFTNotaryCordform.<init>[SimpleFunctionDescriptorImpl]

'p2pPort' @ [62:13] ==> public open fun p2pPort(p0: (Int..Int?)): Unit defined in net.corda.cordform.CordformNode[JavaMethodDescriptor]

'rpcPort' @ [63:13] ==> public open fun rpcPort(p0: (Int..Int?)): Unit defined in net.corda.cordform.CordformNode[JavaMethodDescriptor]

'ServiceIdentityGenerator' @ [68:9] ==> public object ServiceIdentityGenerator defined in net.corda.node.utilities[FakeCallableDescriptorForObject]

'generateToDisk' @ [68:34] ==> public final fun generateToDisk(dirs: List<Path>, serviceId: String, serviceName: X500Name, threshold: Int = ...): Party defined in net.corda.node.utilities.ServiceIdentityGenerator[DeserializedSimpleFunctionDescriptor]

'notaryNames' @ [68:49] ==> private val notaryNames: List<X500Name> defined in net.corda.notarydemo in file BFTNotaryCordform.kt[PropertyDescriptorImpl]

'map' @ [68:61] ==> public inline fun <T, R> Iterable<X500Name>.map(transform: (X500Name) -> (Path..Path?)): List<(Path..Path?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> X500Name
    <R> -> (java.nio.file.Path..java.nio.file.Path?)

'context' @ [68:67] ==> value-parameter context: CordformContext defined in net.corda.notarydemo.BFTNotaryCordform.setup[ValueParameterDescriptorImpl]

'baseDirectory' @ [68:75] ==> public abstract fun baseDirectory(p0: (X500Name..X500Name?)): (Path..Path?) defined in net.corda.cordform.CordformContext[JavaMethodDescriptor]

'it' @ [68:89] ==> value-parameter it: X500Name defined in net.corda.notarydemo.BFTNotaryCordform.setup.<anonymous>[ValueParameterDescriptorImpl]

'advertisedService' @ [68:96] ==> private final val advertisedService: ServiceInfo defined in net.corda.notarydemo.BFTNotaryCordform[PropertyDescriptorImpl]

'type' @ [68:114] ==> public final val type: ServiceType defined in net.corda.core.node.services.ServiceInfo[DeserializedPropertyDescriptor]

'id' @ [68:119] ==> public final val id: String defined in net.corda.core.node.services.ServiceType[DeserializedPropertyDescriptor]

'clusterName' @ [68:123] ==> private final val clusterName: X500Name defined in net.corda.notarydemo.BFTNotaryCordform[PropertyDescriptorImpl]

'minCorrectReplicas' @ [68:136] ==> public fun minCorrectReplicas(clusterSize: Int): Int defined in net.corda.node.services.transactions[DeserializedSimpleFunctionDescriptor]

'clusterSize' @ [68:155] ==> private val clusterSize: Int defined in net.corda.notarydemo in file BFTNotaryCordform.kt[PropertyDescriptorImpl]

