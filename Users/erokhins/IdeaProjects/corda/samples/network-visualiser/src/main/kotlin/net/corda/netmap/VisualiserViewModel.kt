'name' @ [23:20] ==> public final val name: String defined in net.corda.netmap.VisualiserViewModel.Style[DeserializedPropertyDescriptor]

'toLowerCase' @ [23:25] ==> @InlineOnly public inline fun String.toLowerCase(): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'capitalize' @ [23:39] ==> public fun String.capitalize(): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'component1' @ [31:18] ==> public final operator fun component1(): Double defined in net.corda.core.node.ScreenCoordinate[DeserializedSimpleFunctionDescriptor]

'component2' @ [31:21] ==> public final operator fun component2(): Double defined in net.corda.core.node.ScreenCoordinate[DeserializedSimpleFunctionDescriptor]

'invoke' @ [31:26] ==> public abstract operator fun invoke(node: @ParameterName MockNetwork.MockNode): ScreenCoordinate defined in kotlin.Function1[FunctionInvokeDescriptor]

'node' @ [31:37] ==> public final val node: MockNetwork.MockNode defined in net.corda.netmap.VisualiserViewModel.NodeWidget[PropertyDescriptorImpl]

'innerDot' @ [32:13] ==> public final val innerDot: Circle defined in net.corda.netmap.VisualiserViewModel.NodeWidget[PropertyDescriptorImpl]

'centerX' @ [32:22] ==> public final var Circle.centerX: Double[MyPropertyDescriptor]

'x' @ [32:32] ==> val x: Double defined in net.corda.netmap.VisualiserViewModel.NodeWidget.position[LocalVariableDescriptor]

'innerDot' @ [33:13] ==> public final val innerDot: Circle defined in net.corda.netmap.VisualiserViewModel.NodeWidget[PropertyDescriptorImpl]

'centerY' @ [33:22] ==> public final var Circle.centerY: Double[MyPropertyDescriptor]

'y' @ [33:32] ==> val y: Double defined in net.corda.netmap.VisualiserViewModel.NodeWidget.position[LocalVariableDescriptor]

'outerDot' @ [34:13] ==> public final val outerDot: Circle defined in net.corda.netmap.VisualiserViewModel.NodeWidget[PropertyDescriptorImpl]

'centerX' @ [34:22] ==> public final var Circle.centerX: Double[MyPropertyDescriptor]

'x' @ [34:32] ==> val x: Double defined in net.corda.netmap.VisualiserViewModel.NodeWidget.position[LocalVariableDescriptor]

'outerDot' @ [35:13] ==> public final val outerDot: Circle defined in net.corda.netmap.VisualiserViewModel.NodeWidget[PropertyDescriptorImpl]

'centerY' @ [35:22] ==> public final var Circle.centerY: Double[MyPropertyDescriptor]

'y' @ [35:32] ==> val y: Double defined in net.corda.netmap.VisualiserViewModel.NodeWidget.position[LocalVariableDescriptor]

'longPulseDot' @ [36:13] ==> public final val longPulseDot: Circle defined in net.corda.netmap.VisualiserViewModel.NodeWidget[PropertyDescriptorImpl]

'centerX' @ [36:26] ==> public final var Circle.centerX: Double[MyPropertyDescriptor]

'x' @ [36:36] ==> val x: Double defined in net.corda.netmap.VisualiserViewModel.NodeWidget.position[LocalVariableDescriptor]

'longPulseDot' @ [37:13] ==> public final val longPulseDot: Circle defined in net.corda.netmap.VisualiserViewModel.NodeWidget[PropertyDescriptorImpl]

'centerY' @ [37:26] ==> public final var Circle.centerY: Double[MyPropertyDescriptor]

'y' @ [37:36] ==> val y: Double defined in net.corda.netmap.VisualiserViewModel.NodeWidget.position[LocalVariableDescriptor]

'nameLabel' @ [38:14] ==> public final val nameLabel: Label defined in net.corda.netmap.VisualiserViewModel.NodeWidget[PropertyDescriptorImpl]

'parent' @ [38:24] ==> public final val Label.parent: (Parent..Parent?)[MyPropertyDescriptor]

'relocate' @ [38:45] ==> public open fun relocate(p0: Double, p1: Double): Unit defined in javafx.scene.layout.StackPane[JavaMethodDescriptor]

'x' @ [38:54] ==> val x: Double defined in net.corda.netmap.VisualiserViewModel.NodeWidget.position[LocalVariableDescriptor]

'y' @ [38:65] ==> val y: Double defined in net.corda.netmap.VisualiserViewModel.NodeWidget.position[LocalVariableDescriptor]

'statusLabel' @ [39:14] ==> public final val statusLabel: Label defined in net.corda.netmap.VisualiserViewModel.NodeWidget[PropertyDescriptorImpl]

'parent' @ [39:26] ==> public final val Label.parent: (Parent..Parent?)[MyPropertyDescriptor]

'relocate' @ [39:47] ==> public open fun relocate(p0: Double, p1: Double): Unit defined in javafx.scene.layout.StackPane[JavaMethodDescriptor]

'x' @ [39:56] ==> val x: Double defined in net.corda.netmap.VisualiserViewModel.NodeWidget.position[LocalVariableDescriptor]

'y' @ [39:66] ==> val y: Double defined in net.corda.netmap.VisualiserViewModel.NodeWidget.position[LocalVariableDescriptor]

'IRSSimulation' @ [45:22] ==> public constructor IRSSimulation(networkSendManuallyPumped: Boolean, runAsync: Boolean, latencyInjector: InMemoryMessagingNetwork.LatencyCalculator?) defined in net.corda.netmap.simulation.IRSSimulation[ClassConstructorDescriptorImpl]

'HashMap' @ [47:24] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> ProgressTracker
    <V : (Any..Any?)> -> TrackerWidget

'ArrayList' @ [48:24] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> ProgressTracker

'HashMap' @ [49:26] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> MockNode
    <V : (Any..Any?)> -> NodeWidget

'millis' @ [54:43] ==> public open fun millis(p0: Double): (Duration..Duration?) defined in javafx.util.Duration[JavaMethodDescriptor]

'Paused' @ [55:111] ==> public constructor Paused() defined in net.corda.netmap.NetworkMapVisualiser.RunningPausedState.Paused[ClassConstructorDescriptorImpl]

'MAP' @ [57:37] ==> enum entry MAP defined in net.corda.netmap.VisualiserViewModel.Style[FakeCallableDescriptorForObject]

'field' @ [59:13] ==> var field: VisualiserViewModel.Style defined in net.corda.netmap.VisualiserViewModel.<set-displayStyle>[SyntheticFieldDescriptor]

'value' @ [59:21] ==> value-parameter value: VisualiserViewModel.Style defined in net.corda.netmap.VisualiserViewModel.<set-displayStyle>[ValueParameterDescriptorImpl]

'view' @ [60:13] ==> internal final lateinit var view: VisualiserView defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'updateDisplayStyle' @ [60:18] ==> public final fun updateDisplayStyle(displayStyle: VisualiserViewModel.Style): Unit defined in net.corda.netmap.VisualiserView[SimpleFunctionDescriptorImpl]

'value' @ [60:37] ==> value-parameter value: VisualiserViewModel.Style defined in net.corda.netmap.VisualiserViewModel.<set-displayStyle>[ValueParameterDescriptorImpl]

'repositionNodes' @ [61:13] ==> public final fun repositionNodes(): Unit defined in net.corda.netmap.VisualiserViewModel[SimpleFunctionDescriptorImpl]

'view' @ [62:13] ==> internal final lateinit var view: VisualiserView defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'bindHideButtonPosition' @ [62:18] ==> public final fun bindHideButtonPosition(): Unit defined in net.corda.netmap.VisualiserView[SimpleFunctionDescriptorImpl]

'component1' @ [66:15] ==> public final operator fun component1(): Int defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'component2' @ [66:22] ==> public final operator fun component2(): Simulation.SimulatedNode defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'simulation' @ [66:31] ==> public final var simulation: IRSSimulation defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'banks' @ [66:42] ==> public final val banks: List<Simulation.SimulatedNode> defined in net.corda.netmap.simulation.IRSSimulation[PropertyDescriptorImpl]

'withIndex' @ [66:48] ==> public fun <T> Iterable<Simulation.SimulatedNode>.withIndex(): Iterable<IndexedValue<Simulation.SimulatedNode>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SimulatedNode

'nodesToWidgets' @ [67:13] ==> public final val nodesToWidgets: HashMap<MockNetwork.MockNode, VisualiserViewModel.NodeWidget> defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'bank' @ [67:28] ==> val bank: Simulation.SimulatedNode defined in net.corda.netmap.VisualiserViewModel.repositionNodes[LocalVariableDescriptor]

'position' @ [67:36] ==> public final fun position(nodeCoords: (node: MockNetwork.MockNode) -> ScreenCoordinate): Unit defined in net.corda.netmap.VisualiserViewModel.NodeWidget[SimpleFunctionDescriptorImpl]

'when (displayStyle) {
                Style.MAP -> { node -> nodeMapCoords(node) }
                Style.CIRCLE -> { _ -> nodeCircleCoords(NetworkMapVisualiser.NodeType.BANK, index) }
            }' @ [67:45] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: (node: MockNetwork.MockNode) -> ScreenCoordinate, entry1: (node: MockNetwork.MockNode) -> ScreenCoordinate): (node: MockNetwork.MockNode) -> ScreenCoordinate[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Function1<[@kotlin.ParameterName] MockNode, ScreenCoordinate>

'displayStyle' @ [67:51] ==> public final var displayStyle: VisualiserViewModel.Style defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'MAP' @ [68:23] ==> enum entry MAP defined in net.corda.netmap.VisualiserViewModel.Style[FakeCallableDescriptorForObject]

'nodeMapCoords' @ [68:40] ==> public final fun nodeMapCoords(node: MockNetwork.MockNode): ScreenCoordinate defined in net.corda.netmap.VisualiserViewModel[SimpleFunctionDescriptorImpl]

'node' @ [68:54] ==> value-parameter node: MockNetwork.MockNode defined in net.corda.netmap.VisualiserViewModel.repositionNodes.<anonymous>[ValueParameterDescriptorImpl]

'CIRCLE' @ [69:23] ==> enum entry CIRCLE defined in net.corda.netmap.VisualiserViewModel.Style[FakeCallableDescriptorForObject]

'nodeCircleCoords' @ [69:40] ==> public final fun nodeCircleCoords(type: NetworkMapVisualiser.NodeType, index: Int): ScreenCoordinate defined in net.corda.netmap.VisualiserViewModel[SimpleFunctionDescriptorImpl]

'BANK' @ [69:87] ==> enum entry BANK defined in net.corda.netmap.NetworkMapVisualiser.NodeType[FakeCallableDescriptorForObject]

'index' @ [69:93] ==> val index: Int defined in net.corda.netmap.VisualiserViewModel.repositionNodes[LocalVariableDescriptor]

'component1' @ [72:15] ==> public final operator fun component1(): Int defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'component2' @ [72:22] ==> public final operator fun component2(): Simulation.SimulatedNode defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'iterator' @ [72:42] ==> public abstract operator fun iterator(): Iterator<IndexedValue<Simulation.SimulatedNode>> defined in kotlin.collections.Iterable[DeserializedSimpleFunctionDescriptor]

'simulation' @ [72:43] ==> public final var simulation: IRSSimulation defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'serviceProviders' @ [72:54] ==> public final val serviceProviders: List<Simulation.SimulatedNode> defined in net.corda.netmap.simulation.IRSSimulation[PropertyDescriptorImpl]

'simulation' @ [72:73] ==> public final var simulation: IRSSimulation defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'regulators' @ [72:84] ==> public final val regulators: List<Simulation.SimulatedNode> defined in net.corda.netmap.simulation.IRSSimulation[PropertyDescriptorImpl]

'withIndex' @ [72:96] ==> public fun <T> Iterable<Simulation.SimulatedNode>.withIndex(): Iterable<IndexedValue<Simulation.SimulatedNode>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SimulatedNode

'nodesToWidgets' @ [73:13] ==> public final val nodesToWidgets: HashMap<MockNetwork.MockNode, VisualiserViewModel.NodeWidget> defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'serviceProvider' @ [73:28] ==> val serviceProvider: Simulation.SimulatedNode defined in net.corda.netmap.VisualiserViewModel.repositionNodes[LocalVariableDescriptor]

'position' @ [73:47] ==> public final fun position(nodeCoords: (node: MockNetwork.MockNode) -> ScreenCoordinate): Unit defined in net.corda.netmap.VisualiserViewModel.NodeWidget[SimpleFunctionDescriptorImpl]

'when (displayStyle) {
                Style.MAP -> { node -> nodeMapCoords(node) }
                Style.CIRCLE -> { _ -> nodeCircleCoords(NetworkMapVisualiser.NodeType.SERVICE, index) }
            }' @ [73:56] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: (node: MockNetwork.MockNode) -> ScreenCoordinate, entry1: (node: MockNetwork.MockNode) -> ScreenCoordinate): (node: MockNetwork.MockNode) -> ScreenCoordinate[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Function1<[@kotlin.ParameterName] MockNode, ScreenCoordinate>

'displayStyle' @ [73:62] ==> public final var displayStyle: VisualiserViewModel.Style defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'MAP' @ [74:23] ==> enum entry MAP defined in net.corda.netmap.VisualiserViewModel.Style[FakeCallableDescriptorForObject]

'nodeMapCoords' @ [74:40] ==> public final fun nodeMapCoords(node: MockNetwork.MockNode): ScreenCoordinate defined in net.corda.netmap.VisualiserViewModel[SimpleFunctionDescriptorImpl]

'node' @ [74:54] ==> value-parameter node: MockNetwork.MockNode defined in net.corda.netmap.VisualiserViewModel.repositionNodes.<anonymous>[ValueParameterDescriptorImpl]

'CIRCLE' @ [75:23] ==> enum entry CIRCLE defined in net.corda.netmap.VisualiserViewModel.Style[FakeCallableDescriptorForObject]

'nodeCircleCoords' @ [75:40] ==> public final fun nodeCircleCoords(type: NetworkMapVisualiser.NodeType, index: Int): ScreenCoordinate defined in net.corda.netmap.VisualiserViewModel[SimpleFunctionDescriptorImpl]

'SERVICE' @ [75:87] ==> enum entry SERVICE defined in net.corda.netmap.NetworkMapVisualiser.NodeType[FakeCallableDescriptorForObject]

'index' @ [75:96] ==> val index: Int defined in net.corda.netmap.VisualiserViewModel.repositionNodes[LocalVariableDescriptor]

'node' @ [88:20] ==> value-parameter node: MockNetwork.MockNode defined in net.corda.netmap.VisualiserViewModel.nodeMapCoords[ValueParameterDescriptorImpl]

'place' @ [88:25] ==> public final val place: WorldMapLocation defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'coordinate' @ [88:31] ==> public final val coordinate: WorldCoordinate defined in net.corda.core.node.WorldMapLocation[DeserializedPropertyDescriptor]

'project' @ [88:42] ==> public final fun project(screenWidth: Double, screenHeight: Double, topLatitude: Double, bottomLatitude: Double, leftLongitude: Double, rightLongitude: Double): ScreenCoordinate defined in net.corda.core.node.WorldCoordinate[DeserializedSimpleFunctionDescriptor]

'view' @ [88:50] ==> internal final lateinit var view: VisualiserView defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'mapImage' @ [88:55] ==> public final val mapImage: ImageView defined in net.corda.netmap.VisualiserView[PropertyDescriptorImpl]

'fitWidth' @ [88:64] ==> public final var ImageView.fitWidth: Double[MyPropertyDescriptor]

'view' @ [88:74] ==> internal final lateinit var view: VisualiserView defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'mapImage' @ [88:79] ==> public final val mapImage: ImageView defined in net.corda.netmap.VisualiserView[PropertyDescriptorImpl]

'fitHeight' @ [88:88] ==> public final var ImageView.fitHeight: Double[MyPropertyDescriptor]

'-' @ [88:117] ==> public final operator fun unaryMinus(): Double defined in kotlin.Double[DeserializedSimpleFunctionDescriptor]

'Exception' @ [90:19] ==> public final fun <init>(p0: (String..String?), p1: (Throwable..Throwable?)): Exception /* = Exception */ defined in kotlin.Exception[TypeAliasConstructorDescriptorImpl]

'node' @ [90:47] ==> value-parameter node: MockNetwork.MockNode defined in net.corda.netmap.VisualiserViewModel.nodeMapCoords[ValueParameterDescriptorImpl]

'info' @ [90:52] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [90:57] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'e' @ [90:74] ==> val e: Exception /* = Exception */ defined in net.corda.netmap.VisualiserViewModel.nodeMapCoords[LocalVariableDescriptor]

'when (type) {
            NetworkMapVisualiser.NodeType.BANK -> 2 * Math.PI / bankCount
            NetworkMapVisualiser.NodeType.SERVICE -> (2 * Math.PI / serviceCount)
        }' @ [95:31] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Double, entry1: Double): Double[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Double

'type' @ [95:37] ==> value-parameter type: NetworkMapVisualiser.NodeType defined in net.corda.netmap.VisualiserViewModel.nodeCircleCoords[ValueParameterDescriptorImpl]

'BANK' @ [96:43] ==> enum entry BANK defined in net.corda.netmap.NetworkMapVisualiser.NodeType[FakeCallableDescriptorForObject]

'*' @ [96:51] ==> public final operator fun times(other: Double): Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'PI' @ [96:60] ==> public const final val PI: Double defined in java.lang.Math[JavaPropertyDescriptor]

'bankCount' @ [96:65] ==> public final var bankCount: Int defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'SERVICE' @ [97:43] ==> enum entry SERVICE defined in net.corda.netmap.NetworkMapVisualiser.NodeType[FakeCallableDescriptorForObject]

'*' @ [97:55] ==> public final operator fun times(other: Double): Double defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'PI' @ [97:64] ==> public const final val PI: Double defined in java.lang.Math[JavaPropertyDescriptor]

'serviceCount' @ [97:69] ==> public final var serviceCount: Int defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'stepRad' @ [99:34] ==> val stepRad: Double defined in net.corda.netmap.VisualiserViewModel.nodeCircleCoords[LocalVariableDescriptor]

'index' @ [99:44] ==> value-parameter index: Int defined in net.corda.netmap.VisualiserViewModel.nodeCircleCoords[ValueParameterDescriptorImpl]

'when (type) {
            NetworkMapVisualiser.NodeType.BANK -> 0.0
            NetworkMapVisualiser.NodeType.SERVICE -> Math.PI / 2
        }' @ [99:52] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Double, entry1: Double): Double[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Double

'type' @ [99:58] ==> value-parameter type: NetworkMapVisualiser.NodeType defined in net.corda.netmap.VisualiserViewModel.nodeCircleCoords[ValueParameterDescriptorImpl]

'BANK' @ [100:43] ==> enum entry BANK defined in net.corda.netmap.NetworkMapVisualiser.NodeType[FakeCallableDescriptorForObject]

'SERVICE' @ [101:43] ==> enum entry SERVICE defined in net.corda.netmap.NetworkMapVisualiser.NodeType[FakeCallableDescriptorForObject]

'/' @ [101:54] ==> public final operator fun div(other: Int): Double defined in kotlin.Double[DeserializedSimpleFunctionDescriptor]

'PI' @ [101:59] ==> public const final val PI: Double defined in java.lang.Math[JavaPropertyDescriptor]

'when (type) {
            NetworkMapVisualiser.NodeType.BANK -> Math.min(view.stageWidth, view.stageHeight) / 3.5
            NetworkMapVisualiser.NodeType.SERVICE -> Math.min(view.stageWidth, view.stageHeight) / 8
        }' @ [103:22] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Double, entry1: Double): Double[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Double

'type' @ [103:28] ==> value-parameter type: NetworkMapVisualiser.NodeType defined in net.corda.netmap.VisualiserViewModel.nodeCircleCoords[ValueParameterDescriptorImpl]

'BANK' @ [104:43] ==> enum entry BANK defined in net.corda.netmap.NetworkMapVisualiser.NodeType[FakeCallableDescriptorForObject]

'/' @ [104:51] ==> public final operator fun div(other: Double): Double defined in kotlin.Double[DeserializedSimpleFunctionDescriptor]

'min' @ [104:56] ==> public open fun min(p0: Double, p1: Double): Double defined in java.lang.Math[JavaMethodDescriptor]

'view' @ [104:60] ==> internal final lateinit var view: VisualiserView defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'stageWidth' @ [104:65] ==> public final val stageWidth: Double defined in net.corda.netmap.VisualiserView[PropertyDescriptorImpl]

'view' @ [104:77] ==> internal final lateinit var view: VisualiserView defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'stageHeight' @ [104:82] ==> public final val stageHeight: Double defined in net.corda.netmap.VisualiserView[PropertyDescriptorImpl]

'SERVICE' @ [105:43] ==> enum entry SERVICE defined in net.corda.netmap.NetworkMapVisualiser.NodeType[FakeCallableDescriptorForObject]

'/' @ [105:54] ==> public final operator fun div(other: Int): Double defined in kotlin.Double[DeserializedSimpleFunctionDescriptor]

'min' @ [105:59] ==> public open fun min(p0: Double, p1: Double): Double defined in java.lang.Math[JavaMethodDescriptor]

'view' @ [105:63] ==> internal final lateinit var view: VisualiserView defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'stageWidth' @ [105:68] ==> public final val stageWidth: Double defined in net.corda.netmap.VisualiserView[PropertyDescriptorImpl]

'view' @ [105:80] ==> internal final lateinit var view: VisualiserView defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'stageHeight' @ [105:85] ==> public final val stageHeight: Double defined in net.corda.netmap.VisualiserView[PropertyDescriptorImpl]

'-' @ [107:23] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'-' @ [108:23] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'view' @ [109:23] ==> internal final lateinit var view: VisualiserView defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'stageWidth' @ [109:28] ==> public final val stageWidth: Double defined in net.corda.netmap.VisualiserView[PropertyDescriptorImpl]

'xOffset' @ [109:45] ==> val xOffset: Int defined in net.corda.netmap.VisualiserViewModel.nodeCircleCoords[LocalVariableDescriptor]

'view' @ [110:23] ==> internal final lateinit var view: VisualiserView defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'stageHeight' @ [110:28] ==> public final val stageHeight: Double defined in net.corda.netmap.VisualiserView[PropertyDescriptorImpl]

'yOffset' @ [110:46] ==> val yOffset: Int defined in net.corda.netmap.VisualiserViewModel.nodeCircleCoords[LocalVariableDescriptor]

'radius' @ [111:25] ==> val radius: Double defined in net.corda.netmap.VisualiserViewModel.nodeCircleCoords[LocalVariableDescriptor]

'cos' @ [111:39] ==> public open fun cos(p0: Double): Double defined in java.lang.Math[JavaMethodDescriptor]

'tangentRad' @ [111:43] ==> val tangentRad: Double defined in net.corda.netmap.VisualiserViewModel.nodeCircleCoords[LocalVariableDescriptor]

'circleX' @ [111:57] ==> val circleX: Double defined in net.corda.netmap.VisualiserViewModel.nodeCircleCoords[LocalVariableDescriptor]

'radius' @ [112:25] ==> val radius: Double defined in net.corda.netmap.VisualiserViewModel.nodeCircleCoords[LocalVariableDescriptor]

'sin' @ [112:39] ==> public open fun sin(p0: Double): Double defined in java.lang.Math[JavaMethodDescriptor]

'tangentRad' @ [112:43] ==> val tangentRad: Double defined in net.corda.netmap.VisualiserViewModel.nodeCircleCoords[LocalVariableDescriptor]

'circleY' @ [112:57] ==> val circleY: Double defined in net.corda.netmap.VisualiserViewModel.nodeCircleCoords[LocalVariableDescriptor]

'ScreenCoordinate' @ [113:16] ==> public constructor ScreenCoordinate(screenX: Double, screenY: Double) defined in net.corda.core.node.ScreenCoordinate[DeserializedClassConstructorDescriptor]

'x' @ [113:33] ==> val x: Double defined in net.corda.netmap.VisualiserViewModel.nodeCircleCoords[LocalVariableDescriptor]

'y' @ [113:36] ==> val y: Double defined in net.corda.netmap.VisualiserViewModel.nodeCircleCoords[LocalVariableDescriptor]

'bankCount' @ [117:9] ==> public final var bankCount: Int defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'simulation' @ [117:21] ==> public final var simulation: IRSSimulation defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'banks' @ [117:32] ==> public final val banks: List<Simulation.SimulatedNode> defined in net.corda.netmap.simulation.IRSSimulation[PropertyDescriptorImpl]

'size' @ [117:38] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'serviceCount' @ [118:9] ==> public final var serviceCount: Int defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'simulation' @ [118:24] ==> public final var simulation: IRSSimulation defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'serviceProviders' @ [118:35] ==> public final val serviceProviders: List<Simulation.SimulatedNode> defined in net.corda.netmap.simulation.IRSSimulation[PropertyDescriptorImpl]

'size' @ [118:52] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'simulation' @ [118:59] ==> public final var simulation: IRSSimulation defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'regulators' @ [118:70] ==> public final val regulators: List<Simulation.SimulatedNode> defined in net.corda.netmap.simulation.IRSSimulation[PropertyDescriptorImpl]

'size' @ [118:81] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'component1' @ [119:15] ==> public final operator fun component1(): Int defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'component2' @ [119:22] ==> public final operator fun component2(): Simulation.SimulatedNode defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'simulation' @ [119:31] ==> public final var simulation: IRSSimulation defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'banks' @ [119:42] ==> public final val banks: List<Simulation.SimulatedNode> defined in net.corda.netmap.simulation.IRSSimulation[PropertyDescriptorImpl]

'withIndex' @ [119:48] ==> public fun <T> Iterable<Simulation.SimulatedNode>.withIndex(): Iterable<IndexedValue<Simulation.SimulatedNode>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SimulatedNode

'nodesToWidgets' @ [120:13] ==> public final val nodesToWidgets: HashMap<MockNetwork.MockNode, VisualiserViewModel.NodeWidget> defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'bank' @ [120:28] ==> val bank: Simulation.SimulatedNode defined in net.corda.netmap.VisualiserViewModel.createNodes[LocalVariableDescriptor]

'makeNodeWidget' @ [120:36] ==> public final fun makeNodeWidget(forNode: MockNetwork.MockNode, type: String, label: X500Name = ..., nodeType: NetworkMapVisualiser.NodeType, index: Int): VisualiserViewModel.NodeWidget defined in net.corda.netmap.VisualiserViewModel[SimpleFunctionDescriptorImpl]

'bank' @ [120:51] ==> val bank: Simulation.SimulatedNode defined in net.corda.netmap.VisualiserViewModel.createNodes[LocalVariableDescriptor]

'bank' @ [120:65] ==> val bank: Simulation.SimulatedNode defined in net.corda.netmap.VisualiserViewModel.createNodes[LocalVariableDescriptor]

'configuration' @ [120:70] ==> public open val configuration: NodeConfiguration defined in net.corda.netmap.simulation.Simulation.SimulatedNode[DeserializedPropertyDescriptor]

'myLegalName' @ [120:84] ==> public abstract val myLegalName: X500Name defined in net.corda.node.services.config.NodeConfiguration[DeserializedPropertyDescriptor]

'BANK' @ [120:127] ==> enum entry BANK defined in net.corda.netmap.NetworkMapVisualiser.NodeType[FakeCallableDescriptorForObject]

'index' @ [120:133] ==> val index: Int defined in net.corda.netmap.VisualiserViewModel.createNodes[LocalVariableDescriptor]

'component1' @ [122:15] ==> public final operator fun component1(): Int defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'component2' @ [122:22] ==> public final operator fun component2(): Simulation.SimulatedNode defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'simulation' @ [122:34] ==> public final var simulation: IRSSimulation defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'serviceProviders' @ [122:45] ==> public final val serviceProviders: List<Simulation.SimulatedNode> defined in net.corda.netmap.simulation.IRSSimulation[PropertyDescriptorImpl]

'withIndex' @ [122:62] ==> public fun <T> Iterable<Simulation.SimulatedNode>.withIndex(): Iterable<IndexedValue<Simulation.SimulatedNode>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SimulatedNode

'nodesToWidgets' @ [123:13] ==> public final val nodesToWidgets: HashMap<MockNetwork.MockNode, VisualiserViewModel.NodeWidget> defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'service' @ [123:28] ==> val service: Simulation.SimulatedNode defined in net.corda.netmap.VisualiserViewModel.createNodes[LocalVariableDescriptor]

'makeNodeWidget' @ [123:39] ==> public final fun makeNodeWidget(forNode: MockNetwork.MockNode, type: String, label: X500Name = ..., nodeType: NetworkMapVisualiser.NodeType, index: Int): VisualiserViewModel.NodeWidget defined in net.corda.netmap.VisualiserViewModel[SimpleFunctionDescriptorImpl]

'service' @ [123:54] ==> val service: Simulation.SimulatedNode defined in net.corda.netmap.VisualiserViewModel.createNodes[LocalVariableDescriptor]

'service' @ [123:82] ==> val service: Simulation.SimulatedNode defined in net.corda.netmap.VisualiserViewModel.createNodes[LocalVariableDescriptor]

'configuration' @ [123:90] ==> public open val configuration: NodeConfiguration defined in net.corda.netmap.simulation.Simulation.SimulatedNode[DeserializedPropertyDescriptor]

'myLegalName' @ [123:104] ==> public abstract val myLegalName: X500Name defined in net.corda.node.services.config.NodeConfiguration[DeserializedPropertyDescriptor]

'SERVICE' @ [123:147] ==> enum entry SERVICE defined in net.corda.netmap.NetworkMapVisualiser.NodeType[FakeCallableDescriptorForObject]

'index' @ [123:156] ==> val index: Int defined in net.corda.netmap.VisualiserViewModel.createNodes[LocalVariableDescriptor]

'component1' @ [125:15] ==> public final operator fun component1(): Int defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'component2' @ [125:22] ==> public final operator fun component2(): Simulation.SimulatedNode defined in kotlin.collections.IndexedValue[DeserializedSimpleFunctionDescriptor]

'simulation' @ [125:34] ==> public final var simulation: IRSSimulation defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'regulators' @ [125:45] ==> public final val regulators: List<Simulation.SimulatedNode> defined in net.corda.netmap.simulation.IRSSimulation[PropertyDescriptorImpl]

'withIndex' @ [125:56] ==> public fun <T> Iterable<Simulation.SimulatedNode>.withIndex(): Iterable<IndexedValue<Simulation.SimulatedNode>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SimulatedNode

'nodesToWidgets' @ [126:13] ==> public final val nodesToWidgets: HashMap<MockNetwork.MockNode, VisualiserViewModel.NodeWidget> defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'service' @ [126:28] ==> val service: Simulation.SimulatedNode defined in net.corda.netmap.VisualiserViewModel.createNodes[LocalVariableDescriptor]

'makeNodeWidget' @ [126:39] ==> public final fun makeNodeWidget(forNode: MockNetwork.MockNode, type: String, label: X500Name = ..., nodeType: NetworkMapVisualiser.NodeType, index: Int): VisualiserViewModel.NodeWidget defined in net.corda.netmap.VisualiserViewModel[SimpleFunctionDescriptorImpl]

'service' @ [126:54] ==> val service: Simulation.SimulatedNode defined in net.corda.netmap.VisualiserViewModel.createNodes[LocalVariableDescriptor]

'service' @ [126:76] ==> val service: Simulation.SimulatedNode defined in net.corda.netmap.VisualiserViewModel.createNodes[LocalVariableDescriptor]

'configuration' @ [126:84] ==> public open val configuration: NodeConfiguration defined in net.corda.netmap.simulation.Simulation.SimulatedNode[DeserializedPropertyDescriptor]

'myLegalName' @ [126:98] ==> public abstract val myLegalName: X500Name defined in net.corda.node.services.config.NodeConfiguration[DeserializedPropertyDescriptor]

'SERVICE' @ [126:141] ==> enum entry SERVICE defined in net.corda.netmap.NetworkMapVisualiser.NodeType[FakeCallableDescriptorForObject]

'index' @ [126:150] ==> val index: Int defined in net.corda.netmap.VisualiserViewModel.createNodes[LocalVariableDescriptor]

'simulation' @ [126:158] ==> public final var simulation: IRSSimulation defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'serviceProviders' @ [126:169] ==> public final val serviceProviders: List<Simulation.SimulatedNode> defined in net.corda.netmap.simulation.IRSSimulation[PropertyDescriptorImpl]

'size' @ [126:186] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'X500Name' @ [130:87] ==> public constructor X500Name(p0: (String..String?)) defined in org.bouncycastle.asn1.x500.X500Name[JavaClassConstructorDescriptor]

'Circle' @ [133:25] ==> public constructor Circle(p0: Double) defined in javafx.scene.shape.Circle[JavaClassConstructorDescriptor]

'initialRadius' @ [133:32] ==> value-parameter initialRadius: Double defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget.emitRadarPulse[ValueParameterDescriptorImpl]

'apply' @ [133:47] ==> @InlineOnly public inline fun <T> Circle.apply(block: Circle.() -> Unit): Circle defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Circle

'styleClass' @ [134:17] ==> public final val Circle.styleClass: (ObservableList<(String..String?)>..ObservableList<(String..String?)>?)[MyPropertyDescriptor]

'type' @ [134:38] ==> value-parameter type: String defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[ValueParameterDescriptorImpl]

'styleClass' @ [135:17] ==> public final val Circle.styleClass: (ObservableList<(String..String?)>..ObservableList<(String..String?)>?)[MyPropertyDescriptor]

'Timeline' @ [137:29] ==> public constructor Timeline(vararg p0: (KeyFrame..KeyFrame?)) defined in javafx.animation.Timeline[JavaClassConstructorDescriptor]

'KeyFrame' @ [138:21] ==> public constructor KeyFrame(@NamedArg p0: (Duration..Duration?), @NamedArg vararg p1: (KeyValue..KeyValue?)) defined in javafx.animation.KeyFrame[JavaClassConstructorDescriptor]

'seconds' @ [138:39] ==> public open fun seconds(p0: Double): (Duration..Duration?) defined in javafx.util.Duration[JavaMethodDescriptor]

'pulse' @ [139:29] ==> val pulse: Circle defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget.emitRadarPulse[LocalVariableDescriptor]

'radiusProperty' @ [139:35] ==> public final fun radiusProperty(): (DoubleProperty..DoubleProperty?) defined in javafx.scene.shape.Circle[JavaMethodDescriptor]

'keyValue' @ [139:52] ==> public fun <T : Any> WritableValue<(Number..Number?)>.keyValue(endValue: (Number..Number?), interpolator: Interpolator = ...): KeyValue defined in net.corda.netmap[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> (kotlin.Number..kotlin.Number?)

'initialRadius' @ [139:61] ==> value-parameter initialRadius: Double defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget.emitRadarPulse[ValueParameterDescriptorImpl]

'pulse' @ [140:29] ==> val pulse: Circle defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget.emitRadarPulse[LocalVariableDescriptor]

'opacityProperty' @ [140:35] ==> public final fun opacityProperty(): (DoubleProperty..DoubleProperty?) defined in javafx.scene.shape.Circle[JavaMethodDescriptor]

'keyValue' @ [140:53] ==> public fun <T : Any> WritableValue<(Number..Number?)>.keyValue(endValue: (Number..Number?), interpolator: Interpolator = ...): KeyValue defined in net.corda.netmap[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> (kotlin.Number..kotlin.Number?)

'KeyFrame' @ [142:21] ==> public constructor KeyFrame(@NamedArg p0: (Duration..Duration?), @NamedArg vararg p1: (KeyValue..KeyValue?)) defined in javafx.animation.KeyFrame[JavaClassConstructorDescriptor]

'seconds' @ [142:39] ==> public open fun seconds(p0: Double): (Duration..Duration?) defined in javafx.util.Duration[JavaMethodDescriptor]

'duration' @ [142:47] ==> value-parameter duration: Double defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget.emitRadarPulse[ValueParameterDescriptorImpl]

'pulse' @ [143:29] ==> val pulse: Circle defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget.emitRadarPulse[LocalVariableDescriptor]

'radiusProperty' @ [143:35] ==> public final fun radiusProperty(): (DoubleProperty..DoubleProperty?) defined in javafx.scene.shape.Circle[JavaMethodDescriptor]

'keyValue' @ [143:52] ==> public fun <T : Any> WritableValue<(Number..Number?)>.keyValue(endValue: (Number..Number?), interpolator: Interpolator = ...): KeyValue defined in net.corda.netmap[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> (kotlin.Number..kotlin.Number?)

'targetRadius' @ [143:61] ==> value-parameter targetRadius: Double defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget.emitRadarPulse[ValueParameterDescriptorImpl]

'pulse' @ [144:29] ==> val pulse: Circle defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget.emitRadarPulse[LocalVariableDescriptor]

'opacityProperty' @ [144:35] ==> public final fun opacityProperty(): (DoubleProperty..DoubleProperty?) defined in javafx.scene.shape.Circle[JavaMethodDescriptor]

'keyValue' @ [144:53] ==> public fun <T : Any> WritableValue<(Number..Number?)>.keyValue(endValue: (Number..Number?), interpolator: Interpolator = ...): KeyValue defined in net.corda.netmap[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> (kotlin.Number..kotlin.Number?)

'Pair' @ [147:20] ==> public constructor Pair<out A, out B>(first: Circle, second: Timeline) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> Circle
    <out B> -> Timeline

'pulse' @ [147:25] ==> val pulse: Circle defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget.emitRadarPulse[LocalVariableDescriptor]

'animation' @ [147:32] ==> val animation: Timeline defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget.emitRadarPulse[LocalVariableDescriptor]

'Circle' @ [150:24] ==> public constructor Circle(p0: Double) defined in javafx.scene.shape.Circle[JavaClassConstructorDescriptor]

'apply' @ [150:37] ==> @InlineOnly public inline fun <T> Circle.apply(block: Circle.() -> Unit): Circle defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Circle

'styleClass' @ [151:13] ==> public final val Circle.styleClass: (ObservableList<(String..String?)>..ObservableList<(String..String?)>?)[MyPropertyDescriptor]

'type' @ [151:34] ==> value-parameter type: String defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[ValueParameterDescriptorImpl]

'styleClass' @ [152:13] ==> public final val Circle.styleClass: (ObservableList<(String..String?)>..ObservableList<(String..String?)>?)[MyPropertyDescriptor]

'component1' @ [154:14] ==> public final operator fun component1(): Circle defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [154:24] ==> public final operator fun component2(): Animation defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'emitRadarPulse' @ [154:37] ==> local final fun emitRadarPulse(initialRadius: Double, targetRadius: Double, duration: Double): Pair<Circle, Animation> defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[SimpleFunctionDescriptorImpl]

'component1' @ [155:14] ==> public final operator fun component1(): Circle defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [155:33] ==> public final operator fun component2(): Animation defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'emitRadarPulse' @ [155:50] ==> local final fun emitRadarPulse(initialRadius: Double, targetRadius: Double, duration: Double): Pair<Circle, Animation> defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[SimpleFunctionDescriptorImpl]

'view' @ [156:9] ==> internal final lateinit var view: VisualiserView defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'root' @ [156:14] ==> public final lateinit var root: Pane defined in net.corda.netmap.VisualiserView[PropertyDescriptorImpl]

'children' @ [156:19] ==> public final val Pane.children: (ObservableList<(Node..Node?)>..ObservableList<(Node..Node?)>?)[MyPropertyDescriptor]

'outerDot' @ [156:31] ==> val outerDot: Circle defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[LocalVariableDescriptor]

'view' @ [157:9] ==> internal final lateinit var view: VisualiserView defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'root' @ [157:14] ==> public final lateinit var root: Pane defined in net.corda.netmap.VisualiserView[PropertyDescriptorImpl]

'children' @ [157:19] ==> public final val Pane.children: (ObservableList<(Node..Node?)>..ObservableList<(Node..Node?)>?)[MyPropertyDescriptor]

'longPulseOuterDot' @ [157:31] ==> val longPulseOuterDot: Circle defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[LocalVariableDescriptor]

'view' @ [158:9] ==> internal final lateinit var view: VisualiserView defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'root' @ [158:14] ==> public final lateinit var root: Pane defined in net.corda.netmap.VisualiserView[PropertyDescriptorImpl]

'children' @ [158:19] ==> public final val Pane.children: (ObservableList<(Node..Node?)>..ObservableList<(Node..Node?)>?)[MyPropertyDescriptor]

'innerDot' @ [158:31] ==> val innerDot: Circle defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[LocalVariableDescriptor]

'Label' @ [160:25] ==> public constructor Label(p0: (String..String?)) defined in javafx.scene.control.Label[JavaClassConstructorDescriptor]

'label' @ [160:31] ==> value-parameter label: X500Name = ... defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[ValueParameterDescriptorImpl]

'commonName' @ [160:37] ==> public val X500Name.commonName: String defined in net.corda.core.crypto[DeserializedPropertyDescriptor]

'StackPane' @ [161:29] ==> public constructor StackPane(vararg p0: (Node..Node?)) defined in javafx.scene.layout.StackPane[JavaClassConstructorDescriptor]

'nameLabel' @ [161:39] ==> val nameLabel: Label defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[LocalVariableDescriptor]

'apply' @ [161:50] ==> @InlineOnly public inline fun <T> StackPane.apply(block: StackPane.() -> Unit): StackPane defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> StackPane

'styleClass' @ [162:13] ==> public final val StackPane.styleClass: (ObservableList<(String..String?)>..ObservableList<(String..String?)>?)[MyPropertyDescriptor]

'alignment' @ [163:13] ==> public final var StackPane.alignment: (Pos..Pos?)[MyPropertyDescriptor]

'CENTER_RIGHT' @ [163:29] ==> enum entry CENTER_RIGHT defined in javafx.geometry.Pos[FakeCallableDescriptorForObject]

'minWidth' @ [166:13] ==> public final var StackPane.minWidth: Double[MyPropertyDescriptor]

'view' @ [168:9] ==> internal final lateinit var view: VisualiserView defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'root' @ [168:14] ==> public final lateinit var root: Pane defined in net.corda.netmap.VisualiserView[PropertyDescriptorImpl]

'children' @ [168:19] ==> public final val Pane.children: (ObservableList<(Node..Node?)>..ObservableList<(Node..Node?)>?)[MyPropertyDescriptor]

'nameLabelRect' @ [168:31] ==> val nameLabelRect: StackPane defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[LocalVariableDescriptor]

'Label' @ [170:27] ==> public constructor Label(p0: (String..String?)) defined in javafx.scene.control.Label[JavaClassConstructorDescriptor]

'StackPane' @ [171:31] ==> public constructor StackPane(vararg p0: (Node..Node?)) defined in javafx.scene.layout.StackPane[JavaClassConstructorDescriptor]

'statusLabel' @ [171:41] ==> val statusLabel: Label defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[LocalVariableDescriptor]

'apply' @ [171:54] ==> @InlineOnly public inline fun <T> StackPane.apply(block: StackPane.() -> Unit): StackPane defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> StackPane

'styleClass' @ [171:62] ==> public final val StackPane.styleClass: (ObservableList<(String..String?)>..ObservableList<(String..String?)>?)[MyPropertyDescriptor]

'view' @ [172:9] ==> internal final lateinit var view: VisualiserView defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'root' @ [172:14] ==> public final lateinit var root: Pane defined in net.corda.netmap.VisualiserView[PropertyDescriptorImpl]

'children' @ [172:19] ==> public final val Pane.children: (ObservableList<(Node..Node?)>..ObservableList<(Node..Node?)>?)[MyPropertyDescriptor]

'statusLabelRect' @ [172:31] ==> val statusLabelRect: StackPane defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[LocalVariableDescriptor]

'NodeWidget' @ [174:22] ==> public constructor NodeWidget(node: MockNetwork.MockNode, innerDot: Circle, outerDot: Circle, longPulseDot: Circle, pulseAnim: Animation, longPulseAnim: Animation, nameLabel: Label, statusLabel: Label) defined in net.corda.netmap.VisualiserViewModel.NodeWidget[ClassConstructorDescriptorImpl]

'forNode' @ [174:33] ==> value-parameter forNode: MockNetwork.MockNode defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[ValueParameterDescriptorImpl]

'innerDot' @ [174:42] ==> val innerDot: Circle defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[LocalVariableDescriptor]

'outerDot' @ [174:52] ==> val outerDot: Circle defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[LocalVariableDescriptor]

'longPulseOuterDot' @ [174:62] ==> val longPulseOuterDot: Circle defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[LocalVariableDescriptor]

'pulseAnim' @ [174:81] ==> val pulseAnim: Animation defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[LocalVariableDescriptor]

'longPulseAnim' @ [174:92] ==> val longPulseAnim: Animation defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[LocalVariableDescriptor]

'nameLabel' @ [174:107] ==> val nameLabel: Label defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[LocalVariableDescriptor]

'statusLabel' @ [174:118] ==> val statusLabel: Label defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[LocalVariableDescriptor]

'when (displayStyle) {
            Style.CIRCLE -> widget.position { _ -> nodeCircleCoords(nodeType, index) }
            Style.MAP -> widget.position { node -> nodeMapCoords(node) }
        }' @ [175:9] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Unit, entry1: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Unit

'displayStyle' @ [175:15] ==> public final var displayStyle: VisualiserViewModel.Style defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'CIRCLE' @ [176:19] ==> enum entry CIRCLE defined in net.corda.netmap.VisualiserViewModel.Style[FakeCallableDescriptorForObject]

'widget' @ [176:29] ==> val widget: VisualiserViewModel.NodeWidget defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[LocalVariableDescriptor]

'position' @ [176:36] ==> public final fun position(nodeCoords: (node: MockNetwork.MockNode) -> ScreenCoordinate): Unit defined in net.corda.netmap.VisualiserViewModel.NodeWidget[SimpleFunctionDescriptorImpl]

'nodeCircleCoords' @ [176:52] ==> public final fun nodeCircleCoords(type: NetworkMapVisualiser.NodeType, index: Int): ScreenCoordinate defined in net.corda.netmap.VisualiserViewModel[SimpleFunctionDescriptorImpl]

'nodeType' @ [176:69] ==> value-parameter nodeType: NetworkMapVisualiser.NodeType defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[ValueParameterDescriptorImpl]

'index' @ [176:79] ==> value-parameter index: Int defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[ValueParameterDescriptorImpl]

'MAP' @ [177:19] ==> enum entry MAP defined in net.corda.netmap.VisualiserViewModel.Style[FakeCallableDescriptorForObject]

'widget' @ [177:26] ==> val widget: VisualiserViewModel.NodeWidget defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[LocalVariableDescriptor]

'position' @ [177:33] ==> public final fun position(nodeCoords: (node: MockNetwork.MockNode) -> ScreenCoordinate): Unit defined in net.corda.netmap.VisualiserViewModel.NodeWidget[SimpleFunctionDescriptorImpl]

'nodeMapCoords' @ [177:52] ==> public final fun nodeMapCoords(node: MockNetwork.MockNode): ScreenCoordinate defined in net.corda.netmap.VisualiserViewModel[SimpleFunctionDescriptorImpl]

'node' @ [177:66] ==> value-parameter node: MockNetwork.MockNode defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget.<anonymous>[ValueParameterDescriptorImpl]

'widget' @ [179:16] ==> val widget: VisualiserViewModel.NodeWidget defined in net.corda.netmap.VisualiserViewModel.makeNodeWidget[LocalVariableDescriptor]

'nodesToWidgets' @ [183:18] ==> public final val nodesToWidgets: HashMap<MockNetwork.MockNode, VisualiserViewModel.NodeWidget> defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'senderNode' @ [183:33] ==> value-parameter senderNode: MockNetwork.MockNode defined in net.corda.netmap.VisualiserViewModel.fireBulletBetweenNodes[ValueParameterDescriptorImpl]

'innerDot' @ [183:47] ==> public final val innerDot: Circle defined in net.corda.netmap.VisualiserViewModel.NodeWidget[PropertyDescriptorImpl]

'centerX' @ [183:56] ==> public final var Circle.centerX: Double[MyPropertyDescriptor]

'nodesToWidgets' @ [184:18] ==> public final val nodesToWidgets: HashMap<MockNetwork.MockNode, VisualiserViewModel.NodeWidget> defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'senderNode' @ [184:33] ==> value-parameter senderNode: MockNetwork.MockNode defined in net.corda.netmap.VisualiserViewModel.fireBulletBetweenNodes[ValueParameterDescriptorImpl]

'innerDot' @ [184:47] ==> public final val innerDot: Circle defined in net.corda.netmap.VisualiserViewModel.NodeWidget[PropertyDescriptorImpl]

'centerY' @ [184:56] ==> public final var Circle.centerY: Double[MyPropertyDescriptor]

'nodesToWidgets' @ [185:18] ==> public final val nodesToWidgets: HashMap<MockNetwork.MockNode, VisualiserViewModel.NodeWidget> defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'destNode' @ [185:33] ==> value-parameter destNode: MockNetwork.MockNode defined in net.corda.netmap.VisualiserViewModel.fireBulletBetweenNodes[ValueParameterDescriptorImpl]

'innerDot' @ [185:45] ==> public final val innerDot: Circle defined in net.corda.netmap.VisualiserViewModel.NodeWidget[PropertyDescriptorImpl]

'centerX' @ [185:54] ==> public final var Circle.centerX: Double[MyPropertyDescriptor]

'nodesToWidgets' @ [186:18] ==> public final val nodesToWidgets: HashMap<MockNetwork.MockNode, VisualiserViewModel.NodeWidget> defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'destNode' @ [186:33] ==> value-parameter destNode: MockNetwork.MockNode defined in net.corda.netmap.VisualiserViewModel.fireBulletBetweenNodes[ValueParameterDescriptorImpl]

'innerDot' @ [186:45] ==> public final val innerDot: Circle defined in net.corda.netmap.VisualiserViewModel.NodeWidget[PropertyDescriptorImpl]

'centerY' @ [186:54] ==> public final var Circle.centerY: Double[MyPropertyDescriptor]

'Circle' @ [188:22] ==> public constructor Circle(p0: Double) defined in javafx.scene.shape.Circle[JavaClassConstructorDescriptor]

'bullet' @ [189:9] ==> val bullet: Circle defined in net.corda.netmap.VisualiserViewModel.fireBulletBetweenNodes[LocalVariableDescriptor]

'styleClass' @ [189:16] ==> public final val Circle.styleClass: (ObservableList<(String..String?)>..ObservableList<(String..String?)>?)[MyPropertyDescriptor]

'bullet' @ [190:9] ==> val bullet: Circle defined in net.corda.netmap.VisualiserViewModel.fireBulletBetweenNodes[LocalVariableDescriptor]

'styleClass' @ [190:16] ==> public final val Circle.styleClass: (ObservableList<(String..String?)>..ObservableList<(String..String?)>?)[MyPropertyDescriptor]

'startType' @ [190:43] ==> value-parameter startType: String defined in net.corda.netmap.VisualiserViewModel.fireBulletBetweenNodes[ValueParameterDescriptorImpl]

'endType' @ [190:57] ==> value-parameter endType: String defined in net.corda.netmap.VisualiserViewModel.fireBulletBetweenNodes[ValueParameterDescriptorImpl]

'with' @ [191:9] ==> @InlineOnly public inline fun <T, R> with(receiver: TranslateTransition, block: TranslateTransition.() -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TranslateTransition
    <R> -> Unit

'TranslateTransition' @ [191:14] ==> public constructor TranslateTransition(p0: (Duration..Duration?), p1: (Node..Node?)) defined in javafx.animation.TranslateTransition[JavaClassConstructorDescriptor]

'stepDuration' @ [191:34] ==> public final var stepDuration: Duration defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'bullet' @ [191:48] ==> val bullet: Circle defined in net.corda.netmap.VisualiserViewModel.fireBulletBetweenNodes[LocalVariableDescriptor]

'fromX' @ [192:13] ==> public final var TranslateTransition.fromX: Double[MyPropertyDescriptor]

'sx' @ [192:21] ==> val sx: Double defined in net.corda.netmap.VisualiserViewModel.fireBulletBetweenNodes[LocalVariableDescriptor]

'fromY' @ [193:13] ==> public final var TranslateTransition.fromY: Double[MyPropertyDescriptor]

'sy' @ [193:21] ==> val sy: Double defined in net.corda.netmap.VisualiserViewModel.fireBulletBetweenNodes[LocalVariableDescriptor]

'toX' @ [194:13] ==> public final var TranslateTransition.toX: Double[MyPropertyDescriptor]

'dx' @ [194:19] ==> val dx: Double defined in net.corda.netmap.VisualiserViewModel.fireBulletBetweenNodes[LocalVariableDescriptor]

'toY' @ [195:13] ==> public final var TranslateTransition.toY: Double[MyPropertyDescriptor]

'dy' @ [195:19] ==> val dy: Double defined in net.corda.netmap.VisualiserViewModel.fireBulletBetweenNodes[LocalVariableDescriptor]

'setOnFinished' @ [196:13] ==> public final fun setOnFinished(p0: (((ActionEvent..ActionEvent?)) -> Unit..(((ActionEvent..ActionEvent?)) -> Unit)?)): Unit defined in javafx.animation.TranslateTransition[MyFunctionDescriptor]

'bullet' @ [204:17] ==> val bullet: Circle defined in net.corda.netmap.VisualiserViewModel.fireBulletBetweenNodes[LocalVariableDescriptor]

'isVisible' @ [204:24] ==> public final var Circle.isVisible: Boolean[MyPropertyDescriptor]

'play' @ [206:13] ==> public open fun play(): Unit defined in javafx.animation.TranslateTransition[JavaMethodDescriptor]

'Line' @ [209:20] ==> public constructor Line(p0: Double, p1: Double, p2: Double, p3: Double) defined in javafx.scene.shape.Line[JavaClassConstructorDescriptor]

'sx' @ [209:25] ==> val sx: Double defined in net.corda.netmap.VisualiserViewModel.fireBulletBetweenNodes[LocalVariableDescriptor]

'sy' @ [209:29] ==> val sy: Double defined in net.corda.netmap.VisualiserViewModel.fireBulletBetweenNodes[LocalVariableDescriptor]

'dx' @ [209:33] ==> val dx: Double defined in net.corda.netmap.VisualiserViewModel.fireBulletBetweenNodes[LocalVariableDescriptor]

'dy' @ [209:37] ==> val dy: Double defined in net.corda.netmap.VisualiserViewModel.fireBulletBetweenNodes[LocalVariableDescriptor]

'apply' @ [209:41] ==> @InlineOnly public inline fun <T> Line.apply(block: Line.() -> Unit): Line defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Line

'styleClass' @ [209:49] ==> public final val Line.styleClass: (ObservableList<(String..String?)>..ObservableList<(String..String?)>?)[MyPropertyDescriptor]

'with' @ [211:9] ==> @InlineOnly public inline fun <T, R> with(receiver: FadeTransition, block: FadeTransition.() -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FadeTransition
    <R> -> Unit

'FadeTransition' @ [211:14] ==> public constructor FadeTransition(p0: (Duration..Duration?), p1: (Node..Node?)) defined in javafx.animation.FadeTransition[JavaClassConstructorDescriptor]

'stepDuration' @ [211:29] ==> public final var stepDuration: Duration defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'divide' @ [211:42] ==> public open fun divide(p0: Double): (Duration..Duration?) defined in javafx.util.Duration[JavaMethodDescriptor]

'line' @ [211:55] ==> val line: Line defined in net.corda.netmap.VisualiserViewModel.fireBulletBetweenNodes[LocalVariableDescriptor]

'fromValue' @ [212:13] ==> public final var FadeTransition.fromValue: Double[MyPropertyDescriptor]

'toValue' @ [213:13] ==> public final var FadeTransition.toValue: Double[MyPropertyDescriptor]

'play' @ [214:13] ==> public open fun play(): Unit defined in javafx.animation.FadeTransition[JavaMethodDescriptor]

'setOnFinished' @ [215:13] ==> public final fun setOnFinished(p0: (((ActionEvent..ActionEvent?)) -> Unit..(((ActionEvent..ActionEvent?)) -> Unit)?)): Unit defined in javafx.animation.FadeTransition[MyFunctionDescriptor]

'with' @ [216:17] ==> @InlineOnly public inline fun <T, R> with(receiver: FadeTransition, block: FadeTransition.() -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> FadeTransition
    <R> -> Unit

'FadeTransition' @ [216:22] ==> public constructor FadeTransition(p0: (Duration..Duration?), p1: (Node..Node?)) defined in javafx.animation.FadeTransition[JavaClassConstructorDescriptor]

'stepDuration' @ [216:37] ==> public final var stepDuration: Duration defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'multiply' @ [216:50] ==> public open fun multiply(p0: Double): (Duration..Duration?) defined in javafx.util.Duration[JavaMethodDescriptor]

'line' @ [216:65] ==> val line: Line defined in net.corda.netmap.VisualiserViewModel.fireBulletBetweenNodes[LocalVariableDescriptor]

'fromValue' @ [216:74] ==> public final var FadeTransition.fromValue: Double[MyPropertyDescriptor]

'toValue' @ [216:91] ==> public final var FadeTransition.toValue: Double[MyPropertyDescriptor]

'play' @ [216:106] ==> public open fun play(): Unit defined in javafx.animation.FadeTransition[JavaMethodDescriptor]

'view' @ [220:9] ==> internal final lateinit var view: VisualiserView defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'root' @ [220:14] ==> public final lateinit var root: Pane defined in net.corda.netmap.VisualiserView[PropertyDescriptorImpl]

'children' @ [220:19] ==> public final val Pane.children: (ObservableList<(Node..Node?)>..ObservableList<(Node..Node?)>?)[MyPropertyDescriptor]

'add' @ [220:28] ==> public abstract fun add(index: Int, element: (Node..Node?)): Unit defined in javafx.collections.ObservableList[DeserializedSimpleFunctionDescriptor]

'line' @ [220:35] ==> val line: Line defined in net.corda.netmap.VisualiserViewModel.fireBulletBetweenNodes[LocalVariableDescriptor]

'view' @ [221:9] ==> internal final lateinit var view: VisualiserView defined in net.corda.netmap.VisualiserViewModel[PropertyDescriptorImpl]

'root' @ [221:14] ==> public final lateinit var root: Pane defined in net.corda.netmap.VisualiserView[PropertyDescriptorImpl]

'children' @ [221:19] ==> public final val Pane.children: (ObservableList<(Node..Node?)>..ObservableList<(Node..Node?)>?)[MyPropertyDescriptor]

'add' @ [221:28] ==> public abstract fun add(element: (Node..Node?)): Boolean defined in javafx.collections.ObservableList[DeserializedSimpleFunctionDescriptor]

'bullet' @ [221:32] ==> val bullet: Circle defined in net.corda.netmap.VisualiserViewModel.fireBulletBetweenNodes[LocalVariableDescriptor]

