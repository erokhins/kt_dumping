'CordaView' @ [46:27] ==> public constructor CordaView(title: String? = ...) defined in net.corda.explorer.model.CordaView[ClassConstructorDescriptorImpl]

'fxml' @ [47:26] ==> public final fun <T : Node> fxml(location: String?, hasControllerAttribute: Boolean): ReadOnlyProperty<UIComponent, BorderPane> defined in net.corda.explorer.views.TransactionViewer[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Node> -> BorderPane

'EXCHANGE' @ [48:41] ==> enum entry EXCHANGE defined in de.jensd.fx.glyphs.fontawesome.FontAwesomeIcon[FakeCallableDescriptorForObject]

'fxid' @ [50:41] ==> public final inline fun <reified T : Any> fxid(propName: String?): ReadOnlyProperty<UIComponent, TableView<TransactionViewer.Transaction>> defined in net.corda.explorer.views.TransactionViewer[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : Any> -> TableView<Transaction>

'fxid' @ [51:46] ==> public final inline fun <reified T : Any> fxid(propName: String?): ReadOnlyProperty<UIComponent, Label> defined in net.corda.explorer.views.TransactionViewer[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : Any> -> Label

'getValue' @ [53:33] ==> public final operator fun getValue(thisRef: Any, property: KProperty<*>): ObservableList<out T> defined in net.corda.client.jfx.model.TrackedDelegate.ObservableListReadOnlyDelegate[DeserializedSimpleFunctionDescriptor]

'TransactionDataModel' @ [53:56] ==> public constructor TransactionDataModel() defined in net.corda.client.jfx.model.TransactionDataModel[DeserializedClassConstructorDescriptor]

'partiallyResolvedTransactions' @ [53:78] ==> public final val partiallyResolvedTransactions: ObservableList<PartiallyResolvedTransaction> defined in net.corda.client.jfx.model.TransactionDataModel[DeserializedPropertyDescriptor]

'getValue' @ [54:38] ==> public final operator fun getValue(thisRef: Any, property: KProperty<*>): ObservableValue<T> defined in net.corda.client.jfx.model.TrackedDelegate.ObservableValueDelegate[DeserializedSimpleFunctionDescriptor]

'ReportingCurrencyModel' @ [54:54] ==> public constructor ReportingCurrencyModel() defined in net.corda.explorer.model.ReportingCurrencyModel[ClassConstructorDescriptorImpl]

'reportingExchange' @ [54:78] ==> public final val reportingExchange: ObservableValue<Pair<Currency, (Amount<Currency>) -> Amount<Currency>>> defined in net.corda.explorer.model.ReportingCurrencyModel[PropertyDescriptorImpl]

'getValue' @ [55:38] ==> public final operator fun getValue(thisRef: Any, property: KProperty<*>): ObservableValue<T> defined in net.corda.client.jfx.model.TrackedDelegate.ObservableValueDelegate[DeserializedSimpleFunctionDescriptor]

'ReportingCurrencyModel' @ [55:54] ==> public constructor ReportingCurrencyModel() defined in net.corda.explorer.model.ReportingCurrencyModel[ClassConstructorDescriptorImpl]

'reportingCurrency' @ [55:78] ==> public final val reportingCurrency: ObservableValue<(Currency..Currency?)> defined in net.corda.explorer.model.ReportingCurrencyModel[PropertyDescriptorImpl]

'getValue' @ [56:31] ==> public final operator fun getValue(thisRef: Any, property: KProperty<*>): ObservableValue<T> defined in net.corda.client.jfx.model.TrackedDelegate.ObservableValueDelegate[DeserializedSimpleFunctionDescriptor]

'NetworkIdentityModel' @ [56:47] ==> public constructor NetworkIdentityModel() defined in net.corda.client.jfx.model.NetworkIdentityModel[DeserializedClassConstructorDescriptor]

'myIdentity' @ [56:69] ==> public final val myIdentity: ObservableValue<NodeInfo?> defined in net.corda.client.jfx.model.NetworkIdentityModel[DeserializedPropertyDescriptor]

'listOf' @ [58:28] ==> public fun <T> listOf(element: CordaWidget): List<CordaWidget> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> CordaWidget

'CordaWidget' @ [58:35] ==> public constructor CordaWidget(name: String, node: Node, icon: FontAwesomeIcon? = ...) defined in net.corda.explorer.model.CordaWidget[ClassConstructorDescriptorImpl]

'title' @ [58:47] ==> public final var title: String defined in net.corda.explorer.views.TransactionViewer[DeserializedPropertyDescriptor]

'TransactionWidget' @ [58:54] ==> public constructor TransactionWidget() defined in net.corda.explorer.views.TransactionViewer.TransactionWidget[ClassConstructorDescriptorImpl]

'icon' @ [58:75] ==> public open val icon: FontAwesomeIcon defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'observable' @ [58:82] ==> public fun <T> List<CordaWidget>.observable(): ObservableList<CordaWidget> defined in tornadofx[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> CordaWidget

'txIdToScroll' @ [82:9] ==> public final var txIdToScroll: SecureHash? defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'let' @ [82:23] ==> @InlineOnly public inline fun <T, R> SecureHash.let(block: (SecureHash) -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SecureHash
    <R> -> Unit

'scrollPosition' @ [83:13] ==> private final var scrollPosition: Int defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'transactionViewTable' @ [83:30] ==> private final val transactionViewTable: TableView<TransactionViewer.Transaction> defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'items' @ [83:51] ==> public final var <S : (Any..Any?)> TableView<TransactionViewer.Transaction>.items: (ObservableList<(TransactionViewer.Transaction..TransactionViewer.Transaction?)>..ObservableList<(TransactionViewer.Transaction..TransactionViewer.Transaction?)>?)[MyPropertyDescriptor]
Inferred types:
    <S : (Any..Any?)> -> Transaction

'indexOfFirst' @ [83:57] ==> public inline fun <T> List<(TransactionViewer.Transaction..TransactionViewer.Transaction?)>.indexOfFirst(predicate: ((TransactionViewer.Transaction..TransactionViewer.Transaction?)) -> Boolean): Int defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (net.corda.explorer.views.TransactionViewer.Transaction..net.corda.explorer.views.TransactionViewer.Transaction?)

'it' @ [83:72] ==> value-parameter it: (TransactionViewer.Transaction..TransactionViewer.Transaction?) defined in net.corda.explorer.views.TransactionViewer.onDock.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'id' @ [83:75] ==> public final val id: SecureHash defined in net.corda.explorer.views.TransactionViewer.Transaction[PropertyDescriptorImpl]

'txIdToScroll' @ [83:81] ==> public final var txIdToScroll: SecureHash? defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'scrollPosition' @ [84:17] ==> private final var scrollPosition: Int defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'expander' @ [85:17] ==> private final lateinit var expander: ExpanderColumn<TransactionViewer.Transaction> defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'toggleExpanded' @ [85:26] ==> public final fun toggleExpanded(index: Int): Unit defined in tornadofx.ExpanderColumn[DeserializedSimpleFunctionDescriptor]

'scrollPosition' @ [85:41] ==> private final var scrollPosition: Int defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'transactionViewTable' @ [86:26] ==> private final val transactionViewTable: TableView<TransactionViewer.Transaction> defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'items' @ [86:47] ==> public final var <S : (Any..Any?)> TableView<TransactionViewer.Transaction>.items: (ObservableList<(TransactionViewer.Transaction..TransactionViewer.Transaction?)>..ObservableList<(TransactionViewer.Transaction..TransactionViewer.Transaction?)>?)[MyPropertyDescriptor]
Inferred types:
    <S : (Any..Any?)> -> Transaction

'scrollPosition' @ [86:53] ==> private final var scrollPosition: Int defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'transactionViewTable' @ [87:17] ==> private final val transactionViewTable: TableView<TransactionViewer.Transaction> defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'scrollTo' @ [87:38] ==> public open fun scrollTo(p0: (TransactionViewer.Transaction..TransactionViewer.Transaction?)): Unit defined in javafx.scene.control.TableView[JavaMethodDescriptor]

'tx' @ [87:47] ==> val tx: (TransactionViewer.Transaction..TransactionViewer.Transaction?) defined in net.corda.explorer.views.TransactionViewer.onDock.<anonymous>[LocalVariableDescriptor]

'scrollPosition' @ [93:13] ==> private final var scrollPosition: Int defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'expander' @ [94:30] ==> private final lateinit var expander: ExpanderColumn<TransactionViewer.Transaction> defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'getExpandedProperty' @ [94:39] ==> public final fun getExpandedProperty(item: TransactionViewer.Transaction): BooleanProperty defined in tornadofx.ExpanderColumn[DeserializedSimpleFunctionDescriptor]

'transactionViewTable' @ [94:59] ==> private final val transactionViewTable: TableView<TransactionViewer.Transaction> defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'items' @ [94:80] ==> public final var <S : (Any..Any?)> TableView<TransactionViewer.Transaction>.items: (ObservableList<(TransactionViewer.Transaction..TransactionViewer.Transaction?)>..ObservableList<(TransactionViewer.Transaction..TransactionViewer.Transaction?)>?)[MyPropertyDescriptor]
Inferred types:
    <S : (Any..Any?)> -> Transaction

'scrollPosition' @ [94:86] ==> private final var scrollPosition: Int defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'isExpanded' @ [95:17] ==> val isExpanded: BooleanProperty defined in net.corda.explorer.views.TransactionViewer.onUndock[LocalVariableDescriptor]

'value' @ [95:28] ==> public final var BooleanProperty.value: (Boolean..Boolean?)[MyPropertyDescriptor]

'expander' @ [95:35] ==> private final lateinit var expander: ExpanderColumn<TransactionViewer.Transaction> defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'toggleExpanded' @ [95:44] ==> public final fun toggleExpanded(index: Int): Unit defined in tornadofx.ExpanderColumn[DeserializedSimpleFunctionDescriptor]

'scrollPosition' @ [95:59] ==> private final var scrollPosition: Int defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'scrollPosition' @ [96:13] ==> private final var scrollPosition: Int defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'txIdToScroll' @ [98:9] ==> public final var txIdToScroll: SecureHash? defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'transactions' @ [105:28] ==> private final val transactions: ObservableList<out PartiallyResolvedTransaction> defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'map' @ [105:41] ==> public fun <A, B> ObservableList<out PartiallyResolvedTransaction>.map(cached: Boolean = ..., function: (PartiallyResolvedTransaction) -> TransactionViewer.Transaction): ObservableList<TransactionViewer.Transaction> defined in net.corda.client.jfx.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> PartiallyResolvedTransaction
    <B> -> Transaction

'it' @ [106:28] ==> value-parameter it: PartiallyResolvedTransaction defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[ValueParameterDescriptorImpl]

'inputs' @ [106:31] ==> public final val inputs: List<ObservableValue<PartiallyResolvedTransaction.InputResolution>> defined in net.corda.client.jfx.model.PartiallyResolvedTransaction[DeserializedPropertyDescriptor]

'sequence' @ [106:38] ==> public fun <A> Collection<ObservableValue<out PartiallyResolvedTransaction.InputResolution>>.sequence(): ObservableList<PartiallyResolvedTransaction.InputResolution> defined in net.corda.client.jfx.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> InputResolution

'map' @ [107:22] ==> public fun <A, B> ObservableList<out PartiallyResolvedTransaction.InputResolution>.map(cached: Boolean = ..., function: (PartiallyResolvedTransaction.InputResolution) -> PartiallyResolvedTransaction.InputResolution.Resolved?): ObservableList<PartiallyResolvedTransaction.InputResolution.Resolved?> defined in net.corda.client.jfx.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> InputResolution
    <B> -> Resolved?

'it' @ [107:28] ==> value-parameter it: PartiallyResolvedTransaction.InputResolution defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'filterNotNull' @ [108:22] ==> public fun <A> ObservableList<out PartiallyResolvedTransaction.InputResolution.Resolved?>.filterNotNull(): ObservableList<PartiallyResolvedTransaction.InputResolution.Resolved> defined in net.corda.client.jfx.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Resolved

'map' @ [109:22] ==> public fun <A, B> ObservableList<out PartiallyResolvedTransaction.InputResolution.Resolved>.map(cached: Boolean = ..., function: (PartiallyResolvedTransaction.InputResolution.Resolved) -> StateAndRef<ContractState>): ObservableList<StateAndRef<ContractState>> defined in net.corda.client.jfx.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Resolved
    <B> -> StateAndRef<ContractState>

'it' @ [109:28] ==> value-parameter it: PartiallyResolvedTransaction.InputResolution.Resolved defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'stateAndRef' @ [109:31] ==> public final val stateAndRef: StateAndRef<ContractState> defined in net.corda.client.jfx.model.PartiallyResolvedTransaction.InputResolution.Resolved[DeserializedPropertyDescriptor]

'it' @ [110:30] ==> value-parameter it: PartiallyResolvedTransaction defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[ValueParameterDescriptorImpl]

'inputs' @ [110:33] ==> public final val inputs: List<ObservableValue<PartiallyResolvedTransaction.InputResolution>> defined in net.corda.client.jfx.model.PartiallyResolvedTransaction[DeserializedPropertyDescriptor]

'sequence' @ [110:40] ==> public fun <A> Collection<ObservableValue<out PartiallyResolvedTransaction.InputResolution>>.sequence(): ObservableList<PartiallyResolvedTransaction.InputResolution> defined in net.corda.client.jfx.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> InputResolution

'map' @ [111:22] ==> public fun <A, B> ObservableList<out PartiallyResolvedTransaction.InputResolution>.map(cached: Boolean = ..., function: (PartiallyResolvedTransaction.InputResolution) -> PartiallyResolvedTransaction.InputResolution.Unresolved?): ObservableList<PartiallyResolvedTransaction.InputResolution.Unresolved?> defined in net.corda.client.jfx.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> InputResolution
    <B> -> Unresolved?

'it' @ [111:28] ==> value-parameter it: PartiallyResolvedTransaction.InputResolution defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'filterNotNull' @ [112:22] ==> public fun <A> ObservableList<out PartiallyResolvedTransaction.InputResolution.Unresolved?>.filterNotNull(): ObservableList<PartiallyResolvedTransaction.InputResolution.Unresolved> defined in net.corda.client.jfx.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Unresolved

'map' @ [113:22] ==> public fun <A, B> ObservableList<out PartiallyResolvedTransaction.InputResolution.Unresolved>.map(cached: Boolean = ..., function: (PartiallyResolvedTransaction.InputResolution.Unresolved) -> StateRef): ObservableList<StateRef> defined in net.corda.client.jfx.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> Unresolved
    <B> -> StateRef

'it' @ [113:28] ==> value-parameter it: PartiallyResolvedTransaction.InputResolution.Unresolved defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'stateRef' @ [113:31] ==> public open val stateRef: StateRef defined in net.corda.client.jfx.model.PartiallyResolvedTransaction.InputResolution.Unresolved[DeserializedPropertyDescriptor]

'it' @ [114:27] ==> value-parameter it: PartiallyResolvedTransaction defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[ValueParameterDescriptorImpl]

'transaction' @ [114:30] ==> public final val transaction: SignedTransaction defined in net.corda.client.jfx.model.PartiallyResolvedTransaction[DeserializedPropertyDescriptor]

'tx' @ [114:42] ==> public final val tx: WireTransaction defined in net.corda.core.transactions.SignedTransaction[DeserializedPropertyDescriptor]

'outputs' @ [114:45] ==> public open val outputs: List<TransactionState<ContractState>> defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'mapIndexed' @ [115:22] ==> public inline fun <T, R> Iterable<TransactionState<ContractState>>.mapIndexed(transform: (index: Int, TransactionState<ContractState>) -> StateAndRef<ContractState>): List<StateAndRef<ContractState>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TransactionState<ContractState>
    <R> -> StateAndRef<ContractState>

'StateRef' @ [116:40] ==> public constructor StateRef(txhash: SecureHash, index: Int) defined in net.corda.core.contracts.StateRef[DeserializedClassConstructorDescriptor]

'it' @ [116:49] ==> value-parameter it: PartiallyResolvedTransaction defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[ValueParameterDescriptorImpl]

'id' @ [116:52] ==> public final val id: SecureHash defined in net.corda.client.jfx.model.PartiallyResolvedTransaction[DeserializedPropertyDescriptor]

'index' @ [116:56] ==> value-parameter index: Int defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'StateAndRef' @ [117:25] ==> public constructor StateAndRef<out T : ContractState>(state: TransactionState<ContractState>, ref: StateRef) defined in net.corda.core.contracts.StateAndRef[DeserializedClassConstructorDescriptor]
Inferred types:
    <out T : ContractState> -> ContractState

'transactionState' @ [117:37] ==> value-parameter transactionState: TransactionState<ContractState> defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'stateRef' @ [117:55] ==> val stateRef: StateRef defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[LocalVariableDescriptor]

'observable' @ [118:23] ==> public fun <T> List<StateAndRef<ContractState>>.observable(): ObservableList<StateAndRef<ContractState>> defined in tornadofx[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> StateAndRef<ContractState>

'Transaction' @ [119:13] ==> public constructor Transaction(tx: PartiallyResolvedTransaction, id: SecureHash, inputs: TransactionViewer.Inputs, outputs: ObservableList<StateAndRef<ContractState>>, inputParties: ObservableList<List<ObservableValue<NodeInfo?>>>, outputParties: ObservableList<List<ObservableValue<NodeInfo?>>>, commandTypes: List<Class<CommandData>>, totalValueEquiv: ObservableValue<AmountDiff<Currency>>) defined in net.corda.explorer.views.TransactionViewer.Transaction[ClassConstructorDescriptorImpl]

'it' @ [120:26] ==> value-parameter it: PartiallyResolvedTransaction defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[ValueParameterDescriptorImpl]

'it' @ [121:26] ==> value-parameter it: PartiallyResolvedTransaction defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[ValueParameterDescriptorImpl]

'id' @ [121:29] ==> public final val id: SecureHash defined in net.corda.client.jfx.model.PartiallyResolvedTransaction[DeserializedPropertyDescriptor]

'Inputs' @ [122:30] ==> public constructor Inputs(resolved: ObservableList<StateAndRef<ContractState>>, unresolved: ObservableList<StateRef>) defined in net.corda.explorer.views.TransactionViewer.Inputs[ClassConstructorDescriptorImpl]

'resolved' @ [122:37] ==> val resolved: ObservableList<StateAndRef<ContractState>> defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[LocalVariableDescriptor]

'unresolved' @ [122:47] ==> val unresolved: ObservableList<StateRef> defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[LocalVariableDescriptor]

'outputs' @ [123:31] ==> val outputs: ObservableList<StateAndRef<ContractState>> defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[LocalVariableDescriptor]

'resolved' @ [124:36] ==> val resolved: ObservableList<StateAndRef<ContractState>> defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[LocalVariableDescriptor]

'getParties' @ [124:45] ==> private final fun ObservableList<StateAndRef<ContractState>>.getParties(): ObservableList<List<ObservableValue<NodeInfo?>>> defined in net.corda.explorer.views.TransactionViewer[SimpleFunctionDescriptorImpl]

'outputs' @ [125:37] ==> val outputs: ObservableList<StateAndRef<ContractState>> defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[LocalVariableDescriptor]

'getParties' @ [125:45] ==> private final fun ObservableList<StateAndRef<ContractState>>.getParties(): ObservableList<List<ObservableValue<NodeInfo?>>> defined in net.corda.explorer.views.TransactionViewer[SimpleFunctionDescriptorImpl]

'it' @ [126:36] ==> value-parameter it: PartiallyResolvedTransaction defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[ValueParameterDescriptorImpl]

'transaction' @ [126:39] ==> public final val transaction: SignedTransaction defined in net.corda.client.jfx.model.PartiallyResolvedTransaction[DeserializedPropertyDescriptor]

'tx' @ [126:51] ==> public final val tx: WireTransaction defined in net.corda.core.transactions.SignedTransaction[DeserializedPropertyDescriptor]

'commands' @ [126:54] ==> public open val commands: List<Command<*>> defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'map' @ [126:63] ==> public inline fun <T, R> Iterable<Command<*>>.map(transform: (Command<*>) -> Class<CommandData>): List<Class<CommandData>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Command<*>
    <R> -> Class<CommandData>

'it' @ [126:69] ==> value-parameter it: Command<*> defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [126:72] ==> public final val value: CommandData defined in net.corda.core.contracts.Command[DeserializedPropertyDescriptor]

'javaClass' @ [126:78] ==> public val <T : Any> CommandData.javaClass: Class<CommandData> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> CommandData

'calculateTotalEquiv' @ [127:41] ==> private fun calculateTotalEquiv(identity: NodeInfo?, reportingCurrencyExchange: Pair<Currency, (Amount<Currency>) -> Amount<Currency>>, inputs: List<ContractState>, outputs: List<ContractState>): AmountDiff<Currency> defined in net.corda.explorer.views in file TransactionViewer.kt[SimpleFunctionDescriptorImpl]

'lift' @ [127:61] ==> public fun <A, B, C, D, R> ((NodeInfo?, Pair<Currency, (Amount<Currency>) -> Amount<Currency>>, ObservableList<ContractState>, List<ContractState>) -> AmountDiff<Currency>).lift(arg0: ObservableValue<NodeInfo?>, arg1: ObservableValue<Pair<Currency, (Amount<Currency>) -> Amount<Currency>>>, arg2: ObservableValue<ObservableList<ContractState>>, arg3: ObservableValue<List<ContractState>>): ObservableValue<AmountDiff<Currency>> defined in net.corda.client.jfx.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> NodeInfo?
    <B> -> Pair<Currency, Function1<Amount<Currency>, Amount<Currency>>>
    <C> -> ObservableList<ContractState>
    <D> -> List<ContractState>
    <R> -> AmountDiff<Currency>

'myIdentity' @ [127:66] ==> private final val myIdentity: ObservableValue<NodeInfo?> defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'reportingExchange' @ [128:29] ==> private final val reportingExchange: ObservableValue<Pair<Currency, (Amount<Currency>) -> Amount<Currency>>> defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'resolved' @ [129:29] ==> val resolved: ObservableList<StateAndRef<ContractState>> defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[LocalVariableDescriptor]

'map' @ [129:38] ==> public fun <A, B> ObservableList<out StateAndRef<ContractState>>.map(cached: Boolean = ..., function: (StateAndRef<ContractState>) -> ContractState): ObservableList<ContractState> defined in net.corda.client.jfx.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> StateAndRef<ContractState>
    <B> -> ContractState

'it' @ [129:44] ==> value-parameter it: StateAndRef<ContractState> defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'state' @ [129:47] ==> public final val state: TransactionState<ContractState> defined in net.corda.core.contracts.StateAndRef[DeserializedPropertyDescriptor]

'data' @ [129:53] ==> public final val data: ContractState defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'lift' @ [129:60] ==> public fun <A> ObservableList<ContractState>.lift(): ObservableValue<ObservableList<ContractState>> defined in net.corda.client.jfx.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> ObservableList<ContractState>

'it' @ [130:29] ==> value-parameter it: PartiallyResolvedTransaction defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[ValueParameterDescriptorImpl]

'transaction' @ [130:32] ==> public final val transaction: SignedTransaction defined in net.corda.client.jfx.model.PartiallyResolvedTransaction[DeserializedPropertyDescriptor]

'tx' @ [130:44] ==> public final val tx: WireTransaction defined in net.corda.core.transactions.SignedTransaction[DeserializedPropertyDescriptor]

'outputStates' @ [130:47] ==> public final val outputStates: List<ContractState> defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'lift' @ [130:60] ==> public fun <A> List<ContractState>.lift(): ObservableValue<List<ContractState>> defined in net.corda.client.jfx.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> List<ContractState>

'SearchField' @ [134:27] ==> public constructor SearchField<T>(data: ObservableList<TransactionViewer.Transaction>, vararg filterCriteria: Pair<String, (TransactionViewer.Transaction, String) -> Boolean>) defined in net.corda.explorer.views.SearchField[ClassConstructorDescriptorImpl]
Inferred types:
    <T> -> Transaction

'transactions' @ [134:39] ==> val transactions: ObservableList<TransactionViewer.Transaction> defined in net.corda.explorer.views.TransactionViewer.<init>[LocalVariableDescriptor]

'to' @ [135:17] ==> public infix fun <A, B> String.to(that: (TransactionViewer.Transaction, String) -> Boolean): Pair<String, (TransactionViewer.Transaction, String) -> Boolean> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> Function2<Transaction, String, Boolean>

'tx' @ [135:51] ==> value-parameter tx: TransactionViewer.Transaction defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[ValueParameterDescriptorImpl]

'id' @ [135:54] ==> public final val id: SecureHash defined in net.corda.explorer.views.TransactionViewer.Transaction[PropertyDescriptorImpl]

'contains' @ [135:59] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

's' @ [135:68] ==> value-parameter s: String defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[ValueParameterDescriptorImpl]

'to' @ [136:17] ==> public infix fun <A, B> String.to(that: (TransactionViewer.Transaction, String) -> Boolean): Pair<String, (TransactionViewer.Transaction, String) -> Boolean> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> Function2<Transaction, String, Boolean>

'tx' @ [136:39] ==> value-parameter tx: TransactionViewer.Transaction defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[ValueParameterDescriptorImpl]

'inputs' @ [136:42] ==> public final val inputs: TransactionViewer.Inputs defined in net.corda.explorer.views.TransactionViewer.Transaction[PropertyDescriptorImpl]

'resolved' @ [136:49] ==> public final val resolved: ObservableList<StateAndRef<ContractState>> defined in net.corda.explorer.views.TransactionViewer.Inputs[PropertyDescriptorImpl]

'any' @ [136:58] ==> public inline fun <T> Iterable<(StateAndRef<ContractState>..StateAndRef<ContractState>?)>.any(predicate: ((StateAndRef<ContractState>..StateAndRef<ContractState>?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (net.corda.core.contracts.StateAndRef<net.corda.core.contracts.ContractState>..net.corda.core.contracts.StateAndRef<net.corda.core.contracts.ContractState>?)

'it' @ [136:64] ==> value-parameter it: (StateAndRef<ContractState>..StateAndRef<ContractState>?) defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'state' @ [136:67] ==> public final val state: TransactionState<ContractState> defined in net.corda.core.contracts.StateAndRef[DeserializedPropertyDescriptor]

'data' @ [136:73] ==> public final val data: ContractState defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'contract' @ [136:78] ==> public abstract val contract: Contract defined in net.corda.core.contracts.ContractState[DeserializedPropertyDescriptor]

'javaClass' @ [136:87] ==> public val <T : Any> Contract.javaClass: Class<Contract> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> Contract

'simpleName' @ [136:97] ==> public final val <T : (Any..Any?)> Class<Contract>.simpleName: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Contract

'contains' @ [136:108] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

's' @ [136:117] ==> value-parameter s: String defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[ValueParameterDescriptorImpl]

'to' @ [137:17] ==> public infix fun <A, B> String.to(that: (TransactionViewer.Transaction, String) -> Boolean): Pair<String, (TransactionViewer.Transaction, String) -> Boolean> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> Function2<Transaction, String, Boolean>

'tx' @ [137:40] ==> value-parameter tx: TransactionViewer.Transaction defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[ValueParameterDescriptorImpl]

'outputs' @ [137:43] ==> public final val outputs: ObservableList<StateAndRef<ContractState>> defined in net.corda.explorer.views.TransactionViewer.Transaction[PropertyDescriptorImpl]

'any' @ [137:51] ==> public inline fun <T> Iterable<(StateAndRef<ContractState>..StateAndRef<ContractState>?)>.any(predicate: ((StateAndRef<ContractState>..StateAndRef<ContractState>?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (net.corda.core.contracts.StateAndRef<net.corda.core.contracts.ContractState>..net.corda.core.contracts.StateAndRef<net.corda.core.contracts.ContractState>?)

'it' @ [137:57] ==> value-parameter it: (StateAndRef<ContractState>..StateAndRef<ContractState>?) defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'state' @ [137:60] ==> public final val state: TransactionState<ContractState> defined in net.corda.core.contracts.StateAndRef[DeserializedPropertyDescriptor]

'data' @ [137:66] ==> public final val data: ContractState defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'contract' @ [137:71] ==> public abstract val contract: Contract defined in net.corda.core.contracts.ContractState[DeserializedPropertyDescriptor]

'javaClass' @ [137:80] ==> public val <T : Any> Contract.javaClass: Class<Contract> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> Contract

'simpleName' @ [137:90] ==> public final val <T : (Any..Any?)> Class<Contract>.simpleName: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Contract

'contains' @ [137:101] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

's' @ [137:110] ==> value-parameter s: String defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[ValueParameterDescriptorImpl]

'to' @ [138:17] ==> public infix fun <A, B> String.to(that: (TransactionViewer.Transaction, String) -> Boolean): Pair<String, (TransactionViewer.Transaction, String) -> Boolean> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> Function2<Transaction, String, Boolean>

'tx' @ [138:45] ==> value-parameter tx: TransactionViewer.Transaction defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[ValueParameterDescriptorImpl]

'inputParties' @ [138:48] ==> public final val inputParties: ObservableList<List<ObservableValue<NodeInfo?>>> defined in net.corda.explorer.views.TransactionViewer.Transaction[PropertyDescriptorImpl]

'any' @ [138:61] ==> public inline fun <T> Iterable<(List<ObservableValue<NodeInfo?>>..List<ObservableValue<NodeInfo?>>?)>.any(predicate: ((List<ObservableValue<NodeInfo?>>..List<ObservableValue<NodeInfo?>>?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.collections.List<javafx.beans.value.ObservableValue<net.corda.core.node.NodeInfo?>>..kotlin.collections.List<javafx.beans.value.ObservableValue<net.corda.core.node.NodeInfo?>>?)

'it' @ [138:67] ==> value-parameter it: (List<ObservableValue<NodeInfo?>>..List<ObservableValue<NodeInfo?>>?) defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'any' @ [138:70] ==> public inline fun <T> Iterable<ObservableValue<NodeInfo?>>.any(predicate: (ObservableValue<NodeInfo?>) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ObservableValue<NodeInfo?>

'it' @ [138:76] ==> value-parameter it: ObservableValue<NodeInfo?> defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [138:79] ==> public final val <T : (Any..Any?)> ObservableValue<NodeInfo?>.value: NodeInfo?[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> NodeInfo?

'legalIdentity' @ [138:86] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'name' @ [138:101] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'commonName' @ [138:107] ==> public val X500Name.commonName: String defined in net.corda.core.crypto[DeserializedPropertyDescriptor]

'contains' @ [138:119] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

's' @ [138:128] ==> value-parameter s: String defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[ValueParameterDescriptorImpl]

'to' @ [139:17] ==> public infix fun <A, B> String.to(that: (TransactionViewer.Transaction, String) -> Boolean): Pair<String, (TransactionViewer.Transaction, String) -> Boolean> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> Function2<Transaction, String, Boolean>

'tx' @ [139:46] ==> value-parameter tx: TransactionViewer.Transaction defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[ValueParameterDescriptorImpl]

'outputParties' @ [139:49] ==> public final val outputParties: ObservableList<List<ObservableValue<NodeInfo?>>> defined in net.corda.explorer.views.TransactionViewer.Transaction[PropertyDescriptorImpl]

'any' @ [139:63] ==> public inline fun <T> Iterable<(List<ObservableValue<NodeInfo?>>..List<ObservableValue<NodeInfo?>>?)>.any(predicate: ((List<ObservableValue<NodeInfo?>>..List<ObservableValue<NodeInfo?>>?)) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.collections.List<javafx.beans.value.ObservableValue<net.corda.core.node.NodeInfo?>>..kotlin.collections.List<javafx.beans.value.ObservableValue<net.corda.core.node.NodeInfo?>>?)

'it' @ [139:69] ==> value-parameter it: (List<ObservableValue<NodeInfo?>>..List<ObservableValue<NodeInfo?>>?) defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'any' @ [139:72] ==> public inline fun <T> Iterable<ObservableValue<NodeInfo?>>.any(predicate: (ObservableValue<NodeInfo?>) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ObservableValue<NodeInfo?>

'it' @ [139:78] ==> value-parameter it: ObservableValue<NodeInfo?> defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [139:81] ==> public final val <T : (Any..Any?)> ObservableValue<NodeInfo?>.value: NodeInfo?[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> NodeInfo?

'legalIdentity' @ [139:88] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'name' @ [139:103] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'commonName' @ [139:109] ==> public val X500Name.commonName: String defined in net.corda.core.crypto[DeserializedPropertyDescriptor]

'contains' @ [139:121] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

's' @ [139:130] ==> value-parameter s: String defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[ValueParameterDescriptorImpl]

'to' @ [140:17] ==> public infix fun <A, B> String.to(that: (TransactionViewer.Transaction, String) -> Boolean): Pair<String, (TransactionViewer.Transaction, String) -> Boolean> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> Function2<Transaction, String, Boolean>

'tx' @ [140:46] ==> value-parameter tx: TransactionViewer.Transaction defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[ValueParameterDescriptorImpl]

'commandTypes' @ [140:49] ==> public final val commandTypes: List<Class<CommandData>> defined in net.corda.explorer.views.TransactionViewer.Transaction[PropertyDescriptorImpl]

'any' @ [140:62] ==> public inline fun <T> Iterable<Class<CommandData>>.any(predicate: (Class<CommandData>) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Class<CommandData>

'it' @ [140:68] ==> value-parameter it: Class<CommandData> defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'simpleName' @ [140:71] ==> public final val <T : (Any..Any?)> Class<CommandData>.simpleName: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> CommandData

'contains' @ [140:82] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

's' @ [140:91] ==> value-parameter s: String defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[ValueParameterDescriptorImpl]

'root' @ [142:9] ==> public open val root: BorderPane defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'top' @ [142:14] ==> public final var BorderPane.top: (Node..Node?)[MyPropertyDescriptor]

'searchField' @ [142:20] ==> val searchField: SearchField<TransactionViewer.Transaction> defined in net.corda.explorer.views.TransactionViewer.<init>[LocalVariableDescriptor]

'root' @ [142:32] ==> public open val root: Parent defined in net.corda.explorer.views.SearchField[PropertyDescriptorImpl]

'transactionViewTable' @ [144:9] ==> private final val transactionViewTable: TableView<TransactionViewer.Transaction> defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'apply' @ [144:30] ==> @InlineOnly public inline fun <T> TableView<TransactionViewer.Transaction>.apply(block: TableView<TransactionViewer.Transaction>.() -> Unit): TableView<TransactionViewer.Transaction> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TableView<Transaction>

'items' @ [145:13] ==> public final var <S : (Any..Any?)> TableView<TransactionViewer.Transaction>.items: (ObservableList<(TransactionViewer.Transaction..TransactionViewer.Transaction?)>..ObservableList<(TransactionViewer.Transaction..TransactionViewer.Transaction?)>?)[MyPropertyDescriptor]
Inferred types:
    <S : (Any..Any?)> -> Transaction

'searchField' @ [145:21] ==> val searchField: SearchField<TransactionViewer.Transaction> defined in net.corda.explorer.views.TransactionViewer.<init>[LocalVariableDescriptor]

'filteredData' @ [145:33] ==> public final val filteredData: ChosenList<(TransactionViewer.Transaction..TransactionViewer.Transaction?)> defined in net.corda.explorer.views.SearchField[PropertyDescriptorImpl]

'column' @ [146:13] ==> public inline fun <reified S, T> TableView<TransactionViewer.Transaction>.column(title: String, prop: KProperty1<TransactionViewer.Transaction, SecureHash>, noinline op: (TableColumn<TransactionViewer.Transaction, SecureHash>.() -> Unit)? = ...): TableColumn<TransactionViewer.Transaction, SecureHash> defined in tornadofx[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified S> -> Transaction
    <T> -> SecureHash

'Transaction' @ [146:38] ==> public constructor Transaction(tx: PartiallyResolvedTransaction, id: SecureHash, inputs: TransactionViewer.Inputs, outputs: ObservableList<StateAndRef<ContractState>>, inputParties: ObservableList<List<ObservableValue<NodeInfo?>>>, outputParties: ObservableList<List<ObservableValue<NodeInfo?>>>, commandTypes: List<Class<CommandData>>, totalValueEquiv: ObservableValue<AmountDiff<Currency>>) defined in net.corda.explorer.views.TransactionViewer.Transaction[ClassConstructorDescriptorImpl]

'id' @ [146:51] ==> public final val id: SecureHash defined in net.corda.explorer.views.TransactionViewer.Transaction[PropertyDescriptorImpl]

'minWidth' @ [147:17] ==> public final var <S : (Any..Any?), T : (Any..Any?)> TableColumn<TransactionViewer.Transaction, SecureHash>.minWidth: Double[MyPropertyDescriptor]
Inferred types:
    <S : (Any..Any?)> -> Transaction
    <T : (Any..Any?)> -> SecureHash

'maxWidth' @ [148:17] ==> public final var <S : (Any..Any?), T : (Any..Any?)> TableColumn<TransactionViewer.Transaction, SecureHash>.maxWidth: Double[MyPropertyDescriptor]
Inferred types:
    <S : (Any..Any?)> -> Transaction
    <T : (Any..Any?)> -> SecureHash

'setCustomCellFactory' @ [149:15] ==> public fun <S, T> TableColumn<TransactionViewer.Transaction, SecureHash>.setCustomCellFactory(toNode: (SecureHash) -> Node): Unit defined in net.corda.explorer.ui[SimpleFunctionDescriptorImpl]
Inferred types:
    <S> -> Transaction
    <T> -> SecureHash

'label' @ [150:17] ==> public fun EventTarget.label(text: String = ..., op: (Label.() -> Unit)? = ...): Label defined in tornadofx[DeserializedSimpleFunctionDescriptor]

'it' @ [150:25] ==> value-parameter it: SecureHash defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'graphic' @ [151:21] ==> public final var Label.graphic: (Node..Node?)[MyPropertyDescriptor]

'identicon' @ [151:31] ==> public fun identicon(secureHash: SecureHash, size: Double): ImageView defined in net.corda.explorer.identicon in file IdenticonRenderer.kt[SimpleFunctionDescriptorImpl]

'it' @ [151:41] ==> value-parameter it: SecureHash defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'tooltip' @ [152:21] ==> public final var Label.tooltip: (Tooltip..Tooltip?)[MyPropertyDescriptor]

'identiconToolTip' @ [152:31] ==> public fun identiconToolTip(secureHash: SecureHash, description: String? = ...): Tooltip defined in net.corda.explorer.identicon in file IdenticonRenderer.kt[SimpleFunctionDescriptorImpl]

'it' @ [152:48] ==> value-parameter it: SecureHash defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'column' @ [155:13] ==> public inline fun <reified S, T> TableView<TransactionViewer.Transaction>.column(title: String, prop: KProperty1<TransactionViewer.Transaction, TransactionViewer.Inputs>, noinline op: (TableColumn<TransactionViewer.Transaction, TransactionViewer.Inputs>.() -> Unit)? = ...): TableColumn<TransactionViewer.Transaction, TransactionViewer.Inputs> defined in tornadofx[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified S> -> Transaction
    <T> -> Inputs

'Transaction' @ [155:29] ==> public constructor Transaction(tx: PartiallyResolvedTransaction, id: SecureHash, inputs: TransactionViewer.Inputs, outputs: ObservableList<StateAndRef<ContractState>>, inputParties: ObservableList<List<ObservableValue<NodeInfo?>>>, outputParties: ObservableList<List<ObservableValue<NodeInfo?>>>, commandTypes: List<Class<CommandData>>, totalValueEquiv: ObservableValue<AmountDiff<Currency>>) defined in net.corda.explorer.views.TransactionViewer.Transaction[ClassConstructorDescriptorImpl]

'inputs' @ [155:42] ==> public final val inputs: TransactionViewer.Inputs defined in net.corda.explorer.views.TransactionViewer.Transaction[PropertyDescriptorImpl]

'cellFormat' @ [155:50] ==> public fun <S, T> TableColumn<TransactionViewer.Transaction, TransactionViewer.Inputs>.cellFormat(formatter: TableCell<TransactionViewer.Transaction, TransactionViewer.Inputs>.(TransactionViewer.Inputs) -> Unit): Unit defined in tornadofx[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <S> -> Transaction
    <T> -> Inputs

'text' @ [156:17] ==> public final var <S : (Any..Any?), T : (Any..Any?)> TableCell<TransactionViewer.Transaction, TransactionViewer.Inputs>.text: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <S : (Any..Any?)> -> Transaction
    <T : (Any..Any?)> -> Inputs

'it' @ [156:24] ==> value-parameter it: TransactionViewer.Inputs defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'resolved' @ [156:27] ==> public final val resolved: ObservableList<StateAndRef<ContractState>> defined in net.corda.explorer.views.TransactionViewer.Inputs[PropertyDescriptorImpl]

'toText' @ [156:36] ==> private final fun ObservableList<StateAndRef<ContractState>>.toText(): String defined in net.corda.explorer.views.TransactionViewer[SimpleFunctionDescriptorImpl]

'!' @ [157:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'it' @ [157:22] ==> value-parameter it: TransactionViewer.Inputs defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'unresolved' @ [157:25] ==> public final val unresolved: ObservableList<StateRef> defined in net.corda.explorer.views.TransactionViewer.Inputs[PropertyDescriptorImpl]

'isEmpty' @ [157:36] ==> public abstract fun isEmpty(): Boolean defined in javafx.collections.ObservableList[DeserializedSimpleFunctionDescriptor]

'!' @ [158:25] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'text' @ [158:26] ==> public final var <S : (Any..Any?), T : (Any..Any?)> TableCell<TransactionViewer.Transaction, TransactionViewer.Inputs>.text: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <S : (Any..Any?)> -> Transaction
    <T : (Any..Any?)> -> Inputs

'isBlank' @ [158:31] ==> public fun CharSequence.isBlank(): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'text' @ [159:25] ==> public final var <S : (Any..Any?), T : (Any..Any?)> TableCell<TransactionViewer.Transaction, TransactionViewer.Inputs>.text: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <S : (Any..Any?)> -> Transaction
    <T : (Any..Any?)> -> Inputs

'text' @ [161:21] ==> public final var <S : (Any..Any?), T : (Any..Any?)> TableCell<TransactionViewer.Transaction, TransactionViewer.Inputs>.text: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <S : (Any..Any?)> -> Transaction
    <T : (Any..Any?)> -> Inputs

'it' @ [161:43] ==> value-parameter it: TransactionViewer.Inputs defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'unresolved' @ [161:46] ==> public final val unresolved: ObservableList<StateRef> defined in net.corda.explorer.views.TransactionViewer.Inputs[PropertyDescriptorImpl]

'size' @ [161:57] ==> public abstract val size: Int defined in javafx.collections.ObservableList[DeserializedPropertyDescriptor]

'column' @ [164:13] ==> public inline fun <reified S, T> TableView<TransactionViewer.Transaction>.column(title: String, prop: KProperty1<TransactionViewer.Transaction, ObservableList<StateAndRef<ContractState>>>, noinline op: (TableColumn<TransactionViewer.Transaction, ObservableList<StateAndRef<ContractState>>>.() -> Unit)? = ...): TableColumn<TransactionViewer.Transaction, ObservableList<StateAndRef<ContractState>>> defined in tornadofx[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified S> -> Transaction
    <T> -> ObservableList<StateAndRef<ContractState>>

'Transaction' @ [164:30] ==> public constructor Transaction(tx: PartiallyResolvedTransaction, id: SecureHash, inputs: TransactionViewer.Inputs, outputs: ObservableList<StateAndRef<ContractState>>, inputParties: ObservableList<List<ObservableValue<NodeInfo?>>>, outputParties: ObservableList<List<ObservableValue<NodeInfo?>>>, commandTypes: List<Class<CommandData>>, totalValueEquiv: ObservableValue<AmountDiff<Currency>>) defined in net.corda.explorer.views.TransactionViewer.Transaction[ClassConstructorDescriptorImpl]

'outputs' @ [164:43] ==> public final val outputs: ObservableList<StateAndRef<ContractState>> defined in net.corda.explorer.views.TransactionViewer.Transaction[PropertyDescriptorImpl]

'cellFormat' @ [164:52] ==> public fun <S, T> TableColumn<TransactionViewer.Transaction, ObservableList<StateAndRef<ContractState>>>.cellFormat(formatter: TableCell<TransactionViewer.Transaction, ObservableList<StateAndRef<ContractState>>>.(ObservableList<StateAndRef<ContractState>>) -> Unit): Unit defined in tornadofx[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <S> -> Transaction
    <T> -> ObservableList<StateAndRef<ContractState>>

'text' @ [164:65] ==> public final var <S : (Any..Any?), T : (Any..Any?)> TableCell<TransactionViewer.Transaction, ObservableList<StateAndRef<ContractState>>>.text: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <S : (Any..Any?)> -> Transaction
    <T : (Any..Any?)> -> ObservableList<StateAndRef<ContractState>>

'it' @ [164:72] ==> value-parameter it: ObservableList<StateAndRef<ContractState>> defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'toText' @ [164:75] ==> private final fun ObservableList<StateAndRef<ContractState>>.toText(): String defined in net.corda.explorer.views.TransactionViewer[SimpleFunctionDescriptorImpl]

'column' @ [165:13] ==> public inline fun <reified S, T> TableView<TransactionViewer.Transaction>.column(title: String, prop: KProperty1<TransactionViewer.Transaction, ObservableList<List<ObservableValue<NodeInfo?>>>>, noinline op: (TableColumn<TransactionViewer.Transaction, ObservableList<List<ObservableValue<NodeInfo?>>>>.() -> Unit)? = ...): TableColumn<TransactionViewer.Transaction, ObservableList<List<ObservableValue<NodeInfo?>>>> defined in tornadofx[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified S> -> Transaction
    <T> -> ObservableList<List<ObservableValue<NodeInfo?>>>

'Transaction' @ [165:35] ==> public constructor Transaction(tx: PartiallyResolvedTransaction, id: SecureHash, inputs: TransactionViewer.Inputs, outputs: ObservableList<StateAndRef<ContractState>>, inputParties: ObservableList<List<ObservableValue<NodeInfo?>>>, outputParties: ObservableList<List<ObservableValue<NodeInfo?>>>, commandTypes: List<Class<CommandData>>, totalValueEquiv: ObservableValue<AmountDiff<Currency>>) defined in net.corda.explorer.views.TransactionViewer.Transaction[ClassConstructorDescriptorImpl]

'inputParties' @ [165:48] ==> public final val inputParties: ObservableList<List<ObservableValue<NodeInfo?>>> defined in net.corda.explorer.views.TransactionViewer.Transaction[PropertyDescriptorImpl]

'setCustomCellFactory' @ [165:62] ==> public fun <S, T> TableColumn<TransactionViewer.Transaction, ObservableList<List<ObservableValue<NodeInfo?>>>>.setCustomCellFactory(toNode: (ObservableList<List<ObservableValue<NodeInfo?>>>) -> Node): Unit defined in net.corda.explorer.ui[SimpleFunctionDescriptorImpl]
Inferred types:
    <S> -> Transaction
    <T> -> ObservableList<List<ObservableValue<NodeInfo?>>>

'label' @ [166:17] ==> public fun EventTarget.label(text: String = ..., op: (Label.() -> Unit)? = ...): Label defined in tornadofx[DeserializedSimpleFunctionDescriptor]

'text' @ [167:21] ==> public final var Label.text: (String..String?)[MyPropertyDescriptor]

'it' @ [167:28] ==> value-parameter it: ObservableList<List<ObservableValue<NodeInfo?>>> defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'formatJoinPartyNames' @ [167:31] ==> private final fun ObservableList<List<ObservableValue<NodeInfo?>>>.formatJoinPartyNames(separator: String = ..., formatter: Formatter<X500Name>): String defined in net.corda.explorer.views.TransactionViewer[SimpleFunctionDescriptorImpl]

'short' @ [167:83] ==> public final val short: Formatter<X500Name> defined in net.corda.explorer.formatters.PartyNameFormatter[PropertyDescriptorImpl]

'tooltip' @ [168:21] ==> public fun Node.tooltip(text: String? = ..., graphic: Node? = ..., op: (Tooltip.() -> Unit)? = ...): Tooltip defined in tornadofx[DeserializedSimpleFunctionDescriptor]

'text' @ [169:25] ==> public final var Tooltip.text: (String..String?)[MyPropertyDescriptor]

'it' @ [169:32] ==> value-parameter it: ObservableList<List<ObservableValue<NodeInfo?>>> defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'formatJoinPartyNames' @ [169:35] ==> private final fun ObservableList<List<ObservableValue<NodeInfo?>>>.formatJoinPartyNames(separator: String = ..., formatter: Formatter<X500Name>): String defined in net.corda.explorer.views.TransactionViewer[SimpleFunctionDescriptorImpl]

'full' @ [169:81] ==> public final val full: Formatter<X500Name> defined in net.corda.explorer.formatters.PartyNameFormatter[PropertyDescriptorImpl]

'column' @ [173:13] ==> public inline fun <reified S, T> TableView<TransactionViewer.Transaction>.column(title: String, prop: KProperty1<TransactionViewer.Transaction, ObservableList<List<ObservableValue<NodeInfo?>>>>, noinline op: (TableColumn<TransactionViewer.Transaction, ObservableList<List<ObservableValue<NodeInfo?>>>>.() -> Unit)? = ...): TableColumn<TransactionViewer.Transaction, ObservableList<List<ObservableValue<NodeInfo?>>>> defined in tornadofx[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified S> -> Transaction
    <T> -> ObservableList<List<ObservableValue<NodeInfo?>>>

'Transaction' @ [173:36] ==> public constructor Transaction(tx: PartiallyResolvedTransaction, id: SecureHash, inputs: TransactionViewer.Inputs, outputs: ObservableList<StateAndRef<ContractState>>, inputParties: ObservableList<List<ObservableValue<NodeInfo?>>>, outputParties: ObservableList<List<ObservableValue<NodeInfo?>>>, commandTypes: List<Class<CommandData>>, totalValueEquiv: ObservableValue<AmountDiff<Currency>>) defined in net.corda.explorer.views.TransactionViewer.Transaction[ClassConstructorDescriptorImpl]

'outputParties' @ [173:49] ==> public final val outputParties: ObservableList<List<ObservableValue<NodeInfo?>>> defined in net.corda.explorer.views.TransactionViewer.Transaction[PropertyDescriptorImpl]

'setCustomCellFactory' @ [173:64] ==> public fun <S, T> TableColumn<TransactionViewer.Transaction, ObservableList<List<ObservableValue<NodeInfo?>>>>.setCustomCellFactory(toNode: (ObservableList<List<ObservableValue<NodeInfo?>>>) -> Node): Unit defined in net.corda.explorer.ui[SimpleFunctionDescriptorImpl]
Inferred types:
    <S> -> Transaction
    <T> -> ObservableList<List<ObservableValue<NodeInfo?>>>

'label' @ [174:17] ==> public fun EventTarget.label(text: String = ..., op: (Label.() -> Unit)? = ...): Label defined in tornadofx[DeserializedSimpleFunctionDescriptor]

'text' @ [175:21] ==> public final var Label.text: (String..String?)[MyPropertyDescriptor]

'it' @ [175:28] ==> value-parameter it: ObservableList<List<ObservableValue<NodeInfo?>>> defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'formatJoinPartyNames' @ [175:31] ==> private final fun ObservableList<List<ObservableValue<NodeInfo?>>>.formatJoinPartyNames(separator: String = ..., formatter: Formatter<X500Name>): String defined in net.corda.explorer.views.TransactionViewer[SimpleFunctionDescriptorImpl]

'short' @ [175:83] ==> public final val short: Formatter<X500Name> defined in net.corda.explorer.formatters.PartyNameFormatter[PropertyDescriptorImpl]

'tooltip' @ [176:21] ==> public fun Node.tooltip(text: String? = ..., graphic: Node? = ..., op: (Tooltip.() -> Unit)? = ...): Tooltip defined in tornadofx[DeserializedSimpleFunctionDescriptor]

'text' @ [177:25] ==> public final var Tooltip.text: (String..String?)[MyPropertyDescriptor]

'it' @ [177:32] ==> value-parameter it: ObservableList<List<ObservableValue<NodeInfo?>>> defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'formatJoinPartyNames' @ [177:35] ==> private final fun ObservableList<List<ObservableValue<NodeInfo?>>>.formatJoinPartyNames(separator: String = ..., formatter: Formatter<X500Name>): String defined in net.corda.explorer.views.TransactionViewer[SimpleFunctionDescriptorImpl]

'full' @ [177:81] ==> public final val full: Formatter<X500Name> defined in net.corda.explorer.formatters.PartyNameFormatter[PropertyDescriptorImpl]

'column' @ [181:13] ==> public inline fun <reified S, T> TableView<TransactionViewer.Transaction>.column(title: String, prop: KProperty1<TransactionViewer.Transaction, List<Class<CommandData>>>, noinline op: (TableColumn<TransactionViewer.Transaction, List<Class<CommandData>>>.() -> Unit)? = ...): TableColumn<TransactionViewer.Transaction, List<Class<CommandData>>> defined in tornadofx[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified S> -> Transaction
    <T> -> List<Class<CommandData>>

'Transaction' @ [181:36] ==> public constructor Transaction(tx: PartiallyResolvedTransaction, id: SecureHash, inputs: TransactionViewer.Inputs, outputs: ObservableList<StateAndRef<ContractState>>, inputParties: ObservableList<List<ObservableValue<NodeInfo?>>>, outputParties: ObservableList<List<ObservableValue<NodeInfo?>>>, commandTypes: List<Class<CommandData>>, totalValueEquiv: ObservableValue<AmountDiff<Currency>>) defined in net.corda.explorer.views.TransactionViewer.Transaction[ClassConstructorDescriptorImpl]

'commandTypes' @ [181:49] ==> public final val commandTypes: List<Class<CommandData>> defined in net.corda.explorer.views.TransactionViewer.Transaction[PropertyDescriptorImpl]

'cellFormat' @ [181:63] ==> public fun <S, T> TableColumn<TransactionViewer.Transaction, List<Class<CommandData>>>.cellFormat(formatter: TableCell<TransactionViewer.Transaction, List<Class<CommandData>>>.(List<Class<CommandData>>) -> Unit): Unit defined in tornadofx[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <S> -> Transaction
    <T> -> List<Class<CommandData>>

'text' @ [181:76] ==> public final var <S : (Any..Any?), T : (Any..Any?)> TableCell<TransactionViewer.Transaction, List<Class<CommandData>>>.text: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <S : (Any..Any?)> -> Transaction
    <T : (Any..Any?)> -> List<Class<CommandData>>

'it' @ [181:83] ==> value-parameter it: List<Class<CommandData>> defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'map' @ [181:86] ==> public inline fun <T, R> Iterable<Class<CommandData>>.map(transform: (Class<CommandData>) -> (String..String?)): List<(String..String?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Class<CommandData>
    <R> -> (kotlin.String..kotlin.String?)

'it' @ [181:92] ==> value-parameter it: Class<CommandData> defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'simpleName' @ [181:95] ==> public final val <T : (Any..Any?)> Class<CommandData>.simpleName: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> CommandData

'joinToString' @ [181:108] ==> public fun <T> Iterable<(String..String?)>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: (((String..String?)) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.String..kotlin.String?)

'column' @ [182:13] ==> @JvmName public inline fun <reified S, T> TableView<TransactionViewer.Transaction>.column(title: String, prop: KProperty1<TransactionViewer.Transaction, ObservableValue<AmountDiff<Currency>>>, noinline op: (TableColumn<TransactionViewer.Transaction, AmountDiff<Currency>>.() -> Unit)? = ...): TableColumn<TransactionViewer.Transaction, AmountDiff<Currency>> defined in tornadofx[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified S> -> Transaction
    <T> -> AmountDiff<Currency>

'Transaction' @ [182:35] ==> public constructor Transaction(tx: PartiallyResolvedTransaction, id: SecureHash, inputs: TransactionViewer.Inputs, outputs: ObservableList<StateAndRef<ContractState>>, inputParties: ObservableList<List<ObservableValue<NodeInfo?>>>, outputParties: ObservableList<List<ObservableValue<NodeInfo?>>>, commandTypes: List<Class<CommandData>>, totalValueEquiv: ObservableValue<AmountDiff<Currency>>) defined in net.corda.explorer.views.TransactionViewer.Transaction[ClassConstructorDescriptorImpl]

'totalValueEquiv' @ [182:48] ==> public final val totalValueEquiv: ObservableValue<AmountDiff<Currency>> defined in net.corda.explorer.views.TransactionViewer.Transaction[PropertyDescriptorImpl]

'cellFormat' @ [182:65] ==> public fun <S, T> TableColumn<TransactionViewer.Transaction, AmountDiff<Currency>>.cellFormat(formatter: TableCell<TransactionViewer.Transaction, AmountDiff<Currency>>.(AmountDiff<Currency>) -> Unit): Unit defined in tornadofx[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <S> -> Transaction
    <T> -> AmountDiff<Currency>

'text' @ [183:17] ==> public final var <S : (Any..Any?), T : (Any..Any?)> TableCell<TransactionViewer.Transaction, AmountDiff<Currency>>.text: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <S : (Any..Any?)> -> Transaction
    <T : (Any..Any?)> -> AmountDiff<Currency>

'it' @ [183:27] ==> value-parameter it: AmountDiff<Currency> defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'positivity' @ [183:30] ==> public final val positivity: Positivity defined in net.corda.explorer.AmountDiff[PropertyDescriptorImpl]

'sign' @ [183:41] ==> public val Positivity.sign: String defined in net.corda.explorer in file AmountDiff.kt[PropertyDescriptorImpl]

'AmountFormatter' @ [183:48] ==> public object AmountFormatter defined in net.corda.explorer.formatters in file AmountFormatter.kt[FakeCallableDescriptorForObject]

'boring' @ [183:64] ==> public final val boring: Formatter<Amount<Currency>> defined in net.corda.explorer.formatters.AmountFormatter[PropertyDescriptorImpl]

'format' @ [183:71] ==> public abstract fun format(value: Amount<Currency>): String defined in net.corda.explorer.formatters.Formatter[SimpleFunctionDescriptorImpl]

'it' @ [183:78] ==> value-parameter it: AmountDiff<Currency> defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'amount' @ [183:81] ==> public final val amount: Amount<Currency> defined in net.corda.explorer.AmountDiff[PropertyDescriptorImpl]

'titleProperty' @ [184:17] ==> public final val titleProperty: SimpleStringProperty defined in net.corda.explorer.views.TransactionViewer[DeserializedPropertyDescriptor]

'bind' @ [184:31] ==> public open fun bind(p0: (ObservableValue<out (String..String?)>..ObservableValue<out (String..String?)>?)): Unit defined in javafx.beans.property.SimpleStringProperty[JavaMethodDescriptor]

'reportingCurrency' @ [184:36] ==> private final val reportingCurrency: ObservableValue<(Currency..Currency?)> defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'map' @ [184:54] ==> public fun <A, B> ObservableValue<out (Currency..Currency?)>.map(function: ((Currency..Currency?)) -> String): ObservableValue<String> defined in net.corda.client.jfx.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> (java.util.Currency..java.util.Currency?)
    <B> -> String

'it' @ [184:75] ==> value-parameter it: (Currency..Currency?) defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'expander' @ [187:13] ==> private final lateinit var expander: ExpanderColumn<TransactionViewer.Transaction> defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'rowExpander' @ [187:24] ==> public fun <S> TableView<TransactionViewer.Transaction>.rowExpander(expandOnDoubleClick: Boolean = ..., expandedNodeCallback: RowExpanderPane.(TransactionViewer.Transaction) -> Unit): ExpanderColumn<TransactionViewer.Transaction> defined in tornadofx[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <S> -> Transaction

'add' @ [188:17] ==> public fun EventTarget.add(node: Node): Unit defined in tornadofx[DeserializedSimpleFunctionDescriptor]

'ContractStatesView' @ [188:21] ==> public constructor ContractStatesView(transaction: TransactionViewer.Transaction) defined in net.corda.explorer.views.TransactionViewer.ContractStatesView[ClassConstructorDescriptorImpl]

'it' @ [188:40] ==> value-parameter it: TransactionViewer.Transaction defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'root' @ [188:44] ==> public open val root: Parent defined in net.corda.explorer.views.TransactionViewer.ContractStatesView[PropertyDescriptorImpl]

'prefHeight' @ [189:17] ==> public final var RowExpanderPane.prefHeight: Double[MyPropertyDescriptor]

'apply' @ [190:15] ==> @InlineOnly public inline fun <T> ExpanderColumn<TransactionViewer.Transaction>.apply(block: ExpanderColumn<TransactionViewer.Transaction>.() -> Unit): ExpanderColumn<TransactionViewer.Transaction> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ExpanderColumn<Transaction>

'minWidth' @ [193:17] ==> public final var <S> ExpanderColumn<TransactionViewer.Transaction>.minWidth: Double[MyPropertyDescriptor]
Inferred types:
    <S> -> Transaction

'maxWidth' @ [194:17] ==> public final var <S> ExpanderColumn<TransactionViewer.Transaction>.maxWidth: Double[MyPropertyDescriptor]
Inferred types:
    <S> -> Transaction

'matchingTransactionsLabel' @ [197:9] ==> private final val matchingTransactionsLabel: Label defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'textProperty' @ [197:35] ==> public final fun textProperty(): (StringProperty..StringProperty?) defined in javafx.scene.control.Label[JavaMethodDescriptor]

'bind' @ [197:50] ==> public abstract fun bind(p0: (ObservableValue<out (String..String?)>..ObservableValue<out (String..String?)>?)): Unit defined in javafx.beans.property.StringProperty[JavaMethodDescriptor]

'size' @ [197:64] ==> public open fun <E : (Any..Any?)> size(p0: (ObservableList<(TransactionViewer.Transaction..TransactionViewer.Transaction?)>..ObservableList<(TransactionViewer.Transaction..TransactionViewer.Transaction?)>?)): (IntegerBinding..IntegerBinding?) defined in javafx.beans.binding.Bindings[JavaMethodDescriptor]
Inferred types:
    <E : (Any..Any?)> -> (net.corda.explorer.views.TransactionViewer.Transaction..net.corda.explorer.views.TransactionViewer.Transaction?)

'transactionViewTable' @ [197:69] ==> private final val transactionViewTable: TableView<TransactionViewer.Transaction> defined in net.corda.explorer.views.TransactionViewer[PropertyDescriptorImpl]

'items' @ [197:90] ==> public final var <S : (Any..Any?)> TableView<TransactionViewer.Transaction>.items: (ObservableList<(TransactionViewer.Transaction..TransactionViewer.Transaction?)>..ObservableList<(TransactionViewer.Transaction..TransactionViewer.Transaction?)>?)[MyPropertyDescriptor]
Inferred types:
    <S : (Any..Any?)> -> Transaction

'map' @ [197:97] ==> public fun <A, B> ObservableValue<out (Number..Number?)>.map(function: ((Number..Number?)) -> String): ObservableValue<String> defined in net.corda.client.jfx.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> (kotlin.Number..kotlin.Number?)
    <B> -> String

'it' @ [198:15] ==> value-parameter it: (Number..Number?) defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[ValueParameterDescriptorImpl]

'if (it == 1) "" else "s"' @ [198:40] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'it' @ [198:44] ==> value-parameter it: (Number..Number?) defined in net.corda.explorer.views.TransactionViewer.<init>.<anonymous>[ValueParameterDescriptorImpl]

'flatten' @ [203:16] ==> public fun <T> Iterable<Iterable<ObservableValue<NodeInfo?>>>.flatten(): List<ObservableValue<NodeInfo?>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ObservableValue<NodeInfo?>

'map' @ [203:26] ==> public inline fun <T, R> Iterable<ObservableValue<NodeInfo?>>.map(transform: (ObservableValue<NodeInfo?>) -> String?): List<String?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ObservableValue<NodeInfo?>
    <R> -> String?

'it' @ [204:13] ==> value-parameter it: ObservableValue<NodeInfo?> defined in net.corda.explorer.views.TransactionViewer.formatJoinPartyNames.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [204:16] ==> public final val <T : (Any..Any?)> ObservableValue<NodeInfo?>.value: NodeInfo?[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> NodeInfo?

'legalIdentity' @ [204:23] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'let' @ [204:38] ==> @InlineOnly public inline fun <T, R> Party.let(block: (Party) -> String): String defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Party
    <R> -> String

'formatter' @ [204:44] ==> value-parameter formatter: Formatter<X500Name> defined in net.corda.explorer.views.TransactionViewer.formatJoinPartyNames[ValueParameterDescriptorImpl]

'format' @ [204:54] ==> public abstract fun format(value: X500Name): String defined in net.corda.explorer.formatters.Formatter[SimpleFunctionDescriptorImpl]

'it' @ [204:61] ==> value-parameter it: Party defined in net.corda.explorer.views.TransactionViewer.formatJoinPartyNames.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [204:64] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'filterNotNull' @ [205:11] ==> public fun <T : Any> Iterable<String?>.filterNotNull(): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> String

'toSet' @ [205:27] ==> public fun <T> Iterable<String>.toSet(): Set<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'joinToString' @ [205:35] ==> public fun <T> Iterable<String>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((String) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'separator' @ [205:48] ==> value-parameter separator: String = ... defined in net.corda.explorer.views.TransactionViewer.formatJoinPartyNames[ValueParameterDescriptorImpl]

'map' @ [208:75] ==> public fun <A, B> ObservableList<out StateAndRef<ContractState>>.map(cached: Boolean = ..., function: (StateAndRef<ContractState>) -> List<ObservableValue<NodeInfo?>>): ObservableList<List<ObservableValue<NodeInfo?>>> defined in net.corda.client.jfx.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> StateAndRef<ContractState>
    <B> -> List<ObservableValue<NodeInfo?>>

'it' @ [208:81] ==> value-parameter it: StateAndRef<ContractState> defined in net.corda.explorer.views.TransactionViewer.getParties.<anonymous>[ValueParameterDescriptorImpl]

'state' @ [208:84] ==> public final val state: TransactionState<ContractState> defined in net.corda.core.contracts.StateAndRef[DeserializedPropertyDescriptor]

'data' @ [208:90] ==> public final val data: ContractState defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'participants' @ [208:95] ==> public abstract val participants: List<AbstractParty> defined in net.corda.core.contracts.ContractState[DeserializedPropertyDescriptor]

'map' @ [208:108] ==> public inline fun <T, R> Iterable<AbstractParty>.map(transform: (AbstractParty) -> ObservableValue<NodeInfo?>): List<ObservableValue<NodeInfo?>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> AbstractParty
    <R> -> ObservableValue<NodeInfo?>

'getModel' @ [208:114] ==> public inline fun <reified M : Any> UIComponent.getModel(): NetworkIdentityModel defined in net.corda.explorer.views[SimpleFunctionDescriptorImpl]
Inferred types:
    <reified M : Any> -> NetworkIdentityModel

'lookup' @ [208:147] ==> public final fun lookup(publicKey: PublicKey): ObservableValue<NodeInfo?> defined in net.corda.client.jfx.model.NetworkIdentityModel[DeserializedSimpleFunctionDescriptor]

'it' @ [208:154] ==> value-parameter it: AbstractParty defined in net.corda.explorer.views.TransactionViewer.getParties.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'owningKey' @ [208:157] ==> public final val owningKey: PublicKey defined in net.corda.core.identity.AbstractParty[DeserializedPropertyDescriptor]

'map' @ [209:71] ==> public fun <A, B> ObservableList<out StateAndRef<ContractState>>.map(cached: Boolean = ..., function: (StateAndRef<ContractState>) -> (String..String?)): ObservableList<(String..String?)> defined in net.corda.client.jfx.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> StateAndRef<ContractState>
    <B> -> (kotlin.String..kotlin.String?)

'it' @ [209:77] ==> value-parameter it: StateAndRef<ContractState> defined in net.corda.explorer.views.TransactionViewer.toText.<anonymous>[ValueParameterDescriptorImpl]

'contract' @ [209:80] ==> private final fun StateAndRef<ContractState>.contract(): Contract defined in net.corda.explorer.views.TransactionViewer[SimpleFunctionDescriptorImpl]

'javaClass' @ [209:91] ==> public val <T : Any> Contract.javaClass: Class<Contract> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> Contract

'simpleName' @ [209:101] ==> public final val <T : (Any..Any?)> Class<Contract>.simpleName: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Contract

'groupBy' @ [209:114] ==> public inline fun <T, K> Iterable<(String..String?)>.groupBy(keySelector: ((String..String?)) -> (String..String?)): Map<(String..String?), List<(String..String?)>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.String..kotlin.String?)
    <K> -> (kotlin.String..kotlin.String?)

'it' @ [209:124] ==> value-parameter it: (String..String?) defined in net.corda.explorer.views.TransactionViewer.toText.<anonymous>[ValueParameterDescriptorImpl]

'map' @ [209:129] ==> public inline fun <K, V, R> Map<out (String..String?), List<(String..String?)>>.map(transform: (Map.Entry<(String..String?), List<(String..String?)>>) -> String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> (kotlin.String..kotlin.String?)
    <V> -> List<(kotlin.String..kotlin.String?)>
    <R> -> String

'it' @ [209:138] ==> value-parameter it: Map.Entry<(String..String?), List<(String..String?)>> defined in net.corda.explorer.views.TransactionViewer.toText.<anonymous>[ValueParameterDescriptorImpl]

'key' @ [209:141] ==> public abstract val key: (String..String?) defined in kotlin.collections.Map.Entry[DeserializedPropertyDescriptor]

'it' @ [209:149] ==> value-parameter it: Map.Entry<(String..String?), List<(String..String?)>> defined in net.corda.explorer.views.TransactionViewer.toText.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [209:152] ==> public abstract val value: List<(String..String?)> defined in kotlin.collections.Map.Entry[DeserializedPropertyDescriptor]

'size' @ [209:158] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'joinToString' @ [209:168] ==> public fun <T> Iterable<String>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((String) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'BorderPane' @ [211:39] ==> public constructor BorderPane() defined in javafx.scene.layout.BorderPane[JavaClassConstructorDescriptor]

'getValue' @ [212:54] ==> public final operator fun getValue(thisRef: Any, property: KProperty<*>): ObservableList<out T> defined in net.corda.client.jfx.model.TrackedDelegate.ObservableListReadOnlyDelegate[DeserializedSimpleFunctionDescriptor]

'TransactionDataModel' @ [212:77] ==> public constructor TransactionDataModel() defined in net.corda.client.jfx.model.TransactionDataModel[DeserializedClassConstructorDescriptor]

'partiallyResolvedTransactions' @ [212:99] ==> public final val partiallyResolvedTransactions: ObservableList<PartiallyResolvedTransaction> defined in net.corda.client.jfx.model.TransactionDataModel[DeserializedPropertyDescriptor]

'right' @ [217:13] ==> public fun BorderPane.right(op: BorderPane.() -> Unit): Unit defined in tornadofx[DeserializedSimpleFunctionDescriptor]

'label' @ [218:17] ==> public fun EventTarget.label(text: String = ..., op: (Label.() -> Unit)? = ...): Label defined in tornadofx[DeserializedSimpleFunctionDescriptor]

'SecureHash' @ [219:32] ==> public companion object defined in net.corda.core.crypto.SecureHash[FakeCallableDescriptorForObject]

'randomSHA256' @ [219:43] ==> @JvmStatic public final fun randomSHA256(): SecureHash.SHA256 defined in net.corda.core.crypto.SecureHash.Companion[DeserializedSimpleFunctionDescriptor]

'graphic' @ [220:21] ==> public final var Label.graphic: (Node..Node?)[MyPropertyDescriptor]

'identicon' @ [220:31] ==> public fun identicon(secureHash: SecureHash, size: Double): ImageView defined in net.corda.explorer.identicon in file IdenticonRenderer.kt[SimpleFunctionDescriptorImpl]

'hash' @ [220:41] ==> val hash: SecureHash.SHA256 defined in net.corda.explorer.views.TransactionViewer.TransactionWidget.<init>.<anonymous>.<anonymous>[LocalVariableDescriptor]

'textProperty' @ [221:21] ==> public final fun textProperty(): (StringProperty..StringProperty?) defined in javafx.scene.control.Label[JavaMethodDescriptor]

'bind' @ [221:36] ==> public abstract fun bind(p0: (ObservableValue<out (String..String?)>..ObservableValue<out (String..String?)>?)): Unit defined in javafx.beans.property.StringProperty[JavaMethodDescriptor]

'size' @ [221:50] ==> public open fun <E : (Any..Any?)> size(p0: (ObservableList<out PartiallyResolvedTransaction>..ObservableList<out PartiallyResolvedTransaction>?)): (IntegerBinding..IntegerBinding?) defined in javafx.beans.binding.Bindings[JavaMethodDescriptor]
Inferred types:
    <E : (Any..Any?)> -> Captured(out PartiallyResolvedTransaction)

'partiallyResolvedTransactions' @ [221:55] ==> private final val partiallyResolvedTransactions: ObservableList<out PartiallyResolvedTransaction> defined in net.corda.explorer.views.TransactionViewer.TransactionWidget[PropertyDescriptorImpl]

'map' @ [221:86] ==> public fun <A, B> ObservableValue<out (Number..Number?)>.map(function: ((Number..Number?)) -> String): ObservableValue<String> defined in net.corda.client.jfx.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> (kotlin.Number..kotlin.Number?)
    <B> -> String

'Number' @ [221:90] ==> public constructor Number() defined in kotlin.Number[DeserializedClassConstructorDescriptor]

'toString' @ [221:98] ==> public open fun toString(): String defined in kotlin.Number[DeserializedSimpleFunctionDescriptor]

'setAlignment' @ [222:32] ==> public open fun setAlignment(p0: (Node..Node?), p1: (Pos..Pos?)): Unit defined in javafx.scene.layout.BorderPane[JavaMethodDescriptor]

'this' @ [222:45] ==> <this> defined in net.corda.explorer.views.TransactionViewer.TransactionWidget.<init>.<anonymous>.<anonymous>[ReceiverParameterDescriptorImpl]

'BOTTOM_RIGHT' @ [222:55] ==> enum entry BOTTOM_RIGHT defined in javafx.geometry.Pos[FakeCallableDescriptorForObject]

'Fragment' @ [228:72] ==> public constructor Fragment(title: String? = ...) defined in tornadofx.Fragment[DeserializedClassConstructorDescriptor]

'fxml' @ [229:30] ==> public final fun <T : Node> fxml(location: String?, hasControllerAttribute: Boolean): ReadOnlyProperty<UIComponent, Parent> defined in net.corda.explorer.views.TransactionViewer.ContractStatesView[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Node> -> Parent

'fxid' @ [230:31] ==> public final inline fun <reified T : Any> fxid(propName: String?): ReadOnlyProperty<UIComponent, ListView<StateAndRef<ContractState>>> defined in net.corda.explorer.views.TransactionViewer.ContractStatesView[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : Any> -> ListView<StateAndRef<ContractState>>

'fxid' @ [231:32] ==> public final inline fun <reified T : Any> fxid(propName: String?): ReadOnlyProperty<UIComponent, ListView<StateAndRef<ContractState>>> defined in net.corda.explorer.views.TransactionViewer.ContractStatesView[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : Any> -> ListView<StateAndRef<ContractState>>

'fxid' @ [232:35] ==> public final inline fun <reified T : Any> fxid(propName: String?): ReadOnlyProperty<UIComponent, VBox> defined in net.corda.explorer.views.TransactionViewer.ContractStatesView[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : Any> -> VBox

'fxid' @ [233:34] ==> public final inline fun <reified T : Any> fxid(propName: String?): ReadOnlyProperty<UIComponent, TitledPane> defined in net.corda.explorer.views.TransactionViewer.ContractStatesView[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : Any> -> TitledPane

'fxid' @ [234:35] ==> public final inline fun <reified T : Any> fxid(propName: String?): ReadOnlyProperty<UIComponent, TitledPane> defined in net.corda.explorer.views.TransactionViewer.ContractStatesView[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : Any> -> TitledPane

'fxid' @ [235:39] ==> public final inline fun <reified T : Any> fxid(propName: String?): ReadOnlyProperty<UIComponent, TitledPane> defined in net.corda.explorer.views.TransactionViewer.ContractStatesView[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : Any> -> TitledPane

'transaction' @ [238:33] ==> value-parameter transaction: TransactionViewer.Transaction defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.<init>[ValueParameterDescriptorImpl]

'tx' @ [238:45] ==> public final val tx: PartiallyResolvedTransaction defined in net.corda.explorer.views.TransactionViewer.Transaction[PropertyDescriptorImpl]

'transaction' @ [238:48] ==> public final val transaction: SignedTransaction defined in net.corda.client.jfx.model.PartiallyResolvedTransaction[DeserializedPropertyDescriptor]

'sigs' @ [238:60] ==> public open val sigs: List<TransactionSignature> defined in net.corda.core.transactions.SignedTransaction[DeserializedPropertyDescriptor]

'map' @ [238:65] ==> public inline fun <T, R> Iterable<TransactionSignature>.map(transform: (TransactionSignature) -> PublicKey): List<PublicKey> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TransactionSignature
    <R> -> PublicKey

'it' @ [238:71] ==> value-parameter it: TransactionSignature defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.<init>.<anonymous>[ValueParameterDescriptorImpl]

'by' @ [238:74] ==> public final val by: PublicKey defined in net.corda.core.crypto.TransactionSignature[DeserializedPropertyDescriptor]

'inputPane' @ [240:13] ==> private final val inputPane: TitledPane defined in net.corda.explorer.views.TransactionViewer.ContractStatesView[PropertyDescriptorImpl]

'text' @ [240:23] ==> public final var TitledPane.text: (String..String?)[MyPropertyDescriptor]

'transaction' @ [240:40] ==> value-parameter transaction: TransactionViewer.Transaction defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.<init>[ValueParameterDescriptorImpl]

'inputs' @ [240:52] ==> public final val inputs: TransactionViewer.Inputs defined in net.corda.explorer.views.TransactionViewer.Transaction[PropertyDescriptorImpl]

'resolved' @ [240:59] ==> public final val resolved: ObservableList<StateAndRef<ContractState>> defined in net.corda.explorer.views.TransactionViewer.Inputs[PropertyDescriptorImpl]

'count' @ [240:68] ==> @InlineOnly public inline fun <T> Collection<(StateAndRef<ContractState>..StateAndRef<ContractState>?)>.count(): Int defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (net.corda.core.contracts.StateAndRef<net.corda.core.contracts.ContractState>..net.corda.core.contracts.StateAndRef<net.corda.core.contracts.ContractState>?)

'outputPane' @ [241:13] ==> private final val outputPane: TitledPane defined in net.corda.explorer.views.TransactionViewer.ContractStatesView[PropertyDescriptorImpl]

'text' @ [241:24] ==> public final var TitledPane.text: (String..String?)[MyPropertyDescriptor]

'transaction' @ [241:42] ==> value-parameter transaction: TransactionViewer.Transaction defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.<init>[ValueParameterDescriptorImpl]

'outputs' @ [241:54] ==> public final val outputs: ObservableList<StateAndRef<ContractState>> defined in net.corda.explorer.views.TransactionViewer.Transaction[PropertyDescriptorImpl]

'count' @ [241:62] ==> @InlineOnly public inline fun <T> Collection<(StateAndRef<ContractState>..StateAndRef<ContractState>?)>.count(): Int defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (net.corda.core.contracts.StateAndRef<net.corda.core.contracts.ContractState>..net.corda.core.contracts.StateAndRef<net.corda.core.contracts.ContractState>?)

'signaturesPane' @ [242:13] ==> private final val signaturesPane: TitledPane defined in net.corda.explorer.views.TransactionViewer.ContractStatesView[PropertyDescriptorImpl]

'text' @ [242:28] ==> public final var TitledPane.text: (String..String?)[MyPropertyDescriptor]

'signatureData' @ [242:50] ==> val signatureData: List<PublicKey> defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.<init>[LocalVariableDescriptor]

'count' @ [242:64] ==> @InlineOnly public inline fun <T> Collection<PublicKey>.count(): Int defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PublicKey

'inputs' @ [244:13] ==> private final val inputs: ListView<StateAndRef<ContractState>> defined in net.corda.explorer.views.TransactionViewer.ContractStatesView[PropertyDescriptorImpl]

'cellCache' @ [244:20] ==> public final fun <T> ListView<StateAndRef<ContractState>>.cellCache(cachedGraphicProvider: (StateAndRef<ContractState>) -> Node): Unit defined in net.corda.explorer.views.TransactionViewer.ContractStatesView[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> StateAndRef<ContractState>

'getCell' @ [244:32] ==> private final fun getCell(contractState: StateAndRef<ContractState>): Node defined in net.corda.explorer.views.TransactionViewer.ContractStatesView[SimpleFunctionDescriptorImpl]

'it' @ [244:40] ==> value-parameter it: StateAndRef<ContractState> defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.<init>.<anonymous>[ValueParameterDescriptorImpl]

'outputs' @ [245:13] ==> private final val outputs: ListView<StateAndRef<ContractState>> defined in net.corda.explorer.views.TransactionViewer.ContractStatesView[PropertyDescriptorImpl]

'cellCache' @ [245:21] ==> public final fun <T> ListView<StateAndRef<ContractState>>.cellCache(cachedGraphicProvider: (StateAndRef<ContractState>) -> Node): Unit defined in net.corda.explorer.views.TransactionViewer.ContractStatesView[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> StateAndRef<ContractState>

'getCell' @ [245:33] ==> private final fun getCell(contractState: StateAndRef<ContractState>): Node defined in net.corda.explorer.views.TransactionViewer.ContractStatesView[SimpleFunctionDescriptorImpl]

'it' @ [245:41] ==> value-parameter it: StateAndRef<ContractState> defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.<init>.<anonymous>[ValueParameterDescriptorImpl]

'inputs' @ [247:13] ==> private final val inputs: ListView<StateAndRef<ContractState>> defined in net.corda.explorer.views.TransactionViewer.ContractStatesView[PropertyDescriptorImpl]

'items' @ [247:20] ==> public final var <T : (Any..Any?)> ListView<StateAndRef<ContractState>>.items: (ObservableList<(StateAndRef<ContractState>..StateAndRef<ContractState>?)>..ObservableList<(StateAndRef<ContractState>..StateAndRef<ContractState>?)>?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> StateAndRef<ContractState>

'transaction' @ [247:28] ==> value-parameter transaction: TransactionViewer.Transaction defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.<init>[ValueParameterDescriptorImpl]

'inputs' @ [247:40] ==> public final val inputs: TransactionViewer.Inputs defined in net.corda.explorer.views.TransactionViewer.Transaction[PropertyDescriptorImpl]

'resolved' @ [247:47] ==> public final val resolved: ObservableList<StateAndRef<ContractState>> defined in net.corda.explorer.views.TransactionViewer.Inputs[PropertyDescriptorImpl]

'outputs' @ [248:13] ==> private final val outputs: ListView<StateAndRef<ContractState>> defined in net.corda.explorer.views.TransactionViewer.ContractStatesView[PropertyDescriptorImpl]

'items' @ [248:21] ==> public final var <T : (Any..Any?)> ListView<StateAndRef<ContractState>>.items: (ObservableList<(StateAndRef<ContractState>..StateAndRef<ContractState>?)>..ObservableList<(StateAndRef<ContractState>..StateAndRef<ContractState>?)>?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> StateAndRef<ContractState>

'transaction' @ [248:29] ==> value-parameter transaction: TransactionViewer.Transaction defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.<init>[ValueParameterDescriptorImpl]

'outputs' @ [248:41] ==> public final val outputs: ObservableList<StateAndRef<ContractState>> defined in net.corda.explorer.views.TransactionViewer.Transaction[PropertyDescriptorImpl]

'observable' @ [248:49] ==> public fun <T> List<(StateAndRef<ContractState>..StateAndRef<ContractState>?)>.observable(): ObservableList<(StateAndRef<ContractState>..StateAndRef<ContractState>?)> defined in tornadofx[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (net.corda.core.contracts.StateAndRef<net.corda.core.contracts.ContractState>..net.corda.core.contracts.StateAndRef<net.corda.core.contracts.ContractState>?)

'signatures' @ [250:13] ==> private final val signatures: VBox defined in net.corda.explorer.views.TransactionViewer.ContractStatesView[PropertyDescriptorImpl]

'children' @ [250:24] ==> public final val VBox.children: (ObservableList<(Node..Node?)>..ObservableList<(Node..Node?)>?)[MyPropertyDescriptor]

'addAll' @ [250:33] ==> public abstract fun addAll(elements: Collection<(Node..Node?)>): Boolean defined in javafx.collections.ObservableList[DeserializedSimpleFunctionDescriptor]

'signatureData' @ [250:40] ==> val signatureData: List<PublicKey> defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.<init>[LocalVariableDescriptor]

'map' @ [250:54] ==> public inline fun <T, R> Iterable<PublicKey>.map(transform: (PublicKey) -> TextField): List<TextField> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PublicKey
    <R> -> TextField

'getModel' @ [251:32] ==> public inline fun <reified M : Any> UIComponent.getModel(): NetworkIdentityModel defined in net.corda.explorer.views[SimpleFunctionDescriptorImpl]
Inferred types:
    <reified M : Any> -> NetworkIdentityModel

'lookup' @ [251:65] ==> public final fun lookup(publicKey: PublicKey): ObservableValue<NodeInfo?> defined in net.corda.client.jfx.model.NetworkIdentityModel[DeserializedSimpleFunctionDescriptor]

'signature' @ [251:72] ==> value-parameter signature: PublicKey defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.<init>.<anonymous>[ValueParameterDescriptorImpl]

'copyableLabel' @ [252:17] ==> public fun EventTarget.copyableLabel(value: ObservableValue<String>? = ..., op: (TextField.() -> Unit)? = ...): TextField defined in net.corda.explorer.views in file GuiUtilities.kt[SimpleFunctionDescriptorImpl]

'nodeInfo' @ [252:31] ==> val nodeInfo: ObservableValue<NodeInfo?> defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.<init>.<anonymous>[LocalVariableDescriptor]

'map' @ [252:40] ==> public fun <A, B> ObservableValue<out NodeInfo?>.map(function: (NodeInfo?) -> String): ObservableValue<String> defined in net.corda.client.jfx.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> NodeInfo?
    <B> -> String

'signature' @ [252:49] ==> value-parameter signature: PublicKey defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.<init>.<anonymous>[ValueParameterDescriptorImpl]

'toStringShort' @ [252:59] ==> public fun PublicKey.toStringShort(): String defined in net.corda.core.crypto[DeserializedSimpleFunctionDescriptor]

'it' @ [252:79] ==> value-parameter it: NodeInfo? defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.<init>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'legalIdentity' @ [252:83] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'let' @ [252:98] ==> @InlineOnly public inline fun <T, R> Party.let(block: (Party) -> String): String defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Party
    <R> -> String

'PartyNameFormatter' @ [252:104] ==> public object PartyNameFormatter defined in net.corda.explorer.formatters in file PartyNameFormatter.kt[FakeCallableDescriptorForObject]

'short' @ [252:123] ==> public final val short: Formatter<X500Name> defined in net.corda.explorer.formatters.PartyNameFormatter[PropertyDescriptorImpl]

'format' @ [252:129] ==> public abstract fun format(value: X500Name): String defined in net.corda.explorer.formatters.Formatter[SimpleFunctionDescriptorImpl]

'it' @ [252:136] ==> value-parameter it: Party defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.<init>.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [252:139] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'invoke' @ [257:20] ==> public abstract operator fun invoke(): GridPane defined in kotlin.Function0[FunctionInvokeDescriptor]

'gridpane' @ [258:17] ==> public fun EventTarget.gridpane(op: (GridPane.() -> Unit)? = ...): GridPane defined in tornadofx[DeserializedSimpleFunctionDescriptor]

'padding' @ [259:21] ==> public final var GridPane.padding: (Insets..Insets?)[MyPropertyDescriptor]

'Insets' @ [259:31] ==> public constructor Insets(@NamedArg p0: Double, @NamedArg p1: Double, @NamedArg p2: Double, @NamedArg p3: Double) defined in javafx.geometry.Insets[JavaClassConstructorDescriptor]

'vgap' @ [260:21] ==> public final var GridPane.vgap: Double[MyPropertyDescriptor]

'hgap' @ [261:21] ==> public final var GridPane.hgap: Double[MyPropertyDescriptor]

'row' @ [262:21] ==> public fun GridPane.row(title: String? = ..., op: (Pane.() -> Unit)? = ...): Unit defined in tornadofx[DeserializedSimpleFunctionDescriptor]

'label' @ [263:25] ==> public fun EventTarget.label(text: String = ..., op: (Label.() -> Unit)? = ...): Label defined in tornadofx[DeserializedSimpleFunctionDescriptor]

'contractState' @ [263:34] ==> value-parameter contractState: StateAndRef<ContractState> defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.getCell[ValueParameterDescriptorImpl]

'contract' @ [263:48] ==> private final fun StateAndRef<ContractState>.contract(): Contract defined in net.corda.explorer.views.TransactionViewer[SimpleFunctionDescriptorImpl]

'javaClass' @ [263:59] ==> public val <T : Any> Contract.javaClass: Class<Contract> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> Contract

'simpleName' @ [263:69] ==> public final val <T : (Any..Any?)> Class<Contract>.simpleName: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Contract

'contractState' @ [263:84] ==> value-parameter contractState: StateAndRef<ContractState> defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.getCell[ValueParameterDescriptorImpl]

'ref' @ [263:98] ==> public final val ref: StateRef defined in net.corda.core.contracts.StateAndRef[DeserializedPropertyDescriptor]

'toString' @ [263:102] ==> public open fun toString(): String defined in net.corda.core.contracts.StateRef[DeserializedSimpleFunctionDescriptor]

'substring' @ [263:113] ==> @InlineOnly public inline fun String.substring(startIndex: Int, endIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'contractState' @ [263:137] ==> value-parameter contractState: StateAndRef<ContractState> defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.getCell[ValueParameterDescriptorImpl]

'ref' @ [263:151] ==> public final val ref: StateRef defined in net.corda.core.contracts.StateAndRef[DeserializedPropertyDescriptor]

'index' @ [263:155] ==> public final val index: Int defined in net.corda.core.contracts.StateRef[DeserializedPropertyDescriptor]

'graphic' @ [264:29] ==> public final var Label.graphic: (Node..Node?)[MyPropertyDescriptor]

'identicon' @ [264:39] ==> public fun identicon(secureHash: SecureHash, size: Double): ImageView defined in net.corda.explorer.identicon in file IdenticonRenderer.kt[SimpleFunctionDescriptorImpl]

'contractState' @ [264:49] ==> value-parameter contractState: StateAndRef<ContractState> defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.getCell[ValueParameterDescriptorImpl]

'ref' @ [264:63] ==> public final val ref: StateRef defined in net.corda.core.contracts.StateAndRef[DeserializedPropertyDescriptor]

'txhash' @ [264:67] ==> public final val txhash: SecureHash defined in net.corda.core.contracts.StateRef[DeserializedPropertyDescriptor]

'tooltip' @ [265:29] ==> public final var Label.tooltip: (Tooltip..Tooltip?)[MyPropertyDescriptor]

'identiconToolTip' @ [265:39] ==> public fun identiconToolTip(secureHash: SecureHash, description: String? = ...): Tooltip defined in net.corda.explorer.identicon in file IdenticonRenderer.kt[SimpleFunctionDescriptorImpl]

'contractState' @ [265:56] ==> value-parameter contractState: StateAndRef<ContractState> defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.getCell[ValueParameterDescriptorImpl]

'ref' @ [265:70] ==> public final val ref: StateRef defined in net.corda.core.contracts.StateAndRef[DeserializedPropertyDescriptor]

'txhash' @ [265:74] ==> public final val txhash: SecureHash defined in net.corda.core.contracts.StateRef[DeserializedPropertyDescriptor]

'gridpaneConstraints' @ [266:29] ==> public fun <T : Node> Label.gridpaneConstraints(op: GridPaneConstraint.() -> Unit): Label defined in tornadofx[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Node> -> Label

'columnSpan' @ [266:51] ==> public final var columnSpan: Int? defined in tornadofx.GridPaneConstraint[DeserializedPropertyDescriptor]

'contractState' @ [269:32] ==> value-parameter contractState: StateAndRef<ContractState> defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.getCell[ValueParameterDescriptorImpl]

'state' @ [269:46] ==> public final val state: TransactionState<ContractState> defined in net.corda.core.contracts.StateAndRef[DeserializedPropertyDescriptor]

'data' @ [269:52] ==> public final val data: ContractState defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'when (data) {
                        is Cash.State -> {
                            row {
                                label("Amount :") { gridpaneConstraints { hAlignment = HPos.RIGHT } }
                                label(AmountFormatter.boring.format(data.amount.withoutIssuer()))
                            }
                            row {
                                label("Issuer :") { gridpaneConstraints { hAlignment = HPos.RIGHT } }
                                val anonymousIssuer: AbstractParty = data.amount.token.issuer.party
                                val issuer: AbstractParty = anonymousIssuer.resolveIssuer().value ?: anonymousIssuer
                                // TODO: Anonymous should probably be italicised or similar
                                label(issuer.nameOrNull()?.let { PartyNameFormatter.short.format(it) } ?: "Anonymous") {
                                    tooltip(anonymousIssuer.owningKey.toBase58String())
                                }
                            }
                            row {
                                label("Owner :") { gridpaneConstraints { hAlignment = HPos.RIGHT } }
                                val owner = data.owner
                                val nodeInfo = getModel<NetworkIdentityModel>().lookup(owner.owningKey)
                                label(nodeInfo.map { it?.legalIdentity?.let { PartyNameFormatter.short.format(it.name) } ?: "???" }) {
                                    tooltip(data.owner.owningKey.toBase58String())
                                }
                            }
                        }
                    // TODO : Generic view using reflection?
                        else -> label {}
                    }' @ [270:21] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Any, entry1: Any): Any[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Any

'data' @ [270:27] ==> val data: ContractState defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.getCell.<anonymous>.<anonymous>[LocalVariableDescriptor]

'row' @ [272:29] ==> public fun GridPane.row(title: String? = ..., op: (Pane.() -> Unit)? = ...): Unit defined in tornadofx[DeserializedSimpleFunctionDescriptor]

'label' @ [273:33] ==> public fun EventTarget.label(text: String = ..., op: (Label.() -> Unit)? = ...): Label defined in tornadofx[DeserializedSimpleFunctionDescriptor]

'gridpaneConstraints' @ [273:53] ==> public fun <T : Node> Label.gridpaneConstraints(op: GridPaneConstraint.() -> Unit): Label defined in tornadofx[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Node> -> Label

'hAlignment' @ [273:75] ==> public final var hAlignment: HPos? defined in tornadofx.GridPaneConstraint[DeserializedPropertyDescriptor]

'RIGHT' @ [273:93] ==> enum entry RIGHT defined in javafx.geometry.HPos[FakeCallableDescriptorForObject]

'label' @ [274:33] ==> public fun EventTarget.label(text: String = ..., op: (Label.() -> Unit)? = ...): Label defined in tornadofx[DeserializedSimpleFunctionDescriptor]

'boring' @ [274:55] ==> public final val boring: Formatter<Amount<Currency>> defined in net.corda.explorer.formatters.AmountFormatter[PropertyDescriptorImpl]

'format' @ [274:62] ==> public abstract fun format(value: Amount<Currency>): String defined in net.corda.explorer.formatters.Formatter[SimpleFunctionDescriptorImpl]

'data' @ [274:69] ==> val data: ContractState defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.getCell.<anonymous>.<anonymous>[LocalVariableDescriptor]

'amount' @ [274:74] ==> public open val amount: Amount<Issued<Currency>> defined in net.corda.finance.contracts.asset.Cash.State[DeserializedPropertyDescriptor]

'withoutIssuer' @ [274:81] ==> public fun <T : Any> Amount<Issued<Currency>>.withoutIssuer(): Amount<Currency> defined in net.corda.core.contracts[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> Currency

'row' @ [276:29] ==> public fun GridPane.row(title: String? = ..., op: (Pane.() -> Unit)? = ...): Unit defined in tornadofx[DeserializedSimpleFunctionDescriptor]

'label' @ [277:33] ==> public fun EventTarget.label(text: String = ..., op: (Label.() -> Unit)? = ...): Label defined in tornadofx[DeserializedSimpleFunctionDescriptor]

'gridpaneConstraints' @ [277:53] ==> public fun <T : Node> Label.gridpaneConstraints(op: GridPaneConstraint.() -> Unit): Label defined in tornadofx[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Node> -> Label

'hAlignment' @ [277:75] ==> public final var hAlignment: HPos? defined in tornadofx.GridPaneConstraint[DeserializedPropertyDescriptor]

'RIGHT' @ [277:93] ==> enum entry RIGHT defined in javafx.geometry.HPos[FakeCallableDescriptorForObject]

'data' @ [278:70] ==> val data: ContractState defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.getCell.<anonymous>.<anonymous>[LocalVariableDescriptor]

'amount' @ [278:75] ==> public open val amount: Amount<Issued<Currency>> defined in net.corda.finance.contracts.asset.Cash.State[DeserializedPropertyDescriptor]

'token' @ [278:82] ==> public final val token: Issued<Currency> defined in net.corda.core.contracts.Amount[DeserializedPropertyDescriptor]

'issuer' @ [278:88] ==> public final val issuer: PartyAndReference defined in net.corda.core.contracts.Issued[DeserializedPropertyDescriptor]

'party' @ [278:95] ==> public final val party: AbstractParty defined in net.corda.core.contracts.PartyAndReference[DeserializedPropertyDescriptor]

'anonymousIssuer' @ [279:61] ==> val anonymousIssuer: AbstractParty defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.getCell.<anonymous>.<anonymous>.<anonymous>[LocalVariableDescriptor]

'resolveIssuer' @ [279:77] ==> public fun AbstractParty.resolveIssuer(): ObservableValue<Party?> defined in net.corda.explorer.views in file GuiUtilities.kt[SimpleFunctionDescriptorImpl]

'value' @ [279:93] ==> public final val <T : (Any..Any?)> ObservableValue<Party?>.value: Party?[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Party?

'anonymousIssuer' @ [279:102] ==> val anonymousIssuer: AbstractParty defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.getCell.<anonymous>.<anonymous>.<anonymous>[LocalVariableDescriptor]

'label' @ [281:33] ==> public fun EventTarget.label(text: String = ..., op: (Label.() -> Unit)? = ...): Label defined in tornadofx[DeserializedSimpleFunctionDescriptor]

'issuer' @ [281:39] ==> val issuer: AbstractParty defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.getCell.<anonymous>.<anonymous>.<anonymous>[LocalVariableDescriptor]

'nameOrNull' @ [281:46] ==> public abstract fun nameOrNull(): X500Name? defined in net.corda.core.identity.AbstractParty[DeserializedSimpleFunctionDescriptor]

'let' @ [281:60] ==> @InlineOnly public inline fun <T, R> X500Name.let(block: (X500Name) -> String): String defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> X500Name
    <R> -> String

'PartyNameFormatter' @ [281:66] ==> public object PartyNameFormatter defined in net.corda.explorer.formatters in file PartyNameFormatter.kt[FakeCallableDescriptorForObject]

'short' @ [281:85] ==> public final val short: Formatter<X500Name> defined in net.corda.explorer.formatters.PartyNameFormatter[PropertyDescriptorImpl]

'format' @ [281:91] ==> public abstract fun format(value: X500Name): String defined in net.corda.explorer.formatters.Formatter[SimpleFunctionDescriptorImpl]

'it' @ [281:98] ==> value-parameter it: X500Name defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.getCell.<anonymous>.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'tooltip' @ [282:37] ==> public fun Node.tooltip(text: String? = ..., graphic: Node? = ..., op: (Tooltip.() -> Unit)? = ...): Tooltip defined in tornadofx[DeserializedSimpleFunctionDescriptor]

'anonymousIssuer' @ [282:45] ==> val anonymousIssuer: AbstractParty defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.getCell.<anonymous>.<anonymous>.<anonymous>[LocalVariableDescriptor]

'owningKey' @ [282:61] ==> public final val owningKey: PublicKey defined in net.corda.core.identity.AbstractParty[DeserializedPropertyDescriptor]

'toBase58String' @ [282:71] ==> public fun PublicKey.toBase58String(): String defined in net.corda.core.crypto[DeserializedSimpleFunctionDescriptor]

'row' @ [285:29] ==> public fun GridPane.row(title: String? = ..., op: (Pane.() -> Unit)? = ...): Unit defined in tornadofx[DeserializedSimpleFunctionDescriptor]

'label' @ [286:33] ==> public fun EventTarget.label(text: String = ..., op: (Label.() -> Unit)? = ...): Label defined in tornadofx[DeserializedSimpleFunctionDescriptor]

'gridpaneConstraints' @ [286:52] ==> public fun <T : Node> Label.gridpaneConstraints(op: GridPaneConstraint.() -> Unit): Label defined in tornadofx[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Node> -> Label

'hAlignment' @ [286:74] ==> public final var hAlignment: HPos? defined in tornadofx.GridPaneConstraint[DeserializedPropertyDescriptor]

'RIGHT' @ [286:92] ==> enum entry RIGHT defined in javafx.geometry.HPos[FakeCallableDescriptorForObject]

'data' @ [287:45] ==> val data: ContractState defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.getCell.<anonymous>.<anonymous>[LocalVariableDescriptor]

'owner' @ [287:50] ==> public open val owner: AbstractParty defined in net.corda.finance.contracts.asset.Cash.State[DeserializedPropertyDescriptor]

'getModel' @ [288:48] ==> public inline fun <reified M : Any> UIComponent.getModel(): NetworkIdentityModel defined in net.corda.explorer.views[SimpleFunctionDescriptorImpl]
Inferred types:
    <reified M : Any> -> NetworkIdentityModel

'lookup' @ [288:81] ==> public final fun lookup(publicKey: PublicKey): ObservableValue<NodeInfo?> defined in net.corda.client.jfx.model.NetworkIdentityModel[DeserializedSimpleFunctionDescriptor]

'owner' @ [288:88] ==> val owner: AbstractParty defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.getCell.<anonymous>.<anonymous>.<anonymous>[LocalVariableDescriptor]

'owningKey' @ [288:94] ==> public final val owningKey: PublicKey defined in net.corda.core.identity.AbstractParty[DeserializedPropertyDescriptor]

'label' @ [289:33] ==> public inline fun <reified T> EventTarget.label(observable: ObservableValue<String>, noinline op: (Label.() -> Unit)? = ...): Label defined in tornadofx[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T> -> String

'nodeInfo' @ [289:39] ==> val nodeInfo: ObservableValue<NodeInfo?> defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.getCell.<anonymous>.<anonymous>.<anonymous>[LocalVariableDescriptor]

'map' @ [289:48] ==> public fun <A, B> ObservableValue<out NodeInfo?>.map(function: (NodeInfo?) -> String): ObservableValue<String> defined in net.corda.client.jfx.utils[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> NodeInfo?
    <B> -> String

'it' @ [289:54] ==> value-parameter it: NodeInfo? defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.getCell.<anonymous>.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'legalIdentity' @ [289:58] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'let' @ [289:73] ==> @InlineOnly public inline fun <T, R> Party.let(block: (Party) -> String): String defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Party
    <R> -> String

'PartyNameFormatter' @ [289:79] ==> public object PartyNameFormatter defined in net.corda.explorer.formatters in file PartyNameFormatter.kt[FakeCallableDescriptorForObject]

'short' @ [289:98] ==> public final val short: Formatter<X500Name> defined in net.corda.explorer.formatters.PartyNameFormatter[PropertyDescriptorImpl]

'format' @ [289:104] ==> public abstract fun format(value: X500Name): String defined in net.corda.explorer.formatters.Formatter[SimpleFunctionDescriptorImpl]

'it' @ [289:111] ==> value-parameter it: Party defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.getCell.<anonymous>.<anonymous>.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [289:114] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'tooltip' @ [290:37] ==> public fun Node.tooltip(text: String? = ..., graphic: Node? = ..., op: (Tooltip.() -> Unit)? = ...): Tooltip defined in tornadofx[DeserializedSimpleFunctionDescriptor]

'data' @ [290:45] ==> val data: ContractState defined in net.corda.explorer.views.TransactionViewer.ContractStatesView.getCell.<anonymous>.<anonymous>[LocalVariableDescriptor]

'owner' @ [290:50] ==> public open val owner: AbstractParty defined in net.corda.finance.contracts.asset.Cash.State[DeserializedPropertyDescriptor]

'owningKey' @ [290:56] ==> public final val owningKey: PublicKey defined in net.corda.core.identity.AbstractParty[DeserializedPropertyDescriptor]

'toBase58String' @ [290:66] ==> public fun PublicKey.toBase58String(): String defined in net.corda.core.crypto[DeserializedSimpleFunctionDescriptor]

'label' @ [295:33] ==> public fun EventTarget.label(text: String = ..., op: (Label.() -> Unit)? = ...): Label defined in tornadofx[DeserializedSimpleFunctionDescriptor]

'this' @ [302:57] ==> <this> defined in net.corda.explorer.views.TransactionViewer.contract[ReceiverParameterDescriptorImpl]

'state' @ [302:62] ==> public final val state: TransactionState<ContractState> defined in net.corda.core.contracts.StateAndRef[DeserializedPropertyDescriptor]

'data' @ [302:68] ==> public final val data: ContractState defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'contract' @ [302:73] ==> public abstract val contract: Contract defined in net.corda.core.contracts.ContractState[DeserializedPropertyDescriptor]

'component1' @ [312:10] ==> public final operator fun component1(): Currency defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [312:29] ==> public final operator fun component2(): (Amount<Currency>) -> Amount<Currency> defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'reportingCurrencyExchange' @ [312:41] ==> value-parameter reportingCurrencyExchange: Pair<Currency, (Amount<Currency>) -> Amount<Currency>> defined in net.corda.explorer.views.calculateTotalEquiv[ValueParameterDescriptorImpl]

'identity' @ [313:25] ==> value-parameter identity: NodeInfo? defined in net.corda.explorer.views.calculateTotalEquiv[ValueParameterDescriptorImpl]

'legalIdentity' @ [313:35] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'this' @ [314:37] ==> <this> defined in net.corda.explorer.views.calculateTotalEquiv.sum[ReceiverParameterDescriptorImpl]

'map' @ [314:42] ==> public inline fun <T, R> Iterable<ContractState>.map(transform: (ContractState) -> Cash.State?): List<Cash.State?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ContractState
    <R> -> State?

'it' @ [314:48] ==> value-parameter it: ContractState defined in net.corda.explorer.views.calculateTotalEquiv.sum.<anonymous>[ValueParameterDescriptorImpl]

'filterNotNull' @ [315:14] ==> public fun <T : Any> Iterable<Cash.State?>.filterNotNull(): List<Cash.State> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> State

'filter' @ [316:14] ==> public inline fun <T> Iterable<Cash.State>.filter(predicate: (Cash.State) -> Boolean): List<Cash.State> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> State

'legalIdentity' @ [316:23] ==> val legalIdentity: Party? defined in net.corda.explorer.views.calculateTotalEquiv[LocalVariableDescriptor]

'it' @ [316:40] ==> value-parameter it: Cash.State defined in net.corda.explorer.views.calculateTotalEquiv.sum.<anonymous>[ValueParameterDescriptorImpl]

'owner' @ [316:43] ==> public open val owner: AbstractParty defined in net.corda.finance.contracts.asset.Cash.State[DeserializedPropertyDescriptor]

'map' @ [317:14] ==> public inline fun <T, R> Iterable<Cash.State>.map(transform: (Cash.State) -> Long): List<Long> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> State
    <R> -> Long

'invoke' @ [317:20] ==> public abstract operator fun invoke(p1: Amount<Currency>): Amount<Currency> defined in kotlin.Function1[FunctionInvokeDescriptor]

'it' @ [317:29] ==> value-parameter it: Cash.State defined in net.corda.explorer.views.calculateTotalEquiv.sum.<anonymous>[ValueParameterDescriptorImpl]

'amount' @ [317:32] ==> public open val amount: Amount<Issued<Currency>> defined in net.corda.finance.contracts.asset.Cash.State[DeserializedPropertyDescriptor]

'withoutIssuer' @ [317:39] ==> public fun <T : Any> Amount<Issued<Currency>>.withoutIssuer(): Amount<Currency> defined in net.corda.core.contracts[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> Currency

'quantity' @ [317:56] ==> public final val quantity: Long defined in net.corda.core.contracts.Amount[DeserializedPropertyDescriptor]

'sum' @ [318:14] ==> @JvmName public fun Iterable<Long>.sum(): Long defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]

'if (inputs.isEmpty()) outputs.map { it as? Cash.State }
            .filterNotNull()
            .filter { legalIdentity == it.amount.token.issuer.party && legalIdentity != it.owner }
            .map { exchange(it.amount.withoutIssuer()).quantity }
            .sum() else 0' @ [321:24] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Long, elseBranch: Long): Long[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Long

'inputs' @ [321:28] ==> value-parameter inputs: List<ContractState> defined in net.corda.explorer.views.calculateTotalEquiv[ValueParameterDescriptorImpl]

'isEmpty' @ [321:35] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'outputs' @ [321:46] ==> value-parameter outputs: List<ContractState> defined in net.corda.explorer.views.calculateTotalEquiv[ValueParameterDescriptorImpl]

'map' @ [321:54] ==> public inline fun <T, R> Iterable<ContractState>.map(transform: (ContractState) -> Cash.State?): List<Cash.State?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ContractState
    <R> -> State?

'it' @ [321:60] ==> value-parameter it: ContractState defined in net.corda.explorer.views.calculateTotalEquiv.<anonymous>[ValueParameterDescriptorImpl]

'filterNotNull' @ [322:14] ==> public fun <T : Any> Iterable<Cash.State?>.filterNotNull(): List<Cash.State> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> State

'filter' @ [323:14] ==> public inline fun <T> Iterable<Cash.State>.filter(predicate: (Cash.State) -> Boolean): List<Cash.State> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> State

'legalIdentity' @ [323:23] ==> val legalIdentity: Party? defined in net.corda.explorer.views.calculateTotalEquiv[LocalVariableDescriptor]

'it' @ [323:40] ==> value-parameter it: Cash.State defined in net.corda.explorer.views.calculateTotalEquiv.<anonymous>[ValueParameterDescriptorImpl]

'amount' @ [323:43] ==> public open val amount: Amount<Issued<Currency>> defined in net.corda.finance.contracts.asset.Cash.State[DeserializedPropertyDescriptor]

'token' @ [323:50] ==> public final val token: Issued<Currency> defined in net.corda.core.contracts.Amount[DeserializedPropertyDescriptor]

'issuer' @ [323:56] ==> public final val issuer: PartyAndReference defined in net.corda.core.contracts.Issued[DeserializedPropertyDescriptor]

'party' @ [323:63] ==> public final val party: AbstractParty defined in net.corda.core.contracts.PartyAndReference[DeserializedPropertyDescriptor]

'legalIdentity' @ [323:72] ==> val legalIdentity: Party? defined in net.corda.explorer.views.calculateTotalEquiv[LocalVariableDescriptor]

'it' @ [323:89] ==> value-parameter it: Cash.State defined in net.corda.explorer.views.calculateTotalEquiv.<anonymous>[ValueParameterDescriptorImpl]

'owner' @ [323:92] ==> public open val owner: AbstractParty defined in net.corda.finance.contracts.asset.Cash.State[DeserializedPropertyDescriptor]

'map' @ [324:14] ==> public inline fun <T, R> Iterable<Cash.State>.map(transform: (Cash.State) -> Long): List<Long> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> State
    <R> -> Long

'invoke' @ [324:20] ==> public abstract operator fun invoke(p1: Amount<Currency>): Amount<Currency> defined in kotlin.Function1[FunctionInvokeDescriptor]

'it' @ [324:29] ==> value-parameter it: Cash.State defined in net.corda.explorer.views.calculateTotalEquiv.<anonymous>[ValueParameterDescriptorImpl]

'amount' @ [324:32] ==> public open val amount: Amount<Issued<Currency>> defined in net.corda.finance.contracts.asset.Cash.State[DeserializedPropertyDescriptor]

'withoutIssuer' @ [324:39] ==> public fun <T : Any> Amount<Issued<Currency>>.withoutIssuer(): Amount<Currency> defined in net.corda.core.contracts[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Any> -> Currency

'quantity' @ [324:56] ==> public final val quantity: Long defined in net.corda.core.contracts.Amount[DeserializedPropertyDescriptor]

'sum' @ [325:14] ==> @JvmName public fun Iterable<Long>.sum(): Long defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]

'AmountDiff' @ [327:12] ==> public companion object defined in net.corda.explorer.AmountDiff[FakeCallableDescriptorForObject]

'fromLong' @ [327:23] ==> public final fun <T : Any> fromLong(quantity: Long, token: Currency): AmountDiff<Currency> defined in net.corda.explorer.AmountDiff.Companion[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> Currency

'outputs' @ [327:32] ==> value-parameter outputs: List<ContractState> defined in net.corda.explorer.views.calculateTotalEquiv[ValueParameterDescriptorImpl]

'sum' @ [327:40] ==> local final fun List<ContractState>.sum(): Long defined in net.corda.explorer.views.calculateTotalEquiv[SimpleFunctionDescriptorImpl]

'inputs' @ [327:48] ==> value-parameter inputs: List<ContractState> defined in net.corda.explorer.views.calculateTotalEquiv[ValueParameterDescriptorImpl]

'sum' @ [327:55] ==> local final fun List<ContractState>.sum(): Long defined in net.corda.explorer.views.calculateTotalEquiv[SimpleFunctionDescriptorImpl]

'issuedAmount' @ [327:63] ==> val issuedAmount: Long defined in net.corda.explorer.views.calculateTotalEquiv[LocalVariableDescriptor]

'reportingCurrency' @ [327:77] ==> val reportingCurrency: Currency defined in net.corda.explorer.views.calculateTotalEquiv[LocalVariableDescriptor]

