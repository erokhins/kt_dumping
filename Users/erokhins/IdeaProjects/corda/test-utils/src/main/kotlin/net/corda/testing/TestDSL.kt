'Deprecated' @ [47:1] ==> public constructor Deprecated(message: String, replaceWith: ReplaceWith = ..., level: DeprecationLevel = ...) defined in kotlin.Deprecated[DeserializedClassConstructorDescriptor]

'ReplaceWith' @ [49:23] ==> public constructor ReplaceWith(expression: String, vararg imports: String) defined in kotlin.ReplaceWith[DeserializedClassConstructorDescriptor]

'ERROR' @ [50:34] ==> enum entry ERROR defined in kotlin.DeprecationLevel[FakeCallableDescriptorForObject]

'Suppress' @ [51:1] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'Deprecated' @ [56:1] ==> public constructor Deprecated(message: String, replaceWith: ReplaceWith = ..., level: DeprecationLevel = ...) defined in kotlin.Deprecated[DeserializedClassConstructorDescriptor]

'ReplaceWith' @ [58:23] ==> public constructor ReplaceWith(expression: String, vararg imports: String) defined in kotlin.ReplaceWith[DeserializedClassConstructorDescriptor]

'ERROR' @ [59:34] ==> enum entry ERROR defined in kotlin.DeprecationLevel[FakeCallableDescriptorForObject]

'Suppress' @ [60:1] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'Deprecated' @ [65:1] ==> public constructor Deprecated(message: String, replaceWith: ReplaceWith = ..., level: DeprecationLevel = ...) defined in kotlin.Deprecated[DeserializedClassConstructorDescriptor]

'ReplaceWith' @ [67:23] ==> public constructor ReplaceWith(expression: String, vararg imports: String) defined in kotlin.ReplaceWith[DeserializedClassConstructorDescriptor]

'ERROR' @ [68:34] ==> enum entry ERROR defined in kotlin.DeprecationLevel[FakeCallableDescriptorForObject]

'Suppress' @ [69:1] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'EnforceVerifyOrFail' @ [81:29] ==> private constructor EnforceVerifyOrFail() defined in net.corda.testing.EnforceVerifyOrFail[ClassConstructorDescriptorImpl]

'Exception' @ [84:45] ==> public final fun <init>(p0: (String..String?)): Exception /* = Exception */ defined in kotlin.Exception[TypeAliasConstructorDescriptorImpl]

'label' @ [84:71] ==> value-parameter label: String defined in net.corda.testing.DuplicateOutputLabel.<init>[ValueParameterDescriptorImpl]

'Exception' @ [85:50] ==> public final fun <init>(p0: (String..String?)): Exception /* = Exception */ defined in kotlin.Exception[TypeAliasConstructorDescriptorImpl]

'ids' @ [85:128] ==> value-parameter ids: List<SecureHash> defined in net.corda.testing.DoubleSpentInputs.<init>[ValueParameterDescriptorImpl]

'Exception' @ [86:65] ==> public final fun <init>(p0: (String..String?)): Exception /* = Exception */ defined in kotlin.Exception[TypeAliasConstructorDescriptorImpl]

'attachmentId' @ [86:96] ==> value-parameter attachmentId: SecureHash defined in net.corda.testing.AttachmentResolutionException.<init>[ValueParameterDescriptorImpl]

'ledgerInterpreter' @ [96:53] ==> value-parameter ledgerInterpreter: TestLedgerDSLInterpreter defined in net.corda.testing.TestTransactionDSLInterpreter.<init>[ValueParameterDescriptorImpl]

'this' @ [101:9] ==> private constructor TestTransactionDSLInterpreter(ledgerInterpreter: TestLedgerDSLInterpreter, transactionBuilder: TransactionBuilder, labelToIndexMap: HashMap<String, Int>) defined in net.corda.testing.TestTransactionDSLInterpreter[ClassConstructorDescriptorImpl]

'ledgerInterpreter' @ [101:14] ==> value-parameter ledgerInterpreter: TestLedgerDSLInterpreter defined in net.corda.testing.TestTransactionDSLInterpreter.<init>[ValueParameterDescriptorImpl]

'transactionBuilder' @ [101:33] ==> value-parameter transactionBuilder: TransactionBuilder defined in net.corda.testing.TestTransactionDSLInterpreter.<init>[ValueParameterDescriptorImpl]

'HashMap' @ [101:53] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> String
    <V : (Any..Any?)> -> Int

'ledgerInterpreter' @ [103:43] ==> public open val ledgerInterpreter: TestLedgerDSLInterpreter defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'services' @ [103:61] ==> public final val services: ServiceHub defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'ledgerInterpreter' @ [104:54] ==> public open val ledgerInterpreter: TestLedgerDSLInterpreter defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'resolveStateRef' @ [104:72] ==> internal final inline fun <reified S : ContractState> resolveStateRef(stateRef: StateRef): TransactionState<ContractState> defined in net.corda.testing.TestLedgerDSLInterpreter[SimpleFunctionDescriptorImpl]
Inferred types:
    <reified S : ContractState> -> ContractState

'stateRef' @ [104:103] ==> value-parameter stateRef: StateRef defined in net.corda.testing.TestTransactionDSLInterpreter.services.<no name provided>.loadState[ValueParameterDescriptorImpl]

'TestTransactionDSLInterpreter' @ [108:13] ==> private constructor TestTransactionDSLInterpreter(ledgerInterpreter: TestLedgerDSLInterpreter, transactionBuilder: TransactionBuilder, labelToIndexMap: HashMap<String, Int>) defined in net.corda.testing.TestTransactionDSLInterpreter[ClassConstructorDescriptorImpl]

'ledgerInterpreter' @ [109:41] ==> public open val ledgerInterpreter: TestLedgerDSLInterpreter defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'transactionBuilder' @ [110:42] ==> public final val transactionBuilder: TransactionBuilder defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'copy' @ [110:61] ==> public final fun copy(): TransactionBuilder defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'HashMap' @ [111:39] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>(p0: (MutableMap<out (String..String?), out (Int..Int?)>..Map<out (String..String?), (Int..Int?)>?)) defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> String
    <V : (Any..Any?)> -> Int

'labelToIndexMap' @ [111:47] ==> internal final val labelToIndexMap: HashMap<String, Int> defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'transactionBuilder' @ [114:40] ==> public final val transactionBuilder: TransactionBuilder defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'toWireTransaction' @ [114:59] ==> public final fun toWireTransaction(): WireTransaction defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'ledgerInterpreter' @ [117:21] ==> public open val ledgerInterpreter: TestLedgerDSLInterpreter defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'resolveStateRef' @ [117:39] ==> internal final inline fun <reified S : ContractState> resolveStateRef(stateRef: StateRef): TransactionState<ContractState> defined in net.corda.testing.TestLedgerDSLInterpreter[SimpleFunctionDescriptorImpl]
Inferred types:
    <reified S : ContractState> -> ContractState

'stateRef' @ [117:70] ==> value-parameter stateRef: StateRef defined in net.corda.testing.TestTransactionDSLInterpreter.input[ValueParameterDescriptorImpl]

'transactionBuilder' @ [118:9] ==> public final val transactionBuilder: TransactionBuilder defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'addInputState' @ [118:28] ==> public open fun addInputState(stateAndRef: StateAndRef<*>): TransactionBuilder defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'StateAndRef' @ [118:42] ==> public constructor StateAndRef<out T : ContractState>(state: TransactionState<ContractState>, ref: StateRef) defined in net.corda.core.contracts.StateAndRef[DeserializedClassConstructorDescriptor]
Inferred types:
    <out T : ContractState> -> ContractState

'state' @ [118:54] ==> val state: TransactionState<ContractState> defined in net.corda.testing.TestTransactionDSLInterpreter.input[LocalVariableDescriptor]

'stateRef' @ [118:61] ==> value-parameter stateRef: StateRef defined in net.corda.testing.TestTransactionDSLInterpreter.input[ValueParameterDescriptorImpl]

'transactionBuilder' @ [122:9] ==> public final val transactionBuilder: TransactionBuilder defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'addOutputState' @ [122:28] ==> @JvmOverloads public final fun addOutputState(state: ContractState, notary: Party, encumbrance: Int? = ...): TransactionBuilder defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'contractState' @ [122:43] ==> value-parameter contractState: ContractState defined in net.corda.testing.TestTransactionDSLInterpreter._output[ValueParameterDescriptorImpl]

'notary' @ [122:58] ==> value-parameter notary: Party defined in net.corda.testing.TestTransactionDSLInterpreter._output[ValueParameterDescriptorImpl]

'encumbrance' @ [122:66] ==> value-parameter encumbrance: Int? defined in net.corda.testing.TestTransactionDSLInterpreter._output[ValueParameterDescriptorImpl]

'label' @ [123:13] ==> value-parameter label: String? defined in net.corda.testing.TestTransactionDSLInterpreter._output[ValueParameterDescriptorImpl]

'if (label in labelToIndexMap) {
                throw DuplicateOutputLabel(label)
            } else {
                val outputIndex = transactionBuilder.outputStates().size - 1
                labelToIndexMap[label] = outputIndex
            }' @ [124:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'label' @ [124:17] ==> value-parameter label: String? defined in net.corda.testing.TestTransactionDSLInterpreter._output[ValueParameterDescriptorImpl]

'labelToIndexMap' @ [124:26] ==> internal final val labelToIndexMap: HashMap<String, Int> defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'DuplicateOutputLabel' @ [125:23] ==> public constructor DuplicateOutputLabel(label: String) defined in net.corda.testing.DuplicateOutputLabel[ClassConstructorDescriptorImpl]

'label' @ [125:44] ==> value-parameter label: String? defined in net.corda.testing.TestTransactionDSLInterpreter._output[ValueParameterDescriptorImpl]

'transactionBuilder' @ [127:35] ==> public final val transactionBuilder: TransactionBuilder defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'outputStates' @ [127:54] ==> public final fun outputStates(): List<TransactionState<*>> defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'size' @ [127:69] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'labelToIndexMap' @ [128:17] ==> internal final val labelToIndexMap: HashMap<String, Int> defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'label' @ [128:33] ==> value-parameter label: String? defined in net.corda.testing.TestTransactionDSLInterpreter._output[ValueParameterDescriptorImpl]

'outputIndex' @ [128:42] ==> val outputIndex: Int defined in net.corda.testing.TestTransactionDSLInterpreter._output[LocalVariableDescriptor]

'transactionBuilder' @ [134:9] ==> public final val transactionBuilder: TransactionBuilder defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'addAttachment' @ [134:28] ==> public final fun addAttachment(attachmentId: SecureHash): TransactionBuilder defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'attachmentId' @ [134:42] ==> value-parameter attachmentId: SecureHash defined in net.corda.testing.TestTransactionDSLInterpreter.attachment[ValueParameterDescriptorImpl]

'Command' @ [138:23] ==> public constructor Command<T : CommandData>(value: CommandData, signers: List<PublicKey>) defined in net.corda.core.contracts.Command[DeserializedClassConstructorDescriptor]
Inferred types:
    <T : CommandData> -> CommandData

'commandData' @ [138:31] ==> value-parameter commandData: CommandData defined in net.corda.testing.TestTransactionDSLInterpreter._command[ValueParameterDescriptorImpl]

'signers' @ [138:44] ==> value-parameter signers: List<PublicKey> defined in net.corda.testing.TestTransactionDSLInterpreter._command[ValueParameterDescriptorImpl]

'transactionBuilder' @ [139:9] ==> public final val transactionBuilder: TransactionBuilder defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'addCommand' @ [139:28] ==> public final fun addCommand(arg: Command<*>): TransactionBuilder defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'command' @ [139:39] ==> val command: Command<CommandData> defined in net.corda.testing.TestTransactionDSLInterpreter._command[LocalVariableDescriptor]

'transactionBuilder' @ [145:9] ==> public final val transactionBuilder: TransactionBuilder defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'copy' @ [145:28] ==> public final fun copy(): TransactionBuilder defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'apply' @ [145:35] ==> @InlineOnly public inline fun <T> TransactionBuilder.apply(block: TransactionBuilder.() -> Unit): TransactionBuilder defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TransactionBuilder

'toWireTransaction' @ [146:13] ==> public final fun toWireTransaction(): WireTransaction defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'toLedgerTransaction' @ [146:33] ==> public final fun toLedgerTransaction(services: ServicesForResolution): LedgerTransaction defined in net.corda.core.transactions.WireTransaction[DeserializedSimpleFunctionDescriptor]

'services' @ [146:53] ==> public final val services: ServiceHub defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'verify' @ [146:63] ==> public final fun verify(): Unit defined in net.corda.core.transactions.LedgerTransaction[DeserializedSimpleFunctionDescriptor]

'Token' @ [148:36] ==> internal object Token : EnforceVerifyOrFail defined in net.corda.testing.EnforceVerifyOrFail[FakeCallableDescriptorForObject]

'transactionBuilder' @ [152:9] ==> public final val transactionBuilder: TransactionBuilder defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'setTimeWindow' @ [152:28] ==> public final fun setTimeWindow(timeWindow: TimeWindow): TransactionBuilder defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'data' @ [152:42] ==> value-parameter data: TimeWindow defined in net.corda.testing.TestTransactionDSLInterpreter.timeWindow[ValueParameterDescriptorImpl]

'invoke' @ [157:9] ==> public abstract operator fun invoke(p1: TransactionDSL<TransactionDSLInterpreter>): EnforceVerifyOrFail defined in kotlin.Function1[FunctionInvokeDescriptor]

'TransactionDSL' @ [157:13] ==> public constructor TransactionDSL<out T : TransactionDSLInterpreter>(interpreter: TestTransactionDSLInterpreter) defined in net.corda.testing.TransactionDSL[ClassConstructorDescriptorImpl]
Inferred types:
    <out T : TransactionDSLInterpreter> -> TestTransactionDSLInterpreter

'copy' @ [157:28] ==> private final fun copy(): TestTransactionDSLInterpreter defined in net.corda.testing.TestTransactionDSLInterpreter[SimpleFunctionDescriptorImpl]

'HashMap' @ [162:95] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> String
    <V : (Any..Any?)> -> StateAndRef<ContractState>

'LinkedHashMap' @ [163:98] ==> public constructor LinkedHashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.LinkedHashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> (net.corda.core.crypto.SecureHash..net.corda.core.crypto.SecureHash?)
    <V : (Any..Any?)> -> (net.corda.testing.TestLedgerDSLInterpreter.WireTransactionWithLocation..net.corda.testing.TestLedgerDSLInterpreter.WireTransactionWithLocation?)

'HashMap' @ [164:109] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> SecureHash
    <V : (Any..Any?)> -> WireTransactionWithLocation

'transactionWithLocations' @ [166:57] ==> private final val transactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'values' @ [166:82] ==> public open val values: MutableCollection<TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in java.util.HashMap[JavaPropertyDescriptor]

'map' @ [166:89] ==> public inline fun <T, R> Iterable<TestLedgerDSLInterpreter.WireTransactionWithLocation>.map(transform: (TestLedgerDSLInterpreter.WireTransactionWithLocation) -> WireTransaction): List<WireTransaction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> WireTransactionWithLocation
    <R> -> WireTransaction

'it' @ [166:95] ==> value-parameter it: TestLedgerDSLInterpreter.WireTransactionWithLocation defined in net.corda.testing.TestLedgerDSLInterpreter.<get-wireTransactions>.<anonymous>[ValueParameterDescriptorImpl]

'transaction' @ [166:98] ==> public final val transaction: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.WireTransactionWithLocation[PropertyDescriptorImpl]

'this' @ [169:41] ==> private constructor TestLedgerDSLInterpreter(services: ServiceHub, labelToOutputStateAndRefs: HashMap<String, StateAndRef<ContractState>> = ..., transactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> = ..., nonVerifiedTransactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> = ...) defined in net.corda.testing.TestLedgerDSLInterpreter[ClassConstructorDescriptorImpl]

'services' @ [169:46] ==> value-parameter services: ServiceHub defined in net.corda.testing.TestLedgerDSLInterpreter.<init>[ValueParameterDescriptorImpl]

'HashMap' @ [169:84] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> String
    <V : (Any..Any?)> -> StateAndRef<ContractState>

'currentThread' @ [173:37] ==> public open fun currentThread(): (Thread..Thread?) defined in java.lang.Thread[JavaMethodDescriptor]

'stackTrace' @ [173:53] ==> public final val Thread.stackTrace: (Array<(StackTraceElement..StackTraceElement?)>..Array<out (StackTraceElement..StackTraceElement?)>?)[MyPropertyDescriptor]

'..' @ [174:23] ==> public final operator fun rangeTo(other: Int): IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'stackTrace' @ [174:26] ==> val stackTrace: (Array<(StackTraceElement..StackTraceElement?)>..Array<out (StackTraceElement..StackTraceElement?)>?) defined in net.corda.testing.TestLedgerDSLInterpreter.Companion.getCallerLocation[LocalVariableDescriptor]

'size' @ [174:37] ==> public final val size: Int defined in kotlin.Array[DeserializedPropertyDescriptor]

'stackTrace' @ [175:41] ==> val stackTrace: (Array<(StackTraceElement..StackTraceElement?)>..Array<out (StackTraceElement..StackTraceElement?)>?) defined in net.corda.testing.TestLedgerDSLInterpreter.Companion.getCallerLocation[LocalVariableDescriptor]

'i' @ [175:52] ==> val i: Int defined in net.corda.testing.TestLedgerDSLInterpreter.Companion.getCallerLocation[LocalVariableDescriptor]

'!' @ [176:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'stackTraceElement' @ [176:22] ==> val stackTraceElement: (StackTraceElement..StackTraceElement?) defined in net.corda.testing.TestLedgerDSLInterpreter.Companion.getCallerLocation[LocalVariableDescriptor]

'fileName' @ [176:40] ==> public final val StackTraceElement.fileName: (String..String?)[MyPropertyDescriptor]

'contains' @ [176:49] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'stackTraceElement' @ [177:28] ==> val stackTraceElement: (StackTraceElement..StackTraceElement?) defined in net.corda.testing.TestLedgerDSLInterpreter.Companion.getCallerLocation[LocalVariableDescriptor]

'toString' @ [177:46] ==> public open fun toString(): String defined in java.lang.StackTraceElement[JavaMethodDescriptor]

'Exception' @ [191:13] ==> public final fun <init>(p0: (String..String?), p1: (Throwable..Throwable?)): Exception /* = Exception */ defined in kotlin.Exception[TypeAliasConstructorDescriptorImpl]

'transactionName' @ [191:38] ==> value-parameter transactionName: String defined in net.corda.testing.TestLedgerDSLInterpreter.VerifiesFailed.<init>[ValueParameterDescriptorImpl]

'cause' @ [191:71] ==> value-parameter cause: Throwable defined in net.corda.testing.TestLedgerDSLInterpreter.VerifiesFailed.<init>[ValueParameterDescriptorImpl]

'cause' @ [191:79] ==> value-parameter cause: Throwable defined in net.corda.testing.TestLedgerDSLInterpreter.VerifiesFailed.<init>[ValueParameterDescriptorImpl]

'Exception' @ [194:13] ==> public final fun <init>(p0: (String..String?)): Exception /* = Exception */ defined in kotlin.Exception[TypeAliasConstructorDescriptorImpl]

'actual' @ [194:37] ==> value-parameter actual: Class<*> defined in net.corda.testing.TestLedgerDSLInterpreter.TypeMismatch.<init>[ValueParameterDescriptorImpl]

'requested' @ [194:80] ==> value-parameter requested: Class<*> defined in net.corda.testing.TestLedgerDSLInterpreter.TypeMismatch.<init>[ValueParameterDescriptorImpl]

'TestLedgerDSLInterpreter' @ [197:13] ==> private constructor TestLedgerDSLInterpreter(services: ServiceHub, labelToOutputStateAndRefs: HashMap<String, StateAndRef<ContractState>> = ..., transactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> = ..., nonVerifiedTransactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> = ...) defined in net.corda.testing.TestLedgerDSLInterpreter[ClassConstructorDescriptorImpl]

'services' @ [198:21] ==> public final val services: ServiceHub defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'HashMap' @ [199:49] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>(p0: (MutableMap<out (String..String?), out (StateAndRef<ContractState>..StateAndRef<ContractState>?)>..Map<out (String..String?), (StateAndRef<ContractState>..StateAndRef<ContractState>?)>?)) defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> String
    <V : (Any..Any?)> -> StateAndRef<ContractState>

'labelToOutputStateAndRefs' @ [199:57] ==> internal final val labelToOutputStateAndRefs: HashMap<String, StateAndRef<ContractState>> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'HashMap' @ [200:48] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>(p0: (MutableMap<out (SecureHash..SecureHash?), out (TestLedgerDSLInterpreter.WireTransactionWithLocation..TestLedgerDSLInterpreter.WireTransactionWithLocation?)>..Map<out (SecureHash..SecureHash?), (TestLedgerDSLInterpreter.WireTransactionWithLocation..TestLedgerDSLInterpreter.WireTransactionWithLocation?)>?)) defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> SecureHash
    <V : (Any..Any?)> -> WireTransactionWithLocation

'transactionWithLocations' @ [200:56] ==> private final val transactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'HashMap' @ [201:59] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>(p0: (MutableMap<out (SecureHash..SecureHash?), out (TestLedgerDSLInterpreter.WireTransactionWithLocation..TestLedgerDSLInterpreter.WireTransactionWithLocation?)>..Map<out (SecureHash..SecureHash?), (TestLedgerDSLInterpreter.WireTransactionWithLocation..TestLedgerDSLInterpreter.WireTransactionWithLocation?)>?)) defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> SecureHash
    <V : (Any..Any?)> -> WireTransactionWithLocation

'nonVerifiedTransactionWithLocations' @ [201:67] ==> private final val nonVerifiedTransactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'transactionWithLocations' @ [206:17] ==> private final val transactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'stateRef' @ [206:42] ==> value-parameter stateRef: StateRef defined in net.corda.testing.TestLedgerDSLInterpreter.resolveStateRef[ValueParameterDescriptorImpl]

'txhash' @ [206:51] ==> public final val txhash: SecureHash defined in net.corda.core.contracts.StateRef[DeserializedPropertyDescriptor]

'nonVerifiedTransactionWithLocations' @ [207:25] ==> private final val nonVerifiedTransactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'stateRef' @ [207:61] ==> value-parameter stateRef: StateRef defined in net.corda.testing.TestLedgerDSLInterpreter.resolveStateRef[ValueParameterDescriptorImpl]

'txhash' @ [207:70] ==> public final val txhash: SecureHash defined in net.corda.core.contracts.StateRef[DeserializedPropertyDescriptor]

'TransactionResolutionException' @ [208:31] ==> public constructor TransactionResolutionException(hash: SecureHash) defined in net.corda.core.contracts.TransactionResolutionException[DeserializedClassConstructorDescriptor]

'stateRef' @ [208:62] ==> value-parameter stateRef: StateRef defined in net.corda.testing.TestLedgerDSLInterpreter.resolveStateRef[ValueParameterDescriptorImpl]

'txhash' @ [208:71] ==> public final val txhash: SecureHash defined in net.corda.core.contracts.StateRef[DeserializedPropertyDescriptor]

'transactionWithLocation' @ [209:22] ==> val transactionWithLocation: TestLedgerDSLInterpreter.WireTransactionWithLocation defined in net.corda.testing.TestLedgerDSLInterpreter.resolveStateRef[LocalVariableDescriptor]

'transaction' @ [209:46] ==> public final val transaction: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.WireTransactionWithLocation[PropertyDescriptorImpl]

'outputs' @ [209:58] ==> public open val outputs: List<TransactionState<ContractState>> defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'stateRef' @ [209:66] ==> value-parameter stateRef: StateRef defined in net.corda.testing.TestLedgerDSLInterpreter.resolveStateRef[ValueParameterDescriptorImpl]

'index' @ [209:75] ==> public final val index: Int defined in net.corda.core.contracts.StateRef[DeserializedPropertyDescriptor]

'if (S::class.java.isAssignableFrom(output.data.javaClass)) @Suppress("UNCHECKED_CAST") {
            output as TransactionState<S>
        } else {
            throw TypeMismatch(requested = S::class.java, actual = output.data.javaClass)
        }' @ [210:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: TransactionState<S>, elseBranch: TransactionState<S>): TransactionState<S>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> TransactionState<S>

'java' @ [210:29] ==> public val <T> KClass<S>.java: Class<S> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> S

'isAssignableFrom' @ [210:34] ==> public open fun isAssignableFrom(p0: (Class<*>..Class<*>?)): Boolean defined in java.lang.Class[JavaMethodDescriptor]

'output' @ [210:51] ==> val output: TransactionState<ContractState> defined in net.corda.testing.TestLedgerDSLInterpreter.resolveStateRef[LocalVariableDescriptor]

'data' @ [210:58] ==> public final val data: ContractState defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'javaClass' @ [210:63] ==> public val <T : Any> ContractState.javaClass: Class<ContractState> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> ContractState

'Suppress' @ [210:75] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'output' @ [211:13] ==> val output: TransactionState<ContractState> defined in net.corda.testing.TestLedgerDSLInterpreter.resolveStateRef[LocalVariableDescriptor]

'TypeMismatch' @ [213:19] ==> public constructor TypeMismatch(requested: Class<*>, actual: Class<*>) defined in net.corda.testing.TestLedgerDSLInterpreter.TypeMismatch[ClassConstructorDescriptorImpl]

'java' @ [213:53] ==> public val <T> KClass<S>.java: Class<S> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> S

'output' @ [213:68] ==> val output: TransactionState<ContractState> defined in net.corda.testing.TestLedgerDSLInterpreter.resolveStateRef[LocalVariableDescriptor]

'data' @ [213:75] ==> public final val data: ContractState defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'javaClass' @ [213:80] ==> public val <T : Any> ContractState.javaClass: Class<ContractState> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> ContractState

'services' @ [218:16] ==> public final val services: ServiceHub defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'attachments' @ [218:25] ==> public abstract val attachments: AttachmentStorage defined in net.corda.core.node.ServiceHub[DeserializedPropertyDescriptor]

'openAttachment' @ [218:37] ==> public abstract fun openAttachment(id: SecureHash): Attachment? defined in net.corda.core.node.services.AttachmentStorage[DeserializedSimpleFunctionDescriptor]

'attachmentId' @ [218:52] ==> value-parameter attachmentId: SecureHash defined in net.corda.testing.TestLedgerDSLInterpreter.resolveAttachment[ValueParameterDescriptorImpl]

'AttachmentResolutionException' @ [218:75] ==> public constructor AttachmentResolutionException(attachmentId: SecureHash) defined in net.corda.testing.AttachmentResolutionException[ClassConstructorDescriptorImpl]

'attachmentId' @ [218:105] ==> value-parameter attachmentId: SecureHash defined in net.corda.testing.TestLedgerDSLInterpreter.resolveAttachment[ValueParameterDescriptorImpl]

'TestTransactionDSLInterpreter' @ [225:38] ==> public constructor TestTransactionDSLInterpreter(ledgerInterpreter: TestLedgerDSLInterpreter, transactionBuilder: TransactionBuilder) defined in net.corda.testing.TestTransactionDSLInterpreter[ClassConstructorDescriptorImpl]

'this' @ [225:68] ==> <this> defined in net.corda.testing.TestLedgerDSLInterpreter[LazyClassReceiverParameterDescriptor]

'transactionBuilder' @ [225:74] ==> value-parameter transactionBuilder: TransactionBuilder defined in net.corda.testing.TestLedgerDSLInterpreter.interpretTransactionDsl[ValueParameterDescriptorImpl]

'invoke' @ [226:9] ==> public abstract operator fun invoke(p1: TransactionDSL<TestTransactionDSLInterpreter>): R defined in kotlin.Function1[FunctionInvokeDescriptor]

'TransactionDSL' @ [226:13] ==> public constructor TransactionDSL<out T : TransactionDSLInterpreter>(interpreter: TestTransactionDSLInterpreter) defined in net.corda.testing.TransactionDSL[ClassConstructorDescriptorImpl]
Inferred types:
    <out T : TransactionDSLInterpreter> -> TestTransactionDSLInterpreter

'transactionInterpreter' @ [226:28] ==> val transactionInterpreter: TestTransactionDSLInterpreter defined in net.corda.testing.TestLedgerDSLInterpreter.interpretTransactionDsl[LocalVariableDescriptor]

'transactionInterpreter' @ [227:16] ==> val transactionInterpreter: TestTransactionDSLInterpreter defined in net.corda.testing.TestLedgerDSLInterpreter.interpretTransactionDsl[LocalVariableDescriptor]

'transactionWithLocations' @ [231:39] ==> private final val transactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'transactionHash' @ [231:64] ==> value-parameter transactionHash: SecureHash defined in net.corda.testing.TestLedgerDSLInterpreter.transactionName[ValueParameterDescriptorImpl]

'if (transactionWithLocation != null) {
            transactionWithLocation.label ?: "TX[${transactionWithLocation.location}]"
        } else {
            null
        }' @ [232:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String?, elseBranch: String?): String?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String?

'transactionWithLocation' @ [232:20] ==> val transactionWithLocation: TestLedgerDSLInterpreter.WireTransactionWithLocation? defined in net.corda.testing.TestLedgerDSLInterpreter.transactionName[LocalVariableDescriptor]

'transactionWithLocation' @ [233:13] ==> val transactionWithLocation: TestLedgerDSLInterpreter.WireTransactionWithLocation? defined in net.corda.testing.TestLedgerDSLInterpreter.transactionName[LocalVariableDescriptor]

'label' @ [233:37] ==> public final val label: String? defined in net.corda.testing.TestLedgerDSLInterpreter.WireTransactionWithLocation[PropertyDescriptorImpl]

'transactionWithLocation' @ [233:52] ==> val transactionWithLocation: TestLedgerDSLInterpreter.WireTransactionWithLocation? defined in net.corda.testing.TestLedgerDSLInterpreter.transactionName[LocalVariableDescriptor]

'location' @ [233:76] ==> public final val location: String? defined in net.corda.testing.TestLedgerDSLInterpreter.WireTransactionWithLocation[PropertyDescriptorImpl]

'labelToOutputStateAndRefs' @ [240:13] ==> internal final val labelToOutputStateAndRefs: HashMap<String, StateAndRef<ContractState>> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'filter' @ [240:39] ==> public inline fun <K, V> Map<out String, StateAndRef<ContractState>>.filter(predicate: (Map.Entry<String, StateAndRef<ContractState>>) -> Boolean): Map<String, StateAndRef<ContractState>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> String
    <V> -> StateAndRef<ContractState>

'it' @ [240:48] ==> value-parameter it: Map.Entry<String, StateAndRef<ContractState>> defined in net.corda.testing.TestLedgerDSLInterpreter.outputToLabel.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [240:51] ==> public abstract val value: StateAndRef<ContractState> defined in kotlin.collections.Map.Entry[DeserializedPropertyDescriptor]

'state' @ [240:57] ==> public final val state: TransactionState<ContractState> defined in net.corda.core.contracts.StateAndRef[DeserializedPropertyDescriptor]

'data' @ [240:63] ==> public final val data: ContractState defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'state' @ [240:71] ==> value-parameter state: ContractState defined in net.corda.testing.TestLedgerDSLInterpreter.outputToLabel[ValueParameterDescriptorImpl]

'keys' @ [240:79] ==> public abstract val keys: Set<String> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'firstOrNull' @ [240:84] ==> public fun <T> Iterable<String>.firstOrNull(): String? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'HashMap' @ [246:80] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> SecureHash
    <V : (Any..Any?)> -> WireTransactionWithLocation

'getCallerLocation' @ [248:35] ==> private final fun getCallerLocation(): String? defined in net.corda.testing.TestLedgerDSLInterpreter.Companion[SimpleFunctionDescriptorImpl]

'interpretTransactionDsl' @ [249:38] ==> private final fun <R> interpretTransactionDsl(transactionBuilder: TransactionBuilder, dsl: TransactionDSL<TestTransactionDSLInterpreter>.() -> R): TestTransactionDSLInterpreter defined in net.corda.testing.TestLedgerDSLInterpreter[SimpleFunctionDescriptorImpl]
Inferred types:
    <R> -> R

'transactionBuilder' @ [249:62] ==> value-parameter transactionBuilder: TransactionBuilder defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap[ValueParameterDescriptorImpl]

'dsl' @ [249:82] ==> value-parameter dsl: TransactionDSL<TestTransactionDSLInterpreter>.() -> R defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap[ValueParameterDescriptorImpl]

'transactionInterpreter' @ [251:31] ==> val transactionInterpreter: TestTransactionDSLInterpreter defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap[LocalVariableDescriptor]

'toWireTransaction' @ [251:54] ==> internal final fun toWireTransaction(): WireTransaction defined in net.corda.testing.TestTransactionDSLInterpreter[SimpleFunctionDescriptorImpl]

'transactionInterpreter' @ [253:9] ==> val transactionInterpreter: TestTransactionDSLInterpreter defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap[LocalVariableDescriptor]

'labelToIndexMap' @ [253:32] ==> internal final val labelToIndexMap: HashMap<String, Int> defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'forEach' @ [253:48] ==> public final fun forEach(p0: (String, Int) -> Unit): Unit defined in java.util.HashMap[MyFunctionDescriptor]

'label' @ [254:17] ==> value-parameter label: String defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap.<anonymous>[ValueParameterDescriptorImpl]

'labelToOutputStateAndRefs' @ [254:26] ==> internal final val labelToOutputStateAndRefs: HashMap<String, StateAndRef<ContractState>> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'DuplicateOutputLabel' @ [255:23] ==> public constructor DuplicateOutputLabel(label: String) defined in net.corda.testing.DuplicateOutputLabel[ClassConstructorDescriptorImpl]

'label' @ [255:44] ==> value-parameter label: String defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap.<anonymous>[ValueParameterDescriptorImpl]

'labelToOutputStateAndRefs' @ [257:13] ==> internal final val labelToOutputStateAndRefs: HashMap<String, StateAndRef<ContractState>> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'label' @ [257:39] ==> value-parameter label: String defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap.<anonymous>[ValueParameterDescriptorImpl]

'wireTransaction' @ [257:48] ==> val wireTransaction: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap[LocalVariableDescriptor]

'outRef' @ [257:64] ==> public final fun <T : ContractState> outRef(index: Int): StateAndRef<ContractState> defined in net.corda.core.transactions.WireTransaction[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : ContractState> -> ContractState

'index' @ [257:71] ==> value-parameter index: Int defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap.<anonymous>[ValueParameterDescriptorImpl]

'transactionMap' @ [259:9] ==> value-parameter transactionMap: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> = ... defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap[ValueParameterDescriptorImpl]

'wireTransaction' @ [259:24] ==> val wireTransaction: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap[LocalVariableDescriptor]

'id' @ [259:40] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'WireTransactionWithLocation' @ [260:17] ==> public constructor WireTransactionWithLocation(label: String?, transaction: WireTransaction, location: String?) defined in net.corda.testing.TestLedgerDSLInterpreter.WireTransactionWithLocation[ClassConstructorDescriptorImpl]

'transactionLabel' @ [260:45] ==> value-parameter transactionLabel: String? defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap[ValueParameterDescriptorImpl]

'wireTransaction' @ [260:63] ==> val wireTransaction: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap[LocalVariableDescriptor]

'transactionLocation' @ [260:80] ==> val transactionLocation: String? defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap[LocalVariableDescriptor]

'wireTransaction' @ [262:16] ==> val wireTransaction: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap[LocalVariableDescriptor]

'recordTransactionWithTransactionMap' @ [269:9] ==> private final fun <R> recordTransactionWithTransactionMap(transactionLabel: String?, transactionBuilder: TransactionBuilder, dsl: TransactionDSL<TestTransactionDSLInterpreter>.() -> EnforceVerifyOrFail, transactionMap: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> = ...): WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter[SimpleFunctionDescriptorImpl]
Inferred types:
    <R> -> EnforceVerifyOrFail

'transactionLabel' @ [269:45] ==> value-parameter transactionLabel: String? defined in net.corda.testing.TestLedgerDSLInterpreter._transaction[ValueParameterDescriptorImpl]

'transactionBuilder' @ [269:63] ==> value-parameter transactionBuilder: TransactionBuilder defined in net.corda.testing.TestLedgerDSLInterpreter._transaction[ValueParameterDescriptorImpl]

'dsl' @ [269:83] ==> value-parameter dsl: TransactionDSL<TestTransactionDSLInterpreter>.() -> EnforceVerifyOrFail defined in net.corda.testing.TestLedgerDSLInterpreter._transaction[ValueParameterDescriptorImpl]

'transactionWithLocations' @ [269:88] ==> private final val transactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'recordTransactionWithTransactionMap' @ [275:9] ==> private final fun <R> recordTransactionWithTransactionMap(transactionLabel: String?, transactionBuilder: TransactionBuilder, dsl: TransactionDSL<TestTransactionDSLInterpreter>.() -> Unit, transactionMap: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> = ...): WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter[SimpleFunctionDescriptorImpl]
Inferred types:
    <R> -> Unit

'transactionLabel' @ [275:45] ==> value-parameter transactionLabel: String? defined in net.corda.testing.TestLedgerDSLInterpreter._unverifiedTransaction[ValueParameterDescriptorImpl]

'transactionBuilder' @ [275:63] ==> value-parameter transactionBuilder: TransactionBuilder defined in net.corda.testing.TestLedgerDSLInterpreter._unverifiedTransaction[ValueParameterDescriptorImpl]

'dsl' @ [275:83] ==> value-parameter dsl: TransactionDSL<TestTransactionDSLInterpreter>.() -> Unit defined in net.corda.testing.TestLedgerDSLInterpreter._unverifiedTransaction[ValueParameterDescriptorImpl]

'nonVerifiedTransactionWithLocations' @ [275:88] ==> private final val nonVerifiedTransactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'invoke' @ [280:13] ==> public abstract operator fun invoke(p1: LedgerDSL<TestTransactionDSLInterpreter, LedgerDSLInterpreter<TestTransactionDSLInterpreter>>): Unit defined in kotlin.Function1[FunctionInvokeDescriptor]

'LedgerDSL' @ [280:17] ==> public constructor LedgerDSL<out T : TransactionDSLInterpreter, out L : LedgerDSLInterpreter<TestTransactionDSLInterpreter>>(interpreter: TestLedgerDSLInterpreter) defined in net.corda.testing.LedgerDSL[ClassConstructorDescriptorImpl]
Inferred types:
    <out T : TransactionDSLInterpreter> -> TestTransactionDSLInterpreter
    <out L : LedgerDSLInterpreter<T>> -> TestLedgerDSLInterpreter

'copy' @ [280:27] ==> internal final fun copy(): TestLedgerDSLInterpreter defined in net.corda.testing.TestLedgerDSLInterpreter[SimpleFunctionDescriptorImpl]

'services' @ [283:16] ==> public final val services: ServiceHub defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'attachments' @ [283:25] ==> public abstract val attachments: AttachmentStorage defined in net.corda.core.node.ServiceHub[DeserializedPropertyDescriptor]

'importAttachment' @ [283:37] ==> public abstract fun importAttachment(jar: InputStream): SecureHash defined in net.corda.core.node.services.AttachmentStorage[DeserializedSimpleFunctionDescriptor]

'attachment' @ [283:54] ==> value-parameter attachment: InputStream defined in net.corda.testing.TestLedgerDSLInterpreter.attachment[ValueParameterDescriptorImpl]

'mutableSetOf' @ [288:30] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableSetOf(): MutableSet<StateRef> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> StateRef

'services' @ [289:13] ==> public final val services: ServiceHub defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'recordTransactions' @ [289:22] ==> public open fun recordTransactions(txs: Iterable<SignedTransaction>): Unit defined in net.corda.core.node.ServiceHub[DeserializedSimpleFunctionDescriptor]

'transactionsUnverified' @ [289:41] ==> public final val transactionsUnverified: List<WireTransaction> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'map' @ [289:64] ==> public inline fun <T, R> Iterable<WireTransaction>.map(transform: (WireTransaction) -> SignedTransaction): List<SignedTransaction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> WireTransaction
    <R> -> SignedTransaction

'SignedTransaction' @ [289:70] ==> public constructor SignedTransaction(ctx: CoreTransaction, sigs: List<TransactionSignature>) defined in net.corda.core.transactions.SignedTransaction[DeserializedClassConstructorDescriptor]

'it' @ [289:88] ==> value-parameter it: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.verifies.<anonymous>[ValueParameterDescriptorImpl]

'listOf' @ [289:92] ==> public fun <T> listOf(element: TransactionSignature): List<TransactionSignature> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TransactionSignature

'NULL_SIGNATURE' @ [289:99] ==> public val NULL_SIGNATURE: TransactionSignature defined in net.corda.core.crypto.testing[DeserializedPropertyDescriptor]

'component1' @ [290:19] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation>.component1(): SecureHash defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> SecureHash
    <V> -> WireTransactionWithLocation

'component2' @ [290:22] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation>.component2(): TestLedgerDSLInterpreter.WireTransactionWithLocation defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> SecureHash
    <V> -> WireTransactionWithLocation

'transactionWithLocations' @ [290:32] ==> private final val transactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'value' @ [291:27] ==> val value: TestLedgerDSLInterpreter.WireTransactionWithLocation defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'transaction' @ [291:33] ==> public final val transaction: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.WireTransactionWithLocation[PropertyDescriptorImpl]

'wtx' @ [292:27] ==> val wtx: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'toLedgerTransaction' @ [292:31] ==> public final fun toLedgerTransaction(services: ServicesForResolution): LedgerTransaction defined in net.corda.core.transactions.WireTransaction[DeserializedSimpleFunctionDescriptor]

'services' @ [292:51] ==> public final val services: ServiceHub defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'ltx' @ [293:17] ==> val ltx: LedgerTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'verify' @ [293:21] ==> public final fun verify(): Unit defined in net.corda.core.transactions.LedgerTransaction[DeserializedSimpleFunctionDescriptor]

'wtx' @ [294:35] ==> val wtx: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'inputs' @ [294:39] ==> public open val inputs: List<StateRef> defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'intersect' @ [294:46] ==> public infix fun <T> Iterable<StateRef>.intersect(other: Iterable<StateRef>): Set<StateRef> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> StateRef

'usedInputs' @ [294:56] ==> val usedInputs: MutableSet<StateRef> defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'!' @ [295:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'doubleSpend' @ [295:22] ==> val doubleSpend: Set<StateRef> defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'isEmpty' @ [295:34] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.Set[DeserializedSimpleFunctionDescriptor]

'mutableListOf' @ [296:33] ==> public fun <T> mutableListOf(vararg elements: SecureHash): MutableList<SecureHash> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SecureHash

'wtx' @ [296:47] ==> val wtx: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'id' @ [296:51] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'doubleSpend' @ [297:21] ==> val doubleSpend: Set<StateRef> defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'mapTo' @ [297:33] ==> public inline fun <T, R, C : MutableCollection<in SecureHash>> Iterable<StateRef>.mapTo(destination: MutableList<SecureHash>, transform: (StateRef) -> SecureHash): MutableList<SecureHash> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> StateRef
    <R> -> SecureHash
    <C : MutableCollection<in R>> -> MutableList<SecureHash>

'txIds' @ [297:39] ==> val txIds: MutableList<SecureHash> defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'it' @ [297:48] ==> value-parameter it: StateRef defined in net.corda.testing.TestLedgerDSLInterpreter.verifies.<anonymous>[ValueParameterDescriptorImpl]

'txhash' @ [297:51] ==> public final val txhash: SecureHash defined in net.corda.core.contracts.StateRef[DeserializedPropertyDescriptor]

'DoubleSpentInputs' @ [298:27] ==> public constructor DoubleSpentInputs(ids: List<SecureHash>) defined in net.corda.testing.DoubleSpentInputs[ClassConstructorDescriptorImpl]

'txIds' @ [298:45] ==> val txIds: MutableList<SecureHash> defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'usedInputs' @ [300:17] ==> val usedInputs: MutableSet<StateRef> defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'addAll' @ [300:28] ==> public abstract fun addAll(elements: Collection<StateRef>): Boolean defined in kotlin.collections.MutableSet[DeserializedSimpleFunctionDescriptor]

'wtx' @ [300:35] ==> val wtx: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'inputs' @ [300:39] ==> public open val inputs: List<StateRef> defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'services' @ [301:17] ==> public final val services: ServiceHub defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'recordTransactions' @ [301:26] ==> public open fun recordTransactions(first: SignedTransaction, vararg remaining: SignedTransaction): Unit defined in net.corda.core.node.ServiceHub[DeserializedSimpleFunctionDescriptor]

'SignedTransaction' @ [301:45] ==> public constructor SignedTransaction(ctx: CoreTransaction, sigs: List<TransactionSignature>) defined in net.corda.core.transactions.SignedTransaction[DeserializedClassConstructorDescriptor]

'wtx' @ [301:63] ==> val wtx: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'listOf' @ [301:68] ==> public fun <T> listOf(element: TransactionSignature): List<TransactionSignature> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TransactionSignature

'NULL_SIGNATURE' @ [301:75] ==> public val NULL_SIGNATURE: TransactionSignature defined in net.corda.core.crypto.testing[DeserializedPropertyDescriptor]

'Token' @ [303:40] ==> internal object Token : EnforceVerifyOrFail defined in net.corda.testing.EnforceVerifyOrFail[FakeCallableDescriptorForObject]

'transactionWithLocations' @ [305:43] ==> private final val transactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'exception' @ [305:68] ==> val exception: TransactionVerificationException defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'txId' @ [305:78] ==> public final val txId: SecureHash defined in net.corda.core.contracts.TransactionVerificationException[DeserializedPropertyDescriptor]

'transactionWithLocation' @ [306:35] ==> val transactionWithLocation: TestLedgerDSLInterpreter.WireTransactionWithLocation? defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'label' @ [306:60] ==> public final val label: String? defined in net.corda.testing.TestLedgerDSLInterpreter.WireTransactionWithLocation[PropertyDescriptorImpl]

'transactionWithLocation' @ [306:69] ==> val transactionWithLocation: TestLedgerDSLInterpreter.WireTransactionWithLocation? defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'location' @ [306:94] ==> public final val location: String? defined in net.corda.testing.TestLedgerDSLInterpreter.WireTransactionWithLocation[PropertyDescriptorImpl]

'VerifiesFailed' @ [307:19] ==> public constructor VerifiesFailed(transactionName: String, cause: Throwable) defined in net.corda.testing.TestLedgerDSLInterpreter.VerifiesFailed[ClassConstructorDescriptorImpl]

'transactionName' @ [307:34] ==> val transactionName: String defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'exception' @ [307:51] ==> val exception: TransactionVerificationException defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'labelToOutputStateAndRefs' @ [312:27] ==> internal final val labelToOutputStateAndRefs: HashMap<String, StateAndRef<ContractState>> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'label' @ [312:53] ==> value-parameter label: String defined in net.corda.testing.TestLedgerDSLInterpreter.retrieveOutputStateAndRef[ValueParameterDescriptorImpl]

'if (stateAndRef == null) {
            throw IllegalArgumentException("State with label '$label' was not found")
        } else if (!clazz.isAssignableFrom(stateAndRef.state.data.javaClass)) {
            throw TypeMismatch(requested = clazz, actual = stateAndRef.state.data.javaClass)
        } else {
            @Suppress("UNCHECKED_CAST")
            return stateAndRef as StateAndRef<S>
        }' @ [313:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nothing, elseBranch: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nothing

'stateAndRef' @ [313:13] ==> val stateAndRef: StateAndRef<ContractState>? defined in net.corda.testing.TestLedgerDSLInterpreter.retrieveOutputStateAndRef[LocalVariableDescriptor]

'IllegalArgumentException' @ [314:19] ==> public final fun <init>(p0: (String..String?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'label' @ [314:64] ==> value-parameter label: String defined in net.corda.testing.TestLedgerDSLInterpreter.retrieveOutputStateAndRef[ValueParameterDescriptorImpl]

'if (!clazz.isAssignableFrom(stateAndRef.state.data.javaClass)) {
            throw TypeMismatch(requested = clazz, actual = stateAndRef.state.data.javaClass)
        } else {
            @Suppress("UNCHECKED_CAST")
            return stateAndRef as StateAndRef<S>
        }' @ [315:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nothing, elseBranch: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nothing

'!' @ [315:20] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'clazz' @ [315:21] ==> value-parameter clazz: Class<S> defined in net.corda.testing.TestLedgerDSLInterpreter.retrieveOutputStateAndRef[ValueParameterDescriptorImpl]

'isAssignableFrom' @ [315:27] ==> public open fun isAssignableFrom(p0: (Class<*>..Class<*>?)): Boolean defined in java.lang.Class[JavaMethodDescriptor]

'stateAndRef' @ [315:44] ==> val stateAndRef: StateAndRef<ContractState>? defined in net.corda.testing.TestLedgerDSLInterpreter.retrieveOutputStateAndRef[LocalVariableDescriptor]

'state' @ [315:56] ==> public final val state: TransactionState<ContractState> defined in net.corda.core.contracts.StateAndRef[DeserializedPropertyDescriptor]

'data' @ [315:62] ==> public final val data: ContractState defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'javaClass' @ [315:67] ==> public val <T : Any> ContractState.javaClass: Class<ContractState> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> ContractState

'TypeMismatch' @ [316:19] ==> public constructor TypeMismatch(requested: Class<*>, actual: Class<*>) defined in net.corda.testing.TestLedgerDSLInterpreter.TypeMismatch[ClassConstructorDescriptorImpl]

'clazz' @ [316:44] ==> value-parameter clazz: Class<S> defined in net.corda.testing.TestLedgerDSLInterpreter.retrieveOutputStateAndRef[ValueParameterDescriptorImpl]

'stateAndRef' @ [316:60] ==> val stateAndRef: StateAndRef<ContractState>? defined in net.corda.testing.TestLedgerDSLInterpreter.retrieveOutputStateAndRef[LocalVariableDescriptor]

'state' @ [316:72] ==> public final val state: TransactionState<ContractState> defined in net.corda.core.contracts.StateAndRef[DeserializedPropertyDescriptor]

'data' @ [316:78] ==> public final val data: ContractState defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'javaClass' @ [316:83] ==> public val <T : Any> ContractState.javaClass: Class<ContractState> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> ContractState

'Suppress' @ [318:13] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'stateAndRef' @ [319:20] ==> val stateAndRef: StateAndRef<ContractState>? defined in net.corda.testing.TestLedgerDSLInterpreter.retrieveOutputStateAndRef[LocalVariableDescriptor]

'transactionWithLocations' @ [323:61] ==> private final val transactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'values' @ [323:86] ==> public open val values: MutableCollection<TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in java.util.HashMap[JavaPropertyDescriptor]

'map' @ [323:93] ==> public inline fun <T, R> Iterable<TestLedgerDSLInterpreter.WireTransactionWithLocation>.map(transform: (TestLedgerDSLInterpreter.WireTransactionWithLocation) -> WireTransaction): List<WireTransaction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> WireTransactionWithLocation
    <R> -> WireTransaction

'it' @ [323:99] ==> value-parameter it: TestLedgerDSLInterpreter.WireTransactionWithLocation defined in net.corda.testing.TestLedgerDSLInterpreter.<get-transactionsToVerify>.<anonymous>[ValueParameterDescriptorImpl]

'transaction' @ [323:102] ==> public final val transaction: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.WireTransactionWithLocation[PropertyDescriptorImpl]

'nonVerifiedTransactionWithLocations' @ [324:63] ==> private final val nonVerifiedTransactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'values' @ [324:99] ==> public open val values: MutableCollection<TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in java.util.HashMap[JavaPropertyDescriptor]

'map' @ [324:106] ==> public inline fun <T, R> Iterable<TestLedgerDSLInterpreter.WireTransactionWithLocation>.map(transform: (TestLedgerDSLInterpreter.WireTransactionWithLocation) -> WireTransaction): List<WireTransaction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> WireTransactionWithLocation
    <R> -> WireTransaction

'it' @ [324:112] ==> value-parameter it: TestLedgerDSLInterpreter.WireTransactionWithLocation defined in net.corda.testing.TestLedgerDSLInterpreter.<get-transactionsUnverified>.<anonymous>[ValueParameterDescriptorImpl]

'transaction' @ [324:115] ==> public final val transaction: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.WireTransactionWithLocation[PropertyDescriptorImpl]

'transactionsToSign' @ [333:84] ==> value-parameter transactionsToSign: List<WireTransaction> defined in net.corda.testing.signAll[ValueParameterDescriptorImpl]

'map' @ [333:103] ==> public inline fun <T, R> Iterable<WireTransaction>.map(transform: (WireTransaction) -> SignedTransaction): List<SignedTransaction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> WireTransaction
    <R> -> SignedTransaction

'check' @ [334:5] ==> @InlineOnly public inline fun check(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'wtx' @ [334:11] ==> value-parameter wtx: WireTransaction defined in net.corda.testing.signAll.<anonymous>[ValueParameterDescriptorImpl]

'requiredSigningKeys' @ [334:15] ==> public final val requiredSigningKeys: Set<PublicKey> defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'isNotEmpty' @ [334:35] ==> @InlineOnly public inline fun <T> Collection<PublicKey>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PublicKey

'ArrayList' @ [335:22] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> TransactionSignature

'HashMap' @ [336:21] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> PublicKey
    <V : (Any..Any?)> -> KeyPair

'ALL_TEST_KEYS' @ [338:6] ==> public val ALL_TEST_KEYS: List<KeyPair> defined in net.corda.testing in file CoreTestUtils.kt[PropertyDescriptorImpl]

'extraKeys' @ [338:22] ==> value-parameter extraKeys: List<KeyPair> defined in net.corda.testing.signAll[ValueParameterDescriptorImpl]

'forEach' @ [338:33] ==> @HidesMembers public inline fun <T> Iterable<KeyPair>.forEach(action: (KeyPair) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KeyPair

'keyLookup' @ [339:9] ==> val keyLookup: HashMap<PublicKey, KeyPair> defined in net.corda.testing.signAll.<anonymous>[LocalVariableDescriptor]

'it' @ [339:19] ==> value-parameter it: KeyPair defined in net.corda.testing.signAll.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'public' @ [339:22] ==> public final val KeyPair.public: (PublicKey..PublicKey?)[MyPropertyDescriptor]

'it' @ [339:32] ==> value-parameter it: KeyPair defined in net.corda.testing.signAll.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'wtx' @ [341:5] ==> value-parameter wtx: WireTransaction defined in net.corda.testing.signAll.<anonymous>[ValueParameterDescriptorImpl]

'requiredSigningKeys' @ [341:9] ==> public final val requiredSigningKeys: Set<PublicKey> defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'expandedCompositeKeys' @ [341:29] ==> public val Iterable<PublicKey>.expandedCompositeKeys: Set<PublicKey> defined in net.corda.core.crypto.composite[DeserializedPropertyDescriptor]

'forEach' @ [341:51] ==> @HidesMembers public inline fun <T> Iterable<PublicKey>.forEach(action: (PublicKey) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PublicKey

'keyLookup' @ [342:19] ==> val keyLookup: HashMap<PublicKey, KeyPair> defined in net.corda.testing.signAll.<anonymous>[LocalVariableDescriptor]

'it' @ [342:29] ==> value-parameter it: PublicKey defined in net.corda.testing.signAll.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'IllegalArgumentException' @ [342:42] ==> public final fun <init>(p0: (String..String?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'it' @ [342:95] ==> value-parameter it: PublicKey defined in net.corda.testing.signAll.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'toStringShort' @ [342:98] ==> public fun PublicKey.toStringShort(): String defined in net.corda.core.crypto[DeserializedSimpleFunctionDescriptor]

'signatures' @ [343:9] ==> val signatures: ArrayList<TransactionSignature> defined in net.corda.testing.signAll.<anonymous>[LocalVariableDescriptor]

'key' @ [343:23] ==> val key: KeyPair defined in net.corda.testing.signAll.<anonymous>.<anonymous>[LocalVariableDescriptor]

'sign' @ [343:27] ==> public fun KeyPair.sign(signableData: SignableData): TransactionSignature defined in net.corda.core.crypto[DeserializedSimpleFunctionDescriptor]

'SignableData' @ [343:32] ==> public constructor SignableData(txId: SecureHash, signatureMetadata: SignatureMetadata) defined in net.corda.core.crypto.SignableData[DeserializedClassConstructorDescriptor]

'wtx' @ [343:45] ==> value-parameter wtx: WireTransaction defined in net.corda.testing.signAll.<anonymous>[ValueParameterDescriptorImpl]

'id' @ [343:49] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'SignatureMetadata' @ [343:53] ==> public constructor SignatureMetadata(platformVersion: Int, schemeNumberID: Int) defined in net.corda.core.crypto.SignatureMetadata[DeserializedClassConstructorDescriptor]

'findSignatureScheme' @ [343:81] ==> @JvmStatic public final fun findSignatureScheme(key: PublicKey): SignatureScheme defined in net.corda.core.crypto.Crypto[DeserializedSimpleFunctionDescriptor]

'it' @ [343:101] ==> value-parameter it: PublicKey defined in net.corda.testing.signAll.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'schemeNumberID' @ [343:105] ==> public final val schemeNumberID: Int defined in net.corda.core.crypto.SignatureScheme[DeserializedPropertyDescriptor]

'SignedTransaction' @ [345:5] ==> public constructor SignedTransaction(ctx: CoreTransaction, sigs: List<TransactionSignature>) defined in net.corda.core.transactions.SignedTransaction[DeserializedClassConstructorDescriptor]

'wtx' @ [345:23] ==> value-parameter wtx: WireTransaction defined in net.corda.testing.signAll.<anonymous>[ValueParameterDescriptorImpl]

'signatures' @ [345:28] ==> val signatures: ArrayList<TransactionSignature> defined in net.corda.testing.signAll.<anonymous>[LocalVariableDescriptor]

'signAll' @ [354:38] ==> public fun signAll(transactionsToSign: List<WireTransaction>, extraKeys: List<KeyPair>): List<SignedTransaction> defined in net.corda.testing in file TestDSL.kt[SimpleFunctionDescriptorImpl]

'this' @ [354:46] ==> <this> defined in net.corda.testing.signAll[ReceiverParameterDescriptorImpl]

'interpreter' @ [354:51] ==> public final val interpreter: TestLedgerDSLInterpreter defined in net.corda.testing.LedgerDSL[PropertyDescriptorImpl]

'wireTransactions' @ [354:63] ==> public final val wireTransactions: List<WireTransaction> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'extraKeys' @ [354:81] ==> value-parameter vararg extraKeys: KeyPair defined in net.corda.testing.signAll[ValueParameterDescriptorImpl]

'toList' @ [354:91] ==> public fun <T> Array<out KeyPair>.toList(): List<KeyPair> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KeyPair

