'Deprecated' @ [47:1] ==> public constructor Deprecated(message: String, replaceWith: ReplaceWith = ..., level: DeprecationLevel = ...) defined in kotlin.Deprecated[DeserializedClassConstructorDescriptor]

'ReplaceWith' @ [49:23] ==> public constructor ReplaceWith(expression: String, vararg imports: String) defined in kotlin.ReplaceWith[DeserializedClassConstructorDescriptor]

'ERROR' @ [50:34] ==> enum entry ERROR defined in kotlin.DeprecationLevel[FakeCallableDescriptorForObject]

'Suppress' @ [51:1] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'Deprecated' @ [56:1] ==> public constructor Deprecated(message: String, replaceWith: ReplaceWith = ..., level: DeprecationLevel = ...) defined in kotlin.Deprecated[DeserializedClassConstructorDescriptor]

'ReplaceWith' @ [58:23] ==> public constructor ReplaceWith(expression: String, vararg imports: String) defined in kotlin.ReplaceWith[DeserializedClassConstructorDescriptor]

'ERROR' @ [59:34] ==> enum entry ERROR defined in kotlin.DeprecationLevel[FakeCallableDescriptorForObject]

'Suppress' @ [60:1] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'Deprecated' @ [65:1] ==> public constructor Deprecated(message: String, replaceWith: ReplaceWith = ..., level: DeprecationLevel = ...) defined in kotlin.Deprecated[DeserializedClassConstructorDescriptor]

'ReplaceWith' @ [67:23] ==> public constructor ReplaceWith(expression: String, vararg imports: String) defined in kotlin.ReplaceWith[DeserializedClassConstructorDescriptor]

'ERROR' @ [68:34] ==> enum entry ERROR defined in kotlin.DeprecationLevel[FakeCallableDescriptorForObject]

'Suppress' @ [69:1] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'EnforceVerifyOrFail' @ [81:29] ==> private constructor EnforceVerifyOrFail() defined in net.corda.testing.EnforceVerifyOrFail[ClassConstructorDescriptorImpl]

'Exception' @ [84:45] ==> public final fun <init>(p0: (String..String?)): Exception /* = Exception */ defined in kotlin.Exception[TypeAliasConstructorDescriptorImpl]

'label' @ [84:71] ==> value-parameter label: String defined in net.corda.testing.DuplicateOutputLabel.<init>[ValueParameterDescriptorImpl]

'Exception' @ [85:50] ==> public final fun <init>(p0: (String..String?)): Exception /* = Exception */ defined in kotlin.Exception[TypeAliasConstructorDescriptorImpl]

'ids' @ [85:128] ==> value-parameter ids: List<SecureHash> defined in net.corda.testing.DoubleSpentInputs.<init>[ValueParameterDescriptorImpl]

'Exception' @ [86:65] ==> public final fun <init>(p0: (String..String?)): Exception /* = Exception */ defined in kotlin.Exception[TypeAliasConstructorDescriptorImpl]

'attachmentId' @ [86:96] ==> value-parameter attachmentId: SecureHash defined in net.corda.testing.AttachmentResolutionException.<init>[ValueParameterDescriptorImpl]

'ledgerInterpreter' @ [96:53] ==> value-parameter ledgerInterpreter: TestLedgerDSLInterpreter defined in net.corda.testing.TestTransactionDSLInterpreter.<init>[ValueParameterDescriptorImpl]

'this' @ [101:9] ==> private constructor TestTransactionDSLInterpreter(ledgerInterpreter: TestLedgerDSLInterpreter, transactionBuilder: TransactionBuilder, labelToIndexMap: HashMap<String, Int>) defined in net.corda.testing.TestTransactionDSLInterpreter[ClassConstructorDescriptorImpl]

'ledgerInterpreter' @ [101:14] ==> value-parameter ledgerInterpreter: TestLedgerDSLInterpreter defined in net.corda.testing.TestTransactionDSLInterpreter.<init>[ValueParameterDescriptorImpl]

'transactionBuilder' @ [101:33] ==> value-parameter transactionBuilder: TransactionBuilder defined in net.corda.testing.TestTransactionDSLInterpreter.<init>[ValueParameterDescriptorImpl]

'HashMap' @ [101:53] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> String
    <V : (Any..Any?)> -> Int

'ledgerInterpreter' @ [103:43] ==> public open val ledgerInterpreter: TestLedgerDSLInterpreter defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'services' @ [103:61] ==> public final val services: ServiceHub defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'ledgerInterpreter' @ [104:54] ==> public open val ledgerInterpreter: TestLedgerDSLInterpreter defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'resolveStateRef' @ [104:72] ==> internal final inline fun <reified S : ContractState> resolveStateRef(stateRef: StateRef): TransactionState<ContractState> defined in net.corda.testing.TestLedgerDSLInterpreter[SimpleFunctionDescriptorImpl]
Inferred types:
    <reified S : ContractState> -> ContractState

'stateRef' @ [104:103] ==> value-parameter stateRef: StateRef defined in net.corda.testing.TestTransactionDSLInterpreter.services.<no name provided>.loadState[ValueParameterDescriptorImpl]

'TestTransactionDSLInterpreter' @ [108:13] ==> private constructor TestTransactionDSLInterpreter(ledgerInterpreter: TestLedgerDSLInterpreter, transactionBuilder: TransactionBuilder, labelToIndexMap: HashMap<String, Int>) defined in net.corda.testing.TestTransactionDSLInterpreter[ClassConstructorDescriptorImpl]

'ledgerInterpreter' @ [109:41] ==> public open val ledgerInterpreter: TestLedgerDSLInterpreter defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'transactionBuilder' @ [110:42] ==> public final val transactionBuilder: TransactionBuilder defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'copy' @ [110:61] ==> public final fun copy(): TransactionBuilder defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'HashMap' @ [111:39] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>(p0: (MutableMap<out (String..String?), out (Int..Int?)>..Map<out (String..String?), (Int..Int?)>?)) defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> String
    <V : (Any..Any?)> -> Int

'labelToIndexMap' @ [111:47] ==> internal final val labelToIndexMap: HashMap<String, Int> defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'transactionBuilder' @ [114:40] ==> public final val transactionBuilder: TransactionBuilder defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'toWireTransaction' @ [114:59] ==> public final fun toWireTransaction(): WireTransaction defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'ledgerInterpreter' @ [117:21] ==> public open val ledgerInterpreter: TestLedgerDSLInterpreter defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'resolveStateRef' @ [117:39] ==> internal final inline fun <reified S : ContractState> resolveStateRef(stateRef: StateRef): TransactionState<ContractState> defined in net.corda.testing.TestLedgerDSLInterpreter[SimpleFunctionDescriptorImpl]
Inferred types:
    <reified S : ContractState> -> ContractState

'stateRef' @ [117:70] ==> value-parameter stateRef: StateRef defined in net.corda.testing.TestTransactionDSLInterpreter.input[ValueParameterDescriptorImpl]

'transactionBuilder' @ [118:9] ==> public final val transactionBuilder: TransactionBuilder defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'addInputState' @ [118:28] ==> public open fun addInputState(stateAndRef: StateAndRef<*>): TransactionBuilder defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'StateAndRef' @ [118:42] ==> public constructor StateAndRef<out T : ContractState>(state: TransactionState<ContractState>, ref: StateRef) defined in net.corda.core.contracts.StateAndRef[DeserializedClassConstructorDescriptor]
Inferred types:
    <out T : ContractState> -> ContractState

'state' @ [118:54] ==> val state: TransactionState<ContractState> defined in net.corda.testing.TestTransactionDSLInterpreter.input[LocalVariableDescriptor]

'stateRef' @ [118:61] ==> value-parameter stateRef: StateRef defined in net.corda.testing.TestTransactionDSLInterpreter.input[ValueParameterDescriptorImpl]

'transactionBuilder' @ [122:9] ==> public final val transactionBuilder: TransactionBuilder defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'addOutputState' @ [122:28] ==> @JvmOverloads public final fun addOutputState(state: ContractState, notary: Party, encumbrance: Int? = ...): TransactionBuilder defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'contractState' @ [122:43] ==> value-parameter contractState: ContractState defined in net.corda.testing.TestTransactionDSLInterpreter._output[ValueParameterDescriptorImpl]

'notary' @ [122:58] ==> value-parameter notary: Party defined in net.corda.testing.TestTransactionDSLInterpreter._output[ValueParameterDescriptorImpl]

'encumbrance' @ [122:66] ==> value-parameter encumbrance: Int? defined in net.corda.testing.TestTransactionDSLInterpreter._output[ValueParameterDescriptorImpl]

'label' @ [123:13] ==> value-parameter label: String? defined in net.corda.testing.TestTransactionDSLInterpreter._output[ValueParameterDescriptorImpl]

'if (label in labelToIndexMap) {
                throw DuplicateOutputLabel(label)
            } else {
                val outputIndex = transactionBuilder.outputStates().size - 1
                labelToIndexMap[label] = outputIndex
            }' @ [124:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'label' @ [124:17] ==> value-parameter label: String? defined in net.corda.testing.TestTransactionDSLInterpreter._output[ValueParameterDescriptorImpl]

'labelToIndexMap' @ [124:26] ==> internal final val labelToIndexMap: HashMap<String, Int> defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'DuplicateOutputLabel' @ [125:23] ==> public constructor DuplicateOutputLabel(label: String) defined in net.corda.testing.DuplicateOutputLabel[ClassConstructorDescriptorImpl]

'label' @ [125:44] ==> value-parameter label: String? defined in net.corda.testing.TestTransactionDSLInterpreter._output[ValueParameterDescriptorImpl]

'transactionBuilder' @ [127:35] ==> public final val transactionBuilder: TransactionBuilder defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'outputStates' @ [127:54] ==> public final fun outputStates(): List<TransactionState<*>> defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'size' @ [127:69] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'labelToIndexMap' @ [128:17] ==> internal final val labelToIndexMap: HashMap<String, Int> defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'label' @ [128:33] ==> value-parameter label: String? defined in net.corda.testing.TestTransactionDSLInterpreter._output[ValueParameterDescriptorImpl]

'outputIndex' @ [128:42] ==> val outputIndex: Int defined in net.corda.testing.TestTransactionDSLInterpreter._output[LocalVariableDescriptor]

'transactionBuilder' @ [134:9] ==> public final val transactionBuilder: TransactionBuilder defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'addAttachment' @ [134:28] ==> public final fun addAttachment(attachmentId: SecureHash): TransactionBuilder defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'attachmentId' @ [134:42] ==> value-parameter attachmentId: SecureHash defined in net.corda.testing.TestTransactionDSLInterpreter.attachment[ValueParameterDescriptorImpl]

'Command' @ [138:23] ==> public constructor Command<T : CommandData>(value: CommandData, signers: List<PublicKey>) defined in net.corda.core.contracts.Command[DeserializedClassConstructorDescriptor]
Inferred types:
    <T : CommandData> -> CommandData

'commandData' @ [138:31] ==> value-parameter commandData: CommandData defined in net.corda.testing.TestTransactionDSLInterpreter._command[ValueParameterDescriptorImpl]

'signers' @ [138:44] ==> value-parameter signers: List<PublicKey> defined in net.corda.testing.TestTransactionDSLInterpreter._command[ValueParameterDescriptorImpl]

'transactionBuilder' @ [139:9] ==> public final val transactionBuilder: TransactionBuilder defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'addCommand' @ [139:28] ==> public final fun addCommand(arg: Command<*>): TransactionBuilder defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'command' @ [139:39] ==> val command: Command<CommandData> defined in net.corda.testing.TestTransactionDSLInterpreter._command[LocalVariableDescriptor]

'transactionBuilder' @ [145:9] ==> public final val transactionBuilder: TransactionBuilder defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'copy' @ [145:28] ==> public final fun copy(): TransactionBuilder defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'apply' @ [145:35] ==> @InlineOnly public inline fun <T> TransactionBuilder.apply(block: TransactionBuilder.() -> Unit): TransactionBuilder defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TransactionBuilder

'toWireTransaction' @ [146:13] ==> public final fun toWireTransaction(): WireTransaction defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'toLedgerTransaction' @ [146:33] ==> public final fun toLedgerTransaction(services: ServicesForResolution): LedgerTransaction defined in net.corda.core.transactions.WireTransaction[DeserializedSimpleFunctionDescriptor]

'services' @ [146:53] ==> public final val services: ServiceHub defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'verify' @ [146:63] ==> public final fun verify(): Unit defined in net.corda.core.transactions.LedgerTransaction[DeserializedSimpleFunctionDescriptor]

'Token' @ [148:36] ==> internal object Token : EnforceVerifyOrFail defined in net.corda.testing.EnforceVerifyOrFail[FakeCallableDescriptorForObject]

'transactionBuilder' @ [152:9] ==> public final val transactionBuilder: TransactionBuilder defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'setTimeWindow' @ [152:28] ==> public final fun setTimeWindow(timeWindow: TimeWindow): TransactionBuilder defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'data' @ [152:42] ==> value-parameter data: TimeWindow defined in net.corda.testing.TestTransactionDSLInterpreter.timeWindow[ValueParameterDescriptorImpl]

'invoke' @ [157:9] ==> public abstract operator fun invoke(p1: TransactionDSL<TransactionDSLInterpreter>): EnforceVerifyOrFail defined in kotlin.Function1[FunctionInvokeDescriptor]

'TransactionDSL' @ [157:13] ==> public constructor TransactionDSL<out T : TransactionDSLInterpreter>(interpreter: TestTransactionDSLInterpreter) defined in net.corda.testing.TransactionDSL[ClassConstructorDescriptorImpl]
Inferred types:
    <out T : TransactionDSLInterpreter> -> TestTransactionDSLInterpreter

'copy' @ [157:28] ==> private final fun copy(): TestTransactionDSLInterpreter defined in net.corda.testing.TestTransactionDSLInterpreter[SimpleFunctionDescriptorImpl]

'HashMap' @ [162:95] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> String
    <V : (Any..Any?)> -> StateAndRef<ContractState>

'LinkedHashMap' @ [163:98] ==> public constructor LinkedHashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.LinkedHashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> SecureHash
    <V : (Any..Any?)> -> WireTransactionWithLocation

'HashMap' @ [164:109] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> SecureHash
    <V : (Any..Any?)> -> WireTransactionWithLocation

'transactionWithLocations' @ [166:57] ==> private final val transactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'values' @ [166:82] ==> public open val values: MutableCollection<TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in java.util.HashMap[JavaPropertyDescriptor]

'map' @ [166:89] ==> public inline fun <T, R> Iterable<TestLedgerDSLInterpreter.WireTransactionWithLocation>.map(transform: (TestLedgerDSLInterpreter.WireTransactionWithLocation) -> WireTransaction): List<WireTransaction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> WireTransactionWithLocation
    <R> -> WireTransaction

'it' @ [166:95] ==> value-parameter it: TestLedgerDSLInterpreter.WireTransactionWithLocation defined in net.corda.testing.TestLedgerDSLInterpreter.<get-wireTransactions>.<anonymous>[ValueParameterDescriptorImpl]

'transaction' @ [166:98] ==> public final val transaction: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.WireTransactionWithLocation[PropertyDescriptorImpl]

'this' @ [169:41] ==> private constructor TestLedgerDSLInterpreter(services: ServiceHub, labelToOutputStateAndRefs: HashMap<String, StateAndRef<ContractState>> = ..., transactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> = ..., nonVerifiedTransactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> = ...) defined in net.corda.testing.TestLedgerDSLInterpreter[ClassConstructorDescriptorImpl]

'services' @ [169:46] ==> value-parameter services: ServiceHub defined in net.corda.testing.TestLedgerDSLInterpreter.<init>[ValueParameterDescriptorImpl]

'HashMap' @ [169:84] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> String
    <V : (Any..Any?)> -> StateAndRef<ContractState>

'currentThread' @ [173:37] ==> public open fun currentThread(): (Thread..Thread?) defined in java.lang.Thread[JavaMethodDescriptor]

'stackTrace' @ [173:53] ==> public final val Thread.stackTrace: (Array<(StackTraceElement..StackTraceElement?)>..Array<out (StackTraceElement..StackTraceElement?)>?)[MyPropertyDescriptor]

'..' @ [174:23] ==> public final operator fun rangeTo(other: Int): IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'stackTrace' @ [174:26] ==> val stackTrace: (Array<(StackTraceElement..StackTraceElement?)>..Array<out (StackTraceElement..StackTraceElement?)>?) defined in net.corda.testing.TestLedgerDSLInterpreter.Companion.getCallerLocation[LocalVariableDescriptor]

'size' @ [174:37] ==> public final val size: Int defined in kotlin.Array[DeserializedPropertyDescriptor]

'stackTrace' @ [175:41] ==> val stackTrace: (Array<(StackTraceElement..StackTraceElement?)>..Array<out (StackTraceElement..StackTraceElement?)>?) defined in net.corda.testing.TestLedgerDSLInterpreter.Companion.getCallerLocation[LocalVariableDescriptor]

'i' @ [175:52] ==> val i: Int defined in net.corda.testing.TestLedgerDSLInterpreter.Companion.getCallerLocation[LocalVariableDescriptor]

'!' @ [176:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'stackTraceElement' @ [176:22] ==> val stackTraceElement: (StackTraceElement..StackTraceElement?) defined in net.corda.testing.TestLedgerDSLInterpreter.Companion.getCallerLocation[LocalVariableDescriptor]

'fileName' @ [176:40] ==> public final val StackTraceElement.fileName: (String..String?)[MyPropertyDescriptor]

'contains' @ [176:49] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'stackTraceElement' @ [177:28] ==> val stackTraceElement: (StackTraceElement..StackTraceElement?) defined in net.corda.testing.TestLedgerDSLInterpreter.Companion.getCallerLocation[LocalVariableDescriptor]

'toString' @ [177:46] ==> public open fun toString(): String defined in java.lang.StackTraceElement[JavaMethodDescriptor]

'Exception' @ [191:13] ==> public final fun <init>(p0: (String..String?), p1: (Throwable..Throwable?)): Exception /* = Exception */ defined in kotlin.Exception[TypeAliasConstructorDescriptorImpl]

'transactionName' @ [191:38] ==> value-parameter transactionName: String defined in net.corda.testing.TestLedgerDSLInterpreter.VerifiesFailed.<init>[ValueParameterDescriptorImpl]

'cause' @ [191:71] ==> value-parameter cause: Throwable defined in net.corda.testing.TestLedgerDSLInterpreter.VerifiesFailed.<init>[ValueParameterDescriptorImpl]

'cause' @ [191:79] ==> value-parameter cause: Throwable defined in net.corda.testing.TestLedgerDSLInterpreter.VerifiesFailed.<init>[ValueParameterDescriptorImpl]

'Exception' @ [194:13] ==> public final fun <init>(p0: (String..String?)): Exception /* = Exception */ defined in kotlin.Exception[TypeAliasConstructorDescriptorImpl]

'actual' @ [194:37] ==> value-parameter actual: Class<*> defined in net.corda.testing.TestLedgerDSLInterpreter.TypeMismatch.<init>[ValueParameterDescriptorImpl]

'requested' @ [194:80] ==> value-parameter requested: Class<*> defined in net.corda.testing.TestLedgerDSLInterpreter.TypeMismatch.<init>[ValueParameterDescriptorImpl]

'TestLedgerDSLInterpreter' @ [197:13] ==> private constructor TestLedgerDSLInterpreter(services: ServiceHub, labelToOutputStateAndRefs: HashMap<String, StateAndRef<ContractState>> = ..., transactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> = ..., nonVerifiedTransactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> = ...) defined in net.corda.testing.TestLedgerDSLInterpreter[ClassConstructorDescriptorImpl]

'services' @ [198:21] ==> public final val services: ServiceHub defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'HashMap' @ [199:49] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>(p0: (MutableMap<out (String..String?), out (StateAndRef<ContractState>..StateAndRef<ContractState>?)>..Map<out (String..String?), (StateAndRef<ContractState>..StateAndRef<ContractState>?)>?)) defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> String
    <V : (Any..Any?)> -> StateAndRef<ContractState>

'labelToOutputStateAndRefs' @ [199:57] ==> internal final val labelToOutputStateAndRefs: HashMap<String, StateAndRef<ContractState>> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'HashMap' @ [200:48] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>(p0: (MutableMap<out (SecureHash..SecureHash?), out (TestLedgerDSLInterpreter.WireTransactionWithLocation..TestLedgerDSLInterpreter.WireTransactionWithLocation?)>..Map<out (SecureHash..SecureHash?), (TestLedgerDSLInterpreter.WireTransactionWithLocation..TestLedgerDSLInterpreter.WireTransactionWithLocation?)>?)) defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> SecureHash
    <V : (Any..Any?)> -> WireTransactionWithLocation

'transactionWithLocations' @ [200:56] ==> private final val transactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'HashMap' @ [201:59] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>(p0: (MutableMap<out (SecureHash..SecureHash?), out (TestLedgerDSLInterpreter.WireTransactionWithLocation..TestLedgerDSLInterpreter.WireTransactionWithLocation?)>..Map<out (SecureHash..SecureHash?), (TestLedgerDSLInterpreter.WireTransactionWithLocation..TestLedgerDSLInterpreter.WireTransactionWithLocation?)>?)) defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> SecureHash
    <V : (Any..Any?)> -> WireTransactionWithLocation

'nonVerifiedTransactionWithLocations' @ [201:67] ==> private final val nonVerifiedTransactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'transactionWithLocations' @ [206:17] ==> private final val transactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'stateRef' @ [206:42] ==> value-parameter stateRef: StateRef defined in net.corda.testing.TestLedgerDSLInterpreter.resolveStateRef[ValueParameterDescriptorImpl]

'txhash' @ [206:51] ==> public final val txhash: SecureHash defined in net.corda.core.contracts.StateRef[DeserializedPropertyDescriptor]

'nonVerifiedTransactionWithLocations' @ [207:25] ==> private final val nonVerifiedTransactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'stateRef' @ [207:61] ==> value-parameter stateRef: StateRef defined in net.corda.testing.TestLedgerDSLInterpreter.resolveStateRef[ValueParameterDescriptorImpl]

'txhash' @ [207:70] ==> public final val txhash: SecureHash defined in net.corda.core.contracts.StateRef[DeserializedPropertyDescriptor]

'TransactionResolutionException' @ [208:31] ==> public constructor TransactionResolutionException(hash: SecureHash) defined in net.corda.core.contracts.TransactionResolutionException[DeserializedClassConstructorDescriptor]

'stateRef' @ [208:62] ==> value-parameter stateRef: StateRef defined in net.corda.testing.TestLedgerDSLInterpreter.resolveStateRef[ValueParameterDescriptorImpl]

'txhash' @ [208:71] ==> public final val txhash: SecureHash defined in net.corda.core.contracts.StateRef[DeserializedPropertyDescriptor]

'transactionWithLocation' @ [209:22] ==> val transactionWithLocation: TestLedgerDSLInterpreter.WireTransactionWithLocation defined in net.corda.testing.TestLedgerDSLInterpreter.resolveStateRef[LocalVariableDescriptor]

'transaction' @ [209:46] ==> public final val transaction: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.WireTransactionWithLocation[PropertyDescriptorImpl]

'outputs' @ [209:58] ==> public open val outputs: List<TransactionState<ContractState>> defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'stateRef' @ [209:66] ==> value-parameter stateRef: StateRef defined in net.corda.testing.TestLedgerDSLInterpreter.resolveStateRef[ValueParameterDescriptorImpl]

'index' @ [209:75] ==> public final val index: Int defined in net.corda.core.contracts.StateRef[DeserializedPropertyDescriptor]

'Suppress' @ [210:9] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'if (S::class.java.isAssignableFrom(output.data.javaClass))  {
            output as TransactionState<S>
        } else {
            throw TypeMismatch(requested = S::class.java, actual = output.data.javaClass)
        }' @ [211:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: TransactionState<S>, elseBranch: TransactionState<S>): TransactionState<S>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> TransactionState<S>

'java' @ [211:29] ==> public val <T> KClass<S>.java: Class<S> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> S

'isAssignableFrom' @ [211:34] ==> public open fun isAssignableFrom(p0: (Class<*>..Class<*>?)): Boolean defined in java.lang.Class[JavaMethodDescriptor]

'output' @ [211:51] ==> val output: TransactionState<ContractState> defined in net.corda.testing.TestLedgerDSLInterpreter.resolveStateRef[LocalVariableDescriptor]

'data' @ [211:58] ==> public final val data: ContractState defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'javaClass' @ [211:63] ==> public val <T : Any> ContractState.javaClass: Class<ContractState> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> ContractState

'output' @ [212:13] ==> val output: TransactionState<ContractState> defined in net.corda.testing.TestLedgerDSLInterpreter.resolveStateRef[LocalVariableDescriptor]

'TypeMismatch' @ [214:19] ==> public constructor TypeMismatch(requested: Class<*>, actual: Class<*>) defined in net.corda.testing.TestLedgerDSLInterpreter.TypeMismatch[ClassConstructorDescriptorImpl]

'java' @ [214:53] ==> public val <T> KClass<S>.java: Class<S> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> S

'output' @ [214:68] ==> val output: TransactionState<ContractState> defined in net.corda.testing.TestLedgerDSLInterpreter.resolveStateRef[LocalVariableDescriptor]

'data' @ [214:75] ==> public final val data: ContractState defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'javaClass' @ [214:80] ==> public val <T : Any> ContractState.javaClass: Class<ContractState> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> ContractState

'services' @ [219:16] ==> public final val services: ServiceHub defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'attachments' @ [219:25] ==> public abstract val attachments: AttachmentStorage defined in net.corda.core.node.ServiceHub[DeserializedPropertyDescriptor]

'openAttachment' @ [219:37] ==> public abstract fun openAttachment(id: SecureHash): Attachment? defined in net.corda.core.node.services.AttachmentStorage[DeserializedSimpleFunctionDescriptor]

'attachmentId' @ [219:52] ==> value-parameter attachmentId: SecureHash defined in net.corda.testing.TestLedgerDSLInterpreter.resolveAttachment[ValueParameterDescriptorImpl]

'AttachmentResolutionException' @ [219:75] ==> public constructor AttachmentResolutionException(attachmentId: SecureHash) defined in net.corda.testing.AttachmentResolutionException[ClassConstructorDescriptorImpl]

'attachmentId' @ [219:105] ==> value-parameter attachmentId: SecureHash defined in net.corda.testing.TestLedgerDSLInterpreter.resolveAttachment[ValueParameterDescriptorImpl]

'TestTransactionDSLInterpreter' @ [226:38] ==> public constructor TestTransactionDSLInterpreter(ledgerInterpreter: TestLedgerDSLInterpreter, transactionBuilder: TransactionBuilder) defined in net.corda.testing.TestTransactionDSLInterpreter[ClassConstructorDescriptorImpl]

'this' @ [226:68] ==> <this> defined in net.corda.testing.TestLedgerDSLInterpreter[LazyClassReceiverParameterDescriptor]

'transactionBuilder' @ [226:74] ==> value-parameter transactionBuilder: TransactionBuilder defined in net.corda.testing.TestLedgerDSLInterpreter.interpretTransactionDsl[ValueParameterDescriptorImpl]

'invoke' @ [227:9] ==> public abstract operator fun invoke(p1: TransactionDSL<TestTransactionDSLInterpreter>): R defined in kotlin.Function1[FunctionInvokeDescriptor]

'TransactionDSL' @ [227:13] ==> public constructor TransactionDSL<out T : TransactionDSLInterpreter>(interpreter: TestTransactionDSLInterpreter) defined in net.corda.testing.TransactionDSL[ClassConstructorDescriptorImpl]
Inferred types:
    <out T : TransactionDSLInterpreter> -> TestTransactionDSLInterpreter

'transactionInterpreter' @ [227:28] ==> val transactionInterpreter: TestTransactionDSLInterpreter defined in net.corda.testing.TestLedgerDSLInterpreter.interpretTransactionDsl[LocalVariableDescriptor]

'transactionInterpreter' @ [228:16] ==> val transactionInterpreter: TestTransactionDSLInterpreter defined in net.corda.testing.TestLedgerDSLInterpreter.interpretTransactionDsl[LocalVariableDescriptor]

'transactionWithLocations' @ [232:39] ==> private final val transactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'transactionHash' @ [232:64] ==> value-parameter transactionHash: SecureHash defined in net.corda.testing.TestLedgerDSLInterpreter.transactionName[ValueParameterDescriptorImpl]

'if (transactionWithLocation != null) {
            transactionWithLocation.label ?: "TX[${transactionWithLocation.location}]"
        } else {
            null
        }' @ [233:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String?, elseBranch: String?): String?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String?

'transactionWithLocation' @ [233:20] ==> val transactionWithLocation: TestLedgerDSLInterpreter.WireTransactionWithLocation? defined in net.corda.testing.TestLedgerDSLInterpreter.transactionName[LocalVariableDescriptor]

'transactionWithLocation' @ [234:13] ==> val transactionWithLocation: TestLedgerDSLInterpreter.WireTransactionWithLocation? defined in net.corda.testing.TestLedgerDSLInterpreter.transactionName[LocalVariableDescriptor]

'label' @ [234:37] ==> public final val label: String? defined in net.corda.testing.TestLedgerDSLInterpreter.WireTransactionWithLocation[PropertyDescriptorImpl]

'transactionWithLocation' @ [234:52] ==> val transactionWithLocation: TestLedgerDSLInterpreter.WireTransactionWithLocation? defined in net.corda.testing.TestLedgerDSLInterpreter.transactionName[LocalVariableDescriptor]

'location' @ [234:76] ==> public final val location: String? defined in net.corda.testing.TestLedgerDSLInterpreter.WireTransactionWithLocation[PropertyDescriptorImpl]

'labelToOutputStateAndRefs' @ [241:13] ==> internal final val labelToOutputStateAndRefs: HashMap<String, StateAndRef<ContractState>> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'filter' @ [241:39] ==> public inline fun <K, V> Map<out String, StateAndRef<ContractState>>.filter(predicate: (Map.Entry<String, StateAndRef<ContractState>>) -> Boolean): Map<String, StateAndRef<ContractState>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> String
    <V> -> StateAndRef<ContractState>

'it' @ [241:48] ==> value-parameter it: Map.Entry<String, StateAndRef<ContractState>> defined in net.corda.testing.TestLedgerDSLInterpreter.outputToLabel.<anonymous>[ValueParameterDescriptorImpl]

'value' @ [241:51] ==> public abstract val value: StateAndRef<ContractState> defined in kotlin.collections.Map.Entry[DeserializedPropertyDescriptor]

'state' @ [241:57] ==> public final val state: TransactionState<ContractState> defined in net.corda.core.contracts.StateAndRef[DeserializedPropertyDescriptor]

'data' @ [241:63] ==> public final val data: ContractState defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'state' @ [241:71] ==> value-parameter state: ContractState defined in net.corda.testing.TestLedgerDSLInterpreter.outputToLabel[ValueParameterDescriptorImpl]

'keys' @ [241:79] ==> public abstract val keys: Set<String> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'firstOrNull' @ [241:84] ==> public fun <T> Iterable<String>.firstOrNull(): String? defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'HashMap' @ [247:80] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> SecureHash
    <V : (Any..Any?)> -> WireTransactionWithLocation

'getCallerLocation' @ [249:35] ==> private final fun getCallerLocation(): String? defined in net.corda.testing.TestLedgerDSLInterpreter.Companion[SimpleFunctionDescriptorImpl]

'interpretTransactionDsl' @ [250:38] ==> private final fun <R> interpretTransactionDsl(transactionBuilder: TransactionBuilder, dsl: TransactionDSL<TestTransactionDSLInterpreter>.() -> R): TestTransactionDSLInterpreter defined in net.corda.testing.TestLedgerDSLInterpreter[SimpleFunctionDescriptorImpl]
Inferred types:
    <R> -> R

'transactionBuilder' @ [250:62] ==> value-parameter transactionBuilder: TransactionBuilder defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap[ValueParameterDescriptorImpl]

'dsl' @ [250:82] ==> value-parameter dsl: TransactionDSL<TestTransactionDSLInterpreter>.() -> R defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap[ValueParameterDescriptorImpl]

'transactionInterpreter' @ [252:31] ==> val transactionInterpreter: TestTransactionDSLInterpreter defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap[LocalVariableDescriptor]

'toWireTransaction' @ [252:54] ==> internal final fun toWireTransaction(): WireTransaction defined in net.corda.testing.TestTransactionDSLInterpreter[SimpleFunctionDescriptorImpl]

'transactionInterpreter' @ [254:9] ==> val transactionInterpreter: TestTransactionDSLInterpreter defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap[LocalVariableDescriptor]

'labelToIndexMap' @ [254:32] ==> internal final val labelToIndexMap: HashMap<String, Int> defined in net.corda.testing.TestTransactionDSLInterpreter[PropertyDescriptorImpl]

'forEach' @ [254:48] ==> public final fun forEach(p0: (String, Int) -> Unit): Unit defined in java.util.HashMap[MyFunctionDescriptor]

'label' @ [255:17] ==> value-parameter label: String defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap.<anonymous>[ValueParameterDescriptorImpl]

'labelToOutputStateAndRefs' @ [255:26] ==> internal final val labelToOutputStateAndRefs: HashMap<String, StateAndRef<ContractState>> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'DuplicateOutputLabel' @ [256:23] ==> public constructor DuplicateOutputLabel(label: String) defined in net.corda.testing.DuplicateOutputLabel[ClassConstructorDescriptorImpl]

'label' @ [256:44] ==> value-parameter label: String defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap.<anonymous>[ValueParameterDescriptorImpl]

'labelToOutputStateAndRefs' @ [258:13] ==> internal final val labelToOutputStateAndRefs: HashMap<String, StateAndRef<ContractState>> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'label' @ [258:39] ==> value-parameter label: String defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap.<anonymous>[ValueParameterDescriptorImpl]

'wireTransaction' @ [258:48] ==> val wireTransaction: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap[LocalVariableDescriptor]

'outRef' @ [258:64] ==> public final fun <T : ContractState> outRef(index: Int): StateAndRef<ContractState> defined in net.corda.core.transactions.WireTransaction[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : ContractState> -> ContractState

'index' @ [258:71] ==> value-parameter index: Int defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap.<anonymous>[ValueParameterDescriptorImpl]

'transactionMap' @ [260:9] ==> value-parameter transactionMap: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> = ... defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap[ValueParameterDescriptorImpl]

'wireTransaction' @ [260:24] ==> val wireTransaction: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap[LocalVariableDescriptor]

'id' @ [260:40] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'WireTransactionWithLocation' @ [261:17] ==> public constructor WireTransactionWithLocation(label: String?, transaction: WireTransaction, location: String?) defined in net.corda.testing.TestLedgerDSLInterpreter.WireTransactionWithLocation[ClassConstructorDescriptorImpl]

'transactionLabel' @ [261:45] ==> value-parameter transactionLabel: String? defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap[ValueParameterDescriptorImpl]

'wireTransaction' @ [261:63] ==> val wireTransaction: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap[LocalVariableDescriptor]

'transactionLocation' @ [261:80] ==> val transactionLocation: String? defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap[LocalVariableDescriptor]

'wireTransaction' @ [263:16] ==> val wireTransaction: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.recordTransactionWithTransactionMap[LocalVariableDescriptor]

'recordTransactionWithTransactionMap' @ [270:9] ==> private final fun <R> recordTransactionWithTransactionMap(transactionLabel: String?, transactionBuilder: TransactionBuilder, dsl: TransactionDSL<TestTransactionDSLInterpreter>.() -> EnforceVerifyOrFail, transactionMap: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> = ...): WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter[SimpleFunctionDescriptorImpl]
Inferred types:
    <R> -> EnforceVerifyOrFail

'transactionLabel' @ [270:45] ==> value-parameter transactionLabel: String? defined in net.corda.testing.TestLedgerDSLInterpreter._transaction[ValueParameterDescriptorImpl]

'transactionBuilder' @ [270:63] ==> value-parameter transactionBuilder: TransactionBuilder defined in net.corda.testing.TestLedgerDSLInterpreter._transaction[ValueParameterDescriptorImpl]

'dsl' @ [270:83] ==> value-parameter dsl: TransactionDSL<TestTransactionDSLInterpreter>.() -> EnforceVerifyOrFail defined in net.corda.testing.TestLedgerDSLInterpreter._transaction[ValueParameterDescriptorImpl]

'transactionWithLocations' @ [270:88] ==> private final val transactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'recordTransactionWithTransactionMap' @ [276:9] ==> private final fun <R> recordTransactionWithTransactionMap(transactionLabel: String?, transactionBuilder: TransactionBuilder, dsl: TransactionDSL<TestTransactionDSLInterpreter>.() -> Unit, transactionMap: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> = ...): WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter[SimpleFunctionDescriptorImpl]
Inferred types:
    <R> -> Unit

'transactionLabel' @ [276:45] ==> value-parameter transactionLabel: String? defined in net.corda.testing.TestLedgerDSLInterpreter._unverifiedTransaction[ValueParameterDescriptorImpl]

'transactionBuilder' @ [276:63] ==> value-parameter transactionBuilder: TransactionBuilder defined in net.corda.testing.TestLedgerDSLInterpreter._unverifiedTransaction[ValueParameterDescriptorImpl]

'dsl' @ [276:83] ==> value-parameter dsl: TransactionDSL<TestTransactionDSLInterpreter>.() -> Unit defined in net.corda.testing.TestLedgerDSLInterpreter._unverifiedTransaction[ValueParameterDescriptorImpl]

'nonVerifiedTransactionWithLocations' @ [276:88] ==> private final val nonVerifiedTransactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'invoke' @ [281:13] ==> public abstract operator fun invoke(p1: LedgerDSL<TestTransactionDSLInterpreter, LedgerDSLInterpreter<TestTransactionDSLInterpreter>>): Unit defined in kotlin.Function1[FunctionInvokeDescriptor]

'LedgerDSL' @ [281:17] ==> public constructor LedgerDSL<out T : TransactionDSLInterpreter, out L : LedgerDSLInterpreter<TestTransactionDSLInterpreter>>(interpreter: TestLedgerDSLInterpreter) defined in net.corda.testing.LedgerDSL[ClassConstructorDescriptorImpl]
Inferred types:
    <out T : TransactionDSLInterpreter> -> TestTransactionDSLInterpreter
    <out L : LedgerDSLInterpreter<T>> -> TestLedgerDSLInterpreter

'copy' @ [281:27] ==> internal final fun copy(): TestLedgerDSLInterpreter defined in net.corda.testing.TestLedgerDSLInterpreter[SimpleFunctionDescriptorImpl]

'services' @ [284:16] ==> public final val services: ServiceHub defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'attachments' @ [284:25] ==> public abstract val attachments: AttachmentStorage defined in net.corda.core.node.ServiceHub[DeserializedPropertyDescriptor]

'importAttachment' @ [284:37] ==> public abstract fun importAttachment(jar: InputStream): SecureHash defined in net.corda.core.node.services.AttachmentStorage[DeserializedSimpleFunctionDescriptor]

'attachment' @ [284:54] ==> value-parameter attachment: InputStream defined in net.corda.testing.TestLedgerDSLInterpreter.attachment[ValueParameterDescriptorImpl]

'mutableSetOf' @ [289:30] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableSetOf(): MutableSet<StateRef> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> StateRef

'services' @ [290:13] ==> public final val services: ServiceHub defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'recordTransactions' @ [290:22] ==> public open fun recordTransactions(txs: Iterable<SignedTransaction>): Unit defined in net.corda.core.node.ServiceHub[DeserializedSimpleFunctionDescriptor]

'transactionsUnverified' @ [290:41] ==> public final val transactionsUnverified: List<WireTransaction> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'map' @ [290:64] ==> public inline fun <T, R> Iterable<WireTransaction>.map(transform: (WireTransaction) -> SignedTransaction): List<SignedTransaction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> WireTransaction
    <R> -> SignedTransaction

'SignedTransaction' @ [290:70] ==> public constructor SignedTransaction(ctx: CoreTransaction, sigs: List<TransactionSignature>) defined in net.corda.core.transactions.SignedTransaction[DeserializedClassConstructorDescriptor]

'it' @ [290:88] ==> value-parameter it: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.verifies.<anonymous>[ValueParameterDescriptorImpl]

'listOf' @ [290:92] ==> public fun <T> listOf(element: TransactionSignature): List<TransactionSignature> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TransactionSignature

'NULL_SIGNATURE' @ [290:99] ==> public val NULL_SIGNATURE: TransactionSignature defined in net.corda.core.crypto.testing[DeserializedPropertyDescriptor]

'component1' @ [291:19] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation>.component1(): SecureHash defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> SecureHash
    <V> -> WireTransactionWithLocation

'component2' @ [291:22] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation>.component2(): TestLedgerDSLInterpreter.WireTransactionWithLocation defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> SecureHash
    <V> -> WireTransactionWithLocation

'transactionWithLocations' @ [291:32] ==> private final val transactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'value' @ [292:27] ==> val value: TestLedgerDSLInterpreter.WireTransactionWithLocation defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'transaction' @ [292:33] ==> public final val transaction: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.WireTransactionWithLocation[PropertyDescriptorImpl]

'wtx' @ [293:27] ==> val wtx: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'toLedgerTransaction' @ [293:31] ==> public final fun toLedgerTransaction(services: ServicesForResolution): LedgerTransaction defined in net.corda.core.transactions.WireTransaction[DeserializedSimpleFunctionDescriptor]

'services' @ [293:51] ==> public final val services: ServiceHub defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'ltx' @ [294:17] ==> val ltx: LedgerTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'verify' @ [294:21] ==> public final fun verify(): Unit defined in net.corda.core.transactions.LedgerTransaction[DeserializedSimpleFunctionDescriptor]

'wtx' @ [295:35] ==> val wtx: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'inputs' @ [295:39] ==> public open val inputs: List<StateRef> defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'intersect' @ [295:46] ==> public infix fun <T> Iterable<StateRef>.intersect(other: Iterable<StateRef>): Set<StateRef> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> StateRef

'usedInputs' @ [295:56] ==> val usedInputs: MutableSet<StateRef> defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'!' @ [296:21] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'doubleSpend' @ [296:22] ==> val doubleSpend: Set<StateRef> defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'isEmpty' @ [296:34] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.Set[DeserializedSimpleFunctionDescriptor]

'mutableListOf' @ [297:33] ==> public fun <T> mutableListOf(vararg elements: SecureHash): MutableList<SecureHash> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SecureHash

'wtx' @ [297:47] ==> val wtx: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'id' @ [297:51] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'doubleSpend' @ [298:21] ==> val doubleSpend: Set<StateRef> defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'mapTo' @ [298:33] ==> public inline fun <T, R, C : MutableCollection<in SecureHash>> Iterable<StateRef>.mapTo(destination: MutableList<SecureHash>, transform: (StateRef) -> SecureHash): MutableList<SecureHash> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> StateRef
    <R> -> SecureHash
    <C : MutableCollection<in R>> -> MutableList<SecureHash>

'txIds' @ [298:39] ==> val txIds: MutableList<SecureHash> defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'it' @ [298:48] ==> value-parameter it: StateRef defined in net.corda.testing.TestLedgerDSLInterpreter.verifies.<anonymous>[ValueParameterDescriptorImpl]

'txhash' @ [298:51] ==> public final val txhash: SecureHash defined in net.corda.core.contracts.StateRef[DeserializedPropertyDescriptor]

'DoubleSpentInputs' @ [299:27] ==> public constructor DoubleSpentInputs(ids: List<SecureHash>) defined in net.corda.testing.DoubleSpentInputs[ClassConstructorDescriptorImpl]

'txIds' @ [299:45] ==> val txIds: MutableList<SecureHash> defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'usedInputs' @ [301:17] ==> val usedInputs: MutableSet<StateRef> defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'addAll' @ [301:28] ==> public abstract fun addAll(elements: Collection<StateRef>): Boolean defined in kotlin.collections.MutableSet[DeserializedSimpleFunctionDescriptor]

'wtx' @ [301:35] ==> val wtx: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'inputs' @ [301:39] ==> public open val inputs: List<StateRef> defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'services' @ [302:17] ==> public final val services: ServiceHub defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'recordTransactions' @ [302:26] ==> public open fun recordTransactions(first: SignedTransaction, vararg remaining: SignedTransaction): Unit defined in net.corda.core.node.ServiceHub[DeserializedSimpleFunctionDescriptor]

'SignedTransaction' @ [302:45] ==> public constructor SignedTransaction(ctx: CoreTransaction, sigs: List<TransactionSignature>) defined in net.corda.core.transactions.SignedTransaction[DeserializedClassConstructorDescriptor]

'wtx' @ [302:63] ==> val wtx: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'listOf' @ [302:68] ==> public fun <T> listOf(element: TransactionSignature): List<TransactionSignature> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TransactionSignature

'NULL_SIGNATURE' @ [302:75] ==> public val NULL_SIGNATURE: TransactionSignature defined in net.corda.core.crypto.testing[DeserializedPropertyDescriptor]

'Token' @ [304:40] ==> internal object Token : EnforceVerifyOrFail defined in net.corda.testing.EnforceVerifyOrFail[FakeCallableDescriptorForObject]

'transactionWithLocations' @ [306:43] ==> private final val transactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'exception' @ [306:68] ==> val exception: TransactionVerificationException defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'txId' @ [306:78] ==> public final val txId: SecureHash defined in net.corda.core.contracts.TransactionVerificationException[DeserializedPropertyDescriptor]

'transactionWithLocation' @ [307:35] ==> val transactionWithLocation: TestLedgerDSLInterpreter.WireTransactionWithLocation? defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'label' @ [307:60] ==> public final val label: String? defined in net.corda.testing.TestLedgerDSLInterpreter.WireTransactionWithLocation[PropertyDescriptorImpl]

'transactionWithLocation' @ [307:69] ==> val transactionWithLocation: TestLedgerDSLInterpreter.WireTransactionWithLocation? defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'location' @ [307:94] ==> public final val location: String? defined in net.corda.testing.TestLedgerDSLInterpreter.WireTransactionWithLocation[PropertyDescriptorImpl]

'VerifiesFailed' @ [308:19] ==> public constructor VerifiesFailed(transactionName: String, cause: Throwable) defined in net.corda.testing.TestLedgerDSLInterpreter.VerifiesFailed[ClassConstructorDescriptorImpl]

'transactionName' @ [308:34] ==> val transactionName: String defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'exception' @ [308:51] ==> val exception: TransactionVerificationException defined in net.corda.testing.TestLedgerDSLInterpreter.verifies[LocalVariableDescriptor]

'labelToOutputStateAndRefs' @ [313:27] ==> internal final val labelToOutputStateAndRefs: HashMap<String, StateAndRef<ContractState>> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'label' @ [313:53] ==> value-parameter label: String defined in net.corda.testing.TestLedgerDSLInterpreter.retrieveOutputStateAndRef[ValueParameterDescriptorImpl]

'if (stateAndRef == null) {
            throw IllegalArgumentException("State with label '$label' was not found")
        } else if (!clazz.isAssignableFrom(stateAndRef.state.data.javaClass)) {
            throw TypeMismatch(requested = clazz, actual = stateAndRef.state.data.javaClass)
        } else {
            @Suppress("UNCHECKED_CAST")
            return stateAndRef as StateAndRef<S>
        }' @ [314:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nothing, elseBranch: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nothing

'stateAndRef' @ [314:13] ==> val stateAndRef: StateAndRef<ContractState>? defined in net.corda.testing.TestLedgerDSLInterpreter.retrieveOutputStateAndRef[LocalVariableDescriptor]

'IllegalArgumentException' @ [315:19] ==> public final fun <init>(p0: (String..String?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'label' @ [315:64] ==> value-parameter label: String defined in net.corda.testing.TestLedgerDSLInterpreter.retrieveOutputStateAndRef[ValueParameterDescriptorImpl]

'if (!clazz.isAssignableFrom(stateAndRef.state.data.javaClass)) {
            throw TypeMismatch(requested = clazz, actual = stateAndRef.state.data.javaClass)
        } else {
            @Suppress("UNCHECKED_CAST")
            return stateAndRef as StateAndRef<S>
        }' @ [316:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nothing, elseBranch: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nothing

'!' @ [316:20] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'clazz' @ [316:21] ==> value-parameter clazz: Class<S> defined in net.corda.testing.TestLedgerDSLInterpreter.retrieveOutputStateAndRef[ValueParameterDescriptorImpl]

'isAssignableFrom' @ [316:27] ==> public open fun isAssignableFrom(p0: (Class<*>..Class<*>?)): Boolean defined in java.lang.Class[JavaMethodDescriptor]

'stateAndRef' @ [316:44] ==> val stateAndRef: StateAndRef<ContractState>? defined in net.corda.testing.TestLedgerDSLInterpreter.retrieveOutputStateAndRef[LocalVariableDescriptor]

'state' @ [316:56] ==> public final val state: TransactionState<ContractState> defined in net.corda.core.contracts.StateAndRef[DeserializedPropertyDescriptor]

'data' @ [316:62] ==> public final val data: ContractState defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'javaClass' @ [316:67] ==> public val <T : Any> ContractState.javaClass: Class<ContractState> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> ContractState

'TypeMismatch' @ [317:19] ==> public constructor TypeMismatch(requested: Class<*>, actual: Class<*>) defined in net.corda.testing.TestLedgerDSLInterpreter.TypeMismatch[ClassConstructorDescriptorImpl]

'clazz' @ [317:44] ==> value-parameter clazz: Class<S> defined in net.corda.testing.TestLedgerDSLInterpreter.retrieveOutputStateAndRef[ValueParameterDescriptorImpl]

'stateAndRef' @ [317:60] ==> val stateAndRef: StateAndRef<ContractState>? defined in net.corda.testing.TestLedgerDSLInterpreter.retrieveOutputStateAndRef[LocalVariableDescriptor]

'state' @ [317:72] ==> public final val state: TransactionState<ContractState> defined in net.corda.core.contracts.StateAndRef[DeserializedPropertyDescriptor]

'data' @ [317:78] ==> public final val data: ContractState defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'javaClass' @ [317:83] ==> public val <T : Any> ContractState.javaClass: Class<ContractState> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> ContractState

'Suppress' @ [319:13] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'stateAndRef' @ [320:20] ==> val stateAndRef: StateAndRef<ContractState>? defined in net.corda.testing.TestLedgerDSLInterpreter.retrieveOutputStateAndRef[LocalVariableDescriptor]

'transactionWithLocations' @ [324:61] ==> private final val transactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'values' @ [324:86] ==> public open val values: MutableCollection<TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in java.util.HashMap[JavaPropertyDescriptor]

'map' @ [324:93] ==> public inline fun <T, R> Iterable<TestLedgerDSLInterpreter.WireTransactionWithLocation>.map(transform: (TestLedgerDSLInterpreter.WireTransactionWithLocation) -> WireTransaction): List<WireTransaction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> WireTransactionWithLocation
    <R> -> WireTransaction

'it' @ [324:99] ==> value-parameter it: TestLedgerDSLInterpreter.WireTransactionWithLocation defined in net.corda.testing.TestLedgerDSLInterpreter.<get-transactionsToVerify>.<anonymous>[ValueParameterDescriptorImpl]

'transaction' @ [324:102] ==> public final val transaction: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.WireTransactionWithLocation[PropertyDescriptorImpl]

'nonVerifiedTransactionWithLocations' @ [325:63] ==> private final val nonVerifiedTransactionWithLocations: HashMap<SecureHash, TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'values' @ [325:99] ==> public open val values: MutableCollection<TestLedgerDSLInterpreter.WireTransactionWithLocation> defined in java.util.HashMap[JavaPropertyDescriptor]

'map' @ [325:106] ==> public inline fun <T, R> Iterable<TestLedgerDSLInterpreter.WireTransactionWithLocation>.map(transform: (TestLedgerDSLInterpreter.WireTransactionWithLocation) -> WireTransaction): List<WireTransaction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> WireTransactionWithLocation
    <R> -> WireTransaction

'it' @ [325:112] ==> value-parameter it: TestLedgerDSLInterpreter.WireTransactionWithLocation defined in net.corda.testing.TestLedgerDSLInterpreter.<get-transactionsUnverified>.<anonymous>[ValueParameterDescriptorImpl]

'transaction' @ [325:115] ==> public final val transaction: WireTransaction defined in net.corda.testing.TestLedgerDSLInterpreter.WireTransactionWithLocation[PropertyDescriptorImpl]

'transactionsToSign' @ [334:84] ==> value-parameter transactionsToSign: List<WireTransaction> defined in net.corda.testing.signAll[ValueParameterDescriptorImpl]

'map' @ [334:103] ==> public inline fun <T, R> Iterable<WireTransaction>.map(transform: (WireTransaction) -> SignedTransaction): List<SignedTransaction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> WireTransaction
    <R> -> SignedTransaction

'check' @ [335:5] ==> @InlineOnly public inline fun check(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'wtx' @ [335:11] ==> value-parameter wtx: WireTransaction defined in net.corda.testing.signAll.<anonymous>[ValueParameterDescriptorImpl]

'requiredSigningKeys' @ [335:15] ==> public final val requiredSigningKeys: Set<PublicKey> defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'isNotEmpty' @ [335:35] ==> @InlineOnly public inline fun <T> Collection<PublicKey>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PublicKey

'ArrayList' @ [336:22] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> TransactionSignature

'HashMap' @ [337:21] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> PublicKey
    <V : (Any..Any?)> -> KeyPair

'ALL_TEST_KEYS' @ [339:6] ==> public val ALL_TEST_KEYS: List<KeyPair> defined in net.corda.testing in file CoreTestUtils.kt[PropertyDescriptorImpl]

'extraKeys' @ [339:22] ==> value-parameter extraKeys: List<KeyPair> defined in net.corda.testing.signAll[ValueParameterDescriptorImpl]

'forEach' @ [339:33] ==> @HidesMembers public inline fun <T> Iterable<KeyPair>.forEach(action: (KeyPair) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KeyPair

'keyLookup' @ [340:9] ==> val keyLookup: HashMap<PublicKey, KeyPair> defined in net.corda.testing.signAll.<anonymous>[LocalVariableDescriptor]

'it' @ [340:19] ==> value-parameter it: KeyPair defined in net.corda.testing.signAll.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'public' @ [340:22] ==> public final val KeyPair.public: (PublicKey..PublicKey?)[MyPropertyDescriptor]

'it' @ [340:32] ==> value-parameter it: KeyPair defined in net.corda.testing.signAll.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'wtx' @ [342:5] ==> value-parameter wtx: WireTransaction defined in net.corda.testing.signAll.<anonymous>[ValueParameterDescriptorImpl]

'requiredSigningKeys' @ [342:9] ==> public final val requiredSigningKeys: Set<PublicKey> defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'expandedCompositeKeys' @ [342:29] ==> public val Iterable<PublicKey>.expandedCompositeKeys: Set<PublicKey> defined in net.corda.core.crypto.composite[DeserializedPropertyDescriptor]

'forEach' @ [342:51] ==> @HidesMembers public inline fun <T> Iterable<PublicKey>.forEach(action: (PublicKey) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PublicKey

'keyLookup' @ [343:19] ==> val keyLookup: HashMap<PublicKey, KeyPair> defined in net.corda.testing.signAll.<anonymous>[LocalVariableDescriptor]

'it' @ [343:29] ==> value-parameter it: PublicKey defined in net.corda.testing.signAll.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'IllegalArgumentException' @ [343:42] ==> public final fun <init>(p0: (String..String?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'it' @ [343:95] ==> value-parameter it: PublicKey defined in net.corda.testing.signAll.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'toStringShort' @ [343:98] ==> public fun PublicKey.toStringShort(): String defined in net.corda.core.crypto[DeserializedSimpleFunctionDescriptor]

'signatures' @ [344:9] ==> val signatures: ArrayList<TransactionSignature> defined in net.corda.testing.signAll.<anonymous>[LocalVariableDescriptor]

'key' @ [344:23] ==> val key: KeyPair defined in net.corda.testing.signAll.<anonymous>.<anonymous>[LocalVariableDescriptor]

'sign' @ [344:27] ==> public fun KeyPair.sign(signableData: SignableData): TransactionSignature defined in net.corda.core.crypto[DeserializedSimpleFunctionDescriptor]

'SignableData' @ [344:32] ==> public constructor SignableData(txId: SecureHash, signatureMetadata: SignatureMetadata) defined in net.corda.core.crypto.SignableData[DeserializedClassConstructorDescriptor]

'wtx' @ [344:45] ==> value-parameter wtx: WireTransaction defined in net.corda.testing.signAll.<anonymous>[ValueParameterDescriptorImpl]

'id' @ [344:49] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'SignatureMetadata' @ [344:53] ==> public constructor SignatureMetadata(platformVersion: Int, schemeNumberID: Int) defined in net.corda.core.crypto.SignatureMetadata[DeserializedClassConstructorDescriptor]

'Crypto' @ [344:74] ==> public object Crypto defined in net.corda.core.crypto[FakeCallableDescriptorForObject]

'findSignatureScheme' @ [344:81] ==> @JvmStatic public final fun findSignatureScheme(key: PublicKey): SignatureScheme defined in net.corda.core.crypto.Crypto[DeserializedSimpleFunctionDescriptor]

'it' @ [344:101] ==> value-parameter it: PublicKey defined in net.corda.testing.signAll.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'schemeNumberID' @ [344:105] ==> public final val schemeNumberID: Int defined in net.corda.core.crypto.SignatureScheme[DeserializedPropertyDescriptor]

'SignedTransaction' @ [346:5] ==> public constructor SignedTransaction(ctx: CoreTransaction, sigs: List<TransactionSignature>) defined in net.corda.core.transactions.SignedTransaction[DeserializedClassConstructorDescriptor]

'wtx' @ [346:23] ==> value-parameter wtx: WireTransaction defined in net.corda.testing.signAll.<anonymous>[ValueParameterDescriptorImpl]

'signatures' @ [346:28] ==> val signatures: ArrayList<TransactionSignature> defined in net.corda.testing.signAll.<anonymous>[LocalVariableDescriptor]

'signAll' @ [355:38] ==> public fun signAll(transactionsToSign: List<WireTransaction>, extraKeys: List<KeyPair>): List<SignedTransaction> defined in net.corda.testing[SimpleFunctionDescriptorImpl]

'this' @ [355:46] ==> <this> defined in net.corda.testing.signAll[ReceiverParameterDescriptorImpl]

'interpreter' @ [355:51] ==> public final val interpreter: TestLedgerDSLInterpreter defined in net.corda.testing.LedgerDSL[PropertyDescriptorImpl]

'wireTransactions' @ [355:63] ==> public final val wireTransactions: List<WireTransaction> defined in net.corda.testing.TestLedgerDSLInterpreter[PropertyDescriptorImpl]

'extraKeys' @ [355:81] ==> value-parameter vararg extraKeys: KeyPair defined in net.corda.testing.signAll[ValueParameterDescriptorImpl]

'toList' @ [355:91] ==> public fun <T> Array<out KeyPair>.toList(): List<KeyPair> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KeyPair

