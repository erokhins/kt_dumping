'CordaSerializable' @ [37:1] ==> public constructor CordaSerializable() defined in net.corda.core.serialization.CordaSerializable[ClassConstructorDescriptorImpl]

'JvmStatic' @ [50:9] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'JvmOverloads' @ [51:9] ==> public constructor JvmOverloads() defined in kotlin.jvm.JvmOverloads[DeserializedClassConstructorDescriptor]

'FLOOR' @ [52:112] ==> enum entry FLOOR defined in java.math.RoundingMode[FakeCallableDescriptorForObject]

'getDisplayTokenSize' @ [53:29] ==> @JvmStatic public final fun getDisplayTokenSize(token: Any): BigDecimal defined in net.corda.core.contracts.Amount.Companion[SimpleFunctionDescriptorImpl]

'token' @ [53:49] ==> value-parameter token: T defined in net.corda.core.contracts.Amount.Companion.fromDecimal[ValueParameterDescriptorImpl]

'displayQuantity' @ [54:30] ==> value-parameter displayQuantity: BigDecimal defined in net.corda.core.contracts.Amount.Companion.fromDecimal[ValueParameterDescriptorImpl]

'divide' @ [54:46] ==> public open fun divide(p0: (BigDecimal..BigDecimal?)): (BigDecimal..BigDecimal?) defined in java.math.BigDecimal[JavaMethodDescriptor]

'tokenSize' @ [54:53] ==> val tokenSize: BigDecimal defined in net.corda.core.contracts.Amount.Companion.fromDecimal[LocalVariableDescriptor]

'setScale' @ [54:64] ==> public open fun setScale(p0: Int, p1: (RoundingMode..RoundingMode?)): (BigDecimal..BigDecimal?) defined in java.math.BigDecimal[JavaMethodDescriptor]

'rounding' @ [54:76] ==> value-parameter rounding: RoundingMode = ... defined in net.corda.core.contracts.Amount.Companion.fromDecimal[ValueParameterDescriptorImpl]

'longValueExact' @ [54:86] ==> public open fun longValueExact(): Long defined in java.math.BigDecimal[JavaMethodDescriptor]

'Amount' @ [55:20] ==> public constructor Amount<T : Any>(quantity: Long, displayTokenSize: BigDecimal, token: T) defined in net.corda.core.contracts.Amount[ClassConstructorDescriptorImpl]
Inferred types:
    <T : Any> -> T

'tokenCount' @ [55:27] ==> val tokenCount: Long defined in net.corda.core.contracts.Amount.Companion.fromDecimal[LocalVariableDescriptor]

'tokenSize' @ [55:39] ==> val tokenSize: BigDecimal defined in net.corda.core.contracts.Amount.Companion.fromDecimal[LocalVariableDescriptor]

'token' @ [55:50] ==> value-parameter token: T defined in net.corda.core.contracts.Amount.Companion.fromDecimal[ValueParameterDescriptorImpl]

'JvmStatic' @ [61:9] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'getDisplayTokenSize' @ [63:29] ==> @JvmStatic public final fun getDisplayTokenSize(token: Any): BigDecimal defined in net.corda.core.contracts.Amount.Companion[SimpleFunctionDescriptorImpl]

'token' @ [63:49] ==> value-parameter token: T defined in net.corda.core.contracts.Amount.Companion.zero[ValueParameterDescriptorImpl]

'Amount' @ [64:20] ==> public constructor Amount<T : Any>(quantity: Long, displayTokenSize: BigDecimal, token: T) defined in net.corda.core.contracts.Amount[ClassConstructorDescriptorImpl]
Inferred types:
    <T : Any> -> T

'tokenSize' @ [64:31] ==> val tokenSize: BigDecimal defined in net.corda.core.contracts.Amount.Companion.zero[LocalVariableDescriptor]

'token' @ [64:42] ==> value-parameter token: T defined in net.corda.core.contracts.Amount.Companion.zero[ValueParameterDescriptorImpl]

'JvmStatic' @ [75:9] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'token' @ [77:17] ==> value-parameter token: Any defined in net.corda.core.contracts.Amount.Companion.getDisplayTokenSize[ValueParameterDescriptorImpl]

'token' @ [78:24] ==> value-parameter token: Any defined in net.corda.core.contracts.Amount.Companion.getDisplayTokenSize[ValueParameterDescriptorImpl]

'displayTokenSize' @ [78:30] ==> public abstract val displayTokenSize: BigDecimal defined in net.corda.core.contracts.TokenizableAssetInfo[PropertyDescriptorImpl]

'token' @ [80:17] ==> value-parameter token: Any defined in net.corda.core.contracts.Amount.Companion.getDisplayTokenSize[ValueParameterDescriptorImpl]

'ONE' @ [81:35] ==> public final val ONE: (BigDecimal..BigDecimal?) defined in java.math.BigDecimal[JavaPropertyDescriptor]

'scaleByPowerOfTen' @ [81:39] ==> public open fun scaleByPowerOfTen(p0: Int): (BigDecimal..BigDecimal?) defined in java.math.BigDecimal[JavaMethodDescriptor]

'-' @ [81:57] ==> public final operator fun unaryMinus(): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'token' @ [81:58] ==> value-parameter token: Any defined in net.corda.core.contracts.Amount.Companion.getDisplayTokenSize[ValueParameterDescriptorImpl]

'defaultFractionDigits' @ [81:64] ==> public final val Currency.defaultFractionDigits: Int[MyPropertyDescriptor]

'token' @ [83:17] ==> value-parameter token: Any defined in net.corda.core.contracts.Amount.Companion.getDisplayTokenSize[ValueParameterDescriptorImpl]

'getDisplayTokenSize' @ [84:24] ==> @JvmStatic public final fun getDisplayTokenSize(token: Any): BigDecimal defined in net.corda.core.contracts.Amount.Companion[SimpleFunctionDescriptorImpl]

'token' @ [84:44] ==> value-parameter token: Any defined in net.corda.core.contracts.Amount.Companion.getDisplayTokenSize[ValueParameterDescriptorImpl]

'product' @ [84:50] ==> public final val product: Any defined in net.corda.core.contracts.Issued[PropertyDescriptorImpl]

'ONE' @ [86:31] ==> public final val ONE: (BigDecimal..BigDecimal?) defined in java.math.BigDecimal[JavaPropertyDescriptor]

'JvmStatic' @ [93:9] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'if (!iterator().hasNext()) null else sumOrThrow()' @ [94:57] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Amount<T>?, elseBranch: Amount<T>?): Amount<T>?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Amount<T>?

'!' @ [94:61] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'iterator' @ [94:62] ==> public abstract operator fun iterator(): Iterator<Amount<T>> defined in kotlin.collections.Iterable[DeserializedSimpleFunctionDescriptor]

'hasNext' @ [94:73] ==> public abstract operator fun hasNext(): Boolean defined in kotlin.collections.Iterator[DeserializedSimpleFunctionDescriptor]

'sumOrThrow' @ [94:94] ==> @JvmStatic public final fun <T : Any> Iterable<Amount<T>>.sumOrThrow(): Amount<T> defined in net.corda.core.contracts.Amount.Companion[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> T

'JvmStatic' @ [100:9] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'reduce' @ [101:58] ==> public inline fun <S, T : Amount<T>> Iterable<Amount<T>>.reduce(operation: (acc: Amount<T>, Amount<T>) -> Amount<T>): Amount<T> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <S> -> Amount<T>
    <T : S> -> Amount<T>

'left' @ [101:82] ==> value-parameter left: Amount<T> defined in net.corda.core.contracts.Amount.Companion.sumOrThrow.<anonymous>[ValueParameterDescriptorImpl]

'right' @ [101:89] ==> value-parameter right: Amount<T> defined in net.corda.core.contracts.Amount.Companion.sumOrThrow.<anonymous>[ValueParameterDescriptorImpl]

'JvmStatic' @ [108:9] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'if (iterator().hasNext()) sumOrThrow() else Amount.zero(token)' @ [109:65] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Amount<T>, elseBranch: Amount<T>): Amount<T>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Amount<T>

'iterator' @ [109:69] ==> public abstract operator fun iterator(): Iterator<Amount<T>> defined in kotlin.collections.Iterable[DeserializedSimpleFunctionDescriptor]

'hasNext' @ [109:80] ==> public abstract operator fun hasNext(): Boolean defined in kotlin.collections.Iterator[DeserializedSimpleFunctionDescriptor]

'sumOrThrow' @ [109:91] ==> @JvmStatic public final fun <T : Any> Iterable<Amount<T>>.sumOrThrow(): Amount<T> defined in net.corda.core.contracts.Amount.Companion[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> T

'zero' @ [109:116] ==> @JvmStatic public final fun <T : Any> zero(token: T): Amount<T> defined in net.corda.core.contracts.Amount.Companion[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> T

'token' @ [109:121] ==> value-parameter token: T defined in net.corda.core.contracts.Amount.Companion.sumOrZero[ValueParameterDescriptorImpl]

'mapOf' @ [111:62] ==> public fun <K, V> mapOf(vararg pairs: Pair<String, (Currency..Currency?)>): Map<String, (Currency..Currency?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> String
    <V> -> (java.util.Currency..java.util.Currency?)

'to' @ [112:17] ==> public infix fun <A, B> String.to(that: (Currency..Currency?)): Pair<String, (Currency..Currency?)> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> (java.util.Currency..java.util.Currency?)

'getInstance' @ [112:33] ==> public open fun getInstance(p0: (String..String?)): (Currency..Currency?) defined in java.util.Currency[JavaMethodDescriptor]

'to' @ [113:17] ==> public infix fun <A, B> String.to(that: (Currency..Currency?)): Pair<String, (Currency..Currency?)> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> (java.util.Currency..java.util.Currency?)

'getInstance' @ [113:33] ==> public open fun getInstance(p0: (String..String?)): (Currency..Currency?) defined in java.util.Currency[JavaMethodDescriptor]

'to' @ [114:17] ==> public infix fun <A, B> String.to(that: (Currency..Currency?)): Pair<String, (Currency..Currency?)> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> (java.util.Currency..java.util.Currency?)

'getInstance' @ [114:33] ==> public open fun getInstance(p0: (String..String?)): (Currency..Currency?) defined in java.util.Currency[JavaMethodDescriptor]

'to' @ [115:17] ==> public infix fun <A, B> String.to(that: (Currency..Currency?)): Pair<String, (Currency..Currency?)> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> (java.util.Currency..java.util.Currency?)

'getInstance' @ [115:33] ==> public open fun getInstance(p0: (String..String?)): (Currency..Currency?) defined in java.util.Currency[JavaMethodDescriptor]

'to' @ [116:17] ==> public infix fun <A, B> String.to(that: (Currency..Currency?)): Pair<String, (Currency..Currency?)> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> (java.util.Currency..java.util.Currency?)

'getInstance' @ [116:33] ==> public open fun getInstance(p0: (String..String?)): (Currency..Currency?) defined in java.util.Currency[JavaMethodDescriptor]

'getValue' @ [119:61] ==> @InlineOnly public operator inline fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> T

'getAvailableCurrencies' @ [120:22] ==> public open fun getAvailableCurrencies(): (MutableSet<(Currency..Currency?)>..Set<(Currency..Currency?)>?) defined in java.util.Currency[JavaMethodDescriptor]

'associateBy' @ [120:47] ==> public inline fun <T, K> Iterable<(Currency..Currency?)>.associateBy(keySelector: ((Currency..Currency?)) -> (String..String?)): Map<(String..String?), (Currency..Currency?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (java.util.Currency..java.util.Currency?)
    <K> -> (kotlin.String..kotlin.String?)

'it' @ [120:61] ==> value-parameter it: (Currency..Currency?) defined in net.corda.core.contracts.Amount.Companion.currencyCodes.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'currencyCode' @ [120:64] ==> public final val Currency.currencyCode: (String..String?)[MyPropertyDescriptor]

'JvmStatic' @ [148:9] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'input' @ [150:21] ==> value-parameter input: String defined in net.corda.core.contracts.Amount.Companion.parseCurrency[ValueParameterDescriptorImpl]

'filter' @ [150:27] ==> public inline fun String.filter(predicate: (Char) -> Boolean): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'it' @ [150:36] ==> value-parameter it: Char defined in net.corda.core.contracts.Amount.Companion.parseCurrency.<anonymous>[ValueParameterDescriptorImpl]

'component1' @ [153:23] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<String, Currency>.component1(): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> String
    <V> -> Currency

'component2' @ [153:31] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<String, Currency>.component2(): Currency defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> String
    <V> -> Currency

'currencySymbols' @ [153:44] ==> private final val currencySymbols: Map<String, Currency> defined in net.corda.core.contracts.Amount.Companion[PropertyDescriptorImpl]

'i' @ [154:25] ==> val i: String defined in net.corda.core.contracts.Amount.Companion.parseCurrency[LocalVariableDescriptor]

'startsWith' @ [154:27] ==> public fun String.startsWith(prefix: String, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'symbol' @ [154:38] ==> val symbol: String defined in net.corda.core.contracts.Amount.Companion.parseCurrency[LocalVariableDescriptor]

'i' @ [155:36] ==> val i: String defined in net.corda.core.contracts.Amount.Companion.parseCurrency[LocalVariableDescriptor]

'substring' @ [155:38] ==> @InlineOnly public inline fun String.substring(startIndex: Int): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'symbol' @ [155:48] ==> val symbol: String defined in net.corda.core.contracts.Amount.Companion.parseCurrency[LocalVariableDescriptor]

'length' @ [155:55] ==> public open val length: Int defined in kotlin.String[DeserializedPropertyDescriptor]

'Amount' @ [156:32] ==> public companion object defined in net.corda.core.contracts.Amount[FakeCallableDescriptorForObject]

'fromDecimal' @ [156:39] ==> @JvmStatic @JvmOverloads public final fun <T : Any> fromDecimal(displayQuantity: BigDecimal, token: Currency, rounding: RoundingMode = ...): Amount<Currency> defined in net.corda.core.contracts.Amount.Companion[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> Currency

'BigDecimal' @ [156:51] ==> public constructor BigDecimal(p0: (String..String?)) defined in java.math.BigDecimal[JavaClassConstructorDescriptor]

'rest' @ [156:62] ==> val rest: String defined in net.corda.core.contracts.Amount.Companion.parseCurrency[LocalVariableDescriptor]

'currency' @ [156:69] ==> val currency: Currency defined in net.corda.core.contracts.Amount.Companion.parseCurrency[LocalVariableDescriptor]

'i' @ [160:29] ==> val i: String defined in net.corda.core.contracts.Amount.Companion.parseCurrency[LocalVariableDescriptor]

'split' @ [160:31] ==> public fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = ..., limit: Int = ...): List<String> defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'split' @ [161:21] ==> val split: List<String> defined in net.corda.core.contracts.Amount.Companion.parseCurrency[LocalVariableDescriptor]

'size' @ [161:27] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'component1' @ [162:26] ==> @InlineOnly public operator inline fun <T> List<String>.component1(): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'component2' @ [162:32] ==> @InlineOnly public operator inline fun <T> List<String>.component2(): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'split' @ [162:40] ==> val split: List<String> defined in net.corda.core.contracts.Amount.Companion.parseCurrency[LocalVariableDescriptor]

'component1' @ [163:27] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<String, Currency>.component1(): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> String
    <V> -> Currency

'component2' @ [163:31] ==> @InlineOnly public operator inline fun <K, V> Map.Entry<String, Currency>.component2(): Currency defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> String
    <V> -> Currency

'currencyCodes' @ [163:44] ==> private final val currencyCodes: Map<String, Currency> defined in net.corda.core.contracts.Amount.Companion[PropertyDescriptorImpl]

'cc' @ [164:29] ==> val cc: String defined in net.corda.core.contracts.Amount.Companion.parseCurrency[LocalVariableDescriptor]

'code' @ [164:35] ==> val code: String defined in net.corda.core.contracts.Amount.Companion.parseCurrency[LocalVariableDescriptor]

'Amount' @ [165:36] ==> public companion object defined in net.corda.core.contracts.Amount[FakeCallableDescriptorForObject]

'fromDecimal' @ [165:43] ==> @JvmStatic @JvmOverloads public final fun <T : Any> fromDecimal(displayQuantity: BigDecimal, token: Currency, rounding: RoundingMode = ...): Amount<Currency> defined in net.corda.core.contracts.Amount.Companion[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> Currency

'BigDecimal' @ [165:55] ==> public constructor BigDecimal(p0: (String..String?)) defined in java.math.BigDecimal[JavaClassConstructorDescriptor]

'rest' @ [165:66] ==> val rest: String defined in net.corda.core.contracts.Amount.Companion.parseCurrency[LocalVariableDescriptor]

'currency' @ [165:73] ==> val currency: Currency defined in net.corda.core.contracts.Amount.Companion.parseCurrency[LocalVariableDescriptor]

'IllegalArgumentException' @ [170:23] ==> public final fun <init>(p0: (String..String?), p1: (Throwable..Throwable?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'input' @ [170:66] ==> value-parameter input: String defined in net.corda.core.contracts.Amount.Companion.parseCurrency[ValueParameterDescriptorImpl]

'e' @ [170:88] ==> val e: Exception /* = Exception */ defined in net.corda.core.contracts.Amount.Companion.parseCurrency[LocalVariableDescriptor]

'IllegalArgumentException' @ [172:19] ==> public final fun <init>(p0: (String..String?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'input' @ [172:80] ==> value-parameter input: String defined in net.corda.core.contracts.Amount.Companion.parseCurrency[ValueParameterDescriptorImpl]

'require' @ [181:9] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'quantity' @ [181:17] ==> public final val quantity: Long defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'quantity' @ [181:70] ==> public final val quantity: Long defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'this' @ [191:50] ==> public constructor Amount<T : Any>(quantity: Long, displayTokenSize: BigDecimal, token: T) defined in net.corda.core.contracts.Amount[ClassConstructorDescriptorImpl]
Inferred types:
    <T : Any> -> T

'tokenQuantity' @ [191:55] ==> value-parameter tokenQuantity: Long defined in net.corda.core.contracts.Amount.<init>[ValueParameterDescriptorImpl]

'getDisplayTokenSize' @ [191:70] ==> @JvmStatic public final fun getDisplayTokenSize(token: Any): BigDecimal defined in net.corda.core.contracts.Amount.Companion[SimpleFunctionDescriptorImpl]

'token' @ [191:90] ==> value-parameter token: T defined in net.corda.core.contracts.Amount.<init>[ValueParameterDescriptorImpl]

'token' @ [191:98] ==> value-parameter token: T defined in net.corda.core.contracts.Amount.<init>[ValueParameterDescriptorImpl]

'checkToken' @ [200:9] ==> private final fun checkToken(other: Amount<T>): Unit defined in net.corda.core.contracts.Amount[SimpleFunctionDescriptorImpl]

'other' @ [200:20] ==> value-parameter other: Amount<T> defined in net.corda.core.contracts.Amount.plus[ValueParameterDescriptorImpl]

'Amount' @ [201:16] ==> public constructor Amount<T : Any>(quantity: Long, displayTokenSize: BigDecimal, token: T) defined in net.corda.core.contracts.Amount[ClassConstructorDescriptorImpl]
Inferred types:
    <T : Any> -> T

'quantity' @ [201:23] ==> public final val quantity: Long defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'other' @ [201:41] ==> value-parameter other: Amount<T> defined in net.corda.core.contracts.Amount.plus[ValueParameterDescriptorImpl]

'quantity' @ [201:47] ==> public final val quantity: Long defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'displayTokenSize' @ [201:57] ==> public final val displayTokenSize: BigDecimal defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'token' @ [201:75] ==> public final val token: T defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'checkToken' @ [212:9] ==> private final fun checkToken(other: Amount<T>): Unit defined in net.corda.core.contracts.Amount[SimpleFunctionDescriptorImpl]

'other' @ [212:20] ==> value-parameter other: Amount<T> defined in net.corda.core.contracts.Amount.minus[ValueParameterDescriptorImpl]

'Amount' @ [213:16] ==> public constructor Amount<T : Any>(quantity: Long, displayTokenSize: BigDecimal, token: T) defined in net.corda.core.contracts.Amount[ClassConstructorDescriptorImpl]
Inferred types:
    <T : Any> -> T

'subtractExact' @ [213:28] ==> public open fun subtractExact(p0: Long, p1: Long): Long defined in java.lang.Math[JavaMethodDescriptor]

'quantity' @ [213:42] ==> public final val quantity: Long defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'other' @ [213:52] ==> value-parameter other: Amount<T> defined in net.corda.core.contracts.Amount.minus[ValueParameterDescriptorImpl]

'quantity' @ [213:58] ==> public final val quantity: Long defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'displayTokenSize' @ [213:69] ==> public final val displayTokenSize: BigDecimal defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'token' @ [213:87] ==> public final val token: T defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'require' @ [217:9] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'other' @ [217:17] ==> value-parameter other: Amount<T> defined in net.corda.core.contracts.Amount.checkToken[ValueParameterDescriptorImpl]

'token' @ [217:23] ==> public final val token: T defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'token' @ [217:32] ==> public final val token: T defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'other' @ [217:60] ==> value-parameter other: Amount<T> defined in net.corda.core.contracts.Amount.checkToken[ValueParameterDescriptorImpl]

'token' @ [217:66] ==> public final val token: T defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'token' @ [217:77] ==> public final val token: T defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'require' @ [218:9] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'other' @ [218:17] ==> value-parameter other: Amount<T> defined in net.corda.core.contracts.Amount.checkToken[ValueParameterDescriptorImpl]

'displayTokenSize' @ [218:23] ==> public final val displayTokenSize: BigDecimal defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'displayTokenSize' @ [218:43] ==> public final val displayTokenSize: BigDecimal defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'other' @ [218:87] ==> value-parameter other: Amount<T> defined in net.corda.core.contracts.Amount.checkToken[ValueParameterDescriptorImpl]

'displayTokenSize' @ [218:93] ==> public final val displayTokenSize: BigDecimal defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'displayTokenSize' @ [218:115] ==> public final val displayTokenSize: BigDecimal defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'Amount' @ [226:50] ==> public constructor Amount<T : Any>(quantity: Long, displayTokenSize: BigDecimal, token: T) defined in net.corda.core.contracts.Amount[ClassConstructorDescriptorImpl]
Inferred types:
    <T : Any> -> T

'multiplyExact' @ [226:62] ==> public open fun multiplyExact(p0: Long, p1: Long): Long defined in java.lang.Math[JavaMethodDescriptor]

'quantity' @ [226:76] ==> public final val quantity: Long defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'other' @ [226:86] ==> value-parameter other: Long defined in net.corda.core.contracts.Amount.times[ValueParameterDescriptorImpl]

'displayTokenSize' @ [226:94] ==> public final val displayTokenSize: BigDecimal defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'token' @ [226:112] ==> public final val token: T defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'Amount' @ [233:49] ==> public constructor Amount<T : Any>(quantity: Long, displayTokenSize: BigDecimal, token: T) defined in net.corda.core.contracts.Amount[ClassConstructorDescriptorImpl]
Inferred types:
    <T : Any> -> T

'multiplyExact' @ [233:61] ==> public open fun multiplyExact(p0: Long, p1: Long): Long defined in java.lang.Math[JavaMethodDescriptor]

'quantity' @ [233:75] ==> public final val quantity: Long defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'other' @ [233:85] ==> value-parameter other: Int defined in net.corda.core.contracts.Amount.times[ValueParameterDescriptorImpl]

'toLong' @ [233:91] ==> public open fun toLong(): Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'displayTokenSize' @ [233:102] ==> public final val displayTokenSize: BigDecimal defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'token' @ [233:120] ==> public final val token: T defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'require' @ [242:9] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'partitions' @ [242:17] ==> value-parameter partitions: Int defined in net.corda.core.contracts.Amount.splitEvenly[ValueParameterDescriptorImpl]

'quantity' @ [243:40] ==> public final val quantity: Long defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'div' @ [243:49] ==> public final operator fun div(other: Int): Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor]

'partitions' @ [243:53] ==> value-parameter partitions: Int defined in net.corda.core.contracts.Amount.splitEvenly[ValueParameterDescriptorImpl]

'quantity' @ [244:30] ==> public final val quantity: Long defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'commonTokensPerPartition' @ [244:42] ==> val commonTokensPerPartition: Long defined in net.corda.core.contracts.Amount.splitEvenly[LocalVariableDescriptor]

'partitions' @ [244:69] ==> value-parameter partitions: Int defined in net.corda.core.contracts.Amount.splitEvenly[ValueParameterDescriptorImpl]

'Amount' @ [245:27] ==> public constructor Amount<T : Any>(quantity: Long, displayTokenSize: BigDecimal, token: T) defined in net.corda.core.contracts.Amount[ClassConstructorDescriptorImpl]
Inferred types:
    <T : Any> -> T

'commonTokensPerPartition' @ [245:34] ==> val commonTokensPerPartition: Long defined in net.corda.core.contracts.Amount.splitEvenly[LocalVariableDescriptor]

'displayTokenSize' @ [245:60] ==> public final val displayTokenSize: BigDecimal defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'token' @ [245:78] ==> public final val token: T defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'Amount' @ [246:34] ==> public constructor Amount<T : Any>(quantity: Long, displayTokenSize: BigDecimal, token: T) defined in net.corda.core.contracts.Amount[ClassConstructorDescriptorImpl]
Inferred types:
    <T : Any> -> T

'commonTokensPerPartition' @ [246:41] ==> val commonTokensPerPartition: Long defined in net.corda.core.contracts.Amount.splitEvenly[LocalVariableDescriptor]

'displayTokenSize' @ [246:72] ==> public final val displayTokenSize: BigDecimal defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'token' @ [246:90] ==> public final val token: T defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'..' @ [247:17] ==> public final operator fun rangeTo(other: Int): IntRange defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'partitions' @ [247:20] ==> value-parameter partitions: Int defined in net.corda.core.contracts.Amount.splitEvenly[ValueParameterDescriptorImpl]

'map' @ [247:36] ==> public inline fun <T, R> Iterable<Int>.map(transform: (Int) -> Amount<T>): List<Amount<T>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Int
    <R> -> Amount<T>

'if (it < residualTokens) splitAmountPlusOne else splitAmount' @ [247:42] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Amount<T>, elseBranch: Amount<T>): Amount<T>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Amount<T>

'it' @ [247:46] ==> value-parameter it: Int defined in net.corda.core.contracts.Amount.splitEvenly.<anonymous>[ValueParameterDescriptorImpl]

'residualTokens' @ [247:51] ==> val residualTokens: Long defined in net.corda.core.contracts.Amount.splitEvenly[LocalVariableDescriptor]

'splitAmountPlusOne' @ [247:67] ==> val splitAmountPlusOne: Amount<T> defined in net.corda.core.contracts.Amount.splitEvenly[LocalVariableDescriptor]

'splitAmount' @ [247:91] ==> val splitAmount: Amount<T> defined in net.corda.core.contracts.Amount.splitEvenly[LocalVariableDescriptor]

'toList' @ [247:105] ==> public fun <T> Iterable<Amount<T>>.toList(): List<Amount<T>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Amount<T>

'*' @ [257:35] ==> @InlineOnly public operator inline fun BigDecimal.times(other: BigDecimal): BigDecimal defined in kotlin[DeserializedSimpleFunctionDescriptor]

'valueOf' @ [257:46] ==> public open fun valueOf(p0: Long, p1: Int): (BigDecimal..BigDecimal?) defined in java.math.BigDecimal[JavaMethodDescriptor]

'quantity' @ [257:54] ==> public final val quantity: Long defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'displayTokenSize' @ [257:69] ==> public final val displayTokenSize: BigDecimal defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'toDecimal' @ [270:16] ==> public final fun toDecimal(): BigDecimal defined in net.corda.core.contracts.Amount[SimpleFunctionDescriptorImpl]

'toPlainString' @ [270:28] ==> public open fun toPlainString(): (String..String?) defined in java.math.BigDecimal[JavaMethodDescriptor]

'token' @ [270:52] ==> public final val token: T defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'checkToken' @ [275:9] ==> private final fun checkToken(other: Amount<T>): Unit defined in net.corda.core.contracts.Amount[SimpleFunctionDescriptorImpl]

'other' @ [275:20] ==> value-parameter other: Amount<T> defined in net.corda.core.contracts.Amount.compareTo[ValueParameterDescriptorImpl]

'quantity' @ [276:16] ==> public final val quantity: Long defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'compareTo' @ [276:25] ==> public open fun compareTo(other: Long): Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor]

'other' @ [276:35] ==> value-parameter other: Amount<T> defined in net.corda.core.contracts.Amount.compareTo[ValueParameterDescriptorImpl]

'quantity' @ [276:41] ==> public final val quantity: Long defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'CordaSerializable' @ [310:1] ==> public constructor CordaSerializable() defined in net.corda.core.serialization.CordaSerializable[ClassConstructorDescriptorImpl]

'JvmStatic' @ [327:9] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'JvmOverloads' @ [328:9] ==> public constructor JvmOverloads() defined in kotlin.jvm.JvmOverloads[DeserializedClassConstructorDescriptor]

'DOWN' @ [333:82] ==> enum entry DOWN defined in java.math.RoundingMode[FakeCallableDescriptorForObject]

'Amount' @ [334:29] ==> public companion object defined in net.corda.core.contracts.Amount[FakeCallableDescriptorForObject]

'getDisplayTokenSize' @ [334:36] ==> @JvmStatic public final fun getDisplayTokenSize(token: Any): BigDecimal defined in net.corda.core.contracts.Amount.Companion[SimpleFunctionDescriptorImpl]

'token' @ [334:56] ==> value-parameter token: T defined in net.corda.core.contracts.AmountTransfer.Companion.fromDecimal[ValueParameterDescriptorImpl]

'displayQuantityDelta' @ [335:35] ==> value-parameter displayQuantityDelta: BigDecimal defined in net.corda.core.contracts.AmountTransfer.Companion.fromDecimal[ValueParameterDescriptorImpl]

'divide' @ [335:56] ==> public open fun divide(p0: (BigDecimal..BigDecimal?)): (BigDecimal..BigDecimal?) defined in java.math.BigDecimal[JavaMethodDescriptor]

'tokenSize' @ [335:63] ==> val tokenSize: BigDecimal defined in net.corda.core.contracts.AmountTransfer.Companion.fromDecimal[LocalVariableDescriptor]

'setScale' @ [335:74] ==> public open fun setScale(p0: Int, p1: (RoundingMode..RoundingMode?)): (BigDecimal..BigDecimal?) defined in java.math.BigDecimal[JavaMethodDescriptor]

'rounding' @ [335:86] ==> value-parameter rounding: RoundingMode = ... defined in net.corda.core.contracts.AmountTransfer.Companion.fromDecimal[ValueParameterDescriptorImpl]

'longValueExact' @ [335:96] ==> public open fun longValueExact(): Long defined in java.math.BigDecimal[JavaMethodDescriptor]

'AmountTransfer' @ [336:20] ==> public constructor AmountTransfer<T : Any, P : Any>(quantityDelta: Long, token: T, source: P, destination: P) defined in net.corda.core.contracts.AmountTransfer[ClassConstructorDescriptorImpl]
Inferred types:
    <T : Any> -> T
    <P : Any> -> P

'deltaTokenCount' @ [336:35] ==> val deltaTokenCount: Long defined in net.corda.core.contracts.AmountTransfer.Companion.fromDecimal[LocalVariableDescriptor]

'token' @ [336:52] ==> value-parameter token: T defined in net.corda.core.contracts.AmountTransfer.Companion.fromDecimal[ValueParameterDescriptorImpl]

'source' @ [336:59] ==> value-parameter source: P defined in net.corda.core.contracts.AmountTransfer.Companion.fromDecimal[ValueParameterDescriptorImpl]

'destination' @ [336:67] ==> value-parameter destination: P defined in net.corda.core.contracts.AmountTransfer.Companion.fromDecimal[ValueParameterDescriptorImpl]

'JvmStatic' @ [340:9] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'AmountTransfer' @ [343:77] ==> public constructor AmountTransfer<T : Any, P : Any>(quantityDelta: Long, token: T, source: P, destination: P) defined in net.corda.core.contracts.AmountTransfer[ClassConstructorDescriptorImpl]
Inferred types:
    <T : Any> -> T
    <P : Any> -> P

'token' @ [343:96] ==> value-parameter token: T defined in net.corda.core.contracts.AmountTransfer.Companion.zero[ValueParameterDescriptorImpl]

'source' @ [343:103] ==> value-parameter source: P defined in net.corda.core.contracts.AmountTransfer.Companion.zero[ValueParameterDescriptorImpl]

'destination' @ [343:111] ==> value-parameter destination: P defined in net.corda.core.contracts.AmountTransfer.Companion.zero[ValueParameterDescriptorImpl]

'require' @ [347:9] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'source' @ [347:17] ==> public final val source: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'destination' @ [347:27] ==> public final val destination: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'source' @ [347:91] ==> public final val source: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'require' @ [358:9] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'other' @ [358:17] ==> value-parameter other: AmountTransfer<T, P> defined in net.corda.core.contracts.AmountTransfer.plus[ValueParameterDescriptorImpl]

'token' @ [358:23] ==> public final val token: T defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'token' @ [358:32] ==> public final val token: T defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'other' @ [358:60] ==> value-parameter other: AmountTransfer<T, P> defined in net.corda.core.contracts.AmountTransfer.plus[ValueParameterDescriptorImpl]

'token' @ [358:66] ==> public final val token: T defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'token' @ [358:77] ==> public final val token: T defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'require' @ [359:9] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'other' @ [359:18] ==> value-parameter other: AmountTransfer<T, P> defined in net.corda.core.contracts.AmountTransfer.plus[ValueParameterDescriptorImpl]

'source' @ [359:24] ==> public final val source: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'source' @ [359:34] ==> public final val source: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'other' @ [359:44] ==> value-parameter other: AmountTransfer<T, P> defined in net.corda.core.contracts.AmountTransfer.plus[ValueParameterDescriptorImpl]

'destination' @ [359:50] ==> public final val destination: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'destination' @ [359:65] ==> public final val destination: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'other' @ [360:21] ==> value-parameter other: AmountTransfer<T, P> defined in net.corda.core.contracts.AmountTransfer.plus[ValueParameterDescriptorImpl]

'source' @ [360:27] ==> public final val source: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'destination' @ [360:37] ==> public final val destination: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'other' @ [360:52] ==> value-parameter other: AmountTransfer<T, P> defined in net.corda.core.contracts.AmountTransfer.plus[ValueParameterDescriptorImpl]

'destination' @ [360:58] ==> public final val destination: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'source' @ [360:73] ==> public final val source: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'if (other.source == source) {
            AmountTransfer(quantityDelta exactAdd other.quantityDelta, token, source, destination)
        } else {
            AmountTransfer(Math.subtractExact(quantityDelta, other.quantityDelta), token, source, destination)
        }' @ [363:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: AmountTransfer<T, P>, elseBranch: AmountTransfer<T, P>): AmountTransfer<T, P>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> AmountTransfer<T, P>

'other' @ [363:20] ==> value-parameter other: AmountTransfer<T, P> defined in net.corda.core.contracts.AmountTransfer.plus[ValueParameterDescriptorImpl]

'source' @ [363:26] ==> public final val source: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'source' @ [363:36] ==> public final val source: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'AmountTransfer' @ [364:13] ==> public constructor AmountTransfer<T : Any, P : Any>(quantityDelta: Long, token: T, source: P, destination: P) defined in net.corda.core.contracts.AmountTransfer[ClassConstructorDescriptorImpl]
Inferred types:
    <T : Any> -> T
    <P : Any> -> P

'quantityDelta' @ [364:28] ==> public final val quantityDelta: Long defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'other' @ [364:51] ==> value-parameter other: AmountTransfer<T, P> defined in net.corda.core.contracts.AmountTransfer.plus[ValueParameterDescriptorImpl]

'quantityDelta' @ [364:57] ==> public final val quantityDelta: Long defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'token' @ [364:72] ==> public final val token: T defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'source' @ [364:79] ==> public final val source: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'destination' @ [364:87] ==> public final val destination: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'AmountTransfer' @ [366:13] ==> public constructor AmountTransfer<T : Any, P : Any>(quantityDelta: Long, token: T, source: P, destination: P) defined in net.corda.core.contracts.AmountTransfer[ClassConstructorDescriptorImpl]
Inferred types:
    <T : Any> -> T
    <P : Any> -> P

'subtractExact' @ [366:33] ==> public open fun subtractExact(p0: Long, p1: Long): Long defined in java.lang.Math[JavaMethodDescriptor]

'quantityDelta' @ [366:47] ==> public final val quantityDelta: Long defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'other' @ [366:62] ==> value-parameter other: AmountTransfer<T, P> defined in net.corda.core.contracts.AmountTransfer.plus[ValueParameterDescriptorImpl]

'quantityDelta' @ [366:68] ==> public final val quantityDelta: Long defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'token' @ [366:84] ==> public final val token: T defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'source' @ [366:91] ==> public final val source: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'destination' @ [366:99] ==> public final val destination: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'*' @ [374:35] ==> @InlineOnly public operator inline fun BigDecimal.times(other: BigDecimal): BigDecimal defined in kotlin[DeserializedSimpleFunctionDescriptor]

'valueOf' @ [374:46] ==> public open fun valueOf(p0: Long, p1: Int): (BigDecimal..BigDecimal?) defined in java.math.BigDecimal[JavaMethodDescriptor]

'quantityDelta' @ [374:54] ==> public final val quantityDelta: Long defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'getDisplayTokenSize' @ [374:81] ==> @JvmStatic public final fun getDisplayTokenSize(token: Any): BigDecimal defined in net.corda.core.contracts.Amount.Companion[SimpleFunctionDescriptorImpl]

'token' @ [374:101] ==> public final val token: T defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'this' @ [377:36] ==> <this> defined in net.corda.core.contracts.AmountTransfer[LazyClassReceiverParameterDescriptor]

'quantityDelta' @ [377:41] ==> public final val quantityDelta: Long defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'this' @ [378:25] ==> <this> defined in net.corda.core.contracts.AmountTransfer[LazyClassReceiverParameterDescriptor]

'token' @ [378:30] ==> public final val token: T defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'this' @ [379:26] ==> <this> defined in net.corda.core.contracts.AmountTransfer[LazyClassReceiverParameterDescriptor]

'source' @ [379:31] ==> public final val source: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'this' @ [380:31] ==> <this> defined in net.corda.core.contracts.AmountTransfer[LazyClassReceiverParameterDescriptor]

'destination' @ [380:36] ==> public final val destination: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'AmountTransfer' @ [380:73] ==> public constructor AmountTransfer<T : Any, P : Any>(quantityDelta: Long, token: T, source: P, destination: P) defined in net.corda.core.contracts.AmountTransfer[ClassConstructorDescriptorImpl]
Inferred types:
    <T : Any> -> T
    <P : Any> -> P

'quantityDelta' @ [380:88] ==> value-parameter quantityDelta: Long = ... defined in net.corda.core.contracts.AmountTransfer.copy[ValueParameterDescriptorImpl]

'token' @ [380:103] ==> value-parameter token: T = ... defined in net.corda.core.contracts.AmountTransfer.copy[ValueParameterDescriptorImpl]

'source' @ [380:110] ==> value-parameter source: P = ... defined in net.corda.core.contracts.AmountTransfer.copy[ValueParameterDescriptorImpl]

'destination' @ [380:118] ==> value-parameter destination: P = ... defined in net.corda.core.contracts.AmountTransfer.copy[ValueParameterDescriptorImpl]

'this' @ [386:13] ==> <this> defined in net.corda.core.contracts.AmountTransfer[LazyClassReceiverParameterDescriptor]

'other' @ [386:22] ==> value-parameter other: Any? defined in net.corda.core.contracts.AmountTransfer.equals[ValueParameterDescriptorImpl]

'other' @ [387:13] ==> value-parameter other: Any? defined in net.corda.core.contracts.AmountTransfer.equals[ValueParameterDescriptorImpl]

'javaClass' @ [387:20] ==> public val <T : Any> Any.javaClass: Class<Any> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> Any

'javaClass' @ [387:33] ==> public val <T : Any> AmountTransfer<T, P>.javaClass: Class<AmountTransfer<T, P>> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> AmountTransfer<T, P>

'other' @ [389:9] ==> value-parameter other: Any? defined in net.corda.core.contracts.AmountTransfer.equals[ValueParameterDescriptorImpl]

'token' @ [391:13] ==> public final val token: T defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'other' @ [391:22] ==> value-parameter other: Any? defined in net.corda.core.contracts.AmountTransfer.equals[ValueParameterDescriptorImpl]

'token' @ [391:28] ==> public final val token: Any defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'if (source == other.source) {
            if (destination != other.destination) return false
            if (quantityDelta != other.quantityDelta) return false
            return true
        } else if (source == other.destination) {
            if (destination != other.source) return false
            if (quantityDelta != -other.quantityDelta) return false
            return true
        }' @ [392:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'source' @ [392:13] ==> public final val source: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'other' @ [392:23] ==> value-parameter other: Any? defined in net.corda.core.contracts.AmountTransfer.equals[ValueParameterDescriptorImpl]

'source' @ [392:29] ==> public final val source: Any defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'destination' @ [393:17] ==> public final val destination: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'other' @ [393:32] ==> value-parameter other: Any? defined in net.corda.core.contracts.AmountTransfer.equals[ValueParameterDescriptorImpl]

'destination' @ [393:38] ==> public final val destination: Any defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'quantityDelta' @ [394:17] ==> public final val quantityDelta: Long defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'other' @ [394:34] ==> value-parameter other: Any? defined in net.corda.core.contracts.AmountTransfer.equals[ValueParameterDescriptorImpl]

'quantityDelta' @ [394:40] ==> public final val quantityDelta: Long defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'source' @ [396:20] ==> public final val source: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'other' @ [396:30] ==> value-parameter other: Any? defined in net.corda.core.contracts.AmountTransfer.equals[ValueParameterDescriptorImpl]

'destination' @ [396:36] ==> public final val destination: Any defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'destination' @ [397:17] ==> public final val destination: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'other' @ [397:32] ==> value-parameter other: Any? defined in net.corda.core.contracts.AmountTransfer.equals[ValueParameterDescriptorImpl]

'source' @ [397:38] ==> public final val source: Any defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'quantityDelta' @ [398:17] ==> public final val quantityDelta: Long defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'-' @ [398:34] ==> public final operator fun unaryMinus(): Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor]

'other' @ [398:35] ==> value-parameter other: Any? defined in net.corda.core.contracts.AmountTransfer.equals[ValueParameterDescriptorImpl]

'quantityDelta' @ [398:41] ==> public final val quantityDelta: Long defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'abs' @ [409:27] ==> public open fun abs(p0: Long): Long defined in java.lang.Math[JavaMethodDescriptor]

'quantityDelta' @ [409:31] ==> public final val quantityDelta: Long defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'hashCode' @ [409:46] ==> public open fun hashCode(): Int defined in kotlin.Long[DeserializedSimpleFunctionDescriptor]

'result' @ [410:9] ==> var result: Int defined in net.corda.core.contracts.AmountTransfer.hashCode[LocalVariableDescriptor]

'*' @ [410:18] ==> public final operator fun times(other: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'result' @ [410:23] ==> var result: Int defined in net.corda.core.contracts.AmountTransfer.hashCode[LocalVariableDescriptor]

'token' @ [410:32] ==> public final val token: T defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'hashCode' @ [410:38] ==> public open fun hashCode(): Int defined in kotlin.Any[DeserializedSimpleFunctionDescriptor]

'result' @ [411:9] ==> var result: Int defined in net.corda.core.contracts.AmountTransfer.hashCode[LocalVariableDescriptor]

'*' @ [411:18] ==> public final operator fun times(other: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'result' @ [411:23] ==> var result: Int defined in net.corda.core.contracts.AmountTransfer.hashCode[LocalVariableDescriptor]

'source' @ [411:33] ==> public final val source: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'hashCode' @ [411:40] ==> public open fun hashCode(): Int defined in kotlin.Any[DeserializedSimpleFunctionDescriptor]

'destination' @ [411:55] ==> public final val destination: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'hashCode' @ [411:67] ==> public open fun hashCode(): Int defined in kotlin.Any[DeserializedSimpleFunctionDescriptor]

'result' @ [412:16] ==> var result: Int defined in net.corda.core.contracts.AmountTransfer.hashCode[LocalVariableDescriptor]

'source' @ [417:32] ==> public final val source: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'destination' @ [417:43] ==> public final val destination: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'this' @ [417:60] ==> <this> defined in net.corda.core.contracts.AmountTransfer[LazyClassReceiverParameterDescriptor]

'toDecimal' @ [417:65] ==> public final fun toDecimal(): BigDecimal defined in net.corda.core.contracts.AmountTransfer[SimpleFunctionDescriptorImpl]

'toPlainString' @ [417:77] ==> public open fun toPlainString(): (String..String?) defined in java.math.BigDecimal[JavaMethodDescriptor]

'token' @ [417:95] ==> public final val token: T defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'Suppress' @ [428:5] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'listOf' @ [429:63] ==> public fun <T> listOf(vararg elements: AmountTransfer<T, P>): List<AmountTransfer<T, P>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> AmountTransfer<T, P>

'copy' @ [429:70] ==> public final fun copy(quantityDelta: Long = ..., token: T = ..., source: P = ..., destination: P = ...): AmountTransfer<T, P> defined in net.corda.core.contracts.AmountTransfer[SimpleFunctionDescriptorImpl]

'centralParty' @ [429:89] ==> value-parameter centralParty: P defined in net.corda.core.contracts.AmountTransfer.novate[ValueParameterDescriptorImpl]

'copy' @ [429:104] ==> public final fun copy(quantityDelta: Long = ..., token: T = ..., source: P = ..., destination: P = ...): AmountTransfer<T, P> defined in net.corda.core.contracts.AmountTransfer[SimpleFunctionDescriptorImpl]

'centralParty' @ [429:118] ==> value-parameter centralParty: P defined in net.corda.core.contracts.AmountTransfer.novate[ValueParameterDescriptorImpl]

'component1' @ [443:14] ==> public final operator fun component1(): P defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [443:21] ==> public final operator fun component2(): P defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'if (quantityDelta >= 0L) Pair(source, destination) else Pair(destination, source)' @ [443:30] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Pair<P, P>, elseBranch: Pair<P, P>): Pair<P, P>[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Pair<P, P>

'quantityDelta' @ [443:34] ==> public final val quantityDelta: Long defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'Pair' @ [443:55] ==> public constructor Pair<out A, out B>(first: P, second: P) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> P
    <out B> -> P

'source' @ [443:60] ==> public final val source: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'destination' @ [443:68] ==> public final val destination: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'Pair' @ [443:86] ==> public constructor Pair<out A, out B>(first: P, second: P) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> P
    <out B> -> P

'destination' @ [443:91] ==> public final val destination: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'source' @ [443:104] ==> public final val source: P defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'abs' @ [444:29] ==> public open fun abs(p0: Long): Long defined in java.lang.Math[JavaMethodDescriptor]

'quantityDelta' @ [444:33] ==> public final val quantityDelta: Long defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'transfer' @ [445:24] ==> val transfer: Long defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'mutableListOf' @ [446:23] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableListOf(): MutableList<SourceAndAmount<T, P>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SourceAndAmount<T, P>

'balances' @ [449:25] ==> value-parameter balances: List<SourceAndAmount<T, P>> defined in net.corda.core.contracts.AmountTransfer.apply[ValueParameterDescriptorImpl]

'if (balance.source != payer
                    || balance.amount.token != token
                    || residual == 0L) {
                // Just copy across unmodified.
                outputs += balance
            } else if (balance.amount.quantity < residual) {
                // Consume the payers amount and do not copy across.
                residual -= balance.amount.quantity
            } else {
                // Calculate any residual spend left on the payers balance.
                if (balance.amount.quantity > residual) {
                    remaining = SourceAndAmount(payer, balance.amount.copy(quantity = Math.subtractExact(balance.amount.quantity, residual)), newRef)
                }
                // Build the new output payment to the payee.
                newAmount = SourceAndAmount(payee, balance.amount.copy(quantity = transfer), newRef)
                // Clear the residual.
                residual = 0L
            }' @ [450:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'balance' @ [450:17] ==> val balance: SourceAndAmount<T, P> defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'source' @ [450:25] ==> public final val source: P defined in net.corda.core.contracts.SourceAndAmount[PropertyDescriptorImpl]

'payer' @ [450:35] ==> val payer: P defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'balance' @ [451:24] ==> val balance: SourceAndAmount<T, P> defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'amount' @ [451:32] ==> public final val amount: Amount<T> defined in net.corda.core.contracts.SourceAndAmount[PropertyDescriptorImpl]

'token' @ [451:39] ==> public final val token: T defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'token' @ [451:48] ==> public final val token: T defined in net.corda.core.contracts.AmountTransfer[PropertyDescriptorImpl]

'residual' @ [452:24] ==> var residual: Long defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'outputs' @ [454:17] ==> val outputs: MutableList<SourceAndAmount<T, P>> defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'balance' @ [454:28] ==> val balance: SourceAndAmount<T, P> defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'if (balance.amount.quantity < residual) {
                // Consume the payers amount and do not copy across.
                residual -= balance.amount.quantity
            } else {
                // Calculate any residual spend left on the payers balance.
                if (balance.amount.quantity > residual) {
                    remaining = SourceAndAmount(payer, balance.amount.copy(quantity = Math.subtractExact(balance.amount.quantity, residual)), newRef)
                }
                // Build the new output payment to the payee.
                newAmount = SourceAndAmount(payee, balance.amount.copy(quantity = transfer), newRef)
                // Clear the residual.
                residual = 0L
            }' @ [455:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'balance' @ [455:24] ==> val balance: SourceAndAmount<T, P> defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'amount' @ [455:32] ==> public final val amount: Amount<T> defined in net.corda.core.contracts.SourceAndAmount[PropertyDescriptorImpl]

'quantity' @ [455:39] ==> public final val quantity: Long defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'residual' @ [455:50] ==> var residual: Long defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'residual' @ [457:17] ==> var residual: Long defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'balance' @ [457:29] ==> val balance: SourceAndAmount<T, P> defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'amount' @ [457:37] ==> public final val amount: Amount<T> defined in net.corda.core.contracts.SourceAndAmount[PropertyDescriptorImpl]

'quantity' @ [457:44] ==> public final val quantity: Long defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'balance' @ [460:21] ==> val balance: SourceAndAmount<T, P> defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'amount' @ [460:29] ==> public final val amount: Amount<T> defined in net.corda.core.contracts.SourceAndAmount[PropertyDescriptorImpl]

'quantity' @ [460:36] ==> public final val quantity: Long defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'residual' @ [460:47] ==> var residual: Long defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'remaining' @ [461:21] ==> var remaining: SourceAndAmount<T, P>? defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'SourceAndAmount' @ [461:33] ==> public constructor SourceAndAmount<T : Any, out P : Any>(source: P, amount: Amount<T>, ref: Any? = ...) defined in net.corda.core.contracts.SourceAndAmount[ClassConstructorDescriptorImpl]
Inferred types:
    <T : Any> -> T
    <out P : Any> -> P

'payer' @ [461:49] ==> val payer: P defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'balance' @ [461:56] ==> val balance: SourceAndAmount<T, P> defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'amount' @ [461:64] ==> public final val amount: Amount<T> defined in net.corda.core.contracts.SourceAndAmount[PropertyDescriptorImpl]

'copy' @ [461:71] ==> public final fun copy(quantity: Long = ..., displayTokenSize: BigDecimal = ..., token: T = ...): Amount<T> defined in net.corda.core.contracts.Amount[SimpleFunctionDescriptorImpl]

'subtractExact' @ [461:92] ==> public open fun subtractExact(p0: Long, p1: Long): Long defined in java.lang.Math[JavaMethodDescriptor]

'balance' @ [461:106] ==> val balance: SourceAndAmount<T, P> defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'amount' @ [461:114] ==> public final val amount: Amount<T> defined in net.corda.core.contracts.SourceAndAmount[PropertyDescriptorImpl]

'quantity' @ [461:121] ==> public final val quantity: Long defined in net.corda.core.contracts.Amount[PropertyDescriptorImpl]

'residual' @ [461:131] ==> var residual: Long defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'newRef' @ [461:143] ==> value-parameter newRef: Any? = ... defined in net.corda.core.contracts.AmountTransfer.apply[ValueParameterDescriptorImpl]

'newAmount' @ [464:17] ==> var newAmount: SourceAndAmount<T, P>? defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'SourceAndAmount' @ [464:29] ==> public constructor SourceAndAmount<T : Any, out P : Any>(source: P, amount: Amount<T>, ref: Any? = ...) defined in net.corda.core.contracts.SourceAndAmount[ClassConstructorDescriptorImpl]
Inferred types:
    <T : Any> -> T
    <out P : Any> -> P

'payee' @ [464:45] ==> val payee: P defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'balance' @ [464:52] ==> val balance: SourceAndAmount<T, P> defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'amount' @ [464:60] ==> public final val amount: Amount<T> defined in net.corda.core.contracts.SourceAndAmount[PropertyDescriptorImpl]

'copy' @ [464:67] ==> public final fun copy(quantity: Long = ..., displayTokenSize: BigDecimal = ..., token: T = ...): Amount<T> defined in net.corda.core.contracts.Amount[SimpleFunctionDescriptorImpl]

'transfer' @ [464:83] ==> val transfer: Long defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'newRef' @ [464:94] ==> value-parameter newRef: Any? = ... defined in net.corda.core.contracts.AmountTransfer.apply[ValueParameterDescriptorImpl]

'residual' @ [466:17] ==> var residual: Long defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'require' @ [469:9] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'residual' @ [469:17] ==> var residual: Long defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'this' @ [469:75] ==> <this> defined in net.corda.core.contracts.AmountTransfer[LazyClassReceiverParameterDescriptor]

'remaining' @ [470:13] ==> var remaining: SourceAndAmount<T, P>? defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'outputs' @ [471:13] ==> val outputs: MutableList<SourceAndAmount<T, P>> defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'remaining' @ [471:24] ==> var remaining: SourceAndAmount<T, P>? defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'outputs' @ [473:9] ==> val outputs: MutableList<SourceAndAmount<T, P>> defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'newAmount' @ [473:20] ==> var newAmount: SourceAndAmount<T, P>? defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

'outputs' @ [474:16] ==> val outputs: MutableList<SourceAndAmount<T, P>> defined in net.corda.core.contracts.AmountTransfer.apply[LocalVariableDescriptor]

