'JvmField' @ [73:5] ==> public constructor JvmField() defined in kotlin.jvm.JvmField[DeserializedClassConstructorDescriptor]

'SignatureScheme' @ [74:22] ==> public constructor SignatureScheme(schemeNumberID: Int, schemeCodeName: String, signatureOID: AlgorithmIdentifier, alternativeOIDs: List<AlgorithmIdentifier>, providerName: String, algorithmName: String, signatureName: String, algSpec: AlgorithmParameterSpec?, keySize: Int?, desc: String) defined in net.corda.core.crypto.SignatureScheme[ClassConstructorDescriptorImpl]

'AlgorithmIdentifier' @ [77:13] ==> public constructor AlgorithmIdentifier(p0: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?), p1: (ASN1Encodable..ASN1Encodable?)) defined in org.bouncycastle.asn1.x509.AlgorithmIdentifier[JavaClassConstructorDescriptor]

'rsaEncryption' @ [77:55] ==> public final val rsaEncryption: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?) defined in org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers[JavaPropertyDescriptor]

'emptyList' @ [78:13] ==> public fun <T> emptyList(): List<AlgorithmIdentifier> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> AlgorithmIdentifier

'PROVIDER_NAME' @ [79:34] ==> public const final val PROVIDER_NAME: String defined in org.bouncycastle.jce.provider.BouncyCastleProvider[JavaPropertyDescriptor]

'JvmField' @ [88:5] ==> public constructor JvmField() defined in kotlin.jvm.JvmField[DeserializedClassConstructorDescriptor]

'SignatureScheme' @ [89:34] ==> public constructor SignatureScheme(schemeNumberID: Int, schemeCodeName: String, signatureOID: AlgorithmIdentifier, alternativeOIDs: List<AlgorithmIdentifier>, providerName: String, algorithmName: String, signatureName: String, algSpec: AlgorithmParameterSpec?, keySize: Int?, desc: String) defined in net.corda.core.crypto.SignatureScheme[ClassConstructorDescriptorImpl]

'AlgorithmIdentifier' @ [92:13] ==> public constructor AlgorithmIdentifier(p0: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?), p1: (ASN1Encodable..ASN1Encodable?)) defined in org.bouncycastle.asn1.x509.AlgorithmIdentifier[JavaClassConstructorDescriptor]

'ecdsa_with_SHA256' @ [92:53] ==> public final val ecdsa_with_SHA256: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?) defined in org.bouncycastle.asn1.x9.X9ObjectIdentifiers[JavaPropertyDescriptor]

'secp256k1' @ [92:93] ==> public final val secp256k1: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?) defined in org.bouncycastle.asn1.sec.SECObjectIdentifiers[JavaPropertyDescriptor]

'listOf' @ [93:13] ==> public fun <T> listOf(element: AlgorithmIdentifier): List<AlgorithmIdentifier> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> AlgorithmIdentifier

'AlgorithmIdentifier' @ [93:20] ==> public constructor AlgorithmIdentifier(p0: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?), p1: (ASN1Encodable..ASN1Encodable?)) defined in org.bouncycastle.asn1.x509.AlgorithmIdentifier[JavaClassConstructorDescriptor]

'id_ecPublicKey' @ [93:60] ==> public final val id_ecPublicKey: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?) defined in org.bouncycastle.asn1.x9.X9ObjectIdentifiers[JavaPropertyDescriptor]

'secp256k1' @ [93:97] ==> public final val secp256k1: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?) defined in org.bouncycastle.asn1.sec.SECObjectIdentifiers[JavaPropertyDescriptor]

'PROVIDER_NAME' @ [94:34] ==> public const final val PROVIDER_NAME: String defined in org.bouncycastle.jce.provider.BouncyCastleProvider[JavaPropertyDescriptor]

'getParameterSpec' @ [97:31] ==> public open fun getParameterSpec(p0: (String..String?)): (ECNamedCurveParameterSpec..ECNamedCurveParameterSpec?) defined in org.bouncycastle.jce.ECNamedCurveTable[JavaMethodDescriptor]

'JvmField' @ [103:5] ==> public constructor JvmField() defined in kotlin.jvm.JvmField[DeserializedClassConstructorDescriptor]

'SignatureScheme' @ [104:34] ==> public constructor SignatureScheme(schemeNumberID: Int, schemeCodeName: String, signatureOID: AlgorithmIdentifier, alternativeOIDs: List<AlgorithmIdentifier>, providerName: String, algorithmName: String, signatureName: String, algSpec: AlgorithmParameterSpec?, keySize: Int?, desc: String) defined in net.corda.core.crypto.SignatureScheme[ClassConstructorDescriptorImpl]

'AlgorithmIdentifier' @ [107:13] ==> public constructor AlgorithmIdentifier(p0: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?), p1: (ASN1Encodable..ASN1Encodable?)) defined in org.bouncycastle.asn1.x509.AlgorithmIdentifier[JavaClassConstructorDescriptor]

'ecdsa_with_SHA256' @ [107:53] ==> public final val ecdsa_with_SHA256: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?) defined in org.bouncycastle.asn1.x9.X9ObjectIdentifiers[JavaPropertyDescriptor]

'secp256r1' @ [107:93] ==> public final val secp256r1: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?) defined in org.bouncycastle.asn1.sec.SECObjectIdentifiers[JavaPropertyDescriptor]

'listOf' @ [108:13] ==> public fun <T> listOf(element: AlgorithmIdentifier): List<AlgorithmIdentifier> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> AlgorithmIdentifier

'AlgorithmIdentifier' @ [108:20] ==> public constructor AlgorithmIdentifier(p0: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?), p1: (ASN1Encodable..ASN1Encodable?)) defined in org.bouncycastle.asn1.x509.AlgorithmIdentifier[JavaClassConstructorDescriptor]

'id_ecPublicKey' @ [108:60] ==> public final val id_ecPublicKey: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?) defined in org.bouncycastle.asn1.x9.X9ObjectIdentifiers[JavaPropertyDescriptor]

'secp256r1' @ [108:97] ==> public final val secp256r1: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?) defined in org.bouncycastle.asn1.sec.SECObjectIdentifiers[JavaPropertyDescriptor]

'PROVIDER_NAME' @ [109:34] ==> public const final val PROVIDER_NAME: String defined in org.bouncycastle.jce.provider.BouncyCastleProvider[JavaPropertyDescriptor]

'getParameterSpec' @ [112:31] ==> public open fun getParameterSpec(p0: (String..String?)): (ECNamedCurveParameterSpec..ECNamedCurveParameterSpec?) defined in org.bouncycastle.jce.ECNamedCurveTable[JavaMethodDescriptor]

'JvmField' @ [118:5] ==> public constructor JvmField() defined in kotlin.jvm.JvmField[DeserializedClassConstructorDescriptor]

'SignatureScheme' @ [119:32] ==> public constructor SignatureScheme(schemeNumberID: Int, schemeCodeName: String, signatureOID: AlgorithmIdentifier, alternativeOIDs: List<AlgorithmIdentifier>, providerName: String, algorithmName: String, signatureName: String, algSpec: AlgorithmParameterSpec?, keySize: Int?, desc: String) defined in net.corda.core.crypto.SignatureScheme[ClassConstructorDescriptorImpl]

'AlgorithmIdentifier' @ [123:13] ==> public constructor AlgorithmIdentifier(p0: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?), p1: (ASN1Encodable..ASN1Encodable?)) defined in org.bouncycastle.asn1.x509.AlgorithmIdentifier[JavaClassConstructorDescriptor]

'ASN1ObjectIdentifier' @ [123:33] ==> public constructor ASN1ObjectIdentifier(p0: (String..String?)) defined in org.bouncycastle.asn1.ASN1ObjectIdentifier[JavaClassConstructorDescriptor]

'emptyList' @ [124:13] ==> public fun <T> emptyList(): List<AlgorithmIdentifier> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> AlgorithmIdentifier

'PROVIDER_NAME' @ [126:34] ==> public const final val PROVIDER_NAME: String defined in org.bouncycastle.jce.provider.BouncyCastleProvider[JavaPropertyDescriptor]

'SIGNATURE_ALGORITHM' @ [128:25] ==> public const final val SIGNATURE_ALGORITHM: String defined in net.i2p.crypto.eddsa.EdDSAEngine[JavaPropertyDescriptor]

'getByName' @ [129:34] ==> public open fun getByName(p0: (String..String?)): (EdDSANamedCurveSpec..EdDSANamedCurveSpec?) defined in net.i2p.crypto.eddsa.spec.EdDSANamedCurveTable[JavaMethodDescriptor]

'JvmField' @ [138:5] ==> public constructor JvmField() defined in kotlin.jvm.JvmField[DeserializedClassConstructorDescriptor]

'DLSequence' @ [139:22] ==> public constructor DLSequence(p0: (Array<(ASN1Encodable..ASN1Encodable?)>..Array<out (ASN1Encodable..ASN1Encodable?)>?)) defined in org.bouncycastle.asn1.DLSequence[JavaClassConstructorDescriptor]

'arrayOf' @ [139:33] ==> public inline fun <reified @PureReifiable T> arrayOf(vararg elements: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?)): Array<(ASN1ObjectIdentifier..ASN1ObjectIdentifier?)> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified @PureReifiable T> -> (org.bouncycastle.asn1.ASN1ObjectIdentifier..org.bouncycastle.asn1.ASN1ObjectIdentifier?)

'id_sha512_256' @ [139:63] ==> public final val id_sha512_256: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?) defined in org.bouncycastle.asn1.nist.NISTObjectIdentifiers[JavaPropertyDescriptor]

'JvmField' @ [141:5] ==> public constructor JvmField() defined in kotlin.jvm.JvmField[DeserializedClassConstructorDescriptor]

'SignatureScheme' @ [142:29] ==> public constructor SignatureScheme(schemeNumberID: Int, schemeCodeName: String, signatureOID: AlgorithmIdentifier, alternativeOIDs: List<AlgorithmIdentifier>, providerName: String, algorithmName: String, signatureName: String, algSpec: AlgorithmParameterSpec?, keySize: Int?, desc: String) defined in net.corda.core.crypto.SignatureScheme[ClassConstructorDescriptorImpl]

'AlgorithmIdentifier' @ [145:13] ==> public constructor AlgorithmIdentifier(p0: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?), p1: (ASN1Encodable..ASN1Encodable?)) defined in org.bouncycastle.asn1.x509.AlgorithmIdentifier[JavaClassConstructorDescriptor]

'sphincs256_with_SHA512' @ [145:53] ==> public final val sphincs256_with_SHA512: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?) defined in org.bouncycastle.asn1.bc.BCObjectIdentifiers[JavaPropertyDescriptor]

'DLSequence' @ [145:77] ==> public constructor DLSequence(p0: (Array<(ASN1Encodable..ASN1Encodable?)>..Array<out (ASN1Encodable..ASN1Encodable?)>?)) defined in org.bouncycastle.asn1.DLSequence[JavaClassConstructorDescriptor]

'arrayOf' @ [145:88] ==> public inline fun <reified @PureReifiable T> arrayOf(vararg elements: ASN1Primitive): Array<ASN1Primitive> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified @PureReifiable T> -> ASN1Primitive

'ASN1Integer' @ [145:96] ==> public constructor ASN1Integer(p0: Long) defined in org.bouncycastle.asn1.ASN1Integer[JavaClassConstructorDescriptor]

'SHA512_256' @ [145:112] ==> @JvmField public final val SHA512_256: DLSequence defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'listOf' @ [146:13] ==> public fun <T> listOf(element: AlgorithmIdentifier): List<AlgorithmIdentifier> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> AlgorithmIdentifier

'AlgorithmIdentifier' @ [146:20] ==> public constructor AlgorithmIdentifier(p0: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?), p1: (ASN1Encodable..ASN1Encodable?)) defined in org.bouncycastle.asn1.x509.AlgorithmIdentifier[JavaClassConstructorDescriptor]

'sphincs256' @ [146:60] ==> public final val sphincs256: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?) defined in org.bouncycastle.asn1.bc.BCObjectIdentifiers[JavaPropertyDescriptor]

'DLSequence' @ [146:72] ==> public constructor DLSequence(p0: (Array<(ASN1Encodable..ASN1Encodable?)>..Array<out (ASN1Encodable..ASN1Encodable?)>?)) defined in org.bouncycastle.asn1.DLSequence[JavaClassConstructorDescriptor]

'arrayOf' @ [146:83] ==> public inline fun <reified @PureReifiable T> arrayOf(vararg elements: ASN1Primitive): Array<ASN1Primitive> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified @PureReifiable T> -> ASN1Primitive

'ASN1Integer' @ [146:91] ==> public constructor ASN1Integer(p0: Long) defined in org.bouncycastle.asn1.ASN1Integer[JavaClassConstructorDescriptor]

'SHA512_256' @ [146:107] ==> @JvmField public final val SHA512_256: DLSequence defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'SPHINCS256KeyGenParameterSpec' @ [150:13] ==> public constructor SPHINCS256KeyGenParameterSpec(p0: (String..String?)) defined in org.bouncycastle.pqc.jcajce.spec.SPHINCS256KeyGenParameterSpec[JavaClassConstructorDescriptor]

'SHA512_256' @ [150:73] ==> public const final val SHA512_256: String defined in org.bouncycastle.pqc.jcajce.spec.SPHINCS256KeyGenParameterSpec[JavaPropertyDescriptor]

'+' @ [152:13] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'JvmField' @ [157:5] ==> public constructor JvmField() defined in kotlin.jvm.JvmField[DeserializedClassConstructorDescriptor]

'SignatureScheme' @ [158:25] ==> public constructor SignatureScheme(schemeNumberID: Int, schemeCodeName: String, signatureOID: AlgorithmIdentifier, alternativeOIDs: List<AlgorithmIdentifier>, providerName: String, algorithmName: String, signatureName: String, algSpec: AlgorithmParameterSpec?, keySize: Int?, desc: String) defined in net.corda.core.crypto.SignatureScheme[ClassConstructorDescriptorImpl]

'AlgorithmIdentifier' @ [161:13] ==> public constructor AlgorithmIdentifier(p0: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?)) defined in org.bouncycastle.asn1.x509.AlgorithmIdentifier[JavaClassConstructorDescriptor]

'CordaObjectIdentifier' @ [161:33] ==> public object CordaObjectIdentifier defined in net.corda.core.crypto.provider in file CordaSecurityProvider.kt[FakeCallableDescriptorForObject]

'COMPOSITE_KEY' @ [161:55] ==> @JvmField public final val COMPOSITE_KEY: ASN1ObjectIdentifier defined in net.corda.core.crypto.provider.CordaObjectIdentifier[PropertyDescriptorImpl]

'emptyList' @ [162:13] ==> public fun <T> emptyList(): List<AlgorithmIdentifier> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> AlgorithmIdentifier

'CordaSecurityProvider' @ [163:13] ==> public companion object defined in net.corda.core.crypto.provider.CordaSecurityProvider[FakeCallableDescriptorForObject]

'PROVIDER_NAME' @ [163:35] ==> public const final val PROVIDER_NAME: String defined in net.corda.core.crypto.provider.CordaSecurityProvider.Companion[PropertyDescriptorImpl]

'CompositeKey' @ [164:13] ==> public companion object defined in net.corda.core.crypto.composite.CompositeKey[FakeCallableDescriptorForObject]

'KEY_ALGORITHM' @ [164:26] ==> public final val KEY_ALGORITHM: String defined in net.corda.core.crypto.composite.CompositeKey.Companion[PropertyDescriptorImpl]

'CompositeSignature' @ [165:13] ==> public companion object defined in net.corda.core.crypto.composite.CompositeSignature[FakeCallableDescriptorForObject]

'SIGNATURE_ALGORITHM' @ [165:32] ==> public const final val SIGNATURE_ALGORITHM: String defined in net.corda.core.crypto.composite.CompositeSignature.Companion[PropertyDescriptorImpl]

'JvmField' @ [172:5] ==> public constructor JvmField() defined in kotlin.jvm.JvmField[DeserializedClassConstructorDescriptor]

'EDDSA_ED25519_SHA512' @ [173:36] ==> @JvmField public final val EDDSA_ED25519_SHA512: SignatureScheme defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'listOf' @ [179:68] ==> public fun <T> listOf(vararg elements: SignatureScheme): List<SignatureScheme> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SignatureScheme

'RSA_SHA256' @ [180:13] ==> @JvmField public final val RSA_SHA256: SignatureScheme defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'ECDSA_SECP256K1_SHA256' @ [181:13] ==> @JvmField public final val ECDSA_SECP256K1_SHA256: SignatureScheme defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'ECDSA_SECP256R1_SHA256' @ [182:13] ==> @JvmField public final val ECDSA_SECP256R1_SHA256: SignatureScheme defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'EDDSA_ED25519_SHA512' @ [183:13] ==> @JvmField public final val EDDSA_ED25519_SHA512: SignatureScheme defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'SPHINCS256_SHA256' @ [184:13] ==> @JvmField public final val SPHINCS256_SHA256: SignatureScheme defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'COMPOSITE_KEY' @ [185:13] ==> @JvmField public final val COMPOSITE_KEY: SignatureScheme defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'associateBy' @ [186:7] ==> public inline fun <T, K> Iterable<SignatureScheme>.associateBy(keySelector: (SignatureScheme) -> String): Map<String, SignatureScheme> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SignatureScheme
    <K> -> String

'it' @ [186:21] ==> value-parameter it: SignatureScheme defined in net.corda.core.crypto.Crypto.signatureSchemeMap.<anonymous>[ValueParameterDescriptorImpl]

'schemeCodeName' @ [186:24] ==> public final val schemeCodeName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'signatureSchemeMap' @ [193:16] ==> private final val signatureSchemeMap: Map<String, SignatureScheme> defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'values' @ [193:35] ==> public abstract val values: Collection<SignatureScheme> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'flatMap' @ [193:42] ==> public inline fun <T, R> Iterable<SignatureScheme>.flatMap(transform: (SignatureScheme) -> Iterable<Pair<AlgorithmIdentifier, SignatureScheme>>): List<Pair<AlgorithmIdentifier, SignatureScheme>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SignatureScheme
    <R> -> Pair<AlgorithmIdentifier, SignatureScheme>

'scheme' @ [193:62] ==> value-parameter scheme: SignatureScheme defined in net.corda.core.crypto.Crypto.algorithmMap.<anonymous>[ValueParameterDescriptorImpl]

'alternativeOIDs' @ [193:69] ==> public final val alternativeOIDs: List<AlgorithmIdentifier> defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'map' @ [193:85] ==> public inline fun <T, R> Iterable<AlgorithmIdentifier>.map(transform: (AlgorithmIdentifier) -> Pair<AlgorithmIdentifier, SignatureScheme>): List<Pair<AlgorithmIdentifier, SignatureScheme>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> AlgorithmIdentifier
    <R> -> Pair<AlgorithmIdentifier, SignatureScheme>

'Pair' @ [193:91] ==> public constructor Pair<out A, out B>(first: AlgorithmIdentifier, second: SignatureScheme) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> AlgorithmIdentifier
    <out B> -> SignatureScheme

'it' @ [193:96] ==> value-parameter it: AlgorithmIdentifier defined in net.corda.core.crypto.Crypto.algorithmMap.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'scheme' @ [193:100] ==> value-parameter scheme: SignatureScheme defined in net.corda.core.crypto.Crypto.algorithmMap.<anonymous>[ValueParameterDescriptorImpl]

'signatureSchemeMap' @ [194:15] ==> private final val signatureSchemeMap: Map<String, SignatureScheme> defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'values' @ [194:34] ==> public abstract val values: Collection<SignatureScheme> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'map' @ [194:41] ==> public inline fun <T, R> Iterable<SignatureScheme>.map(transform: (SignatureScheme) -> Pair<AlgorithmIdentifier, SignatureScheme>): List<Pair<AlgorithmIdentifier, SignatureScheme>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SignatureScheme
    <R> -> Pair<AlgorithmIdentifier, SignatureScheme>

'Pair' @ [194:47] ==> public constructor Pair<out A, out B>(first: AlgorithmIdentifier, second: SignatureScheme) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> AlgorithmIdentifier
    <out B> -> SignatureScheme

'it' @ [194:52] ==> value-parameter it: SignatureScheme defined in net.corda.core.crypto.Crypto.algorithmMap.<anonymous>[ValueParameterDescriptorImpl]

'signatureOID' @ [194:55] ==> public final val signatureOID: AlgorithmIdentifier defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'it' @ [194:69] ==> value-parameter it: SignatureScheme defined in net.corda.core.crypto.Crypto.algorithmMap.<anonymous>[ValueParameterDescriptorImpl]

'toMap' @ [195:14] ==> public fun <K, V> Iterable<Pair<AlgorithmIdentifier, SignatureScheme>>.toMap(): Map<AlgorithmIdentifier, SignatureScheme> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> AlgorithmIdentifier
    <V> -> SignatureScheme

'mapOf' @ [201:54] ==> public fun <K, V> mapOf(vararg pairs: Pair<String, Provider>): Map<String, Provider> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> String
    <V> -> Provider

'to' @ [202:13] ==> public infix fun <A, B> String.to(that: BouncyCastleProvider): Pair<String, BouncyCastleProvider> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> BouncyCastleProvider

'PROVIDER_NAME' @ [202:34] ==> public const final val PROVIDER_NAME: String defined in org.bouncycastle.jce.provider.BouncyCastleProvider[JavaPropertyDescriptor]

'getBouncyCastleProvider' @ [202:51] ==> private final fun getBouncyCastleProvider(): BouncyCastleProvider defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'CordaSecurityProvider' @ [203:13] ==> public companion object defined in net.corda.core.crypto.provider.CordaSecurityProvider[FakeCallableDescriptorForObject]

'PROVIDER_NAME' @ [203:35] ==> public const final val PROVIDER_NAME: String defined in net.corda.core.crypto.provider.CordaSecurityProvider.Companion[PropertyDescriptorImpl]

'CordaSecurityProvider' @ [203:52] ==> public constructor CordaSecurityProvider() defined in net.corda.core.crypto.provider.CordaSecurityProvider[ClassConstructorDescriptorImpl]

'to' @ [204:13] ==> public infix fun <A, B> String.to(that: BouncyCastlePQCProvider): Pair<String, BouncyCastlePQCProvider> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <A> -> String
    <B> -> BouncyCastlePQCProvider

'BouncyCastlePQCProvider' @ [204:24] ==> public constructor BouncyCastlePQCProvider() defined in org.bouncycastle.pqc.jcajce.provider.BouncyCastlePQCProvider[JavaClassConstructorDescriptor]

'BouncyCastleProvider' @ [206:45] ==> public constructor BouncyCastleProvider() defined in org.bouncycastle.jce.provider.BouncyCastleProvider[JavaClassConstructorDescriptor]

'apply' @ [206:68] ==> @InlineOnly public inline fun <T> BouncyCastleProvider.apply(block: BouncyCastleProvider.() -> Unit): BouncyCastleProvider defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> BouncyCastleProvider

'putAll' @ [207:9] ==> public open fun putAll(from: Map<*, *>): Unit defined in org.bouncycastle.jce.provider.BouncyCastleProvider[JavaMethodDescriptor]

'EdDSASecurityProvider' @ [207:16] ==> public constructor EdDSASecurityProvider() defined in net.i2p.crypto.eddsa.EdDSASecurityProvider[JavaClassConstructorDescriptor]

'addKeyInfoConverter' @ [208:9] ==> public open fun addKeyInfoConverter(p0: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?), p1: (AsymmetricKeyInfoConverter..AsymmetricKeyInfoConverter?)): Unit defined in org.bouncycastle.jce.provider.BouncyCastleProvider[JavaMethodDescriptor]

'EDDSA_ED25519_SHA512' @ [208:29] ==> @JvmField public final val EDDSA_ED25519_SHA512: SignatureScheme defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'signatureOID' @ [208:50] ==> public final val signatureOID: AlgorithmIdentifier defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'algorithm' @ [208:63] ==> public final val AlgorithmIdentifier.algorithm: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?)[MyPropertyDescriptor]

'KeyInfoConverter' @ [208:74] ==> public constructor KeyInfoConverter(signatureScheme: SignatureScheme) defined in net.corda.core.crypto.Crypto.KeyInfoConverter[ClassConstructorDescriptorImpl]

'EDDSA_ED25519_SHA512' @ [208:91] ==> @JvmField public final val EDDSA_ED25519_SHA512: SignatureScheme defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'JvmStatic' @ [211:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'ArrayList' @ [212:62] ==> public final fun <E> <init>(p0: (MutableCollection<out (SignatureScheme..SignatureScheme?)>..Collection<(SignatureScheme..SignatureScheme?)>?)): ArrayList<SignatureScheme> /* = ArrayList<SignatureScheme> */ defined in kotlin.collections.ArrayList[TypeAliasConstructorDescriptorImpl]
Inferred types:
    <E> -> SignatureScheme

'signatureSchemeMap' @ [212:72] ==> private final val signatureSchemeMap: Map<String, SignatureScheme> defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'values' @ [212:91] ==> public abstract val values: Collection<SignatureScheme> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'JvmStatic' @ [214:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'providerMap' @ [216:16] ==> private final val providerMap: Map<String, Provider> defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'name' @ [216:28] ==> value-parameter name: String defined in net.corda.core.crypto.Crypto.findProvider[ValueParameterDescriptorImpl]

'IllegalArgumentException' @ [216:43] ==> public final fun <init>(p0: (String..String?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'name' @ [216:93] ==> value-parameter name: String defined in net.corda.core.crypto.Crypto.findProvider[ValueParameterDescriptorImpl]

'addProvider' @ [222:18] ==> public open fun addProvider(p0: (Provider..Provider?)): Int defined in java.security.Security[JavaMethodDescriptor]

'getBouncyCastleProvider' @ [222:30] ==> private final fun getBouncyCastleProvider(): BouncyCastleProvider defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'addProvider' @ [223:18] ==> public open fun addProvider(p0: (Provider..Provider?)): Int defined in java.security.Security[JavaMethodDescriptor]

'CordaSecurityProvider' @ [223:30] ==> public constructor CordaSecurityProvider() defined in net.corda.core.crypto.provider.CordaSecurityProvider[ClassConstructorDescriptorImpl]

'if (id.parameters is DERNull) {
            AlgorithmIdentifier(id.algorithm, null)
        } else {
            id
        }' @ [230:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: AlgorithmIdentifier, elseBranch: AlgorithmIdentifier): AlgorithmIdentifier[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> AlgorithmIdentifier

'id' @ [230:20] ==> value-parameter id: AlgorithmIdentifier defined in net.corda.core.crypto.Crypto.normaliseAlgorithmIdentifier[ValueParameterDescriptorImpl]

'parameters' @ [230:23] ==> public final val AlgorithmIdentifier.parameters: (ASN1Encodable..ASN1Encodable?)[MyPropertyDescriptor]

'AlgorithmIdentifier' @ [231:13] ==> public constructor AlgorithmIdentifier(p0: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?), p1: (ASN1Encodable..ASN1Encodable?)) defined in org.bouncycastle.asn1.x509.AlgorithmIdentifier[JavaClassConstructorDescriptor]

'id' @ [231:33] ==> value-parameter id: AlgorithmIdentifier defined in net.corda.core.crypto.Crypto.normaliseAlgorithmIdentifier[ValueParameterDescriptorImpl]

'algorithm' @ [231:36] ==> public final val AlgorithmIdentifier.algorithm: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?)[MyPropertyDescriptor]

'id' @ [233:13] ==> value-parameter id: AlgorithmIdentifier defined in net.corda.core.crypto.Crypto.normaliseAlgorithmIdentifier[ValueParameterDescriptorImpl]

'JvmStatic' @ [237:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'algorithmMap' @ [239:16] ==> private final val algorithmMap: Map<AlgorithmIdentifier, SignatureScheme> defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'normaliseAlgorithmIdentifier' @ [239:29] ==> private final fun normaliseAlgorithmIdentifier(id: AlgorithmIdentifier): AlgorithmIdentifier defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'algorithm' @ [239:58] ==> value-parameter algorithm: AlgorithmIdentifier defined in net.corda.core.crypto.Crypto.findSignatureScheme[ValueParameterDescriptorImpl]

'IllegalArgumentException' @ [240:26] ==> public final fun <init>(p0: (String..String?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'algorithm' @ [240:78] ==> value-parameter algorithm: AlgorithmIdentifier defined in net.corda.core.crypto.Crypto.findSignatureScheme[ValueParameterDescriptorImpl]

'algorithm' @ [240:88] ==> public final val AlgorithmIdentifier.algorithm: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?)[MyPropertyDescriptor]

'id' @ [240:98] ==> public final val ASN1ObjectIdentifier.id: (String..String?)[MyPropertyDescriptor]

'JvmStatic' @ [251:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'signatureSchemeMap' @ [253:16] ==> private final val signatureSchemeMap: Map<String, SignatureScheme> defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'schemeCodeName' @ [253:35] ==> value-parameter schemeCodeName: String defined in net.corda.core.crypto.Crypto.findSignatureScheme[ValueParameterDescriptorImpl]

'IllegalArgumentException' @ [254:26] ==> public final fun <init>(p0: (String..String?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'schemeCodeName' @ [254:99] ==> value-parameter schemeCodeName: String defined in net.corda.core.crypto.Crypto.findSignatureScheme[ValueParameterDescriptorImpl]

'JvmStatic' @ [265:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'getInstance' @ [267:44] ==> public open fun getInstance(p0: (Any..Any?)): (SubjectPublicKeyInfo..SubjectPublicKeyInfo?) defined in org.bouncycastle.asn1.x509.SubjectPublicKeyInfo[JavaMethodDescriptor]

'key' @ [267:56] ==> value-parameter key: PublicKey defined in net.corda.core.crypto.Crypto.findSignatureScheme[ValueParameterDescriptorImpl]

'encoded' @ [267:60] ==> public final val PublicKey.encoded: (ByteArray..ByteArray?)[MyPropertyDescriptor]

'findSignatureScheme' @ [268:16] ==> @JvmStatic public final fun findSignatureScheme(algorithm: AlgorithmIdentifier): SignatureScheme defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'keyInfo' @ [268:36] ==> val keyInfo: (SubjectPublicKeyInfo..SubjectPublicKeyInfo?) defined in net.corda.core.crypto.Crypto.findSignatureScheme[LocalVariableDescriptor]

'algorithm' @ [268:44] ==> public final val SubjectPublicKeyInfo.algorithm: (AlgorithmIdentifier..AlgorithmIdentifier?)[MyPropertyDescriptor]

'JvmStatic' @ [279:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'getInstance' @ [281:38] ==> public open fun getInstance(p0: (Any..Any?)): (PrivateKeyInfo..PrivateKeyInfo?) defined in org.bouncycastle.asn1.pkcs.PrivateKeyInfo[JavaMethodDescriptor]

'key' @ [281:50] ==> value-parameter key: PrivateKey defined in net.corda.core.crypto.Crypto.findSignatureScheme[ValueParameterDescriptorImpl]

'encoded' @ [281:54] ==> public final val PrivateKey.encoded: (ByteArray..ByteArray?)[MyPropertyDescriptor]

'findSignatureScheme' @ [282:16] ==> @JvmStatic public final fun findSignatureScheme(algorithm: AlgorithmIdentifier): SignatureScheme defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'keyInfo' @ [282:36] ==> val keyInfo: (PrivateKeyInfo..PrivateKeyInfo?) defined in net.corda.core.crypto.Crypto.findSignatureScheme[LocalVariableDescriptor]

'privateKeyAlgorithm' @ [282:44] ==> public final val PrivateKeyInfo.privateKeyAlgorithm: (AlgorithmIdentifier..AlgorithmIdentifier?)[MyPropertyDescriptor]

'JvmStatic' @ [292:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'getInstance' @ [294:38] ==> public open fun getInstance(p0: (Any..Any?)): (PrivateKeyInfo..PrivateKeyInfo?) defined in org.bouncycastle.asn1.pkcs.PrivateKeyInfo[JavaMethodDescriptor]

'encodedKey' @ [294:50] ==> value-parameter encodedKey: ByteArray defined in net.corda.core.crypto.Crypto.decodePrivateKey[ValueParameterDescriptorImpl]

'findSignatureScheme' @ [295:31] ==> @JvmStatic public final fun findSignatureScheme(algorithm: AlgorithmIdentifier): SignatureScheme defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'keyInfo' @ [295:51] ==> val keyInfo: (PrivateKeyInfo..PrivateKeyInfo?) defined in net.corda.core.crypto.Crypto.decodePrivateKey[LocalVariableDescriptor]

'privateKeyAlgorithm' @ [295:59] ==> public final val PrivateKeyInfo.privateKeyAlgorithm: (AlgorithmIdentifier..AlgorithmIdentifier?)[MyPropertyDescriptor]

'getInstance' @ [296:37] ==> public open fun getInstance(p0: (String..String?), p1: (Provider..Provider?)): (KeyFactory..KeyFactory?) defined in java.security.KeyFactory[JavaMethodDescriptor]

'signatureScheme' @ [296:49] ==> val signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.decodePrivateKey[LocalVariableDescriptor]

'algorithmName' @ [296:65] ==> public final val algorithmName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'providerMap' @ [296:80] ==> private final val providerMap: Map<String, Provider> defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'signatureScheme' @ [296:92] ==> val signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.decodePrivateKey[LocalVariableDescriptor]

'providerName' @ [296:108] ==> public final val providerName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'keyFactory' @ [297:16] ==> val keyFactory: (KeyFactory..KeyFactory?) defined in net.corda.core.crypto.Crypto.decodePrivateKey[LocalVariableDescriptor]

'generatePrivate' @ [297:27] ==> public final fun generatePrivate(p0: (KeySpec..KeySpec?)): (PrivateKey..PrivateKey?) defined in java.security.KeyFactory[JavaMethodDescriptor]

'PKCS8EncodedKeySpec' @ [297:43] ==> public constructor PKCS8EncodedKeySpec(p0: (ByteArray..ByteArray?)) defined in java.security.spec.PKCS8EncodedKeySpec[JavaClassConstructorDescriptor]

'encodedKey' @ [297:63] ==> value-parameter encodedKey: ByteArray defined in net.corda.core.crypto.Crypto.decodePrivateKey[ValueParameterDescriptorImpl]

'JvmStatic' @ [308:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'Throws' @ [309:5] ==> public constructor Throws(vararg exceptionClasses: KClass<out Throwable>) defined in kotlin.jvm.Throws[DeserializedClassConstructorDescriptor]

'InvalidKeySpecException' @ [309:13] ==> public constructor InvalidKeySpecException() defined in java.security.spec.InvalidKeySpecException[JavaClassConstructorDescriptor]

'decodePrivateKey' @ [311:16] ==> @JvmStatic @Throws public final fun decodePrivateKey(signatureScheme: SignatureScheme, encodedKey: ByteArray): PrivateKey defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'findSignatureScheme' @ [311:33] ==> @JvmStatic public final fun findSignatureScheme(schemeCodeName: String): SignatureScheme defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'schemeCodeName' @ [311:53] ==> value-parameter schemeCodeName: String defined in net.corda.core.crypto.Crypto.decodePrivateKey[ValueParameterDescriptorImpl]

'encodedKey' @ [311:70] ==> value-parameter encodedKey: ByteArray defined in net.corda.core.crypto.Crypto.decodePrivateKey[ValueParameterDescriptorImpl]

'JvmStatic' @ [322:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'Throws' @ [323:5] ==> public constructor Throws(vararg exceptionClasses: KClass<out Throwable>) defined in kotlin.jvm.Throws[DeserializedClassConstructorDescriptor]

'InvalidKeySpecException' @ [323:13] ==> public constructor InvalidKeySpecException() defined in java.security.spec.InvalidKeySpecException[JavaClassConstructorDescriptor]

'require' @ [325:9] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'isSupportedSignatureScheme' @ [325:17] ==> @JvmStatic public final fun isSupportedSignatureScheme(signatureScheme: SignatureScheme): Boolean defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'signatureScheme' @ [325:44] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.decodePrivateKey[ValueParameterDescriptorImpl]

'signatureScheme' @ [326:62] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.decodePrivateKey[ValueParameterDescriptorImpl]

'schemeCodeName' @ [326:78] ==> public final val schemeCodeName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'getInstance' @ [329:41] ==> public open fun getInstance(p0: (String..String?), p1: (Provider..Provider?)): (KeyFactory..KeyFactory?) defined in java.security.KeyFactory[JavaMethodDescriptor]

'signatureScheme' @ [329:53] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.decodePrivateKey[ValueParameterDescriptorImpl]

'algorithmName' @ [329:69] ==> public final val algorithmName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'providerMap' @ [329:84] ==> private final val providerMap: Map<String, Provider> defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'signatureScheme' @ [329:96] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.decodePrivateKey[ValueParameterDescriptorImpl]

'providerName' @ [329:112] ==> public final val providerName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'keyFactory' @ [330:20] ==> val keyFactory: (KeyFactory..KeyFactory?) defined in net.corda.core.crypto.Crypto.decodePrivateKey[LocalVariableDescriptor]

'generatePrivate' @ [330:31] ==> public final fun generatePrivate(p0: (KeySpec..KeySpec?)): (PrivateKey..PrivateKey?) defined in java.security.KeyFactory[JavaMethodDescriptor]

'PKCS8EncodedKeySpec' @ [330:47] ==> public constructor PKCS8EncodedKeySpec(p0: (ByteArray..ByteArray?)) defined in java.security.spec.PKCS8EncodedKeySpec[JavaClassConstructorDescriptor]

'encodedKey' @ [330:67] ==> value-parameter encodedKey: ByteArray defined in net.corda.core.crypto.Crypto.decodePrivateKey[ValueParameterDescriptorImpl]

'InvalidKeySpecException' @ [332:19] ==> public constructor InvalidKeySpecException(p0: (String..String?), p1: (Throwable..Throwable?)) defined in java.security.spec.InvalidKeySpecException[JavaClassConstructorDescriptor]

'+' @ [332:43] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'ikse' @ [333:72] ==> val ikse: InvalidKeySpecException defined in net.corda.core.crypto.Crypto.decodePrivateKey[LocalVariableDescriptor]

'JvmStatic' @ [344:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'getInstance' @ [346:57] ==> public open fun getInstance(p0: (Any..Any?)): (SubjectPublicKeyInfo..SubjectPublicKeyInfo?) defined in org.bouncycastle.asn1.x509.SubjectPublicKeyInfo[JavaMethodDescriptor]

'encodedKey' @ [346:69] ==> value-parameter encodedKey: ByteArray defined in net.corda.core.crypto.Crypto.decodePublicKey[ValueParameterDescriptorImpl]

'findSignatureScheme' @ [347:31] ==> @JvmStatic public final fun findSignatureScheme(algorithm: AlgorithmIdentifier): SignatureScheme defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'subjectPublicKeyInfo' @ [347:51] ==> val subjectPublicKeyInfo: (SubjectPublicKeyInfo..SubjectPublicKeyInfo?) defined in net.corda.core.crypto.Crypto.decodePublicKey[LocalVariableDescriptor]

'algorithm' @ [347:72] ==> public final val SubjectPublicKeyInfo.algorithm: (AlgorithmIdentifier..AlgorithmIdentifier?)[MyPropertyDescriptor]

'getInstance' @ [348:37] ==> public open fun getInstance(p0: (String..String?), p1: (Provider..Provider?)): (KeyFactory..KeyFactory?) defined in java.security.KeyFactory[JavaMethodDescriptor]

'signatureScheme' @ [348:49] ==> val signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.decodePublicKey[LocalVariableDescriptor]

'algorithmName' @ [348:65] ==> public final val algorithmName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'providerMap' @ [348:80] ==> private final val providerMap: Map<String, Provider> defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'signatureScheme' @ [348:92] ==> val signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.decodePublicKey[LocalVariableDescriptor]

'providerName' @ [348:108] ==> public final val providerName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'keyFactory' @ [349:16] ==> val keyFactory: (KeyFactory..KeyFactory?) defined in net.corda.core.crypto.Crypto.decodePublicKey[LocalVariableDescriptor]

'generatePublic' @ [349:27] ==> public final fun generatePublic(p0: (KeySpec..KeySpec?)): (PublicKey..PublicKey?) defined in java.security.KeyFactory[JavaMethodDescriptor]

'X509EncodedKeySpec' @ [349:42] ==> public constructor X509EncodedKeySpec(p0: (ByteArray..ByteArray?)) defined in java.security.spec.X509EncodedKeySpec[JavaClassConstructorDescriptor]

'encodedKey' @ [349:61] ==> value-parameter encodedKey: ByteArray defined in net.corda.core.crypto.Crypto.decodePublicKey[ValueParameterDescriptorImpl]

'JvmStatic' @ [361:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'Throws' @ [362:5] ==> public constructor Throws(vararg exceptionClasses: KClass<out Throwable>) defined in kotlin.jvm.Throws[DeserializedClassConstructorDescriptor]

'InvalidKeySpecException' @ [362:13] ==> public constructor InvalidKeySpecException() defined in java.security.spec.InvalidKeySpecException[JavaClassConstructorDescriptor]

'decodePublicKey' @ [364:16] ==> @JvmStatic @Throws public final fun decodePublicKey(signatureScheme: SignatureScheme, encodedKey: ByteArray): PublicKey defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'findSignatureScheme' @ [364:32] ==> @JvmStatic public final fun findSignatureScheme(schemeCodeName: String): SignatureScheme defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'schemeCodeName' @ [364:52] ==> value-parameter schemeCodeName: String defined in net.corda.core.crypto.Crypto.decodePublicKey[ValueParameterDescriptorImpl]

'encodedKey' @ [364:69] ==> value-parameter encodedKey: ByteArray defined in net.corda.core.crypto.Crypto.decodePublicKey[ValueParameterDescriptorImpl]

'JvmStatic' @ [376:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'Throws' @ [377:5] ==> public constructor Throws(vararg exceptionClasses: KClass<out Throwable>) defined in kotlin.jvm.Throws[DeserializedClassConstructorDescriptor]

'InvalidKeySpecException' @ [377:13] ==> public constructor InvalidKeySpecException() defined in java.security.spec.InvalidKeySpecException[JavaClassConstructorDescriptor]

'require' @ [379:9] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'isSupportedSignatureScheme' @ [379:17] ==> @JvmStatic public final fun isSupportedSignatureScheme(signatureScheme: SignatureScheme): Boolean defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'signatureScheme' @ [379:44] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.decodePublicKey[ValueParameterDescriptorImpl]

'signatureScheme' @ [380:62] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.decodePublicKey[ValueParameterDescriptorImpl]

'schemeCodeName' @ [380:78] ==> public final val schemeCodeName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'getInstance' @ [383:41] ==> public open fun getInstance(p0: (String..String?), p1: (Provider..Provider?)): (KeyFactory..KeyFactory?) defined in java.security.KeyFactory[JavaMethodDescriptor]

'signatureScheme' @ [383:53] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.decodePublicKey[ValueParameterDescriptorImpl]

'algorithmName' @ [383:69] ==> public final val algorithmName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'providerMap' @ [383:84] ==> private final val providerMap: Map<String, Provider> defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'signatureScheme' @ [383:96] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.decodePublicKey[ValueParameterDescriptorImpl]

'providerName' @ [383:112] ==> public final val providerName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'keyFactory' @ [384:20] ==> val keyFactory: (KeyFactory..KeyFactory?) defined in net.corda.core.crypto.Crypto.decodePublicKey[LocalVariableDescriptor]

'generatePublic' @ [384:31] ==> public final fun generatePublic(p0: (KeySpec..KeySpec?)): (PublicKey..PublicKey?) defined in java.security.KeyFactory[JavaMethodDescriptor]

'X509EncodedKeySpec' @ [384:46] ==> public constructor X509EncodedKeySpec(p0: (ByteArray..ByteArray?)) defined in java.security.spec.X509EncodedKeySpec[JavaClassConstructorDescriptor]

'encodedKey' @ [384:65] ==> value-parameter encodedKey: ByteArray defined in net.corda.core.crypto.Crypto.decodePublicKey[ValueParameterDescriptorImpl]

'InvalidKeySpecException' @ [386:25] ==> public constructor InvalidKeySpecException(p0: (String..String?), p1: (Throwable..Throwable?)) defined in java.security.spec.InvalidKeySpecException[JavaClassConstructorDescriptor]

'+' @ [386:49] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'ikse' @ [387:77] ==> val ikse: InvalidKeySpecException defined in net.corda.core.crypto.Crypto.decodePublicKey[LocalVariableDescriptor]

'JvmStatic' @ [402:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'Throws' @ [403:5] ==> public constructor Throws(vararg exceptionClasses: KClass<out Throwable>) defined in kotlin.jvm.Throws[DeserializedClassConstructorDescriptor]

'InvalidKeyException' @ [403:13] ==> public constructor InvalidKeyException() defined in java.security.InvalidKeyException[JavaClassConstructorDescriptor]

'SignatureException' @ [403:41] ==> public constructor SignatureException() defined in java.security.SignatureException[JavaClassConstructorDescriptor]

'doSign' @ [404:64] ==> @JvmStatic @Throws public final fun doSign(signatureScheme: SignatureScheme, privateKey: PrivateKey, clearData: ByteArray): ByteArray defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'findSignatureScheme' @ [404:71] ==> @JvmStatic public final fun findSignatureScheme(key: PrivateKey): SignatureScheme defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'privateKey' @ [404:91] ==> value-parameter privateKey: PrivateKey defined in net.corda.core.crypto.Crypto.doSign[ValueParameterDescriptorImpl]

'privateKey' @ [404:104] ==> value-parameter privateKey: PrivateKey defined in net.corda.core.crypto.Crypto.doSign[ValueParameterDescriptorImpl]

'clearData' @ [404:116] ==> value-parameter clearData: ByteArray defined in net.corda.core.crypto.Crypto.doSign[ValueParameterDescriptorImpl]

'JvmStatic' @ [416:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'Throws' @ [417:5] ==> public constructor Throws(vararg exceptionClasses: KClass<out Throwable>) defined in kotlin.jvm.Throws[DeserializedClassConstructorDescriptor]

'InvalidKeyException' @ [417:13] ==> public constructor InvalidKeyException() defined in java.security.InvalidKeyException[JavaClassConstructorDescriptor]

'SignatureException' @ [417:41] ==> public constructor SignatureException() defined in java.security.SignatureException[JavaClassConstructorDescriptor]

'doSign' @ [419:16] ==> @JvmStatic @Throws public final fun doSign(signatureScheme: SignatureScheme, privateKey: PrivateKey, clearData: ByteArray): ByteArray defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'findSignatureScheme' @ [419:23] ==> @JvmStatic public final fun findSignatureScheme(schemeCodeName: String): SignatureScheme defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'schemeCodeName' @ [419:43] ==> value-parameter schemeCodeName: String defined in net.corda.core.crypto.Crypto.doSign[ValueParameterDescriptorImpl]

'privateKey' @ [419:60] ==> value-parameter privateKey: PrivateKey defined in net.corda.core.crypto.Crypto.doSign[ValueParameterDescriptorImpl]

'clearData' @ [419:72] ==> value-parameter clearData: ByteArray defined in net.corda.core.crypto.Crypto.doSign[ValueParameterDescriptorImpl]

'JvmStatic' @ [432:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'Throws' @ [433:5] ==> public constructor Throws(vararg exceptionClasses: KClass<out Throwable>) defined in kotlin.jvm.Throws[DeserializedClassConstructorDescriptor]

'InvalidKeyException' @ [433:13] ==> public constructor InvalidKeyException() defined in java.security.InvalidKeyException[JavaClassConstructorDescriptor]

'SignatureException' @ [433:41] ==> public constructor SignatureException() defined in java.security.SignatureException[JavaClassConstructorDescriptor]

'require' @ [435:9] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'isSupportedSignatureScheme' @ [435:17] ==> @JvmStatic public final fun isSupportedSignatureScheme(signatureScheme: SignatureScheme): Boolean defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'signatureScheme' @ [435:44] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.doSign[ValueParameterDescriptorImpl]

'signatureScheme' @ [436:62] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.doSign[ValueParameterDescriptorImpl]

'schemeCodeName' @ [436:78] ==> public final val schemeCodeName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'require' @ [438:9] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'clearData' @ [438:17] ==> value-parameter clearData: ByteArray defined in net.corda.core.crypto.Crypto.doSign[ValueParameterDescriptorImpl]

'isNotEmpty' @ [438:27] ==> @InlineOnly public inline fun ByteArray.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]

'getInstance' @ [439:35] ==> public open fun getInstance(p0: (String..String?), p1: (Provider..Provider?)): (Signature..Signature?) defined in java.security.Signature[JavaMethodDescriptor]

'signatureScheme' @ [439:47] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.doSign[ValueParameterDescriptorImpl]

'signatureName' @ [439:63] ==> public final val signatureName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'providerMap' @ [439:78] ==> private final val providerMap: Map<String, Provider> defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'signatureScheme' @ [439:90] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.doSign[ValueParameterDescriptorImpl]

'providerName' @ [439:106] ==> public final val providerName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'signature' @ [440:9] ==> val signature: (Signature..Signature?) defined in net.corda.core.crypto.Crypto.doSign[LocalVariableDescriptor]

'initSign' @ [440:19] ==> public final fun initSign(p0: (PrivateKey..PrivateKey?)): Unit defined in java.security.Signature[JavaMethodDescriptor]

'privateKey' @ [440:28] ==> value-parameter privateKey: PrivateKey defined in net.corda.core.crypto.Crypto.doSign[ValueParameterDescriptorImpl]

'signature' @ [441:9] ==> val signature: (Signature..Signature?) defined in net.corda.core.crypto.Crypto.doSign[LocalVariableDescriptor]

'update' @ [441:19] ==> public final fun update(p0: (ByteArray..ByteArray?)): Unit defined in java.security.Signature[JavaMethodDescriptor]

'clearData' @ [441:26] ==> value-parameter clearData: ByteArray defined in net.corda.core.crypto.Crypto.doSign[ValueParameterDescriptorImpl]

'signature' @ [442:16] ==> val signature: (Signature..Signature?) defined in net.corda.core.crypto.Crypto.doSign[LocalVariableDescriptor]

'sign' @ [442:26] ==> public final fun sign(): (ByteArray..ByteArray?) defined in java.security.Signature[JavaMethodDescriptor]

'JvmStatic' @ [457:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'Throws' @ [458:5] ==> public constructor Throws(vararg exceptionClasses: KClass<out Throwable>) defined in kotlin.jvm.Throws[DeserializedClassConstructorDescriptor]

'InvalidKeyException' @ [458:13] ==> public constructor InvalidKeyException() defined in java.security.InvalidKeyException[JavaClassConstructorDescriptor]

'SignatureException' @ [458:41] ==> public constructor SignatureException() defined in java.security.SignatureException[JavaClassConstructorDescriptor]

'findSignatureScheme' @ [460:39] ==> @JvmStatic public final fun findSignatureScheme(key: PrivateKey): SignatureScheme defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'keyPair' @ [460:59] ==> value-parameter keyPair: KeyPair defined in net.corda.core.crypto.Crypto.doSign[ValueParameterDescriptorImpl]

'private' @ [460:67] ==> public final val KeyPair.private: (PrivateKey..PrivateKey?)[MyPropertyDescriptor]

'findSignatureScheme' @ [461:44] ==> @JvmStatic public final fun findSignatureScheme(key: PublicKey): SignatureScheme defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'keyPair' @ [461:64] ==> value-parameter keyPair: KeyPair defined in net.corda.core.crypto.Crypto.doSign[ValueParameterDescriptorImpl]

'public' @ [461:72] ==> public final val KeyPair.public: (PublicKey..PublicKey?)[MyPropertyDescriptor]

'require' @ [462:9] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'sigKey' @ [462:17] ==> val sigKey: SignatureScheme defined in net.corda.core.crypto.Crypto.doSign[LocalVariableDescriptor]

'sigMetaData' @ [462:27] ==> val sigMetaData: SignatureScheme defined in net.corda.core.crypto.Crypto.doSign[LocalVariableDescriptor]

'sigMetaData' @ [463:41] ==> val sigMetaData: SignatureScheme defined in net.corda.core.crypto.Crypto.doSign[LocalVariableDescriptor]

'schemeCodeName' @ [463:53] ==> public final val schemeCodeName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'sigKey' @ [463:105] ==> val sigKey: SignatureScheme defined in net.corda.core.crypto.Crypto.doSign[LocalVariableDescriptor]

'schemeCodeName' @ [463:112] ==> public final val schemeCodeName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'doSign' @ [465:30] ==> @JvmStatic @Throws public final fun doSign(schemeCodeName: String, privateKey: PrivateKey, clearData: ByteArray): ByteArray defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'sigKey' @ [465:37] ==> val sigKey: SignatureScheme defined in net.corda.core.crypto.Crypto.doSign[LocalVariableDescriptor]

'schemeCodeName' @ [465:44] ==> public final val schemeCodeName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'keyPair' @ [465:60] ==> value-parameter keyPair: KeyPair defined in net.corda.core.crypto.Crypto.doSign[ValueParameterDescriptorImpl]

'private' @ [465:68] ==> public final val KeyPair.private: (PrivateKey..PrivateKey?)[MyPropertyDescriptor]

'signableData' @ [465:77] ==> value-parameter signableData: SignableData defined in net.corda.core.crypto.Crypto.doSign[ValueParameterDescriptorImpl]

'serialize' @ [465:90] ==> public fun <T : Any> SignableData.serialize(serializationFactory: SerializationFactory = ..., context: SerializationContext = ...): SerializedBytes<SignableData> defined in net.corda.core.serialization[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> SignableData

'bytes' @ [465:102] ==> public open val bytes: ByteArray defined in net.corda.core.serialization.SerializedBytes[PropertyDescriptorImpl]

'TransactionSignature' @ [466:16] ==> public constructor TransactionSignature(bytes: ByteArray, by: PublicKey, signatureMetadata: SignatureMetadata) defined in net.corda.core.crypto.TransactionSignature[ClassConstructorDescriptorImpl]

'signatureBytes' @ [466:37] ==> val signatureBytes: ByteArray defined in net.corda.core.crypto.Crypto.doSign[LocalVariableDescriptor]

'keyPair' @ [466:53] ==> value-parameter keyPair: KeyPair defined in net.corda.core.crypto.Crypto.doSign[ValueParameterDescriptorImpl]

'public' @ [466:61] ==> public final val KeyPair.public: (PublicKey..PublicKey?)[MyPropertyDescriptor]

'signableData' @ [466:69] ==> value-parameter signableData: SignableData defined in net.corda.core.crypto.Crypto.doSign[ValueParameterDescriptorImpl]

'signatureMetadata' @ [466:82] ==> public final val signatureMetadata: SignatureMetadata defined in net.corda.core.crypto.SignableData[PropertyDescriptorImpl]

'JvmStatic' @ [483:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'Throws' @ [484:5] ==> public constructor Throws(vararg exceptionClasses: KClass<out Throwable>) defined in kotlin.jvm.Throws[DeserializedClassConstructorDescriptor]

'InvalidKeyException' @ [484:13] ==> public constructor InvalidKeyException() defined in java.security.InvalidKeyException[JavaClassConstructorDescriptor]

'SignatureException' @ [484:41] ==> public constructor SignatureException() defined in java.security.SignatureException[JavaClassConstructorDescriptor]

'doVerify' @ [486:16] ==> @JvmStatic @Throws public final fun doVerify(signatureScheme: SignatureScheme, publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'findSignatureScheme' @ [486:25] ==> @JvmStatic public final fun findSignatureScheme(schemeCodeName: String): SignatureScheme defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'schemeCodeName' @ [486:45] ==> value-parameter schemeCodeName: String defined in net.corda.core.crypto.Crypto.doVerify[ValueParameterDescriptorImpl]

'publicKey' @ [486:62] ==> value-parameter publicKey: PublicKey defined in net.corda.core.crypto.Crypto.doVerify[ValueParameterDescriptorImpl]

'signatureData' @ [486:73] ==> value-parameter signatureData: ByteArray defined in net.corda.core.crypto.Crypto.doVerify[ValueParameterDescriptorImpl]

'clearData' @ [486:88] ==> value-parameter clearData: ByteArray defined in net.corda.core.crypto.Crypto.doVerify[ValueParameterDescriptorImpl]

'JvmStatic' @ [504:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'Throws' @ [505:5] ==> public constructor Throws(vararg exceptionClasses: KClass<out Throwable>) defined in kotlin.jvm.Throws[DeserializedClassConstructorDescriptor]

'InvalidKeyException' @ [505:13] ==> public constructor InvalidKeyException() defined in java.security.InvalidKeyException[JavaClassConstructorDescriptor]

'SignatureException' @ [505:41] ==> public constructor SignatureException() defined in java.security.SignatureException[JavaClassConstructorDescriptor]

'doVerify' @ [507:16] ==> @JvmStatic @Throws public final fun doVerify(signatureScheme: SignatureScheme, publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'findSignatureScheme' @ [507:25] ==> @JvmStatic public final fun findSignatureScheme(key: PublicKey): SignatureScheme defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'publicKey' @ [507:45] ==> value-parameter publicKey: PublicKey defined in net.corda.core.crypto.Crypto.doVerify[ValueParameterDescriptorImpl]

'publicKey' @ [507:57] ==> value-parameter publicKey: PublicKey defined in net.corda.core.crypto.Crypto.doVerify[ValueParameterDescriptorImpl]

'signatureData' @ [507:68] ==> value-parameter signatureData: ByteArray defined in net.corda.core.crypto.Crypto.doVerify[ValueParameterDescriptorImpl]

'clearData' @ [507:83] ==> value-parameter clearData: ByteArray defined in net.corda.core.crypto.Crypto.doVerify[ValueParameterDescriptorImpl]

'JvmStatic' @ [524:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'Throws' @ [525:5] ==> public constructor Throws(vararg exceptionClasses: KClass<out Throwable>) defined in kotlin.jvm.Throws[DeserializedClassConstructorDescriptor]

'InvalidKeyException' @ [525:13] ==> public constructor InvalidKeyException() defined in java.security.InvalidKeyException[JavaClassConstructorDescriptor]

'SignatureException' @ [525:41] ==> public constructor SignatureException() defined in java.security.SignatureException[JavaClassConstructorDescriptor]

'require' @ [527:9] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'isSupportedSignatureScheme' @ [527:17] ==> @JvmStatic public final fun isSupportedSignatureScheme(signatureScheme: SignatureScheme): Boolean defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'signatureScheme' @ [527:44] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.doVerify[ValueParameterDescriptorImpl]

'signatureScheme' @ [528:62] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.doVerify[ValueParameterDescriptorImpl]

'schemeCodeName' @ [528:78] ==> public final val schemeCodeName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'signatureData' @ [530:13] ==> value-parameter signatureData: ByteArray defined in net.corda.core.crypto.Crypto.doVerify[ValueParameterDescriptorImpl]

'isEmpty' @ [530:27] ==> @InlineOnly public inline fun ByteArray.isEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]

'IllegalArgumentException' @ [530:44] ==> public final fun <init>(p0: (String..String?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'clearData' @ [531:13] ==> value-parameter clearData: ByteArray defined in net.corda.core.crypto.Crypto.doVerify[ValueParameterDescriptorImpl]

'isEmpty' @ [531:23] ==> @InlineOnly public inline fun ByteArray.isEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]

'IllegalArgumentException' @ [531:40] ==> public final fun <init>(p0: (String..String?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'isValid' @ [532:34] ==> @JvmStatic @Throws public final fun isValid(signatureScheme: SignatureScheme, publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'signatureScheme' @ [532:42] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.doVerify[ValueParameterDescriptorImpl]

'publicKey' @ [532:59] ==> value-parameter publicKey: PublicKey defined in net.corda.core.crypto.Crypto.doVerify[ValueParameterDescriptorImpl]

'signatureData' @ [532:70] ==> value-parameter signatureData: ByteArray defined in net.corda.core.crypto.Crypto.doVerify[ValueParameterDescriptorImpl]

'clearData' @ [532:85] ==> value-parameter clearData: ByteArray defined in net.corda.core.crypto.Crypto.doVerify[ValueParameterDescriptorImpl]

'if (verificationResult) {
            return true
        } else {
            throw SignatureException("Signature Verification failed!")
        }' @ [533:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nothing, elseBranch: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nothing

'verificationResult' @ [533:13] ==> val verificationResult: Boolean defined in net.corda.core.crypto.Crypto.doVerify[LocalVariableDescriptor]

'SignatureException' @ [536:19] ==> public constructor SignatureException(p0: (String..String?)) defined in java.security.SignatureException[JavaClassConstructorDescriptor]

'JvmStatic' @ [552:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'Throws' @ [553:5] ==> public constructor Throws(vararg exceptionClasses: KClass<out Throwable>) defined in kotlin.jvm.Throws[DeserializedClassConstructorDescriptor]

'InvalidKeyException' @ [553:13] ==> public constructor InvalidKeyException() defined in java.security.InvalidKeyException[JavaClassConstructorDescriptor]

'SignatureException' @ [553:41] ==> public constructor SignatureException() defined in java.security.SignatureException[JavaClassConstructorDescriptor]

'SignableData' @ [555:28] ==> public constructor SignableData(txId: SecureHash, signatureMetadata: SignatureMetadata) defined in net.corda.core.crypto.SignableData[ClassConstructorDescriptorImpl]

'txId' @ [555:41] ==> value-parameter txId: SecureHash defined in net.corda.core.crypto.Crypto.doVerify[ValueParameterDescriptorImpl]

'transactionSignature' @ [555:47] ==> value-parameter transactionSignature: TransactionSignature defined in net.corda.core.crypto.Crypto.doVerify[ValueParameterDescriptorImpl]

'signatureMetadata' @ [555:68] ==> public final val signatureMetadata: SignatureMetadata defined in net.corda.core.crypto.TransactionSignature[PropertyDescriptorImpl]

'Crypto' @ [556:16] ==> public object Crypto defined in net.corda.core.crypto in file Crypto.kt[FakeCallableDescriptorForObject]

'doVerify' @ [556:23] ==> @JvmStatic @Throws public final fun doVerify(publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'transactionSignature' @ [556:32] ==> value-parameter transactionSignature: TransactionSignature defined in net.corda.core.crypto.Crypto.doVerify[ValueParameterDescriptorImpl]

'by' @ [556:53] ==> public final val by: PublicKey defined in net.corda.core.crypto.TransactionSignature[PropertyDescriptorImpl]

'transactionSignature' @ [556:57] ==> value-parameter transactionSignature: TransactionSignature defined in net.corda.core.crypto.Crypto.doVerify[ValueParameterDescriptorImpl]

'bytes' @ [556:78] ==> public open val bytes: ByteArray defined in net.corda.core.crypto.TransactionSignature[PropertyDescriptorImpl]

'signableData' @ [556:85] ==> val signableData: SignableData defined in net.corda.core.crypto.Crypto.doVerify[LocalVariableDescriptor]

'serialize' @ [556:98] ==> public fun <T : Any> SignableData.serialize(serializationFactory: SerializationFactory = ..., context: SerializationContext = ...): SerializedBytes<SignableData> defined in net.corda.core.serialization[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> SignableData

'bytes' @ [556:110] ==> public open val bytes: ByteArray defined in net.corda.core.serialization.SerializedBytes[PropertyDescriptorImpl]

'JvmStatic' @ [571:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'Throws' @ [572:5] ==> public constructor Throws(vararg exceptionClasses: KClass<out Throwable>) defined in kotlin.jvm.Throws[DeserializedClassConstructorDescriptor]

'SignatureException' @ [572:13] ==> public constructor SignatureException() defined in java.security.SignatureException[JavaClassConstructorDescriptor]

'SignableData' @ [574:28] ==> public constructor SignableData(txId: SecureHash, signatureMetadata: SignatureMetadata) defined in net.corda.core.crypto.SignableData[ClassConstructorDescriptorImpl]

'txId' @ [574:41] ==> value-parameter txId: SecureHash defined in net.corda.core.crypto.Crypto.isValid[ValueParameterDescriptorImpl]

'transactionSignature' @ [574:47] ==> value-parameter transactionSignature: TransactionSignature defined in net.corda.core.crypto.Crypto.isValid[ValueParameterDescriptorImpl]

'signatureMetadata' @ [574:68] ==> public final val signatureMetadata: SignatureMetadata defined in net.corda.core.crypto.TransactionSignature[PropertyDescriptorImpl]

'isValid' @ [575:16] ==> @JvmStatic @Throws public final fun isValid(signatureScheme: SignatureScheme, publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'findSignatureScheme' @ [576:17] ==> @JvmStatic public final fun findSignatureScheme(key: PublicKey): SignatureScheme defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'transactionSignature' @ [576:37] ==> value-parameter transactionSignature: TransactionSignature defined in net.corda.core.crypto.Crypto.isValid[ValueParameterDescriptorImpl]

'by' @ [576:58] ==> public final val by: PublicKey defined in net.corda.core.crypto.TransactionSignature[PropertyDescriptorImpl]

'transactionSignature' @ [577:17] ==> value-parameter transactionSignature: TransactionSignature defined in net.corda.core.crypto.Crypto.isValid[ValueParameterDescriptorImpl]

'by' @ [577:38] ==> public final val by: PublicKey defined in net.corda.core.crypto.TransactionSignature[PropertyDescriptorImpl]

'transactionSignature' @ [578:17] ==> value-parameter transactionSignature: TransactionSignature defined in net.corda.core.crypto.Crypto.isValid[ValueParameterDescriptorImpl]

'bytes' @ [578:38] ==> public open val bytes: ByteArray defined in net.corda.core.crypto.TransactionSignature[PropertyDescriptorImpl]

'signableData' @ [579:17] ==> val signableData: SignableData defined in net.corda.core.crypto.Crypto.isValid[LocalVariableDescriptor]

'serialize' @ [579:30] ==> public fun <T : Any> SignableData.serialize(serializationFactory: SerializationFactory = ..., context: SerializationContext = ...): SerializedBytes<SignableData> defined in net.corda.core.serialization[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> SignableData

'bytes' @ [579:42] ==> public open val bytes: ByteArray defined in net.corda.core.serialization.SerializedBytes[PropertyDescriptorImpl]

'JvmStatic' @ [597:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'Throws' @ [598:5] ==> public constructor Throws(vararg exceptionClasses: KClass<out Throwable>) defined in kotlin.jvm.Throws[DeserializedClassConstructorDescriptor]

'SignatureException' @ [598:13] ==> public constructor SignatureException() defined in java.security.SignatureException[JavaClassConstructorDescriptor]

'isValid' @ [600:16] ==> @JvmStatic @Throws public final fun isValid(signatureScheme: SignatureScheme, publicKey: PublicKey, signatureData: ByteArray, clearData: ByteArray): Boolean defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'findSignatureScheme' @ [600:24] ==> @JvmStatic public final fun findSignatureScheme(key: PublicKey): SignatureScheme defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'publicKey' @ [600:44] ==> value-parameter publicKey: PublicKey defined in net.corda.core.crypto.Crypto.isValid[ValueParameterDescriptorImpl]

'publicKey' @ [600:56] ==> value-parameter publicKey: PublicKey defined in net.corda.core.crypto.Crypto.isValid[ValueParameterDescriptorImpl]

'signatureData' @ [600:67] ==> value-parameter signatureData: ByteArray defined in net.corda.core.crypto.Crypto.isValid[ValueParameterDescriptorImpl]

'clearData' @ [600:82] ==> value-parameter clearData: ByteArray defined in net.corda.core.crypto.Crypto.isValid[ValueParameterDescriptorImpl]

'JvmStatic' @ [617:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'Throws' @ [618:5] ==> public constructor Throws(vararg exceptionClasses: KClass<out Throwable>) defined in kotlin.jvm.Throws[DeserializedClassConstructorDescriptor]

'SignatureException' @ [618:13] ==> public constructor SignatureException() defined in java.security.SignatureException[JavaClassConstructorDescriptor]

'require' @ [620:9] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'isSupportedSignatureScheme' @ [620:17] ==> @JvmStatic public final fun isSupportedSignatureScheme(signatureScheme: SignatureScheme): Boolean defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'signatureScheme' @ [620:44] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.isValid[ValueParameterDescriptorImpl]

'signatureScheme' @ [621:62] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.isValid[ValueParameterDescriptorImpl]

'schemeCodeName' @ [621:78] ==> public final val schemeCodeName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'getInstance' @ [623:35] ==> public open fun getInstance(p0: (String..String?), p1: (Provider..Provider?)): (Signature..Signature?) defined in java.security.Signature[JavaMethodDescriptor]

'signatureScheme' @ [623:47] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.isValid[ValueParameterDescriptorImpl]

'signatureName' @ [623:63] ==> public final val signatureName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'providerMap' @ [623:78] ==> private final val providerMap: Map<String, Provider> defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'signatureScheme' @ [623:90] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.isValid[ValueParameterDescriptorImpl]

'providerName' @ [623:106] ==> public final val providerName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'signature' @ [624:9] ==> val signature: (Signature..Signature?) defined in net.corda.core.crypto.Crypto.isValid[LocalVariableDescriptor]

'initVerify' @ [624:19] ==> public final fun initVerify(p0: (PublicKey..PublicKey?)): Unit defined in java.security.Signature[JavaMethodDescriptor]

'publicKey' @ [624:30] ==> value-parameter publicKey: PublicKey defined in net.corda.core.crypto.Crypto.isValid[ValueParameterDescriptorImpl]

'signature' @ [625:9] ==> val signature: (Signature..Signature?) defined in net.corda.core.crypto.Crypto.isValid[LocalVariableDescriptor]

'update' @ [625:19] ==> public final fun update(p0: (ByteArray..ByteArray?)): Unit defined in java.security.Signature[JavaMethodDescriptor]

'clearData' @ [625:26] ==> value-parameter clearData: ByteArray defined in net.corda.core.crypto.Crypto.isValid[ValueParameterDescriptorImpl]

'signature' @ [626:16] ==> val signature: (Signature..Signature?) defined in net.corda.core.crypto.Crypto.isValid[LocalVariableDescriptor]

'verify' @ [626:26] ==> public final fun verify(p0: (ByteArray..ByteArray?)): Boolean defined in java.security.Signature[JavaMethodDescriptor]

'signatureData' @ [626:33] ==> value-parameter signatureData: ByteArray defined in net.corda.core.crypto.Crypto.isValid[ValueParameterDescriptorImpl]

'JvmStatic' @ [636:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'generateKeyPair' @ [637:60] ==> @JvmOverloads @JvmStatic public final fun generateKeyPair(signatureScheme: SignatureScheme = ...): KeyPair defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'findSignatureScheme' @ [637:76] ==> @JvmStatic public final fun findSignatureScheme(schemeCodeName: String): SignatureScheme defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'schemeCodeName' @ [637:96] ==> value-parameter schemeCodeName: String defined in net.corda.core.crypto.Crypto.generateKeyPair[ValueParameterDescriptorImpl]

'JvmOverloads' @ [646:5] ==> public constructor JvmOverloads() defined in kotlin.jvm.JvmOverloads[DeserializedClassConstructorDescriptor]

'JvmStatic' @ [647:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'DEFAULT_SIGNATURE_SCHEME' @ [648:60] ==> @JvmField public final val DEFAULT_SIGNATURE_SCHEME: SignatureScheme defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'require' @ [649:9] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'isSupportedSignatureScheme' @ [649:17] ==> @JvmStatic public final fun isSupportedSignatureScheme(signatureScheme: SignatureScheme): Boolean defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'signatureScheme' @ [649:44] ==> value-parameter signatureScheme: SignatureScheme = ... defined in net.corda.core.crypto.Crypto.generateKeyPair[ValueParameterDescriptorImpl]

'signatureScheme' @ [650:62] ==> value-parameter signatureScheme: SignatureScheme = ... defined in net.corda.core.crypto.Crypto.generateKeyPair[ValueParameterDescriptorImpl]

'schemeCodeName' @ [650:78] ==> public final val schemeCodeName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'getInstance' @ [652:49] ==> public open fun getInstance(p0: (String..String?), p1: (Provider..Provider?)): (KeyPairGenerator..KeyPairGenerator?) defined in java.security.KeyPairGenerator[JavaMethodDescriptor]

'signatureScheme' @ [652:61] ==> value-parameter signatureScheme: SignatureScheme = ... defined in net.corda.core.crypto.Crypto.generateKeyPair[ValueParameterDescriptorImpl]

'algorithmName' @ [652:77] ==> public final val algorithmName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'providerMap' @ [652:92] ==> private final val providerMap: Map<String, Provider> defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'signatureScheme' @ [652:104] ==> value-parameter signatureScheme: SignatureScheme = ... defined in net.corda.core.crypto.Crypto.generateKeyPair[ValueParameterDescriptorImpl]

'providerName' @ [652:120] ==> public final val providerName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'if (signatureScheme.algSpec != null)
            keyPairGenerator.initialize(signatureScheme.algSpec, newSecureRandom())
        else
            keyPairGenerator.initialize(signatureScheme.keySize!!, newSecureRandom())' @ [653:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'signatureScheme' @ [653:13] ==> value-parameter signatureScheme: SignatureScheme = ... defined in net.corda.core.crypto.Crypto.generateKeyPair[ValueParameterDescriptorImpl]

'algSpec' @ [653:29] ==> public final val algSpec: AlgorithmParameterSpec? defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'keyPairGenerator' @ [654:13] ==> val keyPairGenerator: (KeyPairGenerator..KeyPairGenerator?) defined in net.corda.core.crypto.Crypto.generateKeyPair[LocalVariableDescriptor]

'initialize' @ [654:30] ==> public open fun initialize(p0: (AlgorithmParameterSpec..AlgorithmParameterSpec?), p1: (SecureRandom..SecureRandom?)): Unit defined in java.security.KeyPairGenerator[JavaMethodDescriptor]

'signatureScheme' @ [654:41] ==> value-parameter signatureScheme: SignatureScheme = ... defined in net.corda.core.crypto.Crypto.generateKeyPair[ValueParameterDescriptorImpl]

'algSpec' @ [654:57] ==> public final val algSpec: AlgorithmParameterSpec? defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'newSecureRandom' @ [654:66] ==> @Throws public fun newSecureRandom(): SecureRandom defined in net.corda.core.crypto in file CryptoUtils.kt[SimpleFunctionDescriptorImpl]

'keyPairGenerator' @ [656:13] ==> val keyPairGenerator: (KeyPairGenerator..KeyPairGenerator?) defined in net.corda.core.crypto.Crypto.generateKeyPair[LocalVariableDescriptor]

'initialize' @ [656:30] ==> public open fun initialize(p0: Int, p1: (SecureRandom..SecureRandom?)): Unit defined in java.security.KeyPairGenerator[JavaMethodDescriptor]

'signatureScheme' @ [656:41] ==> value-parameter signatureScheme: SignatureScheme = ... defined in net.corda.core.crypto.Crypto.generateKeyPair[ValueParameterDescriptorImpl]

'keySize' @ [656:57] ==> public final val keySize: Int? defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'newSecureRandom' @ [656:68] ==> @Throws public fun newSecureRandom(): SecureRandom defined in net.corda.core.crypto in file CryptoUtils.kt[SimpleFunctionDescriptorImpl]

'keyPairGenerator' @ [657:16] ==> val keyPairGenerator: (KeyPairGenerator..KeyPairGenerator?) defined in net.corda.core.crypto.Crypto.generateKeyPair[LocalVariableDescriptor]

'generateKeyPair' @ [657:33] ==> public open fun generateKeyPair(): (KeyPair..KeyPair?) defined in java.security.KeyPairGenerator[JavaMethodDescriptor]

'JvmStatic' @ [716:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'require' @ [718:9] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'isSupportedSignatureScheme' @ [718:17] ==> @JvmStatic public final fun isSupportedSignatureScheme(signatureScheme: SignatureScheme): Boolean defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'signatureScheme' @ [718:44] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.deriveKeyPair[ValueParameterDescriptorImpl]

'signatureScheme' @ [719:62] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.deriveKeyPair[ValueParameterDescriptorImpl]

'schemeCodeName' @ [719:78] ==> public final val schemeCodeName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'when (signatureScheme) {
            ECDSA_SECP256R1_SHA256, ECDSA_SECP256K1_SHA256 -> deriveKeyPairECDSA(signatureScheme.algSpec as ECParameterSpec, privateKey, seed)
            EDDSA_ED25519_SHA512 -> deriveKeyPairEdDSA(privateKey, seed)
            else -> throw UnsupportedOperationException("Although supported for signing, deterministic key derivation is " +
                    "not currently implemented for ${signatureScheme.schemeCodeName}")
        }' @ [721:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KeyPair, entry1: KeyPair, entry2: KeyPair): KeyPair[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KeyPair

'signatureScheme' @ [721:22] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.deriveKeyPair[ValueParameterDescriptorImpl]

'ECDSA_SECP256R1_SHA256' @ [722:13] ==> @JvmField public final val ECDSA_SECP256R1_SHA256: SignatureScheme defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'ECDSA_SECP256K1_SHA256' @ [722:37] ==> @JvmField public final val ECDSA_SECP256K1_SHA256: SignatureScheme defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'deriveKeyPairECDSA' @ [722:63] ==> private final fun deriveKeyPairECDSA(parameterSpec: ECParameterSpec, privateKey: PrivateKey, seed: ByteArray): KeyPair defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'signatureScheme' @ [722:82] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.deriveKeyPair[ValueParameterDescriptorImpl]

'algSpec' @ [722:98] ==> public final val algSpec: AlgorithmParameterSpec? defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'privateKey' @ [722:126] ==> value-parameter privateKey: PrivateKey defined in net.corda.core.crypto.Crypto.deriveKeyPair[ValueParameterDescriptorImpl]

'seed' @ [722:138] ==> value-parameter seed: ByteArray defined in net.corda.core.crypto.Crypto.deriveKeyPair[ValueParameterDescriptorImpl]

'EDDSA_ED25519_SHA512' @ [723:13] ==> @JvmField public final val EDDSA_ED25519_SHA512: SignatureScheme defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'deriveKeyPairEdDSA' @ [723:37] ==> private final fun deriveKeyPairEdDSA(privateKey: PrivateKey, seed: ByteArray): KeyPair defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'privateKey' @ [723:56] ==> value-parameter privateKey: PrivateKey defined in net.corda.core.crypto.Crypto.deriveKeyPair[ValueParameterDescriptorImpl]

'seed' @ [723:68] ==> value-parameter seed: ByteArray defined in net.corda.core.crypto.Crypto.deriveKeyPair[ValueParameterDescriptorImpl]

'UnsupportedOperationException' @ [724:27] ==> public final fun <init>(p0: (String..String?)): UnsupportedOperationException /* = UnsupportedOperationException */ defined in kotlin.UnsupportedOperationException[TypeAliasConstructorDescriptorImpl]

'+' @ [724:57] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'signatureScheme' @ [725:54] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.deriveKeyPair[ValueParameterDescriptorImpl]

'schemeCodeName' @ [725:70] ==> public final val schemeCodeName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'JvmStatic' @ [738:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'deriveKeyPair' @ [740:16] ==> @JvmStatic public final fun deriveKeyPair(signatureScheme: SignatureScheme, privateKey: PrivateKey, seed: ByteArray): KeyPair defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'findSignatureScheme' @ [740:30] ==> @JvmStatic public final fun findSignatureScheme(key: PrivateKey): SignatureScheme defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'privateKey' @ [740:50] ==> value-parameter privateKey: PrivateKey defined in net.corda.core.crypto.Crypto.deriveKeyPair[ValueParameterDescriptorImpl]

'privateKey' @ [740:63] ==> value-parameter privateKey: PrivateKey defined in net.corda.core.crypto.Crypto.deriveKeyPair[ValueParameterDescriptorImpl]

'seed' @ [740:75] ==> value-parameter seed: ByteArray defined in net.corda.core.crypto.Crypto.deriveKeyPair[ValueParameterDescriptorImpl]

'deriveHMAC' @ [747:24] ==> private final fun deriveHMAC(privateKey: PrivateKey, seed: ByteArray): ByteArray defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'privateKey' @ [747:35] ==> value-parameter privateKey: PrivateKey defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[ValueParameterDescriptorImpl]

'seed' @ [747:47] ==> value-parameter seed: ByteArray defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[ValueParameterDescriptorImpl]

'macBytes' @ [752:33] ==> val macBytes: ByteArray defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[LocalVariableDescriptor]

'copyOf' @ [752:42] ==> @InlineOnly public inline fun ByteArray.copyOf(newSize: Int): ByteArray defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]

'parameterSpec' @ [752:49] ==> value-parameter parameterSpec: ECParameterSpec defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[ValueParameterDescriptorImpl]

'curve' @ [752:63] ==> public final val ECParameterSpec.curve: (ECCurve..ECCurve?)[MyPropertyDescriptor]

'fieldSize' @ [752:69] ==> public final val ECCurve.fieldSize: Int[MyPropertyDescriptor]

'BigInteger' @ [755:30] ==> public constructor BigInteger(p0: Int, p1: (ByteArray..ByteArray?)) defined in java.math.BigInteger[JavaClassConstructorDescriptor]

'fieldSizeMacBytes' @ [755:44] ==> val fieldSizeMacBytes: ByteArray defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[LocalVariableDescriptor]

'deterministicD' @ [764:13] ==> val deterministicD: BigInteger defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[LocalVariableDescriptor]

'TWO' @ [764:42] ==> public final val TWO: (BigInteger..BigInteger?) defined in org.bouncycastle.math.ec.ECConstants[JavaPropertyDescriptor]

'<' @ [765:20] ==> public open fun compareTo(other: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'getNafWeight' @ [765:29] ==> public open fun getNafWeight(p0: (BigInteger..BigInteger?)): Int defined in org.bouncycastle.math.ec.WNafUtil[JavaMethodDescriptor]

'deterministicD' @ [765:42] ==> val deterministicD: BigInteger defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[LocalVariableDescriptor]

'parameterSpec' @ [765:60] ==> value-parameter parameterSpec: ECParameterSpec defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[ValueParameterDescriptorImpl]

'n' @ [765:74] ==> public final val ECParameterSpec.n: (BigInteger..BigInteger?)[MyPropertyDescriptor]

'bitLength' @ [765:76] ==> public open fun bitLength(): Int defined in java.math.BigInteger[JavaMethodDescriptor]

'ushr' @ [765:88] ==> public final infix fun ushr(bitCount: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'deterministicD' @ [766:20] ==> val deterministicD: BigInteger defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[LocalVariableDescriptor]

'parameterSpec' @ [766:38] ==> value-parameter parameterSpec: ECParameterSpec defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[ValueParameterDescriptorImpl]

'n' @ [766:52] ==> public final val ECParameterSpec.n: (BigInteger..BigInteger?)[MyPropertyDescriptor]

'deriveKeyPairECDSA' @ [768:20] ==> private final fun deriveKeyPairECDSA(parameterSpec: ECParameterSpec, privateKey: PrivateKey, seed: ByteArray): KeyPair defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'parameterSpec' @ [768:39] ==> value-parameter parameterSpec: ECParameterSpec defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[ValueParameterDescriptorImpl]

'privateKey' @ [768:54] ==> value-parameter privateKey: PrivateKey defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[ValueParameterDescriptorImpl]

'seed' @ [768:66] ==> value-parameter seed: ByteArray defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[ValueParameterDescriptorImpl]

'sha256' @ [768:71] ==> public fun ByteArray.sha256(): SecureHash.SHA256 defined in net.corda.core.crypto in file SecureHash.kt[SimpleFunctionDescriptorImpl]

'bytes' @ [768:80] ==> public open val bytes: ByteArray defined in net.corda.core.crypto.SecureHash.SHA256[PropertyDescriptorImpl]

'ECPrivateKeySpec' @ [770:30] ==> public constructor ECPrivateKeySpec(p0: (BigInteger..BigInteger?), p1: (ECParameterSpec..ECParameterSpec?)) defined in org.bouncycastle.jce.spec.ECPrivateKeySpec[JavaClassConstructorDescriptor]

'deterministicD' @ [770:47] ==> val deterministicD: BigInteger defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[LocalVariableDescriptor]

'parameterSpec' @ [770:63] ==> value-parameter parameterSpec: ECParameterSpec defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[ValueParameterDescriptorImpl]

'BCECPrivateKey' @ [771:27] ==> public constructor BCECPrivateKey(p0: (String..String?), p1: (ECPrivateKeySpec..ECPrivateKeySpec?), p2: (ProviderConfiguration..ProviderConfiguration?)) defined in org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPrivateKey[JavaClassConstructorDescriptor]

'privateKey' @ [771:42] ==> value-parameter privateKey: PrivateKey defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[ValueParameterDescriptorImpl]

'algorithm' @ [771:53] ==> public final val PrivateKey.algorithm: (String..String?)[MyPropertyDescriptor]

'privateKeySpec' @ [771:64] ==> val privateKeySpec: ECPrivateKeySpec defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[LocalVariableDescriptor]

'CONFIGURATION' @ [771:101] ==> public final val CONFIGURATION: (ProviderConfiguration..ProviderConfiguration?) defined in org.bouncycastle.jce.provider.BouncyCastleProvider[JavaPropertyDescriptor]

'FixedPointCombMultiplier' @ [778:22] ==> public constructor FixedPointCombMultiplier() defined in org.bouncycastle.math.ec.FixedPointCombMultiplier[JavaClassConstructorDescriptor]

'multiply' @ [778:49] ==> public open fun multiply(p0: (ECPoint..ECPoint?), p1: (BigInteger..BigInteger?)): (ECPoint..ECPoint?) defined in org.bouncycastle.math.ec.FixedPointCombMultiplier[JavaMethodDescriptor]

'parameterSpec' @ [778:58] ==> value-parameter parameterSpec: ECParameterSpec defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[ValueParameterDescriptorImpl]

'g' @ [778:72] ==> public final val ECParameterSpec.g: (ECPoint..ECPoint?)[MyPropertyDescriptor]

'deterministicD' @ [778:75] ==> val deterministicD: BigInteger defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[LocalVariableDescriptor]

'pointQ' @ [780:13] ==> val pointQ: (ECPoint..ECPoint?) defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[LocalVariableDescriptor]

'isInfinity' @ [780:20] ==> public final val ECPoint.isInfinity: Boolean[MyPropertyDescriptor]

'deriveKeyPairECDSA' @ [782:20] ==> private final fun deriveKeyPairECDSA(parameterSpec: ECParameterSpec, privateKey: PrivateKey, seed: ByteArray): KeyPair defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'parameterSpec' @ [782:39] ==> value-parameter parameterSpec: ECParameterSpec defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[ValueParameterDescriptorImpl]

'privateKey' @ [782:54] ==> value-parameter privateKey: PrivateKey defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[ValueParameterDescriptorImpl]

'seed' @ [782:66] ==> value-parameter seed: ByteArray defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[ValueParameterDescriptorImpl]

'sha256' @ [782:71] ==> public fun ByteArray.sha256(): SecureHash.SHA256 defined in net.corda.core.crypto in file SecureHash.kt[SimpleFunctionDescriptorImpl]

'bytes' @ [782:80] ==> public open val bytes: ByteArray defined in net.corda.core.crypto.SecureHash.SHA256[PropertyDescriptorImpl]

'ECPublicKeySpec' @ [783:29] ==> public constructor ECPublicKeySpec(p0: (ECPoint..ECPoint?), p1: (ECParameterSpec..ECParameterSpec?)) defined in org.bouncycastle.jce.spec.ECPublicKeySpec[JavaClassConstructorDescriptor]

'pointQ' @ [783:45] ==> val pointQ: (ECPoint..ECPoint?) defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[LocalVariableDescriptor]

'parameterSpec' @ [783:53] ==> value-parameter parameterSpec: ECParameterSpec defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[ValueParameterDescriptorImpl]

'BCECPublicKey' @ [784:26] ==> public constructor BCECPublicKey(p0: (String..String?), p1: (ECPublicKeySpec..ECPublicKeySpec?), p2: (ProviderConfiguration..ProviderConfiguration?)) defined in org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey[JavaClassConstructorDescriptor]

'privateKey' @ [784:40] ==> value-parameter privateKey: PrivateKey defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[ValueParameterDescriptorImpl]

'algorithm' @ [784:51] ==> public final val PrivateKey.algorithm: (String..String?)[MyPropertyDescriptor]

'publicKeySpec' @ [784:62] ==> val publicKeySpec: ECPublicKeySpec defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[LocalVariableDescriptor]

'CONFIGURATION' @ [784:98] ==> public final val CONFIGURATION: (ProviderConfiguration..ProviderConfiguration?) defined in org.bouncycastle.jce.provider.BouncyCastleProvider[JavaPropertyDescriptor]

'KeyPair' @ [786:16] ==> public constructor KeyPair(p0: (PublicKey..PublicKey?), p1: (PrivateKey..PrivateKey?)) defined in java.security.KeyPair[JavaClassConstructorDescriptor]

'publicKeyD' @ [786:24] ==> val publicKeyD: BCECPublicKey defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[LocalVariableDescriptor]

'privateKeyD' @ [786:36] ==> val privateKeyD: BCECPrivateKey defined in net.corda.core.crypto.Crypto.deriveKeyPairECDSA[LocalVariableDescriptor]

'deriveHMAC' @ [792:24] ==> private final fun deriveHMAC(privateKey: PrivateKey, seed: ByteArray): ByteArray defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'privateKey' @ [792:35] ==> value-parameter privateKey: PrivateKey defined in net.corda.core.crypto.Crypto.deriveKeyPairEdDSA[ValueParameterDescriptorImpl]

'seed' @ [792:47] ==> value-parameter seed: ByteArray defined in net.corda.core.crypto.Crypto.deriveKeyPairEdDSA[ValueParameterDescriptorImpl]

'EDDSA_ED25519_SHA512' @ [795:22] ==> @JvmField public final val EDDSA_ED25519_SHA512: SignatureScheme defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'algSpec' @ [795:43] ==> public final val algSpec: AlgorithmParameterSpec? defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'macBytes' @ [796:21] ==> val macBytes: ByteArray defined in net.corda.core.crypto.Crypto.deriveKeyPairEdDSA[LocalVariableDescriptor]

'copyOf' @ [796:30] ==> @InlineOnly public inline fun ByteArray.copyOf(newSize: Int): ByteArray defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]

'params' @ [796:37] ==> val params: EdDSANamedCurveSpec defined in net.corda.core.crypto.Crypto.deriveKeyPairEdDSA[LocalVariableDescriptor]

'curve' @ [796:44] ==> public final val EdDSANamedCurveSpec.curve: (Curve..Curve?)[MyPropertyDescriptor]

'field' @ [796:50] ==> public final val Curve.field: (Field..Field?)[MyPropertyDescriptor]

'getb' @ [796:56] ==> public open fun getb(): Int defined in net.i2p.crypto.eddsa.math.Field[JavaMethodDescriptor]

'EdDSAPrivateKeySpec' @ [797:27] ==> public constructor EdDSAPrivateKeySpec(p0: (ByteArray..ByteArray?), p1: (EdDSAParameterSpec..EdDSAParameterSpec?)) defined in net.i2p.crypto.eddsa.spec.EdDSAPrivateKeySpec[JavaClassConstructorDescriptor]

'bytes' @ [797:47] ==> val bytes: ByteArray defined in net.corda.core.crypto.Crypto.deriveKeyPairEdDSA[LocalVariableDescriptor]

'params' @ [797:54] ==> val params: EdDSANamedCurveSpec defined in net.corda.core.crypto.Crypto.deriveKeyPairEdDSA[LocalVariableDescriptor]

'EdDSAPublicKeySpec' @ [798:26] ==> public constructor EdDSAPublicKeySpec(p0: (GroupElement..GroupElement?), p1: (EdDSAParameterSpec..EdDSAParameterSpec?)) defined in net.i2p.crypto.eddsa.spec.EdDSAPublicKeySpec[JavaClassConstructorDescriptor]

'privateKeyD' @ [798:45] ==> val privateKeyD: EdDSAPrivateKeySpec defined in net.corda.core.crypto.Crypto.deriveKeyPairEdDSA[LocalVariableDescriptor]

'a' @ [798:57] ==> public final val EdDSAPrivateKeySpec.a: (GroupElement..GroupElement?)[MyPropertyDescriptor]

'params' @ [798:60] ==> val params: EdDSANamedCurveSpec defined in net.corda.core.crypto.Crypto.deriveKeyPairEdDSA[LocalVariableDescriptor]

'KeyPair' @ [799:16] ==> public constructor KeyPair(p0: (PublicKey..PublicKey?), p1: (PrivateKey..PrivateKey?)) defined in java.security.KeyPair[JavaClassConstructorDescriptor]

'EdDSAPublicKey' @ [799:24] ==> public constructor EdDSAPublicKey(p0: (EdDSAPublicKeySpec..EdDSAPublicKeySpec?)) defined in net.i2p.crypto.eddsa.EdDSAPublicKey[JavaClassConstructorDescriptor]

'publicKeyD' @ [799:39] ==> val publicKeyD: EdDSAPublicKeySpec defined in net.corda.core.crypto.Crypto.deriveKeyPairEdDSA[LocalVariableDescriptor]

'EdDSAPrivateKey' @ [799:52] ==> public constructor EdDSAPrivateKey(p0: (EdDSAPrivateKeySpec..EdDSAPrivateKeySpec?)) defined in net.i2p.crypto.eddsa.EdDSAPrivateKey[JavaClassConstructorDescriptor]

'privateKeyD' @ [799:68] ==> val privateKeyD: EdDSAPrivateKeySpec defined in net.corda.core.crypto.Crypto.deriveKeyPairEdDSA[LocalVariableDescriptor]

'JvmStatic' @ [811:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'when (signatureScheme) {
            EDDSA_ED25519_SHA512 -> deriveEdDSAKeyPairFromEntropy(entropy)
            else -> throw IllegalArgumentException("Unsupported signature scheme for fixed entropy-based key pair " +
                    "generation: ${signatureScheme.schemeCodeName}")
        }' @ [813:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: KeyPair, entry1: KeyPair): KeyPair[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> KeyPair

'signatureScheme' @ [813:22] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.deriveKeyPairFromEntropy[ValueParameterDescriptorImpl]

'EDDSA_ED25519_SHA512' @ [814:13] ==> @JvmField public final val EDDSA_ED25519_SHA512: SignatureScheme defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'deriveEdDSAKeyPairFromEntropy' @ [814:37] ==> private final fun deriveEdDSAKeyPairFromEntropy(entropy: BigInteger): KeyPair defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'entropy' @ [814:67] ==> value-parameter entropy: BigInteger defined in net.corda.core.crypto.Crypto.deriveKeyPairFromEntropy[ValueParameterDescriptorImpl]

'IllegalArgumentException' @ [815:27] ==> public final fun <init>(p0: (String..String?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'+' @ [815:52] ==> public final operator fun plus(other: Any?): String defined in kotlin.String[DeserializedSimpleFunctionDescriptor]

'signatureScheme' @ [816:36] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.deriveKeyPairFromEntropy[ValueParameterDescriptorImpl]

'schemeCodeName' @ [816:52] ==> public final val schemeCodeName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'JvmStatic' @ [825:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'deriveKeyPairFromEntropy' @ [826:66] ==> @JvmStatic public final fun deriveKeyPairFromEntropy(signatureScheme: SignatureScheme, entropy: BigInteger): KeyPair defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'DEFAULT_SIGNATURE_SCHEME' @ [826:91] ==> @JvmField public final val DEFAULT_SIGNATURE_SCHEME: SignatureScheme defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'entropy' @ [826:117] ==> value-parameter entropy: BigInteger defined in net.corda.core.crypto.Crypto.deriveKeyPairFromEntropy[ValueParameterDescriptorImpl]

'EDDSA_ED25519_SHA512' @ [830:22] ==> @JvmField public final val EDDSA_ED25519_SHA512: SignatureScheme defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'algSpec' @ [830:43] ==> public final val algSpec: AlgorithmParameterSpec? defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'entropy' @ [831:21] ==> value-parameter entropy: BigInteger defined in net.corda.core.crypto.Crypto.deriveEdDSAKeyPairFromEntropy[ValueParameterDescriptorImpl]

'toByteArray' @ [831:29] ==> public open fun toByteArray(): (ByteArray..ByteArray?) defined in java.math.BigInteger[JavaMethodDescriptor]

'copyOf' @ [831:43] ==> @InlineOnly public inline fun ByteArray.copyOf(newSize: Int): ByteArray defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]

'params' @ [831:50] ==> val params: EdDSANamedCurveSpec defined in net.corda.core.crypto.Crypto.deriveEdDSAKeyPairFromEntropy[LocalVariableDescriptor]

'curve' @ [831:57] ==> public final val EdDSANamedCurveSpec.curve: (Curve..Curve?)[MyPropertyDescriptor]

'field' @ [831:63] ==> public final val Curve.field: (Field..Field?)[MyPropertyDescriptor]

'getb' @ [831:69] ==> public open fun getb(): Int defined in net.i2p.crypto.eddsa.math.Field[JavaMethodDescriptor]

'EdDSAPrivateKeySpec' @ [832:20] ==> public constructor EdDSAPrivateKeySpec(p0: (ByteArray..ByteArray?), p1: (EdDSAParameterSpec..EdDSAParameterSpec?)) defined in net.i2p.crypto.eddsa.spec.EdDSAPrivateKeySpec[JavaClassConstructorDescriptor]

'bytes' @ [832:40] ==> val bytes: ByteArray defined in net.corda.core.crypto.Crypto.deriveEdDSAKeyPairFromEntropy[LocalVariableDescriptor]

'params' @ [832:47] ==> val params: EdDSANamedCurveSpec defined in net.corda.core.crypto.Crypto.deriveEdDSAKeyPairFromEntropy[LocalVariableDescriptor]

'EdDSAPublicKeySpec' @ [833:19] ==> public constructor EdDSAPublicKeySpec(p0: (GroupElement..GroupElement?), p1: (EdDSAParameterSpec..EdDSAParameterSpec?)) defined in net.i2p.crypto.eddsa.spec.EdDSAPublicKeySpec[JavaClassConstructorDescriptor]

'priv' @ [833:38] ==> val priv: EdDSAPrivateKeySpec defined in net.corda.core.crypto.Crypto.deriveEdDSAKeyPairFromEntropy[LocalVariableDescriptor]

'a' @ [833:43] ==> public final val EdDSAPrivateKeySpec.a: (GroupElement..GroupElement?)[MyPropertyDescriptor]

'params' @ [833:46] ==> val params: EdDSANamedCurveSpec defined in net.corda.core.crypto.Crypto.deriveEdDSAKeyPairFromEntropy[LocalVariableDescriptor]

'KeyPair' @ [834:16] ==> public constructor KeyPair(p0: (PublicKey..PublicKey?), p1: (PrivateKey..PrivateKey?)) defined in java.security.KeyPair[JavaClassConstructorDescriptor]

'EdDSAPublicKey' @ [834:24] ==> public constructor EdDSAPublicKey(p0: (EdDSAPublicKeySpec..EdDSAPublicKeySpec?)) defined in net.i2p.crypto.eddsa.EdDSAPublicKey[JavaClassConstructorDescriptor]

'pub' @ [834:39] ==> val pub: EdDSAPublicKeySpec defined in net.corda.core.crypto.Crypto.deriveEdDSAKeyPairFromEntropy[LocalVariableDescriptor]

'EdDSAPrivateKey' @ [834:45] ==> public constructor EdDSAPrivateKey(p0: (EdDSAPrivateKeySpec..EdDSAPrivateKeySpec?)) defined in net.i2p.crypto.eddsa.EdDSAPrivateKey[JavaClassConstructorDescriptor]

'priv' @ [834:61] ==> val priv: EdDSAPrivateKeySpec defined in net.corda.core.crypto.Crypto.deriveEdDSAKeyPairFromEntropy[LocalVariableDescriptor]

'getInstance' @ [840:23] ==> public final fun getInstance(p0: (String..String?), p1: (Provider..Provider?)): (Mac..Mac?) defined in javax.crypto.Mac[JavaMethodDescriptor]

'providerMap' @ [840:49] ==> private final val providerMap: Map<String, Provider> defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'PROVIDER_NAME' @ [840:82] ==> public const final val PROVIDER_NAME: String defined in org.bouncycastle.jce.provider.BouncyCastleProvider[JavaPropertyDescriptor]

'when (privateKey) {
            is BCECPrivateKey -> privateKey.d.toByteArray()
            is EdDSAPrivateKey -> privateKey.geta()
            else -> throw InvalidKeyException("Key type ${privateKey.algorithm} is not supported for deterministic key derivation")
        }' @ [841:23] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: (ByteArray..ByteArray?), entry1: (ByteArray..ByteArray?), entry2: (ByteArray..ByteArray?)): (ByteArray..ByteArray?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> (kotlin.ByteArray..kotlin.ByteArray?)

'privateKey' @ [841:29] ==> value-parameter privateKey: PrivateKey defined in net.corda.core.crypto.Crypto.deriveHMAC[ValueParameterDescriptorImpl]

'privateKey' @ [842:34] ==> value-parameter privateKey: PrivateKey defined in net.corda.core.crypto.Crypto.deriveHMAC[ValueParameterDescriptorImpl]

'd' @ [842:45] ==> public final val BCECPrivateKey.d: (BigInteger..BigInteger?)[MyPropertyDescriptor]

'toByteArray' @ [842:47] ==> public open fun toByteArray(): (ByteArray..ByteArray?) defined in java.math.BigInteger[JavaMethodDescriptor]

'privateKey' @ [843:35] ==> value-parameter privateKey: PrivateKey defined in net.corda.core.crypto.Crypto.deriveHMAC[ValueParameterDescriptorImpl]

'geta' @ [843:46] ==> public open fun geta(): (ByteArray..ByteArray?) defined in net.i2p.crypto.eddsa.EdDSAPrivateKey[JavaMethodDescriptor]

'InvalidKeyException' @ [844:27] ==> public constructor InvalidKeyException(p0: (String..String?)) defined in java.security.InvalidKeyException[JavaClassConstructorDescriptor]

'privateKey' @ [844:59] ==> value-parameter privateKey: PrivateKey defined in net.corda.core.crypto.Crypto.deriveHMAC[ValueParameterDescriptorImpl]

'algorithm' @ [844:70] ==> public final val PrivateKey.algorithm: (String..String?)[MyPropertyDescriptor]

'SecretKeySpec' @ [846:19] ==> public constructor SecretKeySpec(p0: (ByteArray..ByteArray?), p1: (String..String?)) defined in javax.crypto.spec.SecretKeySpec[JavaClassConstructorDescriptor]

'keyData' @ [846:33] ==> val keyData: (ByteArray..ByteArray?) defined in net.corda.core.crypto.Crypto.deriveHMAC[LocalVariableDescriptor]

'mac' @ [847:9] ==> val mac: (Mac..Mac?) defined in net.corda.core.crypto.Crypto.deriveHMAC[LocalVariableDescriptor]

'init' @ [847:13] ==> public final fun init(p0: (Key..Key?)): Unit defined in javax.crypto.Mac[JavaMethodDescriptor]

'key' @ [847:18] ==> val key: SecretKeySpec defined in net.corda.core.crypto.Crypto.deriveHMAC[LocalVariableDescriptor]

'mac' @ [848:16] ==> val mac: (Mac..Mac?) defined in net.corda.core.crypto.Crypto.deriveHMAC[LocalVariableDescriptor]

'doFinal' @ [848:20] ==> public final fun doFinal(p0: (ByteArray..ByteArray?)): (ByteArray..ByteArray?) defined in javax.crypto.Mac[JavaMethodDescriptor]

'seed' @ [848:28] ==> value-parameter seed: ByteArray defined in net.corda.core.crypto.Crypto.deriveHMAC[ValueParameterDescriptorImpl]

'keyInfo' @ [853:20] ==> value-parameter keyInfo: SubjectPublicKeyInfo? defined in net.corda.core.crypto.Crypto.KeyInfoConverter.generatePublic[ValueParameterDescriptorImpl]

'let' @ [853:29] ==> @InlineOnly public inline fun <T, R> SubjectPublicKeyInfo.let(block: (SubjectPublicKeyInfo) -> PublicKey): PublicKey defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SubjectPublicKeyInfo
    <R> -> PublicKey

'decodePublicKey' @ [853:35] ==> @JvmStatic @Throws public final fun decodePublicKey(signatureScheme: SignatureScheme, encodedKey: ByteArray): PublicKey defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'signatureScheme' @ [853:51] ==> public final val signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.KeyInfoConverter[PropertyDescriptorImpl]

'it' @ [853:68] ==> value-parameter it: SubjectPublicKeyInfo defined in net.corda.core.crypto.Crypto.KeyInfoConverter.generatePublic.<anonymous>[ValueParameterDescriptorImpl]

'encoded' @ [853:71] ==> public final val SubjectPublicKeyInfo.encoded: (ByteArray..ByteArray?)[MyPropertyDescriptor]

'keyInfo' @ [856:20] ==> value-parameter keyInfo: PrivateKeyInfo? defined in net.corda.core.crypto.Crypto.KeyInfoConverter.generatePrivate[ValueParameterDescriptorImpl]

'let' @ [856:29] ==> @InlineOnly public inline fun <T, R> PrivateKeyInfo.let(block: (PrivateKeyInfo) -> PrivateKey): PrivateKey defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PrivateKeyInfo
    <R> -> PrivateKey

'decodePrivateKey' @ [856:35] ==> @JvmStatic @Throws public final fun decodePrivateKey(signatureScheme: SignatureScheme, encodedKey: ByteArray): PrivateKey defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'signatureScheme' @ [856:52] ==> public final val signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.KeyInfoConverter[PropertyDescriptorImpl]

'it' @ [856:69] ==> value-parameter it: PrivateKeyInfo defined in net.corda.core.crypto.Crypto.KeyInfoConverter.generatePrivate.<anonymous>[ValueParameterDescriptorImpl]

'encoded' @ [856:72] ==> public final val PrivateKeyInfo.encoded: (ByteArray..ByteArray?)[MyPropertyDescriptor]

'JvmStatic' @ [874:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'require' @ [876:9] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'isSupportedSignatureScheme' @ [876:17] ==> @JvmStatic public final fun isSupportedSignatureScheme(signatureScheme: SignatureScheme): Boolean defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'signatureScheme' @ [876:44] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.publicKeyOnCurve[ValueParameterDescriptorImpl]

'signatureScheme' @ [877:62] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.publicKeyOnCurve[ValueParameterDescriptorImpl]

'schemeCodeName' @ [877:78] ==> public final val schemeCodeName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'when (publicKey) {
            is BCECPublicKey -> publicKey.parameters == signatureScheme.algSpec && !publicKey.q.isInfinity && publicKey.q.isValid
            is EdDSAPublicKey -> publicKey.params == signatureScheme.algSpec && !isEdDSAPointAtInfinity(publicKey) && publicKey.a.isOnCurve
            else -> throw IllegalArgumentException("Unsupported key type: ${publicKey::class}")
        }' @ [879:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean, entry2: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'publicKey' @ [879:22] ==> value-parameter publicKey: PublicKey defined in net.corda.core.crypto.Crypto.publicKeyOnCurve[ValueParameterDescriptorImpl]

'publicKey' @ [880:33] ==> value-parameter publicKey: PublicKey defined in net.corda.core.crypto.Crypto.publicKeyOnCurve[ValueParameterDescriptorImpl]

'parameters' @ [880:43] ==> public final val BCECPublicKey.parameters: (ECParameterSpec..ECParameterSpec?)[MyPropertyDescriptor]

'signatureScheme' @ [880:57] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.publicKeyOnCurve[ValueParameterDescriptorImpl]

'algSpec' @ [880:73] ==> public final val algSpec: AlgorithmParameterSpec? defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'!' @ [880:84] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'publicKey' @ [880:85] ==> value-parameter publicKey: PublicKey defined in net.corda.core.crypto.Crypto.publicKeyOnCurve[ValueParameterDescriptorImpl]

'q' @ [880:95] ==> public final val BCECPublicKey.q: (ECPoint..ECPoint?)[MyPropertyDescriptor]

'isInfinity' @ [880:97] ==> public final val ECPoint.isInfinity: Boolean[MyPropertyDescriptor]

'publicKey' @ [880:111] ==> value-parameter publicKey: PublicKey defined in net.corda.core.crypto.Crypto.publicKeyOnCurve[ValueParameterDescriptorImpl]

'q' @ [880:121] ==> public final val BCECPublicKey.q: (ECPoint..ECPoint?)[MyPropertyDescriptor]

'isValid' @ [880:123] ==> public final val ECPoint.isValid: Boolean[MyPropertyDescriptor]

'publicKey' @ [881:34] ==> value-parameter publicKey: PublicKey defined in net.corda.core.crypto.Crypto.publicKeyOnCurve[ValueParameterDescriptorImpl]

'params' @ [881:44] ==> public final val EdDSAPublicKey.params: (EdDSAParameterSpec..EdDSAParameterSpec?)[MyPropertyDescriptor]

'signatureScheme' @ [881:54] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.publicKeyOnCurve[ValueParameterDescriptorImpl]

'algSpec' @ [881:70] ==> public final val algSpec: AlgorithmParameterSpec? defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'!' @ [881:81] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'isEdDSAPointAtInfinity' @ [881:82] ==> private final fun isEdDSAPointAtInfinity(publicKey: EdDSAPublicKey): Boolean defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'publicKey' @ [881:105] ==> value-parameter publicKey: PublicKey defined in net.corda.core.crypto.Crypto.publicKeyOnCurve[ValueParameterDescriptorImpl]

'publicKey' @ [881:119] ==> value-parameter publicKey: PublicKey defined in net.corda.core.crypto.Crypto.publicKeyOnCurve[ValueParameterDescriptorImpl]

'a' @ [881:129] ==> public final val EdDSAPublicKey.a: (GroupElement..GroupElement?)[MyPropertyDescriptor]

'isOnCurve' @ [881:131] ==> public final val GroupElement.isOnCurve: Boolean[MyPropertyDescriptor]

'IllegalArgumentException' @ [882:27] ==> public final fun <init>(p0: (String..String?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'publicKey' @ [882:77] ==> value-parameter publicKey: PublicKey defined in net.corda.core.crypto.Crypto.publicKeyOnCurve[ValueParameterDescriptorImpl]

'publicKey' @ [889:16] ==> value-parameter publicKey: EdDSAPublicKey defined in net.corda.core.crypto.Crypto.isEdDSAPointAtInfinity[ValueParameterDescriptorImpl]

'a' @ [889:26] ==> public final val EdDSAPublicKey.a: (GroupElement..GroupElement?)[MyPropertyDescriptor]

'toP3' @ [889:28] ==> public open fun toP3(): (GroupElement..GroupElement?) defined in net.i2p.crypto.eddsa.math.GroupElement[JavaMethodDescriptor]

'EDDSA_ED25519_SHA512' @ [889:39] ==> @JvmField public final val EDDSA_ED25519_SHA512: SignatureScheme defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'algSpec' @ [889:60] ==> public final val algSpec: AlgorithmParameterSpec? defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'curve' @ [889:92] ==> public final val EdDSANamedCurveSpec.curve: (Curve..Curve?)[MyPropertyDescriptor]

'getZero' @ [889:98] ==> public open fun getZero(p0: (GroupElement.Representation..GroupElement.Representation?)): (GroupElement..GroupElement?) defined in net.i2p.crypto.eddsa.math.Curve[JavaMethodDescriptor]

'P3' @ [889:134] ==> enum entry P3 defined in net.i2p.crypto.eddsa.math.GroupElement.Representation[FakeCallableDescriptorForObject]

'JvmStatic' @ [893:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'signatureScheme' @ [895:16] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.isSupportedSignatureScheme[ValueParameterDescriptorImpl]

'schemeCodeName' @ [895:32] ==> public final val schemeCodeName: String defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'signatureSchemeMap' @ [895:50] ==> private final val signatureSchemeMap: Map<String, SignatureScheme> defined in net.corda.core.crypto.Crypto[PropertyDescriptorImpl]

'when (key) {
            is PublicKey -> validatePublicKey(signatureScheme, key)
            is PrivateKey -> validatePrivateKey(signatureScheme, key)
            else -> throw IllegalArgumentException("Unsupported key type: ${key::class}")
        }' @ [900:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean, entry2: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'key' @ [900:22] ==> value-parameter key: Key defined in net.corda.core.crypto.Crypto.validateKey[ValueParameterDescriptorImpl]

'validatePublicKey' @ [901:29] ==> private final fun validatePublicKey(signatureScheme: SignatureScheme, key: PublicKey): Boolean defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'signatureScheme' @ [901:47] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.validateKey[ValueParameterDescriptorImpl]

'key' @ [901:64] ==> value-parameter key: Key defined in net.corda.core.crypto.Crypto.validateKey[ValueParameterDescriptorImpl]

'validatePrivateKey' @ [902:30] ==> private final fun validatePrivateKey(signatureScheme: SignatureScheme, key: PrivateKey): Boolean defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'signatureScheme' @ [902:49] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.validateKey[ValueParameterDescriptorImpl]

'key' @ [902:66] ==> value-parameter key: Key defined in net.corda.core.crypto.Crypto.validateKey[ValueParameterDescriptorImpl]

'IllegalArgumentException' @ [903:27] ==> public final fun <init>(p0: (String..String?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'key' @ [903:77] ==> value-parameter key: Key defined in net.corda.core.crypto.Crypto.validateKey[ValueParameterDescriptorImpl]

'when (key) {
            is BCECPublicKey, is EdDSAPublicKey -> publicKeyOnCurve(signatureScheme, key)
            is BCRSAPublicKey, is BCSphincs256PublicKey -> true // TODO: Check if non-ECC keys satisfy params (i.e. approved/valid RSA modulus size).
            else -> throw IllegalArgumentException("Unsupported key type: ${key::class}")
        }' @ [909:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean, entry2: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'key' @ [909:22] ==> value-parameter key: PublicKey defined in net.corda.core.crypto.Crypto.validatePublicKey[ValueParameterDescriptorImpl]

'publicKeyOnCurve' @ [910:52] ==> @JvmStatic public final fun publicKeyOnCurve(signatureScheme: SignatureScheme, publicKey: PublicKey): Boolean defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'signatureScheme' @ [910:69] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.validatePublicKey[ValueParameterDescriptorImpl]

'key' @ [910:86] ==> value-parameter key: PublicKey defined in net.corda.core.crypto.Crypto.validatePublicKey[ValueParameterDescriptorImpl]

'IllegalArgumentException' @ [912:27] ==> public final fun <init>(p0: (String..String?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'key' @ [912:77] ==> value-parameter key: PublicKey defined in net.corda.core.crypto.Crypto.validatePublicKey[ValueParameterDescriptorImpl]

'when (key) {
            is BCECPrivateKey -> key.parameters == signatureScheme.algSpec
            is EdDSAPrivateKey -> key.params == signatureScheme.algSpec
            is BCRSAPrivateKey, is BCSphincs256PrivateKey -> true // TODO: Check if non-ECC keys satisfy params (i.e. approved/valid RSA modulus size).
            else -> throw IllegalArgumentException("Unsupported key type: ${key::class}")
        }' @ [918:16] ==> public final fun <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-WHEN-RESOLVE>`(entry0: Boolean, entry1: Boolean, entry2: Boolean, entry3: Boolean): Boolean[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-WHEN-RESOLVE>`> -> Boolean

'key' @ [918:22] ==> value-parameter key: PrivateKey defined in net.corda.core.crypto.Crypto.validatePrivateKey[ValueParameterDescriptorImpl]

'key' @ [919:34] ==> value-parameter key: PrivateKey defined in net.corda.core.crypto.Crypto.validatePrivateKey[ValueParameterDescriptorImpl]

'parameters' @ [919:38] ==> public final val BCECPrivateKey.parameters: (ECParameterSpec..ECParameterSpec?)[MyPropertyDescriptor]

'signatureScheme' @ [919:52] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.validatePrivateKey[ValueParameterDescriptorImpl]

'algSpec' @ [919:68] ==> public final val algSpec: AlgorithmParameterSpec? defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'key' @ [920:35] ==> value-parameter key: PrivateKey defined in net.corda.core.crypto.Crypto.validatePrivateKey[ValueParameterDescriptorImpl]

'params' @ [920:39] ==> public final val EdDSAPrivateKey.params: (EdDSAParameterSpec..EdDSAParameterSpec?)[MyPropertyDescriptor]

'signatureScheme' @ [920:49] ==> value-parameter signatureScheme: SignatureScheme defined in net.corda.core.crypto.Crypto.validatePrivateKey[ValueParameterDescriptorImpl]

'algSpec' @ [920:65] ==> public final val algSpec: AlgorithmParameterSpec? defined in net.corda.core.crypto.SignatureScheme[PropertyDescriptorImpl]

'IllegalArgumentException' @ [922:27] ==> public final fun <init>(p0: (String..String?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'key' @ [922:77] ==> value-parameter key: PrivateKey defined in net.corda.core.crypto.Crypto.validatePrivateKey[ValueParameterDescriptorImpl]

'JvmStatic' @ [935:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'decodePublicKey' @ [936:70] ==> @JvmStatic public final fun decodePublicKey(encodedKey: ByteArray): PublicKey defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'key' @ [936:86] ==> value-parameter key: SubjectPublicKeyInfo defined in net.corda.core.crypto.Crypto.toSupportedPublicKey[ValueParameterDescriptorImpl]

'encoded' @ [936:90] ==> public final val SubjectPublicKeyInfo.encoded: (ByteArray..ByteArray?)[MyPropertyDescriptor]

'JvmStatic' @ [947:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'decodePublicKey' @ [948:59] ==> @JvmStatic public final fun decodePublicKey(encodedKey: ByteArray): PublicKey defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'key' @ [948:75] ==> value-parameter key: PublicKey defined in net.corda.core.crypto.Crypto.toSupportedPublicKey[ValueParameterDescriptorImpl]

'encoded' @ [948:79] ==> public final val PublicKey.encoded: (ByteArray..ByteArray?)[MyPropertyDescriptor]

'JvmStatic' @ [958:5] ==> public constructor JvmStatic() defined in kotlin.jvm.JvmStatic[DeserializedClassConstructorDescriptor]

'decodePrivateKey' @ [959:62] ==> @JvmStatic public final fun decodePrivateKey(encodedKey: ByteArray): PrivateKey defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'key' @ [959:79] ==> value-parameter key: PrivateKey defined in net.corda.core.crypto.Crypto.toSupportedPrivateKey[ValueParameterDescriptorImpl]

'encoded' @ [959:83] ==> public final val PrivateKey.encoded: (ByteArray..ByteArray?)[MyPropertyDescriptor]

