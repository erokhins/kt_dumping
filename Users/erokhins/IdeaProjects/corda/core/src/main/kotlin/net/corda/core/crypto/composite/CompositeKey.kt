'CordaSerializable' @ [34:1] ==> public constructor CordaSerializable() defined in net.corda.core.serialization.CordaSerializable[ClassConstructorDescriptorImpl]

'getInstance' @ [41:47] ==> public final fun getInstance(asn1: ASN1Primitive): PublicKey defined in net.corda.core.crypto.composite.CompositeKey.Companion[SimpleFunctionDescriptorImpl]

'fromByteArray' @ [41:73] ==> public open fun fromByteArray(p0: (ByteArray..ByteArray?)): (ASN1Primitive..ASN1Primitive?) defined in org.bouncycastle.asn1.ASN1Primitive[JavaMethodDescriptor]

'encoded' @ [41:87] ==> value-parameter encoded: ByteArray defined in net.corda.core.crypto.composite.CompositeKey.Companion.getInstance[ValueParameterDescriptorImpl]

'getInstance' @ [44:48] ==> public open fun getInstance(p0: (Any..Any?)): (SubjectPublicKeyInfo..SubjectPublicKeyInfo?) defined in org.bouncycastle.asn1.x509.SubjectPublicKeyInfo[JavaMethodDescriptor]

'asn1' @ [44:60] ==> value-parameter asn1: ASN1Primitive defined in net.corda.core.crypto.composite.CompositeKey.Companion.getInstance[ValueParameterDescriptorImpl]

'require' @ [45:13] ==> @InlineOnly public inline fun require(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'keyInfo' @ [45:21] ==> val keyInfo: (SubjectPublicKeyInfo..SubjectPublicKeyInfo?) defined in net.corda.core.crypto.composite.CompositeKey.Companion.getInstance[LocalVariableDescriptor]

'algorithm' @ [45:29] ==> public final val SubjectPublicKeyInfo.algorithm: (AlgorithmIdentifier..AlgorithmIdentifier?)[MyPropertyDescriptor]

'algorithm' @ [45:39] ==> public final val AlgorithmIdentifier.algorithm: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?)[MyPropertyDescriptor]

'COMPOSITE_KEY' @ [45:74] ==> @JvmField public final val COMPOSITE_KEY: ASN1ObjectIdentifier defined in net.corda.core.crypto.provider.CordaObjectIdentifier[PropertyDescriptorImpl]

'getInstance' @ [46:41] ==> public open fun getInstance(p0: (Any..Any?)): (ASN1Sequence..ASN1Sequence?) defined in org.bouncycastle.asn1.ASN1Sequence[JavaMethodDescriptor]

'keyInfo' @ [46:53] ==> val keyInfo: (SubjectPublicKeyInfo..SubjectPublicKeyInfo?) defined in net.corda.core.crypto.composite.CompositeKey.Companion.getInstance[LocalVariableDescriptor]

'parsePublicKey' @ [46:61] ==> public open fun parsePublicKey(): (ASN1Primitive..ASN1Primitive?) defined in org.bouncycastle.asn1.x509.SubjectPublicKeyInfo[JavaMethodDescriptor]

'getInstance' @ [47:41] ==> public open fun getInstance(p0: (Any..Any?)): (ASN1Integer..ASN1Integer?) defined in org.bouncycastle.asn1.ASN1Integer[JavaMethodDescriptor]

'sequence' @ [47:53] ==> val sequence: (ASN1Sequence..ASN1Sequence?) defined in net.corda.core.crypto.composite.CompositeKey.Companion.getInstance[LocalVariableDescriptor]

'getObjectAt' @ [47:62] ==> public open fun getObjectAt(p0: Int): (ASN1Encodable..ASN1Encodable?) defined in org.bouncycastle.asn1.ASN1Sequence[JavaMethodDescriptor]

'positiveValue' @ [47:78] ==> public final val ASN1Integer.positiveValue: (BigInteger..BigInteger?)[MyPropertyDescriptor]

'toInt' @ [47:92] ==> public open fun toInt(): Int defined in java.math.BigInteger[JavaMethodDescriptor]

'getInstance' @ [48:51] ==> public open fun getInstance(p0: (Any..Any?)): (ASN1Sequence..ASN1Sequence?) defined in org.bouncycastle.asn1.ASN1Sequence[JavaMethodDescriptor]

'sequence' @ [48:63] ==> val sequence: (ASN1Sequence..ASN1Sequence?) defined in net.corda.core.crypto.composite.CompositeKey.Companion.getInstance[LocalVariableDescriptor]

'getObjectAt' @ [48:72] ==> public open fun getObjectAt(p0: Int): (ASN1Encodable..ASN1Encodable?) defined in org.bouncycastle.asn1.ASN1Sequence[JavaMethodDescriptor]

'Builder' @ [49:27] ==> public constructor Builder() defined in net.corda.core.crypto.composite.CompositeKey.Builder[ClassConstructorDescriptorImpl]

'sequenceOfChildren' @ [50:34] ==> val sequenceOfChildren: (ASN1Sequence..ASN1Sequence?) defined in net.corda.core.crypto.composite.CompositeKey.Companion.getInstance[LocalVariableDescriptor]

'objects' @ [50:53] ==> public final val ASN1Sequence.objects: raw (Enumeration<(Any..Any?)>..Enumeration<*>?)[MyPropertyDescriptor]

'toList' @ [50:61] ==> @InlineOnly public inline fun <T> Enumeration<(Any..Any?)>.toList(): List<(Any..Any?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.Any..kotlin.Any?)

'listOfChildren' @ [51:13] ==> val listOfChildren: List<(Any..Any?)> defined in net.corda.core.crypto.composite.CompositeKey.Companion.getInstance[LocalVariableDescriptor]

'forEach' @ [51:28] ==> @HidesMembers public inline fun <T> Iterable<(Any..Any?)>.forEach(action: ((Any..Any?)) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (kotlin.Any..kotlin.Any?)

'require' @ [52:17] ==> @InlineOnly public inline fun require(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'childAsn1' @ [52:25] ==> value-parameter childAsn1: (Any..Any?) defined in net.corda.core.crypto.composite.CompositeKey.Companion.getInstance.<anonymous>[ValueParameterDescriptorImpl]

'childAsn1' @ [53:32] ==> value-parameter childAsn1: (Any..Any?) defined in net.corda.core.crypto.composite.CompositeKey.Companion.getInstance.<anonymous>[ValueParameterDescriptorImpl]

'Crypto' @ [54:27] ==> public object Crypto defined in net.corda.core.crypto in file Crypto.kt[FakeCallableDescriptorForObject]

'decodePublicKey' @ [54:34] ==> @JvmStatic public final fun decodePublicKey(encodedKey: ByteArray): PublicKey defined in net.corda.core.crypto.Crypto[SimpleFunctionDescriptorImpl]

'childSeq' @ [54:51] ==> val childSeq: ASN1Sequence defined in net.corda.core.crypto.composite.CompositeKey.Companion.getInstance.<anonymous>[LocalVariableDescriptor]

'getObjectAt' @ [54:60] ==> public open fun getObjectAt(p0: Int): (ASN1Encodable..ASN1Encodable?) defined in org.bouncycastle.asn1.ASN1Sequence[JavaMethodDescriptor]

'bytes' @ [54:92] ==> public final val DERBitString.bytes: (ByteArray..ByteArray?)[MyPropertyDescriptor]

'getInstance' @ [55:42] ==> public open fun getInstance(p0: (Any..Any?)): (ASN1Integer..ASN1Integer?) defined in org.bouncycastle.asn1.ASN1Integer[JavaMethodDescriptor]

'childSeq' @ [55:54] ==> val childSeq: ASN1Sequence defined in net.corda.core.crypto.composite.CompositeKey.Companion.getInstance.<anonymous>[LocalVariableDescriptor]

'getObjectAt' @ [55:63] ==> public open fun getObjectAt(p0: Int): (ASN1Encodable..ASN1Encodable?) defined in org.bouncycastle.asn1.ASN1Sequence[JavaMethodDescriptor]

'builder' @ [56:17] ==> val builder: CompositeKey.Builder defined in net.corda.core.crypto.composite.CompositeKey.Companion.getInstance[LocalVariableDescriptor]

'addKey' @ [56:25] ==> public final fun addKey(key: PublicKey, weight: Int = ...): CompositeKey.Builder defined in net.corda.core.crypto.composite.CompositeKey.Builder[SimpleFunctionDescriptorImpl]

'key' @ [56:32] ==> val key: PublicKey defined in net.corda.core.crypto.composite.CompositeKey.Companion.getInstance.<anonymous>[LocalVariableDescriptor]

'weight' @ [56:37] ==> val weight: (ASN1Integer..ASN1Integer?) defined in net.corda.core.crypto.composite.CompositeKey.Companion.getInstance.<anonymous>[LocalVariableDescriptor]

'positiveValue' @ [56:44] ==> public final val ASN1Integer.positiveValue: (BigInteger..BigInteger?)[MyPropertyDescriptor]

'toInt' @ [56:58] ==> public open fun toInt(): Int defined in java.math.BigInteger[JavaMethodDescriptor]

'builder' @ [58:20] ==> val builder: CompositeKey.Builder defined in net.corda.core.crypto.composite.CompositeKey.Companion.getInstance[LocalVariableDescriptor]

'build' @ [58:28] ==> public final fun build(threshold: Int? = ...): PublicKey defined in net.corda.core.crypto.composite.CompositeKey.Builder[SimpleFunctionDescriptorImpl]

'threshold' @ [58:34] ==> val threshold: Int defined in net.corda.core.crypto.composite.CompositeKey.Companion.getInstance[LocalVariableDescriptor]

'children' @ [62:41] ==> value-parameter children: List<CompositeKey.NodeAndWeight> defined in net.corda.core.crypto.composite.CompositeKey.<init>[ValueParameterDescriptorImpl]

'sorted' @ [62:50] ==> public fun <T : Comparable<CompositeKey.NodeAndWeight>> Iterable<CompositeKey.NodeAndWeight>.sorted(): List<CompositeKey.NodeAndWeight> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Comparable<T>> -> NodeAndWeight

'checkConstraints' @ [66:9] ==> private final fun checkConstraints(): Unit defined in net.corda.core.crypto.composite.CompositeKey[SimpleFunctionDescriptorImpl]

'Transient' @ [69:5] ==> public constructor Transient() defined in kotlin.jvm.Transient[DeserializedClassConstructorDescriptor]

'require' @ [74:9] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'children' @ [74:17] ==> public final val children: List<CompositeKey.NodeAndWeight> defined in net.corda.core.crypto.composite.CompositeKey[PropertyDescriptorImpl]

'size' @ [74:26] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'children' @ [74:34] ==> public final val children: List<CompositeKey.NodeAndWeight> defined in net.corda.core.crypto.composite.CompositeKey[PropertyDescriptorImpl]

'toSet' @ [74:43] ==> public fun <T> Iterable<CompositeKey.NodeAndWeight>.toSet(): Set<CompositeKey.NodeAndWeight> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> NodeAndWeight

'size' @ [74:51] ==> public abstract val size: Int defined in kotlin.collections.Set[DeserializedPropertyDescriptor]

'require' @ [77:9] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'children' @ [77:17] ==> public final val children: List<CompositeKey.NodeAndWeight> defined in net.corda.core.crypto.composite.CompositeKey[PropertyDescriptorImpl]

'size' @ [77:26] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'require' @ [79:9] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'threshold' @ [79:17] ==> public final val threshold: Int defined in net.corda.core.crypto.composite.CompositeKey[PropertyDescriptorImpl]

'threshold' @ [79:69] ==> public final val threshold: Int defined in net.corda.core.crypto.composite.CompositeKey[PropertyDescriptorImpl]

'totalWeight' @ [81:27] ==> private final fun totalWeight(): Int defined in net.corda.core.crypto.composite.CompositeKey[SimpleFunctionDescriptorImpl]

'require' @ [82:9] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'threshold' @ [82:17] ==> public final val threshold: Int defined in net.corda.core.crypto.composite.CompositeKey[PropertyDescriptorImpl]

'totalWeight' @ [82:30] ==> val totalWeight: Int defined in net.corda.core.crypto.composite.CompositeKey.checkConstraints[LocalVariableDescriptor]

'threshold' @ [83:39] ==> public final val threshold: Int defined in net.corda.core.crypto.composite.CompositeKey[PropertyDescriptorImpl]

'totalWeight' @ [83:106] ==> val totalWeight: Int defined in net.corda.core.crypto.composite.CompositeKey.checkConstraints[LocalVariableDescriptor]

'component1' @ [91:15] ==> public final operator fun component1(): PublicKey defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[SimpleFunctionDescriptorImpl]

'children' @ [91:24] ==> public final val children: List<CompositeKey.NodeAndWeight> defined in net.corda.core.crypto.composite.CompositeKey[PropertyDescriptorImpl]

'node' @ [92:17] ==> val node: PublicKey defined in net.corda.core.crypto.composite.CompositeKey.cycleDetection[LocalVariableDescriptor]

'IdentityHashMap' @ [93:37] ==> public constructor IdentityHashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.IdentityHashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> CompositeKey
    <V : (Any..Any?)> -> Boolean

'curVisitedMap' @ [94:17] ==> val curVisitedMap: IdentityHashMap<CompositeKey, Boolean> defined in net.corda.core.crypto.composite.CompositeKey.cycleDetection[LocalVariableDescriptor]

'putAll' @ [94:31] ==> public open fun putAll(from: Map<out (CompositeKey..CompositeKey?), (Boolean..Boolean?)>): Unit defined in java.util.IdentityHashMap[JavaMethodDescriptor]

'visitedMap' @ [94:38] ==> value-parameter visitedMap: IdentityHashMap<CompositeKey, Boolean> defined in net.corda.core.crypto.composite.CompositeKey.cycleDetection[ValueParameterDescriptorImpl]

'require' @ [95:17] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'!' @ [95:25] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'curVisitedMap' @ [95:26] ==> val curVisitedMap: IdentityHashMap<CompositeKey, Boolean> defined in net.corda.core.crypto.composite.CompositeKey.cycleDetection[LocalVariableDescriptor]

'contains' @ [95:40] ==> @InlineOnly public operator inline fun <@OnlyInputTypes K, V> Map<out (CompositeKey..CompositeKey?), (Boolean..Boolean?)>.contains(key: (CompositeKey..CompositeKey?)): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <@OnlyInputTypes K> -> (net.corda.core.crypto.composite.CompositeKey..net.corda.core.crypto.composite.CompositeKey?)
    <V> -> (kotlin.Boolean..kotlin.Boolean?)

'node' @ [95:49] ==> val node: PublicKey defined in net.corda.core.crypto.composite.CompositeKey.cycleDetection[LocalVariableDescriptor]

'node' @ [95:93] ==> val node: PublicKey defined in net.corda.core.crypto.composite.CompositeKey.cycleDetection[LocalVariableDescriptor]

'curVisitedMap' @ [96:17] ==> val curVisitedMap: IdentityHashMap<CompositeKey, Boolean> defined in net.corda.core.crypto.composite.CompositeKey.cycleDetection[LocalVariableDescriptor]

'put' @ [96:31] ==> public open fun put(key: (CompositeKey..CompositeKey?), value: (Boolean..Boolean?)): Boolean? defined in java.util.IdentityHashMap[JavaMethodDescriptor]

'node' @ [96:35] ==> val node: PublicKey defined in net.corda.core.crypto.composite.CompositeKey.cycleDetection[LocalVariableDescriptor]

'node' @ [97:17] ==> val node: PublicKey defined in net.corda.core.crypto.composite.CompositeKey.cycleDetection[LocalVariableDescriptor]

'cycleDetection' @ [97:22] ==> private final fun cycleDetection(visitedMap: IdentityHashMap<CompositeKey, Boolean>): Unit defined in net.corda.core.crypto.composite.CompositeKey[SimpleFunctionDescriptorImpl]

'curVisitedMap' @ [97:37] ==> val curVisitedMap: IdentityHashMap<CompositeKey, Boolean> defined in net.corda.core.crypto.composite.CompositeKey.cycleDetection[LocalVariableDescriptor]

'IdentityHashMap' @ [111:26] ==> public constructor IdentityHashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.IdentityHashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> CompositeKey
    <V : (Any..Any?)> -> Boolean

'visitedMap' @ [112:9] ==> val visitedMap: IdentityHashMap<CompositeKey, Boolean> defined in net.corda.core.crypto.composite.CompositeKey.checkValidity[LocalVariableDescriptor]

'put' @ [112:20] ==> public open fun put(key: (CompositeKey..CompositeKey?), value: (Boolean..Boolean?)): Boolean? defined in java.util.IdentityHashMap[JavaMethodDescriptor]

'this' @ [112:24] ==> <this> defined in net.corda.core.crypto.composite.CompositeKey[LazyClassReceiverParameterDescriptor]

'cycleDetection' @ [113:9] ==> private final fun cycleDetection(visitedMap: IdentityHashMap<CompositeKey, Boolean>): Unit defined in net.corda.core.crypto.composite.CompositeKey[SimpleFunctionDescriptorImpl]

'visitedMap' @ [113:24] ==> val visitedMap: IdentityHashMap<CompositeKey, Boolean> defined in net.corda.core.crypto.composite.CompositeKey.checkValidity[LocalVariableDescriptor]

'checkConstraints' @ [114:9] ==> private final fun checkConstraints(): Unit defined in net.corda.core.crypto.composite.CompositeKey[SimpleFunctionDescriptorImpl]

'component1' @ [115:15] ==> public final operator fun component1(): PublicKey defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[SimpleFunctionDescriptorImpl]

'component2' @ [115:21] ==> public final operator fun component2(): Int defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[SimpleFunctionDescriptorImpl]

'children' @ [115:27] ==> public final val children: List<CompositeKey.NodeAndWeight> defined in net.corda.core.crypto.composite.CompositeKey[PropertyDescriptorImpl]

'node' @ [116:17] ==> val node: PublicKey defined in net.corda.core.crypto.composite.CompositeKey.checkValidity[LocalVariableDescriptor]

'node' @ [118:17] ==> val node: PublicKey defined in net.corda.core.crypto.composite.CompositeKey.checkValidity[LocalVariableDescriptor]

'checkConstraints' @ [118:22] ==> private final fun checkConstraints(): Unit defined in net.corda.core.crypto.composite.CompositeKey[SimpleFunctionDescriptorImpl]

'validated' @ [121:9] ==> @Transient private final var validated: Boolean defined in net.corda.core.crypto.composite.CompositeKey[PropertyDescriptorImpl]

'component1' @ [128:15] ==> public final operator fun component1(): PublicKey defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[SimpleFunctionDescriptorImpl]

'component2' @ [128:18] ==> public final operator fun component2(): Int defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[SimpleFunctionDescriptorImpl]

'children' @ [128:29] ==> public final val children: List<CompositeKey.NodeAndWeight> defined in net.corda.core.crypto.composite.CompositeKey[PropertyDescriptorImpl]

'require' @ [129:13] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'weight' @ [129:21] ==> val weight: Int defined in net.corda.core.crypto.composite.CompositeKey.totalWeight[LocalVariableDescriptor]

'weight' @ [129:58] ==> val weight: Int defined in net.corda.core.crypto.composite.CompositeKey.totalWeight[LocalVariableDescriptor]

'sum' @ [130:13] ==> var sum: Int defined in net.corda.core.crypto.composite.CompositeKey.totalWeight[LocalVariableDescriptor]

'sum' @ [130:19] ==> var sum: Int defined in net.corda.core.crypto.composite.CompositeKey.totalWeight[LocalVariableDescriptor]

'weight' @ [130:32] ==> val weight: Int defined in net.corda.core.crypto.composite.CompositeKey.totalWeight[LocalVariableDescriptor]

'sum' @ [132:16] ==> var sum: Int defined in net.corda.core.crypto.composite.CompositeKey.totalWeight[LocalVariableDescriptor]

'CordaSerializable' @ [139:5] ==> public constructor CordaSerializable() defined in net.corda.core.serialization.CordaSerializable[ClassConstructorDescriptorImpl]

'ASN1Object' @ [140:97] ==> public constructor ASN1Object() defined in org.bouncycastle.asn1.ASN1Object[JavaClassConstructorDescriptor]

'require' @ [143:13] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'weight' @ [143:21] ==> public final val weight: Int defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[PropertyDescriptorImpl]

'this' @ [143:84] ==> <this> defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[LazyClassReceiverParameterDescriptor]

'if (weight == other.weight)
                node.encoded.sequence().compareTo(other.node.encoded.sequence())
            else
                weight.compareTo(other.weight)' @ [147:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Int, elseBranch: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Int

'weight' @ [147:24] ==> public final val weight: Int defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[PropertyDescriptorImpl]

'other' @ [147:34] ==> value-parameter other: CompositeKey.NodeAndWeight defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight.compareTo[ValueParameterDescriptorImpl]

'weight' @ [147:40] ==> public final val weight: Int defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[PropertyDescriptorImpl]

'node' @ [148:17] ==> public final val node: PublicKey defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[PropertyDescriptorImpl]

'encoded' @ [148:22] ==> public final val PublicKey.encoded: (ByteArray..ByteArray?)[MyPropertyDescriptor]

'sequence' @ [148:30] ==> public fun ByteArray.sequence(offset: Int = ..., size: Int = ...): ByteSequence defined in net.corda.core.utilities in file ByteArrays.kt[SimpleFunctionDescriptorImpl]

'compareTo' @ [148:41] ==> public open fun compareTo(other: ByteSequence): Int defined in net.corda.core.utilities.ByteSequence[SimpleFunctionDescriptorImpl]

'other' @ [148:51] ==> value-parameter other: CompositeKey.NodeAndWeight defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight.compareTo[ValueParameterDescriptorImpl]

'node' @ [148:57] ==> public final val node: PublicKey defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[PropertyDescriptorImpl]

'encoded' @ [148:62] ==> public final val PublicKey.encoded: (ByteArray..ByteArray?)[MyPropertyDescriptor]

'sequence' @ [148:70] ==> public fun ByteArray.sequence(offset: Int = ..., size: Int = ...): ByteSequence defined in net.corda.core.utilities in file ByteArrays.kt[SimpleFunctionDescriptorImpl]

'weight' @ [150:17] ==> public final val weight: Int defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[PropertyDescriptorImpl]

'compareTo' @ [150:24] ==> public open fun compareTo(other: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'other' @ [150:34] ==> value-parameter other: CompositeKey.NodeAndWeight defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight.compareTo[ValueParameterDescriptorImpl]

'weight' @ [150:40] ==> public final val weight: Int defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[PropertyDescriptorImpl]

'ASN1EncodableVector' @ [154:26] ==> public constructor ASN1EncodableVector() defined in org.bouncycastle.asn1.ASN1EncodableVector[JavaClassConstructorDescriptor]

'vector' @ [155:13] ==> val vector: ASN1EncodableVector defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight.toASN1Primitive[LocalVariableDescriptor]

'add' @ [155:20] ==> public open fun add(p0: (ASN1Encodable..ASN1Encodable?)): Unit defined in org.bouncycastle.asn1.ASN1EncodableVector[JavaMethodDescriptor]

'DERBitString' @ [155:24] ==> public constructor DERBitString(p0: (ByteArray..ByteArray?)) defined in org.bouncycastle.asn1.DERBitString[JavaClassConstructorDescriptor]

'node' @ [155:37] ==> public final val node: PublicKey defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[PropertyDescriptorImpl]

'encoded' @ [155:42] ==> public final val PublicKey.encoded: (ByteArray..ByteArray?)[MyPropertyDescriptor]

'vector' @ [156:13] ==> val vector: ASN1EncodableVector defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight.toASN1Primitive[LocalVariableDescriptor]

'add' @ [156:20] ==> public open fun add(p0: (ASN1Encodable..ASN1Encodable?)): Unit defined in org.bouncycastle.asn1.ASN1EncodableVector[JavaMethodDescriptor]

'ASN1Integer' @ [156:24] ==> public constructor ASN1Integer(p0: Long) defined in org.bouncycastle.asn1.ASN1Integer[JavaClassConstructorDescriptor]

'weight' @ [156:36] ==> public final val weight: Int defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[PropertyDescriptorImpl]

'toLong' @ [156:43] ==> public open fun toLong(): Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'DERSequence' @ [157:20] ==> public constructor DERSequence(p0: (ASN1EncodableVector..ASN1EncodableVector?)) defined in org.bouncycastle.asn1.DERSequence[JavaClassConstructorDescriptor]

'vector' @ [157:32] ==> val vector: ASN1EncodableVector defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight.toASN1Primitive[LocalVariableDescriptor]

'node' @ [161:35] ==> public final val node: PublicKey defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[PropertyDescriptorImpl]

'toStringShort' @ [161:40] ==> public fun PublicKey.toStringShort(): String defined in net.corda.core.crypto in file CryptoUtils.kt[SimpleFunctionDescriptorImpl]

'weight' @ [161:67] ==> public final val weight: Int defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[PropertyDescriptorImpl]

'isFulfilledBy' @ [168:41] ==> public final fun isFulfilledBy(keysToCheck: Iterable<PublicKey>): Boolean defined in net.corda.core.crypto.composite.CompositeKey[SimpleFunctionDescriptorImpl]

'setOf' @ [168:55] ==> public fun <T> setOf(element: PublicKey): Set<PublicKey> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PublicKey

'key' @ [168:61] ==> value-parameter key: PublicKey defined in net.corda.core.crypto.composite.CompositeKey.isFulfilledBy[ValueParameterDescriptorImpl]

'KEY_ALGORITHM' @ [170:35] ==> public final val KEY_ALGORITHM: String defined in net.corda.core.crypto.composite.CompositeKey.Companion[PropertyDescriptorImpl]

'ASN1EncodableVector' @ [173:25] ==> public constructor ASN1EncodableVector() defined in org.bouncycastle.asn1.ASN1EncodableVector[JavaClassConstructorDescriptor]

'ASN1EncodableVector' @ [174:30] ==> public constructor ASN1EncodableVector() defined in org.bouncycastle.asn1.ASN1EncodableVector[JavaClassConstructorDescriptor]

'children' @ [175:9] ==> public final val children: List<CompositeKey.NodeAndWeight> defined in net.corda.core.crypto.composite.CompositeKey[PropertyDescriptorImpl]

'forEach' @ [175:18] ==> @HidesMembers public inline fun <T> Iterable<CompositeKey.NodeAndWeight>.forEach(action: (CompositeKey.NodeAndWeight) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> NodeAndWeight

'childrenVector' @ [176:13] ==> val childrenVector: ASN1EncodableVector defined in net.corda.core.crypto.composite.CompositeKey.getEncoded[LocalVariableDescriptor]

'add' @ [176:28] ==> public open fun add(p0: (ASN1Encodable..ASN1Encodable?)): Unit defined in org.bouncycastle.asn1.ASN1EncodableVector[JavaMethodDescriptor]

'it' @ [176:32] ==> value-parameter it: CompositeKey.NodeAndWeight defined in net.corda.core.crypto.composite.CompositeKey.getEncoded.<anonymous>[ValueParameterDescriptorImpl]

'toASN1Primitive' @ [176:35] ==> public open fun toASN1Primitive(): ASN1Primitive defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[SimpleFunctionDescriptorImpl]

'keyVector' @ [178:9] ==> val keyVector: ASN1EncodableVector defined in net.corda.core.crypto.composite.CompositeKey.getEncoded[LocalVariableDescriptor]

'add' @ [178:19] ==> public open fun add(p0: (ASN1Encodable..ASN1Encodable?)): Unit defined in org.bouncycastle.asn1.ASN1EncodableVector[JavaMethodDescriptor]

'ASN1Integer' @ [178:23] ==> public constructor ASN1Integer(p0: Long) defined in org.bouncycastle.asn1.ASN1Integer[JavaClassConstructorDescriptor]

'threshold' @ [178:35] ==> public final val threshold: Int defined in net.corda.core.crypto.composite.CompositeKey[PropertyDescriptorImpl]

'toLong' @ [178:45] ==> public open fun toLong(): Long defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'keyVector' @ [179:9] ==> val keyVector: ASN1EncodableVector defined in net.corda.core.crypto.composite.CompositeKey.getEncoded[LocalVariableDescriptor]

'add' @ [179:19] ==> public open fun add(p0: (ASN1Encodable..ASN1Encodable?)): Unit defined in org.bouncycastle.asn1.ASN1EncodableVector[JavaMethodDescriptor]

'DERSequence' @ [179:23] ==> public constructor DERSequence(p0: (ASN1EncodableVector..ASN1EncodableVector?)) defined in org.bouncycastle.asn1.DERSequence[JavaClassConstructorDescriptor]

'childrenVector' @ [179:35] ==> val childrenVector: ASN1EncodableVector defined in net.corda.core.crypto.composite.CompositeKey.getEncoded[LocalVariableDescriptor]

'SubjectPublicKeyInfo' @ [180:16] ==> public constructor SubjectPublicKeyInfo(p0: (AlgorithmIdentifier..AlgorithmIdentifier?), p1: (ASN1Encodable..ASN1Encodable?)) defined in org.bouncycastle.asn1.x509.SubjectPublicKeyInfo[JavaClassConstructorDescriptor]

'AlgorithmIdentifier' @ [180:37] ==> public constructor AlgorithmIdentifier(p0: (ASN1ObjectIdentifier..ASN1ObjectIdentifier?)) defined in org.bouncycastle.asn1.x509.AlgorithmIdentifier[JavaClassConstructorDescriptor]

'COMPOSITE_KEY' @ [180:79] ==> @JvmField public final val COMPOSITE_KEY: ASN1ObjectIdentifier defined in net.corda.core.crypto.provider.CordaObjectIdentifier[PropertyDescriptorImpl]

'DERSequence' @ [180:95] ==> public constructor DERSequence(p0: (ASN1EncodableVector..ASN1EncodableVector?)) defined in org.bouncycastle.asn1.DERSequence[JavaClassConstructorDescriptor]

'keyVector' @ [180:107] ==> val keyVector: ASN1EncodableVector defined in net.corda.core.crypto.composite.CompositeKey.getEncoded[LocalVariableDescriptor]

'encoded' @ [180:119] ==> public final val SubjectPublicKeyInfo.encoded: (ByteArray..ByteArray?)[MyPropertyDescriptor]

'DER' @ [183:45] ==> public const final val DER: String defined in org.bouncycastle.asn1.ASN1Encoding[JavaPropertyDescriptor]

'keysToCheck' @ [187:13] ==> value-parameter keysToCheck: Iterable<PublicKey> defined in net.corda.core.crypto.composite.CompositeKey.checkFulfilledBy[ValueParameterDescriptorImpl]

'any' @ [187:25] ==> public inline fun <T> Iterable<PublicKey>.any(predicate: (PublicKey) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PublicKey

'it' @ [187:31] ==> value-parameter it: PublicKey defined in net.corda.core.crypto.composite.CompositeKey.checkFulfilledBy.<anonymous>[ValueParameterDescriptorImpl]

'children' @ [188:27] ==> public final val children: List<CompositeKey.NodeAndWeight> defined in net.corda.core.crypto.composite.CompositeKey[PropertyDescriptorImpl]

'map' @ [188:36] ==> public inline fun <T, R> Iterable<CompositeKey.NodeAndWeight>.map(transform: (CompositeKey.NodeAndWeight) -> Int): List<Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> NodeAndWeight
    <R> -> Int

'component1' @ [188:43] ==> public final operator fun component1(): PublicKey defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[SimpleFunctionDescriptorImpl]

'component2' @ [188:49] ==> public final operator fun component2(): Int defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[SimpleFunctionDescriptorImpl]

'if (node is CompositeKey) {
                if (node.checkFulfilledBy(keysToCheck)) weight else 0
            } else {
                if (keysToCheck.contains(node)) weight else 0
            }' @ [189:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Int, elseBranch: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Int

'node' @ [189:17] ==> val node: PublicKey defined in net.corda.core.crypto.composite.CompositeKey.checkFulfilledBy.<anonymous>[LocalVariableDescriptor]

'if (node.checkFulfilledBy(keysToCheck)) weight else 0' @ [190:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Int, elseBranch: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Int

'node' @ [190:21] ==> val node: PublicKey defined in net.corda.core.crypto.composite.CompositeKey.checkFulfilledBy.<anonymous>[LocalVariableDescriptor]

'checkFulfilledBy' @ [190:26] ==> private final fun checkFulfilledBy(keysToCheck: Iterable<PublicKey>): Boolean defined in net.corda.core.crypto.composite.CompositeKey[SimpleFunctionDescriptorImpl]

'keysToCheck' @ [190:43] ==> value-parameter keysToCheck: Iterable<PublicKey> defined in net.corda.core.crypto.composite.CompositeKey.checkFulfilledBy[ValueParameterDescriptorImpl]

'weight' @ [190:57] ==> val weight: Int defined in net.corda.core.crypto.composite.CompositeKey.checkFulfilledBy.<anonymous>[LocalVariableDescriptor]

'if (keysToCheck.contains(node)) weight else 0' @ [192:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Int, elseBranch: Int): Int[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Int

'keysToCheck' @ [192:21] ==> value-parameter keysToCheck: Iterable<PublicKey> defined in net.corda.core.crypto.composite.CompositeKey.checkFulfilledBy[ValueParameterDescriptorImpl]

'contains' @ [192:33] ==> public operator fun <@OnlyInputTypes T> Iterable<PublicKey>.contains(element: PublicKey): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <@OnlyInputTypes T> -> PublicKey

'node' @ [192:42] ==> val node: PublicKey defined in net.corda.core.crypto.composite.CompositeKey.checkFulfilledBy.<anonymous>[LocalVariableDescriptor]

'weight' @ [192:49] ==> val weight: Int defined in net.corda.core.crypto.composite.CompositeKey.checkFulfilledBy.<anonymous>[LocalVariableDescriptor]

'sum' @ [194:11] ==> @JvmName public fun Iterable<Int>.sum(): Int defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]

'totalWeight' @ [195:16] ==> val totalWeight: Int defined in net.corda.core.crypto.composite.CompositeKey.checkFulfilledBy[LocalVariableDescriptor]

'threshold' @ [195:31] ==> public final val threshold: Int defined in net.corda.core.crypto.composite.CompositeKey[PropertyDescriptorImpl]

'!' @ [206:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'validated' @ [206:14] ==> @Transient private final var validated: Boolean defined in net.corda.core.crypto.composite.CompositeKey[PropertyDescriptorImpl]

'checkValidity' @ [207:13] ==> public final fun checkValidity(): Unit defined in net.corda.core.crypto.composite.CompositeKey[SimpleFunctionDescriptorImpl]

'checkFulfilledBy' @ [208:16] ==> private final fun checkFulfilledBy(keysToCheck: Iterable<PublicKey>): Boolean defined in net.corda.core.crypto.composite.CompositeKey[SimpleFunctionDescriptorImpl]

'keysToCheck' @ [208:33] ==> value-parameter keysToCheck: Iterable<PublicKey> defined in net.corda.core.crypto.composite.CompositeKey.isFulfilledBy[ValueParameterDescriptorImpl]

'children' @ [215:17] ==> public final val children: List<CompositeKey.NodeAndWeight> defined in net.corda.core.crypto.composite.CompositeKey[PropertyDescriptorImpl]

'flatMap' @ [215:26] ==> public inline fun <T, R> Iterable<CompositeKey.NodeAndWeight>.flatMap(transform: (CompositeKey.NodeAndWeight) -> Iterable<PublicKey>): List<PublicKey> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> NodeAndWeight
    <R> -> PublicKey

'it' @ [215:36] ==> value-parameter it: CompositeKey.NodeAndWeight defined in net.corda.core.crypto.composite.CompositeKey.<get-leafKeys>.<anonymous>[ValueParameterDescriptorImpl]

'node' @ [215:39] ==> public final val node: PublicKey defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[PropertyDescriptorImpl]

'keys' @ [215:44] ==> public val PublicKey.keys: Set<PublicKey> defined in net.corda.core.crypto in file CryptoUtils.kt[PropertyDescriptorImpl]

'toSet' @ [215:51] ==> public fun <T> Iterable<PublicKey>.toSet(): Set<PublicKey> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PublicKey

'this' @ [218:13] ==> <this> defined in net.corda.core.crypto.composite.CompositeKey[LazyClassReceiverParameterDescriptor]

'other' @ [218:22] ==> value-parameter other: Any? defined in net.corda.core.crypto.composite.CompositeKey.equals[ValueParameterDescriptorImpl]

'other' @ [219:13] ==> value-parameter other: Any? defined in net.corda.core.crypto.composite.CompositeKey.equals[ValueParameterDescriptorImpl]

'threshold' @ [220:13] ==> public final val threshold: Int defined in net.corda.core.crypto.composite.CompositeKey[PropertyDescriptorImpl]

'other' @ [220:26] ==> value-parameter other: Any? defined in net.corda.core.crypto.composite.CompositeKey.equals[ValueParameterDescriptorImpl]

'threshold' @ [220:32] ==> public final val threshold: Int defined in net.corda.core.crypto.composite.CompositeKey[PropertyDescriptorImpl]

'children' @ [221:13] ==> public final val children: List<CompositeKey.NodeAndWeight> defined in net.corda.core.crypto.composite.CompositeKey[PropertyDescriptorImpl]

'other' @ [221:25] ==> value-parameter other: Any? defined in net.corda.core.crypto.composite.CompositeKey.equals[ValueParameterDescriptorImpl]

'children' @ [221:31] ==> public final val children: List<CompositeKey.NodeAndWeight> defined in net.corda.core.crypto.composite.CompositeKey[PropertyDescriptorImpl]

'threshold' @ [227:22] ==> public final val threshold: Int defined in net.corda.core.crypto.composite.CompositeKey[PropertyDescriptorImpl]

'result' @ [228:9] ==> var result: Int defined in net.corda.core.crypto.composite.CompositeKey.hashCode[LocalVariableDescriptor]

'*' @ [228:18] ==> public final operator fun times(other: Int): Int defined in kotlin.Int[DeserializedSimpleFunctionDescriptor]

'result' @ [228:23] ==> var result: Int defined in net.corda.core.crypto.composite.CompositeKey.hashCode[LocalVariableDescriptor]

'children' @ [228:32] ==> public final val children: List<CompositeKey.NodeAndWeight> defined in net.corda.core.crypto.composite.CompositeKey[PropertyDescriptorImpl]

'hashCode' @ [228:41] ==> public open fun hashCode(): Int defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'result' @ [229:16] ==> var result: Int defined in net.corda.core.crypto.composite.CompositeKey.hashCode[LocalVariableDescriptor]

'children' @ [232:35] ==> public final val children: List<CompositeKey.NodeAndWeight> defined in net.corda.core.crypto.composite.CompositeKey[PropertyDescriptorImpl]

'joinToString' @ [232:44] ==> public fun <T> Iterable<CompositeKey.NodeAndWeight>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((CompositeKey.NodeAndWeight) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> NodeAndWeight

'mutableListOf' @ [236:60] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableListOf(): MutableList<CompositeKey.NodeAndWeight> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> NodeAndWeight

'children' @ [240:13] ==> private final val children: MutableList<CompositeKey.NodeAndWeight> defined in net.corda.core.crypto.composite.CompositeKey.Builder[PropertyDescriptorImpl]

'add' @ [240:22] ==> public abstract fun add(element: CompositeKey.NodeAndWeight): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'NodeAndWeight' @ [240:26] ==> public constructor NodeAndWeight(node: PublicKey, weight: Int) defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[ClassConstructorDescriptorImpl]

'key' @ [240:40] ==> value-parameter key: PublicKey defined in net.corda.core.crypto.composite.CompositeKey.Builder.addKey[ValueParameterDescriptorImpl]

'weight' @ [240:45] ==> value-parameter weight: Int = ... defined in net.corda.core.crypto.composite.CompositeKey.Builder.addKey[ValueParameterDescriptorImpl]

'this' @ [241:20] ==> <this> defined in net.corda.core.crypto.composite.CompositeKey.Builder[LazyClassReceiverParameterDescriptor]

'keys' @ [245:13] ==> value-parameter vararg keys: PublicKey defined in net.corda.core.crypto.composite.CompositeKey.Builder.addKeys[ValueParameterDescriptorImpl]

'forEach' @ [245:18] ==> public inline fun <T> Array<out PublicKey>.forEach(action: (PublicKey) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PublicKey

'addKey' @ [245:28] ==> public final fun addKey(key: PublicKey, weight: Int = ...): CompositeKey.Builder defined in net.corda.core.crypto.composite.CompositeKey.Builder[SimpleFunctionDescriptorImpl]

'it' @ [245:35] ==> value-parameter it: PublicKey defined in net.corda.core.crypto.composite.CompositeKey.Builder.addKeys.<anonymous>[ValueParameterDescriptorImpl]

'this' @ [246:20] ==> <this> defined in net.corda.core.crypto.composite.CompositeKey.Builder[LazyClassReceiverParameterDescriptor]

'addKeys' @ [249:55] ==> public final fun addKeys(vararg keys: PublicKey): CompositeKey.Builder defined in net.corda.core.crypto.composite.CompositeKey.Builder[SimpleFunctionDescriptorImpl]

'keys' @ [249:64] ==> value-parameter keys: List<PublicKey> defined in net.corda.core.crypto.composite.CompositeKey.Builder.addKeys[ValueParameterDescriptorImpl]

'toTypedArray' @ [249:69] ==> public inline fun <reified T> Collection<PublicKey>.toTypedArray(): Array<PublicKey> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T> -> PublicKey

'children' @ [259:21] ==> private final val children: MutableList<CompositeKey.NodeAndWeight> defined in net.corda.core.crypto.composite.CompositeKey.Builder[PropertyDescriptorImpl]

'size' @ [259:30] ==> public abstract val size: Int defined in kotlin.collections.MutableList[DeserializedPropertyDescriptor]

'if (n > 1)
                CompositeKey(threshold ?: children.map { (_, weight) -> weight }.sum(), children)
            else if (n == 1) {
                require(threshold == null || threshold == children.first().weight)
                { "Trying to build invalid CompositeKey, threshold value different than weight of single child node." }
                // Returning the only child node which is [PublicKey] itself. We need to avoid single-key [CompositeKey] instances,
                // as there are scenarios where developers expected the underlying key and its composite versions to be equivalent.
                children.first().node
            } else throw IllegalArgumentException("Trying to build CompositeKey without child nodes.")' @ [260:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: PublicKey, elseBranch: PublicKey): PublicKey[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> PublicKey

'n' @ [260:24] ==> val n: Int defined in net.corda.core.crypto.composite.CompositeKey.Builder.build[LocalVariableDescriptor]

'CompositeKey' @ [261:17] ==> private constructor CompositeKey(threshold: Int, children: List<CompositeKey.NodeAndWeight>) defined in net.corda.core.crypto.composite.CompositeKey[ClassConstructorDescriptorImpl]

'threshold' @ [261:30] ==> value-parameter threshold: Int? = ... defined in net.corda.core.crypto.composite.CompositeKey.Builder.build[ValueParameterDescriptorImpl]

'children' @ [261:43] ==> private final val children: MutableList<CompositeKey.NodeAndWeight> defined in net.corda.core.crypto.composite.CompositeKey.Builder[PropertyDescriptorImpl]

'map' @ [261:52] ==> public inline fun <T, R> Iterable<CompositeKey.NodeAndWeight>.map(transform: (CompositeKey.NodeAndWeight) -> Int): List<Int> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> NodeAndWeight
    <R> -> Int

'component1' @ [261:59] ==> public final operator fun component1(): PublicKey defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[SimpleFunctionDescriptorImpl]

'component2' @ [261:62] ==> public final operator fun component2(): Int defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[SimpleFunctionDescriptorImpl]

'weight' @ [261:73] ==> val weight: Int defined in net.corda.core.crypto.composite.CompositeKey.Builder.build.<anonymous>[LocalVariableDescriptor]

'sum' @ [261:82] ==> @JvmName public fun Iterable<Int>.sum(): Int defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]

'children' @ [261:89] ==> private final val children: MutableList<CompositeKey.NodeAndWeight> defined in net.corda.core.crypto.composite.CompositeKey.Builder[PropertyDescriptorImpl]

'if (n == 1) {
                require(threshold == null || threshold == children.first().weight)
                { "Trying to build invalid CompositeKey, threshold value different than weight of single child node." }
                // Returning the only child node which is [PublicKey] itself. We need to avoid single-key [CompositeKey] instances,
                // as there are scenarios where developers expected the underlying key and its composite versions to be equivalent.
                children.first().node
            } else throw IllegalArgumentException("Trying to build CompositeKey without child nodes.")' @ [262:18] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: PublicKey, elseBranch: PublicKey): PublicKey[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> PublicKey

'n' @ [262:22] ==> val n: Int defined in net.corda.core.crypto.composite.CompositeKey.Builder.build[LocalVariableDescriptor]

'require' @ [263:17] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'threshold' @ [263:25] ==> value-parameter threshold: Int? = ... defined in net.corda.core.crypto.composite.CompositeKey.Builder.build[ValueParameterDescriptorImpl]

'threshold' @ [263:46] ==> value-parameter threshold: Int? = ... defined in net.corda.core.crypto.composite.CompositeKey.Builder.build[ValueParameterDescriptorImpl]

'children' @ [263:59] ==> private final val children: MutableList<CompositeKey.NodeAndWeight> defined in net.corda.core.crypto.composite.CompositeKey.Builder[PropertyDescriptorImpl]

'first' @ [263:68] ==> public fun <T> List<CompositeKey.NodeAndWeight>.first(): CompositeKey.NodeAndWeight defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> NodeAndWeight

'weight' @ [263:76] ==> public final val weight: Int defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[PropertyDescriptorImpl]

'children' @ [267:17] ==> private final val children: MutableList<CompositeKey.NodeAndWeight> defined in net.corda.core.crypto.composite.CompositeKey.Builder[PropertyDescriptorImpl]

'first' @ [267:26] ==> public fun <T> List<CompositeKey.NodeAndWeight>.first(): CompositeKey.NodeAndWeight defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> NodeAndWeight

'node' @ [267:34] ==> public final val node: PublicKey defined in net.corda.core.crypto.composite.CompositeKey.NodeAndWeight[PropertyDescriptorImpl]

'IllegalArgumentException' @ [268:26] ==> public final fun <init>(p0: (String..String?)): IllegalArgumentException /* = IllegalArgumentException */ defined in kotlin.IllegalArgumentException[TypeAliasConstructorDescriptorImpl]

'flatMap' @ [279:13] ==> public inline fun <T, R> Iterable<PublicKey>.flatMap(transform: (PublicKey) -> Iterable<PublicKey>): List<PublicKey> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PublicKey
    <R> -> PublicKey

'it' @ [279:23] ==> value-parameter it: PublicKey defined in net.corda.core.crypto.composite.<get-expandedCompositeKeys>.<anonymous>[ValueParameterDescriptorImpl]

'keys' @ [279:26] ==> public val PublicKey.keys: Set<PublicKey> defined in net.corda.core.crypto in file CryptoUtils.kt[PropertyDescriptorImpl]

'toSet' @ [279:33] ==> public fun <T> Iterable<PublicKey>.toSet(): Set<PublicKey> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PublicKey

