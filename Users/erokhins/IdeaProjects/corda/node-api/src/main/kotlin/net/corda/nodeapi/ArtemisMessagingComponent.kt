'SingletonSerializeAsToken' @ [20:44] ==> public constructor SingletonSerializeAsToken() defined in net.corda.core.serialization.SingletonSerializeAsToken[DeserializedClassConstructorDescriptor]

'setProperty' @ [23:20] ==> public open fun setProperty(p0: (String..String?), p1: (String..String?)): (String..String?) defined in java.lang.System[JavaMethodDescriptor]

'INTERNAL_PREFIX' @ [32:37] ==> public const final val INTERNAL_PREFIX: String defined in net.corda.nodeapi.ArtemisMessagingComponent.Companion[PropertyDescriptorImpl]

'INTERNAL_PREFIX' @ [33:40] ==> public const final val INTERNAL_PREFIX: String defined in net.corda.nodeapi.ArtemisMessagingComponent.Companion[PropertyDescriptorImpl]

'INTERNAL_PREFIX' @ [36:46] ==> public const final val INTERNAL_PREFIX: String defined in net.corda.nodeapi.ArtemisMessagingComponent.Companion[PropertyDescriptorImpl]

'INTERNAL_PREFIX' @ [37:42] ==> public const final val INTERNAL_PREFIX: String defined in net.corda.nodeapi.ArtemisMessagingComponent.Companion[PropertyDescriptorImpl]

'CordaSerializable' @ [48:5] ==> public constructor CordaSerializable() defined in net.corda.core.serialization.CordaSerializable[DeserializedClassConstructorDescriptor]

'NETWORK_MAP_QUEUE' @ [50:48] ==> public const final val NETWORK_MAP_QUEUE: String defined in net.corda.nodeapi.ArtemisMessagingComponent.Companion[PropertyDescriptorImpl]

'CordaSerializable' @ [64:5] ==> public constructor CordaSerializable() defined in net.corda.core.serialization.CordaSerializable[DeserializedClassConstructorDescriptor]

'NodeAddress' @ [68:24] ==> public constructor NodeAddress(queueName: String, hostAndPort: NetworkHostAndPort) defined in net.corda.nodeapi.ArtemisMessagingComponent.NodeAddress[ClassConstructorDescriptorImpl]

'PEERS_PREFIX' @ [68:38] ==> public const final val PEERS_PREFIX: String defined in net.corda.nodeapi.ArtemisMessagingComponent.Companion[PropertyDescriptorImpl]

'peerIdentity' @ [68:52] ==> value-parameter peerIdentity: PublicKey defined in net.corda.nodeapi.ArtemisMessagingComponent.NodeAddress.Companion.asPeer[ValueParameterDescriptorImpl]

'toBase58String' @ [68:65] ==> public fun PublicKey.toBase58String(): String defined in net.corda.core.crypto[DeserializedSimpleFunctionDescriptor]

'hostAndPort' @ [68:85] ==> value-parameter hostAndPort: NetworkHostAndPort defined in net.corda.nodeapi.ArtemisMessagingComponent.NodeAddress.Companion.asPeer[ValueParameterDescriptorImpl]

'NodeAddress' @ [72:24] ==> public constructor NodeAddress(queueName: String, hostAndPort: NetworkHostAndPort) defined in net.corda.nodeapi.ArtemisMessagingComponent.NodeAddress[ClassConstructorDescriptorImpl]

'SERVICES_PREFIX' @ [72:38] ==> public const final val SERVICES_PREFIX: String defined in net.corda.nodeapi.ArtemisMessagingComponent.Companion[PropertyDescriptorImpl]

'serviceIdentity' @ [72:55] ==> value-parameter serviceIdentity: PublicKey defined in net.corda.nodeapi.ArtemisMessagingComponent.NodeAddress.Companion.asService[ValueParameterDescriptorImpl]

'toBase58String' @ [72:71] ==> public fun PublicKey.toBase58String(): String defined in net.corda.core.crypto[DeserializedSimpleFunctionDescriptor]

'hostAndPort' @ [72:91] ==> value-parameter hostAndPort: NetworkHostAndPort defined in net.corda.nodeapi.ArtemisMessagingComponent.NodeAddress.Companion.asService[ValueParameterDescriptorImpl]

'SERVICES_PREFIX' @ [87:44] ==> public const final val SERVICES_PREFIX: String defined in net.corda.nodeapi.ArtemisMessagingComponent.Companion[PropertyDescriptorImpl]

'identity' @ [87:61] ==> public final val identity: PublicKey defined in net.corda.nodeapi.ArtemisMessagingComponent.ServiceAddress[PropertyDescriptorImpl]

'toBase58String' @ [87:70] ==> public fun PublicKey.toBase58String(): String defined in net.corda.core.crypto[DeserializedSimpleFunctionDescriptor]

'config' @ [98:22] ==> public abstract val config: SSLConfiguration? defined in net.corda.nodeapi.ArtemisMessagingComponent[PropertyDescriptorImpl]

'arrayOf' @ [99:9] ==> public inline fun <reified @PureReifiable T> arrayOf(vararg elements: Path): Array<Path> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified @PureReifiable T> -> Path

'config' @ [99:17] ==> val config: SSLConfiguration defined in net.corda.nodeapi.ArtemisMessagingComponent.checkStorePasswords[LocalVariableDescriptor]

'sslKeystore' @ [99:24] ==> public open val sslKeystore: Path defined in net.corda.nodeapi.config.SSLConfiguration[PropertyDescriptorImpl]

'config' @ [99:37] ==> val config: SSLConfiguration defined in net.corda.nodeapi.ArtemisMessagingComponent.checkStorePasswords[LocalVariableDescriptor]

'nodeKeystore' @ [99:44] ==> public open val nodeKeystore: Path defined in net.corda.nodeapi.config.SSLConfiguration[PropertyDescriptorImpl]

'forEach' @ [99:58] ==> public inline fun <T> Array<out Path>.forEach(action: (Path) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Path

'it' @ [100:13] ==> value-parameter it: Path defined in net.corda.nodeapi.ArtemisMessagingComponent.checkStorePasswords.<anonymous>[ValueParameterDescriptorImpl]

'read' @ [100:16] ==> public inline fun <R> Path.read(vararg options: OpenOption, block: (InputStream) -> Unit): Unit defined in net.corda.core.internal[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <R> -> Unit

'getInstance' @ [101:26] ==> public open fun getInstance(p0: (String..String?)): (KeyStore..KeyStore?) defined in java.security.KeyStore[JavaMethodDescriptor]

'load' @ [101:45] ==> public final fun load(p0: (InputStream..InputStream?), p1: (CharArray..CharArray?)): Unit defined in java.security.KeyStore[JavaMethodDescriptor]

'it' @ [101:50] ==> value-parameter it: InputStream defined in net.corda.nodeapi.ArtemisMessagingComponent.checkStorePasswords.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'config' @ [101:54] ==> val config: SSLConfiguration defined in net.corda.nodeapi.ArtemisMessagingComponent.checkStorePasswords[LocalVariableDescriptor]

'keyStorePassword' @ [101:61] ==> public abstract val keyStorePassword: String defined in net.corda.nodeapi.config.SSLConfiguration[PropertyDescriptorImpl]

'toCharArray' @ [101:78] ==> @InlineOnly public inline fun String.toCharArray(): CharArray defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'config' @ [104:9] ==> val config: SSLConfiguration defined in net.corda.nodeapi.ArtemisMessagingComponent.checkStorePasswords[LocalVariableDescriptor]

'trustStoreFile' @ [104:16] ==> public open val trustStoreFile: Path defined in net.corda.nodeapi.config.SSLConfiguration[PropertyDescriptorImpl]

'read' @ [104:31] ==> public inline fun <R> Path.read(vararg options: OpenOption, block: (InputStream) -> Unit): Unit defined in net.corda.core.internal[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <R> -> Unit

'getInstance' @ [105:22] ==> public open fun getInstance(p0: (String..String?)): (KeyStore..KeyStore?) defined in java.security.KeyStore[JavaMethodDescriptor]

'load' @ [105:41] ==> public final fun load(p0: (InputStream..InputStream?), p1: (CharArray..CharArray?)): Unit defined in java.security.KeyStore[JavaMethodDescriptor]

'it' @ [105:46] ==> value-parameter it: InputStream defined in net.corda.nodeapi.ArtemisMessagingComponent.checkStorePasswords.<anonymous>[ValueParameterDescriptorImpl]

'config' @ [105:50] ==> val config: SSLConfiguration defined in net.corda.nodeapi.ArtemisMessagingComponent.checkStorePasswords[LocalVariableDescriptor]

'trustStorePassword' @ [105:57] ==> public abstract val trustStorePassword: String defined in net.corda.nodeapi.config.SSLConfiguration[PropertyDescriptorImpl]

'toCharArray' @ [105:76] ==> @InlineOnly public inline fun String.toCharArray(): CharArray defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'if (nodeInfo.advertisedServices.any { it.info.type == ServiceType.networkMap }) {
            NetworkMapAddress(nodeInfo.addresses.first())
        } else {
            NodeAddress.asPeer(nodeInfo.legalIdentity.owningKey, nodeInfo.addresses.first())
        }' @ [110:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: ArtemisMessagingComponent.ArtemisPeerAddress, elseBranch: ArtemisMessagingComponent.ArtemisPeerAddress): ArtemisMessagingComponent.ArtemisPeerAddress[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> ArtemisPeerAddress

'nodeInfo' @ [110:20] ==> value-parameter nodeInfo: NodeInfo defined in net.corda.nodeapi.ArtemisMessagingComponent.getArtemisPeerAddress[ValueParameterDescriptorImpl]

'advertisedServices' @ [110:29] ==> public final val advertisedServices: List<ServiceEntry> defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'any' @ [110:48] ==> public inline fun <T> Iterable<ServiceEntry>.any(predicate: (ServiceEntry) -> Boolean): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ServiceEntry

'it' @ [110:54] ==> value-parameter it: ServiceEntry defined in net.corda.nodeapi.ArtemisMessagingComponent.getArtemisPeerAddress.<anonymous>[ValueParameterDescriptorImpl]

'info' @ [110:57] ==> public final val info: ServiceInfo defined in net.corda.core.node.ServiceEntry[DeserializedPropertyDescriptor]

'type' @ [110:62] ==> public final val type: ServiceType defined in net.corda.core.node.services.ServiceInfo[DeserializedPropertyDescriptor]

'ServiceType' @ [110:70] ==> public companion object defined in net.corda.core.node.services.ServiceType[FakeCallableDescriptorForObject]

'networkMap' @ [110:82] ==> public final val networkMap: ServiceType defined in net.corda.core.node.services.ServiceType.Companion[DeserializedPropertyDescriptor]

'NetworkMapAddress' @ [111:13] ==> public constructor NetworkMapAddress(hostAndPort: NetworkHostAndPort) defined in net.corda.nodeapi.ArtemisMessagingComponent.NetworkMapAddress[ClassConstructorDescriptorImpl]

'nodeInfo' @ [111:31] ==> value-parameter nodeInfo: NodeInfo defined in net.corda.nodeapi.ArtemisMessagingComponent.getArtemisPeerAddress[ValueParameterDescriptorImpl]

'addresses' @ [111:40] ==> public final val addresses: List<NetworkHostAndPort> defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'first' @ [111:50] ==> public fun <T> List<NetworkHostAndPort>.first(): NetworkHostAndPort defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> NetworkHostAndPort

'NodeAddress' @ [113:13] ==> public companion object defined in net.corda.nodeapi.ArtemisMessagingComponent.NodeAddress[FakeCallableDescriptorForObject]

'asPeer' @ [113:25] ==> public final fun asPeer(peerIdentity: PublicKey, hostAndPort: NetworkHostAndPort): ArtemisMessagingComponent.NodeAddress defined in net.corda.nodeapi.ArtemisMessagingComponent.NodeAddress.Companion[SimpleFunctionDescriptorImpl]

'nodeInfo' @ [113:32] ==> value-parameter nodeInfo: NodeInfo defined in net.corda.nodeapi.ArtemisMessagingComponent.getArtemisPeerAddress[ValueParameterDescriptorImpl]

'legalIdentity' @ [113:41] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'owningKey' @ [113:55] ==> public final val owningKey: PublicKey defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'nodeInfo' @ [113:66] ==> value-parameter nodeInfo: NodeInfo defined in net.corda.nodeapi.ArtemisMessagingComponent.getArtemisPeerAddress[ValueParameterDescriptorImpl]

'addresses' @ [113:75] ==> public final val addresses: List<NetworkHostAndPort> defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'first' @ [113:85] ==> public fun <T> List<NetworkHostAndPort>.first(): NetworkHostAndPort defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> NetworkHostAndPort

