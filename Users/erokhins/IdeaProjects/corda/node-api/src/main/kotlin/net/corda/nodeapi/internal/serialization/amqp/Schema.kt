'OpaqueBytes' @ [25:35] ==> public constructor OpaqueBytes(bytes: ByteArray) defined in net.corda.core.utilities.OpaqueBytes[DeserializedClassConstructorDescriptor]

'toByteArray' @ [25:73] ==> @InlineOnly public inline fun String.toByteArray(charset: Charset = ...): ByteArray defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'UnsignedLong' @ [35:26] ==> public constructor UnsignedLong(p0: Long) defined in org.apache.qpid.proton.amqp.UnsignedLong[JavaClassConstructorDescriptor]

'or' @ [35:39] ==> public final infix fun or(other: Long): Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor]

'DESCRIPTOR_TOP_32BITS' @ [35:45] ==> public val DESCRIPTOR_TOP_32BITS: Long defined in net.corda.nodeapi.internal.serialization.amqp in file Schema.kt[PropertyDescriptorImpl]

'Descriptor' @ [36:33] ==> public constructor Descriptor(name: String?, code: UnsignedLong? = ...) defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor[ClassConstructorDescriptorImpl]

'DESCRIPTOR' @ [36:50] ==> public final val DESCRIPTOR: UnsignedLong defined in net.corda.nodeapi.internal.serialization.amqp.Envelope.Companion[PropertyDescriptorImpl]

'data' @ [39:33] ==> value-parameter data: Data defined in net.corda.nodeapi.internal.serialization.amqp.Envelope.Companion.get[ValueParameterDescriptorImpl]

'`object`' @ [39:38] ==> public final val Data.`object`: (Any..Any?)[MyPropertyDescriptor]

'describedType' @ [40:17] ==> val describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.Envelope.Companion.get[LocalVariableDescriptor]

'descriptor' @ [40:31] ==> public final val DescribedType.descriptor: (Any..Any?)[MyPropertyDescriptor]

'DESCRIPTOR' @ [40:45] ==> public final val DESCRIPTOR: UnsignedLong defined in net.corda.nodeapi.internal.serialization.amqp.Envelope.Companion[PropertyDescriptorImpl]

'NotSerializableException' @ [41:23] ==> public constructor NotSerializableException(p0: (String..String?)) defined in java.io.NotSerializableException[JavaClassConstructorDescriptor]

'describedType' @ [41:73] ==> val describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.Envelope.Companion.get[LocalVariableDescriptor]

'descriptor' @ [41:87] ==> public final val DescribedType.descriptor: (Any..Any?)[MyPropertyDescriptor]

'describedType' @ [43:24] ==> val describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.Envelope.Companion.get[LocalVariableDescriptor]

'described' @ [43:38] ==> public final val DescribedType.described: (Any..Any?)[MyPropertyDescriptor]

'newInstance' @ [44:20] ==> public open fun newInstance(described: Any?): Envelope defined in net.corda.nodeapi.internal.serialization.amqp.Envelope.Companion[SimpleFunctionDescriptorImpl]

'listOf' @ [44:32] ==> public fun <T> listOf(vararg elements: Any?): List<Any?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Any?

'list' @ [44:39] ==> val list: List<*> defined in net.corda.nodeapi.internal.serialization.amqp.Envelope.Companion.get[LocalVariableDescriptor]

'Schema' @ [44:48] ==> public companion object : DescribedTypeConstructor<Schema> defined in net.corda.nodeapi.internal.serialization.amqp.Schema[FakeCallableDescriptorForObject]

'get' @ [44:55] ==> public final fun get(obj: Any): Schema defined in net.corda.nodeapi.internal.serialization.amqp.Schema.Companion[SimpleFunctionDescriptorImpl]

'list' @ [44:59] ==> val list: List<*> defined in net.corda.nodeapi.internal.serialization.amqp.Envelope.Companion.get[LocalVariableDescriptor]

'Envelope' @ [47:49] ==> public companion object : DescribedTypeConstructor<Envelope> defined in net.corda.nodeapi.internal.serialization.amqp.Envelope[FakeCallableDescriptorForObject]

'java' @ [47:65] ==> public val <T> KClass<Envelope>.java: Class<Envelope> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> Envelope

'described' @ [50:24] ==> value-parameter described: Any? defined in net.corda.nodeapi.internal.serialization.amqp.Envelope.Companion.newInstance[ValueParameterDescriptorImpl]

'IllegalStateException' @ [50:55] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'Envelope' @ [51:20] ==> public constructor Envelope(obj: Any?, schema: Schema) defined in net.corda.nodeapi.internal.serialization.amqp.Envelope[ClassConstructorDescriptorImpl]

'list' @ [51:29] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.Envelope.Companion.newInstance[LocalVariableDescriptor]

'list' @ [51:38] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.Envelope.Companion.newInstance[LocalVariableDescriptor]

'DESCRIPTOR' @ [55:41] ==> public final val DESCRIPTOR: UnsignedLong defined in net.corda.nodeapi.internal.serialization.amqp.Envelope.Companion[PropertyDescriptorImpl]

'listOf' @ [57:40] ==> public fun <T> listOf(vararg elements: Any?): List<Any?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Any?

'obj' @ [57:47] ==> public final val obj: Any? defined in net.corda.nodeapi.internal.serialization.amqp.Envelope[PropertyDescriptorImpl]

'schema' @ [57:52] ==> public final val schema: Schema defined in net.corda.nodeapi.internal.serialization.amqp.Envelope[PropertyDescriptorImpl]

'UnsignedLong' @ [66:26] ==> public constructor UnsignedLong(p0: Long) defined in org.apache.qpid.proton.amqp.UnsignedLong[JavaClassConstructorDescriptor]

'or' @ [66:39] ==> public final infix fun or(other: Long): Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor]

'DESCRIPTOR_TOP_32BITS' @ [66:45] ==> public val DESCRIPTOR_TOP_32BITS: Long defined in net.corda.nodeapi.internal.serialization.amqp in file Schema.kt[PropertyDescriptorImpl]

'obj' @ [69:33] ==> value-parameter obj: Any defined in net.corda.nodeapi.internal.serialization.amqp.Schema.Companion.get[ValueParameterDescriptorImpl]

'describedType' @ [70:17] ==> val describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.Schema.Companion.get[LocalVariableDescriptor]

'descriptor' @ [70:31] ==> public final val DescribedType.descriptor: (Any..Any?)[MyPropertyDescriptor]

'DESCRIPTOR' @ [70:45] ==> public final val DESCRIPTOR: UnsignedLong defined in net.corda.nodeapi.internal.serialization.amqp.Schema.Companion[PropertyDescriptorImpl]

'NotSerializableException' @ [71:23] ==> public constructor NotSerializableException(p0: (String..String?)) defined in java.io.NotSerializableException[JavaClassConstructorDescriptor]

'describedType' @ [71:73] ==> val describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.Schema.Companion.get[LocalVariableDescriptor]

'descriptor' @ [71:87] ==> public final val DescribedType.descriptor: (Any..Any?)[MyPropertyDescriptor]

'describedType' @ [73:24] ==> val describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.Schema.Companion.get[LocalVariableDescriptor]

'described' @ [73:38] ==> public final val DescribedType.described: (Any..Any?)[MyPropertyDescriptor]

'newInstance' @ [74:20] ==> public open fun newInstance(described: Any?): Schema defined in net.corda.nodeapi.internal.serialization.amqp.Schema.Companion[SimpleFunctionDescriptorImpl]

'listOf' @ [74:32] ==> public fun <T> listOf(element: List<TypeNotation>): List<List<TypeNotation>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> List<TypeNotation>

'list' @ [74:40] ==> val list: List<*> defined in net.corda.nodeapi.internal.serialization.amqp.Schema.Companion.get[LocalVariableDescriptor]

'map' @ [74:60] ==> public inline fun <T, R> Iterable<Any?>.map(transform: (Any?) -> TypeNotation): List<TypeNotation> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Any?
    <R> -> TypeNotation

'TypeNotation' @ [74:66] ==> public companion object defined in net.corda.nodeapi.internal.serialization.amqp.TypeNotation[FakeCallableDescriptorForObject]

'get' @ [74:79] ==> public final fun get(obj: Any): TypeNotation defined in net.corda.nodeapi.internal.serialization.amqp.TypeNotation.Companion[SimpleFunctionDescriptorImpl]

'it' @ [74:83] ==> value-parameter it: Any? defined in net.corda.nodeapi.internal.serialization.amqp.Schema.Companion.get.<anonymous>[ValueParameterDescriptorImpl]

'Schema' @ [77:49] ==> public companion object : DescribedTypeConstructor<Schema> defined in net.corda.nodeapi.internal.serialization.amqp.Schema[FakeCallableDescriptorForObject]

'java' @ [77:63] ==> public val <T> KClass<Schema>.java: Class<Schema> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> Schema

'described' @ [80:24] ==> value-parameter described: Any? defined in net.corda.nodeapi.internal.serialization.amqp.Schema.Companion.newInstance[ValueParameterDescriptorImpl]

'IllegalStateException' @ [80:55] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'Suppress' @ [81:13] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'Schema' @ [82:20] ==> public constructor Schema(types: List<TypeNotation>) defined in net.corda.nodeapi.internal.serialization.amqp.Schema[ClassConstructorDescriptorImpl]

'list' @ [82:27] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.Schema.Companion.newInstance[LocalVariableDescriptor]

'DESCRIPTOR' @ [86:41] ==> public final val DESCRIPTOR: UnsignedLong defined in net.corda.nodeapi.internal.serialization.amqp.Schema.Companion[PropertyDescriptorImpl]

'listOf' @ [88:40] ==> public fun <T> listOf(element: List<TypeNotation>): List<List<TypeNotation>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> List<TypeNotation>

'types' @ [88:47] ==> public final val types: List<TypeNotation> defined in net.corda.nodeapi.internal.serialization.amqp.Schema[PropertyDescriptorImpl]

'types' @ [90:39] ==> public final val types: List<TypeNotation> defined in net.corda.nodeapi.internal.serialization.amqp.Schema[PropertyDescriptorImpl]

'joinToString' @ [90:45] ==> public fun <T> Iterable<TypeNotation>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((TypeNotation) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TypeNotation

'UnsignedLong' @ [95:26] ==> public constructor UnsignedLong(p0: Long) defined in org.apache.qpid.proton.amqp.UnsignedLong[JavaClassConstructorDescriptor]

'or' @ [95:39] ==> public final infix fun or(other: Long): Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor]

'DESCRIPTOR_TOP_32BITS' @ [95:45] ==> public val DESCRIPTOR_TOP_32BITS: Long defined in net.corda.nodeapi.internal.serialization.amqp in file Schema.kt[PropertyDescriptorImpl]

'obj' @ [98:33] ==> value-parameter obj: Any defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor.Companion.get[ValueParameterDescriptorImpl]

'describedType' @ [99:17] ==> val describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor.Companion.get[LocalVariableDescriptor]

'descriptor' @ [99:31] ==> public final val DescribedType.descriptor: (Any..Any?)[MyPropertyDescriptor]

'DESCRIPTOR' @ [99:45] ==> public final val DESCRIPTOR: UnsignedLong defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor.Companion[PropertyDescriptorImpl]

'NotSerializableException' @ [100:23] ==> public constructor NotSerializableException(p0: (String..String?)) defined in java.io.NotSerializableException[JavaClassConstructorDescriptor]

'describedType' @ [100:73] ==> val describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor.Companion.get[LocalVariableDescriptor]

'descriptor' @ [100:87] ==> public final val DescribedType.descriptor: (Any..Any?)[MyPropertyDescriptor]

'newInstance' @ [102:20] ==> public open fun newInstance(described: Any?): Descriptor defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor.Companion[SimpleFunctionDescriptorImpl]

'describedType' @ [102:32] ==> val describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor.Companion.get[LocalVariableDescriptor]

'described' @ [102:46] ==> public final val DescribedType.described: (Any..Any?)[MyPropertyDescriptor]

'Descriptor' @ [105:49] ==> public companion object : DescribedTypeConstructor<Descriptor> defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor[FakeCallableDescriptorForObject]

'java' @ [105:67] ==> public val <T> KClass<Descriptor>.java: Class<Descriptor> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> Descriptor

'described' @ [108:24] ==> value-parameter described: Any? defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor.Companion.newInstance[ValueParameterDescriptorImpl]

'IllegalStateException' @ [108:55] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'Descriptor' @ [109:20] ==> public constructor Descriptor(name: String?, code: UnsignedLong? = ...) defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor[ClassConstructorDescriptorImpl]

'list' @ [109:31] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor.Companion.newInstance[LocalVariableDescriptor]

'list' @ [109:51] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor.Companion.newInstance[LocalVariableDescriptor]

'DESCRIPTOR' @ [113:41] ==> public final val DESCRIPTOR: UnsignedLong defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor.Companion[PropertyDescriptorImpl]

'listOf' @ [115:40] ==> public fun <T> listOf(vararg elements: {java.io.Serializable & Comparable<{UnsignedLong & String}>}?): List<{java.io.Serializable & Comparable<{UnsignedLong & String}>}?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> {java.io.Serializable & Comparable<{UnsignedLong & String}>}?

'name' @ [115:47] ==> public final val name: String? defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor[PropertyDescriptorImpl]

'code' @ [115:53] ==> public final val code: UnsignedLong? defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor[PropertyDescriptorImpl]

'StringBuilder' @ [118:18] ==> public final fun <init>(p0: (String..String?)): StringBuilder /* = StringBuilder */ defined in kotlin.text.StringBuilder[TypeAliasConstructorDescriptorImpl]

'name' @ [119:13] ==> public final val name: String? defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor[PropertyDescriptorImpl]

'sb' @ [120:13] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor.toString[LocalVariableDescriptor]

'append' @ [120:16] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'name' @ [120:33] ==> public final val name: String? defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor[PropertyDescriptorImpl]

'code' @ [122:13] ==> public final val code: UnsignedLong? defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor[PropertyDescriptorImpl]

'String' @ [123:24] ==> public companion object defined in kotlin.String[FakeCallableDescriptorForObject]

'format' @ [123:31] ==> @InlineOnly public inline fun String.Companion.format(format: String, vararg args: Any?): String defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'code' @ [123:55] ==> public final val code: UnsignedLong? defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor[PropertyDescriptorImpl]

'toLong' @ [123:60] ==> public open fun toLong(): Long defined in org.apache.qpid.proton.amqp.UnsignedLong[JavaMethodDescriptor]

'shr' @ [123:69] ==> public final infix fun shr(bitCount: Int): Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor]

'code' @ [123:78] ==> public final val code: UnsignedLong? defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor[PropertyDescriptorImpl]

'toLong' @ [123:83] ==> public open fun toLong(): Long defined in org.apache.qpid.proton.amqp.UnsignedLong[JavaMethodDescriptor]

'and' @ [123:92] ==> public final infix fun and(other: Long): Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor]

'sb' @ [124:13] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor.toString[LocalVariableDescriptor]

'append' @ [124:16] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'code' @ [124:33] ==> val code: String defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor.toString[LocalVariableDescriptor]

'sb' @ [126:9] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor.toString[LocalVariableDescriptor]

'append' @ [126:12] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'sb' @ [127:16] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor.toString[LocalVariableDescriptor]

'toString' @ [127:19] ==> public open fun toString(): String defined in java.lang.StringBuilder[JavaMethodDescriptor]

'UnsignedLong' @ [133:26] ==> public constructor UnsignedLong(p0: Long) defined in org.apache.qpid.proton.amqp.UnsignedLong[JavaClassConstructorDescriptor]

'or' @ [133:39] ==> public final infix fun or(other: Long): Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor]

'DESCRIPTOR_TOP_32BITS' @ [133:45] ==> public val DESCRIPTOR_TOP_32BITS: Long defined in net.corda.nodeapi.internal.serialization.amqp in file Schema.kt[PropertyDescriptorImpl]

'obj' @ [136:33] ==> value-parameter obj: Any defined in net.corda.nodeapi.internal.serialization.amqp.Field.Companion.get[ValueParameterDescriptorImpl]

'describedType' @ [137:17] ==> val describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.Field.Companion.get[LocalVariableDescriptor]

'descriptor' @ [137:31] ==> public final val DescribedType.descriptor: (Any..Any?)[MyPropertyDescriptor]

'DESCRIPTOR' @ [137:45] ==> public final val DESCRIPTOR: UnsignedLong defined in net.corda.nodeapi.internal.serialization.amqp.Field.Companion[PropertyDescriptorImpl]

'NotSerializableException' @ [138:23] ==> public constructor NotSerializableException(p0: (String..String?)) defined in java.io.NotSerializableException[JavaClassConstructorDescriptor]

'describedType' @ [138:73] ==> val describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.Field.Companion.get[LocalVariableDescriptor]

'descriptor' @ [138:87] ==> public final val DescribedType.descriptor: (Any..Any?)[MyPropertyDescriptor]

'newInstance' @ [140:20] ==> public open fun newInstance(described: Any?): Field defined in net.corda.nodeapi.internal.serialization.amqp.Field.Companion[SimpleFunctionDescriptorImpl]

'describedType' @ [140:32] ==> val describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.Field.Companion.get[LocalVariableDescriptor]

'described' @ [140:46] ==> public final val DescribedType.described: (Any..Any?)[MyPropertyDescriptor]

'Field' @ [143:49] ==> public companion object : DescribedTypeConstructor<Field> defined in net.corda.nodeapi.internal.serialization.amqp.Field[FakeCallableDescriptorForObject]

'java' @ [143:62] ==> public val <T> KClass<Field>.java: Class<Field> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> Field

'described' @ [146:24] ==> value-parameter described: Any? defined in net.corda.nodeapi.internal.serialization.amqp.Field.Companion.newInstance[ValueParameterDescriptorImpl]

'IllegalStateException' @ [146:55] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'Suppress' @ [147:13] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'Field' @ [148:20] ==> public constructor Field(name: String, type: String, requires: List<String>, default: String?, label: String?, mandatory: Boolean, multiple: Boolean) defined in net.corda.nodeapi.internal.serialization.amqp.Field[ClassConstructorDescriptorImpl]

'list' @ [148:26] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.Field.Companion.newInstance[LocalVariableDescriptor]

'list' @ [148:45] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.Field.Companion.newInstance[LocalVariableDescriptor]

'list' @ [148:64] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.Field.Companion.newInstance[LocalVariableDescriptor]

'list' @ [148:89] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.Field.Companion.newInstance[LocalVariableDescriptor]

'list' @ [148:109] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.Field.Companion.newInstance[LocalVariableDescriptor]

'list' @ [148:129] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.Field.Companion.newInstance[LocalVariableDescriptor]

'list' @ [148:149] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.Field.Companion.newInstance[LocalVariableDescriptor]

'DESCRIPTOR' @ [152:41] ==> public final val DESCRIPTOR: UnsignedLong defined in net.corda.nodeapi.internal.serialization.amqp.Field.Companion[PropertyDescriptorImpl]

'listOf' @ [154:40] ==> public fun <T> listOf(vararg elements: Any?): List<Any?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Any?

'name' @ [154:47] ==> public final val name: String defined in net.corda.nodeapi.internal.serialization.amqp.Field[PropertyDescriptorImpl]

'type' @ [154:53] ==> public final val type: String defined in net.corda.nodeapi.internal.serialization.amqp.Field[PropertyDescriptorImpl]

'requires' @ [154:59] ==> public final val requires: List<String> defined in net.corda.nodeapi.internal.serialization.amqp.Field[PropertyDescriptorImpl]

'default' @ [154:69] ==> public final val default: String? defined in net.corda.nodeapi.internal.serialization.amqp.Field[PropertyDescriptorImpl]

'label' @ [154:78] ==> public final val label: String? defined in net.corda.nodeapi.internal.serialization.amqp.Field[PropertyDescriptorImpl]

'mandatory' @ [154:85] ==> public final val mandatory: Boolean defined in net.corda.nodeapi.internal.serialization.amqp.Field[PropertyDescriptorImpl]

'multiple' @ [154:96] ==> public final val multiple: Boolean defined in net.corda.nodeapi.internal.serialization.amqp.Field[PropertyDescriptorImpl]

'StringBuilder' @ [157:18] ==> public final fun <init>(p0: (String..String?)): StringBuilder /* = StringBuilder */ defined in kotlin.text.StringBuilder[TypeAliasConstructorDescriptorImpl]

'name' @ [157:48] ==> public final val name: String defined in net.corda.nodeapi.internal.serialization.amqp.Field[PropertyDescriptorImpl]

'type' @ [157:63] ==> public final val type: String defined in net.corda.nodeapi.internal.serialization.amqp.Field[PropertyDescriptorImpl]

'mandatory' @ [157:83] ==> public final val mandatory: Boolean defined in net.corda.nodeapi.internal.serialization.amqp.Field[PropertyDescriptorImpl]

'multiple' @ [157:107] ==> public final val multiple: Boolean defined in net.corda.nodeapi.internal.serialization.amqp.Field[PropertyDescriptorImpl]

'requires' @ [158:13] ==> public final val requires: List<String> defined in net.corda.nodeapi.internal.serialization.amqp.Field[PropertyDescriptorImpl]

'isNotEmpty' @ [158:22] ==> @InlineOnly public inline fun <T> Collection<String>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'sb' @ [159:13] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.Field.toString[LocalVariableDescriptor]

'append' @ [159:16] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'sb' @ [160:13] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.Field.toString[LocalVariableDescriptor]

'append' @ [160:16] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'requires' @ [160:23] ==> public final val requires: List<String> defined in net.corda.nodeapi.internal.serialization.amqp.Field[PropertyDescriptorImpl]

'joinToString' @ [160:32] ==> public fun <T> Iterable<String>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((String) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'sb' @ [161:13] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.Field.toString[LocalVariableDescriptor]

'append' @ [161:16] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'default' @ [163:13] ==> public final val default: String? defined in net.corda.nodeapi.internal.serialization.amqp.Field[PropertyDescriptorImpl]

'sb' @ [164:13] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.Field.toString[LocalVariableDescriptor]

'append' @ [164:16] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'default' @ [164:36] ==> public final val default: String? defined in net.corda.nodeapi.internal.serialization.amqp.Field[PropertyDescriptorImpl]

'!' @ [166:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'label' @ [166:14] ==> public final val label: String? defined in net.corda.nodeapi.internal.serialization.amqp.Field[PropertyDescriptorImpl]

'isNullOrBlank' @ [166:20] ==> @InlineOnly public inline fun CharSequence?.isNullOrBlank(): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'sb' @ [167:13] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.Field.toString[LocalVariableDescriptor]

'append' @ [167:16] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'label' @ [167:34] ==> public final val label: String? defined in net.corda.nodeapi.internal.serialization.amqp.Field[PropertyDescriptorImpl]

'sb' @ [169:9] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.Field.toString[LocalVariableDescriptor]

'append' @ [169:12] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'sb' @ [170:16] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.Field.toString[LocalVariableDescriptor]

'toString' @ [170:19] ==> public open fun toString(): String defined in java.lang.StringBuilder[JavaMethodDescriptor]

'obj' @ [177:33] ==> value-parameter obj: Any defined in net.corda.nodeapi.internal.serialization.amqp.TypeNotation.Companion.get[ValueParameterDescriptorImpl]

'if (describedType.descriptor == CompositeType.DESCRIPTOR) {
                return CompositeType.get(describedType)
            } else if (describedType.descriptor == RestrictedType.DESCRIPTOR) {
                return RestrictedType.get(describedType)
            } else {
                throw NotSerializableException("Unexpected descriptor ${describedType.descriptor}.")
            }' @ [178:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nothing, elseBranch: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nothing

'describedType' @ [178:17] ==> val describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.TypeNotation.Companion.get[LocalVariableDescriptor]

'descriptor' @ [178:31] ==> public final val DescribedType.descriptor: (Any..Any?)[MyPropertyDescriptor]

'CompositeType' @ [178:45] ==> public companion object : DescribedTypeConstructor<CompositeType> defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType[FakeCallableDescriptorForObject]

'DESCRIPTOR' @ [178:59] ==> public final val DESCRIPTOR: UnsignedLong defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.Companion[PropertyDescriptorImpl]

'CompositeType' @ [179:24] ==> public companion object : DescribedTypeConstructor<CompositeType> defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType[FakeCallableDescriptorForObject]

'get' @ [179:38] ==> public final fun get(describedType: DescribedType): CompositeType defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.Companion[SimpleFunctionDescriptorImpl]

'describedType' @ [179:42] ==> val describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.TypeNotation.Companion.get[LocalVariableDescriptor]

'if (describedType.descriptor == RestrictedType.DESCRIPTOR) {
                return RestrictedType.get(describedType)
            } else {
                throw NotSerializableException("Unexpected descriptor ${describedType.descriptor}.")
            }' @ [180:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nothing, elseBranch: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nothing

'describedType' @ [180:24] ==> val describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.TypeNotation.Companion.get[LocalVariableDescriptor]

'descriptor' @ [180:38] ==> public final val DescribedType.descriptor: (Any..Any?)[MyPropertyDescriptor]

'RestrictedType' @ [180:52] ==> public companion object : DescribedTypeConstructor<RestrictedType> defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType[FakeCallableDescriptorForObject]

'DESCRIPTOR' @ [180:67] ==> public final val DESCRIPTOR: UnsignedLong defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.Companion[PropertyDescriptorImpl]

'RestrictedType' @ [181:24] ==> public companion object : DescribedTypeConstructor<RestrictedType> defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType[FakeCallableDescriptorForObject]

'get' @ [181:39] ==> public final fun get(describedType: DescribedType): RestrictedType defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.Companion[SimpleFunctionDescriptorImpl]

'describedType' @ [181:43] ==> val describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.TypeNotation.Companion.get[LocalVariableDescriptor]

'NotSerializableException' @ [183:23] ==> public constructor NotSerializableException(p0: (String..String?)) defined in java.io.NotSerializableException[JavaClassConstructorDescriptor]

'describedType' @ [183:73] ==> val describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.TypeNotation.Companion.get[LocalVariableDescriptor]

'descriptor' @ [183:87] ==> public final val DescribedType.descriptor: (Any..Any?)[MyPropertyDescriptor]

'TypeNotation' @ [194:183] ==> private constructor TypeNotation() defined in net.corda.nodeapi.internal.serialization.amqp.TypeNotation[ClassConstructorDescriptorImpl]

'UnsignedLong' @ [196:26] ==> public constructor UnsignedLong(p0: Long) defined in org.apache.qpid.proton.amqp.UnsignedLong[JavaClassConstructorDescriptor]

'or' @ [196:39] ==> public final infix fun or(other: Long): Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor]

'DESCRIPTOR_TOP_32BITS' @ [196:45] ==> public val DESCRIPTOR_TOP_32BITS: Long defined in net.corda.nodeapi.internal.serialization.amqp in file Schema.kt[PropertyDescriptorImpl]

'describedType' @ [199:17] ==> value-parameter describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.Companion.get[ValueParameterDescriptorImpl]

'descriptor' @ [199:31] ==> public final val DescribedType.descriptor: (Any..Any?)[MyPropertyDescriptor]

'DESCRIPTOR' @ [199:45] ==> public final val DESCRIPTOR: UnsignedLong defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.Companion[PropertyDescriptorImpl]

'NotSerializableException' @ [200:23] ==> public constructor NotSerializableException(p0: (String..String?)) defined in java.io.NotSerializableException[JavaClassConstructorDescriptor]

'describedType' @ [200:73] ==> value-parameter describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.Companion.get[ValueParameterDescriptorImpl]

'descriptor' @ [200:87] ==> public final val DescribedType.descriptor: (Any..Any?)[MyPropertyDescriptor]

'describedType' @ [202:24] ==> value-parameter describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.Companion.get[ValueParameterDescriptorImpl]

'described' @ [202:38] ==> public final val DescribedType.described: (Any..Any?)[MyPropertyDescriptor]

'newInstance' @ [203:20] ==> public open fun newInstance(described: Any?): CompositeType defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.Companion[SimpleFunctionDescriptorImpl]

'listOf' @ [203:32] ==> public fun <T> listOf(vararg elements: Any?): List<Any?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Any?

'list' @ [203:39] ==> val list: List<*> defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.Companion.get[LocalVariableDescriptor]

'list' @ [203:48] ==> val list: List<*> defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.Companion.get[LocalVariableDescriptor]

'list' @ [203:57] ==> val list: List<*> defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.Companion.get[LocalVariableDescriptor]

'Descriptor' @ [203:66] ==> public companion object : DescribedTypeConstructor<Descriptor> defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor[FakeCallableDescriptorForObject]

'get' @ [203:77] ==> public final fun get(obj: Any): Descriptor defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor.Companion[SimpleFunctionDescriptorImpl]

'list' @ [203:81] ==> val list: List<*> defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.Companion.get[LocalVariableDescriptor]

'list' @ [203:94] ==> val list: List<*> defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.Companion.get[LocalVariableDescriptor]

'map' @ [203:114] ==> public inline fun <T, R> Iterable<Any?>.map(transform: (Any?) -> Field): List<Field> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Any?
    <R> -> Field

'Field' @ [203:120] ==> public companion object : DescribedTypeConstructor<Field> defined in net.corda.nodeapi.internal.serialization.amqp.Field[FakeCallableDescriptorForObject]

'get' @ [203:126] ==> public final fun get(obj: Any): Field defined in net.corda.nodeapi.internal.serialization.amqp.Field.Companion[SimpleFunctionDescriptorImpl]

'it' @ [203:130] ==> value-parameter it: Any? defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.Companion.get.<anonymous>[ValueParameterDescriptorImpl]

'CompositeType' @ [206:49] ==> public companion object : DescribedTypeConstructor<CompositeType> defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType[FakeCallableDescriptorForObject]

'java' @ [206:70] ==> public val <T> KClass<CompositeType>.java: Class<CompositeType> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> CompositeType

'described' @ [209:24] ==> value-parameter described: Any? defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.Companion.newInstance[ValueParameterDescriptorImpl]

'IllegalStateException' @ [209:55] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'Suppress' @ [210:13] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'CompositeType' @ [211:20] ==> public constructor CompositeType(name: String, label: String?, provides: List<String>, descriptor: Descriptor, fields: List<Field>) defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType[ClassConstructorDescriptorImpl]

'list' @ [211:34] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.Companion.newInstance[LocalVariableDescriptor]

'list' @ [211:53] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.Companion.newInstance[LocalVariableDescriptor]

'list' @ [211:73] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.Companion.newInstance[LocalVariableDescriptor]

'list' @ [211:98] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.Companion.newInstance[LocalVariableDescriptor]

'list' @ [211:121] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.Companion.newInstance[LocalVariableDescriptor]

'DESCRIPTOR' @ [215:41] ==> public final val DESCRIPTOR: UnsignedLong defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.Companion[PropertyDescriptorImpl]

'listOf' @ [217:40] ==> public fun <T> listOf(vararg elements: Any?): List<Any?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Any?

'name' @ [217:47] ==> public open val name: String defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType[PropertyDescriptorImpl]

'label' @ [217:53] ==> public open val label: String? defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType[PropertyDescriptorImpl]

'provides' @ [217:60] ==> public open val provides: List<String> defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType[PropertyDescriptorImpl]

'descriptor' @ [217:70] ==> public open val descriptor: Descriptor defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType[PropertyDescriptorImpl]

'fields' @ [217:82] ==> public final val fields: List<Field> defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType[PropertyDescriptorImpl]

'StringBuilder' @ [220:18] ==> public final fun <init>(p0: (String..String?)): StringBuilder /* = StringBuilder */ defined in kotlin.text.StringBuilder[TypeAliasConstructorDescriptorImpl]

'name' @ [220:67] ==> public open val name: String defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType[PropertyDescriptorImpl]

'!' @ [221:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'label' @ [221:14] ==> public open val label: String? defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType[PropertyDescriptorImpl]

'isNullOrBlank' @ [221:20] ==> @InlineOnly public inline fun CharSequence?.isNullOrBlank(): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'sb' @ [222:13] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.toString[LocalVariableDescriptor]

'append' @ [222:16] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'label' @ [222:34] ==> public open val label: String? defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType[PropertyDescriptorImpl]

'provides' @ [224:13] ==> public open val provides: List<String> defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType[PropertyDescriptorImpl]

'isNotEmpty' @ [224:22] ==> @InlineOnly public inline fun <T> Collection<String>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'sb' @ [225:13] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.toString[LocalVariableDescriptor]

'append' @ [225:16] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'sb' @ [226:13] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.toString[LocalVariableDescriptor]

'append' @ [226:16] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'provides' @ [226:23] ==> public open val provides: List<String> defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType[PropertyDescriptorImpl]

'joinToString' @ [226:32] ==> public fun <T> Iterable<String>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((String) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'sb' @ [227:13] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.toString[LocalVariableDescriptor]

'append' @ [227:16] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'sb' @ [229:9] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.toString[LocalVariableDescriptor]

'append' @ [229:12] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'sb' @ [230:9] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.toString[LocalVariableDescriptor]

'append' @ [230:12] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'descriptor' @ [230:23] ==> public open val descriptor: Descriptor defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType[PropertyDescriptorImpl]

'fields' @ [231:23] ==> public final val fields: List<Field> defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType[PropertyDescriptorImpl]

'sb' @ [232:13] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.toString[LocalVariableDescriptor]

'append' @ [232:16] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'field' @ [232:27] ==> val field: Field defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.toString[LocalVariableDescriptor]

'sb' @ [234:9] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.toString[LocalVariableDescriptor]

'append' @ [234:12] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'sb' @ [235:16] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.CompositeType.toString[LocalVariableDescriptor]

'toString' @ [235:19] ==> public open fun toString(): String defined in java.lang.StringBuilder[JavaMethodDescriptor]

'TypeNotation' @ [239:206] ==> private constructor TypeNotation() defined in net.corda.nodeapi.internal.serialization.amqp.TypeNotation[ClassConstructorDescriptorImpl]

'UnsignedLong' @ [241:26] ==> public constructor UnsignedLong(p0: Long) defined in org.apache.qpid.proton.amqp.UnsignedLong[JavaClassConstructorDescriptor]

'or' @ [241:39] ==> public final infix fun or(other: Long): Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor]

'DESCRIPTOR_TOP_32BITS' @ [241:45] ==> public val DESCRIPTOR_TOP_32BITS: Long defined in net.corda.nodeapi.internal.serialization.amqp in file Schema.kt[PropertyDescriptorImpl]

'describedType' @ [244:17] ==> value-parameter describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.Companion.get[ValueParameterDescriptorImpl]

'descriptor' @ [244:31] ==> public final val DescribedType.descriptor: (Any..Any?)[MyPropertyDescriptor]

'DESCRIPTOR' @ [244:45] ==> public final val DESCRIPTOR: UnsignedLong defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.Companion[PropertyDescriptorImpl]

'NotSerializableException' @ [245:23] ==> public constructor NotSerializableException(p0: (String..String?)) defined in java.io.NotSerializableException[JavaClassConstructorDescriptor]

'describedType' @ [245:73] ==> value-parameter describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.Companion.get[ValueParameterDescriptorImpl]

'descriptor' @ [245:87] ==> public final val DescribedType.descriptor: (Any..Any?)[MyPropertyDescriptor]

'describedType' @ [247:24] ==> value-parameter describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.Companion.get[ValueParameterDescriptorImpl]

'described' @ [247:38] ==> public final val DescribedType.described: (Any..Any?)[MyPropertyDescriptor]

'newInstance' @ [248:20] ==> public open fun newInstance(described: Any?): RestrictedType defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.Companion[SimpleFunctionDescriptorImpl]

'listOf' @ [248:32] ==> public fun <T> listOf(vararg elements: Any?): List<Any?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Any?

'list' @ [248:39] ==> val list: List<*> defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.Companion.get[LocalVariableDescriptor]

'list' @ [248:48] ==> val list: List<*> defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.Companion.get[LocalVariableDescriptor]

'list' @ [248:57] ==> val list: List<*> defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.Companion.get[LocalVariableDescriptor]

'list' @ [248:66] ==> val list: List<*> defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.Companion.get[LocalVariableDescriptor]

'Descriptor' @ [248:75] ==> public companion object : DescribedTypeConstructor<Descriptor> defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor[FakeCallableDescriptorForObject]

'get' @ [248:86] ==> public final fun get(obj: Any): Descriptor defined in net.corda.nodeapi.internal.serialization.amqp.Descriptor.Companion[SimpleFunctionDescriptorImpl]

'list' @ [248:90] ==> val list: List<*> defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.Companion.get[LocalVariableDescriptor]

'list' @ [248:103] ==> val list: List<*> defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.Companion.get[LocalVariableDescriptor]

'map' @ [248:123] ==> public inline fun <T, R> Iterable<Any?>.map(transform: (Any?) -> Choice): List<Choice> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Any?
    <R> -> Choice

'Choice' @ [248:129] ==> public companion object : DescribedTypeConstructor<Choice> defined in net.corda.nodeapi.internal.serialization.amqp.Choice[FakeCallableDescriptorForObject]

'get' @ [248:136] ==> public final fun get(obj: Any): Choice defined in net.corda.nodeapi.internal.serialization.amqp.Choice.Companion[SimpleFunctionDescriptorImpl]

'it' @ [248:140] ==> value-parameter it: Any? defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.Companion.get.<anonymous>[ValueParameterDescriptorImpl]

'RestrictedType' @ [251:49] ==> public companion object : DescribedTypeConstructor<RestrictedType> defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType[FakeCallableDescriptorForObject]

'java' @ [251:71] ==> public val <T> KClass<RestrictedType>.java: Class<RestrictedType> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> RestrictedType

'described' @ [254:24] ==> value-parameter described: Any? defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.Companion.newInstance[ValueParameterDescriptorImpl]

'IllegalStateException' @ [254:55] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'Suppress' @ [255:13] ==> public constructor Suppress(vararg names: String) defined in kotlin.Suppress[DeserializedClassConstructorDescriptor]

'RestrictedType' @ [256:20] ==> public constructor RestrictedType(name: String, label: String?, provides: List<String>, source: String, descriptor: Descriptor, choices: List<Choice>) defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType[ClassConstructorDescriptorImpl]

'list' @ [256:35] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.Companion.newInstance[LocalVariableDescriptor]

'list' @ [256:54] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.Companion.newInstance[LocalVariableDescriptor]

'list' @ [256:74] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.Companion.newInstance[LocalVariableDescriptor]

'list' @ [256:99] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.Companion.newInstance[LocalVariableDescriptor]

'list' @ [256:118] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.Companion.newInstance[LocalVariableDescriptor]

'list' @ [256:141] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.Companion.newInstance[LocalVariableDescriptor]

'DESCRIPTOR' @ [260:41] ==> public final val DESCRIPTOR: UnsignedLong defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.Companion[PropertyDescriptorImpl]

'listOf' @ [262:40] ==> public fun <T> listOf(vararg elements: Any?): List<Any?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Any?

'name' @ [262:47] ==> public open val name: String defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType[PropertyDescriptorImpl]

'label' @ [262:53] ==> public open val label: String? defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType[PropertyDescriptorImpl]

'provides' @ [262:60] ==> public open val provides: List<String> defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType[PropertyDescriptorImpl]

'source' @ [262:70] ==> public final val source: String defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType[PropertyDescriptorImpl]

'descriptor' @ [262:78] ==> public open val descriptor: Descriptor defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType[PropertyDescriptorImpl]

'choices' @ [262:90] ==> public final val choices: List<Choice> defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType[PropertyDescriptorImpl]

'StringBuilder' @ [265:18] ==> public final fun <init>(p0: (String..String?)): StringBuilder /* = StringBuilder */ defined in kotlin.text.StringBuilder[TypeAliasConstructorDescriptorImpl]

'name' @ [265:68] ==> public open val name: String defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType[PropertyDescriptorImpl]

'!' @ [266:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'label' @ [266:14] ==> public open val label: String? defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType[PropertyDescriptorImpl]

'isNullOrBlank' @ [266:20] ==> @InlineOnly public inline fun CharSequence?.isNullOrBlank(): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'sb' @ [267:13] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.toString[LocalVariableDescriptor]

'append' @ [267:16] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'label' @ [267:34] ==> public open val label: String? defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType[PropertyDescriptorImpl]

'sb' @ [269:9] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.toString[LocalVariableDescriptor]

'append' @ [269:12] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'source' @ [269:31] ==> public final val source: String defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType[PropertyDescriptorImpl]

'provides' @ [270:13] ==> public open val provides: List<String> defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType[PropertyDescriptorImpl]

'isNotEmpty' @ [270:22] ==> @InlineOnly public inline fun <T> Collection<String>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'sb' @ [271:13] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.toString[LocalVariableDescriptor]

'append' @ [271:16] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'sb' @ [272:13] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.toString[LocalVariableDescriptor]

'append' @ [272:16] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'provides' @ [272:23] ==> public open val provides: List<String> defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType[PropertyDescriptorImpl]

'joinToString' @ [272:32] ==> public fun <T> Iterable<String>.joinToString(separator: CharSequence = ..., prefix: CharSequence = ..., postfix: CharSequence = ..., limit: Int = ..., truncated: CharSequence = ..., transform: ((String) -> CharSequence)? = ...): String defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'sb' @ [273:13] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.toString[LocalVariableDescriptor]

'append' @ [273:16] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'sb' @ [275:9] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.toString[LocalVariableDescriptor]

'append' @ [275:12] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'sb' @ [276:9] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.toString[LocalVariableDescriptor]

'append' @ [276:12] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'descriptor' @ [276:23] ==> public open val descriptor: Descriptor defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType[PropertyDescriptorImpl]

'sb' @ [277:9] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.toString[LocalVariableDescriptor]

'append' @ [277:12] ==> public open fun append(p0: (String..String?)): (StringBuilder..StringBuilder?) defined in java.lang.StringBuilder[JavaMethodDescriptor]

'sb' @ [278:16] ==> val sb: StringBuilder /* = StringBuilder */ defined in net.corda.nodeapi.internal.serialization.amqp.RestrictedType.toString[LocalVariableDescriptor]

'toString' @ [278:19] ==> public open fun toString(): String defined in java.lang.StringBuilder[JavaMethodDescriptor]

'UnsignedLong' @ [284:26] ==> public constructor UnsignedLong(p0: Long) defined in org.apache.qpid.proton.amqp.UnsignedLong[JavaClassConstructorDescriptor]

'or' @ [284:39] ==> public final infix fun or(other: Long): Long defined in kotlin.Long[DeserializedSimpleFunctionDescriptor]

'DESCRIPTOR_TOP_32BITS' @ [284:45] ==> public val DESCRIPTOR_TOP_32BITS: Long defined in net.corda.nodeapi.internal.serialization.amqp in file Schema.kt[PropertyDescriptorImpl]

'obj' @ [287:33] ==> value-parameter obj: Any defined in net.corda.nodeapi.internal.serialization.amqp.Choice.Companion.get[ValueParameterDescriptorImpl]

'describedType' @ [288:17] ==> val describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.Choice.Companion.get[LocalVariableDescriptor]

'descriptor' @ [288:31] ==> public final val DescribedType.descriptor: (Any..Any?)[MyPropertyDescriptor]

'DESCRIPTOR' @ [288:45] ==> public final val DESCRIPTOR: UnsignedLong defined in net.corda.nodeapi.internal.serialization.amqp.Choice.Companion[PropertyDescriptorImpl]

'NotSerializableException' @ [289:23] ==> public constructor NotSerializableException(p0: (String..String?)) defined in java.io.NotSerializableException[JavaClassConstructorDescriptor]

'describedType' @ [289:73] ==> val describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.Choice.Companion.get[LocalVariableDescriptor]

'descriptor' @ [289:87] ==> public final val DescribedType.descriptor: (Any..Any?)[MyPropertyDescriptor]

'newInstance' @ [291:20] ==> public open fun newInstance(described: Any?): Choice defined in net.corda.nodeapi.internal.serialization.amqp.Choice.Companion[SimpleFunctionDescriptorImpl]

'describedType' @ [291:32] ==> val describedType: DescribedType defined in net.corda.nodeapi.internal.serialization.amqp.Choice.Companion.get[LocalVariableDescriptor]

'described' @ [291:46] ==> public final val DescribedType.described: (Any..Any?)[MyPropertyDescriptor]

'Choice' @ [294:49] ==> public companion object : DescribedTypeConstructor<Choice> defined in net.corda.nodeapi.internal.serialization.amqp.Choice[FakeCallableDescriptorForObject]

'java' @ [294:63] ==> public val <T> KClass<Choice>.java: Class<Choice> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> Choice

'described' @ [297:24] ==> value-parameter described: Any? defined in net.corda.nodeapi.internal.serialization.amqp.Choice.Companion.newInstance[ValueParameterDescriptorImpl]

'IllegalStateException' @ [297:55] ==> public final fun <init>(p0: (String..String?)): IllegalStateException /* = IllegalStateException */ defined in kotlin.IllegalStateException[TypeAliasConstructorDescriptorImpl]

'Choice' @ [298:20] ==> public constructor Choice(name: String, value: String) defined in net.corda.nodeapi.internal.serialization.amqp.Choice[ClassConstructorDescriptorImpl]

'list' @ [298:27] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.Choice.Companion.newInstance[LocalVariableDescriptor]

'list' @ [298:46] ==> val list: List<Any?> defined in net.corda.nodeapi.internal.serialization.amqp.Choice.Companion.newInstance[LocalVariableDescriptor]

'DESCRIPTOR' @ [302:41] ==> public final val DESCRIPTOR: UnsignedLong defined in net.corda.nodeapi.internal.serialization.amqp.Choice.Companion[PropertyDescriptorImpl]

'listOf' @ [304:40] ==> public fun <T> listOf(vararg elements: String): List<String> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'name' @ [304:47] ==> public final val name: String defined in net.corda.nodeapi.internal.serialization.amqp.Choice[PropertyDescriptorImpl]

'value' @ [304:53] ==> public final val value: String defined in net.corda.nodeapi.internal.serialization.amqp.Choice[PropertyDescriptorImpl]

'name' @ [307:33] ==> public final val name: String defined in net.corda.nodeapi.internal.serialization.amqp.Choice[PropertyDescriptorImpl]

'value' @ [307:49] ==> public final val value: String defined in net.corda.nodeapi.internal.serialization.amqp.Choice[PropertyDescriptorImpl]

'lazy' @ [319:23] ==> public fun <T> lazy(initializer: () -> Logger): Lazy<Logger> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Logger

'loggerFor' @ [319:30] ==> public inline fun <reified T : Any> loggerFor(): Logger defined in net.corda.core.utilities[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : Any> -> Schema

'fingerprintForType' @ [331:12] ==> private fun fingerprintForType(type: Type, contextType: Type?, alreadySeen: MutableSet<Type>, hasher: Hasher, factory: SerializerFactory): Hasher defined in net.corda.nodeapi.internal.serialization.amqp[SimpleFunctionDescriptorImpl]

'type' @ [331:31] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'HashSet' @ [331:43] ==> public constructor HashSet<E : (Any..Any?)>() defined in java.util.HashSet[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> Type

'murmur3_128' @ [331:62] ==> public open fun murmur3_128(): (HashFunction..HashFunction?) defined in com.google.common.hash.Hashing[JavaMethodDescriptor]

'newHasher' @ [331:76] ==> public abstract fun newHasher(): (Hasher..Hasher?) defined in com.google.common.hash.HashFunction[JavaMethodDescriptor]

'factory' @ [331:89] ==> value-parameter factory: SerializerFactory defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'hash' @ [331:98] ==> public abstract fun hash(): (HashCode..HashCode?) defined in com.google.common.hash.Hasher[JavaMethodDescriptor]

'asBytes' @ [331:105] ==> public abstract fun asBytes(): (ByteArray..ByteArray?) defined in com.google.common.hash.HashCode[JavaMethodDescriptor]

'toBase64' @ [331:115] ==> public fun ByteArray.toBase64(): String defined in net.corda.core.crypto[DeserializedSimpleFunctionDescriptor]

'murmur3_128' @ [335:26] ==> public open fun murmur3_128(): (HashFunction..HashFunction?) defined in com.google.common.hash.Hashing[JavaMethodDescriptor]

'newHasher' @ [335:40] ==> public abstract fun newHasher(): (Hasher..Hasher?) defined in com.google.common.hash.HashFunction[JavaMethodDescriptor]

'typeDescriptors' @ [336:28] ==> value-parameter vararg typeDescriptors: String defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForDescriptors[ValueParameterDescriptorImpl]

'hasher' @ [337:9] ==> val hasher: (Hasher..Hasher?) defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForDescriptors[LocalVariableDescriptor]

'putUnencodedChars' @ [337:16] ==> public abstract fun putUnencodedChars(p0: (CharSequence..CharSequence?)): (Hasher..Hasher?) defined in com.google.common.hash.Hasher[JavaMethodDescriptor]

'typeDescriptor' @ [337:34] ==> val typeDescriptor: String defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForDescriptors[LocalVariableDescriptor]

'hasher' @ [339:12] ==> val hasher: (Hasher..Hasher?) defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForDescriptors[LocalVariableDescriptor]

'hash' @ [339:19] ==> public abstract fun hash(): (HashCode..HashCode?) defined in com.google.common.hash.Hasher[JavaMethodDescriptor]

'asBytes' @ [339:26] ==> public abstract fun asBytes(): (ByteArray..ByteArray?) defined in com.google.common.hash.HashCode[JavaMethodDescriptor]

'toBase64' @ [339:36] ==> public fun ByteArray.toBase64(): String defined in net.corda.core.crypto[DeserializedSimpleFunctionDescriptor]

'factory' @ [344:28] ==> value-parameter factory: SerializerFactory defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintWithCustomSerializerOrElse[ValueParameterDescriptorImpl]

'findCustomSerializer' @ [344:36] ==> internal final fun findCustomSerializer(clazz: Class<*>, declaredType: Type): AMQPSerializer<Any>? defined in net.corda.nodeapi.internal.serialization.amqp.SerializerFactory[SimpleFunctionDescriptorImpl]

'clazz' @ [344:57] ==> value-parameter clazz: Class<*> defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintWithCustomSerializerOrElse[ValueParameterDescriptorImpl]

'declaredType' @ [344:64] ==> value-parameter declaredType: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintWithCustomSerializerOrElse[ValueParameterDescriptorImpl]

'if (customSerializer != null) {
        putUnencodedChars(customSerializer.typeDescriptor)
    } else {
        block()
    }' @ [345:12] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Hasher, elseBranch: Hasher): Hasher[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Hasher

'customSerializer' @ [345:16] ==> val customSerializer: AMQPSerializer<Any>? defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintWithCustomSerializerOrElse[LocalVariableDescriptor]

'putUnencodedChars' @ [346:9] ==> public abstract fun putUnencodedChars(p0: (CharSequence..CharSequence?)): (Hasher..Hasher?) defined in com.google.common.hash.Hasher[JavaMethodDescriptor]

'customSerializer' @ [346:27] ==> val customSerializer: AMQPSerializer<Any>? defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintWithCustomSerializerOrElse[LocalVariableDescriptor]

'typeDescriptor' @ [346:44] ==> public abstract val typeDescriptor: String defined in net.corda.nodeapi.internal.serialization.amqp.AMQPSerializer[PropertyDescriptorImpl]

'invoke' @ [348:9] ==> public abstract operator fun invoke(): Hasher defined in kotlin.Function0[FunctionInvokeDescriptor]

'if (type in alreadySeen) {
        hasher.putUnencodedChars(ALREADY_SEEN_HASH)
    } else {
        alreadySeen += type
        try {
            if (type is SerializerFactory.AnyType) {
                hasher.putUnencodedChars(ANY_TYPE_HASH)
            } else if (type is Class<*>) {
                if (type.isArray) {
                    fingerprintForType(type.componentType, contextType, alreadySeen, hasher, factory).putUnencodedChars(ARRAY_HASH)
                } else if (SerializerFactory.isPrimitive(type)) {
                    hasher.putUnencodedChars(type.name)
                } else if (isCollectionOrMap(type)) {
                    hasher.putUnencodedChars(type.name)
                } else {
                    hasher.fingerprintWithCustomSerializerOrElse(factory, type, type) {
                        if (type.kotlin.objectInstance != null) {
                            // TODO: name collision is too likely for kotlin objects, we need to introduce some reference
                            // to the CorDapp but maybe reference to the JAR in the short term.
                            hasher.putUnencodedChars(type.name)
                        } else {
                            fingerprintForObject(type, type, alreadySeen, hasher, factory)
                        }
                    }
                }
            } else if (type is ParameterizedType) {
                // Hash the rawType + params
                val clazz = type.rawType as Class<*>
                val startingHash = if (isCollectionOrMap(clazz)) {
                    hasher.putUnencodedChars(clazz.name)
                } else {
                    hasher.fingerprintWithCustomSerializerOrElse(factory, clazz, type) {
                        fingerprintForObject(type, type, alreadySeen, hasher, factory)
                    }
                }
                // ... and concatentate the type data for each parameter type.
                type.actualTypeArguments.fold(startingHash) { orig, paramType -> fingerprintForType(paramType, type, alreadySeen, orig, factory) }
            } else if (type is GenericArrayType) {
                // Hash the element type + some array hash
                fingerprintForType(type.genericComponentType, contextType, alreadySeen, hasher, factory).putUnencodedChars(ARRAY_HASH)
            } else if (type is TypeVariable<*>) {
                // TODO: include bounds
                hasher.putUnencodedChars(type.name).putUnencodedChars(TYPE_VARIABLE_HASH)
            } else if (type is WildcardType) {
                hasher.putUnencodedChars(type.typeName).putUnencodedChars(WILDCARD_TYPE_HASH)
            }
            else {
                throw NotSerializableException("Don't know how to hash")
            }
        } catch(e: NotSerializableException) {
            val msg = "${e.message} -> $type"
            logger.error(msg, e)
            throw NotSerializableException(msg)
        }
    }' @ [355:12] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Hasher, elseBranch: Hasher): Hasher[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Hasher

'type' @ [355:16] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'alreadySeen' @ [355:24] ==> value-parameter alreadySeen: MutableSet<Type> defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'hasher' @ [356:9] ==> value-parameter hasher: Hasher defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'putUnencodedChars' @ [356:16] ==> public abstract fun putUnencodedChars(p0: (CharSequence..CharSequence?)): (Hasher..Hasher?) defined in com.google.common.hash.Hasher[JavaMethodDescriptor]

'ALREADY_SEEN_HASH' @ [356:34] ==> private val ALREADY_SEEN_HASH: String defined in net.corda.nodeapi.internal.serialization.amqp in file Schema.kt[PropertyDescriptorImpl]

'alreadySeen' @ [358:9] ==> value-parameter alreadySeen: MutableSet<Type> defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'type' @ [358:24] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'if (type is SerializerFactory.AnyType) {
                hasher.putUnencodedChars(ANY_TYPE_HASH)
            } else if (type is Class<*>) {
                if (type.isArray) {
                    fingerprintForType(type.componentType, contextType, alreadySeen, hasher, factory).putUnencodedChars(ARRAY_HASH)
                } else if (SerializerFactory.isPrimitive(type)) {
                    hasher.putUnencodedChars(type.name)
                } else if (isCollectionOrMap(type)) {
                    hasher.putUnencodedChars(type.name)
                } else {
                    hasher.fingerprintWithCustomSerializerOrElse(factory, type, type) {
                        if (type.kotlin.objectInstance != null) {
                            // TODO: name collision is too likely for kotlin objects, we need to introduce some reference
                            // to the CorDapp but maybe reference to the JAR in the short term.
                            hasher.putUnencodedChars(type.name)
                        } else {
                            fingerprintForObject(type, type, alreadySeen, hasher, factory)
                        }
                    }
                }
            } else if (type is ParameterizedType) {
                // Hash the rawType + params
                val clazz = type.rawType as Class<*>
                val startingHash = if (isCollectionOrMap(clazz)) {
                    hasher.putUnencodedChars(clazz.name)
                } else {
                    hasher.fingerprintWithCustomSerializerOrElse(factory, clazz, type) {
                        fingerprintForObject(type, type, alreadySeen, hasher, factory)
                    }
                }
                // ... and concatentate the type data for each parameter type.
                type.actualTypeArguments.fold(startingHash) { orig, paramType -> fingerprintForType(paramType, type, alreadySeen, orig, factory) }
            } else if (type is GenericArrayType) {
                // Hash the element type + some array hash
                fingerprintForType(type.genericComponentType, contextType, alreadySeen, hasher, factory).putUnencodedChars(ARRAY_HASH)
            } else if (type is TypeVariable<*>) {
                // TODO: include bounds
                hasher.putUnencodedChars(type.name).putUnencodedChars(TYPE_VARIABLE_HASH)
            } else if (type is WildcardType) {
                hasher.putUnencodedChars(type.typeName).putUnencodedChars(WILDCARD_TYPE_HASH)
            }
            else {
                throw NotSerializableException("Don't know how to hash")
            }' @ [360:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (Hasher..Hasher?), elseBranch: (Hasher..Hasher?)): (Hasher..Hasher?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (com.google.common.hash.Hasher..com.google.common.hash.Hasher?)

'type' @ [360:17] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'hasher' @ [361:17] ==> value-parameter hasher: Hasher defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'putUnencodedChars' @ [361:24] ==> public abstract fun putUnencodedChars(p0: (CharSequence..CharSequence?)): (Hasher..Hasher?) defined in com.google.common.hash.Hasher[JavaMethodDescriptor]

'ANY_TYPE_HASH' @ [361:42] ==> private val ANY_TYPE_HASH: String defined in net.corda.nodeapi.internal.serialization.amqp in file Schema.kt[PropertyDescriptorImpl]

'if (type is Class<*>) {
                if (type.isArray) {
                    fingerprintForType(type.componentType, contextType, alreadySeen, hasher, factory).putUnencodedChars(ARRAY_HASH)
                } else if (SerializerFactory.isPrimitive(type)) {
                    hasher.putUnencodedChars(type.name)
                } else if (isCollectionOrMap(type)) {
                    hasher.putUnencodedChars(type.name)
                } else {
                    hasher.fingerprintWithCustomSerializerOrElse(factory, type, type) {
                        if (type.kotlin.objectInstance != null) {
                            // TODO: name collision is too likely for kotlin objects, we need to introduce some reference
                            // to the CorDapp but maybe reference to the JAR in the short term.
                            hasher.putUnencodedChars(type.name)
                        } else {
                            fingerprintForObject(type, type, alreadySeen, hasher, factory)
                        }
                    }
                }
            } else if (type is ParameterizedType) {
                // Hash the rawType + params
                val clazz = type.rawType as Class<*>
                val startingHash = if (isCollectionOrMap(clazz)) {
                    hasher.putUnencodedChars(clazz.name)
                } else {
                    hasher.fingerprintWithCustomSerializerOrElse(factory, clazz, type) {
                        fingerprintForObject(type, type, alreadySeen, hasher, factory)
                    }
                }
                // ... and concatentate the type data for each parameter type.
                type.actualTypeArguments.fold(startingHash) { orig, paramType -> fingerprintForType(paramType, type, alreadySeen, orig, factory) }
            } else if (type is GenericArrayType) {
                // Hash the element type + some array hash
                fingerprintForType(type.genericComponentType, contextType, alreadySeen, hasher, factory).putUnencodedChars(ARRAY_HASH)
            } else if (type is TypeVariable<*>) {
                // TODO: include bounds
                hasher.putUnencodedChars(type.name).putUnencodedChars(TYPE_VARIABLE_HASH)
            } else if (type is WildcardType) {
                hasher.putUnencodedChars(type.typeName).putUnencodedChars(WILDCARD_TYPE_HASH)
            }
            else {
                throw NotSerializableException("Don't know how to hash")
            }' @ [362:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (Hasher..Hasher?), elseBranch: (Hasher..Hasher?)): (Hasher..Hasher?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (com.google.common.hash.Hasher..com.google.common.hash.Hasher?)

'type' @ [362:24] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'if (type.isArray) {
                    fingerprintForType(type.componentType, contextType, alreadySeen, hasher, factory).putUnencodedChars(ARRAY_HASH)
                } else if (SerializerFactory.isPrimitive(type)) {
                    hasher.putUnencodedChars(type.name)
                } else if (isCollectionOrMap(type)) {
                    hasher.putUnencodedChars(type.name)
                } else {
                    hasher.fingerprintWithCustomSerializerOrElse(factory, type, type) {
                        if (type.kotlin.objectInstance != null) {
                            // TODO: name collision is too likely for kotlin objects, we need to introduce some reference
                            // to the CorDapp but maybe reference to the JAR in the short term.
                            hasher.putUnencodedChars(type.name)
                        } else {
                            fingerprintForObject(type, type, alreadySeen, hasher, factory)
                        }
                    }
                }' @ [363:17] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (Hasher..Hasher?), elseBranch: (Hasher..Hasher?)): (Hasher..Hasher?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (com.google.common.hash.Hasher..com.google.common.hash.Hasher?)

'type' @ [363:21] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'isArray' @ [363:26] ==> public final val <T : (Any..Any?)> Class<out (Any..Any?)>.isArray: Boolean[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> (kotlin.Any..kotlin.Any?)

'fingerprintForType' @ [364:21] ==> private fun fingerprintForType(type: Type, contextType: Type?, alreadySeen: MutableSet<Type>, hasher: Hasher, factory: SerializerFactory): Hasher defined in net.corda.nodeapi.internal.serialization.amqp[SimpleFunctionDescriptorImpl]

'type' @ [364:40] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'componentType' @ [364:45] ==> public final val <T : (Any..Any?)> Class<out (Any..Any?)>.componentType: (Class<*>..Class<*>?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> (kotlin.Any..kotlin.Any?)

'contextType' @ [364:60] ==> value-parameter contextType: Type? defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'alreadySeen' @ [364:73] ==> value-parameter alreadySeen: MutableSet<Type> defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'hasher' @ [364:86] ==> value-parameter hasher: Hasher defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'factory' @ [364:94] ==> value-parameter factory: SerializerFactory defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'putUnencodedChars' @ [364:103] ==> public abstract fun putUnencodedChars(p0: (CharSequence..CharSequence?)): (Hasher..Hasher?) defined in com.google.common.hash.Hasher[JavaMethodDescriptor]

'ARRAY_HASH' @ [364:121] ==> private val ARRAY_HASH: String defined in net.corda.nodeapi.internal.serialization.amqp in file Schema.kt[PropertyDescriptorImpl]

'if (SerializerFactory.isPrimitive(type)) {
                    hasher.putUnencodedChars(type.name)
                } else if (isCollectionOrMap(type)) {
                    hasher.putUnencodedChars(type.name)
                } else {
                    hasher.fingerprintWithCustomSerializerOrElse(factory, type, type) {
                        if (type.kotlin.objectInstance != null) {
                            // TODO: name collision is too likely for kotlin objects, we need to introduce some reference
                            // to the CorDapp but maybe reference to the JAR in the short term.
                            hasher.putUnencodedChars(type.name)
                        } else {
                            fingerprintForObject(type, type, alreadySeen, hasher, factory)
                        }
                    }
                }' @ [365:24] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (Hasher..Hasher?), elseBranch: (Hasher..Hasher?)): (Hasher..Hasher?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (com.google.common.hash.Hasher..com.google.common.hash.Hasher?)

'SerializerFactory' @ [365:28] ==> public companion object defined in net.corda.nodeapi.internal.serialization.amqp.SerializerFactory[FakeCallableDescriptorForObject]

'isPrimitive' @ [365:46] ==> public final fun isPrimitive(type: Type): Boolean defined in net.corda.nodeapi.internal.serialization.amqp.SerializerFactory.Companion[SimpleFunctionDescriptorImpl]

'type' @ [365:58] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'hasher' @ [366:21] ==> value-parameter hasher: Hasher defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'putUnencodedChars' @ [366:28] ==> public abstract fun putUnencodedChars(p0: (CharSequence..CharSequence?)): (Hasher..Hasher?) defined in com.google.common.hash.Hasher[JavaMethodDescriptor]

'type' @ [366:46] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'name' @ [366:51] ==> public final val <T : (Any..Any?)> Class<out (Any..Any?)>.name: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> (kotlin.Any..kotlin.Any?)

'if (isCollectionOrMap(type)) {
                    hasher.putUnencodedChars(type.name)
                } else {
                    hasher.fingerprintWithCustomSerializerOrElse(factory, type, type) {
                        if (type.kotlin.objectInstance != null) {
                            // TODO: name collision is too likely for kotlin objects, we need to introduce some reference
                            // to the CorDapp but maybe reference to the JAR in the short term.
                            hasher.putUnencodedChars(type.name)
                        } else {
                            fingerprintForObject(type, type, alreadySeen, hasher, factory)
                        }
                    }
                }' @ [367:24] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (Hasher..Hasher?), elseBranch: (Hasher..Hasher?)): (Hasher..Hasher?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (com.google.common.hash.Hasher..com.google.common.hash.Hasher?)

'isCollectionOrMap' @ [367:28] ==> private fun isCollectionOrMap(type: Class<*>): Boolean defined in net.corda.nodeapi.internal.serialization.amqp[SimpleFunctionDescriptorImpl]

'type' @ [367:46] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'hasher' @ [368:21] ==> value-parameter hasher: Hasher defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'putUnencodedChars' @ [368:28] ==> public abstract fun putUnencodedChars(p0: (CharSequence..CharSequence?)): (Hasher..Hasher?) defined in com.google.common.hash.Hasher[JavaMethodDescriptor]

'type' @ [368:46] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'name' @ [368:51] ==> public final val <T : (Any..Any?)> Class<out (Any..Any?)>.name: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> (kotlin.Any..kotlin.Any?)

'hasher' @ [370:21] ==> value-parameter hasher: Hasher defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'fingerprintWithCustomSerializerOrElse' @ [370:28] ==> private fun Hasher.fingerprintWithCustomSerializerOrElse(factory: SerializerFactory, clazz: Class<*>, declaredType: Type, block: () -> Hasher): Hasher defined in net.corda.nodeapi.internal.serialization.amqp[SimpleFunctionDescriptorImpl]

'factory' @ [370:66] ==> value-parameter factory: SerializerFactory defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'type' @ [370:75] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'type' @ [370:81] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'if (type.kotlin.objectInstance != null) {
                            // TODO: name collision is too likely for kotlin objects, we need to introduce some reference
                            // to the CorDapp but maybe reference to the JAR in the short term.
                            hasher.putUnencodedChars(type.name)
                        } else {
                            fingerprintForObject(type, type, alreadySeen, hasher, factory)
                        }' @ [371:25] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Hasher, elseBranch: Hasher): Hasher[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Hasher

'type' @ [371:29] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'kotlin' @ [371:34] ==> public val <T : Any> Class<out (Any..Any?)>.kotlin: KClass<out (Any..Any?)> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> (kotlin.Any..kotlin.Any?)

'objectInstance' @ [371:41] ==> public abstract val objectInstance: Any? defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor]

'hasher' @ [374:29] ==> value-parameter hasher: Hasher defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'putUnencodedChars' @ [374:36] ==> public abstract fun putUnencodedChars(p0: (CharSequence..CharSequence?)): (Hasher..Hasher?) defined in com.google.common.hash.Hasher[JavaMethodDescriptor]

'type' @ [374:54] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'name' @ [374:59] ==> public final val <T : (Any..Any?)> Class<out (Any..Any?)>.name: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> (kotlin.Any..kotlin.Any?)

'fingerprintForObject' @ [376:29] ==> private fun fingerprintForObject(type: Type, contextType: Type?, alreadySeen: MutableSet<Type>, hasher: Hasher, factory: SerializerFactory): Hasher defined in net.corda.nodeapi.internal.serialization.amqp[SimpleFunctionDescriptorImpl]

'type' @ [376:50] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'type' @ [376:56] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'alreadySeen' @ [376:62] ==> value-parameter alreadySeen: MutableSet<Type> defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'hasher' @ [376:75] ==> value-parameter hasher: Hasher defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'factory' @ [376:83] ==> value-parameter factory: SerializerFactory defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'if (type is ParameterizedType) {
                // Hash the rawType + params
                val clazz = type.rawType as Class<*>
                val startingHash = if (isCollectionOrMap(clazz)) {
                    hasher.putUnencodedChars(clazz.name)
                } else {
                    hasher.fingerprintWithCustomSerializerOrElse(factory, clazz, type) {
                        fingerprintForObject(type, type, alreadySeen, hasher, factory)
                    }
                }
                // ... and concatentate the type data for each parameter type.
                type.actualTypeArguments.fold(startingHash) { orig, paramType -> fingerprintForType(paramType, type, alreadySeen, orig, factory) }
            } else if (type is GenericArrayType) {
                // Hash the element type + some array hash
                fingerprintForType(type.genericComponentType, contextType, alreadySeen, hasher, factory).putUnencodedChars(ARRAY_HASH)
            } else if (type is TypeVariable<*>) {
                // TODO: include bounds
                hasher.putUnencodedChars(type.name).putUnencodedChars(TYPE_VARIABLE_HASH)
            } else if (type is WildcardType) {
                hasher.putUnencodedChars(type.typeName).putUnencodedChars(WILDCARD_TYPE_HASH)
            }
            else {
                throw NotSerializableException("Don't know how to hash")
            }' @ [380:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (Hasher..Hasher?), elseBranch: (Hasher..Hasher?)): (Hasher..Hasher?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (com.google.common.hash.Hasher..com.google.common.hash.Hasher?)

'type' @ [380:24] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'type' @ [382:29] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'rawType' @ [382:34] ==> public final val ParameterizedType.rawType: (Type..Type?)[MyPropertyDescriptor]

'if (isCollectionOrMap(clazz)) {
                    hasher.putUnencodedChars(clazz.name)
                } else {
                    hasher.fingerprintWithCustomSerializerOrElse(factory, clazz, type) {
                        fingerprintForObject(type, type, alreadySeen, hasher, factory)
                    }
                }' @ [383:36] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (Hasher..Hasher?), elseBranch: (Hasher..Hasher?)): (Hasher..Hasher?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (com.google.common.hash.Hasher..com.google.common.hash.Hasher?)

'isCollectionOrMap' @ [383:40] ==> private fun isCollectionOrMap(type: Class<*>): Boolean defined in net.corda.nodeapi.internal.serialization.amqp[SimpleFunctionDescriptorImpl]

'clazz' @ [383:58] ==> val clazz: Class<*> defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[LocalVariableDescriptor]

'hasher' @ [384:21] ==> value-parameter hasher: Hasher defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'putUnencodedChars' @ [384:28] ==> public abstract fun putUnencodedChars(p0: (CharSequence..CharSequence?)): (Hasher..Hasher?) defined in com.google.common.hash.Hasher[JavaMethodDescriptor]

'clazz' @ [384:46] ==> val clazz: Class<*> defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[LocalVariableDescriptor]

'name' @ [384:52] ==> public final val <T : (Any..Any?)> Class<out (Any..Any?)>.name: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> (kotlin.Any..kotlin.Any?)

'hasher' @ [386:21] ==> value-parameter hasher: Hasher defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'fingerprintWithCustomSerializerOrElse' @ [386:28] ==> private fun Hasher.fingerprintWithCustomSerializerOrElse(factory: SerializerFactory, clazz: Class<*>, declaredType: Type, block: () -> Hasher): Hasher defined in net.corda.nodeapi.internal.serialization.amqp[SimpleFunctionDescriptorImpl]

'factory' @ [386:66] ==> value-parameter factory: SerializerFactory defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'clazz' @ [386:75] ==> val clazz: Class<*> defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[LocalVariableDescriptor]

'type' @ [386:82] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'fingerprintForObject' @ [387:25] ==> private fun fingerprintForObject(type: Type, contextType: Type?, alreadySeen: MutableSet<Type>, hasher: Hasher, factory: SerializerFactory): Hasher defined in net.corda.nodeapi.internal.serialization.amqp[SimpleFunctionDescriptorImpl]

'type' @ [387:46] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'type' @ [387:52] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'alreadySeen' @ [387:58] ==> value-parameter alreadySeen: MutableSet<Type> defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'hasher' @ [387:71] ==> value-parameter hasher: Hasher defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'factory' @ [387:79] ==> value-parameter factory: SerializerFactory defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'type' @ [391:17] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'actualTypeArguments' @ [391:22] ==> public final val ParameterizedType.actualTypeArguments: (Array<(Type..Type?)>..Array<out (Type..Type?)>?)[MyPropertyDescriptor]

'fold' @ [391:42] ==> public inline fun <T, R> Array<out (Type..Type?)>.fold(initial: (Hasher..Hasher?), operation: ((Hasher..Hasher?), (Type..Type?)) -> (Hasher..Hasher?)): (Hasher..Hasher?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (java.lang.reflect.Type..java.lang.reflect.Type?)
    <R> -> (com.google.common.hash.Hasher..com.google.common.hash.Hasher?)

'startingHash' @ [391:47] ==> val startingHash: (Hasher..Hasher?) defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[LocalVariableDescriptor]

'fingerprintForType' @ [391:82] ==> private fun fingerprintForType(type: Type, contextType: Type?, alreadySeen: MutableSet<Type>, hasher: Hasher, factory: SerializerFactory): Hasher defined in net.corda.nodeapi.internal.serialization.amqp[SimpleFunctionDescriptorImpl]

'paramType' @ [391:101] ==> value-parameter paramType: (Type..Type?) defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [391:112] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'alreadySeen' @ [391:118] ==> value-parameter alreadySeen: MutableSet<Type> defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'orig' @ [391:131] ==> value-parameter orig: (Hasher..Hasher?) defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType.<anonymous>[ValueParameterDescriptorImpl]

'factory' @ [391:137] ==> value-parameter factory: SerializerFactory defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'if (type is GenericArrayType) {
                // Hash the element type + some array hash
                fingerprintForType(type.genericComponentType, contextType, alreadySeen, hasher, factory).putUnencodedChars(ARRAY_HASH)
            } else if (type is TypeVariable<*>) {
                // TODO: include bounds
                hasher.putUnencodedChars(type.name).putUnencodedChars(TYPE_VARIABLE_HASH)
            } else if (type is WildcardType) {
                hasher.putUnencodedChars(type.typeName).putUnencodedChars(WILDCARD_TYPE_HASH)
            }
            else {
                throw NotSerializableException("Don't know how to hash")
            }' @ [392:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (Hasher..Hasher?), elseBranch: (Hasher..Hasher?)): (Hasher..Hasher?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (com.google.common.hash.Hasher..com.google.common.hash.Hasher?)

'type' @ [392:24] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'fingerprintForType' @ [394:17] ==> private fun fingerprintForType(type: Type, contextType: Type?, alreadySeen: MutableSet<Type>, hasher: Hasher, factory: SerializerFactory): Hasher defined in net.corda.nodeapi.internal.serialization.amqp[SimpleFunctionDescriptorImpl]

'type' @ [394:36] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'genericComponentType' @ [394:41] ==> public final val GenericArrayType.genericComponentType: (Type..Type?)[MyPropertyDescriptor]

'contextType' @ [394:63] ==> value-parameter contextType: Type? defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'alreadySeen' @ [394:76] ==> value-parameter alreadySeen: MutableSet<Type> defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'hasher' @ [394:89] ==> value-parameter hasher: Hasher defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'factory' @ [394:97] ==> value-parameter factory: SerializerFactory defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'putUnencodedChars' @ [394:106] ==> public abstract fun putUnencodedChars(p0: (CharSequence..CharSequence?)): (Hasher..Hasher?) defined in com.google.common.hash.Hasher[JavaMethodDescriptor]

'ARRAY_HASH' @ [394:124] ==> private val ARRAY_HASH: String defined in net.corda.nodeapi.internal.serialization.amqp in file Schema.kt[PropertyDescriptorImpl]

'if (type is TypeVariable<*>) {
                // TODO: include bounds
                hasher.putUnencodedChars(type.name).putUnencodedChars(TYPE_VARIABLE_HASH)
            } else if (type is WildcardType) {
                hasher.putUnencodedChars(type.typeName).putUnencodedChars(WILDCARD_TYPE_HASH)
            }
            else {
                throw NotSerializableException("Don't know how to hash")
            }' @ [395:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (Hasher..Hasher?), elseBranch: (Hasher..Hasher?)): (Hasher..Hasher?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (com.google.common.hash.Hasher..com.google.common.hash.Hasher?)

'type' @ [395:24] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'hasher' @ [397:17] ==> value-parameter hasher: Hasher defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'putUnencodedChars' @ [397:24] ==> public abstract fun putUnencodedChars(p0: (CharSequence..CharSequence?)): (Hasher..Hasher?) defined in com.google.common.hash.Hasher[JavaMethodDescriptor]

'type' @ [397:42] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'name' @ [397:47] ==> public final val <D : (GenericDeclaration..GenericDeclaration?)> TypeVariable<out (GenericDeclaration..GenericDeclaration?)>.name: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <D : (GenericDeclaration..GenericDeclaration?)> -> (java.lang.reflect.GenericDeclaration..java.lang.reflect.GenericDeclaration?)

'putUnencodedChars' @ [397:53] ==> public abstract fun putUnencodedChars(p0: (CharSequence..CharSequence?)): (Hasher..Hasher?) defined in com.google.common.hash.Hasher[JavaMethodDescriptor]

'TYPE_VARIABLE_HASH' @ [397:71] ==> private val TYPE_VARIABLE_HASH: String defined in net.corda.nodeapi.internal.serialization.amqp in file Schema.kt[PropertyDescriptorImpl]

'if (type is WildcardType) {
                hasher.putUnencodedChars(type.typeName).putUnencodedChars(WILDCARD_TYPE_HASH)
            }
            else {
                throw NotSerializableException("Don't know how to hash")
            }' @ [398:20] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: (Hasher..Hasher?), elseBranch: (Hasher..Hasher?)): (Hasher..Hasher?)[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> (com.google.common.hash.Hasher..com.google.common.hash.Hasher?)

'type' @ [398:24] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'hasher' @ [399:17] ==> value-parameter hasher: Hasher defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'putUnencodedChars' @ [399:24] ==> public abstract fun putUnencodedChars(p0: (CharSequence..CharSequence?)): (Hasher..Hasher?) defined in com.google.common.hash.Hasher[JavaMethodDescriptor]

'type' @ [399:42] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'typeName' @ [399:47] ==> public final val WildcardType.typeName: (String..String?)[MyPropertyDescriptor]

'putUnencodedChars' @ [399:57] ==> public abstract fun putUnencodedChars(p0: (CharSequence..CharSequence?)): (Hasher..Hasher?) defined in com.google.common.hash.Hasher[JavaMethodDescriptor]

'WILDCARD_TYPE_HASH' @ [399:75] ==> private val WILDCARD_TYPE_HASH: String defined in net.corda.nodeapi.internal.serialization.amqp in file Schema.kt[PropertyDescriptorImpl]

'NotSerializableException' @ [402:23] ==> public constructor NotSerializableException(p0: (String..String?)) defined in java.io.NotSerializableException[JavaClassConstructorDescriptor]

'e' @ [405:26] ==> val e: NotSerializableException defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[LocalVariableDescriptor]

'message' @ [405:28] ==> public open val message: String? defined in java.io.NotSerializableException[DeserializedPropertyDescriptor]

'type' @ [405:41] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[ValueParameterDescriptorImpl]

'logger' @ [406:13] ==> private val logger: Logger defined in net.corda.nodeapi.internal.serialization.amqp in file Schema.kt[PropertyDescriptorImpl]

'error' @ [406:20] ==> public abstract fun error(p0: (String..String?), p1: (Throwable..Throwable?)): Unit defined in org.slf4j.Logger[JavaMethodDescriptor]

'msg' @ [406:26] ==> val msg: String defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[LocalVariableDescriptor]

'e' @ [406:31] ==> val e: NotSerializableException defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[LocalVariableDescriptor]

'NotSerializableException' @ [407:19] ==> public constructor NotSerializableException(p0: (String..String?)) defined in java.io.NotSerializableException[JavaClassConstructorDescriptor]

'msg' @ [407:44] ==> val msg: String defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForType[LocalVariableDescriptor]

'java' @ [412:67] ==> public val <T> KClass<Collection<*>>.java: Class<Collection<*>> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> Collection<*>

'isAssignableFrom' @ [412:72] ==> public open fun isAssignableFrom(p0: (Class<*>..Class<*>?)): Boolean defined in java.lang.Class[JavaMethodDescriptor]

'type' @ [412:89] ==> value-parameter type: Class<*> defined in net.corda.nodeapi.internal.serialization.amqp.isCollectionOrMap[ValueParameterDescriptorImpl]

'java' @ [412:109] ==> public val <T> KClass<Map<*, *>>.java: Class<Map<*, *>> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> Map<*, *>

'isAssignableFrom' @ [412:114] ==> public open fun isAssignableFrom(p0: (Class<*>..Class<*>?)): Boolean defined in java.lang.Class[JavaMethodDescriptor]

'type' @ [412:131] ==> value-parameter type: Class<*> defined in net.corda.nodeapi.internal.serialization.amqp.isCollectionOrMap[ValueParameterDescriptorImpl]

'type' @ [416:16] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForObject[ValueParameterDescriptorImpl]

'asClass' @ [416:21] ==> internal fun Type.asClass(): Class<*>? defined in net.corda.nodeapi.internal.serialization.amqp in file SerializationHelper.kt[SimpleFunctionDescriptorImpl]

'name' @ [416:32] ==> public final val <T : (Any..Any?)> Class<out (Any..Any?)>.name: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> (kotlin.Any..kotlin.Any?)

'NotSerializableException' @ [416:46] ==> public constructor NotSerializableException(p0: (String..String?)) defined in java.io.NotSerializableException[JavaClassConstructorDescriptor]

'type' @ [416:124] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForObject[ValueParameterDescriptorImpl]

'propertiesForSerialization' @ [417:5] ==> internal fun <T : Any> propertiesForSerialization(kotlinConstructor: KFunction<Any>?, type: Type, factory: SerializerFactory): Collection<PropertySerializer> defined in net.corda.nodeapi.internal.serialization.amqp[SimpleFunctionDescriptorImpl]
Inferred types:
    <T : Any> -> Any

'constructorForDeserialization' @ [417:32] ==> internal fun constructorForDeserialization(type: Type): KFunction<Any>? defined in net.corda.nodeapi.internal.serialization.amqp[SimpleFunctionDescriptorImpl]

'type' @ [417:62] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForObject[ValueParameterDescriptorImpl]

'contextType' @ [417:69] ==> value-parameter contextType: Type? defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForObject[ValueParameterDescriptorImpl]

'type' @ [417:84] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForObject[ValueParameterDescriptorImpl]

'factory' @ [417:90] ==> value-parameter factory: SerializerFactory defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForObject[ValueParameterDescriptorImpl]

'fold' @ [417:99] ==> public inline fun <T, R> Iterable<PropertySerializer>.fold(initial: (Hasher..Hasher?), operation: ((Hasher..Hasher?), PropertySerializer) -> (Hasher..Hasher?)): (Hasher..Hasher?) defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PropertySerializer
    <R> -> (com.google.common.hash.Hasher..com.google.common.hash.Hasher?)

'hasher' @ [417:104] ==> value-parameter hasher: Hasher defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForObject[ValueParameterDescriptorImpl]

'putUnencodedChars' @ [417:111] ==> public abstract fun putUnencodedChars(p0: (CharSequence..CharSequence?)): (Hasher..Hasher?) defined in com.google.common.hash.Hasher[JavaMethodDescriptor]

'name' @ [417:129] ==> val name: String defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForObject[LocalVariableDescriptor]

'fingerprintForType' @ [418:9] ==> private fun fingerprintForType(type: Type, contextType: Type?, alreadySeen: MutableSet<Type>, hasher: Hasher, factory: SerializerFactory): Hasher defined in net.corda.nodeapi.internal.serialization.amqp[SimpleFunctionDescriptorImpl]

'prop' @ [418:28] ==> value-parameter prop: PropertySerializer defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForObject.<anonymous>[ValueParameterDescriptorImpl]

'resolvedType' @ [418:33] ==> public final val resolvedType: Type defined in net.corda.nodeapi.internal.serialization.amqp.PropertySerializer[PropertyDescriptorImpl]

'type' @ [418:47] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForObject[ValueParameterDescriptorImpl]

'alreadySeen' @ [418:53] ==> value-parameter alreadySeen: MutableSet<Type> defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForObject[ValueParameterDescriptorImpl]

'orig' @ [418:66] ==> value-parameter orig: (Hasher..Hasher?) defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForObject.<anonymous>[ValueParameterDescriptorImpl]

'factory' @ [418:72] ==> value-parameter factory: SerializerFactory defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForObject[ValueParameterDescriptorImpl]

'putUnencodedChars' @ [418:81] ==> public abstract fun putUnencodedChars(p0: (CharSequence..CharSequence?)): (Hasher..Hasher?) defined in com.google.common.hash.Hasher[JavaMethodDescriptor]

'prop' @ [418:99] ==> value-parameter prop: PropertySerializer defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForObject.<anonymous>[ValueParameterDescriptorImpl]

'name' @ [418:104] ==> public final val name: String defined in net.corda.nodeapi.internal.serialization.amqp.PropertySerializer[PropertyDescriptorImpl]

'putUnencodedChars' @ [418:110] ==> public abstract fun putUnencodedChars(p0: (CharSequence..CharSequence?)): (Hasher..Hasher?) defined in com.google.common.hash.Hasher[JavaMethodDescriptor]

'if (prop.mandatory) NOT_NULLABLE_HASH else NULLABLE_HASH' @ [418:128] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: String, elseBranch: String): String[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> String

'prop' @ [418:132] ==> value-parameter prop: PropertySerializer defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForObject.<anonymous>[ValueParameterDescriptorImpl]

'mandatory' @ [418:137] ==> public final val mandatory: Boolean defined in net.corda.nodeapi.internal.serialization.amqp.PropertySerializer[PropertyDescriptorImpl]

'NOT_NULLABLE_HASH' @ [418:148] ==> private val NOT_NULLABLE_HASH: String defined in net.corda.nodeapi.internal.serialization.amqp in file Schema.kt[PropertyDescriptorImpl]

'NULLABLE_HASH' @ [418:171] ==> private val NULLABLE_HASH: String defined in net.corda.nodeapi.internal.serialization.amqp in file Schema.kt[PropertyDescriptorImpl]

'interfacesForSerialization' @ [420:5] ==> internal fun interfacesForSerialization(type: Type, serializerFactory: SerializerFactory): List<Type> defined in net.corda.nodeapi.internal.serialization.amqp[SimpleFunctionDescriptorImpl]

'type' @ [420:32] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForObject[ValueParameterDescriptorImpl]

'factory' @ [420:38] ==> value-parameter factory: SerializerFactory defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForObject[ValueParameterDescriptorImpl]

'map' @ [420:47] ==> public inline fun <T, R> Iterable<Type>.map(transform: (Type) -> Hasher): List<Hasher> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Type
    <R> -> Hasher

'fingerprintForType' @ [420:53] ==> private fun fingerprintForType(type: Type, contextType: Type?, alreadySeen: MutableSet<Type>, hasher: Hasher, factory: SerializerFactory): Hasher defined in net.corda.nodeapi.internal.serialization.amqp[SimpleFunctionDescriptorImpl]

'it' @ [420:72] ==> value-parameter it: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForObject.<anonymous>[ValueParameterDescriptorImpl]

'type' @ [420:76] ==> value-parameter type: Type defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForObject[ValueParameterDescriptorImpl]

'alreadySeen' @ [420:82] ==> value-parameter alreadySeen: MutableSet<Type> defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForObject[ValueParameterDescriptorImpl]

'hasher' @ [420:95] ==> value-parameter hasher: Hasher defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForObject[ValueParameterDescriptorImpl]

'factory' @ [420:103] ==> value-parameter factory: SerializerFactory defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForObject[ValueParameterDescriptorImpl]

'hasher' @ [421:12] ==> value-parameter hasher: Hasher defined in net.corda.nodeapi.internal.serialization.amqp.fingerprintForObject[ValueParameterDescriptorImpl]

