'Before' @ [76:5] ==> public constructor Before() defined in org.junit.Before[JavaClassConstructorDescriptor]

'LogHelper' @ [78:9] ==> public object LogHelper defined in net.corda.testing[FakeCallableDescriptorForObject]

'setLevel' @ [78:19] ==> public final fun setLevel(vararg loggerNames: String): Unit defined in net.corda.testing.LogHelper[DeserializedSimpleFunctionDescriptor]

'After' @ [81:5] ==> public constructor After() defined in org.junit.After[JavaClassConstructorDescriptor]

'mockNet' @ [83:9] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'stopNodes' @ [83:17] ==> public final fun stopNodes(): Unit defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'LogHelper' @ [84:9] ==> public object LogHelper defined in net.corda.testing[FakeCallableDescriptorForObject]

'reset' @ [84:19] ==> public final fun reset(vararg names: String): Unit defined in net.corda.testing.LogHelper[DeserializedSimpleFunctionDescriptor]

'Test' @ [87:5] ==> public constructor Test(expected: KClass<out (Throwable..Throwable?)> = ..., timeout: Long = ...) defined in org.junit.Test[JavaClassConstructorDescriptor]

'mockNet' @ [92:9] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'MockNetwork' @ [92:19] ==> public constructor MockNetwork(networkSendManuallyPumped: Boolean = ..., threadPerNode: Boolean = ..., servicePeerAllocationStrategy: InMemoryMessagingNetwork.ServicePeerAllocationStrategy = ..., defaultFactory: MockNetwork.Factory<*> = ..., initialiseSerialization: Boolean = ...) defined in net.corda.testing.node.MockNetwork[DeserializedClassConstructorDescriptor]

'ledger' @ [94:9] ==> @JvmOverloads public fun ledger(services: ServiceHub = ..., initialiseSerialization: Boolean = ..., dsl: LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter>.() -> Unit): LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]

'mockNet' @ [95:33] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'createSomeNodes' @ [95:41] ==> @JvmOverloads public final fun createSomeNodes(numPartyNodes: Int = ..., nodeFactory: MockNetwork.Factory<*> = ..., notaryKeyPair: KeyPair? = ...): MockNetwork.BasketOfNodes defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'basketOfNodes' @ [96:30] ==> val basketOfNodes: MockNetwork.BasketOfNodes defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'notaryNode' @ [96:44] ==> public final val notaryNode: MockNetwork.MockNode defined in net.corda.testing.node.MockNetwork.BasketOfNodes[DeserializedPropertyDescriptor]

'basketOfNodes' @ [97:29] ==> val basketOfNodes: MockNetwork.BasketOfNodes defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'partyNodes' @ [97:43] ==> public final val partyNodes: List<MockNetwork.MockNode> defined in net.corda.testing.node.MockNetwork.BasketOfNodes[DeserializedPropertyDescriptor]

'basketOfNodes' @ [98:27] ==> val basketOfNodes: MockNetwork.BasketOfNodes defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'partyNodes' @ [98:41] ==> public final val partyNodes: List<MockNetwork.MockNode> defined in net.corda.testing.node.MockNetwork.BasketOfNodes[DeserializedPropertyDescriptor]

'basketOfNodes' @ [99:28] ==> val basketOfNodes: MockNetwork.BasketOfNodes defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'partyNodes' @ [99:42] ==> public final val partyNodes: List<MockNetwork.MockNode> defined in net.corda.testing.node.MockNetwork.BasketOfNodes[DeserializedPropertyDescriptor]

'bankNode' @ [100:30] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'info' @ [100:39] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [100:44] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'ref' @ [100:58] ==> public final fun ref(vararg bytes: Byte): PartyAndReference defined in net.corda.core.identity.Party[DeserializedSimpleFunctionDescriptor]

'bankNode' @ [101:28] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'info' @ [101:37] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [101:42] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'ref' @ [101:56] ==> public final fun ref(vararg bytes: Byte): PartyAndReference defined in net.corda.core.identity.Party[DeserializedSimpleFunctionDescriptor]

'aliceNode' @ [103:13] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'disableDBCloseOnStop' @ [103:23] ==> public final fun disableDBCloseOnStop(): Unit defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'bobNode' @ [104:13] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'disableDBCloseOnStop' @ [104:21] ==> public final fun disableDBCloseOnStop(): Unit defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'bobNode' @ [106:13] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'database' @ [106:21] ==> public final lateinit var database: CordaPersistence defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'transaction' @ [106:30] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> Vault<Cash.State>): Vault<Cash.State> defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Vault<State>

'bobNode' @ [107:17] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'services' @ [107:25] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'fillWithSomeTestCash' @ [107:34] ==> public fun ServiceHub.fillWithSomeTestCash(howMuch: Amount<Currency>, issuerServices: ServiceHub = ..., outputNotary: Party = ..., atLeastThisManyStates: Int = ..., atMostThisManyStates: Int = ..., rng: Random = ..., ref: OpaqueBytes = ..., ownedBy: AbstractParty? = ..., issuedBy: PartyAndReference = ...): Vault<Cash.State> defined in net.corda.testing.contracts[DeserializedSimpleFunctionDescriptor]

'DOLLARS' @ [107:60] ==> public val Int.DOLLARS: Amount<Currency> defined in net.corda.finance[DeserializedPropertyDescriptor]

'bankNode' @ [107:69] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'services' @ [107:78] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'notaryNode' @ [107:103] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'info' @ [107:114] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'notaryIdentity' @ [107:119] ==> public final val notaryIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'cashIssuer' @ [108:36] ==> val cashIssuer: PartyAndReference defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'aliceNode' @ [111:35] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'database' @ [111:45] ==> public final lateinit var database: CordaPersistence defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'transaction' @ [111:54] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> List<WireTransaction>): List<WireTransaction> defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> List<WireTransaction>

'fillUpForSeller' @ [112:17] ==> private final fun LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter>.fillUpForSeller(withError: Boolean, issuer: PartyAndReference, owner: AbstractParty, amount: Amount<Issued<Currency>>, attachmentID: SecureHash?, notary: Party): Pair<Vault<ContractState>, List<WireTransaction>> defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'cpIssuer' @ [112:40] ==> val cpIssuer: PartyAndReference defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'aliceNode' @ [112:50] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'info' @ [112:60] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [112:65] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'`issued by`' @ [113:25] ==> public infix fun Amount<Currency>.`issued by`(deposit: PartyAndReference): Amount<Issued<Currency>> defined in net.corda.finance[DeserializedSimpleFunctionDescriptor]

'DOLLARS' @ [113:30] ==> public val Int.DOLLARS: Amount<Currency> defined in net.corda.finance[DeserializedPropertyDescriptor]

'bankNode' @ [113:50] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'info' @ [113:59] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [113:64] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'ref' @ [113:78] ==> public final fun ref(vararg bytes: Byte): PartyAndReference defined in net.corda.core.identity.Party[DeserializedSimpleFunctionDescriptor]

'notaryNode' @ [113:92] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'info' @ [113:103] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'notaryIdentity' @ [113:108] ==> public final val notaryIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'second' @ [113:124] ==> public final val second: List<WireTransaction> defined in kotlin.Pair[DeserializedPropertyDescriptor]

'insertFakeTransactions' @ [116:13] ==> private final fun insertFakeTransactions(wtxToSign: List<WireTransaction>, node: AbstractNode, notaryNode: AbstractNode, vararg extraSigningNodes: AbstractNode): Map<SecureHash, SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'alicesFakePaper' @ [116:36] ==> val alicesFakePaper: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'aliceNode' @ [116:53] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'notaryNode' @ [116:64] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'bankNode' @ [116:76] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'component1' @ [118:18] ==> public final operator fun component1(): CordaFuture<FlowStateMachine<*>> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RunResult[SimpleFunctionDescriptorImpl]

'component2' @ [118:35] ==> public final operator fun component2(): CordaFuture<SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RunResult[SimpleFunctionDescriptorImpl]

'runBuyerAndSeller' @ [118:50] ==> private final fun runBuyerAndSeller(notaryNode: MockNetwork.MockNode, sellerNode: MockNetwork.MockNode, buyerNode: MockNetwork.MockNode, assetToSell: StateAndRef<OwnableState>): TwoPartyTradeFlowTests.RunResult defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'notaryNode' @ [118:68] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'aliceNode' @ [118:80] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'bobNode' @ [118:91] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'outputStateAndRef' @ [119:37] ==> public final inline fun <reified S : ContractState> String.outputStateAndRef(): StateAndRef<OwnableState> defined in net.corda.testing.LedgerDSL[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified S : ContractState> -> OwnableState

'assertEquals' @ [123:13] ==> public fun <@OnlyInputTypes T> assertEquals(expected: Any?, actual: Any?, message: String? = ...): Unit defined in kotlin.test[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <@OnlyInputTypes T> -> Any?

'aliceResult' @ [123:26] ==> val aliceResult: CordaFuture<SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'getOrThrow' @ [123:38] ==> public fun <V> Future<SignedTransaction>.getOrThrow(timeout: Duration? = ...): SignedTransaction defined in net.corda.core.utilities[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <V> -> SignedTransaction

'bobStateMachine' @ [123:52] ==> val bobStateMachine: CordaFuture<FlowStateMachine<*>> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'getOrThrow' @ [123:68] ==> public fun <V> Future<FlowStateMachine<*>>.getOrThrow(timeout: Duration? = ...): FlowStateMachine<*> defined in net.corda.core.utilities[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <V> -> FlowStateMachine<*>

'resultFuture' @ [123:81] ==> public abstract val resultFuture: CordaFuture<out Any?> defined in net.corda.core.internal.FlowStateMachine[DeserializedPropertyDescriptor]

'getOrThrow' @ [123:94] ==> public fun <V> Future<out Any?>.getOrThrow(timeout: Duration? = ...): Any? defined in net.corda.core.utilities[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <V> -> Any?

'aliceNode' @ [125:13] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'stop' @ [125:23] ==> public open fun stop(): Unit defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'bobNode' @ [126:13] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'stop' @ [126:21] ==> public open fun stop(): Unit defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'aliceNode' @ [128:13] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'database' @ [128:23] ==> public final lateinit var database: CordaPersistence defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'transaction' @ [128:32] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> Unit): Unit defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Unit

'assertThat' @ [129:17] ==> @CheckReturnValue public open fun <ELEMENT : (Any..Any?)> assertThat(p0: (MutableList<out (Checkpoint..Checkpoint?)>..List<(Checkpoint..Checkpoint?)>?)): (ListAssert<(Checkpoint..Checkpoint?)>..ListAssert<(Checkpoint..Checkpoint?)>?) defined in org.assertj.core.api.Assertions[JavaMethodDescriptor]
Inferred types:
    <ELEMENT : (Any..Any?)> -> Checkpoint

'aliceNode' @ [129:28] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'checkpointStorage' @ [129:38] ==> public final lateinit var checkpointStorage: CheckpointStorage defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'checkpoints' @ [129:56] ==> internal fun CheckpointStorage.checkpoints(): List<Checkpoint> defined in net.corda.node.services.persistence[SimpleFunctionDescriptorImpl]

'isEmpty' @ [129:71] ==> public open fun isEmpty(): Unit defined in org.assertj.core.api.ListAssert[JavaMethodDescriptor]

'aliceNode' @ [131:13] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'manuallyCloseDB' @ [131:23] ==> public final fun manuallyCloseDB(): Unit defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'bobNode' @ [132:13] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'database' @ [132:21] ==> public final lateinit var database: CordaPersistence defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'transaction' @ [132:30] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> Unit): Unit defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Unit

'assertThat' @ [133:17] ==> @CheckReturnValue public open fun <ELEMENT : (Any..Any?)> assertThat(p0: (MutableList<out (Checkpoint..Checkpoint?)>..List<(Checkpoint..Checkpoint?)>?)): (ListAssert<(Checkpoint..Checkpoint?)>..ListAssert<(Checkpoint..Checkpoint?)>?) defined in org.assertj.core.api.Assertions[JavaMethodDescriptor]
Inferred types:
    <ELEMENT : (Any..Any?)> -> Checkpoint

'bobNode' @ [133:28] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'checkpointStorage' @ [133:36] ==> public final lateinit var checkpointStorage: CheckpointStorage defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'checkpoints' @ [133:54] ==> internal fun CheckpointStorage.checkpoints(): List<Checkpoint> defined in net.corda.node.services.persistence[SimpleFunctionDescriptorImpl]

'isEmpty' @ [133:69] ==> public open fun isEmpty(): Unit defined in org.assertj.core.api.ListAssert[JavaMethodDescriptor]

'bobNode' @ [135:13] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper`.<anonymous>[LocalVariableDescriptor]

'manuallyCloseDB' @ [135:21] ==> public final fun manuallyCloseDB(): Unit defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'Test' @ [139:5] ==> public constructor Test(expected: KClass<out (Throwable..Throwable?)> = ..., timeout: Long = ...) defined in org.junit.Test[JavaClassConstructorDescriptor]

'InsufficientBalanceException' @ [139:22] ==> public constructor InsufficientBalanceException(amountMissing: Amount<*>) defined in net.corda.core.contracts.InsufficientBalanceException[DeserializedClassConstructorDescriptor]

'mockNet' @ [141:9] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'MockNetwork' @ [141:19] ==> public constructor MockNetwork(networkSendManuallyPumped: Boolean = ..., threadPerNode: Boolean = ..., servicePeerAllocationStrategy: InMemoryMessagingNetwork.ServicePeerAllocationStrategy = ..., defaultFactory: MockNetwork.Factory<*> = ..., initialiseSerialization: Boolean = ...) defined in net.corda.testing.node.MockNetwork[DeserializedClassConstructorDescriptor]

'ledger' @ [143:9] ==> @JvmOverloads public fun ledger(services: ServiceHub = ..., initialiseSerialization: Boolean = ..., dsl: LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter>.() -> Unit): LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]

'mockNet' @ [144:30] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'createNotaryNode' @ [144:38] ==> public final fun createNotaryNode(networkMapAddress: SingleMessageRecipient? = ..., legalName: X500Name? = ..., overrideServices: Map<ServiceInfo, KeyPair>? = ..., serviceName: X500Name? = ...): MockNetwork.MockNode defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'DUMMY_NOTARY' @ [144:61] ==> public val DUMMY_NOTARY: Party defined in net.corda.testing[DeserializedPropertyDescriptor]

'name' @ [144:74] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'mockNet' @ [145:29] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'createPartyNode' @ [145:37] ==> public final fun createPartyNode(networkMapAddress: SingleMessageRecipient, legalName: X500Name? = ..., overrideServices: Map<ServiceInfo, KeyPair>? = ...): MockNetwork.MockNode defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'notaryNode' @ [145:53] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'network' @ [145:64] ==> public final lateinit var network: MessagingService defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'myAddress' @ [145:72] ==> public abstract val myAddress: SingleMessageRecipient defined in net.corda.node.services.messaging.MessagingService[DeserializedPropertyDescriptor]

'ALICE' @ [145:83] ==> public val ALICE: Party defined in net.corda.testing[DeserializedPropertyDescriptor]

'name' @ [145:89] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'mockNet' @ [146:27] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'createPartyNode' @ [146:35] ==> public final fun createPartyNode(networkMapAddress: SingleMessageRecipient, legalName: X500Name? = ..., overrideServices: Map<ServiceInfo, KeyPair>? = ...): MockNetwork.MockNode defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'notaryNode' @ [146:51] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'network' @ [146:62] ==> public final lateinit var network: MessagingService defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'myAddress' @ [146:70] ==> public abstract val myAddress: SingleMessageRecipient defined in net.corda.node.services.messaging.MessagingService[DeserializedPropertyDescriptor]

'BOB' @ [146:81] ==> public val BOB: Party defined in net.corda.testing[DeserializedPropertyDescriptor]

'name' @ [146:85] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'mockNet' @ [147:28] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'createPartyNode' @ [147:36] ==> public final fun createPartyNode(networkMapAddress: SingleMessageRecipient, legalName: X500Name? = ..., overrideServices: Map<ServiceInfo, KeyPair>? = ...): MockNetwork.MockNode defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'notaryNode' @ [147:52] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'network' @ [147:63] ==> public final lateinit var network: MessagingService defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'myAddress' @ [147:71] ==> public abstract val myAddress: SingleMessageRecipient defined in net.corda.node.services.messaging.MessagingService[DeserializedPropertyDescriptor]

'BOC' @ [147:82] ==> public val BOC: Party defined in net.corda.testing[DeserializedPropertyDescriptor]

'name' @ [147:86] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'bankNode' @ [148:30] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'info' @ [148:39] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [148:44] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'ref' @ [148:58] ==> public final fun ref(vararg bytes: Byte): PartyAndReference defined in net.corda.core.identity.Party[DeserializedSimpleFunctionDescriptor]

'bankNode' @ [149:28] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'info' @ [149:37] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [149:42] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'ref' @ [149:56] ==> public final fun ref(vararg bytes: Byte): PartyAndReference defined in net.corda.core.identity.Party[DeserializedSimpleFunctionDescriptor]

'aliceNode' @ [151:13] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'disableDBCloseOnStop' @ [151:23] ==> public final fun disableDBCloseOnStop(): Unit defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'bobNode' @ [152:13] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'disableDBCloseOnStop' @ [152:21] ==> public final fun disableDBCloseOnStop(): Unit defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'bobNode' @ [154:30] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'database' @ [154:38] ==> public final lateinit var database: CordaPersistence defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'transaction' @ [154:47] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> Vault<Cash.State>): Vault<Cash.State> defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Vault<State>

'bobNode' @ [155:17] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'services' @ [155:25] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'fillWithSomeTestCash' @ [155:34] ==> public fun ServiceHub.fillWithSomeTestCash(howMuch: Amount<Currency>, issuerServices: ServiceHub = ..., outputNotary: Party = ..., atLeastThisManyStates: Int = ..., atMostThisManyStates: Int = ..., rng: Random = ..., ref: OpaqueBytes = ..., ownedBy: AbstractParty? = ..., issuedBy: PartyAndReference = ...): Vault<Cash.State> defined in net.corda.testing.contracts[DeserializedSimpleFunctionDescriptor]

'DOLLARS' @ [155:60] ==> public val Int.DOLLARS: Amount<Currency> defined in net.corda.finance[DeserializedPropertyDescriptor]

'bankNode' @ [155:69] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'services' @ [155:78] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'notaryNode' @ [155:88] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'info' @ [155:99] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'notaryIdentity' @ [155:104] ==> public final val notaryIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'cashIssuer' @ [156:40] ==> val cashIssuer: PartyAndReference defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'aliceNode' @ [159:35] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'database' @ [159:45] ==> public final lateinit var database: CordaPersistence defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'transaction' @ [159:54] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> List<WireTransaction>): List<WireTransaction> defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> List<WireTransaction>

'fillUpForSeller' @ [160:17] ==> private final fun LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter>.fillUpForSeller(withError: Boolean, issuer: PartyAndReference, owner: AbstractParty, amount: Amount<Issued<Currency>>, attachmentID: SecureHash?, notary: Party): Pair<Vault<ContractState>, List<WireTransaction>> defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'cpIssuer' @ [160:40] ==> val cpIssuer: PartyAndReference defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'aliceNode' @ [160:50] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'info' @ [160:60] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [160:65] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'`issued by`' @ [161:25] ==> public infix fun Amount<Currency>.`issued by`(deposit: PartyAndReference): Amount<Issued<Currency>> defined in net.corda.finance[DeserializedSimpleFunctionDescriptor]

'DOLLARS' @ [161:30] ==> public val Int.DOLLARS: Amount<Currency> defined in net.corda.finance[DeserializedPropertyDescriptor]

'bankNode' @ [161:50] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'info' @ [161:59] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [161:64] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'ref' @ [161:78] ==> public final fun ref(vararg bytes: Byte): PartyAndReference defined in net.corda.core.identity.Party[DeserializedSimpleFunctionDescriptor]

'notaryNode' @ [161:92] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'info' @ [161:103] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'notaryIdentity' @ [161:108] ==> public final val notaryIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'second' @ [161:124] ==> public final val second: List<WireTransaction> defined in kotlin.Pair[DeserializedPropertyDescriptor]

'insertFakeTransactions' @ [164:13] ==> private final fun insertFakeTransactions(wtxToSign: List<WireTransaction>, node: AbstractNode, notaryNode: AbstractNode, vararg extraSigningNodes: AbstractNode): Map<SecureHash, SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'alicesFakePaper' @ [164:36] ==> val alicesFakePaper: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'aliceNode' @ [164:53] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'notaryNode' @ [164:64] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'bankNode' @ [164:76] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'randomUUID' @ [166:35] ==> public open fun randomUUID(): (UUID..UUID?) defined in java.util.UUID[JavaMethodDescriptor]

'bobNode' @ [167:13] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'database' @ [167:21] ==> public final lateinit var database: CordaPersistence defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'transaction' @ [167:30] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> Unit): Unit defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Unit

'cashStates' @ [169:28] ==> val cashStates: Vault<Cash.State> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'states' @ [169:39] ==> public final val states: Iterable<StateAndRef<Cash.State>> defined in net.corda.core.node.services.Vault[DeserializedPropertyDescriptor]

'map' @ [169:46] ==> public inline fun <T, R> Iterable<StateAndRef<Cash.State>>.map(transform: (StateAndRef<Cash.State>) -> StateRef): List<StateRef> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> StateAndRef<State>
    <R> -> StateRef

'it' @ [169:52] ==> value-parameter it: StateAndRef<Cash.State> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'ref' @ [169:55] ==> public final val ref: StateRef defined in net.corda.core.contracts.StateAndRef[DeserializedPropertyDescriptor]

'refs' @ [170:21] ==> val refs: List<StateRef> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>.<anonymous>[LocalVariableDescriptor]

'isNotEmpty' @ [170:26] ==> @InlineOnly public inline fun <T> Collection<StateRef>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> StateRef

'bobNode' @ [171:21] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'services' @ [171:29] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'vaultService' @ [171:38] ==> public abstract val vaultService: VaultService defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'softLockReserve' @ [171:51] ==> public abstract fun softLockReserve(lockId: UUID, stateRefs: NonEmptySet<StateRef>): Unit defined in net.corda.core.node.services.VaultService[DeserializedSimpleFunctionDescriptor]

'cashLockId' @ [171:67] ==> val cashLockId: (UUID..UUID?) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'refs' @ [171:79] ==> val refs: List<StateRef> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>.<anonymous>[LocalVariableDescriptor]

'toNonEmptySet' @ [171:84] ==> public fun <T> Collection<StateRef>.toNonEmptySet(): NonEmptySet<StateRef> defined in net.corda.core.utilities[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> StateRef

'component1' @ [175:18] ==> public final operator fun component1(): CordaFuture<FlowStateMachine<*>> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RunResult[SimpleFunctionDescriptorImpl]

'component2' @ [175:35] ==> public final operator fun component2(): CordaFuture<SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RunResult[SimpleFunctionDescriptorImpl]

'runBuyerAndSeller' @ [175:50] ==> private final fun runBuyerAndSeller(notaryNode: MockNetwork.MockNode, sellerNode: MockNetwork.MockNode, buyerNode: MockNetwork.MockNode, assetToSell: StateAndRef<OwnableState>): TwoPartyTradeFlowTests.RunResult defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'notaryNode' @ [175:68] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'aliceNode' @ [175:80] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'bobNode' @ [175:91] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'outputStateAndRef' @ [176:37] ==> public final inline fun <reified S : ContractState> String.outputStateAndRef(): StateAndRef<OwnableState> defined in net.corda.testing.LedgerDSL[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified S : ContractState> -> OwnableState

'assertEquals' @ [178:13] ==> public fun <@OnlyInputTypes T> assertEquals(expected: Any?, actual: Any?, message: String? = ...): Unit defined in kotlin.test[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <@OnlyInputTypes T> -> Any?

'aliceResult' @ [178:26] ==> val aliceResult: CordaFuture<SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'getOrThrow' @ [178:38] ==> public fun <V> Future<SignedTransaction>.getOrThrow(timeout: Duration? = ...): SignedTransaction defined in net.corda.core.utilities[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <V> -> SignedTransaction

'bobStateMachine' @ [178:52] ==> val bobStateMachine: CordaFuture<FlowStateMachine<*>> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'getOrThrow' @ [178:68] ==> public fun <V> Future<FlowStateMachine<*>>.getOrThrow(timeout: Duration? = ...): FlowStateMachine<*> defined in net.corda.core.utilities[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <V> -> FlowStateMachine<*>

'resultFuture' @ [178:81] ==> public abstract val resultFuture: CordaFuture<out Any?> defined in net.corda.core.internal.FlowStateMachine[DeserializedPropertyDescriptor]

'getOrThrow' @ [178:94] ==> public fun <V> Future<out Any?>.getOrThrow(timeout: Duration? = ...): Any? defined in net.corda.core.utilities[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <V> -> Any?

'aliceNode' @ [180:13] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'stop' @ [180:23] ==> public open fun stop(): Unit defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'bobNode' @ [181:13] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'stop' @ [181:21] ==> public open fun stop(): Unit defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'aliceNode' @ [183:13] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'database' @ [183:23] ==> public final lateinit var database: CordaPersistence defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'transaction' @ [183:32] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> Unit): Unit defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Unit

'assertThat' @ [184:17] ==> @CheckReturnValue public open fun <ELEMENT : (Any..Any?)> assertThat(p0: (MutableList<out (Checkpoint..Checkpoint?)>..List<(Checkpoint..Checkpoint?)>?)): (ListAssert<(Checkpoint..Checkpoint?)>..ListAssert<(Checkpoint..Checkpoint?)>?) defined in org.assertj.core.api.Assertions[JavaMethodDescriptor]
Inferred types:
    <ELEMENT : (Any..Any?)> -> Checkpoint

'aliceNode' @ [184:28] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'checkpointStorage' @ [184:38] ==> public final lateinit var checkpointStorage: CheckpointStorage defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'checkpoints' @ [184:56] ==> internal fun CheckpointStorage.checkpoints(): List<Checkpoint> defined in net.corda.node.services.persistence[SimpleFunctionDescriptorImpl]

'isEmpty' @ [184:71] ==> public open fun isEmpty(): Unit defined in org.assertj.core.api.ListAssert[JavaMethodDescriptor]

'aliceNode' @ [186:13] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'manuallyCloseDB' @ [186:23] ==> public final fun manuallyCloseDB(): Unit defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'bobNode' @ [187:13] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'database' @ [187:21] ==> public final lateinit var database: CordaPersistence defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'transaction' @ [187:30] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> Unit): Unit defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Unit

'assertThat' @ [188:17] ==> @CheckReturnValue public open fun <ELEMENT : (Any..Any?)> assertThat(p0: (MutableList<out (Checkpoint..Checkpoint?)>..List<(Checkpoint..Checkpoint?)>?)): (ListAssert<(Checkpoint..Checkpoint?)>..ListAssert<(Checkpoint..Checkpoint?)>?) defined in org.assertj.core.api.Assertions[JavaMethodDescriptor]
Inferred types:
    <ELEMENT : (Any..Any?)> -> Checkpoint

'bobNode' @ [188:28] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'checkpointStorage' @ [188:36] ==> public final lateinit var checkpointStorage: CheckpointStorage defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'checkpoints' @ [188:54] ==> internal fun CheckpointStorage.checkpoints(): List<Checkpoint> defined in net.corda.node.services.persistence[SimpleFunctionDescriptorImpl]

'isEmpty' @ [188:69] ==> public open fun isEmpty(): Unit defined in org.assertj.core.api.ListAssert[JavaMethodDescriptor]

'bobNode' @ [190:13] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`trade cash for commercial paper fails using soft locking`.<anonymous>[LocalVariableDescriptor]

'manuallyCloseDB' @ [190:21] ==> public final fun manuallyCloseDB(): Unit defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'Test' @ [194:5] ==> public constructor Test(expected: KClass<out (Throwable..Throwable?)> = ..., timeout: Long = ...) defined in org.junit.Test[JavaClassConstructorDescriptor]

'mockNet' @ [196:9] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'MockNetwork' @ [196:19] ==> public constructor MockNetwork(networkSendManuallyPumped: Boolean = ..., threadPerNode: Boolean = ..., servicePeerAllocationStrategy: InMemoryMessagingNetwork.ServicePeerAllocationStrategy = ..., defaultFactory: MockNetwork.Factory<*> = ..., initialiseSerialization: Boolean = ...) defined in net.corda.testing.node.MockNetwork[DeserializedClassConstructorDescriptor]

'ledger' @ [197:9] ==> @JvmOverloads public fun ledger(services: ServiceHub = ..., initialiseSerialization: Boolean = ..., dsl: LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter>.() -> Unit): LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]

'mockNet' @ [198:30] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'createNotaryNode' @ [198:38] ==> public final fun createNotaryNode(networkMapAddress: SingleMessageRecipient? = ..., legalName: X500Name? = ..., overrideServices: Map<ServiceInfo, KeyPair>? = ..., serviceName: X500Name? = ...): MockNetwork.MockNode defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'DUMMY_NOTARY' @ [198:61] ==> public val DUMMY_NOTARY: Party defined in net.corda.testing[DeserializedPropertyDescriptor]

'name' @ [198:74] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'mockNet' @ [199:29] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'createPartyNode' @ [199:37] ==> public final fun createPartyNode(networkMapAddress: SingleMessageRecipient, legalName: X500Name? = ..., overrideServices: Map<ServiceInfo, KeyPair>? = ...): MockNetwork.MockNode defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'notaryNode' @ [199:53] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'network' @ [199:64] ==> public final lateinit var network: MessagingService defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'myAddress' @ [199:72] ==> public abstract val myAddress: SingleMessageRecipient defined in net.corda.node.services.messaging.MessagingService[DeserializedPropertyDescriptor]

'ALICE' @ [199:83] ==> public val ALICE: Party defined in net.corda.testing[DeserializedPropertyDescriptor]

'name' @ [199:89] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'mockNet' @ [200:27] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'createPartyNode' @ [200:35] ==> public final fun createPartyNode(networkMapAddress: SingleMessageRecipient, legalName: X500Name? = ..., overrideServices: Map<ServiceInfo, KeyPair>? = ...): MockNetwork.MockNode defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'notaryNode' @ [200:51] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'network' @ [200:62] ==> public final lateinit var network: MessagingService defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'myAddress' @ [200:70] ==> public abstract val myAddress: SingleMessageRecipient defined in net.corda.node.services.messaging.MessagingService[DeserializedPropertyDescriptor]

'BOB' @ [200:81] ==> public val BOB: Party defined in net.corda.testing[DeserializedPropertyDescriptor]

'name' @ [200:85] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'mockNet' @ [201:28] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'createPartyNode' @ [201:36] ==> public final fun createPartyNode(networkMapAddress: SingleMessageRecipient, legalName: X500Name? = ..., overrideServices: Map<ServiceInfo, KeyPair>? = ...): MockNetwork.MockNode defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'notaryNode' @ [201:52] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'network' @ [201:63] ==> public final lateinit var network: MessagingService defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'myAddress' @ [201:71] ==> public abstract val myAddress: SingleMessageRecipient defined in net.corda.node.services.messaging.MessagingService[DeserializedPropertyDescriptor]

'BOC' @ [201:82] ==> public val BOC: Party defined in net.corda.testing[DeserializedPropertyDescriptor]

'name' @ [201:86] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'bankNode' @ [202:30] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'info' @ [202:39] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [202:44] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'ref' @ [202:58] ==> public final fun ref(vararg bytes: Byte): PartyAndReference defined in net.corda.core.identity.Party[DeserializedSimpleFunctionDescriptor]

'bankNode' @ [203:28] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'info' @ [203:37] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [203:42] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'ref' @ [203:56] ==> public final fun ref(vararg bytes: Byte): PartyAndReference defined in net.corda.core.identity.Party[DeserializedSimpleFunctionDescriptor]

'aliceNode' @ [205:13] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'services' @ [205:23] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'identityService' @ [205:32] ==> public abstract val identityService: IdentityService defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'verifyAndRegisterIdentity' @ [205:48] ==> public abstract fun verifyAndRegisterIdentity(identity: PartyAndCertificate): PartyAndCertificate? defined in net.corda.core.node.services.IdentityService[DeserializedSimpleFunctionDescriptor]

'bobNode' @ [205:74] ==> var bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'info' @ [205:82] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentityAndCert' @ [205:87] ==> public final val legalIdentityAndCert: PartyAndCertificate defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'bobNode' @ [206:13] ==> var bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'services' @ [206:21] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'identityService' @ [206:30] ==> public abstract val identityService: IdentityService defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'verifyAndRegisterIdentity' @ [206:46] ==> public abstract fun verifyAndRegisterIdentity(identity: PartyAndCertificate): PartyAndCertificate? defined in net.corda.core.node.services.IdentityService[DeserializedSimpleFunctionDescriptor]

'aliceNode' @ [206:72] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'info' @ [206:82] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentityAndCert' @ [206:87] ==> public final val legalIdentityAndCert: PartyAndCertificate defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'aliceNode' @ [207:13] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'disableDBCloseOnStop' @ [207:23] ==> public final fun disableDBCloseOnStop(): Unit defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'bobNode' @ [208:13] ==> var bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'disableDBCloseOnStop' @ [208:21] ==> public final fun disableDBCloseOnStop(): Unit defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'bobNode' @ [210:27] ==> var bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'network' @ [210:35] ==> public final lateinit var network: MessagingService defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'myAddress' @ [210:43] ==> public abstract val myAddress: SingleMessageRecipient defined in net.corda.node.services.messaging.MessagingService[DeserializedPropertyDescriptor]

'notaryNode' @ [211:37] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'network' @ [211:48] ==> public final lateinit var network: MessagingService defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'myAddress' @ [211:56] ==> public abstract val myAddress: SingleMessageRecipient defined in net.corda.node.services.messaging.MessagingService[DeserializedPropertyDescriptor]

'mockNet' @ [213:13] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'runNetwork' @ [213:21] ==> @JvmOverloads public final fun runNetwork(rounds: Int = ...): Unit defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'bobNode' @ [215:13] ==> var bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'database' @ [215:21] ==> public final lateinit var database: CordaPersistence defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'transaction' @ [215:30] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> Vault<Cash.State>): Vault<Cash.State> defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Vault<State>

'bobNode' @ [216:17] ==> var bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'services' @ [216:25] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'fillWithSomeTestCash' @ [216:34] ==> public fun ServiceHub.fillWithSomeTestCash(howMuch: Amount<Currency>, issuerServices: ServiceHub = ..., outputNotary: Party = ..., atLeastThisManyStates: Int = ..., atMostThisManyStates: Int = ..., rng: Random = ..., ref: OpaqueBytes = ..., ownedBy: AbstractParty? = ..., issuedBy: PartyAndReference = ...): Vault<Cash.State> defined in net.corda.testing.contracts[DeserializedSimpleFunctionDescriptor]

'DOLLARS' @ [216:60] ==> public val Int.DOLLARS: Amount<Currency> defined in net.corda.finance[DeserializedPropertyDescriptor]

'bankNode' @ [216:69] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'services' @ [216:78] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'notaryNode' @ [216:103] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'info' @ [216:114] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'notaryIdentity' @ [216:119] ==> public final val notaryIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'cashIssuer' @ [217:36] ==> val cashIssuer: PartyAndReference defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'aliceNode' @ [219:35] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'database' @ [219:45] ==> public final lateinit var database: CordaPersistence defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'transaction' @ [219:54] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> List<WireTransaction>): List<WireTransaction> defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> List<WireTransaction>

'fillUpForSeller' @ [220:17] ==> private final fun LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter>.fillUpForSeller(withError: Boolean, issuer: PartyAndReference, owner: AbstractParty, amount: Amount<Issued<Currency>>, attachmentID: SecureHash?, notary: Party): Pair<Vault<ContractState>, List<WireTransaction>> defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'cpIssuer' @ [220:40] ==> val cpIssuer: PartyAndReference defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'aliceNode' @ [220:50] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'info' @ [220:60] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [220:65] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'`issued by`' @ [221:25] ==> public infix fun Amount<Currency>.`issued by`(deposit: PartyAndReference): Amount<Issued<Currency>> defined in net.corda.finance[DeserializedSimpleFunctionDescriptor]

'DOLLARS' @ [221:30] ==> public val Int.DOLLARS: Amount<Currency> defined in net.corda.finance[DeserializedPropertyDescriptor]

'bankNode' @ [221:50] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'info' @ [221:59] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [221:64] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'ref' @ [221:78] ==> public final fun ref(vararg bytes: Byte): PartyAndReference defined in net.corda.core.identity.Party[DeserializedSimpleFunctionDescriptor]

'notaryNode' @ [221:92] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'info' @ [221:103] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'notaryIdentity' @ [221:108] ==> public final val notaryIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'second' @ [221:124] ==> public final val second: List<WireTransaction> defined in kotlin.Pair[DeserializedPropertyDescriptor]

'insertFakeTransactions' @ [223:13] ==> private final fun insertFakeTransactions(wtxToSign: List<WireTransaction>, node: AbstractNode, notaryNode: AbstractNode, vararg extraSigningNodes: AbstractNode): Map<SecureHash, SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'alicesFakePaper' @ [223:36] ==> val alicesFakePaper: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'aliceNode' @ [223:53] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'notaryNode' @ [223:64] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'bankNode' @ [223:76] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'runBuyerAndSeller' @ [224:31] ==> private final fun runBuyerAndSeller(notaryNode: MockNetwork.MockNode, sellerNode: MockNetwork.MockNode, buyerNode: MockNetwork.MockNode, assetToSell: StateAndRef<OwnableState>): TwoPartyTradeFlowTests.RunResult defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'notaryNode' @ [224:49] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'aliceNode' @ [224:61] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'bobNode' @ [224:72] ==> var bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'outputStateAndRef' @ [224:97] ==> public final inline fun <reified S : ContractState> String.outputStateAndRef(): StateAndRef<OwnableState> defined in net.corda.testing.LedgerDSL[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified S : ContractState> -> OwnableState

'sellerResult' @ [224:118] ==> public final val sellerResult: CordaFuture<SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RunResult[PropertyDescriptorImpl]

'bobNode' @ [228:13] ==> var bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'pumpReceive' @ [228:21] ==> public final fun pumpReceive(block: Boolean = ...): InMemoryMessagingNetwork.MessageTransfer? defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'aliceNode' @ [231:13] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'pumpReceive' @ [231:23] ==> public final fun pumpReceive(block: Boolean = ...): InMemoryMessagingNetwork.MessageTransfer? defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'bobNode' @ [232:13] ==> var bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'pumpReceive' @ [232:21] ==> public final fun pumpReceive(block: Boolean = ...): InMemoryMessagingNetwork.MessageTransfer? defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'aliceNode' @ [233:13] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'pumpReceive' @ [233:23] ==> public final fun pumpReceive(block: Boolean = ...): InMemoryMessagingNetwork.MessageTransfer? defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'bobNode' @ [234:13] ==> var bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'pumpReceive' @ [234:21] ==> public final fun pumpReceive(block: Boolean = ...): InMemoryMessagingNetwork.MessageTransfer? defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'aliceNode' @ [235:13] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'pumpReceive' @ [235:23] ==> public final fun pumpReceive(block: Boolean = ...): InMemoryMessagingNetwork.MessageTransfer? defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'bobNode' @ [236:13] ==> var bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'pumpReceive' @ [236:21] ==> public final fun pumpReceive(block: Boolean = ...): InMemoryMessagingNetwork.MessageTransfer? defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'bobNode' @ [239:13] ==> var bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'database' @ [239:21] ==> public final lateinit var database: CordaPersistence defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'transaction' @ [239:30] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> (ListAssert<(Checkpoint..Checkpoint?)>..ListAssert<(Checkpoint..Checkpoint?)>?)): (ListAssert<(Checkpoint..Checkpoint?)>..ListAssert<(Checkpoint..Checkpoint?)>?) defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.assertj.core.api.ListAssert<(net.corda.node.services.api.Checkpoint..net.corda.node.services.api.Checkpoint?)>..org.assertj.core.api.ListAssert<(net.corda.node.services.api.Checkpoint..net.corda.node.services.api.Checkpoint?)>?)

'assertThat' @ [240:17] ==> @CheckReturnValue public open fun <ELEMENT : (Any..Any?)> assertThat(p0: (MutableList<out (Checkpoint..Checkpoint?)>..List<(Checkpoint..Checkpoint?)>?)): (ListAssert<(Checkpoint..Checkpoint?)>..ListAssert<(Checkpoint..Checkpoint?)>?) defined in org.assertj.core.api.Assertions[JavaMethodDescriptor]
Inferred types:
    <ELEMENT : (Any..Any?)> -> Checkpoint

'bobNode' @ [240:28] ==> var bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'checkpointStorage' @ [240:36] ==> public final lateinit var checkpointStorage: CheckpointStorage defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'checkpoints' @ [240:54] ==> internal fun CheckpointStorage.checkpoints(): List<Checkpoint> defined in net.corda.node.services.persistence[SimpleFunctionDescriptorImpl]

'hasSize' @ [240:69] ==> public open fun hasSize(p0: Int): (ListAssert<(Checkpoint..Checkpoint?)>..ListAssert<(Checkpoint..Checkpoint?)>?) defined in org.assertj.core.api.ListAssert[JavaMethodDescriptor]

'bobNode' @ [243:27] ==> var bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'services' @ [243:35] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'validatedTransactions' @ [243:44] ==> public abstract val validatedTransactions: WritableTransactionStorage defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'bobNode' @ [244:46] ==> var bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'database' @ [244:54] ==> public final lateinit var database: CordaPersistence defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'transaction' @ [244:63] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> Iterable<SignedTransaction>): Iterable<SignedTransaction> defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Iterable<SignedTransaction>

'storage' @ [245:18] ==> val storage: WritableTransactionStorage defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'transactions' @ [245:51] ==> public final val transactions: Iterable<SignedTransaction> defined in net.corda.node.services.persistence.DBTransactionStorage[DeserializedPropertyDescriptor]

'assertThat' @ [247:13] ==> @CheckReturnValue public open fun <ELEMENT : (Any..Any?)> assertThat(p0: (MutableIterable<(SignedTransaction..SignedTransaction?)>..Iterable<(SignedTransaction..SignedTransaction?)>?)): (IterableAssert<(SignedTransaction..SignedTransaction?)>..IterableAssert<(SignedTransaction..SignedTransaction?)>?) defined in org.assertj.core.api.Assertions[JavaMethodDescriptor]
Inferred types:
    <ELEMENT : (Any..Any?)> -> SignedTransaction

'bobTransactionsBeforeCrash' @ [247:24] ==> val bobTransactionsBeforeCrash: Iterable<SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'isNotEmpty' @ [247:52] ==> public final val <ELEMENT : (Any..Any?)> IterableAssert<(SignedTransaction..SignedTransaction?)>.isNotEmpty: (IterableAssert<(SignedTransaction..SignedTransaction?)>..IterableAssert<(SignedTransaction..SignedTransaction?)>?)[MyPropertyDescriptor]
Inferred types:
    <ELEMENT : (Any..Any?)> -> (net.corda.core.transactions.SignedTransaction..net.corda.core.transactions.SignedTransaction?)

'bobNode' @ [250:13] ==> var bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'stop' @ [250:21] ==> public open fun stop(): Unit defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'assertThat' @ [254:13] ==> @CheckReturnValue public open fun <T : (Any..Any?)> assertThat(p0: (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)): (AbstractObjectAssert<*, (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>..AbstractObjectAssert<*, (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>?) defined in org.assertj.core.api.Assertions[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> MessageTransfer

'aliceNode' @ [254:24] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'pumpReceive' @ [254:34] ==> public final fun pumpReceive(block: Boolean = ...): InMemoryMessagingNetwork.MessageTransfer? defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'isNotNull' @ [254:49] ==> public open fun isNotNull(): (AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>..AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>..AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>..AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>..AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>..AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>..AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>..AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>..AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>..AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>..AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>..AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>..AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>..AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>..AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>..AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>?), (InMemoryMessagingNetwork.MessageTransfer..InMemoryMessagingNetwork.MessageTransfer?)>?) defined in org.assertj.core.api.AbstractObjectAssert[JavaMethodDescriptor]

'bobNode' @ [258:13] ==> var bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'mockNet' @ [258:23] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'createNode' @ [258:31] ==> public final fun <N : MockNetwork.MockNode> createNode(networkMapAddress: SingleMessageRecipient? = ..., forcedID: Int? = ..., nodeFactory: MockNetwork.Factory<MockNetwork.MockNode>, start: Boolean = ..., legalName: X500Name? = ..., overrideServices: Map<ServiceInfo, KeyPair>? = ..., entropyRoot: BigInteger = ..., vararg advertisedServices: ServiceInfo, configOverrides: (NodeConfiguration) -> Any? = ...): MockNetwork.MockNode defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <N : MockNetwork.MockNode> -> MockNode

'networkMapAddress' @ [258:42] ==> val networkMapAddress: SingleMessageRecipient defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'bobAddr' @ [258:61] ==> val bobAddr: InMemoryMessagingNetwork.PeerHandle defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'id' @ [258:69] ==> public final val id: Int defined in net.corda.testing.node.InMemoryMessagingNetwork.PeerHandle[DeserializedPropertyDescriptor]

'MockNode' @ [262:40] ==> public constructor MockNode(config: NodeConfiguration, mockNet: MockNetwork, networkMapAddress: SingleMessageRecipient?, advertisedServices: Set<ServiceInfo>, id: Int, overrideServices: Map<ServiceInfo, KeyPair>?, entropyRoot: BigInteger = ...) defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedClassConstructorDescriptor]

'config' @ [262:49] ==> value-parameter config: NodeConfiguration defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>.<no name provided>.create[ValueParameterDescriptorImpl]

'network' @ [262:57] ==> value-parameter network: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>.<no name provided>.create[ValueParameterDescriptorImpl]

'networkMapAddr' @ [262:66] ==> value-parameter networkMapAddr: SingleMessageRecipient? defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>.<no name provided>.create[ValueParameterDescriptorImpl]

'advertisedServices' @ [262:82] ==> value-parameter advertisedServices: Set<ServiceInfo> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>.<no name provided>.create[ValueParameterDescriptorImpl]

'bobAddr' @ [262:102] ==> val bobAddr: InMemoryMessagingNetwork.PeerHandle defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'id' @ [262:110] ==> public final val id: Int defined in net.corda.testing.node.InMemoryMessagingNetwork.PeerHandle[DeserializedPropertyDescriptor]

'overrideServices' @ [262:114] ==> value-parameter overrideServices: Map<ServiceInfo, KeyPair>? defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>.<no name provided>.create[ValueParameterDescriptorImpl]

'entropyRoot' @ [262:132] ==> value-parameter entropyRoot: BigInteger defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>.<no name provided>.create[ValueParameterDescriptorImpl]

'BOB' @ [264:22] ==> public val BOB: Party defined in net.corda.testing[DeserializedPropertyDescriptor]

'name' @ [264:26] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'bobNode' @ [267:29] ==> var bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'smm' @ [267:37] ==> public final lateinit var smm: StateMachineManager defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'findStateMachines' @ [267:41] ==> public final fun <P : FlowLogic<SignedTransaction>, T> findStateMachines(flowClass: Class<TwoPartyTradeFlowTests.BuyerAcceptor>): List<Pair<TwoPartyTradeFlowTests.BuyerAcceptor, CordaFuture<SignedTransaction>>> defined in net.corda.node.services.statemachine.StateMachineManager[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <P : FlowLogic<T>> -> BuyerAcceptor
    <T> -> SignedTransaction

'BuyerAcceptor' @ [267:59] ==> public constructor BuyerAcceptor(seller: Party) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.BuyerAcceptor[ClassConstructorDescriptorImpl]

'java' @ [267:80] ==> public val <T> KClass<TwoPartyTradeFlowTests.BuyerAcceptor>.java: Class<TwoPartyTradeFlowTests.BuyerAcceptor> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> BuyerAcceptor

'single' @ [267:86] ==> public fun <T> List<Pair<TwoPartyTradeFlowTests.BuyerAcceptor, CordaFuture<SignedTransaction>>>.single(): Pair<TwoPartyTradeFlowTests.BuyerAcceptor, CordaFuture<SignedTransaction>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<BuyerAcceptor, CordaFuture<SignedTransaction>>

'second' @ [267:95] ==> public final val second: CordaFuture<SignedTransaction> defined in kotlin.Pair[DeserializedPropertyDescriptor]

'mockNet' @ [270:13] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'runNetwork' @ [270:21] ==> @JvmOverloads public final fun runNetwork(rounds: Int = ...): Unit defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'assertThat' @ [273:13] ==> @CheckReturnValue public open fun <T : (Any..Any?)> assertThat(p0: (SignedTransaction..SignedTransaction?)): (AbstractObjectAssert<*, (SignedTransaction..SignedTransaction?)>..AbstractObjectAssert<*, (SignedTransaction..SignedTransaction?)>?) defined in org.assertj.core.api.Assertions[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> SignedTransaction

'bobFuture' @ [273:24] ==> val bobFuture: CordaFuture<SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'getOrThrow' @ [273:34] ==> public fun <V> Future<SignedTransaction>.getOrThrow(timeout: Duration? = ...): SignedTransaction defined in net.corda.core.utilities[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <V> -> SignedTransaction

'isEqualTo' @ [273:48] ==> public open fun isEqualTo(p0: (Any..Any?)): (AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (SignedTransaction..SignedTransaction?)>..AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (SignedTransaction..SignedTransaction?)>?), (SignedTransaction..SignedTransaction?)>..AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (SignedTransaction..SignedTransaction?)>..AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (SignedTransaction..SignedTransaction?)>?), (SignedTransaction..SignedTransaction?)>?), (SignedTransaction..SignedTransaction?)>..AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (SignedTransaction..SignedTransaction?)>..AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (SignedTransaction..SignedTransaction?)>?), (SignedTransaction..SignedTransaction?)>..AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (SignedTransaction..SignedTransaction?)>..AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (SignedTransaction..SignedTransaction?)>?), (SignedTransaction..SignedTransaction?)>?), (SignedTransaction..SignedTransaction?)>?), (SignedTransaction..SignedTransaction?)>..AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (SignedTransaction..SignedTransaction?)>..AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (SignedTransaction..SignedTransaction?)>?), (SignedTransaction..SignedTransaction?)>..AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (SignedTransaction..SignedTransaction?)>..AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (SignedTransaction..SignedTransaction?)>?), (SignedTransaction..SignedTransaction?)>?), (SignedTransaction..SignedTransaction?)>..AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (SignedTransaction..SignedTransaction?)>..AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (SignedTransaction..SignedTransaction?)>?), (SignedTransaction..SignedTransaction?)>..AbstractObjectAssert<out (AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (SignedTransaction..SignedTransaction?)>..AbstractObjectAssert<out (AbstractObjectAssert<out Any?, out Any?>..AbstractObjectAssert<out Any?, out Any?>?), (SignedTransaction..SignedTransaction?)>?), (SignedTransaction..SignedTransaction?)>?), (SignedTransaction..SignedTransaction?)>?), (SignedTransaction..SignedTransaction?)>?) defined in org.assertj.core.api.AbstractObjectAssert[JavaMethodDescriptor]

'aliceFuture' @ [273:58] ==> val aliceFuture: CordaFuture<SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'getOrThrow' @ [273:70] ==> public fun <V> Future<SignedTransaction>.getOrThrow(timeout: Duration? = ...): SignedTransaction defined in net.corda.core.utilities[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <V> -> SignedTransaction

'assertThat' @ [275:13] ==> @CheckReturnValue public open fun <ELEMENT : (Any..Any?)> assertThat(p0: (MutableList<out (Pair<TwoPartyTradeFlow.Buyer, CordaFuture<SignedTransaction>>..Pair<TwoPartyTradeFlow.Buyer, CordaFuture<SignedTransaction>>?)>..List<(Pair<TwoPartyTradeFlow.Buyer, CordaFuture<SignedTransaction>>..Pair<TwoPartyTradeFlow.Buyer, CordaFuture<SignedTransaction>>?)>?)): (ListAssert<(Pair<TwoPartyTradeFlow.Buyer, CordaFuture<SignedTransaction>>..Pair<TwoPartyTradeFlow.Buyer, CordaFuture<SignedTransaction>>?)>..ListAssert<(Pair<TwoPartyTradeFlow.Buyer, CordaFuture<SignedTransaction>>..Pair<TwoPartyTradeFlow.Buyer, CordaFuture<SignedTransaction>>?)>?) defined in org.assertj.core.api.Assertions[JavaMethodDescriptor]
Inferred types:
    <ELEMENT : (Any..Any?)> -> Pair<Buyer, CordaFuture<SignedTransaction>>

'bobNode' @ [275:24] ==> var bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'smm' @ [275:32] ==> public final lateinit var smm: StateMachineManager defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'findStateMachines' @ [275:36] ==> public final fun <P : FlowLogic<SignedTransaction>, T> findStateMachines(flowClass: Class<TwoPartyTradeFlow.Buyer>): List<Pair<TwoPartyTradeFlow.Buyer, CordaFuture<SignedTransaction>>> defined in net.corda.node.services.statemachine.StateMachineManager[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <P : FlowLogic<T>> -> Buyer
    <T> -> SignedTransaction

'Buyer' @ [275:54] ==> public constructor Buyer(otherParty: Party, notary: Party, acceptablePrice: Amount<Currency>, typeToBuy: Class<out OwnableState>) defined in net.corda.finance.flows.TwoPartyTradeFlow.Buyer[DeserializedClassConstructorDescriptor]

'java' @ [275:67] ==> public val <T> KClass<TwoPartyTradeFlow.Buyer>.java: Class<TwoPartyTradeFlow.Buyer> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> Buyer

'isEmpty' @ [275:74] ==> public open fun isEmpty(): Unit defined in org.assertj.core.api.ListAssert[JavaMethodDescriptor]

'bobNode' @ [276:13] ==> var bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'database' @ [276:21] ==> public final lateinit var database: CordaPersistence defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'transaction' @ [276:30] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> Unit): Unit defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Unit

'assertThat' @ [277:17] ==> @CheckReturnValue public open fun <ELEMENT : (Any..Any?)> assertThat(p0: (MutableList<out (Checkpoint..Checkpoint?)>..List<(Checkpoint..Checkpoint?)>?)): (ListAssert<(Checkpoint..Checkpoint?)>..ListAssert<(Checkpoint..Checkpoint?)>?) defined in org.assertj.core.api.Assertions[JavaMethodDescriptor]
Inferred types:
    <ELEMENT : (Any..Any?)> -> Checkpoint

'bobNode' @ [277:28] ==> var bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'checkpointStorage' @ [277:36] ==> public final lateinit var checkpointStorage: CheckpointStorage defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'checkpoints' @ [277:54] ==> internal fun CheckpointStorage.checkpoints(): List<Checkpoint> defined in net.corda.node.services.persistence[SimpleFunctionDescriptorImpl]

'isEmpty' @ [277:69] ==> public open fun isEmpty(): Unit defined in org.assertj.core.api.ListAssert[JavaMethodDescriptor]

'aliceNode' @ [279:13] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'database' @ [279:23] ==> public final lateinit var database: CordaPersistence defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'transaction' @ [279:32] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> Unit): Unit defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Unit

'assertThat' @ [280:17] ==> @CheckReturnValue public open fun <ELEMENT : (Any..Any?)> assertThat(p0: (MutableList<out (Checkpoint..Checkpoint?)>..List<(Checkpoint..Checkpoint?)>?)): (ListAssert<(Checkpoint..Checkpoint?)>..ListAssert<(Checkpoint..Checkpoint?)>?) defined in org.assertj.core.api.Assertions[JavaMethodDescriptor]
Inferred types:
    <ELEMENT : (Any..Any?)> -> Checkpoint

'aliceNode' @ [280:28] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'checkpointStorage' @ [280:38] ==> public final lateinit var checkpointStorage: CheckpointStorage defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'checkpoints' @ [280:56] ==> internal fun CheckpointStorage.checkpoints(): List<Checkpoint> defined in net.corda.node.services.persistence[SimpleFunctionDescriptorImpl]

'isEmpty' @ [280:71] ==> public open fun isEmpty(): Unit defined in org.assertj.core.api.ListAssert[JavaMethodDescriptor]

'bobNode' @ [283:13] ==> var bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'database' @ [283:21] ==> public final lateinit var database: CordaPersistence defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'transaction' @ [283:30] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> (ListAssert<(SignedTransaction..SignedTransaction?)>..ListAssert<(SignedTransaction..SignedTransaction?)>?)): (ListAssert<(SignedTransaction..SignedTransaction?)>..ListAssert<(SignedTransaction..SignedTransaction?)>?) defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (org.assertj.core.api.ListAssert<(net.corda.core.transactions.SignedTransaction..net.corda.core.transactions.SignedTransaction?)>..org.assertj.core.api.ListAssert<(net.corda.core.transactions.SignedTransaction..net.corda.core.transactions.SignedTransaction?)>?)

'bobTransactionsBeforeCrash' @ [284:47] ==> val bobTransactionsBeforeCrash: Iterable<SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'filter' @ [284:74] ==> public inline fun <T> Iterable<SignedTransaction>.filter(predicate: (SignedTransaction) -> Boolean): List<SignedTransaction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SignedTransaction

'bobNode' @ [285:21] ==> var bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'services' @ [285:29] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'validatedTransactions' @ [285:38] ==> public abstract val validatedTransactions: WritableTransactionStorage defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'getTransaction' @ [285:60] ==> public abstract fun getTransaction(id: SecureHash): SignedTransaction? defined in net.corda.node.services.api.WritableTransactionStorage[DeserializedSimpleFunctionDescriptor]

'it' @ [285:75] ==> value-parameter it: SignedTransaction defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'id' @ [285:78] ==> public open val id: SecureHash defined in net.corda.core.transactions.SignedTransaction[DeserializedPropertyDescriptor]

'assertThat' @ [287:17] ==> @CheckReturnValue public open fun <ELEMENT : (Any..Any?)> assertThat(p0: (MutableList<out (SignedTransaction..SignedTransaction?)>..List<(SignedTransaction..SignedTransaction?)>?)): (ListAssert<(SignedTransaction..SignedTransaction?)>..ListAssert<(SignedTransaction..SignedTransaction?)>?) defined in org.assertj.core.api.Assertions[JavaMethodDescriptor]
Inferred types:
    <ELEMENT : (Any..Any?)> -> SignedTransaction

'restoredBobTransactions' @ [287:28] ==> val restoredBobTransactions: List<SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>.<anonymous>[LocalVariableDescriptor]

'containsAll' @ [287:53] ==> public open fun containsAll(p0: (MutableIterable<(SignedTransaction..SignedTransaction?)>..Iterable<(SignedTransaction..SignedTransaction?)>?)): (ListAssert<(SignedTransaction..SignedTransaction?)>..ListAssert<(SignedTransaction..SignedTransaction?)>?) defined in org.assertj.core.api.ListAssert[JavaMethodDescriptor]

'bobTransactionsBeforeCrash' @ [287:65] ==> val bobTransactionsBeforeCrash: Iterable<SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'aliceNode' @ [290:13] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'manuallyCloseDB' @ [290:23] ==> public final fun manuallyCloseDB(): Unit defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'bobNode' @ [291:13] ==> var bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`shutdown and restore`.<anonymous>[LocalVariableDescriptor]

'manuallyCloseDB' @ [291:21] ==> public final fun manuallyCloseDB(): Unit defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'mockNet' @ [301:16] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'createNode' @ [301:24] ==> public final fun <N : MockNetwork.MockNode> createNode(networkMapAddress: SingleMessageRecipient? = ..., forcedID: Int? = ..., nodeFactory: MockNetwork.Factory<MockNetwork.MockNode>, start: Boolean = ..., legalName: X500Name? = ..., overrideServices: Map<ServiceInfo, KeyPair>? = ..., entropyRoot: BigInteger = ..., vararg advertisedServices: ServiceInfo, configOverrides: (NodeConfiguration) -> Any? = ...): MockNetwork.MockNode defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <N : MockNetwork.MockNode> -> MockNode

'networkMapAddress' @ [301:35] ==> value-parameter networkMapAddress: SingleMessageRecipient? defined in net.corda.node.messaging.TwoPartyTradeFlowTests.makeNodeWithTracking[ValueParameterDescriptorImpl]

'MockNetwork.MockNode' @ [308:33] ==> public constructor MockNode(config: NodeConfiguration, mockNet: MockNetwork, networkMapAddress: SingleMessageRecipient?, advertisedServices: Set<ServiceInfo>, id: Int, overrideServices: Map<ServiceInfo, KeyPair>?, entropyRoot: BigInteger = ...) defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedClassConstructorDescriptor]

'config' @ [308:54] ==> value-parameter config: NodeConfiguration defined in net.corda.node.messaging.TwoPartyTradeFlowTests.makeNodeWithTracking.<no name provided>.create[ValueParameterDescriptorImpl]

'network' @ [308:62] ==> value-parameter network: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests.makeNodeWithTracking.<no name provided>.create[ValueParameterDescriptorImpl]

'networkMapAddr' @ [308:71] ==> value-parameter networkMapAddr: SingleMessageRecipient? defined in net.corda.node.messaging.TwoPartyTradeFlowTests.makeNodeWithTracking.<no name provided>.create[ValueParameterDescriptorImpl]

'advertisedServices' @ [308:87] ==> value-parameter advertisedServices: Set<ServiceInfo> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.makeNodeWithTracking.<no name provided>.create[ValueParameterDescriptorImpl]

'id' @ [308:107] ==> value-parameter id: Int defined in net.corda.node.messaging.TwoPartyTradeFlowTests.makeNodeWithTracking.<no name provided>.create[ValueParameterDescriptorImpl]

'overrideServices' @ [308:111] ==> value-parameter overrideServices: Map<ServiceInfo, KeyPair>? defined in net.corda.node.messaging.TwoPartyTradeFlowTests.makeNodeWithTracking.<no name provided>.create[ValueParameterDescriptorImpl]

'entropyRoot' @ [308:129] ==> value-parameter entropyRoot: BigInteger defined in net.corda.node.messaging.TwoPartyTradeFlowTests.makeNodeWithTracking.<no name provided>.create[ValueParameterDescriptorImpl]

'RecordingTransactionStorage' @ [311:32] ==> public constructor RecordingTransactionStorage(database: CordaPersistence, delegate: WritableTransactionStorage) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RecordingTransactionStorage[ClassConstructorDescriptorImpl]

'database' @ [311:60] ==> public final lateinit var database: CordaPersistence defined in net.corda.node.messaging.TwoPartyTradeFlowTests.makeNodeWithTracking.<no name provided>.create.<no name provided>[DeserializedPropertyDescriptor]

'super' @ [311:70] ==> <this> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.makeNodeWithTracking.<no name provided>.create.<no name provided>[LazyClassReceiverParameterDescriptor]

'makeTransactionStorage' @ [311:76] ==> protected open fun makeTransactionStorage(): WritableTransactionStorage defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]

'name' @ [315:24] ==> value-parameter name: X500Name defined in net.corda.node.messaging.TwoPartyTradeFlowTests.makeNodeWithTracking[ValueParameterDescriptorImpl]

'Test' @ [318:5] ==> public constructor Test(expected: KClass<out (Throwable..Throwable?)> = ..., timeout: Long = ...) defined in org.junit.Test[JavaClassConstructorDescriptor]

'mockNet' @ [320:9] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'MockNetwork' @ [320:19] ==> public constructor MockNetwork(networkSendManuallyPumped: Boolean = ..., threadPerNode: Boolean = ..., servicePeerAllocationStrategy: InMemoryMessagingNetwork.ServicePeerAllocationStrategy = ..., defaultFactory: MockNetwork.Factory<*> = ..., initialiseSerialization: Boolean = ...) defined in net.corda.testing.node.MockNetwork[DeserializedClassConstructorDescriptor]

'mockNet' @ [322:26] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'createNotaryNode' @ [322:34] ==> public final fun createNotaryNode(networkMapAddress: SingleMessageRecipient? = ..., legalName: X500Name? = ..., overrideServices: Map<ServiceInfo, KeyPair>? = ..., serviceName: X500Name? = ...): MockNetwork.MockNode defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'DUMMY_NOTARY' @ [322:57] ==> public val DUMMY_NOTARY: Party defined in net.corda.testing[DeserializedPropertyDescriptor]

'name' @ [322:70] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'makeNodeWithTracking' @ [323:25] ==> private final fun makeNodeWithTracking(networkMapAddress: SingleMessageRecipient?, name: X500Name): MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'notaryNode' @ [323:46] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'network' @ [323:57] ==> public final lateinit var network: MessagingService defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'myAddress' @ [323:65] ==> public abstract val myAddress: SingleMessageRecipient defined in net.corda.node.services.messaging.MessagingService[DeserializedPropertyDescriptor]

'ALICE' @ [323:76] ==> public val ALICE: Party defined in net.corda.testing[DeserializedPropertyDescriptor]

'name' @ [323:82] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'makeNodeWithTracking' @ [324:23] ==> private final fun makeNodeWithTracking(networkMapAddress: SingleMessageRecipient?, name: X500Name): MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'notaryNode' @ [324:44] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'network' @ [324:55] ==> public final lateinit var network: MessagingService defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'myAddress' @ [324:63] ==> public abstract val myAddress: SingleMessageRecipient defined in net.corda.node.services.messaging.MessagingService[DeserializedPropertyDescriptor]

'BOB' @ [324:74] ==> public val BOB: Party defined in net.corda.testing[DeserializedPropertyDescriptor]

'name' @ [324:78] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'makeNodeWithTracking' @ [325:24] ==> private final fun makeNodeWithTracking(networkMapAddress: SingleMessageRecipient?, name: X500Name): MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'notaryNode' @ [325:45] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'network' @ [325:56] ==> public final lateinit var network: MessagingService defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'myAddress' @ [325:64] ==> public abstract val myAddress: SingleMessageRecipient defined in net.corda.node.services.messaging.MessagingService[DeserializedPropertyDescriptor]

'BOC' @ [325:75] ==> public val BOC: Party defined in net.corda.testing[DeserializedPropertyDescriptor]

'name' @ [325:79] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'bankNode' @ [326:22] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'info' @ [326:31] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [326:36] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'ref' @ [326:50] ==> public final fun ref(vararg bytes: Byte): PartyAndReference defined in net.corda.core.identity.Party[DeserializedSimpleFunctionDescriptor]

'listOf' @ [328:24] ==> public fun <T> listOf(vararg elements: MockNetwork.MockNode): List<MockNetwork.MockNode> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> MockNode

'notaryNode' @ [328:31] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'aliceNode' @ [328:43] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'bobNode' @ [328:54] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'bankNode' @ [328:63] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'allNodes' @ [329:9] ==> val allNodes: List<MockNetwork.MockNode> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'forEach' @ [329:18] ==> @HidesMembers public inline fun <T> Iterable<MockNetwork.MockNode>.forEach(action: (MockNetwork.MockNode) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> MockNode

'allNodes' @ [330:13] ==> val allNodes: List<MockNetwork.MockNode> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'map' @ [330:22] ==> public inline fun <T, R> Iterable<MockNetwork.MockNode>.map(transform: (MockNetwork.MockNode) -> PartyAndCertificate): List<PartyAndCertificate> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> MockNode
    <R> -> PartyAndCertificate

'it' @ [330:28] ==> value-parameter it: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'services' @ [330:31] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'myInfo' @ [330:40] ==> public abstract val myInfo: NodeInfo defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'legalIdentityAndCert' @ [330:47] ==> public final val legalIdentityAndCert: PartyAndCertificate defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'forEach' @ [330:70] ==> @HidesMembers public inline fun <T> Iterable<PartyAndCertificate>.forEach(action: (PartyAndCertificate) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PartyAndCertificate

'node' @ [330:92] ==> value-parameter node: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[ValueParameterDescriptorImpl]

'services' @ [330:97] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'identityService' @ [330:106] ==> public abstract val identityService: IdentityService defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'verifyAndRegisterIdentity' @ [330:122] ==> public abstract fun verifyAndRegisterIdentity(identity: PartyAndCertificate): PartyAndCertificate? defined in net.corda.core.node.services.IdentityService[DeserializedSimpleFunctionDescriptor]

'identity' @ [330:148] ==> value-parameter identity: PartyAndCertificate defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'ledger' @ [333:9] ==> @JvmOverloads public fun ledger(services: ServiceHub = ..., initialiseSerialization: Boolean = ..., dsl: LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter>.() -> Unit): LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]

'aliceNode' @ [333:16] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'services' @ [333:26] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'ByteArrayOutputStream' @ [336:26] ==> public constructor ByteArrayOutputStream() defined in java.io.ByteArrayOutputStream[JavaClassConstructorDescriptor]

'JarOutputStream' @ [337:13] ==> public constructor JarOutputStream(p0: (OutputStream..OutputStream?)) defined in java.util.jar.JarOutputStream[JavaClassConstructorDescriptor]

'stream' @ [337:29] ==> val stream: ByteArrayOutputStream defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'use' @ [337:37] ==> @InlineOnly public inline fun <T : Closeable?, R> JarOutputStream.use(block: (JarOutputStream) -> Unit): Unit defined in kotlin.io[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Closeable?> -> JarOutputStream
    <R> -> Unit

'it' @ [338:17] ==> value-parameter it: JarOutputStream defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'putNextEntry' @ [338:20] ==> public open fun putNextEntry(p0: (ZipEntry..ZipEntry?)): Unit defined in java.util.jar.JarOutputStream[JavaMethodDescriptor]

'ZipEntry' @ [338:33] ==> public constructor ZipEntry(p0: (String..String?)) defined in java.util.zip.ZipEntry[JavaClassConstructorDescriptor]

'it' @ [339:17] ==> value-parameter it: JarOutputStream defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'write' @ [339:20] ==> public open fun write(p0: (ByteArray..ByteArray?)): Unit defined in java.util.jar.JarOutputStream[JavaMethodDescriptor]

'toByteArray' @ [339:68] ==> @InlineOnly public inline fun String.toByteArray(charset: Charset = ...): ByteArray defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'it' @ [340:17] ==> value-parameter it: JarOutputStream defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'closeEntry' @ [340:20] ==> public open fun closeEntry(): Unit defined in java.util.jar.JarOutputStream[JavaMethodDescriptor]

'aliceNode' @ [342:32] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'database' @ [342:42] ==> public final lateinit var database: CordaPersistence defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'transaction' @ [342:51] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> SecureHash): SecureHash defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SecureHash

'attachment' @ [343:17] ==> public open fun attachment(attachment: InputStream): SecureHash defined in net.corda.testing.LedgerDSL[DeserializedSimpleFunctionDescriptor]

'ByteArrayInputStream' @ [343:28] ==> public constructor ByteArrayInputStream(p0: (ByteArray..ByteArray?)) defined in java.io.ByteArrayInputStream[JavaClassConstructorDescriptor]

'stream' @ [343:49] ==> val stream: ByteArrayOutputStream defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'toByteArray' @ [343:56] ==> public open fun toByteArray(): (ByteArray..ByteArray?) defined in java.io.ByteArrayOutputStream[JavaMethodDescriptor]

'fillUpForBuyer' @ [346:32] ==> private final fun LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter>.fillUpForBuyer(withError: Boolean, issuer: PartyAndReference, owner: AbstractParty, notary: Party): Pair<Vault<ContractState>, List<WireTransaction>> defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'issuer' @ [346:54] ==> val issuer: PartyAndReference defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'AnonymousParty' @ [346:62] ==> public constructor AnonymousParty(owningKey: PublicKey) defined in net.corda.core.identity.AnonymousParty[DeserializedClassConstructorDescriptor]

'bobNode' @ [346:77] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'info' @ [346:85] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [346:90] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'owningKey' @ [346:104] ==> public final val owningKey: PublicKey defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'notaryNode' @ [347:21] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'info' @ [347:32] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'notaryIdentity' @ [347:37] ==> public final val notaryIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'second' @ [347:53] ==> public final val second: List<WireTransaction> defined in kotlin.Pair[DeserializedPropertyDescriptor]

'insertFakeTransactions' @ [348:34] ==> private final fun insertFakeTransactions(wtxToSign: List<WireTransaction>, node: AbstractNode, notaryNode: AbstractNode, vararg extraSigningNodes: AbstractNode): Map<SecureHash, SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'bobsFakeCash' @ [348:57] ==> val bobsFakeCash: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'bobNode' @ [348:71] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'notaryNode' @ [348:80] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'bankNode' @ [348:92] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'aliceNode' @ [349:35] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'database' @ [349:45] ==> public final lateinit var database: CordaPersistence defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'transaction' @ [349:54] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> List<WireTransaction>): List<WireTransaction> defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> List<WireTransaction>

'fillUpForSeller' @ [350:17] ==> private final fun LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter>.fillUpForSeller(withError: Boolean, issuer: PartyAndReference, owner: AbstractParty, amount: Amount<Issued<Currency>>, attachmentID: SecureHash?, notary: Party): Pair<Vault<ContractState>, List<WireTransaction>> defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'issuer' @ [350:40] ==> val issuer: PartyAndReference defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'aliceNode' @ [350:48] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'info' @ [350:58] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [350:63] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'`issued by`' @ [351:25] ==> public infix fun Amount<Currency>.`issued by`(deposit: PartyAndReference): Amount<Issued<Currency>> defined in net.corda.finance[DeserializedSimpleFunctionDescriptor]

'DOLLARS' @ [351:30] ==> public val Int.DOLLARS: Amount<Currency> defined in net.corda.finance[DeserializedPropertyDescriptor]

'bankNode' @ [351:50] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'info' @ [351:59] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [351:64] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'ref' @ [351:78] ==> public final fun ref(vararg bytes: Byte): PartyAndReference defined in net.corda.core.identity.Party[DeserializedSimpleFunctionDescriptor]

'attachmentID' @ [351:86] ==> val attachmentID: SecureHash defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'notaryNode' @ [351:100] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'info' @ [351:111] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'notaryIdentity' @ [351:116] ==> public final val notaryIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'second' @ [351:132] ==> public final val second: List<WireTransaction> defined in kotlin.Pair[DeserializedPropertyDescriptor]

'insertFakeTransactions' @ [353:36] ==> private final fun insertFakeTransactions(wtxToSign: List<WireTransaction>, node: AbstractNode, notaryNode: AbstractNode, vararg extraSigningNodes: AbstractNode): Map<SecureHash, SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'alicesFakePaper' @ [353:59] ==> val alicesFakePaper: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'aliceNode' @ [353:76] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'notaryNode' @ [353:87] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'bankNode' @ [353:99] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'mockNet' @ [355:13] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'runNetwork' @ [355:21] ==> @JvmOverloads public final fun runNetwork(rounds: Int = ...): Unit defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'runBuyerAndSeller' @ [357:13] ==> private final fun runBuyerAndSeller(notaryNode: MockNetwork.MockNode, sellerNode: MockNetwork.MockNode, buyerNode: MockNetwork.MockNode, assetToSell: StateAndRef<OwnableState>): TwoPartyTradeFlowTests.RunResult defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'notaryNode' @ [357:31] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'aliceNode' @ [357:43] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'bobNode' @ [357:54] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'outputStateAndRef' @ [357:79] ==> public final inline fun <reified S : ContractState> String.outputStateAndRef(): StateAndRef<OwnableState> defined in net.corda.testing.LedgerDSL[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified S : ContractState> -> OwnableState

'mockNet' @ [359:13] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'runNetwork' @ [359:21] ==> @JvmOverloads public final fun runNetwork(rounds: Int = ...): Unit defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'run' @ [361:13] ==> @InlineOnly public inline fun <T, R> LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter>.run(block: LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter>.() -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter>
    <R> -> Unit

'bobNode' @ [362:32] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'services' @ [362:40] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'validatedTransactions' @ [362:49] ==> public abstract val validatedTransactions: WritableTransactionStorage defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'records' @ [362:103] ==> public final val records: MutableList<TwoPartyTradeFlowTests.TxRecord> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RecordingTransactionStorage[PropertyDescriptorImpl]

'records' @ [364:17] ==> val records: MutableList<TwoPartyTradeFlowTests.TxRecord> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>.<anonymous>[LocalVariableDescriptor]

'expectEvents' @ [364:25] ==> public fun <E : Any> Iterable<TwoPartyTradeFlowTests.TxRecord>.expectEvents(isStrict: Boolean = ..., expectCompose: () -> ExpectCompose<TwoPartyTradeFlowTests.TxRecord>): Unit defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <E : Any> -> TxRecord

'sequence' @ [365:21] ==> public fun <E> sequence(vararg expectations: ExpectCompose<TwoPartyTradeFlowTests.TxRecord>): ExpectCompose<TwoPartyTradeFlowTests.TxRecord> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <E> -> TxRecord

'expect' @ [367:29] ==> public inline fun <reified E : Any> expect(event: TwoPartyTradeFlowTests.TxRecord.Get, noinline expectClosure: (TwoPartyTradeFlowTests.TxRecord.Get) -> Unit = ...): ExpectCompose<TwoPartyTradeFlowTests.TxRecord.Get> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> Get

'Get' @ [367:45] ==> public constructor Get(id: SecureHash) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.TxRecord.Get[ClassConstructorDescriptorImpl]

'alicesFakePaper' @ [367:49] ==> val alicesFakePaper: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'id' @ [367:68] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'expect' @ [369:29] ==> public inline fun <reified E : Any> expect(event: TwoPartyTradeFlowTests.TxRecord.Add, noinline expectClosure: (TwoPartyTradeFlowTests.TxRecord.Add) -> Unit = ...): ExpectCompose<TwoPartyTradeFlowTests.TxRecord.Add> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> Add

'Add' @ [369:45] ==> public constructor Add(transaction: SignedTransaction) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.TxRecord.Add[ClassConstructorDescriptorImpl]

'alicesSignedTxns' @ [369:49] ==> val alicesSignedTxns: Map<SecureHash, SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'values' @ [369:66] ==> public abstract val values: Collection<SignedTransaction> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'first' @ [369:73] ==> public fun <T> Iterable<SignedTransaction>.first(): SignedTransaction defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SignedTransaction

'expect' @ [371:29] ==> public inline fun <reified E : Any> expect(event: TwoPartyTradeFlowTests.TxRecord.Get, noinline expectClosure: (TwoPartyTradeFlowTests.TxRecord.Get) -> Unit = ...): ExpectCompose<TwoPartyTradeFlowTests.TxRecord.Get> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> Get

'Get' @ [371:45] ==> public constructor Get(id: SecureHash) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.TxRecord.Get[ClassConstructorDescriptorImpl]

'bobsFakeCash' @ [371:49] ==> val bobsFakeCash: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'id' @ [371:65] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'expect' @ [372:29] ==> public inline fun <reified E : Any> expect(event: TwoPartyTradeFlowTests.TxRecord.Get, noinline expectClosure: (TwoPartyTradeFlowTests.TxRecord.Get) -> Unit = ...): ExpectCompose<TwoPartyTradeFlowTests.TxRecord.Get> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> Get

'Get' @ [372:45] ==> public constructor Get(id: SecureHash) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.TxRecord.Get[ClassConstructorDescriptorImpl]

'bobsFakeCash' @ [372:49] ==> val bobsFakeCash: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'id' @ [372:65] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'expect' @ [374:29] ==> public inline fun <reified E : Any> expect(event: TwoPartyTradeFlowTests.TxRecord.Get, noinline expectClosure: (TwoPartyTradeFlowTests.TxRecord.Get) -> Unit = ...): ExpectCompose<TwoPartyTradeFlowTests.TxRecord.Get> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> Get

'Get' @ [374:45] ==> public constructor Get(id: SecureHash) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.TxRecord.Get[ClassConstructorDescriptorImpl]

'bobsFakeCash' @ [374:49] ==> val bobsFakeCash: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'id' @ [374:65] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'bobNode' @ [379:17] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'database' @ [379:25] ==> public final lateinit var database: CordaPersistence defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'transaction' @ [379:34] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> Unit): Unit defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Unit

'bobNode' @ [380:21] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'services' @ [380:29] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'attachments' @ [380:38] ==> public abstract val attachments: AttachmentStorage defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'openAttachment' @ [380:50] ==> public abstract fun openAttachment(id: SecureHash): Attachment? defined in net.corda.core.node.services.AttachmentStorage[DeserializedSimpleFunctionDescriptor]

'attachmentID' @ [380:65] ==> val attachmentID: SecureHash defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'openAsJAR' @ [380:81] ==> public open fun openAsJAR(): JarInputStream defined in net.corda.core.contracts.Attachment[DeserializedSimpleFunctionDescriptor]

'use' @ [380:93] ==> @InlineOnly public inline fun <T : Closeable?, R> JarInputStream.use(block: (JarInputStream) -> Unit): Unit defined in kotlin.io[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Closeable?> -> JarInputStream
    <R> -> Unit

'it' @ [381:25] ==> value-parameter it: JarInputStream defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'nextJarEntry' @ [381:28] ==> public final val JarInputStream.nextJarEntry: (JarEntry..JarEntry?)[MyPropertyDescriptor]

'it' @ [382:40] ==> value-parameter it: JarInputStream defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>.<anonymous>.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'reader' @ [382:43] ==> @InlineOnly public inline fun InputStream.reader(charset: Charset = ...): InputStreamReader defined in kotlin.io[DeserializedSimpleFunctionDescriptor]

'readText' @ [382:52] ==> public fun Reader.readText(): String defined in kotlin.io[DeserializedSimpleFunctionDescriptor]

'assertTrue' @ [383:25] ==> public fun assertTrue(actual: Boolean, message: String? = ...): Unit defined in kotlin.test[DeserializedSimpleFunctionDescriptor]

'contents' @ [383:36] ==> val contents: String defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>.<anonymous>.<anonymous>.<anonymous>[LocalVariableDescriptor]

'contains' @ [383:45] ==> public operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = ...): Boolean defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'run' @ [389:13] ==> @InlineOnly public inline fun <T, R> LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter>.run(block: LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter>.() -> Unit): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter>
    <R> -> Unit

'aliceNode' @ [390:32] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`[LocalVariableDescriptor]

'services' @ [390:42] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'validatedTransactions' @ [390:51] ==> public abstract val validatedTransactions: WritableTransactionStorage defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'records' @ [390:105] ==> public final val records: MutableList<TwoPartyTradeFlowTests.TxRecord> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RecordingTransactionStorage[PropertyDescriptorImpl]

'records' @ [391:17] ==> val records: MutableList<TwoPartyTradeFlowTests.TxRecord> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>.<anonymous>[LocalVariableDescriptor]

'expectEvents' @ [391:25] ==> public fun <E : Any> Iterable<TwoPartyTradeFlowTests.TxRecord>.expectEvents(isStrict: Boolean = ..., expectCompose: () -> ExpectCompose<TwoPartyTradeFlowTests.TxRecord>): Unit defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <E : Any> -> TxRecord

'sequence' @ [392:21] ==> public fun <E> sequence(vararg expectations: ExpectCompose<TwoPartyTradeFlowTests.TxRecord>): ExpectCompose<TwoPartyTradeFlowTests.TxRecord> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <E> -> TxRecord

'expect' @ [395:29] ==> public inline fun <reified E : Any> expect(event: TwoPartyTradeFlowTests.TxRecord.Get, noinline expectClosure: (TwoPartyTradeFlowTests.TxRecord.Get) -> Unit = ...): ExpectCompose<TwoPartyTradeFlowTests.TxRecord.Get> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> Get

'Get' @ [395:45] ==> public constructor Get(id: SecureHash) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.TxRecord.Get[ClassConstructorDescriptorImpl]

'alicesFakePaper' @ [395:49] ==> val alicesFakePaper: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'id' @ [395:68] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'expect' @ [397:29] ==> public inline fun <reified E : Any> expect(event: TwoPartyTradeFlowTests.TxRecord.Get, noinline expectClosure: (TwoPartyTradeFlowTests.TxRecord.Get) -> Unit = ...): ExpectCompose<TwoPartyTradeFlowTests.TxRecord.Get> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> Get

'Get' @ [397:45] ==> public constructor Get(id: SecureHash) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.TxRecord.Get[ClassConstructorDescriptorImpl]

'bobsFakeCash' @ [397:49] ==> val bobsFakeCash: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'id' @ [397:65] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'expect' @ [398:29] ==> public inline fun <reified E : Any> expect(event: TwoPartyTradeFlowTests.TxRecord.Get, noinline expectClosure: (TwoPartyTradeFlowTests.TxRecord.Get) -> Unit = ...): ExpectCompose<TwoPartyTradeFlowTests.TxRecord.Get> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> Get

'Get' @ [398:45] ==> public constructor Get(id: SecureHash) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.TxRecord.Get[ClassConstructorDescriptorImpl]

'bobsFakeCash' @ [398:49] ==> val bobsFakeCash: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'id' @ [398:65] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'expect' @ [399:29] ==> public inline fun <reified E : Any> expect(event: TwoPartyTradeFlowTests.TxRecord.Get, noinline expectClosure: (TwoPartyTradeFlowTests.TxRecord.Get) -> Unit = ...): ExpectCompose<TwoPartyTradeFlowTests.TxRecord.Get> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> Get

'Get' @ [399:45] ==> public constructor Get(id: SecureHash) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.TxRecord.Get[ClassConstructorDescriptorImpl]

'alicesFakePaper' @ [399:49] ==> val alicesFakePaper: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'id' @ [399:68] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'expect' @ [401:29] ==> public inline fun <reified E : Any> expect(event: TwoPartyTradeFlowTests.TxRecord.Get, noinline expectClosure: (TwoPartyTradeFlowTests.TxRecord.Get) -> Unit = ...): ExpectCompose<TwoPartyTradeFlowTests.TxRecord.Get> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> Get

'Get' @ [401:45] ==> public constructor Get(id: SecureHash) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.TxRecord.Get[ClassConstructorDescriptorImpl]

'bobsFakeCash' @ [401:49] ==> val bobsFakeCash: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'id' @ [401:65] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'expect' @ [404:29] ==> public inline fun <reified E : Any> expect(event: TwoPartyTradeFlowTests.TxRecord.Add, noinline expectClosure: (TwoPartyTradeFlowTests.TxRecord.Add) -> Unit = ...): ExpectCompose<TwoPartyTradeFlowTests.TxRecord.Add> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> Add

'Add' @ [404:45] ==> public constructor Add(transaction: SignedTransaction) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.TxRecord.Add[ClassConstructorDescriptorImpl]

'bobsSignedTxns' @ [404:49] ==> val bobsSignedTxns: Map<SecureHash, SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'bobsFakeCash' @ [404:64] ==> val bobsFakeCash: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'id' @ [404:80] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'expect' @ [405:29] ==> public inline fun <reified E : Any> expect(event: TwoPartyTradeFlowTests.TxRecord.Get, noinline expectClosure: (TwoPartyTradeFlowTests.TxRecord.Get) -> Unit = ...): ExpectCompose<TwoPartyTradeFlowTests.TxRecord.Get> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> Get

'Get' @ [405:45] ==> public constructor Get(id: SecureHash) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.TxRecord.Get[ClassConstructorDescriptorImpl]

'bobsFakeCash' @ [405:49] ==> val bobsFakeCash: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'id' @ [405:65] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'expect' @ [406:29] ==> public inline fun <reified E : Any> expect(event: TwoPartyTradeFlowTests.TxRecord.Add, noinline expectClosure: (TwoPartyTradeFlowTests.TxRecord.Add) -> Unit = ...): ExpectCompose<TwoPartyTradeFlowTests.TxRecord.Add> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> Add

'Add' @ [406:45] ==> public constructor Add(transaction: SignedTransaction) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.TxRecord.Add[ClassConstructorDescriptorImpl]

'bobsSignedTxns' @ [406:49] ==> val bobsSignedTxns: Map<SecureHash, SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'bobsFakeCash' @ [406:64] ==> val bobsFakeCash: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'id' @ [406:80] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'expect' @ [407:29] ==> public inline fun <reified E : Any> expect(event: TwoPartyTradeFlowTests.TxRecord.Get, noinline expectClosure: (TwoPartyTradeFlowTests.TxRecord.Get) -> Unit = ...): ExpectCompose<TwoPartyTradeFlowTests.TxRecord.Get> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> Get

'Get' @ [407:45] ==> public constructor Get(id: SecureHash) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.TxRecord.Get[ClassConstructorDescriptorImpl]

'bobsFakeCash' @ [407:49] ==> val bobsFakeCash: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'id' @ [407:65] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'expect' @ [408:29] ==> public inline fun <reified E : Any> expect(event: TwoPartyTradeFlowTests.TxRecord.Add, noinline expectClosure: (TwoPartyTradeFlowTests.TxRecord.Add) -> Unit = ...): ExpectCompose<TwoPartyTradeFlowTests.TxRecord.Add> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> Add

'Add' @ [408:45] ==> public constructor Add(transaction: SignedTransaction) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.TxRecord.Add[ClassConstructorDescriptorImpl]

'bobsSignedTxns' @ [408:49] ==> val bobsSignedTxns: Map<SecureHash, SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'bobsFakeCash' @ [408:64] ==> val bobsFakeCash: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'id' @ [408:80] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'expect' @ [411:29] ==> public inline fun <reified E : Any> expect(event: TwoPartyTradeFlowTests.TxRecord.Get, noinline expectClosure: (TwoPartyTradeFlowTests.TxRecord.Get) -> Unit = ...): ExpectCompose<TwoPartyTradeFlowTests.TxRecord.Get> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> Get

'Get' @ [411:45] ==> public constructor Get(id: SecureHash) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.TxRecord.Get[ClassConstructorDescriptorImpl]

'bobsFakeCash' @ [411:49] ==> val bobsFakeCash: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'id' @ [411:65] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'expect' @ [412:29] ==> public inline fun <reified E : Any> expect(event: TwoPartyTradeFlowTests.TxRecord.Get, noinline expectClosure: (TwoPartyTradeFlowTests.TxRecord.Get) -> Unit = ...): ExpectCompose<TwoPartyTradeFlowTests.TxRecord.Get> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> Get

'Get' @ [412:45] ==> public constructor Get(id: SecureHash) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.TxRecord.Get[ClassConstructorDescriptorImpl]

'bobsFakeCash' @ [412:49] ==> val bobsFakeCash: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'id' @ [412:65] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'expect' @ [413:29] ==> public inline fun <reified E : Any> expect(event: TwoPartyTradeFlowTests.TxRecord.Get, noinline expectClosure: (TwoPartyTradeFlowTests.TxRecord.Get) -> Unit = ...): ExpectCompose<TwoPartyTradeFlowTests.TxRecord.Get> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> Get

'Get' @ [413:45] ==> public constructor Get(id: SecureHash) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.TxRecord.Get[ClassConstructorDescriptorImpl]

'alicesFakePaper' @ [413:49] ==> val alicesFakePaper: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'id' @ [413:68] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'expect' @ [415:29] ==> public inline fun <reified E : Any> expect(event: TwoPartyTradeFlowTests.TxRecord.Get, noinline expectClosure: (TwoPartyTradeFlowTests.TxRecord.Get) -> Unit = ...): ExpectCompose<TwoPartyTradeFlowTests.TxRecord.Get> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> Get

'Get' @ [415:45] ==> public constructor Get(id: SecureHash) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.TxRecord.Get[ClassConstructorDescriptorImpl]

'bobsFakeCash' @ [415:49] ==> val bobsFakeCash: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'id' @ [415:65] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'expect' @ [416:29] ==> public inline fun <reified E : Any> expect(event: TwoPartyTradeFlowTests.TxRecord.Get, noinline expectClosure: (TwoPartyTradeFlowTests.TxRecord.Get) -> Unit = ...): ExpectCompose<TwoPartyTradeFlowTests.TxRecord.Get> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> Get

'Get' @ [416:45] ==> public constructor Get(id: SecureHash) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.TxRecord.Get[ClassConstructorDescriptorImpl]

'bobsFakeCash' @ [416:49] ==> val bobsFakeCash: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'id' @ [416:65] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'expect' @ [417:29] ==> public inline fun <reified E : Any> expect(event: TwoPartyTradeFlowTests.TxRecord.Get, noinline expectClosure: (TwoPartyTradeFlowTests.TxRecord.Get) -> Unit = ...): ExpectCompose<TwoPartyTradeFlowTests.TxRecord.Get> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> Get

'Get' @ [417:45] ==> public constructor Get(id: SecureHash) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.TxRecord.Get[ClassConstructorDescriptorImpl]

'alicesFakePaper' @ [417:49] ==> val alicesFakePaper: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`check dependencies of sale asset are resolved`.<anonymous>[LocalVariableDescriptor]

'id' @ [417:68] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'Test' @ [424:5] ==> public constructor Test(expected: KClass<out (Throwable..Throwable?)> = ..., timeout: Long = ...) defined in org.junit.Test[JavaClassConstructorDescriptor]

'mockNet' @ [426:9] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'MockNetwork' @ [426:19] ==> public constructor MockNetwork(networkSendManuallyPumped: Boolean = ..., threadPerNode: Boolean = ..., servicePeerAllocationStrategy: InMemoryMessagingNetwork.ServicePeerAllocationStrategy = ..., defaultFactory: MockNetwork.Factory<*> = ..., initialiseSerialization: Boolean = ...) defined in net.corda.testing.node.MockNetwork[DeserializedClassConstructorDescriptor]

'mockNet' @ [428:26] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'createNotaryNode' @ [428:34] ==> public final fun createNotaryNode(networkMapAddress: SingleMessageRecipient? = ..., legalName: X500Name? = ..., overrideServices: Map<ServiceInfo, KeyPair>? = ..., serviceName: X500Name? = ...): MockNetwork.MockNode defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'DUMMY_NOTARY' @ [428:57] ==> public val DUMMY_NOTARY: Party defined in net.corda.testing[DeserializedPropertyDescriptor]

'name' @ [428:70] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'makeNodeWithTracking' @ [429:25] ==> private final fun makeNodeWithTracking(networkMapAddress: SingleMessageRecipient?, name: X500Name): MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'notaryNode' @ [429:46] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'network' @ [429:57] ==> public final lateinit var network: MessagingService defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'myAddress' @ [429:65] ==> public abstract val myAddress: SingleMessageRecipient defined in net.corda.node.services.messaging.MessagingService[DeserializedPropertyDescriptor]

'ALICE' @ [429:76] ==> public val ALICE: Party defined in net.corda.testing[DeserializedPropertyDescriptor]

'name' @ [429:82] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'makeNodeWithTracking' @ [430:23] ==> private final fun makeNodeWithTracking(networkMapAddress: SingleMessageRecipient?, name: X500Name): MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'notaryNode' @ [430:44] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'network' @ [430:55] ==> public final lateinit var network: MessagingService defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'myAddress' @ [430:63] ==> public abstract val myAddress: SingleMessageRecipient defined in net.corda.node.services.messaging.MessagingService[DeserializedPropertyDescriptor]

'BOB' @ [430:74] ==> public val BOB: Party defined in net.corda.testing[DeserializedPropertyDescriptor]

'name' @ [430:78] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'makeNodeWithTracking' @ [431:24] ==> private final fun makeNodeWithTracking(networkMapAddress: SingleMessageRecipient?, name: X500Name): MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'notaryNode' @ [431:45] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'network' @ [431:56] ==> public final lateinit var network: MessagingService defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'myAddress' @ [431:64] ==> public abstract val myAddress: SingleMessageRecipient defined in net.corda.node.services.messaging.MessagingService[DeserializedPropertyDescriptor]

'BOC' @ [431:75] ==> public val BOC: Party defined in net.corda.testing[DeserializedPropertyDescriptor]

'name' @ [431:79] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'bankNode' @ [432:22] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'info' @ [432:31] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [432:36] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'ref' @ [432:50] ==> public final fun ref(vararg bytes: Byte): PartyAndReference defined in net.corda.core.identity.Party[DeserializedSimpleFunctionDescriptor]

'listOf' @ [434:24] ==> public fun <T> listOf(vararg elements: MockNetwork.MockNode): List<MockNetwork.MockNode> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> MockNode

'notaryNode' @ [434:31] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'aliceNode' @ [434:43] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'bobNode' @ [434:54] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'bankNode' @ [434:63] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'allNodes' @ [435:9] ==> val allNodes: List<MockNetwork.MockNode> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'forEach' @ [435:18] ==> @HidesMembers public inline fun <T> Iterable<MockNetwork.MockNode>.forEach(action: (MockNetwork.MockNode) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> MockNode

'allNodes' @ [436:13] ==> val allNodes: List<MockNetwork.MockNode> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'map' @ [436:22] ==> public inline fun <T, R> Iterable<MockNetwork.MockNode>.map(transform: (MockNetwork.MockNode) -> PartyAndCertificate): List<PartyAndCertificate> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> MockNode
    <R> -> PartyAndCertificate

'it' @ [436:28] ==> value-parameter it: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'services' @ [436:31] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'myInfo' @ [436:40] ==> public abstract val myInfo: NodeInfo defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'legalIdentityAndCert' @ [436:47] ==> public final val legalIdentityAndCert: PartyAndCertificate defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'forEach' @ [436:70] ==> @HidesMembers public inline fun <T> Iterable<PartyAndCertificate>.forEach(action: (PartyAndCertificate) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PartyAndCertificate

'node' @ [436:92] ==> value-parameter node: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>[ValueParameterDescriptorImpl]

'services' @ [436:97] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'identityService' @ [436:106] ==> public abstract val identityService: IdentityService defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'verifyAndRegisterIdentity' @ [436:122] ==> public abstract fun verifyAndRegisterIdentity(identity: PartyAndCertificate): PartyAndCertificate? defined in net.corda.core.node.services.IdentityService[DeserializedSimpleFunctionDescriptor]

'identity' @ [436:148] ==> value-parameter identity: PartyAndCertificate defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'ledger' @ [439:9] ==> @JvmOverloads public fun ledger(services: ServiceHub = ..., initialiseSerialization: Boolean = ..., dsl: LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter>.() -> Unit): LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]

'aliceNode' @ [439:16] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'services' @ [439:26] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'ByteArrayOutputStream' @ [442:26] ==> public constructor ByteArrayOutputStream() defined in java.io.ByteArrayOutputStream[JavaClassConstructorDescriptor]

'JarOutputStream' @ [443:13] ==> public constructor JarOutputStream(p0: (OutputStream..OutputStream?)) defined in java.util.jar.JarOutputStream[JavaClassConstructorDescriptor]

'stream' @ [443:29] ==> val stream: ByteArrayOutputStream defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>[LocalVariableDescriptor]

'use' @ [443:37] ==> @InlineOnly public inline fun <T : Closeable?, R> JarOutputStream.use(block: (JarOutputStream) -> Unit): Unit defined in kotlin.io[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : Closeable?> -> JarOutputStream
    <R> -> Unit

'it' @ [444:17] ==> value-parameter it: JarOutputStream defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'putNextEntry' @ [444:20] ==> public open fun putNextEntry(p0: (ZipEntry..ZipEntry?)): Unit defined in java.util.jar.JarOutputStream[JavaMethodDescriptor]

'ZipEntry' @ [444:33] ==> public constructor ZipEntry(p0: (String..String?)) defined in java.util.zip.ZipEntry[JavaClassConstructorDescriptor]

'it' @ [445:17] ==> value-parameter it: JarOutputStream defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'write' @ [445:20] ==> public open fun write(p0: (ByteArray..ByteArray?)): Unit defined in java.util.jar.JarOutputStream[JavaMethodDescriptor]

'toByteArray' @ [445:68] ==> @InlineOnly public inline fun String.toByteArray(charset: Charset = ...): ByteArray defined in kotlin.text[DeserializedSimpleFunctionDescriptor]

'it' @ [446:17] ==> value-parameter it: JarOutputStream defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'closeEntry' @ [446:20] ==> public open fun closeEntry(): Unit defined in java.util.jar.JarOutputStream[JavaMethodDescriptor]

'aliceNode' @ [448:32] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'database' @ [448:42] ==> public final lateinit var database: CordaPersistence defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'transaction' @ [448:51] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> SecureHash): SecureHash defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SecureHash

'attachment' @ [449:17] ==> public open fun attachment(attachment: InputStream): SecureHash defined in net.corda.testing.LedgerDSL[DeserializedSimpleFunctionDescriptor]

'ByteArrayInputStream' @ [449:28] ==> public constructor ByteArrayInputStream(p0: (ByteArray..ByteArray?)) defined in java.io.ByteArrayInputStream[JavaClassConstructorDescriptor]

'stream' @ [449:49] ==> val stream: ByteArrayOutputStream defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>[LocalVariableDescriptor]

'toByteArray' @ [449:56] ==> public open fun toByteArray(): (ByteArray..ByteArray?) defined in java.io.ByteArrayOutputStream[JavaMethodDescriptor]

'bobNode' @ [452:27] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'services' @ [452:35] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'keyManagementService' @ [452:44] ==> public abstract val keyManagementService: KeyManagementService defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'keys' @ [452:65] ==> public abstract val keys: Set<PublicKey> defined in net.corda.core.node.services.KeyManagementService[DeserializedPropertyDescriptor]

'single' @ [452:70] ==> public fun <T> Iterable<PublicKey>.single(): PublicKey defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> PublicKey

'fillUpForBuyer' @ [453:32] ==> private final fun LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter>.fillUpForBuyer(withError: Boolean, issuer: PartyAndReference, owner: AbstractParty, notary: Party): Pair<Vault<ContractState>, List<WireTransaction>> defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'issuer' @ [453:54] ==> val issuer: PartyAndReference defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'AnonymousParty' @ [453:62] ==> public constructor AnonymousParty(owningKey: PublicKey) defined in net.corda.core.identity.AnonymousParty[DeserializedClassConstructorDescriptor]

'bobsKey' @ [453:77] ==> val bobsKey: PublicKey defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>[LocalVariableDescriptor]

'notaryNode' @ [454:21] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'info' @ [454:32] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'notaryIdentity' @ [454:37] ==> public final val notaryIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'second' @ [454:53] ==> public final val second: List<WireTransaction> defined in kotlin.Pair[DeserializedPropertyDescriptor]

'insertFakeTransactions' @ [455:13] ==> private final fun insertFakeTransactions(wtxToSign: List<WireTransaction>, node: AbstractNode, notaryNode: AbstractNode, vararg extraSigningNodes: AbstractNode): Map<SecureHash, SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'bobsFakeCash' @ [455:36] ==> val bobsFakeCash: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>[LocalVariableDescriptor]

'bobNode' @ [455:50] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'notaryNode' @ [455:59] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'bankNode' @ [455:71] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'aliceNode' @ [457:35] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'database' @ [457:45] ==> public final lateinit var database: CordaPersistence defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'transaction' @ [457:54] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> List<WireTransaction>): List<WireTransaction> defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> List<WireTransaction>

'fillUpForSeller' @ [458:17] ==> private final fun LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter>.fillUpForSeller(withError: Boolean, issuer: PartyAndReference, owner: AbstractParty, amount: Amount<Issued<Currency>>, attachmentID: SecureHash?, notary: Party): Pair<Vault<ContractState>, List<WireTransaction>> defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'issuer' @ [458:40] ==> val issuer: PartyAndReference defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'aliceNode' @ [458:48] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'info' @ [458:58] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [458:63] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'`issued by`' @ [459:25] ==> public infix fun Amount<Currency>.`issued by`(deposit: PartyAndReference): Amount<Issued<Currency>> defined in net.corda.finance[DeserializedSimpleFunctionDescriptor]

'DOLLARS' @ [459:30] ==> public val Int.DOLLARS: Amount<Currency> defined in net.corda.finance[DeserializedPropertyDescriptor]

'bankNode' @ [459:50] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'info' @ [459:59] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [459:64] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'ref' @ [459:78] ==> public final fun ref(vararg bytes: Byte): PartyAndReference defined in net.corda.core.identity.Party[DeserializedSimpleFunctionDescriptor]

'attachmentID' @ [459:86] ==> val attachmentID: SecureHash defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>[LocalVariableDescriptor]

'notaryNode' @ [459:100] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'info' @ [459:111] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'notaryIdentity' @ [459:116] ==> public final val notaryIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'second' @ [459:132] ==> public final val second: List<WireTransaction> defined in kotlin.Pair[DeserializedPropertyDescriptor]

'insertFakeTransactions' @ [462:13] ==> private final fun insertFakeTransactions(wtxToSign: List<WireTransaction>, node: AbstractNode, notaryNode: AbstractNode, vararg extraSigningNodes: AbstractNode): Map<SecureHash, SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'alicesFakePaper' @ [462:36] ==> val alicesFakePaper: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>[LocalVariableDescriptor]

'aliceNode' @ [462:53] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'notaryNode' @ [462:64] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'bankNode' @ [462:76] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'mockNet' @ [464:13] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'runNetwork' @ [464:21] ==> @JvmOverloads public final fun runNetwork(rounds: Int = ...): Unit defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'aliceNode' @ [466:33] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'services' @ [466:43] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'validatedTransactions' @ [466:52] ==> public abstract val validatedTransactions: WritableTransactionStorage defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'track' @ [466:74] ==> public abstract fun track(): DataFeed<List<SignedTransaction>, SignedTransaction> defined in net.corda.node.services.api.WritableTransactionStorage[DeserializedSimpleFunctionDescriptor]

'updates' @ [466:82] ==> public final val updates: Observable<SignedTransaction> defined in net.corda.core.messaging.DataFeed[DeserializedPropertyDescriptor]

'with' @ [467:35] ==> @InlineOnly public inline fun <T, R> with(receiver: MockNetwork.MockNode, block: MockNetwork.MockNode.() -> Observable<StateMachineTransactionMapping>): Observable<StateMachineTransactionMapping> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> MockNode
    <R> -> Observable<StateMachineTransactionMapping>

'aliceNode' @ [467:40] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'database' @ [468:17] ==> public final lateinit var database: CordaPersistence defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'transaction' @ [468:26] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> Observable<StateMachineTransactionMapping>): Observable<StateMachineTransactionMapping> defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Observable<StateMachineTransactionMapping>

'services' @ [468:40] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'stateMachineRecordedTransactionMapping' @ [468:49] ==> public abstract val stateMachineRecordedTransactionMapping: StateMachineRecordedTransactionMappingStorage defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'track' @ [468:88] ==> public abstract fun track(): DataFeed<List<StateMachineTransactionMapping>, StateMachineTransactionMapping> defined in net.corda.node.services.api.StateMachineRecordedTransactionMappingStorage[DeserializedSimpleFunctionDescriptor]

'updates' @ [468:96] ==> public final val updates: Observable<StateMachineTransactionMapping> defined in net.corda.core.messaging.DataFeed[DeserializedPropertyDescriptor]

'runBuyerAndSeller' @ [470:29] ==> private final fun runBuyerAndSeller(notaryNode: MockNetwork.MockNode, sellerNode: MockNetwork.MockNode, buyerNode: MockNetwork.MockNode, assetToSell: StateAndRef<OwnableState>): TwoPartyTradeFlowTests.RunResult defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'notaryNode' @ [470:47] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'aliceNode' @ [470:59] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'bobNode' @ [470:70] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`[LocalVariableDescriptor]

'outputStateAndRef' @ [471:37] ==> public final inline fun <reified S : ContractState> String.outputStateAndRef(): StateAndRef<OwnableState> defined in net.corda.testing.LedgerDSL[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified S : ContractState> -> OwnableState

'sellerId' @ [471:58] ==> public final val sellerId: StateMachineRunId defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RunResult[PropertyDescriptorImpl]

'mockNet' @ [473:13] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'runNetwork' @ [473:21] ==> @JvmOverloads public final fun runNetwork(rounds: Int = ...): Unit defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'sequence' @ [476:39] ==> public fun <E> sequence(vararg expectations: ExpectCompose<SignedTransaction>): ExpectCompose<SignedTransaction> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <E> -> SignedTransaction

'expect' @ [477:21] ==> public inline fun <reified E : Any> expect(noinline match: (SignedTransaction) -> Boolean = ..., noinline expectClosure: (SignedTransaction) -> Unit): ExpectCompose<SignedTransaction> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> SignedTransaction

'require' @ [478:25] ==> @InlineOnly public inline fun require(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'tx' @ [478:33] ==> value-parameter tx: SignedTransaction defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'id' @ [478:36] ==> public open val id: SecureHash defined in net.corda.core.transactions.SignedTransaction[DeserializedPropertyDescriptor]

'bobsFakeCash' @ [478:42] ==> val bobsFakeCash: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>[LocalVariableDescriptor]

'id' @ [478:58] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'expect' @ [480:21] ==> public inline fun <reified E : Any> expect(noinline match: (SignedTransaction) -> Boolean = ..., noinline expectClosure: (SignedTransaction) -> Unit): ExpectCompose<SignedTransaction> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> SignedTransaction

'require' @ [481:25] ==> @InlineOnly public inline fun require(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'tx' @ [481:33] ==> value-parameter tx: SignedTransaction defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'id' @ [481:36] ==> public open val id: SecureHash defined in net.corda.core.transactions.SignedTransaction[DeserializedPropertyDescriptor]

'bobsFakeCash' @ [481:42] ==> val bobsFakeCash: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>[LocalVariableDescriptor]

'id' @ [481:58] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'expect' @ [483:21] ==> public inline fun <reified E : Any> expect(noinline match: (SignedTransaction) -> Boolean = ..., noinline expectClosure: (SignedTransaction) -> Unit): ExpectCompose<SignedTransaction> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> SignedTransaction

'require' @ [484:25] ==> @InlineOnly public inline fun require(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'tx' @ [484:33] ==> value-parameter tx: SignedTransaction defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'id' @ [484:36] ==> public open val id: SecureHash defined in net.corda.core.transactions.SignedTransaction[DeserializedPropertyDescriptor]

'bobsFakeCash' @ [484:42] ==> val bobsFakeCash: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>[LocalVariableDescriptor]

'id' @ [484:58] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'aliceTxStream' @ [487:13] ==> val aliceTxStream: Observable<SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>[LocalVariableDescriptor]

'expectEvents' @ [487:27] ==> public fun <E : Any> Observable<SignedTransaction>.expectEvents(isStrict: Boolean = ..., expectCompose: () -> ExpectCompose<SignedTransaction>): Unit defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <E : Any> -> SignedTransaction

'aliceTxExpectations' @ [487:42] ==> val aliceTxExpectations: ExpectCompose<SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>[LocalVariableDescriptor]

'sequence' @ [488:44] ==> public fun <E> sequence(vararg expectations: ExpectCompose<StateMachineTransactionMapping>): ExpectCompose<StateMachineTransactionMapping> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <E> -> StateMachineTransactionMapping

'expect' @ [489:21] ==> public inline fun <reified E : Any> expect(noinline match: (StateMachineTransactionMapping) -> Boolean = ..., noinline expectClosure: (StateMachineTransactionMapping) -> Unit): ExpectCompose<StateMachineTransactionMapping> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> StateMachineTransactionMapping

'component1' @ [489:63] ==> public final operator fun component1(): StateMachineRunId defined in net.corda.core.messaging.StateMachineTransactionMapping[DeserializedSimpleFunctionDescriptor]

'component2' @ [489:82] ==> public final operator fun component2(): SecureHash defined in net.corda.core.messaging.StateMachineTransactionMapping[DeserializedSimpleFunctionDescriptor]

'require' @ [490:25] ==> @InlineOnly public inline fun require(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'stateMachineRunId' @ [490:33] ==> val stateMachineRunId: StateMachineRunId defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>.<anonymous>[LocalVariableDescriptor]

'aliceSmId' @ [490:54] ==> val aliceSmId: StateMachineRunId defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>[LocalVariableDescriptor]

'require' @ [491:25] ==> @InlineOnly public inline fun require(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'transactionId' @ [491:33] ==> val transactionId: SecureHash defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>.<anonymous>[LocalVariableDescriptor]

'bobsFakeCash' @ [491:50] ==> val bobsFakeCash: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>[LocalVariableDescriptor]

'id' @ [491:66] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'expect' @ [493:21] ==> public inline fun <reified E : Any> expect(noinline match: (StateMachineTransactionMapping) -> Boolean = ..., noinline expectClosure: (StateMachineTransactionMapping) -> Unit): ExpectCompose<StateMachineTransactionMapping> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> StateMachineTransactionMapping

'component1' @ [493:31] ==> public final operator fun component1(): StateMachineRunId defined in net.corda.core.messaging.StateMachineTransactionMapping[DeserializedSimpleFunctionDescriptor]

'component2' @ [493:50] ==> public final operator fun component2(): SecureHash defined in net.corda.core.messaging.StateMachineTransactionMapping[DeserializedSimpleFunctionDescriptor]

'require' @ [494:25] ==> @InlineOnly public inline fun require(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'stateMachineRunId' @ [494:33] ==> val stateMachineRunId: StateMachineRunId defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>.<anonymous>[LocalVariableDescriptor]

'aliceSmId' @ [494:54] ==> val aliceSmId: StateMachineRunId defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>[LocalVariableDescriptor]

'require' @ [495:25] ==> @InlineOnly public inline fun require(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'transactionId' @ [495:33] ==> val transactionId: SecureHash defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>.<anonymous>[LocalVariableDescriptor]

'bobsFakeCash' @ [495:50] ==> val bobsFakeCash: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>[LocalVariableDescriptor]

'id' @ [495:66] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'expect' @ [497:21] ==> public inline fun <reified E : Any> expect(noinline match: (StateMachineTransactionMapping) -> Boolean = ..., noinline expectClosure: (StateMachineTransactionMapping) -> Unit): ExpectCompose<StateMachineTransactionMapping> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified E : Any> -> StateMachineTransactionMapping

'component1' @ [497:31] ==> public final operator fun component1(): StateMachineRunId defined in net.corda.core.messaging.StateMachineTransactionMapping[DeserializedSimpleFunctionDescriptor]

'component2' @ [497:50] ==> public final operator fun component2(): SecureHash defined in net.corda.core.messaging.StateMachineTransactionMapping[DeserializedSimpleFunctionDescriptor]

'require' @ [498:25] ==> @InlineOnly public inline fun require(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'stateMachineRunId' @ [498:33] ==> val stateMachineRunId: StateMachineRunId defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>.<anonymous>[LocalVariableDescriptor]

'aliceSmId' @ [498:54] ==> val aliceSmId: StateMachineRunId defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>[LocalVariableDescriptor]

'require' @ [499:25] ==> @InlineOnly public inline fun require(value: Boolean): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'transactionId' @ [499:33] ==> val transactionId: SecureHash defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>.<anonymous>[LocalVariableDescriptor]

'bobsFakeCash' @ [499:50] ==> val bobsFakeCash: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>[LocalVariableDescriptor]

'id' @ [499:66] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'aliceTxMappings' @ [502:13] ==> val aliceTxMappings: Observable<StateMachineTransactionMapping> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>[LocalVariableDescriptor]

'expectEvents' @ [502:29] ==> public fun <E : Any> Observable<StateMachineTransactionMapping>.expectEvents(isStrict: Boolean = ..., expectCompose: () -> ExpectCompose<StateMachineTransactionMapping>): Unit defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <E : Any> -> StateMachineTransactionMapping

'aliceMappingExpectations' @ [502:44] ==> val aliceMappingExpectations: ExpectCompose<StateMachineTransactionMapping> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.`track works`.<anonymous>[LocalVariableDescriptor]

'Test' @ [506:5] ==> public constructor Test(expected: KClass<out (Throwable..Throwable?)> = ..., timeout: Long = ...) defined in org.junit.Test[JavaClassConstructorDescriptor]

'mockNet' @ [508:9] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'MockNetwork' @ [508:19] ==> public constructor MockNetwork(networkSendManuallyPumped: Boolean = ..., threadPerNode: Boolean = ..., servicePeerAllocationStrategy: InMemoryMessagingNetwork.ServicePeerAllocationStrategy = ..., defaultFactory: MockNetwork.Factory<*> = ..., initialiseSerialization: Boolean = ...) defined in net.corda.testing.node.MockNetwork[DeserializedClassConstructorDescriptor]

'ledger' @ [509:9] ==> @JvmOverloads public fun ledger(services: ServiceHub = ..., initialiseSerialization: Boolean = ..., dsl: LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter>.() -> Unit): LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]

'runWithError' @ [510:13] ==> private final fun LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter>.runWithError(bobError: Boolean, aliceError: Boolean, expectedMessageSubstring: String): Unit defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'Test' @ [514:5] ==> public constructor Test(expected: KClass<out (Throwable..Throwable?)> = ..., timeout: Long = ...) defined in org.junit.Test[JavaClassConstructorDescriptor]

'mockNet' @ [516:9] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'MockNetwork' @ [516:19] ==> public constructor MockNetwork(networkSendManuallyPumped: Boolean = ..., threadPerNode: Boolean = ..., servicePeerAllocationStrategy: InMemoryMessagingNetwork.ServicePeerAllocationStrategy = ..., defaultFactory: MockNetwork.Factory<*> = ..., initialiseSerialization: Boolean = ...) defined in net.corda.testing.node.MockNetwork[DeserializedClassConstructorDescriptor]

'ledger' @ [517:9] ==> @JvmOverloads public fun ledger(services: ServiceHub = ..., initialiseSerialization: Boolean = ..., dsl: LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter>.() -> Unit): LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]

'runWithError' @ [518:13] ==> private final fun LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter>.runWithError(bobError: Boolean, aliceError: Boolean, expectedMessageSubstring: String): Unit defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'sellerNode' @ [533:31] ==> value-parameter sellerNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runBuyerAndSeller[ValueParameterDescriptorImpl]

'services' @ [533:42] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'let' @ [533:51] ==> @InlineOnly public inline fun <T, R> ServiceHubInternal.let(block: (ServiceHubInternal) -> PartyAndCertificate): PartyAndCertificate defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ServiceHubInternal
    <R> -> PartyAndCertificate

'serviceHub' @ [534:13] ==> value-parameter serviceHub: ServiceHubInternal defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runBuyerAndSeller.<anonymous>[ValueParameterDescriptorImpl]

'keyManagementService' @ [534:24] ==> public abstract val keyManagementService: KeyManagementService defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'freshKeyAndCert' @ [534:45] ==> @Suspendable public abstract fun freshKeyAndCert(identity: PartyAndCertificate, revocationEnabled: Boolean): PartyAndCertificate defined in net.corda.core.node.services.KeyManagementService[DeserializedSimpleFunctionDescriptor]

'serviceHub' @ [534:61] ==> value-parameter serviceHub: ServiceHubInternal defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runBuyerAndSeller.<anonymous>[ValueParameterDescriptorImpl]

'myInfo' @ [534:72] ==> public abstract val myInfo: NodeInfo defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'legalIdentityAndCert' @ [534:79] ==> public final val legalIdentityAndCert: PartyAndCertificate defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'party' @ [535:11] ==> public final val party: Party defined in net.corda.core.identity.PartyAndCertificate[DeserializedPropertyDescriptor]

'anonymise' @ [535:17] ==> public final fun anonymise(): AnonymousParty defined in net.corda.core.identity.Party[DeserializedSimpleFunctionDescriptor]

'buyerNode' @ [536:53] ==> value-parameter buyerNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runBuyerAndSeller[ValueParameterDescriptorImpl]

'registerInitiatedFlow' @ [536:63] ==> public final fun <T : FlowLogic<*>> registerInitiatedFlow(initiatedFlowClass: Class<TwoPartyTradeFlowTests.BuyerAcceptor>): Observable<TwoPartyTradeFlowTests.BuyerAcceptor> defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T : FlowLogic<*>> -> BuyerAcceptor

'BuyerAcceptor' @ [536:85] ==> public constructor BuyerAcceptor(seller: Party) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.BuyerAcceptor[ClassConstructorDescriptorImpl]

'java' @ [536:106] ==> public val <T> KClass<TwoPartyTradeFlowTests.BuyerAcceptor>.java: Class<TwoPartyTradeFlowTests.BuyerAcceptor> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> BuyerAcceptor

'buyerFlows' @ [537:31] ==> val buyerFlows: Observable<TwoPartyTradeFlowTests.BuyerAcceptor> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runBuyerAndSeller[LocalVariableDescriptor]

'toFuture' @ [537:42] ==> public fun <T> Observable<TwoPartyTradeFlowTests.BuyerAcceptor>.toFuture(): CordaFuture<TwoPartyTradeFlowTests.BuyerAcceptor> defined in net.corda.core[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> BuyerAcceptor

'map' @ [537:53] ==> public fun <V, W> CordaFuture<out TwoPartyTradeFlowTests.BuyerAcceptor>.map(transform: (TwoPartyTradeFlowTests.BuyerAcceptor) -> FlowStateMachine<out Any?>): CordaFuture<FlowStateMachine<out Any?>> defined in net.corda.core.internal.concurrent[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <V> -> BuyerAcceptor
    <W> -> FlowStateMachine<out Any?>

'it' @ [537:59] ==> value-parameter it: TwoPartyTradeFlowTests.BuyerAcceptor defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runBuyerAndSeller.<anonymous>[ValueParameterDescriptorImpl]

'stateMachine' @ [537:62] ==> public final var stateMachine: FlowStateMachine<*> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.BuyerAcceptor[DeserializedPropertyDescriptor]

'SellerInitiator' @ [538:22] ==> public constructor SellerInitiator(buyer: Party, notary: NodeInfo, assetToSell: StateAndRef<OwnableState>, price: Amount<Currency>, me: AnonymousParty) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.SellerInitiator[ClassConstructorDescriptorImpl]

'buyerNode' @ [538:38] ==> value-parameter buyerNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runBuyerAndSeller[ValueParameterDescriptorImpl]

'info' @ [538:48] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [538:53] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'notaryNode' @ [538:68] ==> value-parameter notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runBuyerAndSeller[ValueParameterDescriptorImpl]

'info' @ [538:79] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'assetToSell' @ [538:85] ==> value-parameter assetToSell: StateAndRef<OwnableState> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runBuyerAndSeller[ValueParameterDescriptorImpl]

'DOLLARS' @ [538:103] ==> public val Int.DOLLARS: Amount<Currency> defined in net.corda.finance[DeserializedPropertyDescriptor]

'anonymousSeller' @ [538:112] ==> val anonymousSeller: AnonymousParty defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runBuyerAndSeller[LocalVariableDescriptor]

'sellerNode' @ [539:28] ==> value-parameter sellerNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runBuyerAndSeller[ValueParameterDescriptorImpl]

'services' @ [539:39] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'startFlow' @ [539:48] ==> public open fun <T> startFlow(logic: FlowLogic<SignedTransaction>): FlowStateMachine<SignedTransaction> defined in net.corda.node.services.api.ServiceHubInternal[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SignedTransaction

'seller' @ [539:58] ==> val seller: TwoPartyTradeFlowTests.SellerInitiator defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runBuyerAndSeller[LocalVariableDescriptor]

'resultFuture' @ [539:66] ==> public abstract val resultFuture: CordaFuture<SignedTransaction> defined in net.corda.core.internal.FlowStateMachine[DeserializedPropertyDescriptor]

'RunResult' @ [540:16] ==> public constructor RunResult(buyer: CordaFuture<FlowStateMachine<*>>, sellerResult: CordaFuture<SignedTransaction>, sellerId: StateMachineRunId) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RunResult[ClassConstructorDescriptorImpl]

'firstBuyerFiber' @ [540:26] ==> val firstBuyerFiber: CordaFuture<FlowStateMachine<out Any?>> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runBuyerAndSeller[LocalVariableDescriptor]

'sellerResult' @ [540:43] ==> val sellerResult: CordaFuture<SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runBuyerAndSeller[LocalVariableDescriptor]

'seller' @ [540:57] ==> val seller: TwoPartyTradeFlowTests.SellerInitiator defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runBuyerAndSeller[LocalVariableDescriptor]

'stateMachine' @ [540:64] ==> public final var stateMachine: FlowStateMachine<*> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.SellerInitiator[DeserializedPropertyDescriptor]

'id' @ [540:77] ==> public abstract val id: StateMachineRunId defined in net.corda.core.internal.FlowStateMachine[DeserializedPropertyDescriptor]

'InitiatingFlow' @ [543:5] ==> public constructor InitiatingFlow(version: Int = ...) defined in net.corda.core.flows.InitiatingFlow[DeserializedClassConstructorDescriptor]

'FlowLogic<SignedTransaction>' @ [548:53] ==> public constructor FlowLogic<out T>() defined in net.corda.core.flows.FlowLogic[DeserializedClassConstructorDescriptor]
Inferred types:
    <out T> -> SignedTransaction

'Suspendable' @ [549:9] ==> public constructor Suspendable() defined in co.paralleluniverse.fibers.Suspendable[JavaClassConstructorDescriptor]

'send' @ [551:13] ==> @Suspendable public open fun send(otherParty: Party, payload: Any): Unit defined in net.corda.node.messaging.TwoPartyTradeFlowTests.SellerInitiator[DeserializedSimpleFunctionDescriptor]

'buyer' @ [551:18] ==> public final val buyer: Party defined in net.corda.node.messaging.TwoPartyTradeFlowTests.SellerInitiator[PropertyDescriptorImpl]

'Pair' @ [551:25] ==> public constructor Pair<out A, out B>(first: Party, second: Amount<Currency>) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> Party
    <out B> -> Amount<Currency>

'notary' @ [551:30] ==> public final val notary: NodeInfo defined in net.corda.node.messaging.TwoPartyTradeFlowTests.SellerInitiator[PropertyDescriptorImpl]

'notaryIdentity' @ [551:37] ==> public final val notaryIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'price' @ [551:53] ==> public final val price: Amount<Currency> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.SellerInitiator[PropertyDescriptorImpl]

'subFlow' @ [552:20] ==> @Suspendable public open fun <R> subFlow(subLogic: FlowLogic<SignedTransaction>): SignedTransaction defined in net.corda.node.messaging.TwoPartyTradeFlowTests.SellerInitiator[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <R> -> SignedTransaction

'Seller' @ [552:28] ==> public constructor Seller(otherParty: Party, notaryNode: NodeInfo, assetToSell: StateAndRef<OwnableState>, price: Amount<Currency>, me: AbstractParty, progressTracker: ProgressTracker = ...) defined in net.corda.finance.flows.TwoPartyTradeFlow.Seller[DeserializedClassConstructorDescriptor]

'buyer' @ [553:21] ==> public final val buyer: Party defined in net.corda.node.messaging.TwoPartyTradeFlowTests.SellerInitiator[PropertyDescriptorImpl]

'notary' @ [554:21] ==> public final val notary: NodeInfo defined in net.corda.node.messaging.TwoPartyTradeFlowTests.SellerInitiator[PropertyDescriptorImpl]

'assetToSell' @ [555:21] ==> public final val assetToSell: StateAndRef<OwnableState> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.SellerInitiator[PropertyDescriptorImpl]

'price' @ [556:21] ==> public final val price: Amount<Currency> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.SellerInitiator[PropertyDescriptorImpl]

'me' @ [557:21] ==> public final val me: AnonymousParty defined in net.corda.node.messaging.TwoPartyTradeFlowTests.SellerInitiator[PropertyDescriptorImpl]

'InitiatedBy' @ [561:5] ==> public constructor InitiatedBy(value: KClass<out FlowLogic<*>>) defined in net.corda.core.flows.InitiatedBy[DeserializedClassConstructorDescriptor]

'SellerInitiator' @ [561:18] ==> public constructor SellerInitiator(buyer: Party, notary: NodeInfo, assetToSell: StateAndRef<OwnableState>, price: Amount<Currency>, me: AnonymousParty) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.SellerInitiator[ClassConstructorDescriptorImpl]

'FlowLogic<SignedTransaction>' @ [562:46] ==> public constructor FlowLogic<out T>() defined in net.corda.core.flows.FlowLogic[DeserializedClassConstructorDescriptor]
Inferred types:
    <out T> -> SignedTransaction

'Suspendable' @ [563:9] ==> public constructor Suspendable() defined in co.paralleluniverse.fibers.Suspendable[JavaClassConstructorDescriptor]

'component1' @ [565:18] ==> public final operator fun component1(): Party defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [565:26] ==> public final operator fun component2(): Amount<Currency> defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'receive' @ [565:35] ==> public final inline fun <reified R : Any> receive(otherParty: Party): UntrustworthyData<Pair<Party, Amount<Currency>>> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.BuyerAcceptor[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified R : Any> -> Pair<Party, Amount<Currency>>

'seller' @ [565:74] ==> public final val seller: Party defined in net.corda.node.messaging.TwoPartyTradeFlowTests.BuyerAcceptor[PropertyDescriptorImpl]

'unwrap' @ [565:82] ==> public inline fun <T, R> UntrustworthyData<Pair<Party, Amount<Currency>>>.unwrap(validator: (Pair<Party, Amount<Currency>>) -> Pair<Party, Amount<Currency>>): Pair<Party, Amount<Currency>> defined in net.corda.core.utilities[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<Party, Amount<Currency>>
    <R> -> Pair<Party, Amount<Currency>>

'require' @ [566:17] ==> @InlineOnly public inline fun require(value: Boolean, lazyMessage: () -> Any): Unit defined in kotlin[DeserializedSimpleFunctionDescriptor]

'serviceHub' @ [566:25] ==> public final val serviceHub: ServiceHub defined in net.corda.node.messaging.TwoPartyTradeFlowTests.BuyerAcceptor[DeserializedPropertyDescriptor]

'networkMapCache' @ [566:36] ==> public abstract val networkMapCache: NetworkMapCache defined in net.corda.core.node.ServiceHub[DeserializedPropertyDescriptor]

'isNotary' @ [566:52] ==> public open fun isNotary(party: Party): Boolean defined in net.corda.core.node.services.NetworkMapCache[DeserializedSimpleFunctionDescriptor]

'it' @ [566:61] ==> value-parameter it: Pair<Party, Amount<Currency>> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.BuyerAcceptor.call.<anonymous>[ValueParameterDescriptorImpl]

'first' @ [566:64] ==> public final val first: Party defined in kotlin.Pair[DeserializedPropertyDescriptor]

'it' @ [566:77] ==> value-parameter it: Pair<Party, Amount<Currency>> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.BuyerAcceptor.call.<anonymous>[ValueParameterDescriptorImpl]

'first' @ [566:80] ==> public final val first: Party defined in kotlin.Pair[DeserializedPropertyDescriptor]

'it' @ [567:17] ==> value-parameter it: Pair<Party, Amount<Currency>> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.BuyerAcceptor.call.<anonymous>[ValueParameterDescriptorImpl]

'subFlow' @ [569:20] ==> @Suspendable public open fun <R> subFlow(subLogic: FlowLogic<SignedTransaction>): SignedTransaction defined in net.corda.node.messaging.TwoPartyTradeFlowTests.BuyerAcceptor[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <R> -> SignedTransaction

'Buyer' @ [569:28] ==> public constructor Buyer(otherParty: Party, notary: Party, acceptablePrice: Amount<Currency>, typeToBuy: Class<out OwnableState>) defined in net.corda.finance.flows.TwoPartyTradeFlow.Buyer[DeserializedClassConstructorDescriptor]

'seller' @ [569:34] ==> public final val seller: Party defined in net.corda.node.messaging.TwoPartyTradeFlowTests.BuyerAcceptor[PropertyDescriptorImpl]

'notary' @ [569:42] ==> val notary: Party defined in net.corda.node.messaging.TwoPartyTradeFlowTests.BuyerAcceptor.call[LocalVariableDescriptor]

'price' @ [569:50] ==> val price: Amount<Currency> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.BuyerAcceptor.call[LocalVariableDescriptor]

'State' @ [569:73] ==> public constructor State(issuance: PartyAndReference, owner: AbstractParty, faceValue: Amount<Issued<Currency>>, maturityDate: Instant) defined in net.corda.finance.contracts.CommercialPaper.State[DeserializedClassConstructorDescriptor]

'java' @ [569:86] ==> public val <T> KClass<CommercialPaper.State>.java: Class<CommercialPaper.State> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> State

'mockNet' @ [578:26] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'createNotaryNode' @ [578:34] ==> public final fun createNotaryNode(networkMapAddress: SingleMessageRecipient? = ..., legalName: X500Name? = ..., overrideServices: Map<ServiceInfo, KeyPair>? = ..., serviceName: X500Name? = ...): MockNetwork.MockNode defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'DUMMY_NOTARY' @ [578:57] ==> public val DUMMY_NOTARY: Party defined in net.corda.testing[DeserializedPropertyDescriptor]

'name' @ [578:70] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'mockNet' @ [579:25] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'createPartyNode' @ [579:33] ==> public final fun createPartyNode(networkMapAddress: SingleMessageRecipient, legalName: X500Name? = ..., overrideServices: Map<ServiceInfo, KeyPair>? = ...): MockNetwork.MockNode defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'notaryNode' @ [579:49] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'network' @ [579:60] ==> public final lateinit var network: MessagingService defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'myAddress' @ [579:68] ==> public abstract val myAddress: SingleMessageRecipient defined in net.corda.node.services.messaging.MessagingService[DeserializedPropertyDescriptor]

'ALICE' @ [579:79] ==> public val ALICE: Party defined in net.corda.testing[DeserializedPropertyDescriptor]

'name' @ [579:85] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'mockNet' @ [580:23] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'createPartyNode' @ [580:31] ==> public final fun createPartyNode(networkMapAddress: SingleMessageRecipient, legalName: X500Name? = ..., overrideServices: Map<ServiceInfo, KeyPair>? = ...): MockNetwork.MockNode defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'notaryNode' @ [580:47] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'network' @ [580:58] ==> public final lateinit var network: MessagingService defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'myAddress' @ [580:66] ==> public abstract val myAddress: SingleMessageRecipient defined in net.corda.node.services.messaging.MessagingService[DeserializedPropertyDescriptor]

'BOB' @ [580:77] ==> public val BOB: Party defined in net.corda.testing[DeserializedPropertyDescriptor]

'name' @ [580:81] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'mockNet' @ [581:24] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'createPartyNode' @ [581:32] ==> public final fun createPartyNode(networkMapAddress: SingleMessageRecipient, legalName: X500Name? = ..., overrideServices: Map<ServiceInfo, KeyPair>? = ...): MockNetwork.MockNode defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'notaryNode' @ [581:48] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'network' @ [581:59] ==> public final lateinit var network: MessagingService defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'myAddress' @ [581:67] ==> public abstract val myAddress: SingleMessageRecipient defined in net.corda.node.services.messaging.MessagingService[DeserializedPropertyDescriptor]

'BOC' @ [581:78] ==> public val BOC: Party defined in net.corda.testing[DeserializedPropertyDescriptor]

'name' @ [581:82] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'bankNode' @ [582:22] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'info' @ [582:31] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [582:36] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'ref' @ [582:50] ==> public final fun ref(vararg bytes: Byte): PartyAndReference defined in net.corda.core.identity.Party[DeserializedSimpleFunctionDescriptor]

'bobNode' @ [584:27] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'database' @ [584:35] ==> public final lateinit var database: CordaPersistence defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'transaction' @ [584:44] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> List<WireTransaction>): List<WireTransaction> defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> List<WireTransaction>

'fillUpForBuyer' @ [585:13] ==> private final fun LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter>.fillUpForBuyer(withError: Boolean, issuer: PartyAndReference, owner: AbstractParty, notary: Party): Pair<Vault<ContractState>, List<WireTransaction>> defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'bobError' @ [585:28] ==> value-parameter bobError: Boolean defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[ValueParameterDescriptorImpl]

'issuer' @ [585:38] ==> val issuer: PartyAndReference defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'bobNode' @ [585:46] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'info' @ [585:54] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [585:59] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'notaryNode' @ [586:21] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'info' @ [586:32] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'notaryIdentity' @ [586:37] ==> public final val notaryIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'second' @ [586:53] ==> public final val second: List<WireTransaction> defined in kotlin.Pair[DeserializedPropertyDescriptor]

'aliceNode' @ [588:31] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'database' @ [588:41] ==> public final lateinit var database: CordaPersistence defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'transaction' @ [588:50] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> List<WireTransaction>): List<WireTransaction> defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> List<WireTransaction>

'fillUpForSeller' @ [589:13] ==> private final fun LedgerDSL<TestTransactionDSLInterpreter, TestLedgerDSLInterpreter>.fillUpForSeller(withError: Boolean, issuer: PartyAndReference, owner: AbstractParty, amount: Amount<Issued<Currency>>, attachmentID: SecureHash?, notary: Party): Pair<Vault<ContractState>, List<WireTransaction>> defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'aliceError' @ [589:29] ==> value-parameter aliceError: Boolean defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[ValueParameterDescriptorImpl]

'issuer' @ [589:41] ==> val issuer: PartyAndReference defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'aliceNode' @ [589:49] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'info' @ [589:59] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [589:64] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'`issued by`' @ [590:21] ==> public infix fun Amount<Currency>.`issued by`(deposit: PartyAndReference): Amount<Issued<Currency>> defined in net.corda.finance[DeserializedSimpleFunctionDescriptor]

'DOLLARS' @ [590:26] ==> public val Int.DOLLARS: Amount<Currency> defined in net.corda.finance[DeserializedPropertyDescriptor]

'issuer' @ [590:46] ==> val issuer: PartyAndReference defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'notaryNode' @ [590:60] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'info' @ [590:71] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'notaryIdentity' @ [590:76] ==> public final val notaryIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'second' @ [590:92] ==> public final val second: List<WireTransaction> defined in kotlin.Pair[DeserializedPropertyDescriptor]

'insertFakeTransactions' @ [593:9] ==> private final fun insertFakeTransactions(wtxToSign: List<WireTransaction>, node: AbstractNode, notaryNode: AbstractNode, vararg extraSigningNodes: AbstractNode): Map<SecureHash, SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'bobsBadCash' @ [593:32] ==> val bobsBadCash: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'bobNode' @ [593:45] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'notaryNode' @ [593:54] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'bankNode' @ [593:66] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'insertFakeTransactions' @ [594:9] ==> private final fun insertFakeTransactions(wtxToSign: List<WireTransaction>, node: AbstractNode, notaryNode: AbstractNode, vararg extraSigningNodes: AbstractNode): Map<SecureHash, SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'alicesFakePaper' @ [594:32] ==> val alicesFakePaper: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'aliceNode' @ [594:49] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'notaryNode' @ [594:60] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'bankNode' @ [594:72] ==> val bankNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'mockNet' @ [596:9] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'runNetwork' @ [596:17] ==> @JvmOverloads public final fun runNetwork(rounds: Int = ...): Unit defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'component1' @ [598:14] ==> public final operator fun component1(): CordaFuture<FlowStateMachine<*>> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RunResult[SimpleFunctionDescriptorImpl]

'component2' @ [598:31] ==> public final operator fun component2(): CordaFuture<SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RunResult[SimpleFunctionDescriptorImpl]

'runBuyerAndSeller' @ [598:46] ==> private final fun runBuyerAndSeller(notaryNode: MockNetwork.MockNode, sellerNode: MockNetwork.MockNode, buyerNode: MockNetwork.MockNode, assetToSell: StateAndRef<OwnableState>): TwoPartyTradeFlowTests.RunResult defined in net.corda.node.messaging.TwoPartyTradeFlowTests[SimpleFunctionDescriptorImpl]

'notaryNode' @ [598:64] ==> val notaryNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'aliceNode' @ [598:76] ==> val aliceNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'bobNode' @ [598:87] ==> val bobNode: MockNetwork.MockNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'outputStateAndRef' @ [598:112] ==> public final inline fun <reified S : ContractState> String.outputStateAndRef(): StateAndRef<OwnableState> defined in net.corda.testing.LedgerDSL[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified S : ContractState> -> OwnableState

'mockNet' @ [600:9] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.messaging.TwoPartyTradeFlowTests[PropertyDescriptorImpl]

'runNetwork' @ [600:17] ==> @JvmOverloads public final fun runNetwork(rounds: Int = ...): Unit defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'assertFailsWith' @ [602:17] ==> @InlineOnly public inline fun <reified T : Throwable> assertFailsWith(message: String? = ..., noinline block: () -> Unit): TransactionVerificationException defined in kotlin.test[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified T : Throwable> -> TransactionVerificationException

'if (bobError)
                aliceResult.getOrThrow()
            else
                bobStateMachine.getOrThrow().resultFuture.getOrThrow()' @ [603:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Any?, elseBranch: Any?): Any?[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Any?

'bobError' @ [603:17] ==> value-parameter bobError: Boolean defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[ValueParameterDescriptorImpl]

'aliceResult' @ [604:17] ==> val aliceResult: CordaFuture<SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'getOrThrow' @ [604:29] ==> public fun <V> Future<SignedTransaction>.getOrThrow(timeout: Duration? = ...): SignedTransaction defined in net.corda.core.utilities[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <V> -> SignedTransaction

'bobStateMachine' @ [606:17] ==> val bobStateMachine: CordaFuture<FlowStateMachine<*>> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'getOrThrow' @ [606:33] ==> public fun <V> Future<FlowStateMachine<*>>.getOrThrow(timeout: Duration? = ...): FlowStateMachine<*> defined in net.corda.core.utilities[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <V> -> FlowStateMachine<*>

'resultFuture' @ [606:46] ==> public abstract val resultFuture: CordaFuture<out Any?> defined in net.corda.core.internal.FlowStateMachine[DeserializedPropertyDescriptor]

'getOrThrow' @ [606:59] ==> public fun <V> Future<out Any?>.getOrThrow(timeout: Duration? = ...): Any? defined in net.corda.core.utilities[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <V> -> Any?

'e' @ [608:33] ==> val e: TransactionVerificationException defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'rootCause' @ [608:35] ==> public val Throwable.rootCause: Throwable defined in net.corda.core.internal[DeserializedPropertyDescriptor]

'message' @ [608:45] ==> public open val message: String? defined in kotlin.Throwable[DeserializedPropertyDescriptor]

'expectedMessageSubstring' @ [609:13] ==> value-parameter expectedMessageSubstring: String defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[ValueParameterDescriptorImpl]

'underlyingMessage' @ [609:42] ==> val underlyingMessage: String defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'assertEquals' @ [610:13] ==> public fun <@OnlyInputTypes T> assertEquals(expected: String, actual: String, message: String? = ...): Unit defined in kotlin.test[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <@OnlyInputTypes T> -> String

'expectedMessageSubstring' @ [610:26] ==> value-parameter expectedMessageSubstring: String defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[ValueParameterDescriptorImpl]

'underlyingMessage' @ [610:52] ==> val underlyingMessage: String defined in net.corda.node.messaging.TwoPartyTradeFlowTests.runWithError[LocalVariableDescriptor]

'wtxToSign' @ [621:22] ==> value-parameter wtxToSign: List<WireTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions[ValueParameterDescriptorImpl]

'map' @ [621:32] ==> public inline fun <T, R> Iterable<WireTransaction>.map(transform: (WireTransaction) -> SignedTransaction): List<SignedTransaction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> WireTransaction
    <R> -> SignedTransaction

'it' @ [622:22] ==> value-parameter it: WireTransaction defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions.<anonymous>[ValueParameterDescriptorImpl]

'id' @ [622:25] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'mutableListOf' @ [623:24] ==> @SinceKotlin @InlineOnly public inline fun <T> mutableListOf(): MutableList<TransactionSignature> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TransactionSignature

'sigs' @ [624:13] ==> val sigs: MutableList<TransactionSignature> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions.<anonymous>[LocalVariableDescriptor]

'add' @ [624:18] ==> public abstract fun add(element: TransactionSignature): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'node' @ [624:22] ==> value-parameter node: AbstractNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions[ValueParameterDescriptorImpl]

'services' @ [624:27] ==> public final val services: ServiceHubInternal defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'keyManagementService' @ [624:36] ==> public abstract val keyManagementService: KeyManagementService defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'sign' @ [624:57] ==> @Suspendable public abstract fun sign(signableData: SignableData, publicKey: PublicKey): TransactionSignature defined in net.corda.core.node.services.KeyManagementService[DeserializedSimpleFunctionDescriptor]

'SignableData' @ [624:62] ==> public constructor SignableData(txId: SecureHash, signatureMetadata: SignatureMetadata) defined in net.corda.core.crypto.SignableData[DeserializedClassConstructorDescriptor]

'id' @ [624:75] ==> val id: SecureHash defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions.<anonymous>[LocalVariableDescriptor]

'SignatureMetadata' @ [624:79] ==> public constructor SignatureMetadata(platformVersion: Int, schemeNumberID: Int) defined in net.corda.core.crypto.SignatureMetadata[DeserializedClassConstructorDescriptor]

'Crypto' @ [624:100] ==> public object Crypto defined in net.corda.core.crypto[FakeCallableDescriptorForObject]

'findSignatureScheme' @ [624:107] ==> @JvmStatic public final fun findSignatureScheme(key: PublicKey): SignatureScheme defined in net.corda.core.crypto.Crypto[DeserializedSimpleFunctionDescriptor]

'node' @ [624:127] ==> value-parameter node: AbstractNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions[ValueParameterDescriptorImpl]

'services' @ [624:132] ==> public final val services: ServiceHubInternal defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'legalIdentityKey' @ [624:141] ==> public open val legalIdentityKey: PublicKey defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'schemeNumberID' @ [624:159] ==> public final val schemeNumberID: Int defined in net.corda.core.crypto.SignatureScheme[DeserializedPropertyDescriptor]

'node' @ [624:177] ==> value-parameter node: AbstractNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions[ValueParameterDescriptorImpl]

'services' @ [624:182] ==> public final val services: ServiceHubInternal defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'legalIdentityKey' @ [624:191] ==> public open val legalIdentityKey: PublicKey defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'sigs' @ [625:13] ==> val sigs: MutableList<TransactionSignature> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions.<anonymous>[LocalVariableDescriptor]

'add' @ [625:18] ==> public abstract fun add(element: TransactionSignature): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'notaryNode' @ [625:22] ==> value-parameter notaryNode: AbstractNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions[ValueParameterDescriptorImpl]

'services' @ [625:33] ==> public final val services: ServiceHubInternal defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'keyManagementService' @ [625:42] ==> public abstract val keyManagementService: KeyManagementService defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'sign' @ [625:63] ==> @Suspendable public abstract fun sign(signableData: SignableData, publicKey: PublicKey): TransactionSignature defined in net.corda.core.node.services.KeyManagementService[DeserializedSimpleFunctionDescriptor]

'SignableData' @ [625:68] ==> public constructor SignableData(txId: SecureHash, signatureMetadata: SignatureMetadata) defined in net.corda.core.crypto.SignableData[DeserializedClassConstructorDescriptor]

'id' @ [625:81] ==> val id: SecureHash defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions.<anonymous>[LocalVariableDescriptor]

'SignatureMetadata' @ [625:85] ==> public constructor SignatureMetadata(platformVersion: Int, schemeNumberID: Int) defined in net.corda.core.crypto.SignatureMetadata[DeserializedClassConstructorDescriptor]

'Crypto' @ [625:106] ==> public object Crypto defined in net.corda.core.crypto[FakeCallableDescriptorForObject]

'findSignatureScheme' @ [625:113] ==> @JvmStatic public final fun findSignatureScheme(key: PublicKey): SignatureScheme defined in net.corda.core.crypto.Crypto[DeserializedSimpleFunctionDescriptor]

'notaryNode' @ [625:133] ==> value-parameter notaryNode: AbstractNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions[ValueParameterDescriptorImpl]

'services' @ [625:144] ==> public final val services: ServiceHubInternal defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'notaryIdentityKey' @ [625:153] ==> public open val notaryIdentityKey: PublicKey defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'schemeNumberID' @ [625:172] ==> public final val schemeNumberID: Int defined in net.corda.core.crypto.SignatureScheme[DeserializedPropertyDescriptor]

'notaryNode' @ [625:190] ==> value-parameter notaryNode: AbstractNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions[ValueParameterDescriptorImpl]

'services' @ [625:201] ==> public final val services: ServiceHubInternal defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'notaryIdentityKey' @ [625:210] ==> public open val notaryIdentityKey: PublicKey defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'extraSigningNodes' @ [626:13] ==> value-parameter vararg extraSigningNodes: AbstractNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions[ValueParameterDescriptorImpl]

'forEach' @ [626:31] ==> public inline fun <T> Array<out AbstractNode>.forEach(action: (AbstractNode) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> AbstractNode

'sigs' @ [627:17] ==> val sigs: MutableList<TransactionSignature> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions.<anonymous>[LocalVariableDescriptor]

'add' @ [627:22] ==> public abstract fun add(element: TransactionSignature): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'currentNode' @ [627:26] ==> value-parameter currentNode: AbstractNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'services' @ [627:38] ==> public final val services: ServiceHubInternal defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'keyManagementService' @ [627:47] ==> public abstract val keyManagementService: KeyManagementService defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'sign' @ [627:68] ==> @Suspendable public abstract fun sign(signableData: SignableData, publicKey: PublicKey): TransactionSignature defined in net.corda.core.node.services.KeyManagementService[DeserializedSimpleFunctionDescriptor]

'SignableData' @ [627:73] ==> public constructor SignableData(txId: SecureHash, signatureMetadata: SignatureMetadata) defined in net.corda.core.crypto.SignableData[DeserializedClassConstructorDescriptor]

'id' @ [627:86] ==> val id: SecureHash defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions.<anonymous>[LocalVariableDescriptor]

'SignatureMetadata' @ [627:90] ==> public constructor SignatureMetadata(platformVersion: Int, schemeNumberID: Int) defined in net.corda.core.crypto.SignatureMetadata[DeserializedClassConstructorDescriptor]

'Crypto' @ [627:111] ==> public object Crypto defined in net.corda.core.crypto[FakeCallableDescriptorForObject]

'findSignatureScheme' @ [627:118] ==> @JvmStatic public final fun findSignatureScheme(key: PublicKey): SignatureScheme defined in net.corda.core.crypto.Crypto[DeserializedSimpleFunctionDescriptor]

'currentNode' @ [627:138] ==> value-parameter currentNode: AbstractNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'info' @ [627:150] ==> public final lateinit var info: NodeInfo defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [627:155] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'owningKey' @ [627:169] ==> public final val owningKey: PublicKey defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'schemeNumberID' @ [627:180] ==> public final val schemeNumberID: Int defined in net.corda.core.crypto.SignatureScheme[DeserializedPropertyDescriptor]

'currentNode' @ [627:198] ==> value-parameter currentNode: AbstractNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'info' @ [627:210] ==> public final lateinit var info: NodeInfo defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [627:215] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'owningKey' @ [627:229] ==> public final val owningKey: PublicKey defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'SignedTransaction' @ [629:13] ==> public constructor SignedTransaction(ctx: CoreTransaction, sigs: List<TransactionSignature>) defined in net.corda.core.transactions.SignedTransaction[DeserializedClassConstructorDescriptor]

'it' @ [629:31] ==> value-parameter it: WireTransaction defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions.<anonymous>[ValueParameterDescriptorImpl]

'sigs' @ [629:35] ==> val sigs: MutableList<TransactionSignature> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions.<anonymous>[LocalVariableDescriptor]

'node' @ [631:16] ==> value-parameter node: AbstractNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions[ValueParameterDescriptorImpl]

'database' @ [631:21] ==> public final lateinit var database: CordaPersistence defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'transaction' @ [631:30] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> Map<SecureHash, SignedTransaction>): Map<SecureHash, SignedTransaction> defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Map<SecureHash, SignedTransaction>

'node' @ [632:13] ==> value-parameter node: AbstractNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions[ValueParameterDescriptorImpl]

'services' @ [632:18] ==> public final val services: ServiceHubInternal defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'recordTransactions' @ [632:27] ==> public open fun recordTransactions(txs: Iterable<SignedTransaction>): Unit defined in net.corda.node.services.api.ServiceHubInternal[DeserializedSimpleFunctionDescriptor]

'signed' @ [632:46] ==> val signed: List<SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions[LocalVariableDescriptor]

'node' @ [633:41] ==> value-parameter node: AbstractNode defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions[ValueParameterDescriptorImpl]

'services' @ [633:46] ==> public final val services: ServiceHubInternal defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'validatedTransactions' @ [633:55] ==> public abstract val validatedTransactions: WritableTransactionStorage defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'validatedTransactions' @ [634:17] ==> val validatedTransactions: WritableTransactionStorage defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions.<anonymous>[LocalVariableDescriptor]

'validatedTransactions' @ [635:17] ==> val validatedTransactions: WritableTransactionStorage defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions.<anonymous>[LocalVariableDescriptor]

'records' @ [635:39] ==> public final val records: MutableList<TwoPartyTradeFlowTests.TxRecord> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RecordingTransactionStorage[PropertyDescriptorImpl]

'clear' @ [635:47] ==> public abstract fun clear(): Unit defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'signed' @ [637:13] ==> val signed: List<SignedTransaction> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions[LocalVariableDescriptor]

'associateBy' @ [637:20] ==> public inline fun <T, K> Iterable<SignedTransaction>.associateBy(keySelector: (SignedTransaction) -> SecureHash): Map<SecureHash, SignedTransaction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SignedTransaction
    <K> -> SecureHash

'it' @ [637:34] ==> value-parameter it: SignedTransaction defined in net.corda.node.messaging.TwoPartyTradeFlowTests.insertFakeTransactions.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'id' @ [637:37] ==> public open val id: SecureHash defined in net.corda.core.transactions.SignedTransaction[DeserializedPropertyDescriptor]

'issuer' @ [646:28] ==> value-parameter issuer: PartyAndReference defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[ValueParameterDescriptorImpl]

'party' @ [646:35] ==> public final val party: AbstractParty defined in net.corda.core.contracts.PartyAndReference[DeserializedPropertyDescriptor]

'transaction' @ [649:19] ==> @JvmOverloads public final fun transaction(label: String? = ..., transactionBuilder: TransactionBuilder = ..., dsl: TransactionDSL<TransactionDSLInterpreter>.() -> EnforceVerifyOrFail): WireTransaction defined in net.corda.testing.LedgerDSL[DeserializedSimpleFunctionDescriptor]

'TransactionBuilder' @ [649:52] ==> public constructor TransactionBuilder(notary: Party) defined in net.corda.core.transactions.TransactionBuilder[DeserializedClassConstructorDescriptor]

'notary' @ [649:80] ==> value-parameter notary: Party defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[ValueParameterDescriptorImpl]

'output' @ [651:13] ==> @JvmOverloads public final fun output(label: String? = ..., notary: Party = ..., encumbrance: Int? = ..., contractStateClosure: () -> ContractState): Unit defined in net.corda.testing.TransactionDSL[DeserializedSimpleFunctionDescriptor]

'notary' @ [651:49] ==> value-parameter notary: Party defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[ValueParameterDescriptorImpl]

'`issued by`' @ [651:59] ==> public infix fun Cash.State.`issued by`(deposit: PartyAndReference): Cash.State defined in net.corda.finance.contracts.asset[DeserializedSimpleFunctionDescriptor]

'DOLLARS' @ [651:63] ==> public val Int.DOLLARS: Amount<Currency> defined in net.corda.finance[DeserializedPropertyDescriptor]

'CASH' @ [651:71] ==> public val Amount<Currency>.CASH: Cash.State defined in net.corda.finance.contracts.asset[DeserializedPropertyDescriptor]

'issuer' @ [651:88] ==> value-parameter issuer: PartyAndReference defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[ValueParameterDescriptorImpl]

'interimOwner' @ [651:106] ==> val interimOwner: AbstractParty defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[LocalVariableDescriptor]

'output' @ [652:13] ==> @JvmOverloads public final fun output(label: String? = ..., notary: Party = ..., encumbrance: Int? = ..., contractStateClosure: () -> ContractState): Unit defined in net.corda.testing.TransactionDSL[DeserializedSimpleFunctionDescriptor]

'notary' @ [652:49] ==> value-parameter notary: Party defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[ValueParameterDescriptorImpl]

'`issued by`' @ [652:59] ==> public infix fun Cash.State.`issued by`(deposit: PartyAndReference): Cash.State defined in net.corda.finance.contracts.asset[DeserializedSimpleFunctionDescriptor]

'DOLLARS' @ [652:64] ==> public val Int.DOLLARS: Amount<Currency> defined in net.corda.finance[DeserializedPropertyDescriptor]

'CASH' @ [652:72] ==> public val Amount<Currency>.CASH: Cash.State defined in net.corda.finance.contracts.asset[DeserializedPropertyDescriptor]

'issuer' @ [652:89] ==> value-parameter issuer: PartyAndReference defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[ValueParameterDescriptorImpl]

'interimOwner' @ [652:107] ==> val interimOwner: AbstractParty defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[LocalVariableDescriptor]

'if (!withError) {
                command(issuer.party.owningKey) { Cash.Commands.Issue() }
            } else {
                // Put a broken command on so at least a signature is created
                command(issuer.party.owningKey) { Cash.Commands.Move() }
            }' @ [653:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'!' @ [653:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'withError' @ [653:18] ==> value-parameter withError: Boolean defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[ValueParameterDescriptorImpl]

'command' @ [654:17] ==> public final fun command(vararg signers: PublicKey, commandDataClosure: () -> CommandData): Unit defined in net.corda.testing.TransactionDSL[DeserializedSimpleFunctionDescriptor]

'issuer' @ [654:25] ==> value-parameter issuer: PartyAndReference defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[ValueParameterDescriptorImpl]

'party' @ [654:32] ==> public final val party: AbstractParty defined in net.corda.core.contracts.PartyAndReference[DeserializedPropertyDescriptor]

'owningKey' @ [654:38] ==> public final val owningKey: PublicKey defined in net.corda.core.identity.AbstractParty[DeserializedPropertyDescriptor]

'Cash' @ [654:51] ==> public companion object defined in net.corda.finance.contracts.asset.Cash[FakeCallableDescriptorForObject]

'Issue' @ [654:65] ==> public constructor Issue() defined in net.corda.finance.contracts.asset.Cash.Commands.Issue[DeserializedClassConstructorDescriptor]

'command' @ [657:17] ==> public final fun command(vararg signers: PublicKey, commandDataClosure: () -> CommandData): Unit defined in net.corda.testing.TransactionDSL[DeserializedSimpleFunctionDescriptor]

'issuer' @ [657:25] ==> value-parameter issuer: PartyAndReference defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[ValueParameterDescriptorImpl]

'party' @ [657:32] ==> public final val party: AbstractParty defined in net.corda.core.contracts.PartyAndReference[DeserializedPropertyDescriptor]

'owningKey' @ [657:38] ==> public final val owningKey: PublicKey defined in net.corda.core.identity.AbstractParty[DeserializedPropertyDescriptor]

'Cash' @ [657:51] ==> public companion object defined in net.corda.finance.contracts.asset.Cash[FakeCallableDescriptorForObject]

'Move' @ [657:65] ==> public constructor Move(contract: Class<out Contract>? = ...) defined in net.corda.finance.contracts.asset.Cash.Commands.Move[DeserializedClassConstructorDescriptor]

'timeWindow' @ [659:13] ==> @JvmOverloads public final fun timeWindow(time: Instant, tolerance: Duration = ...): Unit defined in net.corda.testing.TransactionDSL[DeserializedSimpleFunctionDescriptor]

'TEST_TX_TIME' @ [659:24] ==> public val TEST_TX_TIME: Instant defined in net.corda.testing[DeserializedPropertyDescriptor]

'if (withError) {
                this.fails()
            } else {
                this.verifies()
            }' @ [660:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: EnforceVerifyOrFail, elseBranch: EnforceVerifyOrFail): EnforceVerifyOrFail[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> EnforceVerifyOrFail

'withError' @ [660:17] ==> value-parameter withError: Boolean defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[ValueParameterDescriptorImpl]

'this' @ [661:17] ==> <this> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer.<anonymous>[ReceiverParameterDescriptorImpl]

'fails' @ [661:22] ==> public open fun fails(): EnforceVerifyOrFail defined in net.corda.testing.TransactionDSL[DeserializedSimpleFunctionDescriptor]

'this' @ [663:17] ==> <this> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer.<anonymous>[ReceiverParameterDescriptorImpl]

'verifies' @ [663:22] ==> public open fun verifies(): EnforceVerifyOrFail defined in net.corda.testing.TransactionDSL[DeserializedSimpleFunctionDescriptor]

'transaction' @ [668:19] ==> @JvmOverloads public final fun transaction(label: String? = ..., transactionBuilder: TransactionBuilder = ..., dsl: TransactionDSL<TransactionDSLInterpreter>.() -> EnforceVerifyOrFail): WireTransaction defined in net.corda.testing.LedgerDSL[DeserializedSimpleFunctionDescriptor]

'TransactionBuilder' @ [668:52] ==> public constructor TransactionBuilder(notary: Party) defined in net.corda.core.transactions.TransactionBuilder[DeserializedClassConstructorDescriptor]

'notary' @ [668:80] ==> value-parameter notary: Party defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[ValueParameterDescriptorImpl]

'input' @ [669:13] ==> public final fun input(stateLabel: String): Unit defined in net.corda.testing.TransactionDSL[DeserializedSimpleFunctionDescriptor]

'output' @ [670:13] ==> @JvmOverloads public final fun output(label: String? = ..., notary: Party = ..., encumbrance: Int? = ..., contractStateClosure: () -> ContractState): Unit defined in net.corda.testing.TransactionDSL[DeserializedSimpleFunctionDescriptor]

'notary' @ [670:43] ==> value-parameter notary: Party defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[ValueParameterDescriptorImpl]

'`issued by`' @ [670:53] ==> public infix fun Cash.State.`issued by`(deposit: PartyAndReference): Cash.State defined in net.corda.finance.contracts.asset[DeserializedSimpleFunctionDescriptor]

'DOLLARS' @ [670:57] ==> public val Int.DOLLARS: Amount<Currency> defined in net.corda.finance[DeserializedPropertyDescriptor]

'CASH' @ [670:65] ==> public val Amount<Currency>.CASH: Cash.State defined in net.corda.finance.contracts.asset[DeserializedPropertyDescriptor]

'issuer' @ [670:82] ==> value-parameter issuer: PartyAndReference defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[ValueParameterDescriptorImpl]

'owner' @ [670:100] ==> value-parameter owner: AbstractParty defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[ValueParameterDescriptorImpl]

'command' @ [671:13] ==> public final fun command(vararg signers: PublicKey, commandDataClosure: () -> CommandData): Unit defined in net.corda.testing.TransactionDSL[DeserializedSimpleFunctionDescriptor]

'interimOwner' @ [671:21] ==> val interimOwner: AbstractParty defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[LocalVariableDescriptor]

'owningKey' @ [671:34] ==> public final val owningKey: PublicKey defined in net.corda.core.identity.AbstractParty[DeserializedPropertyDescriptor]

'Cash' @ [671:47] ==> public companion object defined in net.corda.finance.contracts.asset.Cash[FakeCallableDescriptorForObject]

'Move' @ [671:61] ==> public constructor Move(contract: Class<out Contract>? = ...) defined in net.corda.finance.contracts.asset.Cash.Commands.Move[DeserializedClassConstructorDescriptor]

'this' @ [672:13] ==> <this> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer.<anonymous>[ReceiverParameterDescriptorImpl]

'verifies' @ [672:18] ==> public open fun verifies(): EnforceVerifyOrFail defined in net.corda.testing.TransactionDSL[DeserializedSimpleFunctionDescriptor]

'transaction' @ [675:19] ==> @JvmOverloads public final fun transaction(label: String? = ..., transactionBuilder: TransactionBuilder = ..., dsl: TransactionDSL<TransactionDSLInterpreter>.() -> EnforceVerifyOrFail): WireTransaction defined in net.corda.testing.LedgerDSL[DeserializedSimpleFunctionDescriptor]

'TransactionBuilder' @ [675:52] ==> public constructor TransactionBuilder(notary: Party) defined in net.corda.core.transactions.TransactionBuilder[DeserializedClassConstructorDescriptor]

'notary' @ [675:80] ==> value-parameter notary: Party defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[ValueParameterDescriptorImpl]

'input' @ [676:13] ==> public final fun input(stateLabel: String): Unit defined in net.corda.testing.TransactionDSL[DeserializedSimpleFunctionDescriptor]

'output' @ [677:13] ==> @JvmOverloads public final fun output(label: String? = ..., notary: Party = ..., encumbrance: Int? = ..., contractStateClosure: () -> ContractState): Unit defined in net.corda.testing.TransactionDSL[DeserializedSimpleFunctionDescriptor]

'notary' @ [677:43] ==> value-parameter notary: Party defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[ValueParameterDescriptorImpl]

'`issued by`' @ [677:53] ==> public infix fun Cash.State.`issued by`(deposit: PartyAndReference): Cash.State defined in net.corda.finance.contracts.asset[DeserializedSimpleFunctionDescriptor]

'DOLLARS' @ [677:57] ==> public val Int.DOLLARS: Amount<Currency> defined in net.corda.finance[DeserializedPropertyDescriptor]

'CASH' @ [677:65] ==> public val Amount<Currency>.CASH: Cash.State defined in net.corda.finance.contracts.asset[DeserializedPropertyDescriptor]

'issuer' @ [677:82] ==> value-parameter issuer: PartyAndReference defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[ValueParameterDescriptorImpl]

'owner' @ [677:100] ==> value-parameter owner: AbstractParty defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[ValueParameterDescriptorImpl]

'output' @ [678:13] ==> @JvmOverloads public final fun output(label: String? = ..., notary: Party = ..., encumbrance: Int? = ..., contractStateClosure: () -> ContractState): Unit defined in net.corda.testing.TransactionDSL[DeserializedSimpleFunctionDescriptor]

'notary' @ [678:29] ==> value-parameter notary: Party defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[ValueParameterDescriptorImpl]

'`issued by`' @ [678:39] ==> public infix fun Cash.State.`issued by`(deposit: PartyAndReference): Cash.State defined in net.corda.finance.contracts.asset[DeserializedSimpleFunctionDescriptor]

'DOLLARS' @ [678:43] ==> public val Int.DOLLARS: Amount<Currency> defined in net.corda.finance[DeserializedPropertyDescriptor]

'CASH' @ [678:51] ==> public val Amount<Currency>.CASH: Cash.State defined in net.corda.finance.contracts.asset[DeserializedPropertyDescriptor]

'issuer' @ [678:68] ==> value-parameter issuer: PartyAndReference defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[ValueParameterDescriptorImpl]

'interimOwner' @ [678:86] ==> val interimOwner: AbstractParty defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[LocalVariableDescriptor]

'command' @ [679:13] ==> public final fun command(vararg signers: PublicKey, commandDataClosure: () -> CommandData): Unit defined in net.corda.testing.TransactionDSL[DeserializedSimpleFunctionDescriptor]

'interimOwner' @ [679:21] ==> val interimOwner: AbstractParty defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[LocalVariableDescriptor]

'owningKey' @ [679:34] ==> public final val owningKey: PublicKey defined in net.corda.core.identity.AbstractParty[DeserializedPropertyDescriptor]

'Cash' @ [679:47] ==> public companion object defined in net.corda.finance.contracts.asset.Cash[FakeCallableDescriptorForObject]

'Move' @ [679:61] ==> public constructor Move(contract: Class<out Contract>? = ...) defined in net.corda.finance.contracts.asset.Cash.Commands.Move[DeserializedClassConstructorDescriptor]

'this' @ [680:13] ==> <this> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer.<anonymous>[ReceiverParameterDescriptorImpl]

'verifies' @ [680:18] ==> public open fun verifies(): EnforceVerifyOrFail defined in net.corda.testing.TransactionDSL[DeserializedSimpleFunctionDescriptor]

'Vault' @ [683:21] ==> public constructor Vault<out T : ContractState>(states: Iterable<StateAndRef<ContractState>>) defined in net.corda.core.node.services.Vault[DeserializedClassConstructorDescriptor]
Inferred types:
    <out T : ContractState> -> ContractState

'listOf' @ [683:42] ==> public fun <T> listOf(vararg elements: StateAndRef<Nothing>): List<StateAndRef<Nothing>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> StateAndRef<Nothing>

'outputStateAndRef' @ [683:62] ==> public final inline fun <reified S : ContractState> String.outputStateAndRef(): StateAndRef<Nothing> defined in net.corda.testing.LedgerDSL[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified S : ContractState> -> Nothing

'outputStateAndRef' @ [683:96] ==> public final inline fun <reified S : ContractState> String.outputStateAndRef(): StateAndRef<Nothing> defined in net.corda.testing.LedgerDSL[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified S : ContractState> -> Nothing

'Pair' @ [684:16] ==> public constructor Pair<out A, out B>(first: Vault<ContractState>, second: List<WireTransaction>) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> Vault<ContractState>
    <out B> -> List<WireTransaction>

'vault' @ [684:21] ==> val vault: Vault<ContractState> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[LocalVariableDescriptor]

'listOf' @ [684:28] ==> public fun <T> listOf(vararg elements: WireTransaction): List<WireTransaction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> WireTransaction

'eb1' @ [684:35] ==> val eb1: WireTransaction defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[LocalVariableDescriptor]

'bc1' @ [684:40] ==> val bc1: WireTransaction defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[LocalVariableDescriptor]

'bc2' @ [684:45] ==> val bc2: WireTransaction defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForBuyer[LocalVariableDescriptor]

'transaction' @ [694:18] ==> @JvmOverloads public final fun transaction(label: String? = ..., transactionBuilder: TransactionBuilder = ..., dsl: TransactionDSL<TransactionDSLInterpreter>.() -> EnforceVerifyOrFail): WireTransaction defined in net.corda.testing.LedgerDSL[DeserializedSimpleFunctionDescriptor]

'TransactionBuilder' @ [694:51] ==> public constructor TransactionBuilder(notary: Party) defined in net.corda.core.transactions.TransactionBuilder[DeserializedClassConstructorDescriptor]

'notary' @ [694:79] ==> value-parameter notary: Party defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForSeller[ValueParameterDescriptorImpl]

'output' @ [695:13] ==> @JvmOverloads public final fun output(label: String? = ..., notary: Party = ..., encumbrance: Int? = ..., contractStateClosure: () -> ContractState): Unit defined in net.corda.testing.TransactionDSL[DeserializedSimpleFunctionDescriptor]

'notary' @ [695:46] ==> value-parameter notary: Party defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForSeller[ValueParameterDescriptorImpl]

'State' @ [696:33] ==> public constructor State(issuance: PartyAndReference, owner: AbstractParty, faceValue: Amount<Issued<Currency>>, maturityDate: Instant) defined in net.corda.finance.contracts.CommercialPaper.State[DeserializedClassConstructorDescriptor]

'issuer' @ [696:39] ==> value-parameter issuer: PartyAndReference defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForSeller[ValueParameterDescriptorImpl]

'owner' @ [696:47] ==> value-parameter owner: AbstractParty defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForSeller[ValueParameterDescriptorImpl]

'amount' @ [696:54] ==> value-parameter amount: Amount<Issued<Currency>> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForSeller[ValueParameterDescriptorImpl]

'TEST_TX_TIME' @ [696:62] ==> public val TEST_TX_TIME: Instant defined in net.corda.testing[DeserializedPropertyDescriptor]

'days' @ [696:79] ==> public val Int.days: Duration defined in net.corda.core.utilities[DeserializedPropertyDescriptor]

'command' @ [698:13] ==> public final fun command(vararg signers: PublicKey, commandDataClosure: () -> CommandData): Unit defined in net.corda.testing.TransactionDSL[DeserializedSimpleFunctionDescriptor]

'issuer' @ [698:21] ==> value-parameter issuer: PartyAndReference defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForSeller[ValueParameterDescriptorImpl]

'party' @ [698:28] ==> public final val party: AbstractParty defined in net.corda.core.contracts.PartyAndReference[DeserializedPropertyDescriptor]

'owningKey' @ [698:34] ==> public final val owningKey: PublicKey defined in net.corda.core.identity.AbstractParty[DeserializedPropertyDescriptor]

'Issue' @ [698:72] ==> public constructor Issue() defined in net.corda.finance.contracts.CommercialPaper.Commands.Issue[DeserializedClassConstructorDescriptor]

'!' @ [699:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'withError' @ [699:18] ==> value-parameter withError: Boolean defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForSeller[ValueParameterDescriptorImpl]

'timeWindow' @ [700:17] ==> @JvmOverloads public final fun timeWindow(time: Instant, tolerance: Duration = ...): Unit defined in net.corda.testing.TransactionDSL[DeserializedSimpleFunctionDescriptor]

'TEST_TX_TIME' @ [700:35] ==> public val TEST_TX_TIME: Instant defined in net.corda.testing[DeserializedPropertyDescriptor]

'attachmentID' @ [701:17] ==> value-parameter attachmentID: SecureHash? defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForSeller[ValueParameterDescriptorImpl]

'attachment' @ [702:17] ==> public open fun attachment(attachmentId: SecureHash): Unit defined in net.corda.testing.TransactionDSL[DeserializedSimpleFunctionDescriptor]

'attachmentID' @ [702:28] ==> value-parameter attachmentID: SecureHash? defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForSeller[ValueParameterDescriptorImpl]

'if (withError) {
                this.fails()
            } else {
                this.verifies()
            }' @ [703:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: EnforceVerifyOrFail, elseBranch: EnforceVerifyOrFail): EnforceVerifyOrFail[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> EnforceVerifyOrFail

'withError' @ [703:17] ==> value-parameter withError: Boolean defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForSeller[ValueParameterDescriptorImpl]

'this' @ [704:17] ==> <this> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForSeller.<anonymous>[ReceiverParameterDescriptorImpl]

'fails' @ [704:22] ==> public open fun fails(): EnforceVerifyOrFail defined in net.corda.testing.TransactionDSL[DeserializedSimpleFunctionDescriptor]

'this' @ [706:17] ==> <this> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForSeller.<anonymous>[ReceiverParameterDescriptorImpl]

'verifies' @ [706:22] ==> public open fun verifies(): EnforceVerifyOrFail defined in net.corda.testing.TransactionDSL[DeserializedSimpleFunctionDescriptor]

'Vault' @ [710:21] ==> public constructor Vault<out T : ContractState>(states: Iterable<StateAndRef<ContractState>>) defined in net.corda.core.node.services.Vault[DeserializedClassConstructorDescriptor]
Inferred types:
    <out T : ContractState> -> ContractState

'listOf' @ [710:42] ==> public fun <T> listOf(element: StateAndRef<Nothing>): List<StateAndRef<Nothing>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> StateAndRef<Nothing>

'outputStateAndRef' @ [710:65] ==> public final inline fun <reified S : ContractState> String.outputStateAndRef(): StateAndRef<Nothing> defined in net.corda.testing.LedgerDSL[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified S : ContractState> -> Nothing

'Pair' @ [711:16] ==> public constructor Pair<out A, out B>(first: Vault<ContractState>, second: List<WireTransaction>) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> Vault<ContractState>
    <out B> -> List<WireTransaction>

'vault' @ [711:21] ==> val vault: Vault<ContractState> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForSeller[LocalVariableDescriptor]

'listOf' @ [711:28] ==> public fun <T> listOf(element: WireTransaction): List<WireTransaction> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> WireTransaction

'ap' @ [711:35] ==> val ap: WireTransaction defined in net.corda.node.messaging.TwoPartyTradeFlowTests.fillUpForSeller[LocalVariableDescriptor]

'database' @ [717:20] ==> public final val database: CordaPersistence defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RecordingTransactionStorage[PropertyDescriptorImpl]

'transaction' @ [717:29] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> DataFeed<List<SignedTransaction>, SignedTransaction>): DataFeed<List<SignedTransaction>, SignedTransaction> defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> DataFeed<List<SignedTransaction>, SignedTransaction>

'delegate' @ [718:17] ==> public final val delegate: WritableTransactionStorage defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RecordingTransactionStorage[PropertyDescriptorImpl]

'track' @ [718:26] ==> public abstract fun track(): DataFeed<List<SignedTransaction>, SignedTransaction> defined in net.corda.node.services.api.WritableTransactionStorage[DeserializedSimpleFunctionDescriptor]

'synchronizedList' @ [722:58] ==> public open fun <T : (Any..Any?)> synchronizedList(p0: (MutableList<(TwoPartyTradeFlowTests.TxRecord..TwoPartyTradeFlowTests.TxRecord?)>..List<(TwoPartyTradeFlowTests.TxRecord..TwoPartyTradeFlowTests.TxRecord?)>?)): (MutableList<(TwoPartyTradeFlowTests.TxRecord..TwoPartyTradeFlowTests.TxRecord?)>..List<(TwoPartyTradeFlowTests.TxRecord..TwoPartyTradeFlowTests.TxRecord?)>?) defined in java.util.Collections[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> TxRecord

'ArrayList' @ [722:75] ==> public constructor ArrayList<E : (Any..Any?)>() defined in java.util.ArrayList[JavaClassConstructorDescriptor]
Inferred types:
    <E : (Any..Any?)> -> TxRecord

'delegate' @ [724:21] ==> public final val delegate: WritableTransactionStorage defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RecordingTransactionStorage[PropertyDescriptorImpl]

'updates' @ [724:30] ==> public abstract val updates: Observable<SignedTransaction> defined in net.corda.node.services.api.WritableTransactionStorage[DeserializedPropertyDescriptor]

'database' @ [727:13] ==> public final val database: CordaPersistence defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RecordingTransactionStorage[PropertyDescriptorImpl]

'transaction' @ [727:22] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> Boolean): Boolean defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Boolean

'records' @ [728:17] ==> public final val records: MutableList<TwoPartyTradeFlowTests.TxRecord> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RecordingTransactionStorage[PropertyDescriptorImpl]

'add' @ [728:25] ==> public abstract fun add(element: TwoPartyTradeFlowTests.TxRecord): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'Add' @ [728:38] ==> public constructor Add(transaction: SignedTransaction) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.TxRecord.Add[ClassConstructorDescriptorImpl]

'transaction' @ [728:42] ==> value-parameter transaction: SignedTransaction defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RecordingTransactionStorage.addTransaction[ValueParameterDescriptorImpl]

'delegate' @ [729:17] ==> public final val delegate: WritableTransactionStorage defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RecordingTransactionStorage[PropertyDescriptorImpl]

'addTransaction' @ [729:26] ==> public abstract fun addTransaction(transaction: SignedTransaction): Boolean defined in net.corda.node.services.api.WritableTransactionStorage[DeserializedSimpleFunctionDescriptor]

'transaction' @ [729:41] ==> value-parameter transaction: SignedTransaction defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RecordingTransactionStorage.addTransaction[ValueParameterDescriptorImpl]

'database' @ [735:20] ==> public final val database: CordaPersistence defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RecordingTransactionStorage[PropertyDescriptorImpl]

'transaction' @ [735:29] ==> public final fun <T> transaction(statement: DatabaseTransaction.() -> SignedTransaction?): SignedTransaction? defined in net.corda.node.utilities.CordaPersistence[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SignedTransaction?

'records' @ [736:17] ==> public final val records: MutableList<TwoPartyTradeFlowTests.TxRecord> defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RecordingTransactionStorage[PropertyDescriptorImpl]

'add' @ [736:25] ==> public abstract fun add(element: TwoPartyTradeFlowTests.TxRecord): Boolean defined in kotlin.collections.MutableList[DeserializedSimpleFunctionDescriptor]

'Get' @ [736:38] ==> public constructor Get(id: SecureHash) defined in net.corda.node.messaging.TwoPartyTradeFlowTests.TxRecord.Get[ClassConstructorDescriptorImpl]

'id' @ [736:42] ==> value-parameter id: SecureHash defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RecordingTransactionStorage.getTransaction[ValueParameterDescriptorImpl]

'delegate' @ [737:17] ==> public final val delegate: WritableTransactionStorage defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RecordingTransactionStorage[PropertyDescriptorImpl]

'getTransaction' @ [737:26] ==> public abstract fun getTransaction(id: SecureHash): SignedTransaction? defined in net.corda.node.services.api.WritableTransactionStorage[DeserializedSimpleFunctionDescriptor]

'id' @ [737:41] ==> value-parameter id: SecureHash defined in net.corda.node.messaging.TwoPartyTradeFlowTests.RecordingTransactionStorage.getTransaction[ValueParameterDescriptorImpl]

