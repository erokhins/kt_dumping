'Before' @ [38:5] ==> public constructor Before() defined in org.junit.Before[JavaClassConstructorDescriptor]

'mockNet' @ [40:9] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'MockNetwork' @ [40:19] ==> public constructor MockNetwork(networkSendManuallyPumped: Boolean = ..., threadPerNode: Boolean = ..., servicePeerAllocationStrategy: InMemoryMessagingNetwork.ServicePeerAllocationStrategy = ..., defaultFactory: MockNetwork.Factory<*> = ..., initialiseSerialization: Boolean = ...) defined in net.corda.testing.node.MockNetwork[DeserializedClassConstructorDescriptor]

'oldNotaryNode' @ [41:9] ==> public final lateinit var oldNotaryNode: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'mockNet' @ [41:25] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'createNode' @ [41:33] ==> public final fun createNode(networkMapAddress: SingleMessageRecipient? = ..., forcedID: Int? = ..., start: Boolean = ..., legalName: X500Name? = ..., overrideServices: Map<ServiceInfo, KeyPair>? = ..., entropyRoot: BigInteger = ..., vararg advertisedServices: ServiceInfo, configOverrides: (NodeConfiguration) -> Any? = ...): MockNetwork.MockNode defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'DUMMY_NOTARY' @ [42:29] ==> public val DUMMY_NOTARY: Party defined in net.corda.testing[DeserializedPropertyDescriptor]

'name' @ [42:42] ==> public final val name: X500Name defined in net.corda.core.identity.Party[DeserializedPropertyDescriptor]

'arrayOf' @ [43:39] ==> public inline fun <reified @PureReifiable T> arrayOf(vararg elements: ServiceInfo): Array<ServiceInfo> defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <reified @PureReifiable T> -> ServiceInfo

'ServiceInfo' @ [43:47] ==> public constructor ServiceInfo(type: ServiceType, name: X500Name? = ...) defined in net.corda.core.node.services.ServiceInfo[DeserializedClassConstructorDescriptor]

'NetworkMapService' @ [43:59] ==> public companion object defined in net.corda.node.services.network.NetworkMapService[FakeCallableDescriptorForObject]

'type' @ [43:77] ==> public final val type: ServiceType defined in net.corda.node.services.network.NetworkMapService.Companion[DeserializedPropertyDescriptor]

'ServiceInfo' @ [43:84] ==> public constructor ServiceInfo(type: ServiceType, name: X500Name? = ...) defined in net.corda.core.node.services.ServiceInfo[DeserializedClassConstructorDescriptor]

'SimpleNotaryService' @ [43:96] ==> public companion object defined in net.corda.node.services.transactions.SimpleNotaryService[FakeCallableDescriptorForObject]

'type' @ [43:116] ==> public final val type: ServiceType defined in net.corda.node.services.transactions.SimpleNotaryService.Companion[DeserializedPropertyDescriptor]

'clientNodeA' @ [44:9] ==> public final lateinit var clientNodeA: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'mockNet' @ [44:23] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'createNode' @ [44:31] ==> public final fun createNode(networkMapAddress: SingleMessageRecipient? = ..., forcedID: Int? = ..., start: Boolean = ..., legalName: X500Name? = ..., overrideServices: Map<ServiceInfo, KeyPair>? = ..., entropyRoot: BigInteger = ..., vararg advertisedServices: ServiceInfo, configOverrides: (NodeConfiguration) -> Any? = ...): MockNetwork.MockNode defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'oldNotaryNode' @ [44:62] ==> public final lateinit var oldNotaryNode: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'network' @ [44:76] ==> public final lateinit var network: MessagingService defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'myAddress' @ [44:84] ==> public abstract val myAddress: SingleMessageRecipient defined in net.corda.node.services.messaging.MessagingService[DeserializedPropertyDescriptor]

'clientNodeB' @ [45:9] ==> public final lateinit var clientNodeB: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'mockNet' @ [45:23] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'createNode' @ [45:31] ==> public final fun createNode(networkMapAddress: SingleMessageRecipient? = ..., forcedID: Int? = ..., start: Boolean = ..., legalName: X500Name? = ..., overrideServices: Map<ServiceInfo, KeyPair>? = ..., entropyRoot: BigInteger = ..., vararg advertisedServices: ServiceInfo, configOverrides: (NodeConfiguration) -> Any? = ...): MockNetwork.MockNode defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'oldNotaryNode' @ [45:62] ==> public final lateinit var oldNotaryNode: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'network' @ [45:76] ==> public final lateinit var network: MessagingService defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'myAddress' @ [45:84] ==> public abstract val myAddress: SingleMessageRecipient defined in net.corda.node.services.messaging.MessagingService[DeserializedPropertyDescriptor]

'newNotaryNode' @ [46:9] ==> public final lateinit var newNotaryNode: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'mockNet' @ [46:25] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'createNode' @ [46:33] ==> public final fun createNode(networkMapAddress: SingleMessageRecipient? = ..., forcedID: Int? = ..., start: Boolean = ..., legalName: X500Name? = ..., overrideServices: Map<ServiceInfo, KeyPair>? = ..., entropyRoot: BigInteger = ..., vararg advertisedServices: ServiceInfo, configOverrides: (NodeConfiguration) -> Any? = ...): MockNetwork.MockNode defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'oldNotaryNode' @ [46:64] ==> public final lateinit var oldNotaryNode: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'network' @ [46:78] ==> public final lateinit var network: MessagingService defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'myAddress' @ [46:86] ==> public abstract val myAddress: SingleMessageRecipient defined in net.corda.node.services.messaging.MessagingService[DeserializedPropertyDescriptor]

'ServiceInfo' @ [46:118] ==> public constructor ServiceInfo(type: ServiceType, name: X500Name? = ...) defined in net.corda.core.node.services.ServiceInfo[DeserializedClassConstructorDescriptor]

'SimpleNotaryService' @ [46:130] ==> public companion object defined in net.corda.node.services.transactions.SimpleNotaryService[FakeCallableDescriptorForObject]

'type' @ [46:150] ==> public final val type: ServiceType defined in net.corda.node.services.transactions.SimpleNotaryService.Companion[DeserializedPropertyDescriptor]

'mockNet' @ [48:9] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'runNetwork' @ [48:17] ==> @JvmOverloads public final fun runNetwork(rounds: Int = ...): Unit defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'After' @ [51:5] ==> public constructor After() defined in org.junit.After[JavaClassConstructorDescriptor]

'mockNet' @ [53:9] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'stopNodes' @ [53:17] ==> public final fun stopNodes(): Unit defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'Test' @ [56:5] ==> public constructor Test(expected: KClass<out (Throwable..Throwable?)> = ..., timeout: Long = ...) defined in org.junit.Test[JavaClassConstructorDescriptor]

'issueState' @ [58:21] ==> public fun issueState(node: AbstractNode, notaryNode: AbstractNode): StateAndRef<*> defined in net.corda.node.services in file NotaryChangeTests.kt[SimpleFunctionDescriptorImpl]

'clientNodeA' @ [58:32] ==> public final lateinit var clientNodeA: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'oldNotaryNode' @ [58:45] ==> public final lateinit var oldNotaryNode: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'newNotaryNode' @ [59:25] ==> public final lateinit var newNotaryNode: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'info' @ [59:39] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'notaryIdentity' @ [59:44] ==> public final val notaryIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'NotaryChangeFlow' @ [60:20] ==> public constructor NotaryChangeFlow<out T : ContractState>(originalState: StateAndRef<ContractState>, newNotary: Party, progressTracker: ProgressTracker = ...) defined in net.corda.core.flows.NotaryChangeFlow[DeserializedClassConstructorDescriptor]
Inferred types:
    <out T : ContractState> -> ContractState

'state' @ [60:37] ==> val state: StateAndRef<*> defined in net.corda.node.services.NotaryChangeTests.`should change notary for a state with single participant`[LocalVariableDescriptor]

'newNotary' @ [60:44] ==> val newNotary: Party defined in net.corda.node.services.NotaryChangeTests.`should change notary for a state with single participant`[LocalVariableDescriptor]

'clientNodeA' @ [61:22] ==> public final lateinit var clientNodeA: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'services' @ [61:34] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'startFlow' @ [61:43] ==> public open fun <T> startFlow(logic: FlowLogic<StateAndRef<ContractState>>): FlowStateMachine<StateAndRef<ContractState>> defined in net.corda.node.services.api.ServiceHubInternal[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> StateAndRef<ContractState>

'flow' @ [61:53] ==> val flow: NotaryChangeFlow<ContractState> defined in net.corda.node.services.NotaryChangeTests.`should change notary for a state with single participant`[LocalVariableDescriptor]

'mockNet' @ [63:9] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'runNetwork' @ [63:17] ==> @JvmOverloads public final fun runNetwork(rounds: Int = ...): Unit defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'future' @ [65:24] ==> val future: FlowStateMachine<StateAndRef<ContractState>> defined in net.corda.node.services.NotaryChangeTests.`should change notary for a state with single participant`[LocalVariableDescriptor]

'resultFuture' @ [65:31] ==> public abstract val resultFuture: CordaFuture<StateAndRef<ContractState>> defined in net.corda.core.internal.FlowStateMachine[DeserializedPropertyDescriptor]

'getOrThrow' @ [65:44] ==> public fun <V> Future<StateAndRef<ContractState>>.getOrThrow(timeout: Duration? = ...): StateAndRef<ContractState> defined in net.corda.core.utilities[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <V> -> StateAndRef<ContractState>

'assertEquals' @ [66:9] ==> public fun <@OnlyInputTypes T> assertEquals(expected: Party, actual: Party, message: String? = ...): Unit defined in kotlin.test[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <@OnlyInputTypes T> -> Party

'newState' @ [66:22] ==> val newState: StateAndRef<ContractState> defined in net.corda.node.services.NotaryChangeTests.`should change notary for a state with single participant`[LocalVariableDescriptor]

'state' @ [66:31] ==> public final val state: TransactionState<ContractState> defined in net.corda.core.contracts.StateAndRef[DeserializedPropertyDescriptor]

'notary' @ [66:37] ==> public final val notary: Party defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'newNotary' @ [66:45] ==> val newNotary: Party defined in net.corda.node.services.NotaryChangeTests.`should change notary for a state with single participant`[LocalVariableDescriptor]

'Test' @ [69:5] ==> public constructor Test(expected: KClass<out (Throwable..Throwable?)> = ..., timeout: Long = ...) defined in org.junit.Test[JavaClassConstructorDescriptor]

'issueMultiPartyState' @ [71:21] ==> public fun issueMultiPartyState(nodeA: AbstractNode, nodeB: AbstractNode, notaryNode: AbstractNode): StateAndRef<DummyContract.MultiOwnerState> defined in net.corda.node.services[SimpleFunctionDescriptorImpl]

'clientNodeA' @ [71:42] ==> public final lateinit var clientNodeA: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'clientNodeB' @ [71:55] ==> public final lateinit var clientNodeB: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'oldNotaryNode' @ [71:68] ==> public final lateinit var oldNotaryNode: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'newNotaryNode' @ [72:25] ==> public final lateinit var newNotaryNode: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'info' @ [72:39] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'notaryIdentity' @ [72:44] ==> public final val notaryIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'NotaryChangeFlow' @ [73:20] ==> public constructor NotaryChangeFlow<out T : ContractState>(originalState: StateAndRef<DummyContract.MultiOwnerState>, newNotary: Party, progressTracker: ProgressTracker = ...) defined in net.corda.core.flows.NotaryChangeFlow[DeserializedClassConstructorDescriptor]
Inferred types:
    <out T : ContractState> -> MultiOwnerState

'state' @ [73:37] ==> val state: StateAndRef<DummyContract.MultiOwnerState> defined in net.corda.node.services.NotaryChangeTests.`should change notary for a state with multiple participants`[LocalVariableDescriptor]

'newNotary' @ [73:44] ==> val newNotary: Party defined in net.corda.node.services.NotaryChangeTests.`should change notary for a state with multiple participants`[LocalVariableDescriptor]

'clientNodeA' @ [74:22] ==> public final lateinit var clientNodeA: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'services' @ [74:34] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'startFlow' @ [74:43] ==> public open fun <T> startFlow(logic: FlowLogic<StateAndRef<DummyContract.MultiOwnerState>>): FlowStateMachine<StateAndRef<DummyContract.MultiOwnerState>> defined in net.corda.node.services.api.ServiceHubInternal[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> StateAndRef<MultiOwnerState>

'flow' @ [74:53] ==> val flow: NotaryChangeFlow<DummyContract.MultiOwnerState> defined in net.corda.node.services.NotaryChangeTests.`should change notary for a state with multiple participants`[LocalVariableDescriptor]

'mockNet' @ [76:9] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'runNetwork' @ [76:17] ==> @JvmOverloads public final fun runNetwork(rounds: Int = ...): Unit defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'future' @ [78:24] ==> val future: FlowStateMachine<StateAndRef<DummyContract.MultiOwnerState>> defined in net.corda.node.services.NotaryChangeTests.`should change notary for a state with multiple participants`[LocalVariableDescriptor]

'resultFuture' @ [78:31] ==> public abstract val resultFuture: CordaFuture<StateAndRef<DummyContract.MultiOwnerState>> defined in net.corda.core.internal.FlowStateMachine[DeserializedPropertyDescriptor]

'getOrThrow' @ [78:44] ==> public fun <V> Future<StateAndRef<DummyContract.MultiOwnerState>>.getOrThrow(timeout: Duration? = ...): StateAndRef<DummyContract.MultiOwnerState> defined in net.corda.core.utilities[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <V> -> StateAndRef<MultiOwnerState>

'assertEquals' @ [79:9] ==> public fun <@OnlyInputTypes T> assertEquals(expected: Party, actual: Party, message: String? = ...): Unit defined in kotlin.test[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <@OnlyInputTypes T> -> Party

'newState' @ [79:22] ==> val newState: StateAndRef<DummyContract.MultiOwnerState> defined in net.corda.node.services.NotaryChangeTests.`should change notary for a state with multiple participants`[LocalVariableDescriptor]

'state' @ [79:31] ==> public final val state: TransactionState<DummyContract.MultiOwnerState> defined in net.corda.core.contracts.StateAndRef[DeserializedPropertyDescriptor]

'notary' @ [79:37] ==> public final val notary: Party defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'newNotary' @ [79:45] ==> val newNotary: Party defined in net.corda.node.services.NotaryChangeTests.`should change notary for a state with multiple participants`[LocalVariableDescriptor]

'clientNodeA' @ [80:28] ==> public final lateinit var clientNodeA: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'services' @ [80:40] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'loadState' @ [80:49] ==> public open fun loadState(stateRef: StateRef): TransactionState<*> defined in net.corda.node.services.api.ServiceHubInternal[DeserializedSimpleFunctionDescriptor]

'newState' @ [80:59] ==> val newState: StateAndRef<DummyContract.MultiOwnerState> defined in net.corda.node.services.NotaryChangeTests.`should change notary for a state with multiple participants`[LocalVariableDescriptor]

'ref' @ [80:68] ==> public final val ref: StateRef defined in net.corda.core.contracts.StateAndRef[DeserializedPropertyDescriptor]

'clientNodeB' @ [81:28] ==> public final lateinit var clientNodeB: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'services' @ [81:40] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'loadState' @ [81:49] ==> public open fun loadState(stateRef: StateRef): TransactionState<*> defined in net.corda.node.services.api.ServiceHubInternal[DeserializedSimpleFunctionDescriptor]

'newState' @ [81:59] ==> val newState: StateAndRef<DummyContract.MultiOwnerState> defined in net.corda.node.services.NotaryChangeTests.`should change notary for a state with multiple participants`[LocalVariableDescriptor]

'ref' @ [81:68] ==> public final val ref: StateRef defined in net.corda.core.contracts.StateAndRef[DeserializedPropertyDescriptor]

'assertEquals' @ [82:9] ==> public fun <@OnlyInputTypes T> assertEquals(expected: TransactionState<ContractState>, actual: TransactionState<ContractState>, message: String? = ...): Unit defined in kotlin.test[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <@OnlyInputTypes T> -> TransactionState<ContractState>

'loadedStateA' @ [82:22] ==> val loadedStateA: TransactionState<*> defined in net.corda.node.services.NotaryChangeTests.`should change notary for a state with multiple participants`[LocalVariableDescriptor]

'loadedStateB' @ [82:36] ==> val loadedStateB: TransactionState<*> defined in net.corda.node.services.NotaryChangeTests.`should change notary for a state with multiple participants`[LocalVariableDescriptor]

'Test' @ [85:5] ==> public constructor Test(expected: KClass<out (Throwable..Throwable?)> = ..., timeout: Long = ...) defined in org.junit.Test[JavaClassConstructorDescriptor]

'issueMultiPartyState' @ [87:21] ==> public fun issueMultiPartyState(nodeA: AbstractNode, nodeB: AbstractNode, notaryNode: AbstractNode): StateAndRef<DummyContract.MultiOwnerState> defined in net.corda.node.services[SimpleFunctionDescriptorImpl]

'clientNodeA' @ [87:42] ==> public final lateinit var clientNodeA: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'clientNodeB' @ [87:55] ==> public final lateinit var clientNodeB: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'oldNotaryNode' @ [87:68] ==> public final lateinit var oldNotaryNode: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'getTestPartyAndCertificate' @ [88:29] ==> public fun getTestPartyAndCertificate(name: X500Name, publicKey: PublicKey, trustRoot: CertificateAndKeyPair = ...): PartyAndCertificate defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]

'X500Name' @ [88:56] ==> public constructor X500Name(p0: (String..String?)) defined in org.bouncycastle.asn1.x500.X500Name[JavaClassConstructorDescriptor]

'generateKeyPair' @ [88:117] ==> public fun generateKeyPair(): KeyPair defined in net.corda.core.crypto[DeserializedSimpleFunctionDescriptor]

'public' @ [88:135] ==> public final val KeyPair.public: (PublicKey..PublicKey?)[MyPropertyDescriptor]

'NotaryChangeFlow' @ [89:20] ==> public constructor NotaryChangeFlow<out T : ContractState>(originalState: StateAndRef<DummyContract.MultiOwnerState>, newNotary: Party, progressTracker: ProgressTracker = ...) defined in net.corda.core.flows.NotaryChangeFlow[DeserializedClassConstructorDescriptor]
Inferred types:
    <out T : ContractState> -> MultiOwnerState

'state' @ [89:37] ==> val state: StateAndRef<DummyContract.MultiOwnerState> defined in net.corda.node.services.NotaryChangeTests.`should throw when a participant refuses to change Notary`[LocalVariableDescriptor]

'newEvilNotary' @ [89:44] ==> val newEvilNotary: PartyAndCertificate defined in net.corda.node.services.NotaryChangeTests.`should throw when a participant refuses to change Notary`[LocalVariableDescriptor]

'party' @ [89:58] ==> public final val party: Party defined in net.corda.core.identity.PartyAndCertificate[DeserializedPropertyDescriptor]

'clientNodeA' @ [90:22] ==> public final lateinit var clientNodeA: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'services' @ [90:34] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'startFlow' @ [90:43] ==> public open fun <T> startFlow(logic: FlowLogic<StateAndRef<DummyContract.MultiOwnerState>>): FlowStateMachine<StateAndRef<DummyContract.MultiOwnerState>> defined in net.corda.node.services.api.ServiceHubInternal[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> StateAndRef<MultiOwnerState>

'flow' @ [90:53] ==> val flow: NotaryChangeFlow<DummyContract.MultiOwnerState> defined in net.corda.node.services.NotaryChangeTests.`should throw when a participant refuses to change Notary`[LocalVariableDescriptor]

'mockNet' @ [92:9] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'runNetwork' @ [92:17] ==> @JvmOverloads public final fun runNetwork(rounds: Int = ...): Unit defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'assertThatExceptionOfType' @ [94:9] ==> @CheckReturnValue public open fun <T : (Throwable..Throwable?)> assertThatExceptionOfType(p0: (Class<out (StateReplacementException..StateReplacementException?)>..Class<out (StateReplacementException..StateReplacementException?)>?)): (ThrowableTypeAssert<(StateReplacementException..StateReplacementException?)>..ThrowableTypeAssert<(StateReplacementException..StateReplacementException?)>?) defined in org.assertj.core.api.Assertions[JavaMethodDescriptor]
Inferred types:
    <T : (Throwable..Throwable?)> -> StateReplacementException

'StateReplacementException' @ [94:35] ==> @JvmOverloads public constructor StateReplacementException(message: String? = ..., cause: Throwable? = ...) defined in net.corda.core.flows.StateReplacementException[DeserializedClassConstructorDescriptor]

'java' @ [94:68] ==> public val <T> KClass<StateReplacementException>.java: Class<StateReplacementException> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> StateReplacementException

'isThrownBy' @ [94:74] ==> public final fun isThrownBy(p0: (() -> Unit..(() -> Unit)?)): (ThrowableAssertAlternative<(StateReplacementException..StateReplacementException?)>..ThrowableAssertAlternative<(StateReplacementException..StateReplacementException?)>?) defined in org.assertj.core.api.ThrowableTypeAssert[MyFunctionDescriptor]

'future' @ [95:13] ==> val future: FlowStateMachine<StateAndRef<DummyContract.MultiOwnerState>> defined in net.corda.node.services.NotaryChangeTests.`should throw when a participant refuses to change Notary`[LocalVariableDescriptor]

'resultFuture' @ [95:20] ==> public abstract val resultFuture: CordaFuture<StateAndRef<DummyContract.MultiOwnerState>> defined in net.corda.core.internal.FlowStateMachine[DeserializedPropertyDescriptor]

'getOrThrow' @ [95:33] ==> public fun <V> Future<StateAndRef<DummyContract.MultiOwnerState>>.getOrThrow(timeout: Duration? = ...): StateAndRef<DummyContract.MultiOwnerState> defined in net.corda.core.utilities[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <V> -> StateAndRef<MultiOwnerState>

'Test' @ [99:5] ==> public constructor Test(expected: KClass<out (Throwable..Throwable?)> = ..., timeout: Long = ...) defined in org.junit.Test[JavaClassConstructorDescriptor]

'issueEncumberedState' @ [101:23] ==> private final fun issueEncumberedState(node: AbstractNode, notaryNode: AbstractNode): WireTransaction defined in net.corda.node.services.NotaryChangeTests[SimpleFunctionDescriptorImpl]

'clientNodeA' @ [101:44] ==> public final lateinit var clientNodeA: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'oldNotaryNode' @ [101:57] ==> public final lateinit var oldNotaryNode: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'StateAndRef' @ [103:21] ==> public constructor StateAndRef<out T : ContractState>(state: TransactionState<ContractState>, ref: StateRef) defined in net.corda.core.contracts.StateAndRef[DeserializedClassConstructorDescriptor]
Inferred types:
    <out T : ContractState> -> ContractState

'issueTx' @ [103:33] ==> val issueTx: WireTransaction defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`[LocalVariableDescriptor]

'outputs' @ [103:41] ==> public open val outputs: List<TransactionState<ContractState>> defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'first' @ [103:49] ==> public fun <T> List<TransactionState<ContractState>>.first(): TransactionState<ContractState> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TransactionState<ContractState>

'StateRef' @ [103:58] ==> public constructor StateRef(txhash: SecureHash, index: Int) defined in net.corda.core.contracts.StateRef[DeserializedClassConstructorDescriptor]

'issueTx' @ [103:67] ==> val issueTx: WireTransaction defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`[LocalVariableDescriptor]

'id' @ [103:75] ==> public open val id: SecureHash defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'newNotaryNode' @ [104:25] ==> public final lateinit var newNotaryNode: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'info' @ [104:39] ==> public final lateinit var info: NodeInfo defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'notaryIdentity' @ [104:44] ==> public final val notaryIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'NotaryChangeFlow' @ [105:20] ==> public constructor NotaryChangeFlow<out T : ContractState>(originalState: StateAndRef<ContractState>, newNotary: Party, progressTracker: ProgressTracker = ...) defined in net.corda.core.flows.NotaryChangeFlow[DeserializedClassConstructorDescriptor]
Inferred types:
    <out T : ContractState> -> ContractState

'state' @ [105:37] ==> val state: StateAndRef<ContractState> defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`[LocalVariableDescriptor]

'newNotary' @ [105:44] ==> val newNotary: Party defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`[LocalVariableDescriptor]

'clientNodeA' @ [106:22] ==> public final lateinit var clientNodeA: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'services' @ [106:34] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'startFlow' @ [106:43] ==> public open fun <T> startFlow(logic: FlowLogic<StateAndRef<ContractState>>): FlowStateMachine<StateAndRef<ContractState>> defined in net.corda.node.services.api.ServiceHubInternal[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> StateAndRef<ContractState>

'flow' @ [106:53] ==> val flow: NotaryChangeFlow<ContractState> defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`[LocalVariableDescriptor]

'mockNet' @ [107:9] ==> public final lateinit var mockNet: MockNetwork defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'runNetwork' @ [107:17] ==> @JvmOverloads public final fun runNetwork(rounds: Int = ...): Unit defined in net.corda.testing.node.MockNetwork[DeserializedSimpleFunctionDescriptor]

'future' @ [108:24] ==> val future: FlowStateMachine<StateAndRef<ContractState>> defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`[LocalVariableDescriptor]

'resultFuture' @ [108:31] ==> public abstract val resultFuture: CordaFuture<StateAndRef<ContractState>> defined in net.corda.core.internal.FlowStateMachine[DeserializedPropertyDescriptor]

'getOrThrow' @ [108:44] ==> public fun <V> Future<StateAndRef<ContractState>>.getOrThrow(timeout: Duration? = ...): StateAndRef<ContractState> defined in net.corda.core.utilities[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <V> -> StateAndRef<ContractState>

'assertEquals' @ [109:9] ==> public fun <@OnlyInputTypes T> assertEquals(expected: Party, actual: Party, message: String? = ...): Unit defined in kotlin.test[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <@OnlyInputTypes T> -> Party

'newState' @ [109:22] ==> val newState: StateAndRef<ContractState> defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`[LocalVariableDescriptor]

'state' @ [109:31] ==> public final val state: TransactionState<ContractState> defined in net.corda.core.contracts.StateAndRef[DeserializedPropertyDescriptor]

'notary' @ [109:37] ==> public final val notary: Party defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'newNotary' @ [109:45] ==> val newNotary: Party defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`[LocalVariableDescriptor]

'clientNodeA' @ [111:26] ==> public final lateinit var clientNodeA: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'services' @ [111:38] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'validatedTransactions' @ [111:47] ==> public abstract val validatedTransactions: WritableTransactionStorage defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'getTransaction' @ [111:69] ==> public abstract fun getTransaction(id: SecureHash): SignedTransaction? defined in net.corda.node.services.api.WritableTransactionStorage[DeserializedSimpleFunctionDescriptor]

'newState' @ [111:84] ==> val newState: StateAndRef<ContractState> defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`[LocalVariableDescriptor]

'ref' @ [111:93] ==> public final val ref: StateRef defined in net.corda.core.contracts.StateAndRef[DeserializedPropertyDescriptor]

'txhash' @ [111:97] ==> public final val txhash: SecureHash defined in net.corda.core.contracts.StateRef[DeserializedPropertyDescriptor]

'recordedTx' @ [112:30] ==> val recordedTx: SignedTransaction defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`[LocalVariableDescriptor]

'resolveNotaryChangeTransaction' @ [112:41] ==> public final fun resolveNotaryChangeTransaction(services: ServiceHub): NotaryChangeLedgerTransaction defined in net.corda.core.transactions.SignedTransaction[DeserializedSimpleFunctionDescriptor]

'clientNodeA' @ [112:72] ==> public final lateinit var clientNodeA: MockNetwork.MockNode defined in net.corda.node.services.NotaryChangeTests[PropertyDescriptorImpl]

'services' @ [112:84] ==> public final val services: ServiceHubInternal defined in net.corda.testing.node.MockNetwork.MockNode[DeserializedPropertyDescriptor]

'issueTx' @ [115:31] ==> val issueTx: WireTransaction defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`[LocalVariableDescriptor]

'outputStates' @ [115:39] ==> public final val outputStates: List<ContractState> defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'notaryChangeTx' @ [116:26] ==> val notaryChangeTx: NotaryChangeLedgerTransaction defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`[LocalVariableDescriptor]

'outputStates' @ [116:41] ==> public final val outputStates: List<ContractState> defined in net.corda.core.transactions.NotaryChangeLedgerTransaction[DeserializedPropertyDescriptor]

'assertTrue' @ [117:9] ==> public fun assertTrue(actual: Boolean, message: String? = ...): Unit defined in kotlin.test[DeserializedSimpleFunctionDescriptor]

'originalOutputs' @ [117:20] ==> val originalOutputs: List<ContractState> defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`[LocalVariableDescriptor]

'minus' @ [117:36] ==> public operator fun <T> Iterable<ContractState>.minus(elements: Iterable<ContractState>): List<ContractState> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> ContractState

'newOutputs' @ [117:42] ==> val newOutputs: List<ContractState> defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`[LocalVariableDescriptor]

'isEmpty' @ [117:54] ==> public abstract fun isEmpty(): Boolean defined in kotlin.collections.List[DeserializedSimpleFunctionDescriptor]

'HashMap' @ [120:31] ==> public constructor HashMap<K : (Any..Any?), V : (Any..Any?)>() defined in java.util.HashMap[JavaClassConstructorDescriptor]
Inferred types:
    <K : (Any..Any?)> -> ContractState
    <V : (Any..Any?)> -> ContractState?

'issueTx' @ [121:9] ==> val issueTx: WireTransaction defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`[LocalVariableDescriptor]

'outputs' @ [121:17] ==> public open val outputs: List<TransactionState<ContractState>> defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'forEach' @ [121:25] ==> @HidesMembers public inline fun <T> Iterable<TransactionState<ContractState>>.forEach(action: (TransactionState<ContractState>) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TransactionState<ContractState>

'it' @ [122:32] ==> value-parameter it: TransactionState<ContractState> defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`.<anonymous>[ValueParameterDescriptorImpl]

'data' @ [122:35] ==> public final val data: ContractState defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'it' @ [123:36] ==> value-parameter it: TransactionState<ContractState> defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`.<anonymous>[ValueParameterDescriptorImpl]

'encumbrance' @ [123:39] ==> public final val encumbrance: Int? defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'let' @ [123:52] ==> @InlineOnly public inline fun <T, R> Int.let(block: (Int) -> ContractState): ContractState defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Int
    <R> -> ContractState

'issueTx' @ [123:58] ==> val issueTx: WireTransaction defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`[LocalVariableDescriptor]

'outputs' @ [123:66] ==> public open val outputs: List<TransactionState<ContractState>> defined in net.corda.core.transactions.WireTransaction[DeserializedPropertyDescriptor]

'it' @ [123:74] ==> value-parameter it: Int defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'data' @ [123:78] ==> public final val data: ContractState defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'encumbranceLink' @ [124:13] ==> val encumbranceLink: HashMap<ContractState, ContractState?> defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`[LocalVariableDescriptor]

'currentState' @ [124:29] ==> val currentState: ContractState defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`.<anonymous>[LocalVariableDescriptor]

'encumbranceState' @ [124:45] ==> val encumbranceState: ContractState? defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`.<anonymous>[LocalVariableDescriptor]

'notaryChangeTx' @ [126:9] ==> val notaryChangeTx: NotaryChangeLedgerTransaction defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`[LocalVariableDescriptor]

'outputs' @ [126:24] ==> public open val outputs: List<TransactionState<ContractState>> defined in net.corda.core.transactions.NotaryChangeLedgerTransaction[DeserializedPropertyDescriptor]

'forEach' @ [126:32] ==> @HidesMembers public inline fun <T> Iterable<TransactionState<ContractState>>.forEach(action: (TransactionState<ContractState>) -> Unit): Unit defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TransactionState<ContractState>

'it' @ [127:32] ==> value-parameter it: TransactionState<ContractState> defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`.<anonymous>[ValueParameterDescriptorImpl]

'data' @ [127:35] ==> public final val data: ContractState defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'it' @ [128:36] ==> value-parameter it: TransactionState<ContractState> defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`.<anonymous>[ValueParameterDescriptorImpl]

'encumbrance' @ [128:39] ==> public final val encumbrance: Int? defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'let' @ [128:52] ==> @InlineOnly public inline fun <T, R> Int.let(block: (Int) -> ContractState): ContractState defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Int
    <R> -> ContractState

'notaryChangeTx' @ [128:58] ==> val notaryChangeTx: NotaryChangeLedgerTransaction defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`[LocalVariableDescriptor]

'outputs' @ [128:73] ==> public open val outputs: List<TransactionState<ContractState>> defined in net.corda.core.transactions.NotaryChangeLedgerTransaction[DeserializedPropertyDescriptor]

'it' @ [128:81] ==> value-parameter it: Int defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'data' @ [128:85] ==> public final val data: ContractState defined in net.corda.core.contracts.TransactionState[DeserializedPropertyDescriptor]

'assertEquals' @ [129:13] ==> public fun <@OnlyInputTypes T> assertEquals(expected: ContractState?, actual: ContractState?, message: String? = ...): Unit defined in kotlin.test[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <@OnlyInputTypes T> -> ContractState?

'encumbranceLink' @ [129:26] ==> val encumbranceLink: HashMap<ContractState, ContractState?> defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`[LocalVariableDescriptor]

'currentState' @ [129:42] ==> val currentState: ContractState defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`.<anonymous>[LocalVariableDescriptor]

'encumbranceState' @ [129:57] ==> val encumbranceState: ContractState? defined in net.corda.node.services.NotaryChangeTests.`should not break encumbrance links`.<anonymous>[LocalVariableDescriptor]

'node' @ [134:21] ==> value-parameter node: AbstractNode defined in net.corda.node.services.NotaryChangeTests.issueEncumberedState[ValueParameterDescriptorImpl]

'info' @ [134:26] ==> public final lateinit var info: NodeInfo defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [134:31] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'ref' @ [134:45] ==> public final fun ref(vararg bytes: Byte): PartyAndReference defined in net.corda.core.identity.Party[DeserializedSimpleFunctionDescriptor]

'notaryNode' @ [135:22] ==> value-parameter notaryNode: AbstractNode defined in net.corda.node.services.NotaryChangeTests.issueEncumberedState[ValueParameterDescriptorImpl]

'info' @ [135:33] ==> public final lateinit var info: NodeInfo defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'notaryIdentity' @ [135:38] ==> public final val notaryIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'DummyContract' @ [137:22] ==> public companion object defined in net.corda.testing.contracts.DummyContract[FakeCallableDescriptorForObject]

'SingleOwnerState' @ [137:36] ==> public constructor SingleOwnerState(magicNumber: Int = ..., owner: AbstractParty) defined in net.corda.testing.contracts.DummyContract.SingleOwnerState[DeserializedClassConstructorDescriptor]

'Random' @ [137:53] ==> public constructor Random() defined in java.util.Random[JavaClassConstructorDescriptor]

'nextInt' @ [137:62] ==> public open fun nextInt(): Int defined in java.util.Random[JavaMethodDescriptor]

'owner' @ [137:73] ==> val owner: PartyAndReference defined in net.corda.node.services.NotaryChangeTests.issueEncumberedState[LocalVariableDescriptor]

'party' @ [137:79] ==> public final val party: AbstractParty defined in net.corda.core.contracts.PartyAndReference[DeserializedPropertyDescriptor]

'DummyContract' @ [138:22] ==> public companion object defined in net.corda.testing.contracts.DummyContract[FakeCallableDescriptorForObject]

'SingleOwnerState' @ [138:36] ==> public constructor SingleOwnerState(magicNumber: Int = ..., owner: AbstractParty) defined in net.corda.testing.contracts.DummyContract.SingleOwnerState[DeserializedClassConstructorDescriptor]

'Random' @ [138:53] ==> public constructor Random() defined in java.util.Random[JavaClassConstructorDescriptor]

'nextInt' @ [138:62] ==> public open fun nextInt(): Int defined in java.util.Random[JavaMethodDescriptor]

'owner' @ [138:73] ==> val owner: PartyAndReference defined in net.corda.node.services.NotaryChangeTests.issueEncumberedState[LocalVariableDescriptor]

'party' @ [138:79] ==> public final val party: AbstractParty defined in net.corda.core.contracts.PartyAndReference[DeserializedPropertyDescriptor]

'DummyContract' @ [139:22] ==> public companion object defined in net.corda.testing.contracts.DummyContract[FakeCallableDescriptorForObject]

'SingleOwnerState' @ [139:36] ==> public constructor SingleOwnerState(magicNumber: Int = ..., owner: AbstractParty) defined in net.corda.testing.contracts.DummyContract.SingleOwnerState[DeserializedClassConstructorDescriptor]

'Random' @ [139:53] ==> public constructor Random() defined in java.util.Random[JavaClassConstructorDescriptor]

'nextInt' @ [139:62] ==> public open fun nextInt(): Int defined in java.util.Random[JavaMethodDescriptor]

'owner' @ [139:73] ==> val owner: PartyAndReference defined in net.corda.node.services.NotaryChangeTests.issueEncumberedState[LocalVariableDescriptor]

'party' @ [139:79] ==> public final val party: AbstractParty defined in net.corda.core.contracts.PartyAndReference[DeserializedPropertyDescriptor]

'TransactionBuilder' @ [141:18] ==> public constructor TransactionBuilder(notary: Party? = ..., lockId: UUID = ..., inputs: MutableList<StateRef> = ..., attachments: MutableList<SecureHash> = ..., outputs: MutableList<TransactionState<ContractState>> = ..., commands: MutableList<Command<*>> = ..., window: TimeWindow? = ..., privacySalt: PrivacySalt = ...) defined in net.corda.core.transactions.TransactionBuilder[DeserializedClassConstructorDescriptor]

'apply' @ [141:43] ==> @InlineOnly public inline fun <T> TransactionBuilder.apply(block: TransactionBuilder.() -> Unit): TransactionBuilder defined in kotlin[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TransactionBuilder

'addCommand' @ [142:13] ==> public final fun addCommand(arg: Command<*>): TransactionBuilder defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'Command' @ [142:24] ==> public constructor Command<T : CommandData>(data: DummyContract.Commands.Create, key: PublicKey) defined in net.corda.core.contracts.Command[DeserializedClassConstructorDescriptor]
Inferred types:
    <T : CommandData> -> Create

'DummyContract' @ [142:32] ==> public companion object defined in net.corda.testing.contracts.DummyContract[FakeCallableDescriptorForObject]

'Create' @ [142:55] ==> public constructor Create() defined in net.corda.testing.contracts.DummyContract.Commands.Create[DeserializedClassConstructorDescriptor]

'owner' @ [142:65] ==> val owner: PartyAndReference defined in net.corda.node.services.NotaryChangeTests.issueEncumberedState[LocalVariableDescriptor]

'party' @ [142:71] ==> public final val party: AbstractParty defined in net.corda.core.contracts.PartyAndReference[DeserializedPropertyDescriptor]

'owningKey' @ [142:77] ==> public final val owningKey: PublicKey defined in net.corda.core.identity.AbstractParty[DeserializedPropertyDescriptor]

'addOutputState' @ [143:13] ==> @JvmOverloads public final fun addOutputState(state: ContractState, notary: Party, encumbrance: Int? = ...): TransactionBuilder defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'stateA' @ [143:28] ==> val stateA: DummyContract.SingleOwnerState defined in net.corda.node.services.NotaryChangeTests.issueEncumberedState[LocalVariableDescriptor]

'notary' @ [143:36] ==> val notary: Party defined in net.corda.node.services.NotaryChangeTests.issueEncumberedState[LocalVariableDescriptor]

'addOutputState' @ [144:13] ==> @JvmOverloads public final fun addOutputState(state: ContractState, notary: Party, encumbrance: Int? = ...): TransactionBuilder defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'stateC' @ [144:28] ==> val stateC: DummyContract.SingleOwnerState defined in net.corda.node.services.NotaryChangeTests.issueEncumberedState[LocalVariableDescriptor]

'notary' @ [144:36] ==> val notary: Party defined in net.corda.node.services.NotaryChangeTests.issueEncumberedState[LocalVariableDescriptor]

'addOutputState' @ [145:13] ==> @JvmOverloads public final fun addOutputState(state: ContractState, notary: Party, encumbrance: Int? = ...): TransactionBuilder defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'stateB' @ [145:28] ==> val stateB: DummyContract.SingleOwnerState defined in net.corda.node.services.NotaryChangeTests.issueEncumberedState[LocalVariableDescriptor]

'notary' @ [145:36] ==> val notary: Party defined in net.corda.node.services.NotaryChangeTests.issueEncumberedState[LocalVariableDescriptor]

'node' @ [147:19] ==> value-parameter node: AbstractNode defined in net.corda.node.services.NotaryChangeTests.issueEncumberedState[ValueParameterDescriptorImpl]

'services' @ [147:24] ==> public final val services: ServiceHubInternal defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'signInitialTransaction' @ [147:33] ==> public open fun signInitialTransaction(builder: TransactionBuilder): SignedTransaction defined in net.corda.node.services.api.ServiceHubInternal[DeserializedSimpleFunctionDescriptor]

'tx' @ [147:56] ==> val tx: TransactionBuilder defined in net.corda.node.services.NotaryChangeTests.issueEncumberedState[LocalVariableDescriptor]

'node' @ [148:9] ==> value-parameter node: AbstractNode defined in net.corda.node.services.NotaryChangeTests.issueEncumberedState[ValueParameterDescriptorImpl]

'services' @ [148:14] ==> public final val services: ServiceHubInternal defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'recordTransactions' @ [148:23] ==> public open fun recordTransactions(first: SignedTransaction, vararg remaining: SignedTransaction): Unit defined in net.corda.node.services.api.ServiceHubInternal[DeserializedSimpleFunctionDescriptor]

'stx' @ [148:42] ==> val stx: SignedTransaction defined in net.corda.node.services.NotaryChangeTests.issueEncumberedState[LocalVariableDescriptor]

'tx' @ [149:16] ==> val tx: TransactionBuilder defined in net.corda.node.services.NotaryChangeTests.issueEncumberedState[LocalVariableDescriptor]

'toWireTransaction' @ [149:19] ==> public final fun toWireTransaction(): WireTransaction defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'DummyContract' @ [162:14] ==> public companion object defined in net.corda.testing.contracts.DummyContract[FakeCallableDescriptorForObject]

'generateInitial' @ [162:28] ==> @JvmStatic public final fun generateInitial(magicNumber: Int, notary: Party, owner: PartyAndReference, vararg otherOwners: PartyAndReference): TransactionBuilder defined in net.corda.testing.contracts.DummyContract.Companion[DeserializedSimpleFunctionDescriptor]

'Random' @ [162:44] ==> public constructor Random() defined in java.util.Random[JavaClassConstructorDescriptor]

'nextInt' @ [162:53] ==> public open fun nextInt(): Int defined in java.util.Random[JavaMethodDescriptor]

'notaryNode' @ [162:64] ==> value-parameter notaryNode: AbstractNode defined in net.corda.node.services.issueState[ValueParameterDescriptorImpl]

'info' @ [162:75] ==> public final lateinit var info: NodeInfo defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'notaryIdentity' @ [162:80] ==> public final val notaryIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'node' @ [162:96] ==> value-parameter node: AbstractNode defined in net.corda.node.services.issueState[ValueParameterDescriptorImpl]

'info' @ [162:101] ==> public final lateinit var info: NodeInfo defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [162:106] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'ref' @ [162:120] ==> public final fun ref(vararg bytes: Byte): PartyAndReference defined in net.corda.core.identity.Party[DeserializedSimpleFunctionDescriptor]

'node' @ [163:24] ==> value-parameter node: AbstractNode defined in net.corda.node.services.issueState[ValueParameterDescriptorImpl]

'services' @ [163:29] ==> public final val services: ServiceHubInternal defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'signInitialTransaction' @ [163:38] ==> public open fun signInitialTransaction(builder: TransactionBuilder): SignedTransaction defined in net.corda.node.services.api.ServiceHubInternal[DeserializedSimpleFunctionDescriptor]

'tx' @ [163:61] ==> val tx: TransactionBuilder defined in net.corda.node.services.issueState[LocalVariableDescriptor]

'notaryNode' @ [164:15] ==> value-parameter notaryNode: AbstractNode defined in net.corda.node.services.issueState[ValueParameterDescriptorImpl]

'services' @ [164:26] ==> public final val services: ServiceHubInternal defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'addSignature' @ [164:35] ==> public open fun addSignature(signedTransaction: SignedTransaction, publicKey: PublicKey): SignedTransaction defined in net.corda.node.services.api.ServiceHubInternal[DeserializedSimpleFunctionDescriptor]

'signedByNode' @ [164:48] ==> val signedByNode: SignedTransaction defined in net.corda.node.services.issueState[LocalVariableDescriptor]

'notaryNode' @ [164:62] ==> value-parameter notaryNode: AbstractNode defined in net.corda.node.services.issueState[ValueParameterDescriptorImpl]

'services' @ [164:73] ==> public final val services: ServiceHubInternal defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'notaryIdentityKey' @ [164:82] ==> public open val notaryIdentityKey: PublicKey defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'node' @ [165:5] ==> value-parameter node: AbstractNode defined in net.corda.node.services.issueState[ValueParameterDescriptorImpl]

'services' @ [165:10] ==> public final val services: ServiceHubInternal defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'recordTransactions' @ [165:19] ==> public open fun recordTransactions(first: SignedTransaction, vararg remaining: SignedTransaction): Unit defined in net.corda.node.services.api.ServiceHubInternal[DeserializedSimpleFunctionDescriptor]

'stx' @ [165:38] ==> val stx: SignedTransaction defined in net.corda.node.services.issueState[LocalVariableDescriptor]

'StateAndRef' @ [166:12] ==> public constructor StateAndRef<out T : ContractState>(state: TransactionState<ContractState>, ref: StateRef) defined in net.corda.core.contracts.StateAndRef[DeserializedClassConstructorDescriptor]
Inferred types:
    <out T : ContractState> -> ContractState

'tx' @ [166:24] ==> val tx: TransactionBuilder defined in net.corda.node.services.issueState[LocalVariableDescriptor]

'outputStates' @ [166:27] ==> public final fun outputStates(): List<TransactionState<*>> defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'first' @ [166:42] ==> public fun <T> List<TransactionState<*>>.first(): TransactionState<*> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TransactionState<*>

'StateRef' @ [166:51] ==> public constructor StateRef(txhash: SecureHash, index: Int) defined in net.corda.core.contracts.StateRef[DeserializedClassConstructorDescriptor]

'stx' @ [166:60] ==> val stx: SignedTransaction defined in net.corda.node.services.issueState[LocalVariableDescriptor]

'id' @ [166:64] ==> public open val id: SecureHash defined in net.corda.core.transactions.SignedTransaction[DeserializedPropertyDescriptor]

'TransactionState' @ [170:17] ==> @JvmOverloads public constructor TransactionState<out T : ContractState>(data: DummyContract.MultiOwnerState, notary: Party, encumbrance: Int? = ...) defined in net.corda.core.contracts.TransactionState[DeserializedClassConstructorDescriptor]
Inferred types:
    <out T : ContractState> -> MultiOwnerState

'DummyContract' @ [170:34] ==> public companion object defined in net.corda.testing.contracts.DummyContract[FakeCallableDescriptorForObject]

'MultiOwnerState' @ [170:48] ==> public constructor MultiOwnerState(magicNumber: Int = ..., owners: List<AbstractParty>) defined in net.corda.testing.contracts.DummyContract.MultiOwnerState[DeserializedClassConstructorDescriptor]

'listOf' @ [171:13] ==> public fun <T> listOf(vararg elements: Party): List<Party> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Party

'nodeA' @ [171:20] ==> value-parameter nodeA: AbstractNode defined in net.corda.node.services.issueMultiPartyState[ValueParameterDescriptorImpl]

'info' @ [171:26] ==> public final lateinit var info: NodeInfo defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [171:31] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'nodeB' @ [171:46] ==> value-parameter nodeB: AbstractNode defined in net.corda.node.services.issueMultiPartyState[ValueParameterDescriptorImpl]

'info' @ [171:52] ==> public final lateinit var info: NodeInfo defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [171:57] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'notaryNode' @ [171:74] ==> value-parameter notaryNode: AbstractNode defined in net.corda.node.services.issueMultiPartyState[ValueParameterDescriptorImpl]

'info' @ [171:85] ==> public final lateinit var info: NodeInfo defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'notaryIdentity' @ [171:90] ==> public final val notaryIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'TransactionBuilder' @ [172:14] ==> public constructor TransactionBuilder(notary: Party) defined in net.corda.core.transactions.TransactionBuilder[DeserializedClassConstructorDescriptor]

'notaryNode' @ [172:42] ==> value-parameter notaryNode: AbstractNode defined in net.corda.node.services.issueMultiPartyState[ValueParameterDescriptorImpl]

'info' @ [172:53] ==> public final lateinit var info: NodeInfo defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'notaryIdentity' @ [172:58] ==> public final val notaryIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'withItems' @ [172:74] ==> public final fun withItems(vararg items: Any): TransactionBuilder defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'state' @ [172:84] ==> val state: TransactionState<DummyContract.MultiOwnerState> defined in net.corda.node.services.issueMultiPartyState[LocalVariableDescriptor]

'dummyCommand' @ [172:91] ==> public fun dummyCommand(vararg signers: PublicKey = ...): Command<TypeOnlyCommandData> defined in net.corda.testing[DeserializedSimpleFunctionDescriptor]

'nodeA' @ [173:21] ==> value-parameter nodeA: AbstractNode defined in net.corda.node.services.issueMultiPartyState[ValueParameterDescriptorImpl]

'services' @ [173:27] ==> public final val services: ServiceHubInternal defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'signInitialTransaction' @ [173:36] ==> public open fun signInitialTransaction(builder: TransactionBuilder): SignedTransaction defined in net.corda.node.services.api.ServiceHubInternal[DeserializedSimpleFunctionDescriptor]

'tx' @ [173:59] ==> val tx: TransactionBuilder defined in net.corda.node.services.issueMultiPartyState[LocalVariableDescriptor]

'nodeB' @ [174:22] ==> value-parameter nodeB: AbstractNode defined in net.corda.node.services.issueMultiPartyState[ValueParameterDescriptorImpl]

'services' @ [174:28] ==> public final val services: ServiceHubInternal defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'addSignature' @ [174:37] ==> public open fun addSignature(signedTransaction: SignedTransaction): SignedTransaction defined in net.corda.node.services.api.ServiceHubInternal[DeserializedSimpleFunctionDescriptor]

'signedByA' @ [174:50] ==> val signedByA: SignedTransaction defined in net.corda.node.services.issueMultiPartyState[LocalVariableDescriptor]

'notaryNode' @ [175:15] ==> value-parameter notaryNode: AbstractNode defined in net.corda.node.services.issueMultiPartyState[ValueParameterDescriptorImpl]

'services' @ [175:26] ==> public final val services: ServiceHubInternal defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'addSignature' @ [175:35] ==> public open fun addSignature(signedTransaction: SignedTransaction, publicKey: PublicKey): SignedTransaction defined in net.corda.node.services.api.ServiceHubInternal[DeserializedSimpleFunctionDescriptor]

'signedByAB' @ [175:48] ==> val signedByAB: SignedTransaction defined in net.corda.node.services.issueMultiPartyState[LocalVariableDescriptor]

'notaryNode' @ [175:60] ==> value-parameter notaryNode: AbstractNode defined in net.corda.node.services.issueMultiPartyState[ValueParameterDescriptorImpl]

'services' @ [175:71] ==> public final val services: ServiceHubInternal defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'notaryIdentityKey' @ [175:80] ==> public open val notaryIdentityKey: PublicKey defined in net.corda.node.services.api.ServiceHubInternal[DeserializedPropertyDescriptor]

'nodeA' @ [176:5] ==> value-parameter nodeA: AbstractNode defined in net.corda.node.services.issueMultiPartyState[ValueParameterDescriptorImpl]

'services' @ [176:11] ==> public final val services: ServiceHubInternal defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'recordTransactions' @ [176:20] ==> public open fun recordTransactions(first: SignedTransaction, vararg remaining: SignedTransaction): Unit defined in net.corda.node.services.api.ServiceHubInternal[DeserializedSimpleFunctionDescriptor]

'stx' @ [176:39] ==> val stx: SignedTransaction defined in net.corda.node.services.issueMultiPartyState[LocalVariableDescriptor]

'nodeB' @ [177:5] ==> value-parameter nodeB: AbstractNode defined in net.corda.node.services.issueMultiPartyState[ValueParameterDescriptorImpl]

'services' @ [177:11] ==> public final val services: ServiceHubInternal defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'recordTransactions' @ [177:20] ==> public open fun recordTransactions(first: SignedTransaction, vararg remaining: SignedTransaction): Unit defined in net.corda.node.services.api.ServiceHubInternal[DeserializedSimpleFunctionDescriptor]

'stx' @ [177:39] ==> val stx: SignedTransaction defined in net.corda.node.services.issueMultiPartyState[LocalVariableDescriptor]

'StateAndRef' @ [178:23] ==> public constructor StateAndRef<out T : ContractState>(state: TransactionState<DummyContract.MultiOwnerState>, ref: StateRef) defined in net.corda.core.contracts.StateAndRef[DeserializedClassConstructorDescriptor]
Inferred types:
    <out T : ContractState> -> MultiOwnerState

'state' @ [178:35] ==> val state: TransactionState<DummyContract.MultiOwnerState> defined in net.corda.node.services.issueMultiPartyState[LocalVariableDescriptor]

'StateRef' @ [178:42] ==> public constructor StateRef(txhash: SecureHash, index: Int) defined in net.corda.core.contracts.StateRef[DeserializedClassConstructorDescriptor]

'stx' @ [178:51] ==> val stx: SignedTransaction defined in net.corda.node.services.issueMultiPartyState[LocalVariableDescriptor]

'id' @ [178:55] ==> public open val id: SecureHash defined in net.corda.core.transactions.SignedTransaction[DeserializedPropertyDescriptor]

'stateAndRef' @ [179:12] ==> val stateAndRef: StateAndRef<DummyContract.MultiOwnerState> defined in net.corda.node.services.issueMultiPartyState[LocalVariableDescriptor]

'DummyContract' @ [183:14] ==> public companion object defined in net.corda.testing.contracts.DummyContract[FakeCallableDescriptorForObject]

'generateInitial' @ [183:28] ==> @JvmStatic public final fun generateInitial(magicNumber: Int, notary: Party, owner: PartyAndReference, vararg otherOwners: PartyAndReference): TransactionBuilder defined in net.corda.testing.contracts.DummyContract.Companion[DeserializedSimpleFunctionDescriptor]

'Random' @ [183:44] ==> public constructor Random() defined in java.util.Random[JavaClassConstructorDescriptor]

'nextInt' @ [183:53] ==> public open fun nextInt(): Int defined in java.util.Random[JavaMethodDescriptor]

'notary' @ [183:64] ==> value-parameter notary: Party defined in net.corda.node.services.issueInvalidState[ValueParameterDescriptorImpl]

'node' @ [183:72] ==> value-parameter node: AbstractNode defined in net.corda.node.services.issueInvalidState[ValueParameterDescriptorImpl]

'info' @ [183:77] ==> public final lateinit var info: NodeInfo defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'legalIdentity' @ [183:82] ==> public final val legalIdentity: Party defined in net.corda.core.node.NodeInfo[DeserializedPropertyDescriptor]

'ref' @ [183:96] ==> public final fun ref(vararg bytes: Byte): PartyAndReference defined in net.corda.core.identity.Party[DeserializedSimpleFunctionDescriptor]

'tx' @ [184:5] ==> val tx: TransactionBuilder defined in net.corda.node.services.issueInvalidState[LocalVariableDescriptor]

'setTimeWindow' @ [184:8] ==> public final fun setTimeWindow(time: Instant, timeTolerance: Duration): TransactionBuilder defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'now' @ [184:30] ==> public open fun now(): (Instant..Instant?) defined in java.time.Instant[JavaMethodDescriptor]

'seconds' @ [184:40] ==> public val Int.seconds: Duration defined in net.corda.core.utilities[DeserializedPropertyDescriptor]

'node' @ [185:15] ==> value-parameter node: AbstractNode defined in net.corda.node.services.issueInvalidState[ValueParameterDescriptorImpl]

'services' @ [185:20] ==> public final val services: ServiceHubInternal defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'signInitialTransaction' @ [185:29] ==> public open fun signInitialTransaction(builder: TransactionBuilder): SignedTransaction defined in net.corda.node.services.api.ServiceHubInternal[DeserializedSimpleFunctionDescriptor]

'tx' @ [185:52] ==> val tx: TransactionBuilder defined in net.corda.node.services.issueInvalidState[LocalVariableDescriptor]

'node' @ [186:5] ==> value-parameter node: AbstractNode defined in net.corda.node.services.issueInvalidState[ValueParameterDescriptorImpl]

'services' @ [186:10] ==> public final val services: ServiceHubInternal defined in net.corda.node.internal.AbstractNode[DeserializedPropertyDescriptor]

'recordTransactions' @ [186:19] ==> public open fun recordTransactions(first: SignedTransaction, vararg remaining: SignedTransaction): Unit defined in net.corda.node.services.api.ServiceHubInternal[DeserializedSimpleFunctionDescriptor]

'stx' @ [186:38] ==> val stx: SignedTransaction defined in net.corda.node.services.issueInvalidState[LocalVariableDescriptor]

'StateAndRef' @ [187:12] ==> public constructor StateAndRef<out T : ContractState>(state: TransactionState<ContractState>, ref: StateRef) defined in net.corda.core.contracts.StateAndRef[DeserializedClassConstructorDescriptor]
Inferred types:
    <out T : ContractState> -> ContractState

'tx' @ [187:24] ==> val tx: TransactionBuilder defined in net.corda.node.services.issueInvalidState[LocalVariableDescriptor]

'outputStates' @ [187:27] ==> public final fun outputStates(): List<TransactionState<*>> defined in net.corda.core.transactions.TransactionBuilder[DeserializedSimpleFunctionDescriptor]

'first' @ [187:42] ==> public fun <T> List<TransactionState<*>>.first(): TransactionState<*> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> TransactionState<*>

'StateRef' @ [187:51] ==> public constructor StateRef(txhash: SecureHash, index: Int) defined in net.corda.core.contracts.StateRef[DeserializedClassConstructorDescriptor]

'stx' @ [187:60] ==> val stx: SignedTransaction defined in net.corda.node.services.issueInvalidState[LocalVariableDescriptor]

'id' @ [187:64] ==> public open val id: SecureHash defined in net.corda.core.transactions.SignedTransaction[DeserializedPropertyDescriptor]

