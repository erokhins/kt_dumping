'CordaSerializable' @ [19:1] ==> public constructor CordaSerializable() defined in net.corda.core.serialization.CordaSerializable[DeserializedClassConstructorDescriptor]

'SingletonSerializeAsToken' @ [34:34] ==> public constructor SingletonSerializeAsToken() defined in net.corda.core.serialization.SingletonSerializeAsToken[DeserializedClassConstructorDescriptor]

'!' @ [36:13] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'flowClass' @ [36:14] ==> value-parameter flowClass: Class<out FlowLogic<*>> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.create[ValueParameterDescriptorImpl]

'isAnnotationPresent' @ [36:24] ==> public open fun isAnnotationPresent(p0: (Class<out (Annotation..Annotation?)>..Class<out (Annotation..Annotation?)>?)): Boolean defined in java.lang.Class[JavaMethodDescriptor]

'SchedulableFlow' @ [36:44] ==> public constructor SchedulableFlow() defined in net.corda.core.flows.SchedulableFlow[DeserializedClassConstructorDescriptor]

'java' @ [36:67] ==> public val <T> KClass<SchedulableFlow>.java: Class<SchedulableFlow> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> SchedulableFlow

'IllegalFlowLogicException' @ [37:19] ==> public constructor IllegalFlowLogicException(type: Class<*>, msg: String) defined in net.corda.core.flows.IllegalFlowLogicException[DeserializedClassConstructorDescriptor]

'flowClass' @ [37:45] ==> value-parameter flowClass: Class<out FlowLogic<*>> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.create[ValueParameterDescriptorImpl]

'createForRPC' @ [39:16] ==> public final fun createForRPC(flowClass: Class<out FlowLogic<*>>, vararg args: Any?): FlowLogicRef defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl[SimpleFunctionDescriptorImpl]

'flowClass' @ [39:29] ==> value-parameter flowClass: Class<out FlowLogic<*>> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.create[ValueParameterDescriptorImpl]

'args' @ [39:41] ==> value-parameter vararg args: Any? defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.create[ValueParameterDescriptorImpl]

'args' @ [45:24] ==> value-parameter vararg args: Any? defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createForRPC[ValueParameterDescriptorImpl]

'map' @ [45:29] ==> public inline fun <T, R> Array<out Any?>.map(transform: (Any?) -> Class<Any>?): List<Class<Any>?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Any?
    <R> -> Class<Any>?

'it' @ [45:35] ==> value-parameter it: Any? defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createForRPC.<anonymous>[ValueParameterDescriptorImpl]

'javaClass' @ [45:39] ==> public val <T : Any> Any.javaClass: Class<Any> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> Any

'flowClass' @ [47:13] ==> value-parameter flowClass: Class<out FlowLogic<*>> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createForRPC[ValueParameterDescriptorImpl]

'kotlin' @ [47:23] ==> public val <T : Any> Class<out FlowLogic<*>>.kotlin: KClass<out FlowLogic<*>> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> Captured(out FlowLogic<*>)

'constructors' @ [47:30] ==> public abstract val constructors: Collection<KFunction<FlowLogic<*>>> defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor]

'single' @ [47:43] ==> public inline fun <T> Iterable<KFunction<FlowLogic<*>>>.single(predicate: (KFunction<FlowLogic<*>>) -> Boolean): KFunction<FlowLogic<*>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> KFunction<FlowLogic<*>>

'ctor' @ [49:33] ==> value-parameter ctor: KFunction<FlowLogic<*>> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createForRPC.<anonymous>[ValueParameterDescriptorImpl]

'javaConstructor' @ [49:38] ==> public val <T> KFunction<FlowLogic<*>>.javaConstructor: Constructor<FlowLogic<*>>? defined in kotlin.reflect.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> FlowLogic<*>

'parameterTypes' @ [49:56] ==> public final val <T : (Any..Any?)> Constructor<FlowLogic<*>>.parameterTypes: (Array<(Class<*>..Class<*>?)>..Array<out (Class<*>..Class<*>?)>?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> FlowLogic<*>

'map' @ [49:71] ==> public inline fun <T, R> Array<out (Class<*>..Class<*>?)>.map(transform: ((Class<*>..Class<*>?)) -> (Class<out (Any..Any?)>..Class<out (Any..Any?)>?)): List<(Class<out (Any..Any?)>..Class<out (Any..Any?)>?)> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> (java.lang.Class<*>..java.lang.Class<*>?)
    <R> -> (java.lang.Class<out (kotlin.Any..kotlin.Any?)>..java.lang.Class<out (kotlin.Any..kotlin.Any?)>?)

'wrap' @ [49:88] ==> public open fun <T : (Any..Any?)> wrap(p0: (Class<out (Any..Any?)>..Class<out (Any..Any?)>?)): (Class<out (Any..Any?)>..Class<out (Any..Any?)>?) defined in com.google.common.primitives.Primitives[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Captured(*)

'it' @ [49:93] ==> value-parameter it: (Class<*>..Class<*>?) defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createForRPC.<anonymous>.<anonymous>[ValueParameterDescriptorImpl]

'argTypes' @ [50:21] ==> val argTypes: List<Class<Any>?> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createForRPC[LocalVariableDescriptor]

'size' @ [50:30] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'ctorTypes' @ [50:38] ==> val ctorTypes: List<(Class<out (Any..Any?)>..Class<out (Any..Any?)>?)> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createForRPC.<anonymous>[LocalVariableDescriptor]

'size' @ [50:48] ==> public abstract val size: Int defined in kotlin.collections.List[DeserializedPropertyDescriptor]

'component1' @ [52:23] ==> public final operator fun component1(): Class<Any>? defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'component2' @ [52:32] ==> public final operator fun component2(): (Class<out (Any..Any?)>..Class<out (Any..Any?)>?) defined in kotlin.Pair[DeserializedSimpleFunctionDescriptor]

'argTypes' @ [52:45] ==> val argTypes: List<Class<Any>?> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createForRPC[LocalVariableDescriptor]

'zip' @ [52:54] ==> public infix fun <T, R> Iterable<Class<Any>?>.zip(other: Iterable<(Class<out (Any..Any?)>..Class<out (Any..Any?)>?)>): List<Pair<Class<Any>?, (Class<out (Any..Any?)>..Class<out (Any..Any?)>?)>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Class<Any>?
    <R> -> (java.lang.Class<out (kotlin.Any..kotlin.Any?)>..java.lang.Class<out (kotlin.Any..kotlin.Any?)>?)

'ctorTypes' @ [52:58] ==> val ctorTypes: List<(Class<out (Any..Any?)>..Class<out (Any..Any?)>?)> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createForRPC.<anonymous>[LocalVariableDescriptor]

'argType' @ [53:25] ==> val argType: Class<Any>? defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createForRPC.<anonymous>[LocalVariableDescriptor]

'!' @ [54:25] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'ctorType' @ [54:26] ==> val ctorType: (Class<out (Any..Any?)>..Class<out (Any..Any?)>?) defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createForRPC.<anonymous>[LocalVariableDescriptor]

'isAssignableFrom' @ [54:35] ==> public open fun isAssignableFrom(p0: (Class<*>..Class<*>?)): Boolean defined in java.lang.Class[JavaMethodDescriptor]

'argType' @ [54:52] ==> val argType: Class<Any>? defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createForRPC.<anonymous>[LocalVariableDescriptor]

'IllegalFlowLogicException' @ [59:19] ==> public constructor IllegalFlowLogicException(type: Class<*>, msg: String) defined in net.corda.core.flows.IllegalFlowLogicException[DeserializedClassConstructorDescriptor]

'flowClass' @ [59:45] ==> value-parameter flowClass: Class<out FlowLogic<*>> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createForRPC[ValueParameterDescriptorImpl]

'argTypes' @ [59:107] ==> val argTypes: List<Class<Any>?> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createForRPC[LocalVariableDescriptor]

'IllegalFlowLogicException' @ [61:19] ==> public constructor IllegalFlowLogicException(type: Class<*>, msg: String) defined in net.corda.core.flows.IllegalFlowLogicException[DeserializedClassConstructorDescriptor]

'flowClass' @ [61:45] ==> value-parameter flowClass: Class<out FlowLogic<*>> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createForRPC[ValueParameterDescriptorImpl]

'argTypes' @ [61:100] ==> val argTypes: List<Class<Any>?> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createForRPC[LocalVariableDescriptor]

'args' @ [65:23] ==> value-parameter vararg args: Any? defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createForRPC[ValueParameterDescriptorImpl]

'zip' @ [65:28] ==> public infix fun <T, R> Array<out Any?>.zip(other: Iterable<KParameter>): List<Pair<Any?, KParameter>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Any?
    <R> -> KParameter

'constructor' @ [65:32] ==> val constructor: KFunction<FlowLogic<*>> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createForRPC[LocalVariableDescriptor]

'parameters' @ [65:44] ==> public abstract val parameters: List<KParameter> defined in kotlin.reflect.KFunction[DeserializedPropertyDescriptor]

'map' @ [65:56] ==> public inline fun <T, R> Iterable<Pair<Any?, KParameter>>.map(transform: (Pair<Any?, KParameter>) -> Pair<String, Any?>): List<Pair<String, Any?>> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> Pair<Any?, KParameter>
    <R> -> Pair<String, Any?>

'Pair' @ [65:62] ==> public constructor Pair<out A, out B>(first: String, second: Any?) defined in kotlin.Pair[DeserializedClassConstructorDescriptor]
Inferred types:
    <out A> -> String
    <out B> -> Any?

'it' @ [65:67] ==> value-parameter it: Pair<Any?, KParameter> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createForRPC.<anonymous>[ValueParameterDescriptorImpl]

'second' @ [65:70] ==> public final val second: KParameter defined in kotlin.Pair[DeserializedPropertyDescriptor]

'name' @ [65:77] ==> public abstract val name: String? defined in kotlin.reflect.KParameter[DeserializedPropertyDescriptor]

'it' @ [65:85] ==> value-parameter it: Pair<Any?, KParameter> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createForRPC.<anonymous>[ValueParameterDescriptorImpl]

'first' @ [65:88] ==> public final val first: Any? defined in kotlin.Pair[DeserializedPropertyDescriptor]

'toMap' @ [65:97] ==> public fun <K, V> Iterable<Pair<String, Any?>>.toMap(): Map<String, Any?> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> String
    <V> -> Any?

'createKotlin' @ [66:16] ==> @VisibleForTesting internal final fun createKotlin(type: Class<out FlowLogic<*>>, args: Map<String, Any?>): FlowLogicRef defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl[SimpleFunctionDescriptorImpl]

'flowClass' @ [66:29] ==> value-parameter flowClass: Class<out FlowLogic<*>> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createForRPC[ValueParameterDescriptorImpl]

'argsMap' @ [66:40] ==> val argsMap: Map<String, Any?> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createForRPC[LocalVariableDescriptor]

'VisibleForTesting' @ [74:5] ==> public constructor VisibleForTesting() defined in net.corda.core.internal.VisibleForTesting[DeserializedClassConstructorDescriptor]

'AppContext' @ [78:26] ==> public constructor AppContext(attachments: List<SecureHash>) defined in net.corda.core.flows.AppContext[DeserializedClassConstructorDescriptor]

'emptyList' @ [78:37] ==> public fun <T> emptyList(): List<SecureHash> defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> SecureHash

'createConstructor' @ [80:9] ==> private final fun createConstructor(clazz: Class<out FlowLogic<*>>, args: Map<String, Any?>): () -> FlowLogic<*> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl[SimpleFunctionDescriptorImpl]

'type' @ [80:27] ==> value-parameter type: Class<out FlowLogic<*>> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createKotlin[ValueParameterDescriptorImpl]

'args' @ [80:33] ==> value-parameter args: Map<String, Any?> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createKotlin[ValueParameterDescriptorImpl]

'FlowLogicRefImpl' @ [81:16] ==> internal constructor FlowLogicRefImpl(flowLogicClassName: String, appContext: AppContext, args: Map<String, Any?>) defined in net.corda.node.services.statemachine.FlowLogicRefImpl[ClassConstructorDescriptorImpl]

'type' @ [81:33] ==> value-parameter type: Class<out FlowLogic<*>> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createKotlin[ValueParameterDescriptorImpl]

'name' @ [81:38] ==> public final val <T : (Any..Any?)> Class<out FlowLogic<*>>.name: (String..String?)[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Captured(out FlowLogic<*>)

'appContext' @ [81:44] ==> val appContext: AppContext defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createKotlin[LocalVariableDescriptor]

'args' @ [81:56] ==> value-parameter args: Map<String, Any?> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createKotlin[ValueParameterDescriptorImpl]

'ref' @ [85:13] ==> value-parameter ref: FlowLogicRef defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.toFlowLogic[ValueParameterDescriptorImpl]

'IllegalFlowLogicException' @ [85:45] ==> public constructor IllegalFlowLogicException(type: Class<*>, msg: String) defined in net.corda.core.flows.IllegalFlowLogicException[DeserializedClassConstructorDescriptor]

'ref' @ [85:71] ==> value-parameter ref: FlowLogicRef defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.toFlowLogic[ValueParameterDescriptorImpl]

'javaClass' @ [85:75] ==> public val <T : Any> FlowLogicRef.javaClass: Class<FlowLogicRef> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> FlowLogicRef

'forName' @ [86:27] ==> @CallerSensitive public open fun forName(p0: (String..String?), p1: Boolean, p2: (ClassLoader..ClassLoader?)): (Class<*>..Class<*>?) defined in java.lang.Class[JavaMethodDescriptor]

'ref' @ [86:35] ==> value-parameter ref: FlowLogicRef defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.toFlowLogic[ValueParameterDescriptorImpl]

'flowLogicClassName' @ [86:39] ==> public final val flowLogicClassName: String defined in net.corda.node.services.statemachine.FlowLogicRefImpl[PropertyDescriptorImpl]

'ref' @ [86:65] ==> value-parameter ref: FlowLogicRef defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.toFlowLogic[ValueParameterDescriptorImpl]

'appContext' @ [86:69] ==> public final val appContext: AppContext defined in net.corda.node.services.statemachine.FlowLogicRefImpl[PropertyDescriptorImpl]

'classLoader' @ [86:80] ==> public final val classLoader: ClassLoader defined in net.corda.core.flows.AppContext[DeserializedPropertyDescriptor]

'asSubclass' @ [86:93] ==> public open fun <U : (Any..Any?)> asSubclass(p0: (Class<(FlowLogic<*>..FlowLogic<*>?)>..Class<(FlowLogic<*>..FlowLogic<*>?)>?)): (Class<out (FlowLogic<*>..FlowLogic<*>?)>..Class<out (FlowLogic<*>..FlowLogic<*>?)>?) defined in java.lang.Class[JavaMethodDescriptor]
Inferred types:
    <U : (Any..Any?)> -> (net.corda.core.flows.FlowLogic<*>..net.corda.core.flows.FlowLogic<*>?)

'FlowLogic' @ [86:104] ==> public constructor FlowLogic<out T>() defined in net.corda.core.flows.FlowLogic[DeserializedClassConstructorDescriptor]
Inferred types:
    <out T> -> org.jetbrains.kotlin.types.ErrorUtils$UninferredParameterTypeConstructor@7bb64385

'java' @ [86:121] ==> public val <T> KClass<FlowLogic<*>>.java: Class<FlowLogic<*>> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T> -> FlowLogic<*>

'createConstructor' @ [87:16] ==> private final fun createConstructor(clazz: Class<out FlowLogic<*>>, args: Map<String, Any?>): () -> FlowLogic<*> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl[SimpleFunctionDescriptorImpl]

'klass' @ [87:34] ==> val klass: (Class<out (FlowLogic<*>..FlowLogic<*>?)>..Class<out (FlowLogic<*>..FlowLogic<*>?)>?) defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.toFlowLogic[LocalVariableDescriptor]

'ref' @ [87:41] ==> value-parameter ref: FlowLogicRef defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.toFlowLogic[ValueParameterDescriptorImpl]

'args' @ [87:45] ==> public final val args: Map<String, Any?> defined in net.corda.node.services.statemachine.FlowLogicRefImpl[PropertyDescriptorImpl]

'clazz' @ [91:29] ==> value-parameter clazz: Class<out FlowLogic<*>> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createConstructor[ValueParameterDescriptorImpl]

'kotlin' @ [91:35] ==> public val <T : Any> Class<out FlowLogic<*>>.kotlin: KClass<out FlowLogic<*>> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> Captured(out FlowLogic<*>)

'constructors' @ [91:42] ==> public abstract val constructors: Collection<KFunction<FlowLogic<*>>> defined in kotlin.reflect.KClass[DeserializedPropertyDescriptor]

'buildParams' @ [92:26] ==> private final fun buildParams(constructor: KFunction<FlowLogic<*>>, args: Map<String, Any?>): HashMap<KParameter, Any?>? defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl[SimpleFunctionDescriptorImpl]

'constructor' @ [92:38] ==> val constructor: KFunction<FlowLogic<*>> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createConstructor[LocalVariableDescriptor]

'args' @ [92:51] ==> value-parameter args: Map<String, Any?> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createConstructor[ValueParameterDescriptorImpl]

'constructor' @ [94:22] ==> val constructor: KFunction<FlowLogic<*>> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createConstructor[LocalVariableDescriptor]

'callBy' @ [94:34] ==> public abstract fun callBy(args: Map<KParameter, Any?>): FlowLogic<*> defined in kotlin.reflect.KFunction[DeserializedSimpleFunctionDescriptor]

'params' @ [94:41] ==> val params: HashMap<KParameter, Any?> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createConstructor[LocalVariableDescriptor]

'IllegalFlowLogicException' @ [96:15] ==> public constructor IllegalFlowLogicException(type: Class<*>, msg: String) defined in net.corda.core.flows.IllegalFlowLogicException[DeserializedClassConstructorDescriptor]

'clazz' @ [96:41] ==> value-parameter clazz: Class<out FlowLogic<*>> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createConstructor[ValueParameterDescriptorImpl]

'args' @ [96:94] ==> value-parameter args: Map<String, Any?> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.createConstructor[ValueParameterDescriptorImpl]

'hashMapOf' @ [100:22] ==> @SinceKotlin @InlineOnly public inline fun <K, V> hashMapOf(): HashMap<KParameter, Any?> /* = HashMap<KParameter, Any?> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <K> -> KParameter
    <V> -> Any?

'hashSetOf' @ [101:24] ==> @SinceKotlin @InlineOnly public inline fun <T> hashSetOf(): HashSet<String> /* = HashSet<String> */ defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'constructor' @ [102:27] ==> value-parameter constructor: KFunction<FlowLogic<*>> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.buildParams[ValueParameterDescriptorImpl]

'parameters' @ [102:39] ==> public abstract val parameters: List<KParameter> defined in kotlin.reflect.KFunction[DeserializedPropertyDescriptor]

'if (!tryBuildParam(args, parameter, params)) {
                return null
            } else {
                usedKeys += parameter.name!!
            }' @ [103:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Unit, elseBranch: Unit): Unit[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Unit

'!' @ [103:17] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'tryBuildParam' @ [103:18] ==> private final fun tryBuildParam(args: Map<String, Any?>, parameter: KParameter, params: HashMap<KParameter, Any?>): Boolean defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl[SimpleFunctionDescriptorImpl]

'args' @ [103:32] ==> value-parameter args: Map<String, Any?> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.buildParams[ValueParameterDescriptorImpl]

'parameter' @ [103:38] ==> val parameter: KParameter defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.buildParams[LocalVariableDescriptor]

'params' @ [103:49] ==> val params: HashMap<KParameter, Any?> /* = HashMap<KParameter, Any?> */ defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.buildParams[LocalVariableDescriptor]

'usedKeys' @ [106:17] ==> val usedKeys: HashSet<String> /* = HashSet<String> */ defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.buildParams[LocalVariableDescriptor]

'parameter' @ [106:29] ==> val parameter: KParameter defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.buildParams[LocalVariableDescriptor]

'name' @ [106:39] ==> public abstract val name: String? defined in kotlin.reflect.KParameter[DeserializedPropertyDescriptor]

'args' @ [109:14] ==> value-parameter args: Map<String, Any?> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.buildParams[ValueParameterDescriptorImpl]

'keys' @ [109:19] ==> public abstract val keys: Set<String> defined in kotlin.collections.Map[DeserializedPropertyDescriptor]

'usedKeys' @ [109:26] ==> val usedKeys: HashSet<String> /* = HashSet<String> */ defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.buildParams[LocalVariableDescriptor]

'isNotEmpty' @ [109:36] ==> @InlineOnly public inline fun <T> Collection<String>.isNotEmpty(): Boolean defined in kotlin.collections[DeserializedSimpleFunctionDescriptor]
Inferred types:
    <T> -> String

'params' @ [113:16] ==> val params: HashMap<KParameter, Any?> /* = HashMap<KParameter, Any?> */ defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.buildParams[LocalVariableDescriptor]

'parameter' @ [117:27] ==> value-parameter parameter: KParameter defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.tryBuildParam[ValueParameterDescriptorImpl]

'name' @ [117:37] ==> public abstract val name: String? defined in kotlin.reflect.KParameter[DeserializedPropertyDescriptor]

'args' @ [117:45] ==> value-parameter args: Map<String, Any?> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.tryBuildParam[ValueParameterDescriptorImpl]

'parameter' @ [119:17] ==> value-parameter parameter: KParameter defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.tryBuildParam[ValueParameterDescriptorImpl]

'isOptional' @ [119:27] ==> public abstract val isOptional: Boolean defined in kotlin.reflect.KParameter[DeserializedPropertyDescriptor]

'!' @ [119:41] ==> public final operator fun not(): Boolean defined in kotlin.Boolean[DeserializedSimpleFunctionDescriptor]

'containsKey' @ [119:42] ==> val containsKey: Boolean defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.tryBuildParam[LocalVariableDescriptor]

'containsKey' @ [119:59] ==> val containsKey: Boolean defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.tryBuildParam[LocalVariableDescriptor]

'paramCanBeBuilt' @ [119:74] ==> private final fun paramCanBeBuilt(args: Map<String, Any?>, parameter: KParameter, params: HashMap<KParameter, Any?>): Boolean defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl[SimpleFunctionDescriptorImpl]

'args' @ [119:90] ==> value-parameter args: Map<String, Any?> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.tryBuildParam[ValueParameterDescriptorImpl]

'parameter' @ [119:96] ==> value-parameter parameter: KParameter defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.tryBuildParam[ValueParameterDescriptorImpl]

'params' @ [119:107] ==> value-parameter params: HashMap<KParameter, Any?> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.tryBuildParam[ValueParameterDescriptorImpl]

'args' @ [123:21] ==> value-parameter args: Map<String, Any?> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.paramCanBeBuilt[ValueParameterDescriptorImpl]

'parameter' @ [123:26] ==> value-parameter parameter: KParameter defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.paramCanBeBuilt[ValueParameterDescriptorImpl]

'name' @ [123:36] ==> public abstract val name: String? defined in kotlin.reflect.KParameter[DeserializedPropertyDescriptor]

'params' @ [124:9] ==> value-parameter params: HashMap<KParameter, Any?> defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.paramCanBeBuilt[ValueParameterDescriptorImpl]

'parameter' @ [124:16] ==> value-parameter parameter: KParameter defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.paramCanBeBuilt[ValueParameterDescriptorImpl]

'value' @ [124:29] ==> val value: Any? defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.paramCanBeBuilt[LocalVariableDescriptor]

'value' @ [125:17] ==> val value: Any? defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.paramCanBeBuilt[LocalVariableDescriptor]

'parameterAssignableFrom' @ [125:33] ==> private final fun parameterAssignableFrom(type: Type, value: Any): Boolean defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl[SimpleFunctionDescriptorImpl]

'parameter' @ [125:57] ==> value-parameter parameter: KParameter defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.paramCanBeBuilt[ValueParameterDescriptorImpl]

'type' @ [125:67] ==> public abstract val type: KType defined in kotlin.reflect.KParameter[DeserializedPropertyDescriptor]

'javaType' @ [125:72] ==> public val KType.javaType: Type defined in kotlin.reflect.jvm[DeserializedPropertyDescriptor]

'value' @ [125:82] ==> val value: Any? defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.paramCanBeBuilt[LocalVariableDescriptor]

'parameter' @ [125:93] ==> value-parameter parameter: KParameter defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.paramCanBeBuilt[ValueParameterDescriptorImpl]

'type' @ [125:103] ==> public abstract val type: KType defined in kotlin.reflect.KParameter[DeserializedPropertyDescriptor]

'isMarkedNullable' @ [125:108] ==> public abstract val isMarkedNullable: Boolean defined in kotlin.reflect.KType[DeserializedPropertyDescriptor]

'if (type is Class<*>) {
            if (type.isPrimitive) {
                return Primitives.unwrap(value.javaClass) == type
            } else {
                return type.isAssignableFrom(value.javaClass)
            }
        } else if (type is ParameterizedType) {
            return parameterAssignableFrom(type.rawType, value)
        } else {
            return false
        }' @ [129:9] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nothing, elseBranch: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nothing

'type' @ [129:13] ==> value-parameter type: Type defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.parameterAssignableFrom[ValueParameterDescriptorImpl]

'if (type.isPrimitive) {
                return Primitives.unwrap(value.javaClass) == type
            } else {
                return type.isAssignableFrom(value.javaClass)
            }' @ [130:13] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nothing, elseBranch: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nothing

'type' @ [130:17] ==> value-parameter type: Type defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.parameterAssignableFrom[ValueParameterDescriptorImpl]

'isPrimitive' @ [130:22] ==> public final val <T : (Any..Any?)> Class<out (Any..Any?)>.isPrimitive: Boolean[MyPropertyDescriptor]
Inferred types:
    <T : (Any..Any?)> -> Captured(*)

'==' @ [131:24] ==> public open fun equals(other: Any?): Boolean defined in java.lang.Class[DeserializedSimpleFunctionDescriptor]

'unwrap' @ [131:35] ==> public open fun <T : (Any..Any?)> unwrap(p0: (Class<(Any..Any?)>..Class<(Any..Any?)>?)): (Class<(Any..Any?)>..Class<(Any..Any?)>?) defined in com.google.common.primitives.Primitives[JavaMethodDescriptor]
Inferred types:
    <T : (Any..Any?)> -> (kotlin.Any..kotlin.Any?)

'value' @ [131:42] ==> value-parameter value: Any defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.parameterAssignableFrom[ValueParameterDescriptorImpl]

'javaClass' @ [131:48] ==> public val <T : Any> (Any..Any?).javaClass: Class<(Any..Any?)> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> (kotlin.Any..kotlin.Any?)

'type' @ [131:62] ==> value-parameter type: Type defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.parameterAssignableFrom[ValueParameterDescriptorImpl]

'type' @ [133:24] ==> value-parameter type: Type defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.parameterAssignableFrom[ValueParameterDescriptorImpl]

'isAssignableFrom' @ [133:29] ==> public open fun isAssignableFrom(p0: (Class<*>..Class<*>?)): Boolean defined in java.lang.Class[JavaMethodDescriptor]

'value' @ [133:46] ==> value-parameter value: Any defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.parameterAssignableFrom[ValueParameterDescriptorImpl]

'javaClass' @ [133:52] ==> public val <T : Any> Any.javaClass: Class<Any> defined in kotlin.jvm[DeserializedPropertyDescriptor]
Inferred types:
    <T : Any> -> Any

'if (type is ParameterizedType) {
            return parameterAssignableFrom(type.rawType, value)
        } else {
            return false
        }' @ [135:16] ==> public final fun <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> `<SPECIAL-FUNCTION-FOR-IF-RESOLVE>`(thenBranch: Nothing, elseBranch: Nothing): Nothing[SimpleFunctionDescriptorImpl]
Inferred types:
    <`<TYPE-PARAMETER-FOR-IF-RESOLVE>`> -> Nothing

'type' @ [135:20] ==> value-parameter type: Type defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.parameterAssignableFrom[ValueParameterDescriptorImpl]

'parameterAssignableFrom' @ [136:20] ==> private final fun parameterAssignableFrom(type: Type, value: Any): Boolean defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl[SimpleFunctionDescriptorImpl]

'type' @ [136:44] ==> value-parameter type: Type defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.parameterAssignableFrom[ValueParameterDescriptorImpl]

'rawType' @ [136:49] ==> public final val ParameterizedType.rawType: (Type..Type?)[MyPropertyDescriptor]

'value' @ [136:58] ==> value-parameter value: Any defined in net.corda.node.services.statemachine.FlowLogicRefFactoryImpl.parameterAssignableFrom[ValueParameterDescriptorImpl]

